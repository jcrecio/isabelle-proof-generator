{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/J/Threaded.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma wset_Suspend_ok_start_state:\n  fixes final r convert_RA\n  assumes \"start_state f P C M vs \\<in> I\"\n  shows \"start_state f P C M vs \\<in> multithreaded_base.wset_Suspend_ok final r convert_RA I\"", "lemma final_locks: \"final e \\<Longrightarrow> expr_locks e l = 0\"", "lemma red_new_thread_heap:\n  \"\\<lbrakk> convert_extTA extNTA,P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; NewThread t'' ex'' h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk> \\<Longrightarrow> h'' = hp s'\"\n  and reds_new_thread_heap:\n  \"\\<lbrakk> convert_extTA extNTA,P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; NewThread t'' ex'' h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk> \\<Longrightarrow> h'' = hp s'\"", "lemma red_ta_Wakeup_no_Join_no_Lock_no_Interrupt:\n  \"\\<lbrakk> convert_extTA extNTA,P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or> WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = {} \\<and> collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> = {} \\<and> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> = {}\"\n  and reds_ta_Wakeup_no_Join_no_Lock_no_Interrupt:\n  \"\\<lbrakk> convert_extTA extNTA,P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or> WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = {} \\<and> collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> = {} \\<and> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> = {}\"", "lemma final_no_red:\n  \"final e \\<Longrightarrow> \\<not> P,t \\<turnstile> \\<langle>e, (h, l)\\<rangle> -ta\\<rightarrow> \\<langle>e', (h', l')\\<rangle>\"", "lemma red_mthr: \"multithreaded final_expr (mred P)\"", "lemma redT_hext_incr:\n  \"P \\<turnstile> s -t\\<triangleright>ta\\<rightarrow> s' \\<Longrightarrow> shr s \\<unlhd> shr s'\"", "lemma RedT_hext_incr:\n  assumes \"P \\<turnstile> s -\\<triangleright>tta\\<rightarrow>* s'\"\n  shows \"shr s \\<unlhd> shr s'\"", "lemma red_NewThread_Thread_Object:\n  \"\\<lbrakk> convert_extTA extNTA,P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; NewThread t' x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk> \n  \\<Longrightarrow> \\<exists>C. typeof_addr (hp s') (thread_id2addr t') = \\<lfloor>Class_type C\\<rfloor> \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* Thread\"\n  and reds_NewThread_Thread_Object:\n  \"\\<lbrakk> convert_extTA extNTA,P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; NewThread t' x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> \\<exists>C. typeof_addr (hp s') (thread_id2addr t') = \\<lfloor>Class_type C\\<rfloor> \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* Thread\"", "lemma lifting_wf_tconf:\n  \"lifting_wf final_expr (mred P) (\\<lambda>t ex h. P,h \\<turnstile> t \\<surd>t)\"", "lemma sync_oks_append [simp]:\n  \"sync_oks (xs @ ys) \\<longleftrightarrow> sync_oks xs \\<and> sync_oks ys \\<and> (contains_insyncs ys \\<longrightarrow> (\\<exists>vs. xs = map Val vs))\"", "lemma fixes e :: \"('a,'b,'addr) exp\" and es :: \"('a,'b,'addr) exp list\"\n  shows not_contains_insync_sync_ok: \"\\<not> contains_insync e \\<Longrightarrow> sync_ok e\"\n  and not_contains_insyncs_sync_oks: \"\\<not> contains_insyncs es \\<Longrightarrow> sync_oks es\"", "lemma expr_locks_sync_ok: \"(\\<And>ad. expr_locks e ad = 0) \\<Longrightarrow> sync_ok e\"\n  and expr_lockss_sync_oks: \"(\\<And>ad. expr_lockss es ad = 0) \\<Longrightarrow> sync_oks es\"", "lemma sync_ok_extRet2J [simp, intro!]: \"sync_ok e \\<Longrightarrow> sync_ok (extRet2J e va)\"", "lemma sync_es_ok_blocks [simp]:\n  \"\\<lbrakk> length pns = length Ts; length Ts = length vs \\<rbrakk> \\<Longrightarrow> sync_ok (blocks pns Ts vs e) = sync_ok e\"", "lemma assumes wf: \"wf_J_prog P\"\n  shows red_preserve_sync_ok: \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; sync_ok e \\<rbrakk> \\<Longrightarrow> sync_ok e'\"\n  and reds_preserve_sync_oks: \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; sync_oks es \\<rbrakk> \\<Longrightarrow> sync_oks es'\"", "lemma assumes wf: \"wf_J_prog P\"\n  shows expr_locks_new_thread:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; NewThread t'' (e'', x'') h \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk> \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\"\n\n  and expr_locks_new_thread':\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; NewThread t'' (e'', x'') h \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk> \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\"", "lemma assumes wf: \"wf_J_prog P\"\n  shows red_new_thread_sync_ok: \"\\<lbrakk> P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; NewThread t'' (e'', x'') h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk> \\<Longrightarrow> sync_ok e''\"\n  and reds_new_thread_sync_ok: \"\\<lbrakk> P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; NewThread t'' (e'', x'') h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk> \\<Longrightarrow> sync_ok e''\"", "lemma lifting_wf_sync_ok: \"wf_J_prog P \\<Longrightarrow> lifting_wf final_expr (mred P) (\\<lambda>t (e, x) m. sync_ok e)\"", "lemma redT_preserve_sync_ok:\n  assumes red: \"P \\<turnstile> s -t\\<triangleright>ta\\<rightarrow> s'\"\n  shows \"\\<lbrakk> wf_J_prog P; sync_es_ok (thr s) (shr s) \\<rbrakk> \\<Longrightarrow> sync_es_ok (thr s') (shr s')\"", "lemma RedT_preserves_sync_ok:\n  \"\\<lbrakk>wf_J_prog P; P \\<turnstile> s -\\<triangleright>ttas\\<rightarrow>* s'; sync_es_ok (thr s) (shr s)\\<rbrakk>\n   \\<Longrightarrow> sync_es_ok (thr s') (shr s')\"", "lemma sync_es_ok_J_start_state:\n  \"\\<lbrakk> wf_J_prog P; P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(pns, body)\\<rfloor> in D; length Ts = length vs \\<rbrakk>\n  \\<Longrightarrow> sync_es_ok (thr (J_start_state P C M vs)) m\"", "lemma lock_okI:\n  \"\\<lbrakk> \\<And>t l. ts t = None \\<Longrightarrow> has_locks (ls $ l) t = 0; \\<And>t e x ln l. ts t = \\<lfloor>((e, x), ln)\\<rfloor> \\<Longrightarrow> has_locks (ls $ l) t + ln $ l= expr_locks e l \\<rbrakk> \\<Longrightarrow> lock_ok ls ts\"", "lemma lock_okE:\n  \"\\<lbrakk> lock_ok ls ts;\n     \\<forall>t. ts t = None \\<longrightarrow> (\\<forall>l. has_locks (ls $ l) t = 0) \\<Longrightarrow> Q;\n     \\<forall>t e x ln. ts t = \\<lfloor>((e, x), ln)\\<rfloor> \\<longrightarrow> (\\<forall>l. has_locks (ls $ l) t + ln $ l = expr_locks e l) \\<Longrightarrow> Q \\<rbrakk>\n  \\<Longrightarrow> Q\"", "lemma lock_okD1:\n  \"\\<lbrakk> lock_ok ls ts; ts t = None \\<rbrakk> \\<Longrightarrow> \\<forall>l. has_locks (ls $ l) t = 0\"", "lemma lock_okD2:\n  \"\\<And>ln. \\<lbrakk> lock_ok ls ts; ts t = \\<lfloor>((e, x), ln)\\<rfloor> \\<rbrakk> \\<Longrightarrow> \\<forall>l. has_locks (ls $ l) t + ln $ l = expr_locks e l\"", "lemma lock_ok_lock_thread_ok:\n  assumes lock: \"lock_ok ls ts\"\n  shows \"lock_thread_ok ls ts\"", "lemma (in J_heap_base) lock_ok_J_start_state:\n  \"\\<lbrakk> wf_J_prog P; P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(pns, body)\\<rfloor> in D; length Ts = length vs \\<rbrakk>\n  \\<Longrightarrow> lock_ok (locks (J_start_state P C M vs)) (thr (J_start_state P C M vs))\"", "lemma upd_expr_lock_actions_append [simp]:\n  \"upd_expr_lock_actions n (Ls @ Ls') = upd_expr_lock_actions (upd_expr_lock_actions n Ls) Ls'\"", "lemma upd_expr_locks_iff [simp]:\n  \"upd_expr_locks els las l = upd_expr_lock_actions (els l) (las $ l)\"", "lemma upd_expr_lock_action_add [simp]:\n  \"upd_expr_lock_action (l + l') L = upd_expr_lock_action l L + l'\"", "lemma upd_expr_lock_actions_add [simp]:\n  \"upd_expr_lock_actions (l + l') Ls = upd_expr_lock_actions l Ls + l'\"", "lemma upd_expr_locks_add [simp]:\n  \"upd_expr_locks (\\<lambda>a. x a + y a) las = (\\<lambda>a. upd_expr_locks x las a + y a)\"", "lemma expr_locks_extRet2J [simp, intro!]: \"expr_locks e = (\\<lambda>ad. 0) \\<Longrightarrow> expr_locks (extRet2J e va) = (\\<lambda>ad. 0)\"", "lemma (in J_heap_base)\n  assumes wf: \"wf_J_prog P\"\n  shows red_update_expr_locks:\n  \"\\<lbrakk> convert_extTA extNTA,P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; sync_ok e \\<rbrakk> \n  \\<Longrightarrow> upd_expr_locks (int o expr_locks e) \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = int o expr_locks e'\"\n  and reds_update_expr_lockss:\n  \"\\<lbrakk> convert_extTA extNTA,P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; sync_oks es \\<rbrakk>\n  \\<Longrightarrow> upd_expr_locks (int o expr_lockss es) \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = int o expr_lockss es'\"", "lemma upd_lock_upd_expr_lock_action_preserve_lock_expr_locks_ok:\n  assumes lao: \"lock_action_ok l t L\"\n  and lelo: \"lock_expr_locks_ok l t n i\"\n  shows \"lock_expr_locks_ok (upd_lock l t L) t (upd_threadR n l t L) (upd_expr_lock_action i L)\"", "lemma upd_locks_upd_expr_lock_preserve_lock_expr_locks_ok:\n  \"\\<lbrakk> lock_actions_ok l t Ls; lock_expr_locks_ok l t n i \\<rbrakk>\n  \\<Longrightarrow> lock_expr_locks_ok (upd_locks l t Ls) t (upd_threadRs n l t Ls) (upd_expr_lock_actions i Ls)\"", "lemma ls_els_okI:\n  \"\\<And>ln. (\\<And>l. lock_expr_locks_ok (ls $ l) t (ln $ l) (els l)) \\<Longrightarrow> ls_els_ok ls t ln els\"", "lemma ls_els_okE:\n  \"\\<And>ln. \\<lbrakk> ls_els_ok ls t ln els; \\<forall>l. lock_expr_locks_ok (ls $ l) t (ln $ l) (els l) \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma ls_els_okD:\n  \"\\<And>ln. ls_els_ok ls t ln els \\<Longrightarrow> lock_expr_locks_ok (ls $ l) t (ln $ l) (els l)\"", "lemma redT_updLs_upd_expr_locks_preserves_ls_els_ok:  \n \"\\<And>ln. \\<lbrakk> ls_els_ok ls t ln els; lock_ok_las ls t las \\<rbrakk>\n  \\<Longrightarrow> ls_els_ok (redT_updLs ls t las) t (redT_updLns ls t ln las) (upd_expr_locks els las)\"", "lemma sync_ok_redT_updT: \n  assumes \"sync_es_ok ts h\"\n  and nt: \"\\<And>t e x h''. ta = NewThread t (e, x) h'' \\<Longrightarrow> sync_ok e\"\n  shows \"sync_es_ok (redT_updT ts ta) h'\"", "lemma sync_ok_redT_updTs: \n  \"\\<lbrakk> sync_es_ok ts h; \\<And>t e x h. NewThread t (e, x) h \\<in> set tas \\<Longrightarrow> sync_ok e \\<rbrakk>\n  \\<Longrightarrow> sync_es_ok (redT_updTs ts tas) h'\"", "lemma lock_ok_thr_updI:\n  \"\\<And>ln. \\<lbrakk> lock_ok ls ts; ts t = \\<lfloor>((e, xs), ln)\\<rfloor>; expr_locks e = expr_locks e' \\<rbrakk>\n  \\<Longrightarrow> lock_ok ls (ts(t \\<mapsto> ((e', xs'), ln)))\"", "lemma redT_preserves_lock_ok:\n  assumes wf: \"wf_J_prog P\"\n  and \"P \\<turnstile> s -t\\<triangleright>ta\\<rightarrow> s'\"\n  and \"lock_ok (locks s) (thr s)\"\n  and \"sync_es_ok (thr s) (shr s)\"\n  shows \"lock_ok (locks s') (thr s')\"", "lemma invariant3p_sync_es_ok_lock_ok:\n  assumes wf: \"wf_J_prog P\"\n  shows \"invariant3p (mredT P) {s. sync_es_ok (thr s) (shr s) \\<and> lock_ok (locks s) (thr s)}\"", "lemma RedT_preserves_lock_ok:\n  assumes wf: \"wf_J_prog P\"\n  and Red: \"P \\<turnstile> s -\\<triangleright>ttas\\<rightarrow>* s'\"\n  and ae: \"sync_es_ok (thr s) (shr s)\"\n  and loes: \"lock_ok (locks s) (thr s)\"\n  shows \"lock_ok (locks s') (thr s')\"", "lemma\n  fixes final\n  assumes det: \"deterministic_heap_ops\"\n  shows red_deterministic:\n  \"\\<lbrakk> convert_extTA extTA,P,t \\<turnstile> \\<langle>e, (shr s, xs)\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; \n     convert_extTA extTA,P,t \\<turnstile> \\<langle>e, (shr s, xs)\\<rangle> -ta'\\<rightarrow> \\<langle>e'', s''\\<rangle>;\n     final_thread.actions_ok final s t ta; final_thread.actions_ok final s t ta' \\<rbrakk> \n  \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s''\"\n  and reds_deterministic:\n  \"\\<lbrakk> convert_extTA extTA,P,t \\<turnstile> \\<langle>es, (shr s, xs)\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; \n     convert_extTA extTA,P,t \\<turnstile> \\<langle>es, (shr s, xs)\\<rangle> [-ta'\\<rightarrow>] \\<langle>es'', s''\\<rangle>;\n     final_thread.actions_ok final s t ta; final_thread.actions_ok final s t ta' \\<rbrakk> \n  \\<Longrightarrow> ta = ta' \\<and> es' = es'' \\<and> s' = s''\"", "lemma red_mthr_deterministic:\n  assumes det: \"deterministic_heap_ops\"\n  shows \"red_mthr.deterministic P UNIV\""], "translations": [["", "lemma wset_Suspend_ok_start_state:\n  fixes final r convert_RA\n  assumes \"start_state f P C M vs \\<in> I\"\n  shows \"start_state f P C M vs \\<in> multithreaded_base.wset_Suspend_ok final r convert_RA I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. start_state f P C M vs\n    \\<in> multithreaded_base.wset_Suspend_ok final r convert_RA I", "using assms"], ["proof (prove)\nusing this:\n  start_state f P C M vs \\<in> I\n\ngoal (1 subgoal):\n 1. start_state f P C M vs\n    \\<in> multithreaded_base.wset_Suspend_ok final r convert_RA I", "by(rule multithreaded_base.wset_Suspend_okI)(simp add: start_state_def split_beta)"], ["", "end"], ["", "abbreviation final_expr :: \"'addr expr \\<times> 'addr locals \\<Rightarrow> bool\"where\n  \"final_expr \\<equiv> \\<lambda>(e, x). final e\""], ["", "lemma final_locks: \"final e \\<Longrightarrow> expr_locks e l = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final e \\<Longrightarrow> expr_locks e l = 0", "by(auto elim: finalE)"], ["", "context J_heap_base begin"], ["", "abbreviation mred\n  :: \"'addr J_prog \\<Rightarrow> ('addr, 'thread_id, 'addr expr \\<times> 'addr locals, 'heap, 'addr, ('addr, 'thread_id) obs_event) semantics\"\nwhere\n  \"mred P t \\<equiv> (\\<lambda>((e, l), h)  ta ((e', l'), h'). P,t \\<turnstile> \\<langle>e, (h, l)\\<rangle> -ta\\<rightarrow> \\<langle>e', (h', l')\\<rangle>)\""], ["", "lemma red_new_thread_heap:\n  \"\\<lbrakk> convert_extTA extNTA,P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; NewThread t'' ex'' h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk> \\<Longrightarrow> h'' = hp s'\"\n  and reds_new_thread_heap:\n  \"\\<lbrakk> convert_extTA extNTA,P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; NewThread t'' ex'' h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk> \\<Longrightarrow> h'' = hp s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>convert_extTA\n               extNTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n      NewThread t'' ex'' h''\n      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n     \\<Longrightarrow> h'' = hp s') &&&\n    (\\<lbrakk>convert_extTA\n               extNTA,P,t \\<turnstile> \\<langle>es,\n  s\\<rangle> [-ta\\<rightarrow>]\n \\<langle>es',s'\\<rangle>;\n      NewThread t'' ex'' h''\n      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n     \\<Longrightarrow> h'' = hp s')", "apply(induct rule: red_reds.inducts)"], ["proof (prove)\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        NewThread t'' ex'' h''\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Class_type\n C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> h'' = hp (h', l)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        NewThread t'' ex'' h''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> h'' = hp (h, l)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>convert_extTA\n                 extNTA,P,t \\<turnstile> \\<langle>e,\n    s\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n        NewThread t'' ex'' h''\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        h'' = hp s';\n        NewThread t'' ex'' h''\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> h'' = hp s'\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        NewThread t'' ex'' h''\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Array_type T\n (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> h'' = hp (h', l)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        NewThread t'' ex'' h''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> h'' = hp s\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        NewThread t'' ex'' h''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> h'' = hp (h, l)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>convert_extTA\n                 extNTA,P,t \\<turnstile> \\<langle>e,\n    s\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n        NewThread t'' ex'' h''\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        h'' = hp s';\n        NewThread t'' ex'' h''\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> h'' = hp s'\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        NewThread t'' ex'' h''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> h'' = hp s\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        NewThread t'' ex'' h''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> h'' = hp s\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>convert_extTA\n                  extNTA,P,t \\<turnstile> \\<langle>e,\n     s\\<rangle> -ta\\<rightarrow>\n    \\<langle>e',s'\\<rangle>;\n         NewThread t'' ex'' h''\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n         h'' = hp s';\n         NewThread t'' ex'' h''\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> h'' = hp s'\nA total of 98 subgoals...", "apply(fastforce dest: red_ext_new_thread_heap simp add: ta_upd_simps)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma red_ta_Wakeup_no_Join_no_Lock_no_Interrupt:\n  \"\\<lbrakk> convert_extTA extNTA,P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or> WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = {} \\<and> collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> = {} \\<and> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> = {}\"\n  and reds_ta_Wakeup_no_Join_no_Lock_no_Interrupt:\n  \"\\<lbrakk> convert_extTA extNTA,P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or> WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = {} \\<and> collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> = {} \\<and> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>convert_extTA\n               extNTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n      Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n      WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n     \\<Longrightarrow> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                       {} \\<and>\n                       collect_cond_actions\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                       {} \\<and>\n                       collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                       {}) &&&\n    (\\<lbrakk>convert_extTA\n               extNTA,P,t \\<turnstile> \\<langle>es,\n  s\\<rangle> [-ta\\<rightarrow>]\n \\<langle>es',s'\\<rangle>;\n      Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n      WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n     \\<Longrightarrow> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                       {} \\<and>\n                       collect_cond_actions\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                       {} \\<and>\n                       collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                       {})", "apply(induct rule: red_reds.inducts)"], ["proof (prove)\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        Notified\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Class_type\n C)\\<rbrace>\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Class_type\n C)\\<rbrace>\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_locks\n                          \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         {} \\<and>\n                         collect_cond_actions\n                          \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> =\n                         {} \\<and>\n                         collect_interrupts\n                          \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> =\n                         {}\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        Notified\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_locks\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         {} \\<and>\n                         collect_cond_actions\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> =\n                         {} \\<and>\n                         collect_interrupts\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> =\n                         {}\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>convert_extTA\n                 extNTA,P,t \\<turnstile> \\<langle>e,\n    s\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<Longrightarrow>\n        collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = {} \\<and>\n        collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n        {} \\<and>\n        collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> = {};\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_locks\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         {} \\<and>\n                         collect_cond_actions\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                         {} \\<and>\n                         collect_interrupts\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                         {}\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        Notified\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Array_type T\n (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Array_type T\n (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_locks\n                          \\<lbrace>\\<lbrace>NewHeapElem a\n       (Array_type T (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         {} \\<and>\n                         collect_cond_actions\n                          \\<lbrace>\\<lbrace>NewHeapElem a\n       (Array_type T (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> =\n                         {} \\<and>\n                         collect_interrupts\n                          \\<lbrace>\\<lbrace>NewHeapElem a\n       (Array_type T (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> =\n                         {}\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        Notified\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_locks\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         {} \\<and>\n                         collect_cond_actions\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> =\n                         {} \\<and>\n                         collect_interrupts\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> =\n                         {}\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        Notified\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_locks\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         {} \\<and>\n                         collect_cond_actions\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> =\n                         {} \\<and>\n                         collect_interrupts\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> =\n                         {}\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>convert_extTA\n                 extNTA,P,t \\<turnstile> \\<langle>e,\n    s\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<Longrightarrow>\n        collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = {} \\<and>\n        collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n        {} \\<and>\n        collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> = {};\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_locks\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         {} \\<and>\n                         collect_cond_actions\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                         {} \\<and>\n                         collect_interrupts\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                         {}\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        Notified\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_locks\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         {} \\<and>\n                         collect_cond_actions\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> =\n                         {} \\<and>\n                         collect_interrupts\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> =\n                         {}\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        Notified\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_locks\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         {} \\<and>\n                         collect_cond_actions\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> =\n                         {} \\<and>\n                         collect_interrupts\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> =\n                         {}\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>convert_extTA\n                  extNTA,P,t \\<turnstile> \\<langle>e,\n     s\\<rangle> -ta\\<rightarrow>\n    \\<langle>e',s'\\<rangle>;\n         Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n         WokenUp\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<Longrightarrow>\n         collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = {} \\<and>\n         collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n         {} \\<and>\n         collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> = {};\n         Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n         WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> collect_locks\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                          {} \\<and>\n                          collect_cond_actions\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                          {} \\<and>\n                          collect_interrupts\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                          {}\nA total of 98 subgoals...", "apply(auto simp add: ta_upd_simps dest: red_external_Wakeup_no_Join_no_Lock_no_Interrupt del: conjI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma final_no_red:\n  \"final e \\<Longrightarrow> \\<not> P,t \\<turnstile> \\<langle>e, (h, l)\\<rangle> -ta\\<rightarrow> \\<langle>e', (h', l')\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final e \\<Longrightarrow>\n    \\<not> extTA2J\n            P,P,t \\<turnstile> \\<langle>e,(h, l)\\<rangle> -ta\\<rightarrow>\n                               \\<langle>e',(h', l')\\<rangle>", "by(auto elim: red.cases finalE)"], ["", "lemma red_mthr: \"multithreaded final_expr (mred P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multithreaded final_expr\n     (\\<lambda>t ((e, l), h) ta ((e', l'), h').\n         extTA2J\n          P,P,t \\<turnstile> \\<langle>e,(h, l)\\<rangle> -ta\\<rightarrow>\n                             \\<langle>e',(h', l')\\<rangle>)", "by(unfold_locales)(auto dest: red_new_thread_heap)"], ["", "end"], ["", "sublocale J_heap_base < red_mthr: multithreaded\n  \"final_expr\"\n  \"mred P\"\n  convert_RA\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. multithreaded final_expr\n     (\\<lambda>t ((e, l), h) ta ((e', l'), h').\n         extTA2J\n          P,P,t \\<turnstile> \\<langle>e,(h, l)\\<rangle> -ta\\<rightarrow>\n                             \\<langle>e',(h', l')\\<rangle>)", "by(rule red_mthr)"], ["", "context J_heap_base begin"], ["", "abbreviation\n  mredT :: \n  \"'addr J_prog \\<Rightarrow> ('addr,'thread_id,'addr expr \\<times> 'addr locals,'heap,'addr) state\n  \\<Rightarrow> ('thread_id \\<times> ('addr, 'thread_id, 'addr expr \\<times> 'addr locals,'heap) Jinja_thread_action) \n  \\<Rightarrow> ('addr,'thread_id,'addr expr \\<times> 'addr locals,'heap,'addr) state \\<Rightarrow> bool\"\nwhere\n  \"mredT P \\<equiv> red_mthr.redT P\""], ["", "abbreviation\n  mredT_syntax1 :: \"'addr J_prog \\<Rightarrow> ('addr,'thread_id,'addr expr \\<times> 'addr locals,'heap,'addr) state\n                  \\<Rightarrow> 'thread_id \\<Rightarrow> ('addr, 'thread_id, 'addr expr \\<times> 'addr locals,'heap) Jinja_thread_action\n                  \\<Rightarrow> ('addr,'thread_id,'addr expr \\<times> 'addr locals,'heap,'addr) state \\<Rightarrow> bool\"\n                    (\"_ \\<turnstile> _ -_\\<triangleright>_\\<rightarrow> _\" [50,0,0,0,50] 80)\nwhere\n  \"mredT_syntax1 P s t ta s' \\<equiv> mredT P s (t, ta) s'\""], ["", "abbreviation\n  mRedT_syntax1 :: \n  \"'addr J_prog\n  \\<Rightarrow> ('addr,'thread_id,'addr expr \\<times> 'addr locals,'heap,'addr) state\n  \\<Rightarrow> ('thread_id \\<times> ('addr, 'thread_id, 'addr expr \\<times> 'addr locals,'heap) Jinja_thread_action) list\n  \\<Rightarrow> ('addr,'thread_id,'addr expr \\<times> 'addr locals,'heap,'addr) state \\<Rightarrow> bool\"\n  (\"_ \\<turnstile> _ -\\<triangleright>_\\<rightarrow>* _\" [50,0,0,50] 80)\nwhere\n  \"P \\<turnstile> s -\\<triangleright>ttas\\<rightarrow>* s' \\<equiv> red_mthr.RedT P s ttas s'\""], ["", "end"], ["", "context J_heap begin"], ["", "lemma redT_hext_incr:\n  \"P \\<turnstile> s -t\\<triangleright>ta\\<rightarrow> s' \\<Longrightarrow> shr s \\<unlhd> shr s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> s -t\\<triangleright>ta\\<rightarrow> s' \\<Longrightarrow>\n    shr s \\<unlhd> shr s'", "by(erule red_mthr.redT.cases)(auto dest!: red_hext_incr intro: hext_trans)"], ["", "lemma RedT_hext_incr:\n  assumes \"P \\<turnstile> s -\\<triangleright>tta\\<rightarrow>* s'\"\n  shows \"shr s \\<unlhd> shr s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shr s \\<unlhd> shr s'", "using assms"], ["proof (prove)\nusing this:\n  P \\<turnstile> s -\\<triangleright>tta\\<rightarrow>* s'\n\ngoal (1 subgoal):\n 1. shr s \\<unlhd> shr s'", "unfolding red_mthr.RedT_def"], ["proof (prove)\nusing this:\n  rtrancl3p (mredT P) s tta s'\n\ngoal (1 subgoal):\n 1. shr s \\<unlhd> shr s'", "by(induct)(auto dest: redT_hext_incr intro: hext_trans)"], ["", "end"], ["", "subsection \\<open>Lifting @{term \"tconf\"} to multithreaded states\\<close>"], ["", "context J_heap begin"], ["", "lemma red_NewThread_Thread_Object:\n  \"\\<lbrakk> convert_extTA extNTA,P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; NewThread t' x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk> \n  \\<Longrightarrow> \\<exists>C. typeof_addr (hp s') (thread_id2addr t') = \\<lfloor>Class_type C\\<rfloor> \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* Thread\"\n  and reds_NewThread_Thread_Object:\n  \"\\<lbrakk> convert_extTA extNTA,P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; NewThread t' x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> \\<exists>C. typeof_addr (hp s') (thread_id2addr t') = \\<lfloor>Class_type C\\<rfloor> \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* Thread\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>convert_extTA\n               extNTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n      NewThread t' x m\n      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n     \\<Longrightarrow> \\<exists>C.\n                          typeof_addr (hp s') (thread_id2addr t') =\n                          \\<lfloor>Class_type C\\<rfloor> \\<and>\n                          P \\<turnstile> C \\<preceq>\\<^sup>* Thread) &&&\n    (\\<lbrakk>convert_extTA\n               extNTA,P,t \\<turnstile> \\<langle>es,\n  s\\<rangle> [-ta\\<rightarrow>]\n \\<langle>es',s'\\<rangle>;\n      NewThread t' x m\n      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n     \\<Longrightarrow> \\<exists>C.\n                          typeof_addr (hp s') (thread_id2addr t') =\n                          \\<lfloor>Class_type C\\<rfloor> \\<and>\n                          P \\<turnstile> C \\<preceq>\\<^sup>* Thread)", "apply(induct rule: red_reds.inducts)"], ["proof (prove)\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        NewThread t' x m\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Class_type\n C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            typeof_addr (hp (h', l)) (thread_id2addr t') =\n                            \\<lfloor>Class_type C\\<rfloor> \\<and>\n                            P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        NewThread t' x m\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            typeof_addr (hp (h, l)) (thread_id2addr t') =\n                            \\<lfloor>Class_type C\\<rfloor> \\<and>\n                            P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>convert_extTA\n                 extNTA,P,t \\<turnstile> \\<langle>e,\n    s\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n        NewThread t' x m\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        \\<exists>C.\n           typeof_addr (hp s') (thread_id2addr t') =\n           \\<lfloor>Class_type C\\<rfloor> \\<and>\n           P \\<turnstile> C \\<preceq>\\<^sup>* Thread;\n        NewThread t' x m\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            typeof_addr (hp s') (thread_id2addr t') =\n                            \\<lfloor>Class_type C\\<rfloor> \\<and>\n                            P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        NewThread t' x m\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Array_type T\n (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            typeof_addr (hp (h', l)) (thread_id2addr t') =\n                            \\<lfloor>Class_type C\\<rfloor> \\<and>\n                            P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        NewThread t' x m\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            typeof_addr (hp s) (thread_id2addr t') =\n                            \\<lfloor>Class_type C\\<rfloor> \\<and>\n                            P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        NewThread t' x m\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            typeof_addr (hp (h, l)) (thread_id2addr t') =\n                            \\<lfloor>Class_type C\\<rfloor> \\<and>\n                            P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>convert_extTA\n                 extNTA,P,t \\<turnstile> \\<langle>e,\n    s\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n        NewThread t' x m\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        \\<exists>C.\n           typeof_addr (hp s') (thread_id2addr t') =\n           \\<lfloor>Class_type C\\<rfloor> \\<and>\n           P \\<turnstile> C \\<preceq>\\<^sup>* Thread;\n        NewThread t' x m\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            typeof_addr (hp s') (thread_id2addr t') =\n                            \\<lfloor>Class_type C\\<rfloor> \\<and>\n                            P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        NewThread t' x m\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            typeof_addr (hp s) (thread_id2addr t') =\n                            \\<lfloor>Class_type C\\<rfloor> \\<and>\n                            P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        NewThread t' x m\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            typeof_addr (hp s) (thread_id2addr t') =\n                            \\<lfloor>Class_type C\\<rfloor> \\<and>\n                            P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>convert_extTA\n                  extNTA,P,t \\<turnstile> \\<langle>e,\n     s\\<rangle> -ta\\<rightarrow>\n    \\<langle>e',s'\\<rangle>;\n         NewThread t' x m\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n         \\<exists>C.\n            typeof_addr (hp s') (thread_id2addr t') =\n            \\<lfloor>Class_type C\\<rfloor> \\<and>\n            P \\<turnstile> C \\<preceq>\\<^sup>* Thread;\n         NewThread t' x m\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>C.\n                             typeof_addr (hp s') (thread_id2addr t') =\n                             \\<lfloor>Class_type C\\<rfloor> \\<and>\n                             P \\<turnstile> C \\<preceq>\\<^sup>* Thread\nA total of 98 subgoals...", "apply(fastforce dest: red_external_new_thread_exists_thread_object simp add: ta_upd_simps)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lifting_wf_tconf:\n  \"lifting_wf final_expr (mred P) (\\<lambda>t ex h. P,h \\<turnstile> t \\<surd>t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lifting_wf final_expr\n     (\\<lambda>t ((e, l), h) ta ((e', l'), h').\n         extTA2J\n          P,P,t \\<turnstile> \\<langle>e,(h, l)\\<rangle> -ta\\<rightarrow>\n                             \\<langle>e',(h', l')\\<rangle>)\n     (\\<lambda>t ex h. P,h \\<turnstile> t \\<surd>t)", "by(unfold_locales)(fastforce dest: red_hext_incr red_NewThread_Thread_Object elim!: tconf_hext_mono intro: tconfI)+"], ["", "end"], ["", "sublocale J_heap < red_tconf: lifting_wf final_expr \"mred P\" convert_RA \"\\<lambda>t ex h. P,h \\<turnstile> t \\<surd>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lifting_wf final_expr\n     (\\<lambda>t ((e, l), h) ta ((e', l'), h').\n         extTA2J\n          P,P,t \\<turnstile> \\<langle>e,(h, l)\\<rangle> -ta\\<rightarrow>\n                             \\<langle>e',(h', l')\\<rangle>)\n     (\\<lambda>t ex h. P,h \\<turnstile> t \\<surd>t)", "by(rule lifting_wf_tconf)"], ["", "subsection \\<open>Towards agreement between the framework semantics' lock state and the locks stored in the expressions\\<close>"], ["", "primrec sync_ok :: \"('a,'b,'addr) exp \\<Rightarrow> bool\"\n  and sync_oks :: \"('a,'b,'addr) exp list \\<Rightarrow> bool\"\nwhere\n  \"sync_ok (new C) = True\"\n| \"sync_ok (newA T\\<lfloor>i\\<rceil>) = sync_ok i\"\n| \"sync_ok (Cast T e) = sync_ok e\"\n| \"sync_ok (e instanceof T) = sync_ok e\"\n| \"sync_ok (Val v) = True\"\n| \"sync_ok (Var v) = True\"\n| \"sync_ok (e \\<guillemotleft>bop\\<guillemotright> e') = (sync_ok e \\<and> sync_ok e' \\<and> (contains_insync e' \\<longrightarrow> is_val e))\"\n| \"sync_ok (V := e) = sync_ok e\"\n| \"sync_ok (a\\<lfloor>i\\<rceil>) = (sync_ok a \\<and> sync_ok i \\<and> (contains_insync i \\<longrightarrow> is_val a))\"\n| \"sync_ok (AAss a i e) = (sync_ok a \\<and> sync_ok i \\<and> sync_ok e \\<and> (contains_insync i \\<longrightarrow> is_val a) \\<and> (contains_insync e \\<longrightarrow> is_val a \\<and> is_val i))\"\n| \"sync_ok (a\\<bullet>length) = sync_ok a\"\n| \"sync_ok (e\\<bullet>F{D}) = sync_ok e\"\n| \"sync_ok (FAss e F D e') = (sync_ok e \\<and> sync_ok e' \\<and> (contains_insync e' \\<longrightarrow> is_val e))\"\n| \"sync_ok (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) = (sync_ok e \\<and> sync_ok e' \\<and> sync_ok e'' \\<and> (contains_insync e' \\<longrightarrow> is_val e) \\<and> (contains_insync e'' \\<longrightarrow> is_val e \\<and> is_val e'))\"\n| \"sync_ok (e\\<bullet>m(pns)) = (sync_ok e \\<and> sync_oks pns \\<and> (contains_insyncs pns \\<longrightarrow> is_val e))\"\n| \"sync_ok ({V : T=vo; e}) = sync_ok e\"\n| \"sync_ok (sync\\<^bsub>V\\<^esub> (o') e) = (sync_ok o' \\<and> \\<not> contains_insync e)\"\n| \"sync_ok (insync\\<^bsub>V\\<^esub> (a) e) = sync_ok e\"\n| \"sync_ok (e;;e') = (sync_ok e \\<and> \\<not> contains_insync e')\"\n| \"sync_ok (if (b) e else e') = (sync_ok b \\<and> \\<not> contains_insync e \\<and> \\<not> contains_insync e')\"\n| \"sync_ok (while (b) e) = (\\<not> contains_insync b \\<and> \\<not> contains_insync e)\"\n| \"sync_ok (throw e) = sync_ok e\"\n| \"sync_ok (try e catch(C v) e') = (sync_ok e \\<and> \\<not> contains_insync e')\"\n| \"sync_oks [] = True\"\n| \"sync_oks (x # xs) = (sync_ok x \\<and> sync_oks xs \\<and> (contains_insyncs xs \\<longrightarrow> is_val x))\""], ["", "lemma sync_oks_append [simp]:\n  \"sync_oks (xs @ ys) \\<longleftrightarrow> sync_oks xs \\<and> sync_oks ys \\<and> (contains_insyncs ys \\<longrightarrow> (\\<exists>vs. xs = map Val vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sync_oks (xs @ ys) =\n    (sync_oks xs \\<and>\n     sync_oks ys \\<and>\n     (contains_insyncs ys \\<longrightarrow> (\\<exists>vs. xs = map Val vs)))", "by(induct xs)(auto simp add: Cons_eq_map_conv)"], ["", "lemma fixes e :: \"('a,'b,'addr) exp\" and es :: \"('a,'b,'addr) exp list\"\n  shows not_contains_insync_sync_ok: \"\\<not> contains_insync e \\<Longrightarrow> sync_ok e\"\n  and not_contains_insyncs_sync_oks: \"\\<not> contains_insyncs es \\<Longrightarrow> sync_oks es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> contains_insync e \\<Longrightarrow> sync_ok e) &&&\n    (\\<not> contains_insyncs es \\<Longrightarrow> sync_oks es)", "by(induct e and es rule: sync_ok.induct sync_oks.induct)(auto)"], ["", "lemma expr_locks_sync_ok: \"(\\<And>ad. expr_locks e ad = 0) \\<Longrightarrow> sync_ok e\"\n  and expr_lockss_sync_oks: \"(\\<And>ad. expr_lockss es ad = 0) \\<Longrightarrow> sync_oks es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>ad. expr_locks e ad = 0) \\<Longrightarrow> sync_ok e) &&&\n    ((\\<And>ad. expr_lockss es ad = 0) \\<Longrightarrow> sync_oks es)", "by(auto intro!: not_contains_insync_sync_ok not_contains_insyncs_sync_oks\n        simp add: contains_insync_conv contains_insyncs_conv)"], ["", "lemma sync_ok_extRet2J [simp, intro!]: \"sync_ok e \\<Longrightarrow> sync_ok (extRet2J e va)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sync_ok e \\<Longrightarrow> sync_ok (extRet2J e va)", "by(cases va) auto"], ["", "abbreviation\n  sync_es_ok :: \"('addr,'thread_id,('a,'b,'addr) exp\\<times>'c) thread_info \\<Rightarrow> 'heap \\<Rightarrow> bool\"\nwhere\n  \"sync_es_ok \\<equiv> ts_ok (\\<lambda>t (e, x) m. sync_ok e)\""], ["", "lemma sync_es_ok_blocks [simp]:\n  \"\\<lbrakk> length pns = length Ts; length Ts = length vs \\<rbrakk> \\<Longrightarrow> sync_ok (blocks pns Ts vs e) = sync_ok e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length pns = length Ts; length Ts = length vs\\<rbrakk>\n    \\<Longrightarrow> sync_ok (blocks pns Ts vs e) = sync_ok e", "by(induct pns Ts vs e rule: blocks.induct) auto"], ["", "context J_heap_base begin"], ["", "lemma assumes wf: \"wf_J_prog P\"\n  shows red_preserve_sync_ok: \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; sync_ok e \\<rbrakk> \\<Longrightarrow> sync_ok e'\"\n  and reds_preserve_sync_oks: \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; sync_oks es \\<rbrakk> \\<Longrightarrow> sync_oks es'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n      sync_ok e\\<rbrakk>\n     \\<Longrightarrow> sync_ok e') &&&\n    (\\<lbrakk>extTA,P,t \\<turnstile> \\<langle>es,\ns\\<rangle> [-ta\\<rightarrow>]\n                                     \\<langle>es',s'\\<rangle>;\n      sync_oks es\\<rbrakk>\n     \\<Longrightarrow> sync_oks es')", "proof(induct rule: red_reds.inducts)"], ["proof (state)\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (addr a)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {}; sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow> sync_ok e';\n        sync_ok (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (newA T\\<lfloor>e'\\<rceil>)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (addr a)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> sync_ok\n                          (Throw (addr_of_sys_xcpt NegativeArraySize))\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow> sync_ok e'; sync_ok (Cast C e)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Cast C e')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Val v)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Throw (addr_of_sys_xcpt ClassCast))\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         sync_ok e \\<Longrightarrow> sync_ok e';\n         sync_ok (e instanceof T)\\<rbrakk>\n        \\<Longrightarrow> sync_ok (e' instanceof T)\nA total of 98 subgoals...", "case (RedCall s a U M Ts T pns body D vs)"], ["proof (state)\nthis:\n  typeof_addr (hp s) a = \\<lfloor>U\\<rfloor>\n  P \\<turnstile> class_type_of\n                  U sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                   body)\\<rfloor> in D\n  length vs = length pns\n  length Ts = length pns\n  sync_ok (addr a\\<bullet>M(map Val vs))\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (addr a)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {}; sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow> sync_ok e';\n        sync_ok (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (newA T\\<lfloor>e'\\<rceil>)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (addr a)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> sync_ok\n                          (Throw (addr_of_sys_xcpt NegativeArraySize))\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow> sync_ok e'; sync_ok (Cast C e)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Cast C e')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Val v)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Throw (addr_of_sys_xcpt ClassCast))\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         sync_ok e \\<Longrightarrow> sync_ok e';\n         sync_ok (e instanceof T)\\<rbrakk>\n        \\<Longrightarrow> sync_ok (e' instanceof T)\nA total of 98 subgoals...", "from wf \\<open>P \\<turnstile> class_type_of U sees M: Ts\\<rightarrow>T = \\<lfloor>(pns, body)\\<rfloor> in D\\<close>"], ["proof (chain)\npicking this:\n  wf_J_prog P\n  P \\<turnstile> class_type_of\n                  U sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                   body)\\<rfloor> in D", "have \"wf_mdecl wf_J_mdecl P D (M,Ts,T,\\<lfloor>(pns,body)\\<rfloor>)\""], ["proof (prove)\nusing this:\n  wf_J_prog P\n  P \\<turnstile> class_type_of\n                  U sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                   body)\\<rfloor> in D\n\ngoal (1 subgoal):\n 1. wf_mdecl wf_J_mdecl P D (M, Ts, T, \\<lfloor>(pns, body)\\<rfloor>)", "by(rule sees_wf_mdecl)"], ["proof (state)\nthis:\n  wf_mdecl wf_J_mdecl P D (M, Ts, T, \\<lfloor>(pns, body)\\<rfloor>)\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (addr a)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {}; sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow> sync_ok e';\n        sync_ok (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (newA T\\<lfloor>e'\\<rceil>)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (addr a)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> sync_ok\n                          (Throw (addr_of_sys_xcpt NegativeArraySize))\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow> sync_ok e'; sync_ok (Cast C e)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Cast C e')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Val v)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Throw (addr_of_sys_xcpt ClassCast))\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         sync_ok e \\<Longrightarrow> sync_ok e';\n         sync_ok (e instanceof T)\\<rbrakk>\n        \\<Longrightarrow> sync_ok (e' instanceof T)\nA total of 98 subgoals...", "then"], ["proof (chain)\npicking this:\n  wf_mdecl wf_J_mdecl P D (M, Ts, T, \\<lfloor>(pns, body)\\<rfloor>)", "obtain T where \"P,[this\\<mapsto>Class D,pns[\\<mapsto>]Ts] \\<turnstile> body :: T\""], ["proof (prove)\nusing this:\n  wf_mdecl wf_J_mdecl P D (M, Ts, T, \\<lfloor>(pns, body)\\<rfloor>)\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        P,[this \\<mapsto> Class D, pns [\\<mapsto>]\n           Ts] \\<turnstile> body :: T \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: wf_mdecl_def)"], ["proof (state)\nthis:\n  P,[this \\<mapsto> Class D, pns [\\<mapsto>] Ts] \\<turnstile> body :: T\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (addr a)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {}; sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow> sync_ok e';\n        sync_ok (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (newA T\\<lfloor>e'\\<rceil>)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (addr a)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> sync_ok\n                          (Throw (addr_of_sys_xcpt NegativeArraySize))\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow> sync_ok e'; sync_ok (Cast C e)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Cast C e')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Val v)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Throw (addr_of_sys_xcpt ClassCast))\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         sync_ok e \\<Longrightarrow> sync_ok e';\n         sync_ok (e instanceof T)\\<rbrakk>\n        \\<Longrightarrow> sync_ok (e' instanceof T)\nA total of 98 subgoals...", "hence \"expr_locks body = (\\<lambda>ad. 0)\""], ["proof (prove)\nusing this:\n  P,[this \\<mapsto> Class D, pns [\\<mapsto>] Ts] \\<turnstile> body :: T\n\ngoal (1 subgoal):\n 1. expr_locks body = (\\<lambda>ad. 0)", "by(rule WT_expr_locks)"], ["proof (state)\nthis:\n  expr_locks body = (\\<lambda>ad. 0)\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (addr a)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {}; sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow> sync_ok e';\n        sync_ok (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (newA T\\<lfloor>e'\\<rceil>)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (addr a)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> sync_ok\n                          (Throw (addr_of_sys_xcpt NegativeArraySize))\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow> sync_ok e'; sync_ok (Cast C e)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Cast C e')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Val v)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Throw (addr_of_sys_xcpt ClassCast))\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         sync_ok e \\<Longrightarrow> sync_ok e';\n         sync_ok (e instanceof T)\\<rbrakk>\n        \\<Longrightarrow> sync_ok (e' instanceof T)\nA total of 98 subgoals...", "with \\<open>length vs = length pns\\<close> \\<open>length Ts = length pns\\<close>"], ["proof (chain)\npicking this:\n  length vs = length pns\n  length Ts = length pns\n  expr_locks body = (\\<lambda>ad. 0)", "have \"expr_locks (blocks pns Ts vs body) = (\\<lambda>ad. 0)\""], ["proof (prove)\nusing this:\n  length vs = length pns\n  length Ts = length pns\n  expr_locks body = (\\<lambda>ad. 0)\n\ngoal (1 subgoal):\n 1. expr_locks (blocks pns Ts vs body) = (\\<lambda>ad. 0)", "by(simp add: expr_locks_blocks)"], ["proof (state)\nthis:\n  expr_locks (blocks pns Ts vs body) = (\\<lambda>ad. 0)\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (addr a)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {}; sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow> sync_ok e';\n        sync_ok (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (newA T\\<lfloor>e'\\<rceil>)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (addr a)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> sync_ok\n                          (Throw (addr_of_sys_xcpt NegativeArraySize))\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow> sync_ok e'; sync_ok (Cast C e)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Cast C e')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Val v)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Throw (addr_of_sys_xcpt ClassCast))\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         sync_ok e \\<Longrightarrow> sync_ok e';\n         sync_ok (e instanceof T)\\<rbrakk>\n        \\<Longrightarrow> sync_ok (e' instanceof T)\nA total of 98 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  expr_locks (blocks pns Ts vs body) = (\\<lambda>ad. 0)\n\ngoal (1 subgoal):\n 1. sync_ok (blocks (this # pns) (Class D # Ts) (Addr a # vs) body)", "by(auto intro: expr_locks_sync_ok)"], ["proof (state)\nthis:\n  sync_ok (blocks (this # pns) (Class D # Ts) (Addr a # vs) body)\n\ngoal (97 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (addr a)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {}; sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow> sync_ok e';\n        sync_ok (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (newA T\\<lfloor>e'\\<rceil>)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (addr a)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> sync_ok\n                          (Throw (addr_of_sys_xcpt NegativeArraySize))\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow> sync_ok e'; sync_ok (Cast C e)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Cast C e')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Val v)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Throw (addr_of_sys_xcpt ClassCast))\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         sync_ok e \\<Longrightarrow> sync_ok e';\n         sync_ok (e instanceof T)\\<rbrakk>\n        \\<Longrightarrow> sync_ok (e' instanceof T)\nA total of 97 subgoals...", "qed(fastforce intro: not_contains_insync_sync_ok)+"], ["", "lemma assumes wf: \"wf_J_prog P\"\n  shows expr_locks_new_thread:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; NewThread t'' (e'', x'') h \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk> \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\"\n\n  and expr_locks_new_thread':\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; NewThread t'' (e'', x'') h \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk> \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>extTA2J\n               P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle>;\n      NewThread t'' (e'', x'') h\n      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n     \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)) &&&\n    (\\<lbrakk>extTA2J\n               P,P,t \\<turnstile> \\<langle>es,s\\<rangle> [-ta\\<rightarrow>]\n                                  \\<langle>es',s'\\<rangle>;\n      NewThread t'' (e'', x'') h\n      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n     \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0))", "proof(induct rule: red_reds.inducts)"], ["proof (state)\ngoal (98 subgoals):\n 1. \\<And>h' a ha C l.\n       \\<lbrakk>(h', a) \\<in> allocate ha (Class_type C);\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Class_type\n C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 2. \\<And>ha C l.\n       \\<lbrakk>allocate ha (Class_type C) = {};\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        expr_locks e'' = (\\<lambda>ad. 0);\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 4. \\<And>i h' a ha T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate ha (Array_type T (nat (sint i)));\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Array_type T\n (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 6. \\<And>i ha T l.\n       \\<lbrakk>0 \\<le>s i; allocate ha (Array_type T (nat (sint i))) = {};\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        expr_locks e'' = (\\<lambda>ad. 0);\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         NewThread t'' (e'', x'') h\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n         expr_locks e'' = (\\<lambda>ad. 0);\n         NewThread t'' (e'', x'') h\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\nA total of 98 subgoals...", "case (RedCallExternal s a U M Ts T D vs ta va h' ta' e' s')"], ["proof (state)\nthis:\n  typeof_addr (hp s) a = \\<lfloor>U\\<rfloor>\n  P \\<turnstile> class_type_of U sees M: Ts\\<rightarrow>T = Native in D\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   hp s\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n  ta' = extTA2J P ta\n  e' = extRet2J (addr a\\<bullet>M(map Val vs)) va\n  s' = (h', lcl s)\n  NewThread t'' (e'', x'') h\n  \\<in> set \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>\n\ngoal (98 subgoals):\n 1. \\<And>h' a ha C l.\n       \\<lbrakk>(h', a) \\<in> allocate ha (Class_type C);\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Class_type\n C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 2. \\<And>ha C l.\n       \\<lbrakk>allocate ha (Class_type C) = {};\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        expr_locks e'' = (\\<lambda>ad. 0);\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 4. \\<And>i h' a ha T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate ha (Array_type T (nat (sint i)));\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Array_type T\n (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 6. \\<And>i ha T l.\n       \\<lbrakk>0 \\<le>s i; allocate ha (Array_type T (nat (sint i))) = {};\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        expr_locks e'' = (\\<lambda>ad. 0);\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         NewThread t'' (e'', x'') h\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n         expr_locks e'' = (\\<lambda>ad. 0);\n         NewThread t'' (e'', x'') h\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\nA total of 98 subgoals...", "then"], ["proof (chain)\npicking this:\n  typeof_addr (hp s) a = \\<lfloor>U\\<rfloor>\n  P \\<turnstile> class_type_of U sees M: Ts\\<rightarrow>T = Native in D\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   hp s\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n  ta' = extTA2J P ta\n  e' = extRet2J (addr a\\<bullet>M(map Val vs)) va\n  s' = (h', lcl s)\n  NewThread t'' (e'', x'') h\n  \\<in> set \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>", "obtain C fs a where subThread: \"P \\<turnstile> C \\<preceq>\\<^sup>* Thread\" and ext: \"extNTA2J P (C, run, a) = (e'', x'')\""], ["proof (prove)\nusing this:\n  typeof_addr (hp s) a = \\<lfloor>U\\<rfloor>\n  P \\<turnstile> class_type_of U sees M: Ts\\<rightarrow>T = Native in D\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   hp s\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n  ta' = extTA2J P ta\n  e' = extRet2J (addr a\\<bullet>M(map Val vs)) va\n  s' = (h', lcl s)\n  NewThread t'' (e'', x'') h\n  \\<in> set \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>C a.\n        \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* Thread;\n         extNTA2J P (C, run, a) = (e'', x'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest: red_external_new_thread_sub_thread)"], ["proof (state)\nthis:\n  P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n  extNTA2J P (C, run, a) = (e'', x'')\n\ngoal (98 subgoals):\n 1. \\<And>h' a ha C l.\n       \\<lbrakk>(h', a) \\<in> allocate ha (Class_type C);\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Class_type\n C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 2. \\<And>ha C l.\n       \\<lbrakk>allocate ha (Class_type C) = {};\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        expr_locks e'' = (\\<lambda>ad. 0);\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 4. \\<And>i h' a ha T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate ha (Array_type T (nat (sint i)));\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Array_type T\n (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 6. \\<And>i ha T l.\n       \\<lbrakk>0 \\<le>s i; allocate ha (Array_type T (nat (sint i))) = {};\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        expr_locks e'' = (\\<lambda>ad. 0);\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         NewThread t'' (e'', x'') h\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n         expr_locks e'' = (\\<lambda>ad. 0);\n         NewThread t'' (e'', x'') h\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\nA total of 98 subgoals...", "from sub_Thread_sees_run[OF wf subThread]"], ["proof (chain)\npicking this:\n  \\<exists>D mthd.\n     P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>mthd\\<rfloor> in D", "obtain D pns body\n    where sees: \"P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>(pns, body)\\<rfloor> in D\""], ["proof (prove)\nusing this:\n  \\<exists>D mthd.\n     P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>mthd\\<rfloor> in D\n\ngoal (1 subgoal):\n 1. (\\<And>pns body D.\n        P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>(pns,\n                             body)\\<rfloor> in D \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>(pns,\n                       body)\\<rfloor> in D\n\ngoal (98 subgoals):\n 1. \\<And>h' a ha C l.\n       \\<lbrakk>(h', a) \\<in> allocate ha (Class_type C);\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Class_type\n C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 2. \\<And>ha C l.\n       \\<lbrakk>allocate ha (Class_type C) = {};\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        expr_locks e'' = (\\<lambda>ad. 0);\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 4. \\<And>i h' a ha T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate ha (Array_type T (nat (sint i)));\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Array_type T\n (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 6. \\<And>i ha T l.\n       \\<lbrakk>0 \\<le>s i; allocate ha (Array_type T (nat (sint i))) = {};\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        expr_locks e'' = (\\<lambda>ad. 0);\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         NewThread t'' (e'', x'') h\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n         expr_locks e'' = (\\<lambda>ad. 0);\n         NewThread t'' (e'', x'') h\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\nA total of 98 subgoals...", "from sees_wf_mdecl[OF wf this]"], ["proof (chain)\npicking this:\n  wf_mdecl wf_J_mdecl P D (run, [], Void, \\<lfloor>(pns, body)\\<rfloor>)", "obtain T where \"P,[this \\<mapsto> Class D] \\<turnstile> body :: T\""], ["proof (prove)\nusing this:\n  wf_mdecl wf_J_mdecl P D (run, [], Void, \\<lfloor>(pns, body)\\<rfloor>)\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        P,[this \\<mapsto> Class D] \\<turnstile> body :: T \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: wf_mdecl_def)"], ["proof (state)\nthis:\n  P,[this \\<mapsto> Class D] \\<turnstile> body :: T\n\ngoal (98 subgoals):\n 1. \\<And>h' a ha C l.\n       \\<lbrakk>(h', a) \\<in> allocate ha (Class_type C);\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Class_type\n C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 2. \\<And>ha C l.\n       \\<lbrakk>allocate ha (Class_type C) = {};\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        expr_locks e'' = (\\<lambda>ad. 0);\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 4. \\<And>i h' a ha T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate ha (Array_type T (nat (sint i)));\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Array_type T\n (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 6. \\<And>i ha T l.\n       \\<lbrakk>0 \\<le>s i; allocate ha (Array_type T (nat (sint i))) = {};\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        expr_locks e'' = (\\<lambda>ad. 0);\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         NewThread t'' (e'', x'') h\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n         expr_locks e'' = (\\<lambda>ad. 0);\n         NewThread t'' (e'', x'') h\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\nA total of 98 subgoals...", "hence \"expr_locks body = (\\<lambda>ad. 0)\""], ["proof (prove)\nusing this:\n  P,[this \\<mapsto> Class D] \\<turnstile> body :: T\n\ngoal (1 subgoal):\n 1. expr_locks body = (\\<lambda>ad. 0)", "by(rule WT_expr_locks)"], ["proof (state)\nthis:\n  expr_locks body = (\\<lambda>ad. 0)\n\ngoal (98 subgoals):\n 1. \\<And>h' a ha C l.\n       \\<lbrakk>(h', a) \\<in> allocate ha (Class_type C);\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Class_type\n C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 2. \\<And>ha C l.\n       \\<lbrakk>allocate ha (Class_type C) = {};\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        expr_locks e'' = (\\<lambda>ad. 0);\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 4. \\<And>i h' a ha T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate ha (Array_type T (nat (sint i)));\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Array_type T\n (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 6. \\<And>i ha T l.\n       \\<lbrakk>0 \\<le>s i; allocate ha (Array_type T (nat (sint i))) = {};\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        expr_locks e'' = (\\<lambda>ad. 0);\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         NewThread t'' (e'', x'') h\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n         expr_locks e'' = (\\<lambda>ad. 0);\n         NewThread t'' (e'', x'') h\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\nA total of 98 subgoals...", "with sees ext"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>(pns,\n                       body)\\<rfloor> in D\n  extNTA2J P (C, run, a) = (e'', x'')\n  expr_locks body = (\\<lambda>ad. 0)", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>(pns,\n                       body)\\<rfloor> in D\n  extNTA2J P (C, run, a) = (e'', x'')\n  expr_locks body = (\\<lambda>ad. 0)\n\ngoal (1 subgoal):\n 1. expr_locks e'' = (\\<lambda>ad. 0)", "by(auto simp add: extNTA2J_def)"], ["proof (state)\nthis:\n  expr_locks e'' = (\\<lambda>ad. 0)\n\ngoal (97 subgoals):\n 1. \\<And>h' a ha C l.\n       \\<lbrakk>(h', a) \\<in> allocate ha (Class_type C);\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Class_type\n C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 2. \\<And>ha C l.\n       \\<lbrakk>allocate ha (Class_type C) = {};\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        expr_locks e'' = (\\<lambda>ad. 0);\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 4. \\<And>i h' a ha T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate ha (Array_type T (nat (sint i)));\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Array_type T\n (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 6. \\<And>i ha T l.\n       \\<lbrakk>0 \\<le>s i; allocate ha (Array_type T (nat (sint i))) = {};\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        expr_locks e'' = (\\<lambda>ad. 0);\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        NewThread t'' (e'', x'') h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         NewThread t'' (e'', x'') h\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n         expr_locks e'' = (\\<lambda>ad. 0);\n         NewThread t'' (e'', x'') h\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> expr_locks e'' = (\\<lambda>ad. 0)\nA total of 97 subgoals...", "qed(auto simp add: ta_upd_simps)"], ["", "lemma assumes wf: \"wf_J_prog P\"\n  shows red_new_thread_sync_ok: \"\\<lbrakk> P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; NewThread t'' (e'', x'') h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk> \\<Longrightarrow> sync_ok e''\"\n  and reds_new_thread_sync_ok: \"\\<lbrakk> P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; NewThread t'' (e'', x'') h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk> \\<Longrightarrow> sync_ok e''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>extTA2J\n               P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle>;\n      NewThread t'' (e'', x'') h''\n      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n     \\<Longrightarrow> sync_ok e'') &&&\n    (\\<lbrakk>extTA2J\n               P,P,t \\<turnstile> \\<langle>es,s\\<rangle> [-ta\\<rightarrow>]\n                                  \\<langle>es',s'\\<rangle>;\n      NewThread t'' (e'', x'') h''\n      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n     \\<Longrightarrow> sync_ok e'')", "by(auto dest!: expr_locks_new_thread[OF wf] expr_locks_new_thread'[OF wf] intro: expr_locks_sync_ok expr_lockss_sync_oks)"], ["", "lemma lifting_wf_sync_ok: \"wf_J_prog P \\<Longrightarrow> lifting_wf final_expr (mred P) (\\<lambda>t (e, x) m. sync_ok e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_J_prog P \\<Longrightarrow>\n    lifting_wf final_expr\n     (\\<lambda>t ((e, l), h) ta ((e', l'), h').\n         extTA2J\n          P,P,t \\<turnstile> \\<langle>e,(h, l)\\<rangle> -ta\\<rightarrow>\n                             \\<langle>e',(h', l')\\<rangle>)\n     (\\<lambda>t (e, x) m. sync_ok e)", "by(unfold_locales)(auto intro: red_preserve_sync_ok red_new_thread_sync_ok)"], ["", "lemma redT_preserve_sync_ok:\n  assumes red: \"P \\<turnstile> s -t\\<triangleright>ta\\<rightarrow> s'\"\n  shows \"\\<lbrakk> wf_J_prog P; sync_es_ok (thr s) (shr s) \\<rbrakk> \\<Longrightarrow> sync_es_ok (thr s') (shr s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_J_prog P; sync_es_ok (thr s) (shr s)\\<rbrakk>\n    \\<Longrightarrow> sync_es_ok (thr s') (shr s')", "by(rule lifting_wf.redT_preserves[OF lifting_wf_sync_ok red])"], ["", "lemma RedT_preserves_sync_ok:\n  \"\\<lbrakk>wf_J_prog P; P \\<turnstile> s -\\<triangleright>ttas\\<rightarrow>* s'; sync_es_ok (thr s) (shr s)\\<rbrakk>\n   \\<Longrightarrow> sync_es_ok (thr s') (shr s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_J_prog P;\n     P \\<turnstile> s -\\<triangleright>ttas\\<rightarrow>* s';\n     sync_es_ok (thr s) (shr s)\\<rbrakk>\n    \\<Longrightarrow> sync_es_ok (thr s') (shr s')", "by(rule lifting_wf.RedT_preserves[OF lifting_wf_sync_ok])"], ["", "lemma sync_es_ok_J_start_state:\n  \"\\<lbrakk> wf_J_prog P; P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(pns, body)\\<rfloor> in D; length Ts = length vs \\<rbrakk>\n  \\<Longrightarrow> sync_es_ok (thr (J_start_state P C M vs)) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_J_prog P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                     body)\\<rfloor> in D;\n     length Ts = length vs\\<rbrakk>\n    \\<Longrightarrow> sync_es_ok (thr (start_state J_local_start P C M vs))\n                       m", "apply(rule ts_okI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t x ln.\n       \\<lbrakk>wf_J_prog P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                        body)\\<rfloor> in D;\n        length Ts = length vs;\n        thr (start_state J_local_start P C M vs) t =\n        \\<lfloor>(x, ln)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (e, x) \\<Rightarrow> \\<lambda>m. sync_ok e)\n                          m", "apply(clarsimp simp add: start_state_def split_beta split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_J_prog P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                     body)\\<rfloor> in D;\n     length Ts = length vs\\<rbrakk>\n    \\<Longrightarrow> sync_ok (blocks pns Ts vs body)", "apply(drule (1) sees_wf_mdecl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                             body)\\<rfloor> in D;\n     length Ts = length vs;\n     wf_mdecl wf_J_mdecl P D\n      (M, Ts, T, \\<lfloor>(pns, body)\\<rfloor>)\\<rbrakk>\n    \\<Longrightarrow> sync_ok (blocks pns Ts vs body)", "apply(clarsimp simp add: wf_mdecl_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>T'.\n       \\<lbrakk>P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                                body)\\<rfloor> in D;\n        length Ts = length pns; \\<forall>x\\<in>set Ts. is_type P x;\n        is_type P T; length vs = length pns; distinct pns;\n        this \\<notin> set pns;\n        \\<D> body \\<lfloor>insert this (set pns)\\<rfloor>;\n        P,[pns [\\<mapsto>] Ts, this \\<mapsto>\n           Class D] \\<turnstile> body :: T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> sync_ok body", "apply(drule WT_expr_locks)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>T'.\n       \\<lbrakk>P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                                body)\\<rfloor> in D;\n        length Ts = length pns; \\<forall>x\\<in>set Ts. is_type P x;\n        is_type P T; length vs = length pns; distinct pns;\n        this \\<notin> set pns;\n        \\<D> body \\<lfloor>insert this (set pns)\\<rfloor>;\n        P \\<turnstile> T' \\<le> T;\n        expr_locks body = (\\<lambda>ad. 0)\\<rbrakk>\n       \\<Longrightarrow> sync_ok body", "apply(rule expr_locks_sync_ok)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>T' ad.\n       \\<lbrakk>P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                                body)\\<rfloor> in D;\n        length Ts = length pns; \\<forall>x\\<in>set Ts. is_type P x;\n        is_type P T; length vs = length pns; distinct pns;\n        this \\<notin> set pns;\n        \\<D> body \\<lfloor>insert this (set pns)\\<rfloor>;\n        P \\<turnstile> T' \\<le> T;\n        expr_locks body = (\\<lambda>ad. 0)\\<rbrakk>\n       \\<Longrightarrow> expr_locks body ad = 0", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "text \\<open>Framework lock state agrees with locks stored in the expression\\<close>"], ["", "definition lock_ok :: \"('addr,'thread_id) locks \\<Rightarrow> ('addr,'thread_id,('a, 'b,'addr) exp \\<times> 'x) thread_info \\<Rightarrow> bool\" where\n  \"\\<And>ln. lock_ok ls ts \\<equiv> \\<forall>t. (case (ts t) of None    \\<Rightarrow> (\\<forall>l. has_locks (ls $ l) t = 0)\n                                     | \\<lfloor>((e, x), ln)\\<rfloor> \\<Rightarrow> (\\<forall>l. has_locks (ls $ l) t + ln $ l = expr_locks e l))\""], ["", "lemma lock_okI:\n  \"\\<lbrakk> \\<And>t l. ts t = None \\<Longrightarrow> has_locks (ls $ l) t = 0; \\<And>t e x ln l. ts t = \\<lfloor>((e, x), ln)\\<rfloor> \\<Longrightarrow> has_locks (ls $ l) t + ln $ l= expr_locks e l \\<rbrakk> \\<Longrightarrow> lock_ok ls ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t l.\n                ts t = None \\<Longrightarrow> has_locks (ls $ l) t = 0;\n     \\<And>t e x ln l.\n        ts t = \\<lfloor>((e, x), ln)\\<rfloor> \\<Longrightarrow>\n        has_locks (ls $ l) t + ln $ l = expr_locks e l\\<rbrakk>\n    \\<Longrightarrow> lock_ok ls ts", "apply(fastforce simp add: lock_ok_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lock_okE:\n  \"\\<lbrakk> lock_ok ls ts;\n     \\<forall>t. ts t = None \\<longrightarrow> (\\<forall>l. has_locks (ls $ l) t = 0) \\<Longrightarrow> Q;\n     \\<forall>t e x ln. ts t = \\<lfloor>((e, x), ln)\\<rfloor> \\<longrightarrow> (\\<forall>l. has_locks (ls $ l) t + ln $ l = expr_locks e l) \\<Longrightarrow> Q \\<rbrakk>\n  \\<Longrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lock_ok ls ts;\n     \\<forall>t.\n        ts t = None \\<longrightarrow>\n        (\\<forall>l. has_locks (ls $ l) t = 0) \\<Longrightarrow>\n     Q;\n     \\<forall>t e x ln.\n        ts t = \\<lfloor>((e, x), ln)\\<rfloor> \\<longrightarrow>\n        (\\<forall>l.\n            has_locks (ls $ l) t + ln $ l =\n            expr_locks e l) \\<Longrightarrow>\n     Q\\<rbrakk>\n    \\<Longrightarrow> Q", "by(fastforce simp add: lock_ok_def)"], ["", "lemma lock_okD1:\n  \"\\<lbrakk> lock_ok ls ts; ts t = None \\<rbrakk> \\<Longrightarrow> \\<forall>l. has_locks (ls $ l) t = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lock_ok ls ts; ts t = None\\<rbrakk>\n    \\<Longrightarrow> \\<forall>l. has_locks (ls $ l) t = 0", "apply(simp add: lock_ok_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t.\n                ((\\<exists>a b ba.\n                     ts t = \\<lfloor>((a, b), ba)\\<rfloor>) \\<or>\n                 (\\<forall>l. has_locks (ls $ l) t = 0)) \\<and>\n                (\\<forall>a b ba.\n                    ts t = \\<lfloor>((a, b), ba)\\<rfloor> \\<longrightarrow>\n                    (\\<forall>l.\n                        has_locks (ls $ l) t + ba $ l = expr_locks a l));\n     ts t = None\\<rbrakk>\n    \\<Longrightarrow> \\<forall>l. has_locks (ls $ l) t = 0", "apply(erule_tac x=\"t\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ts t = None;\n     ((\\<exists>a b ba. ts t = \\<lfloor>((a, b), ba)\\<rfloor>) \\<or>\n      (\\<forall>l. has_locks (ls $ l) t = 0)) \\<and>\n     (\\<forall>a b ba.\n         ts t = \\<lfloor>((a, b), ba)\\<rfloor> \\<longrightarrow>\n         (\\<forall>l.\n             has_locks (ls $ l) t + ba $ l = expr_locks a l))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>l. has_locks (ls $ l) t = 0", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lock_okD2:\n  \"\\<And>ln. \\<lbrakk> lock_ok ls ts; ts t = \\<lfloor>((e, x), ln)\\<rfloor> \\<rbrakk> \\<Longrightarrow> \\<forall>l. has_locks (ls $ l) t + ln $ l = expr_locks e l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln.\n       \\<lbrakk>lock_ok ls ts;\n        ts t = \\<lfloor>((e, x), ln)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>l.\n                            has_locks (ls $ l) t + ln $ l = expr_locks e l", "apply(fastforce simp add: lock_ok_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lock_ok_lock_thread_ok:\n  assumes lock: \"lock_ok ls ts\"\n  shows \"lock_thread_ok ls ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lock_thread_ok ls ts", "proof(rule lock_thread_okI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l t.\n       has_lock (ls $ l) t \\<Longrightarrow>\n       \\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>", "fix l t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l t.\n       has_lock (ls $ l) t \\<Longrightarrow>\n       \\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>", "assume lsl: \"has_lock (ls $ l) t\""], ["proof (state)\nthis:\n  has_lock (ls $ l) t\n\ngoal (1 subgoal):\n 1. \\<And>l t.\n       has_lock (ls $ l) t \\<Longrightarrow>\n       \\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>", "show \"\\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>", "proof(cases \"ts t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ts t = None \\<Longrightarrow> \\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>\n 2. \\<And>a.\n       ts t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>", "case None"], ["proof (state)\nthis:\n  ts t = None\n\ngoal (2 subgoals):\n 1. ts t = None \\<Longrightarrow> \\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>\n 2. \\<And>a.\n       ts t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>", "with lock"], ["proof (chain)\npicking this:\n  lock_ok ls ts\n  ts t = None", "have \"has_locks (ls $ l) t = 0\""], ["proof (prove)\nusing this:\n  lock_ok ls ts\n  ts t = None\n\ngoal (1 subgoal):\n 1. has_locks (ls $ l) t = 0", "by(auto dest: lock_okD1)"], ["proof (state)\nthis:\n  has_locks (ls $ l) t = 0\n\ngoal (2 subgoals):\n 1. ts t = None \\<Longrightarrow> \\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>\n 2. \\<And>a.\n       ts t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>", "with lsl"], ["proof (chain)\npicking this:\n  has_lock (ls $ l) t\n  has_locks (ls $ l) t = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  has_lock (ls $ l) t\n  has_locks (ls $ l) t = 0\n\ngoal (1 subgoal):\n 1. \\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  \\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ts t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       ts t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>", "case (Some a)"], ["proof (state)\nthis:\n  ts t = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ts t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>", "thus ?thesis"], ["proof (prove)\nusing this:\n  ts t = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>", "by blast"], ["proof (state)\nthis:\n  \\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in J_heap_base) lock_ok_J_start_state:\n  \"\\<lbrakk> wf_J_prog P; P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(pns, body)\\<rfloor> in D; length Ts = length vs \\<rbrakk>\n  \\<Longrightarrow> lock_ok (locks (J_start_state P C M vs)) (thr (J_start_state P C M vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_J_prog P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                     body)\\<rfloor> in D;\n     length Ts = length vs\\<rbrakk>\n    \\<Longrightarrow> lock_ok (locks (start_state J_local_start P C M vs))\n                       (thr (start_state J_local_start P C M vs))", "apply(rule lock_okI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t l.\n       \\<lbrakk>wf_J_prog P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                        body)\\<rfloor> in D;\n        length Ts = length vs;\n        thr (start_state J_local_start P C M vs) t = None\\<rbrakk>\n       \\<Longrightarrow> has_locks\n                          (locks (start_state J_local_start P C M vs) $ l)\n                          t =\n                         0\n 2. \\<And>t e x ln l.\n       \\<lbrakk>wf_J_prog P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                        body)\\<rfloor> in D;\n        length Ts = length vs;\n        thr (start_state J_local_start P C M vs) t =\n        \\<lfloor>((e, x), ln)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> has_locks\n                          (locks (start_state J_local_start P C M vs) $ l)\n                          t +\n                         ln $ l =\n                         expr_locks e l", "apply(auto simp add: start_state_def split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>wf_J_prog P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                        body)\\<rfloor> in D;\n        length Ts = length vs\\<rbrakk>\n       \\<Longrightarrow> expr_locks (blocks pns Ts vs body) l = 0", "apply(drule (1) sees_wf_mdecl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                                body)\\<rfloor> in D;\n        length Ts = length vs;\n        wf_mdecl wf_J_mdecl P D\n         (M, Ts, T, \\<lfloor>(pns, body)\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> expr_locks (blocks pns Ts vs body) l = 0", "apply(clarsimp simp add: wf_mdecl_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l T'.\n       \\<lbrakk>P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                                body)\\<rfloor> in D;\n        length Ts = length pns; \\<forall>x\\<in>set Ts. is_type P x;\n        is_type P T; length vs = length pns; distinct pns;\n        this \\<notin> set pns;\n        \\<D> body \\<lfloor>insert this (set pns)\\<rfloor>;\n        P,[pns [\\<mapsto>] Ts, this \\<mapsto>\n           Class D] \\<turnstile> body :: T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> expr_locks (blocks pns Ts vs body) l = 0", "apply(drule WT_expr_locks)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l T'.\n       \\<lbrakk>P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                                body)\\<rfloor> in D;\n        length Ts = length pns; \\<forall>x\\<in>set Ts. is_type P x;\n        is_type P T; length vs = length pns; distinct pns;\n        this \\<notin> set pns;\n        \\<D> body \\<lfloor>insert this (set pns)\\<rfloor>;\n        P \\<turnstile> T' \\<le> T;\n        expr_locks body = (\\<lambda>ad. 0)\\<rbrakk>\n       \\<Longrightarrow> expr_locks (blocks pns Ts vs body) l = 0", "apply(simp add: expr_locks_blocks)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Preservation of lock state agreement\\<close>"], ["", "fun upd_expr_lock_action :: \"int \\<Rightarrow> lock_action \\<Rightarrow> int\"\nwhere\n  \"upd_expr_lock_action i Lock = i + 1\"\n| \"upd_expr_lock_action i Unlock = i - 1\"\n| \"upd_expr_lock_action i UnlockFail = i\"\n| \"upd_expr_lock_action i ReleaseAcquire = i\""], ["", "fun upd_expr_lock_actions :: \"int \\<Rightarrow> lock_action list \\<Rightarrow> int\" where\n  \"upd_expr_lock_actions n [] = n\"\n| \"upd_expr_lock_actions n (L # Ls) = upd_expr_lock_actions (upd_expr_lock_action n L) Ls\""], ["", "lemma upd_expr_lock_actions_append [simp]:\n  \"upd_expr_lock_actions n (Ls @ Ls') = upd_expr_lock_actions (upd_expr_lock_actions n Ls) Ls'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_expr_lock_actions n (Ls @ Ls') =\n    upd_expr_lock_actions (upd_expr_lock_actions n Ls) Ls'", "by(induct Ls arbitrary: n, auto)"], ["", "definition upd_expr_locks :: \"('l \\<Rightarrow> int) \\<Rightarrow> 'l lock_actions \\<Rightarrow> 'l \\<Rightarrow> int\"\nwhere \"upd_expr_locks els las \\<equiv> \\<lambda>l. upd_expr_lock_actions (els l) (las $ l)\""], ["", "lemma upd_expr_locks_iff [simp]:\n  \"upd_expr_locks els las l = upd_expr_lock_actions (els l) (las $ l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_expr_locks els las l = upd_expr_lock_actions (els l) (las $ l)", "by(simp add: upd_expr_locks_def)"], ["", "lemma upd_expr_lock_action_add [simp]:\n  \"upd_expr_lock_action (l + l') L = upd_expr_lock_action l L + l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_expr_lock_action (l + l') L = upd_expr_lock_action l L + l'", "by(cases L, auto)"], ["", "lemma upd_expr_lock_actions_add [simp]:\n  \"upd_expr_lock_actions (l + l') Ls = upd_expr_lock_actions l Ls + l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_expr_lock_actions (l + l') Ls = upd_expr_lock_actions l Ls + l'", "by(induct Ls arbitrary: l, auto)"], ["", "lemma upd_expr_locks_add [simp]:\n  \"upd_expr_locks (\\<lambda>a. x a + y a) las = (\\<lambda>a. upd_expr_locks x las a + y a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_expr_locks (\\<lambda>a. x a + y a) las =\n    (\\<lambda>a. upd_expr_locks x las a + y a)", "by(auto intro: ext)"], ["", "lemma expr_locks_extRet2J [simp, intro!]: \"expr_locks e = (\\<lambda>ad. 0) \\<Longrightarrow> expr_locks (extRet2J e va) = (\\<lambda>ad. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expr_locks e = (\\<lambda>ad. 0) \\<Longrightarrow>\n    expr_locks (extRet2J e va) = (\\<lambda>ad. 0)", "by(cases va) auto"], ["", "lemma (in J_heap_base)\n  assumes wf: \"wf_J_prog P\"\n  shows red_update_expr_locks:\n  \"\\<lbrakk> convert_extTA extNTA,P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; sync_ok e \\<rbrakk> \n  \\<Longrightarrow> upd_expr_locks (int o expr_locks e) \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = int o expr_locks e'\"\n  and reds_update_expr_lockss:\n  \"\\<lbrakk> convert_extTA extNTA,P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; sync_oks es \\<rbrakk>\n  \\<Longrightarrow> upd_expr_locks (int o expr_lockss es) \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = int o expr_lockss es'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>convert_extTA\n               extNTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n      sync_ok e\\<rbrakk>\n     \\<Longrightarrow> upd_expr_locks (int \\<circ> expr_locks e)\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                       int \\<circ> expr_locks e') &&&\n    (\\<lbrakk>convert_extTA\n               extNTA,P,t \\<turnstile> \\<langle>es,\n  s\\<rangle> [-ta\\<rightarrow>]\n \\<langle>es',s'\\<rangle>;\n      sync_oks es\\<rbrakk>\n     \\<Longrightarrow> upd_expr_locks (int \\<circ> expr_lockss es)\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                       int \\<circ> expr_lockss es')", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_extTA\n              extNTA,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n     sync_ok e\\<rbrakk>\n    \\<Longrightarrow> upd_expr_locks (int \\<circ> expr_locks e)\n                       \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                      int \\<circ> expr_locks e'\n 2. \\<lbrakk>convert_extTA\n              extNTA,P,t \\<turnstile> \\<langle>es,\n s\\<rangle> [-ta\\<rightarrow>]\n\\<langle>es',s'\\<rangle>;\n     sync_oks es\\<rbrakk>\n    \\<Longrightarrow> upd_expr_locks (int \\<circ> expr_lockss es)\n                       \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                      int \\<circ> expr_lockss es'", "have \"\\<lbrakk> convert_extTA extNTA,P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; sync_ok e \\<rbrakk> \n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0) \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = (\\<lambda>ad. (int o expr_locks e') ad - (int o expr_locks e) ad)\"\n    and \"\\<lbrakk> convert_extTA extNTA,P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; sync_oks es \\<rbrakk>\n        \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0) \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = (\\<lambda>ad. (int o expr_lockss es') ad - (int o expr_lockss es) ad)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>convert_extTA\n               extNTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n      sync_ok e\\<rbrakk>\n     \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                       (\\<lambda>ad.\n                           (int \\<circ> expr_locks e') ad -\n                           (int \\<circ> expr_locks e) ad)) &&&\n    (\\<lbrakk>convert_extTA\n               extNTA,P,t \\<turnstile> \\<langle>es,\n  s\\<rangle> [-ta\\<rightarrow>]\n \\<langle>es',s'\\<rangle>;\n      sync_oks es\\<rbrakk>\n     \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                       (\\<lambda>ad.\n                           (int \\<circ> expr_lockss es') ad -\n                           (int \\<circ> expr_lockss es) ad))", "proof(induct rule: red_reds.inducts)"], ["proof (state)\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (addr a)) ad -\n                             (int \\<circ> expr_locks (new C)) ad)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {}; sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt OutOfMemory)))\n                              ad -\n                             (int \\<circ> expr_locks (new C)) ad)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>convert_extTA\n                 extNTA,P,t \\<turnstile> \\<langle>e,\n    s\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow>\n        upd_expr_locks (\\<lambda>ad. 0)\n         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n        (\\<lambda>ad.\n            (int \\<circ> expr_locks e') ad - (int \\<circ> expr_locks e) ad);\n        sync_ok (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks (newA T\\<lfloor>e'\\<rceil>))\n                              ad -\n                             (int \\<circ>\n                              expr_locks (newA T\\<lfloor>e\\<rceil>))\n                              ad)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>NewHeapElem a\n       (Array_type T (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (addr a)) ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt NegativeArraySize)))\n                              ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt OutOfMemory)))\n                              ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>convert_extTA\n                 extNTA,P,t \\<turnstile> \\<langle>e,\n    s\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow>\n        upd_expr_locks (\\<lambda>ad. 0)\n         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n        (\\<lambda>ad.\n            (int \\<circ> expr_locks e') ad - (int \\<circ> expr_locks e) ad);\n        sync_ok (Cast C e)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (Cast C e')) ad -\n                             (int \\<circ> expr_locks (Cast C e)) ad)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (Val v)) ad -\n                             (int \\<circ> expr_locks (Cast T (Val v))) ad)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt ClassCast)))\n                              ad -\n                             (int \\<circ> expr_locks (Cast T (Val v))) ad)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>convert_extTA\n                  extNTA,P,t \\<turnstile> \\<langle>e,\n     s\\<rangle> -ta\\<rightarrow>\n    \\<langle>e',s'\\<rangle>;\n         sync_ok e \\<Longrightarrow>\n         upd_expr_locks (\\<lambda>ad. 0)\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n         (\\<lambda>ad.\n             (int \\<circ> expr_locks e') ad -\n             (int \\<circ> expr_locks e) ad);\n         sync_ok (e instanceof T)\\<rbrakk>\n        \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                          (\\<lambda>ad.\n                              (int \\<circ> expr_locks (e' instanceof T))\n                               ad -\n                              (int \\<circ> expr_locks (e instanceof T)) ad)\nA total of 98 subgoals...", "case (RedCall s a U M Ts T pns body D vs)"], ["proof (state)\nthis:\n  typeof_addr (hp s) a = \\<lfloor>U\\<rfloor>\n  P \\<turnstile> class_type_of\n                  U sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                   body)\\<rfloor> in D\n  length vs = length pns\n  length Ts = length pns\n  sync_ok (addr a\\<bullet>M(map Val vs))\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (addr a)) ad -\n                             (int \\<circ> expr_locks (new C)) ad)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {}; sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt OutOfMemory)))\n                              ad -\n                             (int \\<circ> expr_locks (new C)) ad)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>convert_extTA\n                 extNTA,P,t \\<turnstile> \\<langle>e,\n    s\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow>\n        upd_expr_locks (\\<lambda>ad. 0)\n         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n        (\\<lambda>ad.\n            (int \\<circ> expr_locks e') ad - (int \\<circ> expr_locks e) ad);\n        sync_ok (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks (newA T\\<lfloor>e'\\<rceil>))\n                              ad -\n                             (int \\<circ>\n                              expr_locks (newA T\\<lfloor>e\\<rceil>))\n                              ad)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>NewHeapElem a\n       (Array_type T (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (addr a)) ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt NegativeArraySize)))\n                              ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt OutOfMemory)))\n                              ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>convert_extTA\n                 extNTA,P,t \\<turnstile> \\<langle>e,\n    s\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow>\n        upd_expr_locks (\\<lambda>ad. 0)\n         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n        (\\<lambda>ad.\n            (int \\<circ> expr_locks e') ad - (int \\<circ> expr_locks e) ad);\n        sync_ok (Cast C e)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (Cast C e')) ad -\n                             (int \\<circ> expr_locks (Cast C e)) ad)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (Val v)) ad -\n                             (int \\<circ> expr_locks (Cast T (Val v))) ad)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt ClassCast)))\n                              ad -\n                             (int \\<circ> expr_locks (Cast T (Val v))) ad)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>convert_extTA\n                  extNTA,P,t \\<turnstile> \\<langle>e,\n     s\\<rangle> -ta\\<rightarrow>\n    \\<langle>e',s'\\<rangle>;\n         sync_ok e \\<Longrightarrow>\n         upd_expr_locks (\\<lambda>ad. 0)\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n         (\\<lambda>ad.\n             (int \\<circ> expr_locks e') ad -\n             (int \\<circ> expr_locks e) ad);\n         sync_ok (e instanceof T)\\<rbrakk>\n        \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                          (\\<lambda>ad.\n                              (int \\<circ> expr_locks (e' instanceof T))\n                               ad -\n                              (int \\<circ> expr_locks (e instanceof T)) ad)\nA total of 98 subgoals...", "from wf \\<open>P \\<turnstile> class_type_of U sees M: Ts\\<rightarrow>T = \\<lfloor>(pns, body)\\<rfloor> in D\\<close>"], ["proof (chain)\npicking this:\n  wf_J_prog P\n  P \\<turnstile> class_type_of\n                  U sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                   body)\\<rfloor> in D", "have \"wf_mdecl wf_J_mdecl P D (M,Ts,T,\\<lfloor>(pns,body)\\<rfloor>)\""], ["proof (prove)\nusing this:\n  wf_J_prog P\n  P \\<turnstile> class_type_of\n                  U sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                   body)\\<rfloor> in D\n\ngoal (1 subgoal):\n 1. wf_mdecl wf_J_mdecl P D (M, Ts, T, \\<lfloor>(pns, body)\\<rfloor>)", "by(rule sees_wf_mdecl)"], ["proof (state)\nthis:\n  wf_mdecl wf_J_mdecl P D (M, Ts, T, \\<lfloor>(pns, body)\\<rfloor>)\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (addr a)) ad -\n                             (int \\<circ> expr_locks (new C)) ad)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {}; sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt OutOfMemory)))\n                              ad -\n                             (int \\<circ> expr_locks (new C)) ad)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>convert_extTA\n                 extNTA,P,t \\<turnstile> \\<langle>e,\n    s\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow>\n        upd_expr_locks (\\<lambda>ad. 0)\n         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n        (\\<lambda>ad.\n            (int \\<circ> expr_locks e') ad - (int \\<circ> expr_locks e) ad);\n        sync_ok (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks (newA T\\<lfloor>e'\\<rceil>))\n                              ad -\n                             (int \\<circ>\n                              expr_locks (newA T\\<lfloor>e\\<rceil>))\n                              ad)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>NewHeapElem a\n       (Array_type T (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (addr a)) ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt NegativeArraySize)))\n                              ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt OutOfMemory)))\n                              ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>convert_extTA\n                 extNTA,P,t \\<turnstile> \\<langle>e,\n    s\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow>\n        upd_expr_locks (\\<lambda>ad. 0)\n         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n        (\\<lambda>ad.\n            (int \\<circ> expr_locks e') ad - (int \\<circ> expr_locks e) ad);\n        sync_ok (Cast C e)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (Cast C e')) ad -\n                             (int \\<circ> expr_locks (Cast C e)) ad)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (Val v)) ad -\n                             (int \\<circ> expr_locks (Cast T (Val v))) ad)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt ClassCast)))\n                              ad -\n                             (int \\<circ> expr_locks (Cast T (Val v))) ad)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>convert_extTA\n                  extNTA,P,t \\<turnstile> \\<langle>e,\n     s\\<rangle> -ta\\<rightarrow>\n    \\<langle>e',s'\\<rangle>;\n         sync_ok e \\<Longrightarrow>\n         upd_expr_locks (\\<lambda>ad. 0)\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n         (\\<lambda>ad.\n             (int \\<circ> expr_locks e') ad -\n             (int \\<circ> expr_locks e) ad);\n         sync_ok (e instanceof T)\\<rbrakk>\n        \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                          (\\<lambda>ad.\n                              (int \\<circ> expr_locks (e' instanceof T))\n                               ad -\n                              (int \\<circ> expr_locks (e instanceof T)) ad)\nA total of 98 subgoals...", "then"], ["proof (chain)\npicking this:\n  wf_mdecl wf_J_mdecl P D (M, Ts, T, \\<lfloor>(pns, body)\\<rfloor>)", "obtain T where \"P,[this\\<mapsto>Class D,pns[\\<mapsto>]Ts] \\<turnstile> body :: T\""], ["proof (prove)\nusing this:\n  wf_mdecl wf_J_mdecl P D (M, Ts, T, \\<lfloor>(pns, body)\\<rfloor>)\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        P,[this \\<mapsto> Class D, pns [\\<mapsto>]\n           Ts] \\<turnstile> body :: T \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: wf_mdecl_def)"], ["proof (state)\nthis:\n  P,[this \\<mapsto> Class D, pns [\\<mapsto>] Ts] \\<turnstile> body :: T\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (addr a)) ad -\n                             (int \\<circ> expr_locks (new C)) ad)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {}; sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt OutOfMemory)))\n                              ad -\n                             (int \\<circ> expr_locks (new C)) ad)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>convert_extTA\n                 extNTA,P,t \\<turnstile> \\<langle>e,\n    s\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow>\n        upd_expr_locks (\\<lambda>ad. 0)\n         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n        (\\<lambda>ad.\n            (int \\<circ> expr_locks e') ad - (int \\<circ> expr_locks e) ad);\n        sync_ok (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks (newA T\\<lfloor>e'\\<rceil>))\n                              ad -\n                             (int \\<circ>\n                              expr_locks (newA T\\<lfloor>e\\<rceil>))\n                              ad)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>NewHeapElem a\n       (Array_type T (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (addr a)) ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt NegativeArraySize)))\n                              ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt OutOfMemory)))\n                              ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>convert_extTA\n                 extNTA,P,t \\<turnstile> \\<langle>e,\n    s\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow>\n        upd_expr_locks (\\<lambda>ad. 0)\n         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n        (\\<lambda>ad.\n            (int \\<circ> expr_locks e') ad - (int \\<circ> expr_locks e) ad);\n        sync_ok (Cast C e)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (Cast C e')) ad -\n                             (int \\<circ> expr_locks (Cast C e)) ad)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (Val v)) ad -\n                             (int \\<circ> expr_locks (Cast T (Val v))) ad)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt ClassCast)))\n                              ad -\n                             (int \\<circ> expr_locks (Cast T (Val v))) ad)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>convert_extTA\n                  extNTA,P,t \\<turnstile> \\<langle>e,\n     s\\<rangle> -ta\\<rightarrow>\n    \\<langle>e',s'\\<rangle>;\n         sync_ok e \\<Longrightarrow>\n         upd_expr_locks (\\<lambda>ad. 0)\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n         (\\<lambda>ad.\n             (int \\<circ> expr_locks e') ad -\n             (int \\<circ> expr_locks e) ad);\n         sync_ok (e instanceof T)\\<rbrakk>\n        \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                          (\\<lambda>ad.\n                              (int \\<circ> expr_locks (e' instanceof T))\n                               ad -\n                              (int \\<circ> expr_locks (e instanceof T)) ad)\nA total of 98 subgoals...", "hence \"expr_locks body = (\\<lambda>ad. 0)\""], ["proof (prove)\nusing this:\n  P,[this \\<mapsto> Class D, pns [\\<mapsto>] Ts] \\<turnstile> body :: T\n\ngoal (1 subgoal):\n 1. expr_locks body = (\\<lambda>ad. 0)", "by(rule WT_expr_locks)"], ["proof (state)\nthis:\n  expr_locks body = (\\<lambda>ad. 0)\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (addr a)) ad -\n                             (int \\<circ> expr_locks (new C)) ad)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {}; sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt OutOfMemory)))\n                              ad -\n                             (int \\<circ> expr_locks (new C)) ad)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>convert_extTA\n                 extNTA,P,t \\<turnstile> \\<langle>e,\n    s\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow>\n        upd_expr_locks (\\<lambda>ad. 0)\n         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n        (\\<lambda>ad.\n            (int \\<circ> expr_locks e') ad - (int \\<circ> expr_locks e) ad);\n        sync_ok (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks (newA T\\<lfloor>e'\\<rceil>))\n                              ad -\n                             (int \\<circ>\n                              expr_locks (newA T\\<lfloor>e\\<rceil>))\n                              ad)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>NewHeapElem a\n       (Array_type T (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (addr a)) ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt NegativeArraySize)))\n                              ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt OutOfMemory)))\n                              ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>convert_extTA\n                 extNTA,P,t \\<turnstile> \\<langle>e,\n    s\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow>\n        upd_expr_locks (\\<lambda>ad. 0)\n         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n        (\\<lambda>ad.\n            (int \\<circ> expr_locks e') ad - (int \\<circ> expr_locks e) ad);\n        sync_ok (Cast C e)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (Cast C e')) ad -\n                             (int \\<circ> expr_locks (Cast C e)) ad)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (Val v)) ad -\n                             (int \\<circ> expr_locks (Cast T (Val v))) ad)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt ClassCast)))\n                              ad -\n                             (int \\<circ> expr_locks (Cast T (Val v))) ad)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>convert_extTA\n                  extNTA,P,t \\<turnstile> \\<langle>e,\n     s\\<rangle> -ta\\<rightarrow>\n    \\<langle>e',s'\\<rangle>;\n         sync_ok e \\<Longrightarrow>\n         upd_expr_locks (\\<lambda>ad. 0)\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n         (\\<lambda>ad.\n             (int \\<circ> expr_locks e') ad -\n             (int \\<circ> expr_locks e) ad);\n         sync_ok (e instanceof T)\\<rbrakk>\n        \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                          (\\<lambda>ad.\n                              (int \\<circ> expr_locks (e' instanceof T))\n                               ad -\n                              (int \\<circ> expr_locks (e instanceof T)) ad)\nA total of 98 subgoals...", "with \\<open>length vs = length pns\\<close> \\<open>length Ts = length pns\\<close>"], ["proof (chain)\npicking this:\n  length vs = length pns\n  length Ts = length pns\n  expr_locks body = (\\<lambda>ad. 0)", "have \"expr_locks (blocks pns Ts vs body) = (\\<lambda>ad. 0)\""], ["proof (prove)\nusing this:\n  length vs = length pns\n  length Ts = length pns\n  expr_locks body = (\\<lambda>ad. 0)\n\ngoal (1 subgoal):\n 1. expr_locks (blocks pns Ts vs body) = (\\<lambda>ad. 0)", "by(simp add: expr_locks_blocks)"], ["proof (state)\nthis:\n  expr_locks (blocks pns Ts vs body) = (\\<lambda>ad. 0)\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (addr a)) ad -\n                             (int \\<circ> expr_locks (new C)) ad)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {}; sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt OutOfMemory)))\n                              ad -\n                             (int \\<circ> expr_locks (new C)) ad)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>convert_extTA\n                 extNTA,P,t \\<turnstile> \\<langle>e,\n    s\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow>\n        upd_expr_locks (\\<lambda>ad. 0)\n         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n        (\\<lambda>ad.\n            (int \\<circ> expr_locks e') ad - (int \\<circ> expr_locks e) ad);\n        sync_ok (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks (newA T\\<lfloor>e'\\<rceil>))\n                              ad -\n                             (int \\<circ>\n                              expr_locks (newA T\\<lfloor>e\\<rceil>))\n                              ad)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>NewHeapElem a\n       (Array_type T (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (addr a)) ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt NegativeArraySize)))\n                              ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt OutOfMemory)))\n                              ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>convert_extTA\n                 extNTA,P,t \\<turnstile> \\<langle>e,\n    s\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow>\n        upd_expr_locks (\\<lambda>ad. 0)\n         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n        (\\<lambda>ad.\n            (int \\<circ> expr_locks e') ad - (int \\<circ> expr_locks e) ad);\n        sync_ok (Cast C e)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (Cast C e')) ad -\n                             (int \\<circ> expr_locks (Cast C e)) ad)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (Val v)) ad -\n                             (int \\<circ> expr_locks (Cast T (Val v))) ad)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt ClassCast)))\n                              ad -\n                             (int \\<circ> expr_locks (Cast T (Val v))) ad)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>convert_extTA\n                  extNTA,P,t \\<turnstile> \\<langle>e,\n     s\\<rangle> -ta\\<rightarrow>\n    \\<langle>e',s'\\<rangle>;\n         sync_ok e \\<Longrightarrow>\n         upd_expr_locks (\\<lambda>ad. 0)\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n         (\\<lambda>ad.\n             (int \\<circ> expr_locks e') ad -\n             (int \\<circ> expr_locks e) ad);\n         sync_ok (e instanceof T)\\<rbrakk>\n        \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                          (\\<lambda>ad.\n                              (int \\<circ> expr_locks (e' instanceof T))\n                               ad -\n                              (int \\<circ> expr_locks (e instanceof T)) ad)\nA total of 98 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  expr_locks (blocks pns Ts vs body) = (\\<lambda>ad. 0)\n\ngoal (1 subgoal):\n 1. upd_expr_locks (\\<lambda>ad. 0)\n     \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n    (\\<lambda>ad.\n        (int \\<circ>\n         expr_locks (blocks (this # pns) (Class D # Ts) (Addr a # vs) body))\n         ad -\n        (int \\<circ> expr_locks (addr a\\<bullet>M(map Val vs))) ad)", "by(auto intro: expr_locks_sync_ok)"], ["proof (state)\nthis:\n  upd_expr_locks (\\<lambda>ad. 0)\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n  (\\<lambda>ad.\n      (int \\<circ>\n       expr_locks (blocks (this # pns) (Class D # Ts) (Addr a # vs) body))\n       ad -\n      (int \\<circ> expr_locks (addr a\\<bullet>M(map Val vs))) ad)\n\ngoal (97 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (addr a)) ad -\n                             (int \\<circ> expr_locks (new C)) ad)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {}; sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt OutOfMemory)))\n                              ad -\n                             (int \\<circ> expr_locks (new C)) ad)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>convert_extTA\n                 extNTA,P,t \\<turnstile> \\<langle>e,\n    s\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow>\n        upd_expr_locks (\\<lambda>ad. 0)\n         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n        (\\<lambda>ad.\n            (int \\<circ> expr_locks e') ad - (int \\<circ> expr_locks e) ad);\n        sync_ok (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks (newA T\\<lfloor>e'\\<rceil>))\n                              ad -\n                             (int \\<circ>\n                              expr_locks (newA T\\<lfloor>e\\<rceil>))\n                              ad)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>NewHeapElem a\n       (Array_type T (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (addr a)) ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt NegativeArraySize)))\n                              ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt OutOfMemory)))\n                              ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>convert_extTA\n                 extNTA,P,t \\<turnstile> \\<langle>e,\n    s\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow>\n        upd_expr_locks (\\<lambda>ad. 0)\n         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n        (\\<lambda>ad.\n            (int \\<circ> expr_locks e') ad - (int \\<circ> expr_locks e) ad);\n        sync_ok (Cast C e)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (Cast C e')) ad -\n                             (int \\<circ> expr_locks (Cast C e)) ad)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (Val v)) ad -\n                             (int \\<circ> expr_locks (Cast T (Val v))) ad)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt ClassCast)))\n                              ad -\n                             (int \\<circ> expr_locks (Cast T (Val v))) ad)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>convert_extTA\n                  extNTA,P,t \\<turnstile> \\<langle>e,\n     s\\<rangle> -ta\\<rightarrow>\n    \\<langle>e',s'\\<rangle>;\n         sync_ok e \\<Longrightarrow>\n         upd_expr_locks (\\<lambda>ad. 0)\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n         (\\<lambda>ad.\n             (int \\<circ> expr_locks e') ad -\n             (int \\<circ> expr_locks e) ad);\n         sync_ok (e instanceof T)\\<rbrakk>\n        \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                          (\\<lambda>ad.\n                              (int \\<circ> expr_locks (e' instanceof T))\n                               ad -\n                              (int \\<circ> expr_locks (e instanceof T)) ad)\nA total of 97 subgoals...", "next"], ["proof (state)\ngoal (97 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (addr a)) ad -\n                             (int \\<circ> expr_locks (new C)) ad)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {}; sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt OutOfMemory)))\n                              ad -\n                             (int \\<circ> expr_locks (new C)) ad)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>convert_extTA\n                 extNTA,P,t \\<turnstile> \\<langle>e,\n    s\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow>\n        upd_expr_locks (\\<lambda>ad. 0)\n         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n        (\\<lambda>ad.\n            (int \\<circ> expr_locks e') ad - (int \\<circ> expr_locks e) ad);\n        sync_ok (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks (newA T\\<lfloor>e'\\<rceil>))\n                              ad -\n                             (int \\<circ>\n                              expr_locks (newA T\\<lfloor>e\\<rceil>))\n                              ad)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>NewHeapElem a\n       (Array_type T (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (addr a)) ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt NegativeArraySize)))\n                              ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt OutOfMemory)))\n                              ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>convert_extTA\n                 extNTA,P,t \\<turnstile> \\<langle>e,\n    s\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow>\n        upd_expr_locks (\\<lambda>ad. 0)\n         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n        (\\<lambda>ad.\n            (int \\<circ> expr_locks e') ad - (int \\<circ> expr_locks e) ad);\n        sync_ok (Cast C e)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (Cast C e')) ad -\n                             (int \\<circ> expr_locks (Cast C e)) ad)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (Val v)) ad -\n                             (int \\<circ> expr_locks (Cast T (Val v))) ad)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt ClassCast)))\n                              ad -\n                             (int \\<circ> expr_locks (Cast T (Val v))) ad)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>convert_extTA\n                  extNTA,P,t \\<turnstile> \\<langle>e,\n     s\\<rangle> -ta\\<rightarrow>\n    \\<langle>e',s'\\<rangle>;\n         sync_ok e \\<Longrightarrow>\n         upd_expr_locks (\\<lambda>ad. 0)\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n         (\\<lambda>ad.\n             (int \\<circ> expr_locks e') ad -\n             (int \\<circ> expr_locks e) ad);\n         sync_ok (e instanceof T)\\<rbrakk>\n        \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                          (\\<lambda>ad.\n                              (int \\<circ> expr_locks (e' instanceof T))\n                               ad -\n                              (int \\<circ> expr_locks (e instanceof T)) ad)\nA total of 97 subgoals...", "case RedCallExternal"], ["proof (state)\nthis:\n  typeof_addr (hp s_) a_ = \\<lfloor>hU_\\<rfloor>\n  P \\<turnstile> class_type_of\n                  hU_ sees M_: Ts_\\<rightarrow>T_ = Native in D_\n  P,t \\<turnstile> \\<langle>a_\\<bullet>M_(vs_),\n                   hp s_\\<rangle> -ta_\\<rightarrow>ext \\<langle>va_,\n                 h'_\\<rangle>\n  ta'_ = convert_extTA extNTA ta_\n  e'_ = extRet2J (addr a_\\<bullet>M_(map Val vs_)) va_\n  s'_ = (h'_, lcl s_)\n  sync_ok (addr a_\\<bullet>M_(map Val vs_))\n\ngoal (97 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (addr a)) ad -\n                             (int \\<circ> expr_locks (new C)) ad)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {}; sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt OutOfMemory)))\n                              ad -\n                             (int \\<circ> expr_locks (new C)) ad)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>convert_extTA\n                 extNTA,P,t \\<turnstile> \\<langle>e,\n    s\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow>\n        upd_expr_locks (\\<lambda>ad. 0)\n         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n        (\\<lambda>ad.\n            (int \\<circ> expr_locks e') ad - (int \\<circ> expr_locks e) ad);\n        sync_ok (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks (newA T\\<lfloor>e'\\<rceil>))\n                              ad -\n                             (int \\<circ>\n                              expr_locks (newA T\\<lfloor>e\\<rceil>))\n                              ad)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>NewHeapElem a\n       (Array_type T (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (addr a)) ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt NegativeArraySize)))\n                              ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt OutOfMemory)))\n                              ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>convert_extTA\n                 extNTA,P,t \\<turnstile> \\<langle>e,\n    s\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow>\n        upd_expr_locks (\\<lambda>ad. 0)\n         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n        (\\<lambda>ad.\n            (int \\<circ> expr_locks e') ad - (int \\<circ> expr_locks e) ad);\n        sync_ok (Cast C e)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (Cast C e')) ad -\n                             (int \\<circ> expr_locks (Cast C e)) ad)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (Val v)) ad -\n                             (int \\<circ> expr_locks (Cast T (Val v))) ad)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt ClassCast)))\n                              ad -\n                             (int \\<circ> expr_locks (Cast T (Val v))) ad)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>convert_extTA\n                  extNTA,P,t \\<turnstile> \\<langle>e,\n     s\\<rangle> -ta\\<rightarrow>\n    \\<langle>e',s'\\<rangle>;\n         sync_ok e \\<Longrightarrow>\n         upd_expr_locks (\\<lambda>ad. 0)\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n         (\\<lambda>ad.\n             (int \\<circ> expr_locks e') ad -\n             (int \\<circ> expr_locks e) ad);\n         sync_ok (e instanceof T)\\<rbrakk>\n        \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                          (\\<lambda>ad.\n                              (int \\<circ> expr_locks (e' instanceof T))\n                               ad -\n                              (int \\<circ> expr_locks (e instanceof T)) ad)\nA total of 97 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  typeof_addr (hp s_) a_ = \\<lfloor>hU_\\<rfloor>\n  P \\<turnstile> class_type_of\n                  hU_ sees M_: Ts_\\<rightarrow>T_ = Native in D_\n  P,t \\<turnstile> \\<langle>a_\\<bullet>M_(vs_),\n                   hp s_\\<rangle> -ta_\\<rightarrow>ext \\<langle>va_,\n                 h'_\\<rangle>\n  ta'_ = convert_extTA extNTA ta_\n  e'_ = extRet2J (addr a_\\<bullet>M_(map Val vs_)) va_\n  s'_ = (h'_, lcl s_)\n  sync_ok (addr a_\\<bullet>M_(map Val vs_))\n\ngoal (1 subgoal):\n 1. upd_expr_locks (\\<lambda>ad. 0)\n     \\<lbrace>ta'_\\<rbrace>\\<^bsub>l\\<^esub> =\n    (\\<lambda>ad.\n        (int \\<circ> expr_locks e'_) ad -\n        (int \\<circ> expr_locks (addr a_\\<bullet>M_(map Val vs_))) ad)", "by(auto simp add: fun_eq_iff contains_insync_conv contains_insyncs_conv finfun_upd_apply ta_upd_simps elim!: red_external.cases)"], ["proof (state)\nthis:\n  upd_expr_locks (\\<lambda>ad. 0) \\<lbrace>ta'_\\<rbrace>\\<^bsub>l\\<^esub> =\n  (\\<lambda>ad.\n      (int \\<circ> expr_locks e'_) ad -\n      (int \\<circ> expr_locks (addr a_\\<bullet>M_(map Val vs_))) ad)\n\ngoal (96 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (addr a)) ad -\n                             (int \\<circ> expr_locks (new C)) ad)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {}; sync_ok (new C)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt OutOfMemory)))\n                              ad -\n                             (int \\<circ> expr_locks (new C)) ad)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>convert_extTA\n                 extNTA,P,t \\<turnstile> \\<langle>e,\n    s\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow>\n        upd_expr_locks (\\<lambda>ad. 0)\n         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n        (\\<lambda>ad.\n            (int \\<circ> expr_locks e') ad - (int \\<circ> expr_locks e) ad);\n        sync_ok (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks (newA T\\<lfloor>e'\\<rceil>))\n                              ad -\n                             (int \\<circ>\n                              expr_locks (newA T\\<lfloor>e\\<rceil>))\n                              ad)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>NewHeapElem a\n       (Array_type T (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (addr a)) ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt NegativeArraySize)))\n                              ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt OutOfMemory)))\n                              ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>convert_extTA\n                 extNTA,P,t \\<turnstile> \\<langle>e,\n    s\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n        sync_ok e \\<Longrightarrow>\n        upd_expr_locks (\\<lambda>ad. 0)\n         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n        (\\<lambda>ad.\n            (int \\<circ> expr_locks e') ad - (int \\<circ> expr_locks e) ad);\n        sync_ok (Cast C e)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (Cast C e')) ad -\n                             (int \\<circ> expr_locks (Cast C e)) ad)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (Val v)) ad -\n                             (int \\<circ> expr_locks (Cast T (Val v))) ad)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt ClassCast)))\n                              ad -\n                             (int \\<circ> expr_locks (Cast T (Val v))) ad)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>convert_extTA\n                  extNTA,P,t \\<turnstile> \\<langle>e,\n     s\\<rangle> -ta\\<rightarrow>\n    \\<langle>e',s'\\<rangle>;\n         sync_ok e \\<Longrightarrow>\n         upd_expr_locks (\\<lambda>ad. 0)\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n         (\\<lambda>ad.\n             (int \\<circ> expr_locks e') ad -\n             (int \\<circ> expr_locks e) ad);\n         sync_ok (e instanceof T)\\<rbrakk>\n        \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                          (\\<lambda>ad.\n                              (int \\<circ> expr_locks (e' instanceof T))\n                               ad -\n                              (int \\<circ> expr_locks (e instanceof T)) ad)\nA total of 96 subgoals...", "qed(fastforce simp add: fun_eq_iff contains_insync_conv contains_insyncs_conv finfun_upd_apply ta_upd_simps)+"], ["proof (state)\nthis:\n  \\<lbrakk>convert_extTA\n            extNTA,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n   sync_ok e\\<rbrakk>\n  \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                    (\\<lambda>ad.\n                        (int \\<circ> expr_locks e') ad -\n                        (int \\<circ> expr_locks e) ad)\n  \\<lbrakk>convert_extTA\n            extNTA,P,t \\<turnstile> \\<langle>es,\n                                     s\\<rangle> [-ta\\<rightarrow>]\n                                    \\<langle>es',s'\\<rangle>;\n   sync_oks es\\<rbrakk>\n  \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                    (\\<lambda>ad.\n                        (int \\<circ> expr_lockss es') ad -\n                        (int \\<circ> expr_lockss es) ad)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_extTA\n              extNTA,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n     sync_ok e\\<rbrakk>\n    \\<Longrightarrow> upd_expr_locks (int \\<circ> expr_locks e)\n                       \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                      int \\<circ> expr_locks e'\n 2. \\<lbrakk>convert_extTA\n              extNTA,P,t \\<turnstile> \\<langle>es,\n s\\<rangle> [-ta\\<rightarrow>]\n\\<langle>es',s'\\<rangle>;\n     sync_oks es\\<rbrakk>\n    \\<Longrightarrow> upd_expr_locks (int \\<circ> expr_lockss es)\n                       \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                      int \\<circ> expr_lockss es'", "hence \"\\<lbrakk> convert_extTA extNTA,P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; sync_ok e \\<rbrakk>\n        \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0 + (int \\<circ> expr_locks e) ad) \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = int \\<circ> expr_locks e'\"\n    and \"\\<lbrakk> convert_extTA extNTA,P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; sync_oks es \\<rbrakk>\n        \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0 + (int \\<circ> expr_lockss es) ad) \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = int \\<circ> expr_lockss es'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>convert_extTA\n            extNTA,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n   sync_ok e\\<rbrakk>\n  \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                    (\\<lambda>ad.\n                        (int \\<circ> expr_locks e') ad -\n                        (int \\<circ> expr_locks e) ad)\n  \\<lbrakk>convert_extTA\n            extNTA,P,t \\<turnstile> \\<langle>es,\n                                     s\\<rangle> [-ta\\<rightarrow>]\n                                    \\<langle>es',s'\\<rangle>;\n   sync_oks es\\<rbrakk>\n  \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                    (\\<lambda>ad.\n                        (int \\<circ> expr_lockss es') ad -\n                        (int \\<circ> expr_lockss es) ad)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>convert_extTA\n               extNTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n      sync_ok e\\<rbrakk>\n     \\<Longrightarrow> upd_expr_locks\n                        (\\<lambda>ad. 0 + (int \\<circ> expr_locks e) ad)\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                       int \\<circ> expr_locks e') &&&\n    (\\<lbrakk>convert_extTA\n               extNTA,P,t \\<turnstile> \\<langle>es,\n  s\\<rangle> [-ta\\<rightarrow>]\n \\<langle>es',s'\\<rangle>;\n      sync_oks es\\<rbrakk>\n     \\<Longrightarrow> upd_expr_locks\n                        (\\<lambda>ad. 0 + (int \\<circ> expr_lockss es) ad)\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                       int \\<circ> expr_lockss es')", "by(auto intro: ext simp only: upd_expr_locks_add)"], ["proof (state)\nthis:\n  \\<lbrakk>convert_extTA\n            extNTA,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n   sync_ok e\\<rbrakk>\n  \\<Longrightarrow> upd_expr_locks\n                     (\\<lambda>ad. 0 + (int \\<circ> expr_locks e) ad)\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                    int \\<circ> expr_locks e'\n  \\<lbrakk>convert_extTA\n            extNTA,P,t \\<turnstile> \\<langle>es,\n                                     s\\<rangle> [-ta\\<rightarrow>]\n                                    \\<langle>es',s'\\<rangle>;\n   sync_oks es\\<rbrakk>\n  \\<Longrightarrow> upd_expr_locks\n                     (\\<lambda>ad. 0 + (int \\<circ> expr_lockss es) ad)\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                    int \\<circ> expr_lockss es'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_extTA\n              extNTA,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n     sync_ok e\\<rbrakk>\n    \\<Longrightarrow> upd_expr_locks (int \\<circ> expr_locks e)\n                       \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                      int \\<circ> expr_locks e'\n 2. \\<lbrakk>convert_extTA\n              extNTA,P,t \\<turnstile> \\<langle>es,\n s\\<rangle> [-ta\\<rightarrow>]\n\\<langle>es',s'\\<rangle>;\n     sync_oks es\\<rbrakk>\n    \\<Longrightarrow> upd_expr_locks (int \\<circ> expr_lockss es)\n                       \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                      int \\<circ> expr_lockss es'", "thus \"\\<lbrakk> convert_extTA extNTA,P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; sync_ok e \\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (int o expr_locks e) \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = int o expr_locks e'\"\n    and \"\\<lbrakk> convert_extTA extNTA,P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; sync_oks es \\<rbrakk>\n        \\<Longrightarrow> upd_expr_locks (int o expr_lockss es) \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = int o expr_lockss es'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>convert_extTA\n            extNTA,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n   sync_ok e\\<rbrakk>\n  \\<Longrightarrow> upd_expr_locks\n                     (\\<lambda>ad. 0 + (int \\<circ> expr_locks e) ad)\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                    int \\<circ> expr_locks e'\n  \\<lbrakk>convert_extTA\n            extNTA,P,t \\<turnstile> \\<langle>es,\n                                     s\\<rangle> [-ta\\<rightarrow>]\n                                    \\<langle>es',s'\\<rangle>;\n   sync_oks es\\<rbrakk>\n  \\<Longrightarrow> upd_expr_locks\n                     (\\<lambda>ad. 0 + (int \\<circ> expr_lockss es) ad)\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                    int \\<circ> expr_lockss es'\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>convert_extTA\n               extNTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n      sync_ok e\\<rbrakk>\n     \\<Longrightarrow> upd_expr_locks (int \\<circ> expr_locks e)\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                       int \\<circ> expr_locks e') &&&\n    (\\<lbrakk>convert_extTA\n               extNTA,P,t \\<turnstile> \\<langle>es,\n  s\\<rangle> [-ta\\<rightarrow>]\n \\<langle>es',s'\\<rangle>;\n      sync_oks es\\<rbrakk>\n     \\<Longrightarrow> upd_expr_locks (int \\<circ> expr_lockss es)\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                       int \\<circ> expr_lockss es')", "by(auto simp add: o_def)"], ["proof (state)\nthis:\n  \\<lbrakk>convert_extTA\n            extNTA,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n   sync_ok e\\<rbrakk>\n  \\<Longrightarrow> upd_expr_locks (int \\<circ> expr_locks e)\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                    int \\<circ> expr_locks e'\n  \\<lbrakk>convert_extTA\n            extNTA,P,t \\<turnstile> \\<langle>es,\n                                     s\\<rangle> [-ta\\<rightarrow>]\n                                    \\<langle>es',s'\\<rangle>;\n   sync_oks es\\<rbrakk>\n  \\<Longrightarrow> upd_expr_locks (int \\<circ> expr_lockss es)\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                    int \\<circ> expr_lockss es'\n\ngoal:\nNo subgoals!", "qed"], ["", "definition lock_expr_locks_ok :: \"'t FWState.lock \\<Rightarrow> 't \\<Rightarrow> nat \\<Rightarrow> int \\<Rightarrow> bool\" where\n  \"lock_expr_locks_ok l t n i \\<equiv> (i = int (has_locks l t) + int n) \\<and> i \\<ge> 0\""], ["", "lemma upd_lock_upd_expr_lock_action_preserve_lock_expr_locks_ok:\n  assumes lao: \"lock_action_ok l t L\"\n  and lelo: \"lock_expr_locks_ok l t n i\"\n  shows \"lock_expr_locks_ok (upd_lock l t L) t (upd_threadR n l t L) (upd_expr_lock_action i L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lock_expr_locks_ok (upd_lock l t L) t (upd_threadR n l t L)\n     (upd_expr_lock_action i L)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lock_expr_locks_ok (upd_lock l t L) t (upd_threadR n l t L)\n     (upd_expr_lock_action i L)", "from lelo"], ["proof (chain)\npicking this:\n  lock_expr_locks_ok l t n i", "have i: \"i \\<ge> 0\"\n    and hl: \"i = int (has_locks l t) + int n\""], ["proof (prove)\nusing this:\n  lock_expr_locks_ok l t n i\n\ngoal (1 subgoal):\n 1. 0 \\<le> i &&& i = int (has_locks l t) + int n", "by(auto simp add: lock_expr_locks_ok_def)"], ["proof (state)\nthis:\n  0 \\<le> i\n  i = int (has_locks l t) + int n\n\ngoal (1 subgoal):\n 1. lock_expr_locks_ok (upd_lock l t L) t (upd_threadR n l t L)\n     (upd_expr_lock_action i L)", "from lelo"], ["proof (chain)\npicking this:\n  lock_expr_locks_ok l t n i", "show ?thesis"], ["proof (prove)\nusing this:\n  lock_expr_locks_ok l t n i\n\ngoal (1 subgoal):\n 1. lock_expr_locks_ok (upd_lock l t L) t (upd_threadR n l t L)\n     (upd_expr_lock_action i L)", "proof(cases L)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>lock_expr_locks_ok l t n i; L = Lock\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)\n 2. \\<lbrakk>lock_expr_locks_ok l t n i; L = Unlock\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)\n 3. \\<lbrakk>lock_expr_locks_ok l t n i; L = UnlockFail\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)\n 4. \\<lbrakk>lock_expr_locks_ok l t n i; L = ReleaseAcquire\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)", "case Lock"], ["proof (state)\nthis:\n  L = Lock\n\ngoal (4 subgoals):\n 1. \\<lbrakk>lock_expr_locks_ok l t n i; L = Lock\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)\n 2. \\<lbrakk>lock_expr_locks_ok l t n i; L = Unlock\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)\n 3. \\<lbrakk>lock_expr_locks_ok l t n i; L = UnlockFail\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)\n 4. \\<lbrakk>lock_expr_locks_ok l t n i; L = ReleaseAcquire\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)", "with lao"], ["proof (chain)\npicking this:\n  lock_action_ok l t L\n  L = Lock", "have \"may_lock l t\""], ["proof (prove)\nusing this:\n  lock_action_ok l t L\n  L = Lock\n\ngoal (1 subgoal):\n 1. may_lock l t", "by(simp)"], ["proof (state)\nthis:\n  may_lock l t\n\ngoal (4 subgoals):\n 1. \\<lbrakk>lock_expr_locks_ok l t n i; L = Lock\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)\n 2. \\<lbrakk>lock_expr_locks_ok l t n i; L = Unlock\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)\n 3. \\<lbrakk>lock_expr_locks_ok l t n i; L = UnlockFail\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)\n 4. \\<lbrakk>lock_expr_locks_ok l t n i; L = ReleaseAcquire\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)", "with hl"], ["proof (chain)\npicking this:\n  i = int (has_locks l t) + int n\n  may_lock l t", "have \"has_locks (lock_lock l t) t = (Suc (has_locks l t))\""], ["proof (prove)\nusing this:\n  i = int (has_locks l t) + int n\n  may_lock l t\n\ngoal (1 subgoal):\n 1. has_locks (lock_lock l t) t = Suc (has_locks l t)", "by(auto)"], ["proof (state)\nthis:\n  has_locks (lock_lock l t) t = Suc (has_locks l t)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>lock_expr_locks_ok l t n i; L = Lock\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)\n 2. \\<lbrakk>lock_expr_locks_ok l t n i; L = Unlock\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)\n 3. \\<lbrakk>lock_expr_locks_ok l t n i; L = UnlockFail\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)\n 4. \\<lbrakk>lock_expr_locks_ok l t n i; L = ReleaseAcquire\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)", "with Lock i hl"], ["proof (chain)\npicking this:\n  L = Lock\n  0 \\<le> i\n  i = int (has_locks l t) + int n\n  has_locks (lock_lock l t) t = Suc (has_locks l t)", "show ?thesis"], ["proof (prove)\nusing this:\n  L = Lock\n  0 \\<le> i\n  i = int (has_locks l t) + int n\n  has_locks (lock_lock l t) t = Suc (has_locks l t)\n\ngoal (1 subgoal):\n 1. lock_expr_locks_ok (upd_lock l t L) t (upd_threadR n l t L)\n     (upd_expr_lock_action i L)", "by(simp add: lock_expr_locks_ok_def)"], ["proof (state)\nthis:\n  lock_expr_locks_ok (upd_lock l t L) t (upd_threadR n l t L)\n   (upd_expr_lock_action i L)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>lock_expr_locks_ok l t n i; L = Unlock\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)\n 2. \\<lbrakk>lock_expr_locks_ok l t n i; L = UnlockFail\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)\n 3. \\<lbrakk>lock_expr_locks_ok l t n i; L = ReleaseAcquire\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>lock_expr_locks_ok l t n i; L = Unlock\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)\n 2. \\<lbrakk>lock_expr_locks_ok l t n i; L = UnlockFail\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)\n 3. \\<lbrakk>lock_expr_locks_ok l t n i; L = ReleaseAcquire\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)", "case Unlock"], ["proof (state)\nthis:\n  L = Unlock\n\ngoal (3 subgoals):\n 1. \\<lbrakk>lock_expr_locks_ok l t n i; L = Unlock\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)\n 2. \\<lbrakk>lock_expr_locks_ok l t n i; L = UnlockFail\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)\n 3. \\<lbrakk>lock_expr_locks_ok l t n i; L = ReleaseAcquire\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)", "with lao"], ["proof (chain)\npicking this:\n  lock_action_ok l t L\n  L = Unlock", "have \"has_lock l t\""], ["proof (prove)\nusing this:\n  lock_action_ok l t L\n  L = Unlock\n\ngoal (1 subgoal):\n 1. has_lock l t", "by simp"], ["proof (state)\nthis:\n  has_lock l t\n\ngoal (3 subgoals):\n 1. \\<lbrakk>lock_expr_locks_ok l t n i; L = Unlock\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)\n 2. \\<lbrakk>lock_expr_locks_ok l t n i; L = UnlockFail\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)\n 3. \\<lbrakk>lock_expr_locks_ok l t n i; L = ReleaseAcquire\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)", "then"], ["proof (chain)\npicking this:\n  has_lock l t", "obtain n' \n      where hl': \"has_locks l t = Suc n'\""], ["proof (prove)\nusing this:\n  has_lock l t\n\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        has_locks l t = Suc n' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: has_lock_has_locks_Suc)"], ["proof (state)\nthis:\n  has_locks l t = Suc n'\n\ngoal (3 subgoals):\n 1. \\<lbrakk>lock_expr_locks_ok l t n i; L = Unlock\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)\n 2. \\<lbrakk>lock_expr_locks_ok l t n i; L = UnlockFail\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)\n 3. \\<lbrakk>lock_expr_locks_ok l t n i; L = ReleaseAcquire\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)", "hence \"has_locks (unlock_lock l) t = n'\""], ["proof (prove)\nusing this:\n  has_locks l t = Suc n'\n\ngoal (1 subgoal):\n 1. has_locks (unlock_lock l) t = n'", "by simp"], ["proof (state)\nthis:\n  has_locks (unlock_lock l) t = n'\n\ngoal (3 subgoals):\n 1. \\<lbrakk>lock_expr_locks_ok l t n i; L = Unlock\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)\n 2. \\<lbrakk>lock_expr_locks_ok l t n i; L = UnlockFail\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)\n 3. \\<lbrakk>lock_expr_locks_ok l t n i; L = ReleaseAcquire\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)", "with Unlock i hl hl'"], ["proof (chain)\npicking this:\n  L = Unlock\n  0 \\<le> i\n  i = int (has_locks l t) + int n\n  has_locks l t = Suc n'\n  has_locks (unlock_lock l) t = n'", "show ?thesis"], ["proof (prove)\nusing this:\n  L = Unlock\n  0 \\<le> i\n  i = int (has_locks l t) + int n\n  has_locks l t = Suc n'\n  has_locks (unlock_lock l) t = n'\n\ngoal (1 subgoal):\n 1. lock_expr_locks_ok (upd_lock l t L) t (upd_threadR n l t L)\n     (upd_expr_lock_action i L)", "by(simp add: lock_expr_locks_ok_def)"], ["proof (state)\nthis:\n  lock_expr_locks_ok (upd_lock l t L) t (upd_threadR n l t L)\n   (upd_expr_lock_action i L)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>lock_expr_locks_ok l t n i; L = UnlockFail\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)\n 2. \\<lbrakk>lock_expr_locks_ok l t n i; L = ReleaseAcquire\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_lock l t L) t\n                       (upd_threadR n l t L) (upd_expr_lock_action i L)", "qed(auto simp add: lock_expr_locks_ok_def)"], ["proof (state)\nthis:\n  lock_expr_locks_ok (upd_lock l t L) t (upd_threadR n l t L)\n   (upd_expr_lock_action i L)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma upd_locks_upd_expr_lock_preserve_lock_expr_locks_ok:\n  \"\\<lbrakk> lock_actions_ok l t Ls; lock_expr_locks_ok l t n i \\<rbrakk>\n  \\<Longrightarrow> lock_expr_locks_ok (upd_locks l t Ls) t (upd_threadRs n l t Ls) (upd_expr_lock_actions i Ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lock_actions_ok l t Ls; lock_expr_locks_ok l t n i\\<rbrakk>\n    \\<Longrightarrow> lock_expr_locks_ok (upd_locks l t Ls) t\n                       (upd_threadRs n l t Ls) (upd_expr_lock_actions i Ls)", "by(induct Ls arbitrary: l i n)(auto intro: upd_lock_upd_expr_lock_action_preserve_lock_expr_locks_ok)"], ["", "definition ls_els_ok :: \"('addr,'thread_id) locks \\<Rightarrow> 'thread_id \\<Rightarrow> ('addr \\<Rightarrow>f nat) \\<Rightarrow> ('addr \\<Rightarrow> int) \\<Rightarrow> bool\" where\n  \"\\<And>ln. ls_els_ok ls t ln els \\<equiv> \\<forall>l. lock_expr_locks_ok (ls $ l) t (ln $ l) (els l)\""], ["", "lemma ls_els_okI:\n  \"\\<And>ln. (\\<And>l. lock_expr_locks_ok (ls $ l) t (ln $ l) (els l)) \\<Longrightarrow> ls_els_ok ls t ln els\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln.\n       (\\<And>l.\n           lock_expr_locks_ok (ls $ l) t (ln $ l) (els l)) \\<Longrightarrow>\n       ls_els_ok ls t ln els", "by(auto simp add: ls_els_ok_def)"], ["", "lemma ls_els_okE:\n  \"\\<And>ln. \\<lbrakk> ls_els_ok ls t ln els; \\<forall>l. lock_expr_locks_ok (ls $ l) t (ln $ l) (els l) \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln.\n       \\<lbrakk>ls_els_ok ls t ln els;\n        \\<forall>l.\n           lock_expr_locks_ok (ls $ l) t (ln $ l) (els l) \\<Longrightarrow>\n        P\\<rbrakk>\n       \\<Longrightarrow> P", "by(auto simp add: ls_els_ok_def)"], ["", "lemma ls_els_okD:\n  \"\\<And>ln. ls_els_ok ls t ln els \\<Longrightarrow> lock_expr_locks_ok (ls $ l) t (ln $ l) (els l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln.\n       ls_els_ok ls t ln els \\<Longrightarrow>\n       lock_expr_locks_ok (ls $ l) t (ln $ l) (els l)", "by(auto simp add: ls_els_ok_def)"], ["", "lemma redT_updLs_upd_expr_locks_preserves_ls_els_ok:  \n \"\\<And>ln. \\<lbrakk> ls_els_ok ls t ln els; lock_ok_las ls t las \\<rbrakk>\n  \\<Longrightarrow> ls_els_ok (redT_updLs ls t las) t (redT_updLns ls t ln las) (upd_expr_locks els las)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln.\n       \\<lbrakk>ls_els_ok ls t ln els; lock_ok_las ls t las\\<rbrakk>\n       \\<Longrightarrow> ls_els_ok (redT_updLs ls t las) t\n                          (redT_updLns ls t ln las) (upd_expr_locks els las)", "by(auto intro!: ls_els_okI upd_locks_upd_expr_lock_preserve_lock_expr_locks_ok elim!: ls_els_okE simp add: redT_updLs_def lock_ok_las_def)"], ["", "lemma sync_ok_redT_updT: \n  assumes \"sync_es_ok ts h\"\n  and nt: \"\\<And>t e x h''. ta = NewThread t (e, x) h'' \\<Longrightarrow> sync_ok e\"\n  shows \"sync_es_ok (redT_updT ts ta) h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sync_es_ok (redT_updT ts ta) h'", "using assms"], ["proof (prove)\nusing this:\n  sync_es_ok ts h\n  ta = NewThread ?t (?e, ?x) ?h'' \\<Longrightarrow> sync_ok ?e\n\ngoal (1 subgoal):\n 1. sync_es_ok (redT_updT ts ta) h'", "proof(cases ta)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>sync_es_ok ts h;\n        \\<And>t e x h''.\n           ta = NewThread t (e, x) h'' \\<Longrightarrow> sync_ok e;\n        ta = NewThread x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> sync_es_ok (redT_updT ts ta) h'\n 2. \\<And>x21 x22.\n       \\<lbrakk>sync_es_ok ts h;\n        \\<And>t e x h''.\n           ta = NewThread t (e, x) h'' \\<Longrightarrow> sync_ok e;\n        ta = ThreadExists x21 x22\\<rbrakk>\n       \\<Longrightarrow> sync_es_ok (redT_updT ts ta) h'", "case (NewThread T x m)"], ["proof (state)\nthis:\n  ta = NewThread T x m\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>sync_es_ok ts h;\n        \\<And>t e x h''.\n           ta = NewThread t (e, x) h'' \\<Longrightarrow> sync_ok e;\n        ta = NewThread x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> sync_es_ok (redT_updT ts ta) h'\n 2. \\<And>x21 x22.\n       \\<lbrakk>sync_es_ok ts h;\n        \\<And>t e x h''.\n           ta = NewThread t (e, x) h'' \\<Longrightarrow> sync_ok e;\n        ta = ThreadExists x21 x22\\<rbrakk>\n       \\<Longrightarrow> sync_es_ok (redT_updT ts ta) h'", "obtain E X where [simp]: \"x = (E, X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>E X. x = (E, X) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases x, auto)"], ["proof (state)\nthis:\n  x = (E, X)\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>sync_es_ok ts h;\n        \\<And>t e x h''.\n           ta = NewThread t (e, x) h'' \\<Longrightarrow> sync_ok e;\n        ta = NewThread x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> sync_es_ok (redT_updT ts ta) h'\n 2. \\<And>x21 x22.\n       \\<lbrakk>sync_es_ok ts h;\n        \\<And>t e x h''.\n           ta = NewThread t (e, x) h'' \\<Longrightarrow> sync_ok e;\n        ta = ThreadExists x21 x22\\<rbrakk>\n       \\<Longrightarrow> sync_es_ok (redT_updT ts ta) h'", "with NewThread"], ["proof (chain)\npicking this:\n  ta = NewThread T x m\n  x = (E, X)", "have \"sync_ok E\""], ["proof (prove)\nusing this:\n  ta = NewThread T x m\n  x = (E, X)\n\ngoal (1 subgoal):\n 1. sync_ok E", "by(simp)(rule nt)"], ["proof (state)\nthis:\n  sync_ok E\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>sync_es_ok ts h;\n        \\<And>t e x h''.\n           ta = NewThread t (e, x) h'' \\<Longrightarrow> sync_ok e;\n        ta = NewThread x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> sync_es_ok (redT_updT ts ta) h'\n 2. \\<And>x21 x22.\n       \\<lbrakk>sync_es_ok ts h;\n        \\<And>t e x h''.\n           ta = NewThread t (e, x) h'' \\<Longrightarrow> sync_ok e;\n        ta = ThreadExists x21 x22\\<rbrakk>\n       \\<Longrightarrow> sync_es_ok (redT_updT ts ta) h'", "with NewThread \\<open>sync_es_ok ts h\\<close>"], ["proof (chain)\npicking this:\n  ta = NewThread T x m\n  sync_es_ok ts h\n  sync_ok E", "show ?thesis"], ["proof (prove)\nusing this:\n  ta = NewThread T x m\n  sync_es_ok ts h\n  sync_ok E\n\ngoal (1 subgoal):\n 1. sync_es_ok (redT_updT ts ta) h'", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ta = NewThread T x m; sync_es_ok ts h; sync_ok E\\<rbrakk>\n    \\<Longrightarrow> sync_es_ok (redT_updT ts ta) h'", "apply(rule ts_okI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t xa ln.\n       \\<lbrakk>ta = NewThread T x m; sync_es_ok ts h; sync_ok E;\n        redT_updT ts ta t = \\<lfloor>(xa, ln)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (case xa of\n                          (e, x) \\<Rightarrow> \\<lambda>m. sync_ok e)\n                          h'", "apply(case_tac \"t=T\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t xa ln.\n       \\<lbrakk>ta = NewThread T x m; sync_es_ok ts h; sync_ok E;\n        redT_updT ts ta t = \\<lfloor>(xa, ln)\\<rfloor>; t = T\\<rbrakk>\n       \\<Longrightarrow> (case xa of\n                          (e, x) \\<Rightarrow> \\<lambda>m. sync_ok e)\n                          h'\n 2. \\<And>t xa ln.\n       \\<lbrakk>ta = NewThread T x m; sync_es_ok ts h; sync_ok E;\n        redT_updT ts ta t = \\<lfloor>(xa, ln)\\<rfloor>;\n        t \\<noteq> T\\<rbrakk>\n       \\<Longrightarrow> (case xa of\n                          (e, x) \\<Rightarrow> \\<lambda>m. sync_ok e)\n                          h'", "by(auto dest: ts_okD)"], ["proof (state)\nthis:\n  sync_es_ok (redT_updT ts ta) h'\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>sync_es_ok ts h;\n        \\<And>t e x h''.\n           ta = NewThread t (e, x) h'' \\<Longrightarrow> sync_ok e;\n        ta = ThreadExists x21 x22\\<rbrakk>\n       \\<Longrightarrow> sync_es_ok (redT_updT ts ta) h'", "qed(auto intro: ts_okI dest: ts_okD)"], ["", "lemma sync_ok_redT_updTs: \n  \"\\<lbrakk> sync_es_ok ts h; \\<And>t e x h. NewThread t (e, x) h \\<in> set tas \\<Longrightarrow> sync_ok e \\<rbrakk>\n  \\<Longrightarrow> sync_es_ok (redT_updTs ts tas) h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sync_es_ok ts h;\n     \\<And>t e x h.\n        NewThread t (e, x) h \\<in> set tas \\<Longrightarrow>\n        sync_ok e\\<rbrakk>\n    \\<Longrightarrow> sync_es_ok (redT_updTs ts tas) h'", "proof(induct tas arbitrary: ts)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ts.\n       \\<lbrakk>sync_es_ok ts h;\n        \\<And>t e x h.\n           NewThread t (e, x) h \\<in> set [] \\<Longrightarrow>\n           sync_ok e\\<rbrakk>\n       \\<Longrightarrow> sync_es_ok (redT_updTs ts []) h'\n 2. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>sync_es_ok ts h;\n                    \\<And>t e x h.\n                       NewThread t (e, x) h \\<in> set tas \\<Longrightarrow>\n                       sync_ok e\\<rbrakk>\n                   \\<Longrightarrow> sync_es_ok (redT_updTs ts tas) h';\n        sync_es_ok ts h;\n        \\<And>t e x h.\n           NewThread t (e, x) h \\<in> set (a # tas) \\<Longrightarrow>\n           sync_ok e\\<rbrakk>\n       \\<Longrightarrow> sync_es_ok (redT_updTs ts (a # tas)) h'", "case Nil"], ["proof (state)\nthis:\n  sync_es_ok ts h\n  NewThread ?t (?e, ?x) ?h \\<in> set [] \\<Longrightarrow> sync_ok ?e\n\ngoal (2 subgoals):\n 1. \\<And>ts.\n       \\<lbrakk>sync_es_ok ts h;\n        \\<And>t e x h.\n           NewThread t (e, x) h \\<in> set [] \\<Longrightarrow>\n           sync_ok e\\<rbrakk>\n       \\<Longrightarrow> sync_es_ok (redT_updTs ts []) h'\n 2. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>sync_es_ok ts h;\n                    \\<And>t e x h.\n                       NewThread t (e, x) h \\<in> set tas \\<Longrightarrow>\n                       sync_ok e\\<rbrakk>\n                   \\<Longrightarrow> sync_es_ok (redT_updTs ts tas) h';\n        sync_es_ok ts h;\n        \\<And>t e x h.\n           NewThread t (e, x) h \\<in> set (a # tas) \\<Longrightarrow>\n           sync_ok e\\<rbrakk>\n       \\<Longrightarrow> sync_es_ok (redT_updTs ts (a # tas)) h'", "thus ?case"], ["proof (prove)\nusing this:\n  sync_es_ok ts h\n  NewThread ?t (?e, ?x) ?h \\<in> set [] \\<Longrightarrow> sync_ok ?e\n\ngoal (1 subgoal):\n 1. sync_es_ok (redT_updTs ts []) h'", "by(auto intro: ts_okI dest: ts_okD)"], ["proof (state)\nthis:\n  sync_es_ok (redT_updTs ts []) h'\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>sync_es_ok ts h;\n                    \\<And>t e x h.\n                       NewThread t (e, x) h \\<in> set tas \\<Longrightarrow>\n                       sync_ok e\\<rbrakk>\n                   \\<Longrightarrow> sync_es_ok (redT_updTs ts tas) h';\n        sync_es_ok ts h;\n        \\<And>t e x h.\n           NewThread t (e, x) h \\<in> set (a # tas) \\<Longrightarrow>\n           sync_ok e\\<rbrakk>\n       \\<Longrightarrow> sync_es_ok (redT_updTs ts (a # tas)) h'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>sync_es_ok ts h;\n                    \\<And>t e x h.\n                       NewThread t (e, x) h \\<in> set tas \\<Longrightarrow>\n                       sync_ok e\\<rbrakk>\n                   \\<Longrightarrow> sync_es_ok (redT_updTs ts tas) h';\n        sync_es_ok ts h;\n        \\<And>t e x h.\n           NewThread t (e, x) h \\<in> set (a # tas) \\<Longrightarrow>\n           sync_ok e\\<rbrakk>\n       \\<Longrightarrow> sync_es_ok (redT_updTs ts (a # tas)) h'", "case (Cons TA TAS TS)"], ["proof (state)\nthis:\n  \\<lbrakk>sync_es_ok ?ts h;\n   \\<And>t e x h.\n      NewThread t (e, x) h \\<in> set TAS \\<Longrightarrow>\n      sync_ok e\\<rbrakk>\n  \\<Longrightarrow> sync_es_ok (redT_updTs ?ts TAS) h'\n  sync_es_ok TS h\n  NewThread ?t (?e, ?x) ?h \\<in> set (TA # TAS) \\<Longrightarrow> sync_ok ?e\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>sync_es_ok ts h;\n                    \\<And>t e x h.\n                       NewThread t (e, x) h \\<in> set tas \\<Longrightarrow>\n                       sync_ok e\\<rbrakk>\n                   \\<Longrightarrow> sync_es_ok (redT_updTs ts tas) h';\n        sync_es_ok ts h;\n        \\<And>t e x h.\n           NewThread t (e, x) h \\<in> set (a # tas) \\<Longrightarrow>\n           sync_ok e\\<rbrakk>\n       \\<Longrightarrow> sync_es_ok (redT_updTs ts (a # tas)) h'", "note IH = \\<open>\\<And>ts. \\<lbrakk>sync_es_ok ts h; \\<And>t e x h''. NewThread t (e, x) h'' \\<in> set TAS \\<Longrightarrow> sync_ok e\\<rbrakk> \n            \\<Longrightarrow> sync_es_ok (redT_updTs ts TAS) h'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>sync_es_ok ?ts h;\n   \\<And>t e x h''.\n      NewThread t (e, x) h'' \\<in> set TAS \\<Longrightarrow>\n      sync_ok e\\<rbrakk>\n  \\<Longrightarrow> sync_es_ok (redT_updTs ?ts TAS) h'\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>sync_es_ok ts h;\n                    \\<And>t e x h.\n                       NewThread t (e, x) h \\<in> set tas \\<Longrightarrow>\n                       sync_ok e\\<rbrakk>\n                   \\<Longrightarrow> sync_es_ok (redT_updTs ts tas) h';\n        sync_es_ok ts h;\n        \\<And>t e x h.\n           NewThread t (e, x) h \\<in> set (a # tas) \\<Longrightarrow>\n           sync_ok e\\<rbrakk>\n       \\<Longrightarrow> sync_es_ok (redT_updTs ts (a # tas)) h'", "note nt = \\<open>\\<And>t e x h. NewThread t (e, x) h \\<in> set (TA # TAS) \\<Longrightarrow> sync_ok e\\<close>"], ["proof (state)\nthis:\n  NewThread ?t (?e, ?x) ?h \\<in> set (TA # TAS) \\<Longrightarrow> sync_ok ?e\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>sync_es_ok ts h;\n                    \\<And>t e x h.\n                       NewThread t (e, x) h \\<in> set tas \\<Longrightarrow>\n                       sync_ok e\\<rbrakk>\n                   \\<Longrightarrow> sync_es_ok (redT_updTs ts tas) h';\n        sync_es_ok ts h;\n        \\<And>t e x h.\n           NewThread t (e, x) h \\<in> set (a # tas) \\<Longrightarrow>\n           sync_ok e\\<rbrakk>\n       \\<Longrightarrow> sync_es_ok (redT_updTs ts (a # tas)) h'", "from \\<open>sync_es_ok TS h\\<close> nt"], ["proof (chain)\npicking this:\n  sync_es_ok TS h\n  NewThread ?t (?e, ?x) ?h \\<in> set (TA # TAS) \\<Longrightarrow> sync_ok ?e", "have \"sync_es_ok (redT_updT TS TA) h\""], ["proof (prove)\nusing this:\n  sync_es_ok TS h\n  NewThread ?t (?e, ?x) ?h \\<in> set (TA # TAS) \\<Longrightarrow> sync_ok ?e\n\ngoal (1 subgoal):\n 1. sync_es_ok (redT_updT TS TA) h", "by(auto elim!: sync_ok_redT_updT)"], ["proof (state)\nthis:\n  sync_es_ok (redT_updT TS TA) h\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>sync_es_ok ts h;\n                    \\<And>t e x h.\n                       NewThread t (e, x) h \\<in> set tas \\<Longrightarrow>\n                       sync_ok e\\<rbrakk>\n                   \\<Longrightarrow> sync_es_ok (redT_updTs ts tas) h';\n        sync_es_ok ts h;\n        \\<And>t e x h.\n           NewThread t (e, x) h \\<in> set (a # tas) \\<Longrightarrow>\n           sync_ok e\\<rbrakk>\n       \\<Longrightarrow> sync_es_ok (redT_updTs ts (a # tas)) h'", "hence \"sync_es_ok (redT_updTs (redT_updT TS TA) TAS) h'\""], ["proof (prove)\nusing this:\n  sync_es_ok (redT_updT TS TA) h\n\ngoal (1 subgoal):\n 1. sync_es_ok (redT_updTs (redT_updT TS TA) TAS) h'", "by(rule IH)(auto intro: nt)"], ["proof (state)\nthis:\n  sync_es_ok (redT_updTs (redT_updT TS TA) TAS) h'\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>sync_es_ok ts h;\n                    \\<And>t e x h.\n                       NewThread t (e, x) h \\<in> set tas \\<Longrightarrow>\n                       sync_ok e\\<rbrakk>\n                   \\<Longrightarrow> sync_es_ok (redT_updTs ts tas) h';\n        sync_es_ok ts h;\n        \\<And>t e x h.\n           NewThread t (e, x) h \\<in> set (a # tas) \\<Longrightarrow>\n           sync_ok e\\<rbrakk>\n       \\<Longrightarrow> sync_es_ok (redT_updTs ts (a # tas)) h'", "thus ?case"], ["proof (prove)\nusing this:\n  sync_es_ok (redT_updTs (redT_updT TS TA) TAS) h'\n\ngoal (1 subgoal):\n 1. sync_es_ok (redT_updTs TS (TA # TAS)) h'", "by simp"], ["proof (state)\nthis:\n  sync_es_ok (redT_updTs TS (TA # TAS)) h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lock_ok_thr_updI:\n  \"\\<And>ln. \\<lbrakk> lock_ok ls ts; ts t = \\<lfloor>((e, xs), ln)\\<rfloor>; expr_locks e = expr_locks e' \\<rbrakk>\n  \\<Longrightarrow> lock_ok ls (ts(t \\<mapsto> ((e', xs'), ln)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln.\n       \\<lbrakk>lock_ok ls ts; ts t = \\<lfloor>((e, xs), ln)\\<rfloor>;\n        expr_locks e = expr_locks e'\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls (ts(t \\<mapsto> ((e', xs'), ln)))", "by(rule lock_okI)(auto split: if_split_asm dest: lock_okD2 lock_okD1)"], ["", "context J_heap_base begin"], ["", "lemma redT_preserves_lock_ok:\n  assumes wf: \"wf_J_prog P\"\n  and \"P \\<turnstile> s -t\\<triangleright>ta\\<rightarrow> s'\"\n  and \"lock_ok (locks s) (thr s)\"\n  and \"sync_es_ok (thr s) (shr s)\"\n  shows \"lock_ok (locks s') (thr s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lock_ok (locks s') (thr s')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lock_ok (locks s') (thr s')", "obtain ls ts h ws \"is\" where s [simp]: \"s = (ls, (ts, h), ws, is)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ls ts h ws is.\n        s = (ls, (ts, h), ws, is) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases s) fastforce"], ["proof (state)\nthis:\n  s = (ls, (ts, h), ws, is)\n\ngoal (1 subgoal):\n 1. lock_ok (locks s') (thr s')", "obtain ls' ts' h' ws' is' where s' [simp]: \"s' = (ls', (ts', h'), ws', is')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ls' ts' h' ws' is'.\n        s' = (ls', (ts', h'), ws', is') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases s') fastforce"], ["proof (state)\nthis:\n  s' = (ls', (ts', h'), ws', is')\n\ngoal (1 subgoal):\n 1. lock_ok (locks s') (thr s')", "from assms"], ["proof (chain)\npicking this:\n  wf_J_prog P\n  P \\<turnstile> s -t\\<triangleright>ta\\<rightarrow> s'\n  lock_ok (locks s) (thr s)\n  sync_es_ok (thr s) (shr s)", "have redT: \"P \\<turnstile> (ls, (ts, h), ws, is) -t\\<triangleright>ta\\<rightarrow> (ls', (ts', h'), ws', is')\"\n    and loes: \"lock_ok ls ts\"\n    and aoes: \"sync_es_ok ts h\""], ["proof (prove)\nusing this:\n  wf_J_prog P\n  P \\<turnstile> s -t\\<triangleright>ta\\<rightarrow> s'\n  lock_ok (locks s) (thr s)\n  sync_es_ok (thr s) (shr s)\n\ngoal (1 subgoal):\n 1. red_mthr.redT_syntax2 P ls (ts, h) ws is t ta ls' (ts', h') ws' is' &&&\n    lock_ok ls ts &&& sync_es_ok ts h", "by auto"], ["proof (state)\nthis:\n  red_mthr.redT_syntax2 P ls (ts, h) ws is t ta ls' (ts', h') ws' is'\n  lock_ok ls ts\n  sync_es_ok ts h\n\ngoal (1 subgoal):\n 1. lock_ok (locks s') (thr s')", "from redT"], ["proof (chain)\npicking this:\n  red_mthr.redT_syntax2 P ls (ts, h) ws is t ta ls' (ts', h') ws' is'", "have \"lock_ok ls' ts'\""], ["proof (prove)\nusing this:\n  red_mthr.redT_syntax2 P ls (ts, h) ws is t ta ls' (ts', h') ws' is'\n\ngoal (1 subgoal):\n 1. lock_ok ls' ts'", "proof(cases rule: red_mthr.redT_elims)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x x' m' ws'a.\n       \\<lbrakk>red_mthr.r_syntax P t x (shr (ls, (ts, h), ws, is)) ta x'\n                 m';\n        thr (ls, (ts, h), ws, is) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks (ls, (ts, h), ws, is)) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n        red_mthr.cond_action_oks (ls, (ts, h), ws, is) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset (ls, (ts, h), ws, is)) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t (wset (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> ws'a;\n        (ls', (ts', h'), ws', is') =\n        (redT_updLs (locks (ls, (ts, h), ws, is)) t\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr (ls, (ts, h), ws, is))\n           \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n          (t \\<mapsto>\n          (x',\n           redT_updLns (locks (ls, (ts, h), ws, is)) t no_wait_locks\n            \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'),\n         ws'a,\n         redT_updIs (interrupts (ls, (ts, h), ws, is))\n          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls' ts'\n 2. \\<And>x ln n.\n       \\<lbrakk>thr (ls, (ts, h), ws, is) t = \\<lfloor>(x, ln)\\<rfloor>;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset (ls, (ts, h), ws, is) t);\n        may_acquire_all (locks (ls, (ts, h), ws, is)) t ln; 0 < ln $ n;\n        (ls', (ts', h'), ws', is') =\n        (acquire_all (locks (ls, (ts, h), ws, is)) t ln,\n         (thr (ls, (ts, h), ws, is)(t \\<mapsto> (x, no_wait_locks)),\n          shr (ls, (ts, h), ws, is)),\n         wset (ls, (ts, h), ws, is),\n         interrupts (ls, (ts, h), ws, is))\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls' ts'", "case (normal a a' m')"], ["proof (state)\nthis:\n  red_mthr.r_syntax P t a (shr (ls, (ts, h), ws, is)) ta a' m'\n  thr (ls, (ts, h), ws, is) t = \\<lfloor>(a, no_wait_locks)\\<rfloor>\n  lock_ok_las (locks (ls, (ts, h), ws, is)) t\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\n  thread_oks (thr (ls, (ts, h), ws, is))\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n  red_mthr.cond_action_oks (ls, (ts, h), ws, is) t\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>\n  wset_actions_ok (wset (ls, (ts, h), ws, is)) t\n   \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\n  interrupt_actions_ok (interrupts (ls, (ts, h), ws, is))\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n  redT_updWs t (wset (ls, (ts, h), ws, is))\n   \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> ws'_\n  (ls', (ts', h'), ws', is') =\n  (redT_updLs (locks (ls, (ts, h), ws, is)) t\n    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>,\n   (redT_updTs (thr (ls, (ts, h), ws, is))\n     \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n    (t \\<mapsto>\n    (a',\n     redT_updLns (locks (ls, (ts, h), ws, is)) t no_wait_locks\n      \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)),\n    m'),\n   ws'_,\n   redT_updIs (interrupts (ls, (ts, h), ws, is))\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>)\n\ngoal (2 subgoals):\n 1. \\<And>x x' m' ws'a.\n       \\<lbrakk>red_mthr.r_syntax P t x (shr (ls, (ts, h), ws, is)) ta x'\n                 m';\n        thr (ls, (ts, h), ws, is) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks (ls, (ts, h), ws, is)) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n        red_mthr.cond_action_oks (ls, (ts, h), ws, is) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset (ls, (ts, h), ws, is)) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t (wset (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> ws'a;\n        (ls', (ts', h'), ws', is') =\n        (redT_updLs (locks (ls, (ts, h), ws, is)) t\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr (ls, (ts, h), ws, is))\n           \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n          (t \\<mapsto>\n          (x',\n           redT_updLns (locks (ls, (ts, h), ws, is)) t no_wait_locks\n            \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'),\n         ws'a,\n         redT_updIs (interrupts (ls, (ts, h), ws, is))\n          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls' ts'\n 2. \\<And>x ln n.\n       \\<lbrakk>thr (ls, (ts, h), ws, is) t = \\<lfloor>(x, ln)\\<rfloor>;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset (ls, (ts, h), ws, is) t);\n        may_acquire_all (locks (ls, (ts, h), ws, is)) t ln; 0 < ln $ n;\n        (ls', (ts', h'), ws', is') =\n        (acquire_all (locks (ls, (ts, h), ws, is)) t ln,\n         (thr (ls, (ts, h), ws, is)(t \\<mapsto> (x, no_wait_locks)),\n          shr (ls, (ts, h), ws, is)),\n         wset (ls, (ts, h), ws, is),\n         interrupts (ls, (ts, h), ws, is))\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls' ts'", "moreover"], ["proof (state)\nthis:\n  red_mthr.r_syntax P t a (shr (ls, (ts, h), ws, is)) ta a' m'\n  thr (ls, (ts, h), ws, is) t = \\<lfloor>(a, no_wait_locks)\\<rfloor>\n  lock_ok_las (locks (ls, (ts, h), ws, is)) t\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\n  thread_oks (thr (ls, (ts, h), ws, is))\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n  red_mthr.cond_action_oks (ls, (ts, h), ws, is) t\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>\n  wset_actions_ok (wset (ls, (ts, h), ws, is)) t\n   \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\n  interrupt_actions_ok (interrupts (ls, (ts, h), ws, is))\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n  redT_updWs t (wset (ls, (ts, h), ws, is))\n   \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> ws'_\n  (ls', (ts', h'), ws', is') =\n  (redT_updLs (locks (ls, (ts, h), ws, is)) t\n    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>,\n   (redT_updTs (thr (ls, (ts, h), ws, is))\n     \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n    (t \\<mapsto>\n    (a',\n     redT_updLns (locks (ls, (ts, h), ws, is)) t no_wait_locks\n      \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)),\n    m'),\n   ws'_,\n   redT_updIs (interrupts (ls, (ts, h), ws, is))\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>)\n\ngoal (2 subgoals):\n 1. \\<And>x x' m' ws'a.\n       \\<lbrakk>red_mthr.r_syntax P t x (shr (ls, (ts, h), ws, is)) ta x'\n                 m';\n        thr (ls, (ts, h), ws, is) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks (ls, (ts, h), ws, is)) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n        red_mthr.cond_action_oks (ls, (ts, h), ws, is) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset (ls, (ts, h), ws, is)) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t (wset (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> ws'a;\n        (ls', (ts', h'), ws', is') =\n        (redT_updLs (locks (ls, (ts, h), ws, is)) t\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr (ls, (ts, h), ws, is))\n           \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n          (t \\<mapsto>\n          (x',\n           redT_updLns (locks (ls, (ts, h), ws, is)) t no_wait_locks\n            \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'),\n         ws'a,\n         redT_updIs (interrupts (ls, (ts, h), ws, is))\n          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls' ts'\n 2. \\<And>x ln n.\n       \\<lbrakk>thr (ls, (ts, h), ws, is) t = \\<lfloor>(x, ln)\\<rfloor>;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset (ls, (ts, h), ws, is) t);\n        may_acquire_all (locks (ls, (ts, h), ws, is)) t ln; 0 < ln $ n;\n        (ls', (ts', h'), ws', is') =\n        (acquire_all (locks (ls, (ts, h), ws, is)) t ln,\n         (thr (ls, (ts, h), ws, is)(t \\<mapsto> (x, no_wait_locks)),\n          shr (ls, (ts, h), ws, is)),\n         wset (ls, (ts, h), ws, is),\n         interrupts (ls, (ts, h), ws, is))\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls' ts'", "obtain e x where \"a = (e, x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e x. a = (e, x) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases a, auto)"], ["proof (state)\nthis:\n  a = (e, x)\n\ngoal (2 subgoals):\n 1. \\<And>x x' m' ws'a.\n       \\<lbrakk>red_mthr.r_syntax P t x (shr (ls, (ts, h), ws, is)) ta x'\n                 m';\n        thr (ls, (ts, h), ws, is) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks (ls, (ts, h), ws, is)) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n        red_mthr.cond_action_oks (ls, (ts, h), ws, is) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset (ls, (ts, h), ws, is)) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t (wset (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> ws'a;\n        (ls', (ts', h'), ws', is') =\n        (redT_updLs (locks (ls, (ts, h), ws, is)) t\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr (ls, (ts, h), ws, is))\n           \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n          (t \\<mapsto>\n          (x',\n           redT_updLns (locks (ls, (ts, h), ws, is)) t no_wait_locks\n            \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'),\n         ws'a,\n         redT_updIs (interrupts (ls, (ts, h), ws, is))\n          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls' ts'\n 2. \\<And>x ln n.\n       \\<lbrakk>thr (ls, (ts, h), ws, is) t = \\<lfloor>(x, ln)\\<rfloor>;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset (ls, (ts, h), ws, is) t);\n        may_acquire_all (locks (ls, (ts, h), ws, is)) t ln; 0 < ln $ n;\n        (ls', (ts', h'), ws', is') =\n        (acquire_all (locks (ls, (ts, h), ws, is)) t ln,\n         (thr (ls, (ts, h), ws, is)(t \\<mapsto> (x, no_wait_locks)),\n          shr (ls, (ts, h), ws, is)),\n         wset (ls, (ts, h), ws, is),\n         interrupts (ls, (ts, h), ws, is))\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls' ts'", "moreover"], ["proof (state)\nthis:\n  a = (e, x)\n\ngoal (2 subgoals):\n 1. \\<And>x x' m' ws'a.\n       \\<lbrakk>red_mthr.r_syntax P t x (shr (ls, (ts, h), ws, is)) ta x'\n                 m';\n        thr (ls, (ts, h), ws, is) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks (ls, (ts, h), ws, is)) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n        red_mthr.cond_action_oks (ls, (ts, h), ws, is) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset (ls, (ts, h), ws, is)) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t (wset (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> ws'a;\n        (ls', (ts', h'), ws', is') =\n        (redT_updLs (locks (ls, (ts, h), ws, is)) t\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr (ls, (ts, h), ws, is))\n           \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n          (t \\<mapsto>\n          (x',\n           redT_updLns (locks (ls, (ts, h), ws, is)) t no_wait_locks\n            \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'),\n         ws'a,\n         redT_updIs (interrupts (ls, (ts, h), ws, is))\n          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls' ts'\n 2. \\<And>x ln n.\n       \\<lbrakk>thr (ls, (ts, h), ws, is) t = \\<lfloor>(x, ln)\\<rfloor>;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset (ls, (ts, h), ws, is) t);\n        may_acquire_all (locks (ls, (ts, h), ws, is)) t ln; 0 < ln $ n;\n        (ls', (ts', h'), ws', is') =\n        (acquire_all (locks (ls, (ts, h), ws, is)) t ln,\n         (thr (ls, (ts, h), ws, is)(t \\<mapsto> (x, no_wait_locks)),\n          shr (ls, (ts, h), ws, is)),\n         wset (ls, (ts, h), ws, is),\n         interrupts (ls, (ts, h), ws, is))\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls' ts'", "obtain e' x' where \"a' = (e', x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e' x'. a' = (e', x') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases a', auto)"], ["proof (state)\nthis:\n  a' = (e', x')\n\ngoal (2 subgoals):\n 1. \\<And>x x' m' ws'a.\n       \\<lbrakk>red_mthr.r_syntax P t x (shr (ls, (ts, h), ws, is)) ta x'\n                 m';\n        thr (ls, (ts, h), ws, is) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks (ls, (ts, h), ws, is)) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n        red_mthr.cond_action_oks (ls, (ts, h), ws, is) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset (ls, (ts, h), ws, is)) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t (wset (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> ws'a;\n        (ls', (ts', h'), ws', is') =\n        (redT_updLs (locks (ls, (ts, h), ws, is)) t\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr (ls, (ts, h), ws, is))\n           \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n          (t \\<mapsto>\n          (x',\n           redT_updLns (locks (ls, (ts, h), ws, is)) t no_wait_locks\n            \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'),\n         ws'a,\n         redT_updIs (interrupts (ls, (ts, h), ws, is))\n          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls' ts'\n 2. \\<And>x ln n.\n       \\<lbrakk>thr (ls, (ts, h), ws, is) t = \\<lfloor>(x, ln)\\<rfloor>;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset (ls, (ts, h), ws, is) t);\n        may_acquire_all (locks (ls, (ts, h), ws, is)) t ln; 0 < ln $ n;\n        (ls', (ts', h'), ws', is') =\n        (acquire_all (locks (ls, (ts, h), ws, is)) t ln,\n         (thr (ls, (ts, h), ws, is)(t \\<mapsto> (x, no_wait_locks)),\n          shr (ls, (ts, h), ws, is)),\n         wset (ls, (ts, h), ws, is),\n         interrupts (ls, (ts, h), ws, is))\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls' ts'", "ultimately"], ["proof (chain)\npicking this:\n  red_mthr.r_syntax P t a (shr (ls, (ts, h), ws, is)) ta a' m'\n  thr (ls, (ts, h), ws, is) t = \\<lfloor>(a, no_wait_locks)\\<rfloor>\n  lock_ok_las (locks (ls, (ts, h), ws, is)) t\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\n  thread_oks (thr (ls, (ts, h), ws, is))\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n  red_mthr.cond_action_oks (ls, (ts, h), ws, is) t\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>\n  wset_actions_ok (wset (ls, (ts, h), ws, is)) t\n   \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\n  interrupt_actions_ok (interrupts (ls, (ts, h), ws, is))\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n  redT_updWs t (wset (ls, (ts, h), ws, is))\n   \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> ws'_\n  (ls', (ts', h'), ws', is') =\n  (redT_updLs (locks (ls, (ts, h), ws, is)) t\n    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>,\n   (redT_updTs (thr (ls, (ts, h), ws, is))\n     \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n    (t \\<mapsto>\n    (a',\n     redT_updLns (locks (ls, (ts, h), ws, is)) t no_wait_locks\n      \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)),\n    m'),\n   ws'_,\n   redT_updIs (interrupts (ls, (ts, h), ws, is))\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>)\n  a = (e, x)\n  a' = (e', x')", "have P: \"P,t \\<turnstile> \\<langle>e,(h, x)\\<rangle> -ta\\<rightarrow> \\<langle>e',(m', x')\\<rangle>\"\n      and est: \"ts t = \\<lfloor>((e, x), no_wait_locks)\\<rfloor>\"\n      and lota: \"lock_ok_las ls t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\"\n      and cctta: \"thread_oks ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\"\n      and ls': \"ls' = redT_updLs ls t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\"\n      and s': \"ts' = redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto> ((e', x'), redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>))\""], ["proof (prove)\nusing this:\n  red_mthr.r_syntax P t a (shr (ls, (ts, h), ws, is)) ta a' m'\n  thr (ls, (ts, h), ws, is) t = \\<lfloor>(a, no_wait_locks)\\<rfloor>\n  lock_ok_las (locks (ls, (ts, h), ws, is)) t\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\n  thread_oks (thr (ls, (ts, h), ws, is))\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n  red_mthr.cond_action_oks (ls, (ts, h), ws, is) t\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>\n  wset_actions_ok (wset (ls, (ts, h), ws, is)) t\n   \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\n  interrupt_actions_ok (interrupts (ls, (ts, h), ws, is))\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n  redT_updWs t (wset (ls, (ts, h), ws, is))\n   \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> ws'_\n  (ls', (ts', h'), ws', is') =\n  (redT_updLs (locks (ls, (ts, h), ws, is)) t\n    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>,\n   (redT_updTs (thr (ls, (ts, h), ws, is))\n     \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n    (t \\<mapsto>\n    (a',\n     redT_updLns (locks (ls, (ts, h), ws, is)) t no_wait_locks\n      \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)),\n    m'),\n   ws'_,\n   redT_updIs (interrupts (ls, (ts, h), ws, is))\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>)\n  a = (e, x)\n  a' = (e', x')\n\ngoal (1 subgoal):\n 1. (extTA2J\n      P,P,t \\<turnstile> \\<langle>e,(h, x)\\<rangle> -ta\\<rightarrow>\n                         \\<langle>e',(m', x')\\<rangle> &&&\n     ts t = \\<lfloor>((e, x), no_wait_locks)\\<rfloor> &&&\n     lock_ok_las ls t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>) &&&\n    thread_oks ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> &&&\n    ls' = redT_updLs ls t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> &&&\n    ts' = redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n    ((e', x'),\n     redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>))", "by auto"], ["proof (state)\nthis:\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e,(h, x)\\<rangle> -ta\\<rightarrow>\n                      \\<langle>e',(m', x')\\<rangle>\n  ts t = \\<lfloor>((e, x), no_wait_locks)\\<rfloor>\n  lock_ok_las ls t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\n  thread_oks ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n  ls' = redT_updLs ls t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\n  ts' = redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n  ((e', x'),\n   redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>))\n\ngoal (2 subgoals):\n 1. \\<And>x x' m' ws'a.\n       \\<lbrakk>red_mthr.r_syntax P t x (shr (ls, (ts, h), ws, is)) ta x'\n                 m';\n        thr (ls, (ts, h), ws, is) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks (ls, (ts, h), ws, is)) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n        red_mthr.cond_action_oks (ls, (ts, h), ws, is) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset (ls, (ts, h), ws, is)) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t (wset (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> ws'a;\n        (ls', (ts', h'), ws', is') =\n        (redT_updLs (locks (ls, (ts, h), ws, is)) t\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr (ls, (ts, h), ws, is))\n           \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n          (t \\<mapsto>\n          (x',\n           redT_updLns (locks (ls, (ts, h), ws, is)) t no_wait_locks\n            \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'),\n         ws'a,\n         redT_updIs (interrupts (ls, (ts, h), ws, is))\n          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls' ts'\n 2. \\<And>x ln n.\n       \\<lbrakk>thr (ls, (ts, h), ws, is) t = \\<lfloor>(x, ln)\\<rfloor>;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset (ls, (ts, h), ws, is) t);\n        may_acquire_all (locks (ls, (ts, h), ws, is)) t ln; 0 < ln $ n;\n        (ls', (ts', h'), ws', is') =\n        (acquire_all (locks (ls, (ts, h), ws, is)) t ln,\n         (thr (ls, (ts, h), ws, is)(t \\<mapsto> (x, no_wait_locks)),\n          shr (ls, (ts, h), ws, is)),\n         wset (ls, (ts, h), ws, is),\n         interrupts (ls, (ts, h), ws, is))\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls' ts'", "let ?ts' = \"redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto> ((e', x'), redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x x' m' ws'a.\n       \\<lbrakk>red_mthr.r_syntax P t x (shr (ls, (ts, h), ws, is)) ta x'\n                 m';\n        thr (ls, (ts, h), ws, is) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks (ls, (ts, h), ws, is)) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n        red_mthr.cond_action_oks (ls, (ts, h), ws, is) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset (ls, (ts, h), ws, is)) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t (wset (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> ws'a;\n        (ls', (ts', h'), ws', is') =\n        (redT_updLs (locks (ls, (ts, h), ws, is)) t\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr (ls, (ts, h), ws, is))\n           \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n          (t \\<mapsto>\n          (x',\n           redT_updLns (locks (ls, (ts, h), ws, is)) t no_wait_locks\n            \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'),\n         ws'a,\n         redT_updIs (interrupts (ls, (ts, h), ws, is))\n          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls' ts'\n 2. \\<And>x ln n.\n       \\<lbrakk>thr (ls, (ts, h), ws, is) t = \\<lfloor>(x, ln)\\<rfloor>;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset (ls, (ts, h), ws, is) t);\n        may_acquire_all (locks (ls, (ts, h), ws, is)) t ln; 0 < ln $ n;\n        (ls', (ts', h'), ws', is') =\n        (acquire_all (locks (ls, (ts, h), ws, is)) t ln,\n         (thr (ls, (ts, h), ws, is)(t \\<mapsto> (x, no_wait_locks)),\n          shr (ls, (ts, h), ws, is)),\n         wset (ls, (ts, h), ws, is),\n         interrupts (ls, (ts, h), ws, is))\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls' ts'", "from est aoes"], ["proof (chain)\npicking this:\n  ts t = \\<lfloor>((e, x), no_wait_locks)\\<rfloor>\n  sync_es_ok ts h", "have aoe: \"sync_ok e\""], ["proof (prove)\nusing this:\n  ts t = \\<lfloor>((e, x), no_wait_locks)\\<rfloor>\n  sync_es_ok ts h\n\ngoal (1 subgoal):\n 1. sync_ok e", "by(auto dest: ts_okD)"], ["proof (state)\nthis:\n  sync_ok e\n\ngoal (2 subgoals):\n 1. \\<And>x x' m' ws'a.\n       \\<lbrakk>red_mthr.r_syntax P t x (shr (ls, (ts, h), ws, is)) ta x'\n                 m';\n        thr (ls, (ts, h), ws, is) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks (ls, (ts, h), ws, is)) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n        red_mthr.cond_action_oks (ls, (ts, h), ws, is) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset (ls, (ts, h), ws, is)) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t (wset (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> ws'a;\n        (ls', (ts', h'), ws', is') =\n        (redT_updLs (locks (ls, (ts, h), ws, is)) t\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr (ls, (ts, h), ws, is))\n           \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n          (t \\<mapsto>\n          (x',\n           redT_updLns (locks (ls, (ts, h), ws, is)) t no_wait_locks\n            \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'),\n         ws'a,\n         redT_updIs (interrupts (ls, (ts, h), ws, is))\n          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls' ts'\n 2. \\<And>x ln n.\n       \\<lbrakk>thr (ls, (ts, h), ws, is) t = \\<lfloor>(x, ln)\\<rfloor>;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset (ls, (ts, h), ws, is) t);\n        may_acquire_all (locks (ls, (ts, h), ws, is)) t ln; 0 < ln $ n;\n        (ls', (ts', h'), ws', is') =\n        (acquire_all (locks (ls, (ts, h), ws, is)) t ln,\n         (thr (ls, (ts, h), ws, is)(t \\<mapsto> (x, no_wait_locks)),\n          shr (ls, (ts, h), ws, is)),\n         wset (ls, (ts, h), ws, is),\n         interrupts (ls, (ts, h), ws, is))\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls' ts'", "from aoe P"], ["proof (chain)\npicking this:\n  sync_ok e\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e,(h, x)\\<rangle> -ta\\<rightarrow>\n                      \\<langle>e',(m', x')\\<rangle>", "have aoe': \"sync_ok e'\""], ["proof (prove)\nusing this:\n  sync_ok e\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e,(h, x)\\<rangle> -ta\\<rightarrow>\n                      \\<langle>e',(m', x')\\<rangle>\n\ngoal (1 subgoal):\n 1. sync_ok e'", "by(auto dest: red_preserve_sync_ok[OF wf])"], ["proof (state)\nthis:\n  sync_ok e'\n\ngoal (2 subgoals):\n 1. \\<And>x x' m' ws'a.\n       \\<lbrakk>red_mthr.r_syntax P t x (shr (ls, (ts, h), ws, is)) ta x'\n                 m';\n        thr (ls, (ts, h), ws, is) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks (ls, (ts, h), ws, is)) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n        red_mthr.cond_action_oks (ls, (ts, h), ws, is) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset (ls, (ts, h), ws, is)) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t (wset (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> ws'a;\n        (ls', (ts', h'), ws', is') =\n        (redT_updLs (locks (ls, (ts, h), ws, is)) t\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr (ls, (ts, h), ws, is))\n           \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n          (t \\<mapsto>\n          (x',\n           redT_updLns (locks (ls, (ts, h), ws, is)) t no_wait_locks\n            \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'),\n         ws'a,\n         redT_updIs (interrupts (ls, (ts, h), ws, is))\n          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls' ts'\n 2. \\<And>x ln n.\n       \\<lbrakk>thr (ls, (ts, h), ws, is) t = \\<lfloor>(x, ln)\\<rfloor>;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset (ls, (ts, h), ws, is) t);\n        may_acquire_all (locks (ls, (ts, h), ws, is)) t ln; 0 < ln $ n;\n        (ls', (ts', h'), ws', is') =\n        (acquire_all (locks (ls, (ts, h), ws, is)) t ln,\n         (thr (ls, (ts, h), ws, is)(t \\<mapsto> (x, no_wait_locks)),\n          shr (ls, (ts, h), ws, is)),\n         wset (ls, (ts, h), ws, is),\n         interrupts (ls, (ts, h), ws, is))\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls' ts'", "from aoes red_new_thread_sync_ok[OF wf P]"], ["proof (chain)\npicking this:\n  sync_es_ok ts h\n  NewThread ?t'' (?e'', ?x'') ?h''\n  \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n  sync_ok ?e''", "have \"sync_es_ok (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) h'\""], ["proof (prove)\nusing this:\n  sync_es_ok ts h\n  NewThread ?t'' (?e'', ?x'') ?h''\n  \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n  sync_ok ?e''\n\ngoal (1 subgoal):\n 1. sync_es_ok (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) h'", "by(rule sync_ok_redT_updTs)"], ["proof (state)\nthis:\n  sync_es_ok (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) h'\n\ngoal (2 subgoals):\n 1. \\<And>x x' m' ws'a.\n       \\<lbrakk>red_mthr.r_syntax P t x (shr (ls, (ts, h), ws, is)) ta x'\n                 m';\n        thr (ls, (ts, h), ws, is) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks (ls, (ts, h), ws, is)) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n        red_mthr.cond_action_oks (ls, (ts, h), ws, is) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset (ls, (ts, h), ws, is)) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t (wset (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> ws'a;\n        (ls', (ts', h'), ws', is') =\n        (redT_updLs (locks (ls, (ts, h), ws, is)) t\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr (ls, (ts, h), ws, is))\n           \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n          (t \\<mapsto>\n          (x',\n           redT_updLns (locks (ls, (ts, h), ws, is)) t no_wait_locks\n            \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'),\n         ws'a,\n         redT_updIs (interrupts (ls, (ts, h), ws, is))\n          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls' ts'\n 2. \\<And>x ln n.\n       \\<lbrakk>thr (ls, (ts, h), ws, is) t = \\<lfloor>(x, ln)\\<rfloor>;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset (ls, (ts, h), ws, is) t);\n        may_acquire_all (locks (ls, (ts, h), ws, is)) t ln; 0 < ln $ n;\n        (ls', (ts', h'), ws', is') =\n        (acquire_all (locks (ls, (ts, h), ws, is)) t ln,\n         (thr (ls, (ts, h), ws, is)(t \\<mapsto> (x, no_wait_locks)),\n          shr (ls, (ts, h), ws, is)),\n         wset (ls, (ts, h), ws, is),\n         interrupts (ls, (ts, h), ws, is))\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls' ts'", "with aoe'"], ["proof (chain)\npicking this:\n  sync_ok e'\n  sync_es_ok (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) h'", "have aoes': \"sync_es_ok ?ts' m'\""], ["proof (prove)\nusing this:\n  sync_ok e'\n  sync_es_ok (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) h'\n\ngoal (1 subgoal):\n 1. sync_es_ok\n     (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n      ((e', x'),\n       redT_updLns ls t no_wait_locks\n        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n     m'", "by(auto intro!: ts_okI dest: ts_okD split: if_split_asm)"], ["proof (state)\nthis:\n  sync_es_ok\n   (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n    ((e', x'),\n     redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n   m'\n\ngoal (2 subgoals):\n 1. \\<And>x x' m' ws'a.\n       \\<lbrakk>red_mthr.r_syntax P t x (shr (ls, (ts, h), ws, is)) ta x'\n                 m';\n        thr (ls, (ts, h), ws, is) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks (ls, (ts, h), ws, is)) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n        red_mthr.cond_action_oks (ls, (ts, h), ws, is) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset (ls, (ts, h), ws, is)) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t (wset (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> ws'a;\n        (ls', (ts', h'), ws', is') =\n        (redT_updLs (locks (ls, (ts, h), ws, is)) t\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr (ls, (ts, h), ws, is))\n           \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n          (t \\<mapsto>\n          (x',\n           redT_updLns (locks (ls, (ts, h), ws, is)) t no_wait_locks\n            \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'),\n         ws'a,\n         redT_updIs (interrupts (ls, (ts, h), ws, is))\n          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls' ts'\n 2. \\<And>x ln n.\n       \\<lbrakk>thr (ls, (ts, h), ws, is) t = \\<lfloor>(x, ln)\\<rfloor>;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset (ls, (ts, h), ws, is) t);\n        may_acquire_all (locks (ls, (ts, h), ws, is)) t ln; 0 < ln $ n;\n        (ls', (ts', h'), ws', is') =\n        (acquire_all (locks (ls, (ts, h), ws, is)) t ln,\n         (thr (ls, (ts, h), ws, is)(t \\<mapsto> (x, no_wait_locks)),\n          shr (ls, (ts, h), ws, is)),\n         wset (ls, (ts, h), ws, is),\n         interrupts (ls, (ts, h), ws, is))\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls' ts'", "have \"lock_ok ls' ?ts'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lock_ok ls'\n     (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n      ((e', x'),\n       redT_updLns ls t no_wait_locks\n        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))", "proof(rule lock_okI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>tb l.\n       (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n        ((e', x'),\n         redT_updLns ls t no_wait_locks\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n        tb =\n       None \\<Longrightarrow>\n       has_locks (ls' $ l) tb = 0\n 2. \\<And>tb e x ln l.\n       (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n        ((e', x'),\n         redT_updLns ls t no_wait_locks\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n        tb =\n       \\<lfloor>((e, x), ln)\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) tb + ln $ l = expr_locks e l", "fix t'' l"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>tb l.\n       (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n        ((e', x'),\n         redT_updLns ls t no_wait_locks\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n        tb =\n       None \\<Longrightarrow>\n       has_locks (ls' $ l) tb = 0\n 2. \\<And>tb e x ln l.\n       (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n        ((e', x'),\n         redT_updLns ls t no_wait_locks\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n        tb =\n       \\<lfloor>((e, x), ln)\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) tb + ln $ l = expr_locks e l", "assume \"?ts' t'' = None\""], ["proof (state)\nthis:\n  (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n   ((e', x'),\n    redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n   t'' =\n  None\n\ngoal (2 subgoals):\n 1. \\<And>tb l.\n       (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n        ((e', x'),\n         redT_updLns ls t no_wait_locks\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n        tb =\n       None \\<Longrightarrow>\n       has_locks (ls' $ l) tb = 0\n 2. \\<And>tb e x ln l.\n       (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n        ((e', x'),\n         redT_updLns ls t no_wait_locks\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n        tb =\n       \\<lfloor>((e, x), ln)\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) tb + ln $ l = expr_locks e l", "hence \"ts t'' = None\""], ["proof (prove)\nusing this:\n  (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n   ((e', x'),\n    redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n   t'' =\n  None\n\ngoal (1 subgoal):\n 1. ts t'' = None", "by(auto split: if_split_asm intro: redT_updTs_None)"], ["proof (state)\nthis:\n  ts t'' = None\n\ngoal (2 subgoals):\n 1. \\<And>tb l.\n       (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n        ((e', x'),\n         redT_updLns ls t no_wait_locks\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n        tb =\n       None \\<Longrightarrow>\n       has_locks (ls' $ l) tb = 0\n 2. \\<And>tb e x ln l.\n       (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n        ((e', x'),\n         redT_updLns ls t no_wait_locks\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n        tb =\n       \\<lfloor>((e, x), ln)\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) tb + ln $ l = expr_locks e l", "with loes"], ["proof (chain)\npicking this:\n  lock_ok ls ts\n  ts t'' = None", "have \"has_locks (ls $ l) t'' = 0\""], ["proof (prove)\nusing this:\n  lock_ok ls ts\n  ts t'' = None\n\ngoal (1 subgoal):\n 1. has_locks (ls $ l) t'' = 0", "by(auto dest: lock_okD1)"], ["proof (state)\nthis:\n  has_locks (ls $ l) t'' = 0\n\ngoal (2 subgoals):\n 1. \\<And>tb l.\n       (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n        ((e', x'),\n         redT_updLns ls t no_wait_locks\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n        tb =\n       None \\<Longrightarrow>\n       has_locks (ls' $ l) tb = 0\n 2. \\<And>tb e x ln l.\n       (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n        ((e', x'),\n         redT_updLns ls t no_wait_locks\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n        tb =\n       \\<lfloor>((e, x), ln)\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) tb + ln $ l = expr_locks e l", "moreover"], ["proof (state)\nthis:\n  has_locks (ls $ l) t'' = 0\n\ngoal (2 subgoals):\n 1. \\<And>tb l.\n       (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n        ((e', x'),\n         redT_updLns ls t no_wait_locks\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n        tb =\n       None \\<Longrightarrow>\n       has_locks (ls' $ l) tb = 0\n 2. \\<And>tb e x ln l.\n       (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n        ((e', x'),\n         redT_updLns ls t no_wait_locks\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n        tb =\n       \\<lfloor>((e, x), ln)\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) tb + ln $ l = expr_locks e l", "from \\<open>?ts' t'' = None\\<close>"], ["proof (chain)\npicking this:\n  (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n   ((e', x'),\n    redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n   t'' =\n  None", "have \"t \\<noteq> t''\""], ["proof (prove)\nusing this:\n  (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n   ((e', x'),\n    redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n   t'' =\n  None\n\ngoal (1 subgoal):\n 1. t \\<noteq> t''", "by(simp split: if_split_asm)"], ["proof (state)\nthis:\n  t \\<noteq> t''\n\ngoal (2 subgoals):\n 1. \\<And>tb l.\n       (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n        ((e', x'),\n         redT_updLns ls t no_wait_locks\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n        tb =\n       None \\<Longrightarrow>\n       has_locks (ls' $ l) tb = 0\n 2. \\<And>tb e x ln l.\n       (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n        ((e', x'),\n         redT_updLns ls t no_wait_locks\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n        tb =\n       \\<lfloor>((e, x), ln)\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) tb + ln $ l = expr_locks e l", "ultimately"], ["proof (chain)\npicking this:\n  has_locks (ls $ l) t'' = 0\n  t \\<noteq> t''", "show \"has_locks (ls' $ l) t'' = 0\""], ["proof (prove)\nusing this:\n  has_locks (ls $ l) t'' = 0\n  t \\<noteq> t''\n\ngoal (1 subgoal):\n 1. has_locks (ls' $ l) t'' = 0", "by(simp add: red_mthr.redT_has_locks_inv[OF redT])"], ["proof (state)\nthis:\n  has_locks (ls' $ l) t'' = 0\n\ngoal (1 subgoal):\n 1. \\<And>tb e x ln l.\n       (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n        ((e', x'),\n         redT_updLns ls t no_wait_locks\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n        tb =\n       \\<lfloor>((e, x), ln)\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) tb + ln $ l = expr_locks e l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>tb e x ln l.\n       (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n        ((e', x'),\n         redT_updLns ls t no_wait_locks\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n        tb =\n       \\<lfloor>((e, x), ln)\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) tb + ln $ l = expr_locks e l", "fix t'' e'' x'' l ln''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>tb e x ln l.\n       (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n        ((e', x'),\n         redT_updLns ls t no_wait_locks\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n        tb =\n       \\<lfloor>((e, x), ln)\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) tb + ln $ l = expr_locks e l", "assume ts't'': \"?ts' t'' = \\<lfloor>((e'', x''), ln'')\\<rfloor>\""], ["proof (state)\nthis:\n  (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n   ((e', x'),\n    redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n   t'' =\n  \\<lfloor>((e'', x''), ln'')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>tb e x ln l.\n       (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n        ((e', x'),\n         redT_updLns ls t no_wait_locks\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n        tb =\n       \\<lfloor>((e, x), ln)\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) tb + ln $ l = expr_locks e l", "with aoes'"], ["proof (chain)\npicking this:\n  sync_es_ok\n   (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n    ((e', x'),\n     redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n   m'\n  (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n   ((e', x'),\n    redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n   t'' =\n  \\<lfloor>((e'', x''), ln'')\\<rfloor>", "have aoe'': \"sync_ok e''\""], ["proof (prove)\nusing this:\n  sync_es_ok\n   (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n    ((e', x'),\n     redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n   m'\n  (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n   ((e', x'),\n    redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n   t'' =\n  \\<lfloor>((e'', x''), ln'')\\<rfloor>\n\ngoal (1 subgoal):\n 1. sync_ok e''", "by(auto dest: ts_okD)"], ["proof (state)\nthis:\n  sync_ok e''\n\ngoal (1 subgoal):\n 1. \\<And>tb e x ln l.\n       (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n        ((e', x'),\n         redT_updLns ls t no_wait_locks\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n        tb =\n       \\<lfloor>((e, x), ln)\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) tb + ln $ l = expr_locks e l", "show \"has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "proof(cases \"t = t''\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t = t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n 2. t \\<noteq> t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "case True"], ["proof (state)\nthis:\n  t = t''\n\ngoal (2 subgoals):\n 1. t = t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n 2. t \\<noteq> t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "note tt'' = \\<open>t = t''\\<close>"], ["proof (state)\nthis:\n  t = t''\n\ngoal (2 subgoals):\n 1. t = t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n 2. t \\<noteq> t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "with ts't''"], ["proof (chain)\npicking this:\n  (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n   ((e', x'),\n    redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n   t'' =\n  \\<lfloor>((e'', x''), ln'')\\<rfloor>\n  t = t''", "have  e'': \"e'' = e'\" and x'': \"x'' = x'\"\n          and ln'': \"ln'' = redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\""], ["proof (prove)\nusing this:\n  (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n   ((e', x'),\n    redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n   t'' =\n  \\<lfloor>((e'', x''), ln'')\\<rfloor>\n  t = t''\n\ngoal (1 subgoal):\n 1. e'' = e' &&&\n    x'' = x' &&&\n    ln'' =\n    redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>", "by auto"], ["proof (state)\nthis:\n  e'' = e'\n  x'' = x'\n  ln'' =\n  redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\n\ngoal (2 subgoals):\n 1. t = t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n 2. t \\<noteq> t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "have \"ls_els_ok ls t no_wait_locks (int o expr_locks e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ls_els_ok ls t no_wait_locks (int \\<circ> expr_locks e)", "proof(rule ls_els_okI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       lock_expr_locks_ok (ls $ l) t (no_wait_locks $ l)\n        ((int \\<circ> expr_locks e) l)", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       lock_expr_locks_ok (ls $ l) t (no_wait_locks $ l)\n        ((int \\<circ> expr_locks e) l)", "note lock_okD2[OF loes, OF est]"], ["proof (state)\nthis:\n  \\<forall>l. has_locks (ls $ l) t + no_wait_locks $ l = expr_locks e l\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       lock_expr_locks_ok (ls $ l) t (no_wait_locks $ l)\n        ((int \\<circ> expr_locks e) l)", "thus \"lock_expr_locks_ok (ls $ l) t (no_wait_locks $ l) ((int \\<circ> expr_locks e) l)\""], ["proof (prove)\nusing this:\n  \\<forall>l. has_locks (ls $ l) t + no_wait_locks $ l = expr_locks e l\n\ngoal (1 subgoal):\n 1. lock_expr_locks_ok (ls $ l) t (no_wait_locks $ l)\n     ((int \\<circ> expr_locks e) l)", "by(simp add: lock_expr_locks_ok_def)"], ["proof (state)\nthis:\n  lock_expr_locks_ok (ls $ l) t (no_wait_locks $ l)\n   ((int \\<circ> expr_locks e) l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ls_els_ok ls t no_wait_locks (int \\<circ> expr_locks e)\n\ngoal (2 subgoals):\n 1. t = t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n 2. t \\<noteq> t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "hence \"ls_els_ok (redT_updLs ls t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>) t (redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>) (upd_expr_locks (int o expr_locks e) \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)\""], ["proof (prove)\nusing this:\n  ls_els_ok ls t no_wait_locks (int \\<circ> expr_locks e)\n\ngoal (1 subgoal):\n 1. ls_els_ok (redT_updLs ls t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>) t\n     (redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)\n     (upd_expr_locks (int \\<circ> expr_locks e)\n       \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)", "by(rule redT_updLs_upd_expr_locks_preserves_ls_els_ok[OF _ lota])"], ["proof (state)\nthis:\n  ls_els_ok (redT_updLs ls t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>) t\n   (redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)\n   (upd_expr_locks (int \\<circ> expr_locks e)\n     \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)\n\ngoal (2 subgoals):\n 1. t = t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n 2. t \\<noteq> t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "hence \"ls_els_ok (redT_updLs ls t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>) t (redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>) (int o expr_locks e')\""], ["proof (prove)\nusing this:\n  ls_els_ok (redT_updLs ls t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>) t\n   (redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)\n   (upd_expr_locks (int \\<circ> expr_locks e)\n     \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)\n\ngoal (1 subgoal):\n 1. ls_els_ok (redT_updLs ls t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>) t\n     (redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)\n     (int \\<circ> expr_locks e')", "by(simp only: red_update_expr_locks[OF wf P aoe])"], ["proof (state)\nthis:\n  ls_els_ok (redT_updLs ls t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>) t\n   (redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)\n   (int \\<circ> expr_locks e')\n\ngoal (2 subgoals):\n 1. t = t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n 2. t \\<noteq> t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "thus ?thesis"], ["proof (prove)\nusing this:\n  ls_els_ok (redT_updLs ls t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>) t\n   (redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)\n   (int \\<circ> expr_locks e')\n\ngoal (1 subgoal):\n 1. has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "using ls' e'' tt'' ln''"], ["proof (prove)\nusing this:\n  ls_els_ok (redT_updLs ls t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>) t\n   (redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)\n   (int \\<circ> expr_locks e')\n  ls' = redT_updLs ls t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\n  e'' = e'\n  t = t''\n  ln'' =\n  redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\n\ngoal (1 subgoal):\n 1. has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "by(auto dest: ls_els_okD[where l = l] simp: lock_expr_locks_ok_def)"], ["proof (state)\nthis:\n  has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n\ngoal (1 subgoal):\n 1. t \\<noteq> t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<noteq> t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "case False"], ["proof (state)\nthis:\n  t \\<noteq> t''\n\ngoal (1 subgoal):\n 1. t \\<noteq> t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "note tt'' = \\<open>t \\<noteq> t''\\<close>"], ["proof (state)\nthis:\n  t \\<noteq> t''\n\ngoal (1 subgoal):\n 1. t \\<noteq> t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "from lota"], ["proof (chain)\npicking this:\n  lock_ok_las ls t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>", "have lao: \"lock_actions_ok (ls $ l) t (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\""], ["proof (prove)\nusing this:\n  lock_ok_las ls t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\n\ngoal (1 subgoal):\n 1. lock_actions_ok (ls $ l) t (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)", "by(simp add: lock_ok_las_def)"], ["proof (state)\nthis:\n  lock_actions_ok (ls $ l) t (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n\ngoal (1 subgoal):\n 1. t \\<noteq> t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "proof(cases \"ts t''\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ts t'' = None \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n 2. \\<And>a.\n       ts t'' = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "case None"], ["proof (state)\nthis:\n  ts t'' = None\n\ngoal (2 subgoals):\n 1. ts t'' = None \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n 2. \\<And>a.\n       ts t'' = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "with est ts't'' tt'' cctta"], ["proof (chain)\npicking this:\n  ts t = \\<lfloor>((e, x), no_wait_locks)\\<rfloor>\n  (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n   ((e', x'),\n    redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n   t'' =\n  \\<lfloor>((e'', x''), ln'')\\<rfloor>\n  t \\<noteq> t''\n  thread_oks ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n  ts t'' = None", "obtain m where \"NewThread t'' (e'', x'') m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\" and ln'': \"ln'' = no_wait_locks\""], ["proof (prove)\nusing this:\n  ts t = \\<lfloor>((e, x), no_wait_locks)\\<rfloor>\n  (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n   ((e', x'),\n    redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n   t'' =\n  \\<lfloor>((e'', x''), ln'')\\<rfloor>\n  t \\<noteq> t''\n  thread_oks ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n  ts t'' = None\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>NewThread t'' (e'', x'') m\n                 \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n         ln'' = no_wait_locks\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: redT_updTs_new_thread)"], ["proof (state)\nthis:\n  NewThread t'' (e'', x'') m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n  ln'' = no_wait_locks\n\ngoal (2 subgoals):\n 1. ts t'' = None \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n 2. \\<And>a.\n       ts t'' = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "moreover"], ["proof (state)\nthis:\n  NewThread t'' (e'', x'') m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n  ln'' = no_wait_locks\n\ngoal (2 subgoals):\n 1. ts t'' = None \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n 2. \\<And>a.\n       ts t'' = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "with P"], ["proof (chain)\npicking this:\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e,(h, x)\\<rangle> -ta\\<rightarrow>\n                      \\<langle>e',(m', x')\\<rangle>\n  NewThread t'' (e'', x'') m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n  ln'' = no_wait_locks", "have \"m' = m\""], ["proof (prove)\nusing this:\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e,(h, x)\\<rangle> -ta\\<rightarrow>\n                      \\<langle>e',(m', x')\\<rangle>\n  NewThread t'' (e'', x'') m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n  ln'' = no_wait_locks\n\ngoal (1 subgoal):\n 1. m' = m", "by(auto dest: red_new_thread_heap)"], ["proof (state)\nthis:\n  m' = m\n\ngoal (2 subgoals):\n 1. ts t'' = None \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n 2. \\<And>a.\n       ts t'' = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "ultimately"], ["proof (chain)\npicking this:\n  NewThread t'' (e'', x'') m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n  ln'' = no_wait_locks\n  m' = m", "have \"NewThread t'' (e'', x'') m' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\""], ["proof (prove)\nusing this:\n  NewThread t'' (e'', x'') m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n  ln'' = no_wait_locks\n  m' = m\n\ngoal (1 subgoal):\n 1. NewThread t'' (e'', x'') m'\n    \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>", "by simp"], ["proof (state)\nthis:\n  NewThread t'' (e'', x'') m'\n  \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n\ngoal (2 subgoals):\n 1. ts t'' = None \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n 2. \\<And>a.\n       ts t'' = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "with wf P ln''"], ["proof (chain)\npicking this:\n  wf_J_prog P\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e,(h, x)\\<rangle> -ta\\<rightarrow>\n                      \\<langle>e',(m', x')\\<rangle>\n  ln'' = no_wait_locks\n  NewThread t'' (e'', x'') m'\n  \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>", "have \"expr_locks e'' = (\\<lambda>ad. 0)\""], ["proof (prove)\nusing this:\n  wf_J_prog P\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e,(h, x)\\<rangle> -ta\\<rightarrow>\n                      \\<langle>e',(m', x')\\<rangle>\n  ln'' = no_wait_locks\n  NewThread t'' (e'', x'') m'\n  \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n\ngoal (1 subgoal):\n 1. expr_locks e'' = (\\<lambda>ad. 0)", "by -(rule expr_locks_new_thread)"], ["proof (state)\nthis:\n  expr_locks e'' = (\\<lambda>ad. 0)\n\ngoal (2 subgoals):\n 1. ts t'' = None \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n 2. \\<And>a.\n       ts t'' = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "hence elel: \"expr_locks e'' l = 0\""], ["proof (prove)\nusing this:\n  expr_locks e'' = (\\<lambda>ad. 0)\n\ngoal (1 subgoal):\n 1. expr_locks e'' l = 0", "by simp"], ["proof (state)\nthis:\n  expr_locks e'' l = 0\n\ngoal (2 subgoals):\n 1. ts t'' = None \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n 2. \\<And>a.\n       ts t'' = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "from loes None"], ["proof (chain)\npicking this:\n  lock_ok ls ts\n  ts t'' = None", "have \"has_locks (ls $ l) t'' = 0\""], ["proof (prove)\nusing this:\n  lock_ok ls ts\n  ts t'' = None\n\ngoal (1 subgoal):\n 1. has_locks (ls $ l) t'' = 0", "by(auto dest: lock_okD1)"], ["proof (state)\nthis:\n  has_locks (ls $ l) t'' = 0\n\ngoal (2 subgoals):\n 1. ts t'' = None \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n 2. \\<And>a.\n       ts t'' = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "moreover"], ["proof (state)\nthis:\n  has_locks (ls $ l) t'' = 0\n\ngoal (2 subgoals):\n 1. ts t'' = None \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n 2. \\<And>a.\n       ts t'' = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "note lock_actions_ok_has_locks_upd_locks_eq_has_locks[OF lao tt''[symmetric]]"], ["proof (state)\nthis:\n  has_locks\n   (upd_locks (ls $ l) t (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)) t'' =\n  has_locks (ls $ l) t''\n\ngoal (2 subgoals):\n 1. ts t'' = None \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n 2. \\<And>a.\n       ts t'' = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "ultimately"], ["proof (chain)\npicking this:\n  has_locks (ls $ l) t'' = 0\n  has_locks\n   (upd_locks (ls $ l) t (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)) t'' =\n  has_locks (ls $ l) t''", "have \"has_locks (redT_updLs ls t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l) t'' = 0\""], ["proof (prove)\nusing this:\n  has_locks (ls $ l) t'' = 0\n  has_locks\n   (upd_locks (ls $ l) t (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)) t'' =\n  has_locks (ls $ l) t''\n\ngoal (1 subgoal):\n 1. has_locks (redT_updLs ls t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t'' =\n    0", "by(auto simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  has_locks (redT_updLs ls t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n   t'' =\n  0\n\ngoal (2 subgoals):\n 1. ts t'' = None \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n 2. \\<And>a.\n       ts t'' = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "with elel ls' ln''"], ["proof (chain)\npicking this:\n  expr_locks e'' l = 0\n  ls' = redT_updLs ls t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\n  ln'' = no_wait_locks\n  has_locks (redT_updLs ls t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n   t'' =\n  0", "show ?thesis"], ["proof (prove)\nusing this:\n  expr_locks e'' l = 0\n  ls' = redT_updLs ls t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\n  ln'' = no_wait_locks\n  has_locks (redT_updLs ls t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n   t'' =\n  0\n\ngoal (1 subgoal):\n 1. has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "by(auto)"], ["proof (state)\nthis:\n  has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ts t'' = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       ts t'' = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "case (Some a)"], ["proof (state)\nthis:\n  ts t'' = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ts t'' = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "then"], ["proof (chain)\npicking this:\n  ts t'' = \\<lfloor>a\\<rfloor>", "obtain E X LN where est'': \"ts t'' = \\<lfloor>((E, X), LN)\\<rfloor>\""], ["proof (prove)\nusing this:\n  ts t'' = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>E X LN.\n        ts t'' = \\<lfloor>((E, X), LN)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases a, auto)"], ["proof (state)\nthis:\n  ts t'' = \\<lfloor>((E, X), LN)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ts t'' = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "with loes"], ["proof (chain)\npicking this:\n  lock_ok ls ts\n  ts t'' = \\<lfloor>((E, X), LN)\\<rfloor>", "have IH: \"has_locks (ls $ l) t'' + LN $ l = expr_locks E l\""], ["proof (prove)\nusing this:\n  lock_ok ls ts\n  ts t'' = \\<lfloor>((E, X), LN)\\<rfloor>\n\ngoal (1 subgoal):\n 1. has_locks (ls $ l) t'' + LN $ l = expr_locks E l", "by(auto dest: lock_okD2)"], ["proof (state)\nthis:\n  has_locks (ls $ l) t'' + LN $ l = expr_locks E l\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ts t'' = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "from est est'' tt'' cctta"], ["proof (chain)\npicking this:\n  ts t = \\<lfloor>((e, x), no_wait_locks)\\<rfloor>\n  ts t'' = \\<lfloor>((E, X), LN)\\<rfloor>\n  t \\<noteq> t''\n  thread_oks ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>", "have \"?ts' t'' = \\<lfloor>((E, X), LN)\\<rfloor>\""], ["proof (prove)\nusing this:\n  ts t = \\<lfloor>((e, x), no_wait_locks)\\<rfloor>\n  ts t'' = \\<lfloor>((E, X), LN)\\<rfloor>\n  t \\<noteq> t''\n  thread_oks ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n\ngoal (1 subgoal):\n 1. (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n     ((e', x'),\n      redT_updLns ls t no_wait_locks\n       \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n     t'' =\n    \\<lfloor>((E, X), LN)\\<rfloor>", "by(simp)(rule redT_updTs_Some, simp_all)"], ["proof (state)\nthis:\n  (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n   ((e', x'),\n    redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n   t'' =\n  \\<lfloor>((E, X), LN)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ts t'' = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "with ts't''"], ["proof (chain)\npicking this:\n  (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n   ((e', x'),\n    redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n   t'' =\n  \\<lfloor>((e'', x''), ln'')\\<rfloor>\n  (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n   ((e', x'),\n    redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n   t'' =\n  \\<lfloor>((E, X), LN)\\<rfloor>", "have e'': \"E = e''\" and x'': \"X = x''\"\n            and ln'': \"ln'' = LN\""], ["proof (prove)\nusing this:\n  (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n   ((e', x'),\n    redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n   t'' =\n  \\<lfloor>((e'', x''), ln'')\\<rfloor>\n  (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n   ((e', x'),\n    redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n   t'' =\n  \\<lfloor>((E, X), LN)\\<rfloor>\n\ngoal (1 subgoal):\n 1. E = e'' &&& X = x'' &&& ln'' = LN", "by(simp_all)"], ["proof (state)\nthis:\n  E = e''\n  X = x''\n  ln'' = LN\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ts t'' = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "with lock_actions_ok_has_locks_upd_locks_eq_has_locks[OF lao tt''[symmetric]] IH ls'"], ["proof (chain)\npicking this:\n  has_locks\n   (upd_locks (ls $ l) t (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)) t'' =\n  has_locks (ls $ l) t''\n  has_locks (ls $ l) t'' + LN $ l = expr_locks E l\n  ls' = redT_updLs ls t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\n  E = e''\n  X = x''\n  ln'' = LN", "show ?thesis"], ["proof (prove)\nusing this:\n  has_locks\n   (upd_locks (ls $ l) t (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)) t'' =\n  has_locks (ls $ l) t''\n  has_locks (ls $ l) t'' + LN $ l = expr_locks E l\n  ls' = redT_updLs ls t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\n  E = e''\n  X = x''\n  ln'' = LN\n\ngoal (1 subgoal):\n 1. has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "by(clarsimp simp add: redT_updLs_def fun_eq_iff)"], ["proof (state)\nthis:\n  has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lock_ok ls'\n   (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n    ((e', x'),\n     redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n\ngoal (2 subgoals):\n 1. \\<And>x x' m' ws'a.\n       \\<lbrakk>red_mthr.r_syntax P t x (shr (ls, (ts, h), ws, is)) ta x'\n                 m';\n        thr (ls, (ts, h), ws, is) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks (ls, (ts, h), ws, is)) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n        red_mthr.cond_action_oks (ls, (ts, h), ws, is) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset (ls, (ts, h), ws, is)) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t (wset (ls, (ts, h), ws, is))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> ws'a;\n        (ls', (ts', h'), ws', is') =\n        (redT_updLs (locks (ls, (ts, h), ws, is)) t\n          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr (ls, (ts, h), ws, is))\n           \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n          (t \\<mapsto>\n          (x',\n           redT_updLns (locks (ls, (ts, h), ws, is)) t no_wait_locks\n            \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'),\n         ws'a,\n         redT_updIs (interrupts (ls, (ts, h), ws, is))\n          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls' ts'\n 2. \\<And>x ln n.\n       \\<lbrakk>thr (ls, (ts, h), ws, is) t = \\<lfloor>(x, ln)\\<rfloor>;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset (ls, (ts, h), ws, is) t);\n        may_acquire_all (locks (ls, (ts, h), ws, is)) t ln; 0 < ln $ n;\n        (ls', (ts', h'), ws', is') =\n        (acquire_all (locks (ls, (ts, h), ws, is)) t ln,\n         (thr (ls, (ts, h), ws, is)(t \\<mapsto> (x, no_wait_locks)),\n          shr (ls, (ts, h), ws, is)),\n         wset (ls, (ts, h), ws, is),\n         interrupts (ls, (ts, h), ws, is))\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls' ts'", "with s'"], ["proof (chain)\npicking this:\n  ts' = redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n  ((e', x'),\n   redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>))\n  lock_ok ls'\n   (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n    ((e', x'),\n     redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))", "show ?thesis"], ["proof (prove)\nusing this:\n  ts' = redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n  ((e', x'),\n   redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>))\n  lock_ok ls'\n   (redT_updTs ts \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n    ((e', x'),\n     redT_updLns ls t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)))\n\ngoal (1 subgoal):\n 1. lock_ok ls' ts'", "by simp"], ["proof (state)\nthis:\n  lock_ok ls' ts'\n\ngoal (1 subgoal):\n 1. \\<And>x ln n.\n       \\<lbrakk>thr (ls, (ts, h), ws, is) t = \\<lfloor>(x, ln)\\<rfloor>;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset (ls, (ts, h), ws, is) t);\n        may_acquire_all (locks (ls, (ts, h), ws, is)) t ln; 0 < ln $ n;\n        (ls', (ts', h'), ws', is') =\n        (acquire_all (locks (ls, (ts, h), ws, is)) t ln,\n         (thr (ls, (ts, h), ws, is)(t \\<mapsto> (x, no_wait_locks)),\n          shr (ls, (ts, h), ws, is)),\n         wset (ls, (ts, h), ws, is),\n         interrupts (ls, (ts, h), ws, is))\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls' ts'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ln n.\n       \\<lbrakk>thr (ls, (ts, h), ws, is) t = \\<lfloor>(x, ln)\\<rfloor>;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset (ls, (ts, h), ws, is) t);\n        may_acquire_all (locks (ls, (ts, h), ws, is)) t ln; 0 < ln $ n;\n        (ls', (ts', h'), ws', is') =\n        (acquire_all (locks (ls, (ts, h), ws, is)) t ln,\n         (thr (ls, (ts, h), ws, is)(t \\<mapsto> (x, no_wait_locks)),\n          shr (ls, (ts, h), ws, is)),\n         wset (ls, (ts, h), ws, is),\n         interrupts (ls, (ts, h), ws, is))\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls' ts'", "case (acquire a ln n)"], ["proof (state)\nthis:\n  thr (ls, (ts, h), ws, is) t = \\<lfloor>(a, ln)\\<rfloor>\n  ta = (K$ [], [], [], [], [], convert_RA ln)\n  \\<not> waiting (wset (ls, (ts, h), ws, is) t)\n  may_acquire_all (locks (ls, (ts, h), ws, is)) t ln\n  0 < ln $ n\n  (ls', (ts', h'), ws', is') =\n  (acquire_all (locks (ls, (ts, h), ws, is)) t ln,\n   (thr (ls, (ts, h), ws, is)(t \\<mapsto> (a, no_wait_locks)),\n    shr (ls, (ts, h), ws, is)),\n   wset (ls, (ts, h), ws, is), interrupts (ls, (ts, h), ws, is))\n\ngoal (1 subgoal):\n 1. \\<And>x ln n.\n       \\<lbrakk>thr (ls, (ts, h), ws, is) t = \\<lfloor>(x, ln)\\<rfloor>;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset (ls, (ts, h), ws, is) t);\n        may_acquire_all (locks (ls, (ts, h), ws, is)) t ln; 0 < ln $ n;\n        (ls', (ts', h'), ws', is') =\n        (acquire_all (locks (ls, (ts, h), ws, is)) t ln,\n         (thr (ls, (ts, h), ws, is)(t \\<mapsto> (x, no_wait_locks)),\n          shr (ls, (ts, h), ws, is)),\n         wset (ls, (ts, h), ws, is),\n         interrupts (ls, (ts, h), ws, is))\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls' ts'", "hence [simp]: \"ta = (K$ [], [], [], [], [], convert_RA ln)\" \"ws' = ws\" \"h' = h\" \n      and ls': \"ls' = acquire_all ls t ln\"\n      and ts': \"ts' = ts(t \\<mapsto> (a, no_wait_locks))\"\n      and \"ts t = \\<lfloor>(a, ln)\\<rfloor>\"\n      and \"may_acquire_all ls t ln\""], ["proof (prove)\nusing this:\n  thr (ls, (ts, h), ws, is) t = \\<lfloor>(a, ln)\\<rfloor>\n  ta = (K$ [], [], [], [], [], convert_RA ln)\n  \\<not> waiting (wset (ls, (ts, h), ws, is) t)\n  may_acquire_all (locks (ls, (ts, h), ws, is)) t ln\n  0 < ln $ n\n  (ls', (ts', h'), ws', is') =\n  (acquire_all (locks (ls, (ts, h), ws, is)) t ln,\n   (thr (ls, (ts, h), ws, is)(t \\<mapsto> (a, no_wait_locks)),\n    shr (ls, (ts, h), ws, is)),\n   wset (ls, (ts, h), ws, is), interrupts (ls, (ts, h), ws, is))\n\ngoal (1 subgoal):\n 1. ((ta = (K$ [], [], [], [], [], convert_RA ln) &&&\n      ws' = ws &&& h' = h) &&&\n     ls' = acquire_all ls t ln) &&&\n    ts' = ts(t \\<mapsto> (a, no_wait_locks)) &&&\n    ts t = \\<lfloor>(a, ln)\\<rfloor> &&& may_acquire_all ls t ln", "by auto"], ["proof (state)\nthis:\n  ta = (K$ [], [], [], [], [], convert_RA ln)\n  ws' = ws\n  h' = h\n  ls' = acquire_all ls t ln\n  ts' = ts(t \\<mapsto> (a, no_wait_locks))\n  ts t = \\<lfloor>(a, ln)\\<rfloor>\n  may_acquire_all ls t ln\n\ngoal (1 subgoal):\n 1. \\<And>x ln n.\n       \\<lbrakk>thr (ls, (ts, h), ws, is) t = \\<lfloor>(x, ln)\\<rfloor>;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset (ls, (ts, h), ws, is) t);\n        may_acquire_all (locks (ls, (ts, h), ws, is)) t ln; 0 < ln $ n;\n        (ls', (ts', h'), ws', is') =\n        (acquire_all (locks (ls, (ts, h), ws, is)) t ln,\n         (thr (ls, (ts, h), ws, is)(t \\<mapsto> (x, no_wait_locks)),\n          shr (ls, (ts, h), ws, is)),\n         wset (ls, (ts, h), ws, is),\n         interrupts (ls, (ts, h), ws, is))\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls' ts'", "obtain e x where [simp]: \"a = (e, x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e x. a = (e, x) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases a, auto)"], ["proof (state)\nthis:\n  a = (e, x)\n\ngoal (1 subgoal):\n 1. \\<And>x ln n.\n       \\<lbrakk>thr (ls, (ts, h), ws, is) t = \\<lfloor>(x, ln)\\<rfloor>;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset (ls, (ts, h), ws, is) t);\n        may_acquire_all (locks (ls, (ts, h), ws, is)) t ln; 0 < ln $ n;\n        (ls', (ts', h'), ws', is') =\n        (acquire_all (locks (ls, (ts, h), ws, is)) t ln,\n         (thr (ls, (ts, h), ws, is)(t \\<mapsto> (x, no_wait_locks)),\n          shr (ls, (ts, h), ws, is)),\n         wset (ls, (ts, h), ws, is),\n         interrupts (ls, (ts, h), ws, is))\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls' ts'", "from ts'"], ["proof (chain)\npicking this:\n  ts' = ts(t \\<mapsto> (a, no_wait_locks))", "have ts': \"ts' = ts(t \\<mapsto> ((e, x), no_wait_locks))\""], ["proof (prove)\nusing this:\n  ts' = ts(t \\<mapsto> (a, no_wait_locks))\n\ngoal (1 subgoal):\n 1. ts' = ts(t \\<mapsto> ((e, x), no_wait_locks))", "by simp"], ["proof (state)\nthis:\n  ts' = ts(t \\<mapsto> ((e, x), no_wait_locks))\n\ngoal (1 subgoal):\n 1. \\<And>x ln n.\n       \\<lbrakk>thr (ls, (ts, h), ws, is) t = \\<lfloor>(x, ln)\\<rfloor>;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset (ls, (ts, h), ws, is) t);\n        may_acquire_all (locks (ls, (ts, h), ws, is)) t ln; 0 < ln $ n;\n        (ls', (ts', h'), ws', is') =\n        (acquire_all (locks (ls, (ts, h), ws, is)) t ln,\n         (thr (ls, (ts, h), ws, is)(t \\<mapsto> (x, no_wait_locks)),\n          shr (ls, (ts, h), ws, is)),\n         wset (ls, (ts, h), ws, is),\n         interrupts (ls, (ts, h), ws, is))\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls' ts'", "from \\<open>ts t = \\<lfloor>(a, ln)\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  ts t = \\<lfloor>(a, ln)\\<rfloor>", "have tst: \"ts t = \\<lfloor>((e, x), ln)\\<rfloor>\""], ["proof (prove)\nusing this:\n  ts t = \\<lfloor>(a, ln)\\<rfloor>\n\ngoal (1 subgoal):\n 1. ts t = \\<lfloor>((e, x), ln)\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  ts t = \\<lfloor>((e, x), ln)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x ln n.\n       \\<lbrakk>thr (ls, (ts, h), ws, is) t = \\<lfloor>(x, ln)\\<rfloor>;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset (ls, (ts, h), ws, is) t);\n        may_acquire_all (locks (ls, (ts, h), ws, is)) t ln; 0 < ln $ n;\n        (ls', (ts', h'), ws', is') =\n        (acquire_all (locks (ls, (ts, h), ws, is)) t ln,\n         (thr (ls, (ts, h), ws, is)(t \\<mapsto> (x, no_wait_locks)),\n          shr (ls, (ts, h), ws, is)),\n         wset (ls, (ts, h), ws, is),\n         interrupts (ls, (ts, h), ws, is))\\<rbrakk>\n       \\<Longrightarrow> lock_ok ls' ts'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lock_ok ls' ts'", "proof(rule lock_okI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t l. ts' t = None \\<Longrightarrow> has_locks (ls' $ l) t = 0\n 2. \\<And>t e x ln l.\n       ts' t = \\<lfloor>((e, x), ln)\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) t + ln $ l = expr_locks e l", "fix t'' l"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t l. ts' t = None \\<Longrightarrow> has_locks (ls' $ l) t = 0\n 2. \\<And>t e x ln l.\n       ts' t = \\<lfloor>((e, x), ln)\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) t + ln $ l = expr_locks e l", "assume rtutes: \"ts' t'' = None\""], ["proof (state)\nthis:\n  ts' t'' = None\n\ngoal (2 subgoals):\n 1. \\<And>t l. ts' t = None \\<Longrightarrow> has_locks (ls' $ l) t = 0\n 2. \\<And>t e x ln l.\n       ts' t = \\<lfloor>((e, x), ln)\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) t + ln $ l = expr_locks e l", "with ts'"], ["proof (chain)\npicking this:\n  ts' = ts(t \\<mapsto> ((e, x), no_wait_locks))\n  ts' t'' = None", "have tst'': \"ts t'' = None\""], ["proof (prove)\nusing this:\n  ts' = ts(t \\<mapsto> ((e, x), no_wait_locks))\n  ts' t'' = None\n\ngoal (1 subgoal):\n 1. ts t'' = None", "by(simp split: if_split_asm)"], ["proof (state)\nthis:\n  ts t'' = None\n\ngoal (2 subgoals):\n 1. \\<And>t l. ts' t = None \\<Longrightarrow> has_locks (ls' $ l) t = 0\n 2. \\<And>t e x ln l.\n       ts' t = \\<lfloor>((e, x), ln)\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) t + ln $ l = expr_locks e l", "with tst"], ["proof (chain)\npicking this:\n  ts t = \\<lfloor>((e, x), ln)\\<rfloor>\n  ts t'' = None", "have tt'': \"t \\<noteq> t''\""], ["proof (prove)\nusing this:\n  ts t = \\<lfloor>((e, x), ln)\\<rfloor>\n  ts t'' = None\n\ngoal (1 subgoal):\n 1. t \\<noteq> t''", "by auto"], ["proof (state)\nthis:\n  t \\<noteq> t''\n\ngoal (2 subgoals):\n 1. \\<And>t l. ts' t = None \\<Longrightarrow> has_locks (ls' $ l) t = 0\n 2. \\<And>t e x ln l.\n       ts' t = \\<lfloor>((e, x), ln)\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) t + ln $ l = expr_locks e l", "from tst'' loes"], ["proof (chain)\npicking this:\n  ts t'' = None\n  lock_ok ls ts", "have \"has_locks (ls $ l) t'' = 0\""], ["proof (prove)\nusing this:\n  ts t'' = None\n  lock_ok ls ts\n\ngoal (1 subgoal):\n 1. has_locks (ls $ l) t'' = 0", "by(auto dest: lock_okD1)"], ["proof (state)\nthis:\n  has_locks (ls $ l) t'' = 0\n\ngoal (2 subgoals):\n 1. \\<And>t l. ts' t = None \\<Longrightarrow> has_locks (ls' $ l) t = 0\n 2. \\<And>t e x ln l.\n       ts' t = \\<lfloor>((e, x), ln)\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) t + ln $ l = expr_locks e l", "thus \"has_locks (ls' $ l) t'' = 0\""], ["proof (prove)\nusing this:\n  has_locks (ls $ l) t'' = 0\n\ngoal (1 subgoal):\n 1. has_locks (ls' $ l) t'' = 0", "by(simp add: red_mthr.redT_has_locks_inv[OF redT tt''])"], ["proof (state)\nthis:\n  has_locks (ls' $ l) t'' = 0\n\ngoal (1 subgoal):\n 1. \\<And>t e x ln l.\n       ts' t = \\<lfloor>((e, x), ln)\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) t + ln $ l = expr_locks e l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t e x ln l.\n       ts' t = \\<lfloor>((e, x), ln)\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) t + ln $ l = expr_locks e l", "fix t'' e'' x'' ln'' l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t e x ln l.\n       ts' t = \\<lfloor>((e, x), ln)\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) t + ln $ l = expr_locks e l", "assume ts't'': \"ts' t'' = \\<lfloor>((e'', x''), ln'')\\<rfloor>\""], ["proof (state)\nthis:\n  ts' t'' = \\<lfloor>((e'', x''), ln'')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>t e x ln l.\n       ts' t = \\<lfloor>((e, x), ln)\\<rfloor> \\<Longrightarrow>\n       has_locks (ls' $ l) t + ln $ l = expr_locks e l", "show \"has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "proof(cases \"t = t''\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t = t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n 2. t \\<noteq> t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "case True"], ["proof (state)\nthis:\n  t = t''\n\ngoal (2 subgoals):\n 1. t = t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n 2. t \\<noteq> t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "note [simp] = this"], ["proof (state)\nthis:\n  t = t''\n\ngoal (2 subgoals):\n 1. t = t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n 2. t \\<noteq> t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "with ts't'' ts' tst"], ["proof (chain)\npicking this:\n  ts' t'' = \\<lfloor>((e'', x''), ln'')\\<rfloor>\n  ts' = ts(t \\<mapsto> ((e, x), no_wait_locks))\n  ts t = \\<lfloor>((e, x), ln)\\<rfloor>\n  t = t''", "have [simp]: \"ln'' = no_wait_locks\" \"e = e''\""], ["proof (prove)\nusing this:\n  ts' t'' = \\<lfloor>((e'', x''), ln'')\\<rfloor>\n  ts' = ts(t \\<mapsto> ((e, x), no_wait_locks))\n  ts t = \\<lfloor>((e, x), ln)\\<rfloor>\n  t = t''\n\ngoal (1 subgoal):\n 1. ln'' = no_wait_locks &&& e = e''", "by auto"], ["proof (state)\nthis:\n  ln'' = no_wait_locks\n  e = e''\n\ngoal (2 subgoals):\n 1. t = t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n 2. t \\<noteq> t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "from tst loes"], ["proof (chain)\npicking this:\n  ts t = \\<lfloor>((e, x), ln)\\<rfloor>\n  lock_ok ls ts", "have \"has_locks (ls $ l) t + ln $ l = expr_locks e l\""], ["proof (prove)\nusing this:\n  ts t = \\<lfloor>((e, x), ln)\\<rfloor>\n  lock_ok ls ts\n\ngoal (1 subgoal):\n 1. has_locks (ls $ l) t + ln $ l = expr_locks e l", "by(auto dest: lock_okD2)"], ["proof (state)\nthis:\n  has_locks (ls $ l) t + ln $ l = expr_locks e l\n\ngoal (2 subgoals):\n 1. t = t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n 2. t \\<noteq> t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "proof(cases \"ln $ l > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < ln $ l \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n 2. \\<not> 0 < ln $ l \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "case True"], ["proof (state)\nthis:\n  0 < ln $ l\n\ngoal (2 subgoals):\n 1. 0 < ln $ l \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n 2. \\<not> 0 < ln $ l \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "with \\<open>may_acquire_all ls t ln\\<close> ls'"], ["proof (chain)\npicking this:\n  may_acquire_all ls t ln\n  ls' = acquire_all ls t ln\n  0 < ln $ l", "have \"may_lock (ls $ l) t\""], ["proof (prove)\nusing this:\n  may_acquire_all ls t ln\n  ls' = acquire_all ls t ln\n  0 < ln $ l\n\ngoal (1 subgoal):\n 1. may_lock (ls $ l) t", "by(auto elim: may_acquire_allE)"], ["proof (state)\nthis:\n  may_lock (ls $ l) t\n\ngoal (2 subgoals):\n 1. 0 < ln $ l \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n 2. \\<not> 0 < ln $ l \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "with ls'"], ["proof (chain)\npicking this:\n  ls' = acquire_all ls t ln\n  may_lock (ls $ l) t", "have \"has_locks (ls' $ l) t = has_locks (ls $ l) t + ln $ l\""], ["proof (prove)\nusing this:\n  ls' = acquire_all ls t ln\n  may_lock (ls $ l) t\n\ngoal (1 subgoal):\n 1. has_locks (ls' $ l) t = has_locks (ls $ l) t + ln $ l", "by(simp add: has_locks_acquire_locks_conv)"], ["proof (state)\nthis:\n  has_locks (ls' $ l) t = has_locks (ls $ l) t + ln $ l\n\ngoal (2 subgoals):\n 1. 0 < ln $ l \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n 2. \\<not> 0 < ln $ l \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "with \\<open>has_locks (ls $ l) t + ln $ l = expr_locks e l\\<close>"], ["proof (chain)\npicking this:\n  has_locks (ls $ l) t + ln $ l = expr_locks e l\n  has_locks (ls' $ l) t = has_locks (ls $ l) t + ln $ l", "show ?thesis"], ["proof (prove)\nusing this:\n  has_locks (ls $ l) t + ln $ l = expr_locks e l\n  has_locks (ls' $ l) t = has_locks (ls $ l) t + ln $ l\n\ngoal (1 subgoal):\n 1. has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "by(simp)"], ["proof (state)\nthis:\n  has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n\ngoal (1 subgoal):\n 1. \\<not> 0 < ln $ l \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < ln $ l \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < ln $ l\n\ngoal (1 subgoal):\n 1. \\<not> 0 < ln $ l \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "hence \"ln $ l = 0\""], ["proof (prove)\nusing this:\n  \\<not> 0 < ln $ l\n\ngoal (1 subgoal):\n 1. ln $ l = 0", "by simp"], ["proof (state)\nthis:\n  ln $ l = 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 < ln $ l \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "with ls'"], ["proof (chain)\npicking this:\n  ls' = acquire_all ls t ln\n  ln $ l = 0", "have \"has_locks (ls' $ l) t = has_locks (ls $ l) t\""], ["proof (prove)\nusing this:\n  ls' = acquire_all ls t ln\n  ln $ l = 0\n\ngoal (1 subgoal):\n 1. has_locks (ls' $ l) t = has_locks (ls $ l) t", "by(simp)"], ["proof (state)\nthis:\n  has_locks (ls' $ l) t = has_locks (ls $ l) t\n\ngoal (1 subgoal):\n 1. \\<not> 0 < ln $ l \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "with \\<open>has_locks (ls $ l) t + ln $ l = expr_locks e l\\<close> \\<open>ln $ l = 0\\<close>"], ["proof (chain)\npicking this:\n  has_locks (ls $ l) t + ln $ l = expr_locks e l\n  ln $ l = 0\n  has_locks (ls' $ l) t = has_locks (ls $ l) t", "show ?thesis"], ["proof (prove)\nusing this:\n  has_locks (ls $ l) t + ln $ l = expr_locks e l\n  ln $ l = 0\n  has_locks (ls' $ l) t = has_locks (ls $ l) t\n\ngoal (1 subgoal):\n 1. has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "by(simp)"], ["proof (state)\nthis:\n  has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n\ngoal (1 subgoal):\n 1. t \\<noteq> t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<noteq> t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "case False"], ["proof (state)\nthis:\n  t \\<noteq> t''\n\ngoal (1 subgoal):\n 1. t \\<noteq> t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "with ts' ts't''"], ["proof (chain)\npicking this:\n  ts' = ts(t \\<mapsto> ((e, x), no_wait_locks))\n  ts' t'' = \\<lfloor>((e'', x''), ln'')\\<rfloor>\n  t \\<noteq> t''", "have tst'': \"ts t'' = \\<lfloor>((e'', x''), ln'')\\<rfloor>\""], ["proof (prove)\nusing this:\n  ts' = ts(t \\<mapsto> ((e, x), no_wait_locks))\n  ts' t'' = \\<lfloor>((e'', x''), ln'')\\<rfloor>\n  t \\<noteq> t''\n\ngoal (1 subgoal):\n 1. ts t'' = \\<lfloor>((e'', x''), ln'')\\<rfloor>", "by(simp)"], ["proof (state)\nthis:\n  ts t'' = \\<lfloor>((e'', x''), ln'')\\<rfloor>\n\ngoal (1 subgoal):\n 1. t \\<noteq> t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "with loes"], ["proof (chain)\npicking this:\n  lock_ok ls ts\n  ts t'' = \\<lfloor>((e'', x''), ln'')\\<rfloor>", "have \"has_locks (ls $ l) t'' + ln'' $ l = expr_locks e'' l\""], ["proof (prove)\nusing this:\n  lock_ok ls ts\n  ts t'' = \\<lfloor>((e'', x''), ln'')\\<rfloor>\n\ngoal (1 subgoal):\n 1. has_locks (ls $ l) t'' + ln'' $ l = expr_locks e'' l", "by(auto dest: lock_okD2)"], ["proof (state)\nthis:\n  has_locks (ls $ l) t'' + ln'' $ l = expr_locks e'' l\n\ngoal (1 subgoal):\n 1. t \\<noteq> t'' \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "proof(cases \"ln $ l > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < ln $ l \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n 2. \\<not> 0 < ln $ l \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < ln $ l\n\ngoal (2 subgoals):\n 1. 0 < ln $ l \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n 2. \\<not> 0 < ln $ l \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "with \\<open>t \\<noteq> t''\\<close> ls'"], ["proof (chain)\npicking this:\n  t \\<noteq> t''\n  ls' = acquire_all ls t ln\n  \\<not> 0 < ln $ l", "have \"has_locks (ls' $ l) t'' = has_locks (ls $ l) t''\""], ["proof (prove)\nusing this:\n  t \\<noteq> t''\n  ls' = acquire_all ls t ln\n  \\<not> 0 < ln $ l\n\ngoal (1 subgoal):\n 1. has_locks (ls' $ l) t'' = has_locks (ls $ l) t''", "by(simp)"], ["proof (state)\nthis:\n  has_locks (ls' $ l) t'' = has_locks (ls $ l) t''\n\ngoal (2 subgoals):\n 1. 0 < ln $ l \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n 2. \\<not> 0 < ln $ l \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "with \\<open>has_locks (ls $ l) t'' + ln'' $ l = expr_locks e'' l\\<close>"], ["proof (chain)\npicking this:\n  has_locks (ls $ l) t'' + ln'' $ l = expr_locks e'' l\n  has_locks (ls' $ l) t'' = has_locks (ls $ l) t''", "show ?thesis"], ["proof (prove)\nusing this:\n  has_locks (ls $ l) t'' + ln'' $ l = expr_locks e'' l\n  has_locks (ls' $ l) t'' = has_locks (ls $ l) t''\n\ngoal (1 subgoal):\n 1. has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "by(simp)"], ["proof (state)\nthis:\n  has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n\ngoal (1 subgoal):\n 1. 0 < ln $ l \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < ln $ l \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "case True"], ["proof (state)\nthis:\n  0 < ln $ l\n\ngoal (1 subgoal):\n 1. 0 < ln $ l \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "with \\<open>may_acquire_all ls t ln\\<close>"], ["proof (chain)\npicking this:\n  may_acquire_all ls t ln\n  0 < ln $ l", "have \"may_lock (ls $ l) t\""], ["proof (prove)\nusing this:\n  may_acquire_all ls t ln\n  0 < ln $ l\n\ngoal (1 subgoal):\n 1. may_lock (ls $ l) t", "by(auto elim: may_acquire_allE)"], ["proof (state)\nthis:\n  may_lock (ls $ l) t\n\ngoal (1 subgoal):\n 1. 0 < ln $ l \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "with ls' \\<open>t \\<noteq> t''\\<close>"], ["proof (chain)\npicking this:\n  ls' = acquire_all ls t ln\n  t \\<noteq> t''\n  may_lock (ls $ l) t", "have \"has_locks (ls' $ l) t'' = has_locks (ls $ l) t''\""], ["proof (prove)\nusing this:\n  ls' = acquire_all ls t ln\n  t \\<noteq> t''\n  may_lock (ls $ l) t\n\ngoal (1 subgoal):\n 1. has_locks (ls' $ l) t'' = has_locks (ls $ l) t''", "by(simp add: has_locks_acquire_locks_conv')"], ["proof (state)\nthis:\n  has_locks (ls' $ l) t'' = has_locks (ls $ l) t''\n\ngoal (1 subgoal):\n 1. 0 < ln $ l \\<Longrightarrow>\n    has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "with ls' \\<open>has_locks (ls $ l) t'' + ln'' $ l = expr_locks e'' l\\<close>"], ["proof (chain)\npicking this:\n  ls' = acquire_all ls t ln\n  has_locks (ls $ l) t'' + ln'' $ l = expr_locks e'' l\n  has_locks (ls' $ l) t'' = has_locks (ls $ l) t''", "show ?thesis"], ["proof (prove)\nusing this:\n  ls' = acquire_all ls t ln\n  has_locks (ls $ l) t'' + ln'' $ l = expr_locks e'' l\n  has_locks (ls' $ l) t'' = has_locks (ls $ l) t''\n\ngoal (1 subgoal):\n 1. has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l", "by(simp)"], ["proof (state)\nthis:\n  has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  has_locks (ls' $ l) t'' + ln'' $ l = expr_locks e'' l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lock_ok ls' ts'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lock_ok ls' ts'\n\ngoal (1 subgoal):\n 1. lock_ok (locks s') (thr s')", "thus ?thesis"], ["proof (prove)\nusing this:\n  lock_ok ls' ts'\n\ngoal (1 subgoal):\n 1. lock_ok (locks s') (thr s')", "by simp"], ["proof (state)\nthis:\n  lock_ok (locks s') (thr s')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invariant3p_sync_es_ok_lock_ok:\n  assumes wf: \"wf_J_prog P\"\n  shows \"invariant3p (mredT P) {s. sync_es_ok (thr s) (shr s) \\<and> lock_ok (locks s) (thr s)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant3p (mredT P)\n     {s. sync_es_ok (thr s) (shr s) \\<and> lock_ok (locks s) (thr s)}", "apply(rule invariant3pI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s tl s'.\n       \\<lbrakk>s \\<in> {s. sync_es_ok (thr s) (shr s) \\<and>\n                            lock_ok (locks s) (thr s)};\n        mredT P s tl s'\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> {s. sync_es_ok (thr s) (shr s) \\<and>\nlock_ok (locks s) (thr s)}", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ba ac ad ae af ag ah bb ai aj bc ak bd.\n       \\<lbrakk>red_mthr.redT_syntax2 P a (aa, b) ab ba ac\n                 (ad, ae, af, ag, ah, bb) ai (aj, bc) ak bd;\n        sync_es_ok (thr (a, (aa, b), ab, ba)) (shr (a, (aa, b), ab, ba));\n        lock_ok (locks (a, (aa, b), ab, ba))\n         (thr (a, (aa, b), ab, ba))\\<rbrakk>\n       \\<Longrightarrow> sync_es_ok (thr (ai, (aj, bc), ak, bd))\n                          (shr (ai, (aj, bc), ak, bd)) \\<and>\n                         lock_ok (locks (ai, (aj, bc), ak, bd))\n                          (thr (ai, (aj, bc), ak, bd))", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa b ab ba ac ad ae af ag ah bb ai aj bc ak bd.\n       \\<lbrakk>red_mthr.redT_syntax2 P a (aa, b) ab ba ac\n                 (ad, ae, af, ag, ah, bb) ai (aj, bc) ak bd;\n        sync_es_ok (thr (a, (aa, b), ab, ba)) (shr (a, (aa, b), ab, ba));\n        lock_ok (locks (a, (aa, b), ab, ba))\n         (thr (a, (aa, b), ab, ba))\\<rbrakk>\n       \\<Longrightarrow> sync_es_ok (thr (ai, (aj, bc), ak, bd))\n                          (shr (ai, (aj, bc), ak, bd))\n 2. \\<And>a aa b ab ba ac ad ae af ag ah bb ai aj bc ak bd.\n       \\<lbrakk>red_mthr.redT_syntax2 P a (aa, b) ab ba ac\n                 (ad, ae, af, ag, ah, bb) ai (aj, bc) ak bd;\n        sync_es_ok (thr (a, (aa, b), ab, ba)) (shr (a, (aa, b), ab, ba));\n        lock_ok (locks (a, (aa, b), ab, ba))\n         (thr (a, (aa, b), ab, ba))\\<rbrakk>\n       \\<Longrightarrow> lock_ok (locks (ai, (aj, bc), ak, bd))\n                          (thr (ai, (aj, bc), ak, bd))", "apply(rule lifting_wf.redT_preserves[OF lifting_wf_sync_ok[OF wf]], blast)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa b ab ba ac ad ae af ag ah bb ai aj bc ak bd.\n       \\<lbrakk>red_mthr.redT_syntax2 P a (aa, b) ab ba ac\n                 (ad, ae, af, ag, ah, bb) ai (aj, bc) ak bd;\n        sync_es_ok (thr (a, (aa, b), ab, ba)) (shr (a, (aa, b), ab, ba));\n        lock_ok (locks (a, (aa, b), ab, ba))\n         (thr (a, (aa, b), ab, ba))\\<rbrakk>\n       \\<Longrightarrow> sync_es_ok (thr (a, (aa, b), ab, ba))\n                          (shr (a, (aa, b), ab, ba))\n 2. \\<And>a aa b ab ba ac ad ae af ag ah bb ai aj bc ak bd.\n       \\<lbrakk>red_mthr.redT_syntax2 P a (aa, b) ab ba ac\n                 (ad, ae, af, ag, ah, bb) ai (aj, bc) ak bd;\n        sync_es_ok (thr (a, (aa, b), ab, ba)) (shr (a, (aa, b), ab, ba));\n        lock_ok (locks (a, (aa, b), ab, ba))\n         (thr (a, (aa, b), ab, ba))\\<rbrakk>\n       \\<Longrightarrow> lock_ok (locks (ai, (aj, bc), ak, bd))\n                          (thr (ai, (aj, bc), ak, bd))", "apply(assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ba ac ad ae af ag ah bb ai aj bc ak bd.\n       \\<lbrakk>red_mthr.redT_syntax2 P a (aa, b) ab ba ac\n                 (ad, ae, af, ag, ah, bb) ai (aj, bc) ak bd;\n        sync_es_ok (thr (a, (aa, b), ab, ba)) (shr (a, (aa, b), ab, ba));\n        lock_ok (locks (a, (aa, b), ab, ba))\n         (thr (a, (aa, b), ab, ba))\\<rbrakk>\n       \\<Longrightarrow> lock_ok (locks (ai, (aj, bc), ak, bd))\n                          (thr (ai, (aj, bc), ak, bd))", "apply(erule (2) redT_preserves_lock_ok[OF wf])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma RedT_preserves_lock_ok:\n  assumes wf: \"wf_J_prog P\"\n  and Red: \"P \\<turnstile> s -\\<triangleright>ttas\\<rightarrow>* s'\"\n  and ae: \"sync_es_ok (thr s) (shr s)\"\n  and loes: \"lock_ok (locks s) (thr s)\"\n  shows \"lock_ok (locks s') (thr s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lock_ok (locks s') (thr s')", "using invariant3p_rtrancl3p[OF invariant3p_sync_es_ok_lock_ok[OF wf] Red[unfolded red_mthr.RedT_def]] ae loes"], ["proof (prove)\nusing this:\n  s \\<in> {s. sync_es_ok (thr s) (shr s) \\<and>\n              lock_ok (locks s) (thr s)} \\<Longrightarrow>\n  s' \\<in> {s. sync_es_ok (thr s) (shr s) \\<and> lock_ok (locks s) (thr s)}\n  sync_es_ok (thr s) (shr s)\n  lock_ok (locks s) (thr s)\n\ngoal (1 subgoal):\n 1. lock_ok (locks s') (thr s')", "by simp"], ["", "end"], ["", "subsection \\<open>Determinism\\<close>"], ["", "context J_heap_base begin"], ["", "lemma\n  fixes final\n  assumes det: \"deterministic_heap_ops\"\n  shows red_deterministic:\n  \"\\<lbrakk> convert_extTA extTA,P,t \\<turnstile> \\<langle>e, (shr s, xs)\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; \n     convert_extTA extTA,P,t \\<turnstile> \\<langle>e, (shr s, xs)\\<rangle> -ta'\\<rightarrow> \\<langle>e'', s''\\<rangle>;\n     final_thread.actions_ok final s t ta; final_thread.actions_ok final s t ta' \\<rbrakk> \n  \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s''\"\n  and reds_deterministic:\n  \"\\<lbrakk> convert_extTA extTA,P,t \\<turnstile> \\<langle>es, (shr s, xs)\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; \n     convert_extTA extTA,P,t \\<turnstile> \\<langle>es, (shr s, xs)\\<rangle> [-ta'\\<rightarrow>] \\<langle>es'', s''\\<rangle>;\n     final_thread.actions_ok final s t ta; final_thread.actions_ok final s t ta' \\<rbrakk> \n  \\<Longrightarrow> ta = ta' \\<and> es' = es'' \\<and> s' = s''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>convert_extTA\n               extTA,P,t \\<turnstile> \\<langle>e,\n (shr s, xs)\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n      convert_extTA\n       extTA,P,t \\<turnstile> \\<langle>e,\n                               (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                              \\<langle>e'',s''\\<rangle>;\n      final_thread.actions_ok final s t ta;\n      final_thread.actions_ok final s t ta'\\<rbrakk>\n     \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'') &&&\n    (\\<lbrakk>convert_extTA\n               extTA,P,t \\<turnstile> \\<langle>es,\n (shr s, xs)\\<rangle> [-ta\\<rightarrow>]\n\\<langle>es',s'\\<rangle>;\n      convert_extTA\n       extTA,P,t \\<turnstile> \\<langle>es,\n                               (shr s, xs)\\<rangle> [-ta'\\<rightarrow>]\n                              \\<langle>es'',s''\\<rangle>;\n      final_thread.actions_ok final s t ta;\n      final_thread.actions_ok final s t ta'\\<rbrakk>\n     \\<Longrightarrow> ta = ta' \\<and> es' = es'' \\<and> s' = s'')", "proof(induct e \"(shr s, xs)\" ta e' s' and es \"(shr s, xs)\" ta es' s' arbitrary: e'' s'' xs and es'' s'' xs rule: red_reds.inducts)"], ["proof (state)\ngoal (98 subgoals):\n 1. \\<And>h' a C l e'' s''.\n       \\<lbrakk>(h', a) \\<in> allocate (shr s) (Class_type C);\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>new C,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t\n         \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace> =\n                         ta' \\<and>\n                         addr a = e'' \\<and> (h', l) = s''\n 2. \\<And>C l e'' s''.\n       \\<lbrakk>allocate (shr s) (Class_type C) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>new C,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 3. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         newA T\\<lfloor>e'\\<rceil> = e'' \\<and> s' = s''\n 4. \\<And>i h' a T l e'' s''.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate (shr s) (Array_type T (nat (sint i)));\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t\n         \\<lbrace>NewHeapElem a (Array_type T (nat (sint i)))\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>NewHeapElem a\n                                   (Array_type T (nat (sint i)))\\<rbrace> =\n                         ta' \\<and>\n                         addr a = e'' \\<and> (h', l) = s''\n 5. \\<And>i T xs e'' s''.\n       \\<lbrakk>i <s 0;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt NegativeArraySize) =\n                         e'' \\<and>\n                         (shr s, xs) = s''\n 6. \\<And>i T l e'' s''.\n       \\<lbrakk>0 \\<le>s i;\n        allocate (shr s) (Array_type T (nat (sint i))) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 7. \\<And>e ta e' s' C xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast C e,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> Cast C e' = e'' \\<and> s' = s''\n 8. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Val v = e'' \\<and> (shr s, xs) = s''\n 9. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt ClassCast) = e'' \\<and>\n                         (shr s, xs) = s''\n 10. \\<And>e ta e' s' T xs e'' s''.\n        \\<lbrakk>convert_extTA\n                  extTA,P,t \\<turnstile> \\<langle>e,\n    (shr s, xs)\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n         \\<And>e'' s''.\n            \\<lbrakk>convert_extTA\n                      extTA,P,t \\<turnstile> \\<langle>e,\n        (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n       \\<langle>e'',s''\\<rangle>;\n             final_thread.actions_ok final s t ta;\n             final_thread.actions_ok final s t ta'\\<rbrakk>\n            \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n         convert_extTA\n          extTA,P,t \\<turnstile> \\<langle>e instanceof T,\n                                  (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                 \\<langle>e'',s''\\<rangle>;\n         final_thread.actions_ok final s t ta;\n         final_thread.actions_ok final s t ta'\\<rbrakk>\n        \\<Longrightarrow> ta = ta' \\<and>\n                          e' instanceof T = e'' \\<and> s' = s''\nA total of 98 subgoals...", "case RedNew"], ["proof (state)\nthis:\n  (h'_, a_) \\<in> allocate (shr s) (Class_type C_)\n  convert_extTA\n   extTA,P,t \\<turnstile> \\<langle>new C_,\n                           (shr s, l_)\\<rangle> -ta'\\<rightarrow>\n                          \\<langle>e'',s''\\<rangle>\n  final_thread.actions_ok final s t\n   \\<lbrace>NewHeapElem a_ (Class_type C_)\\<rbrace>\n  final_thread.actions_ok final s t ta'\n\ngoal (98 subgoals):\n 1. \\<And>h' a C l e'' s''.\n       \\<lbrakk>(h', a) \\<in> allocate (shr s) (Class_type C);\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>new C,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t\n         \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace> =\n                         ta' \\<and>\n                         addr a = e'' \\<and> (h', l) = s''\n 2. \\<And>C l e'' s''.\n       \\<lbrakk>allocate (shr s) (Class_type C) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>new C,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 3. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         newA T\\<lfloor>e'\\<rceil> = e'' \\<and> s' = s''\n 4. \\<And>i h' a T l e'' s''.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate (shr s) (Array_type T (nat (sint i)));\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t\n         \\<lbrace>NewHeapElem a (Array_type T (nat (sint i)))\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>NewHeapElem a\n                                   (Array_type T (nat (sint i)))\\<rbrace> =\n                         ta' \\<and>\n                         addr a = e'' \\<and> (h', l) = s''\n 5. \\<And>i T xs e'' s''.\n       \\<lbrakk>i <s 0;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt NegativeArraySize) =\n                         e'' \\<and>\n                         (shr s, xs) = s''\n 6. \\<And>i T l e'' s''.\n       \\<lbrakk>0 \\<le>s i;\n        allocate (shr s) (Array_type T (nat (sint i))) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 7. \\<And>e ta e' s' C xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast C e,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> Cast C e' = e'' \\<and> s' = s''\n 8. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Val v = e'' \\<and> (shr s, xs) = s''\n 9. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt ClassCast) = e'' \\<and>\n                         (shr s, xs) = s''\n 10. \\<And>e ta e' s' T xs e'' s''.\n        \\<lbrakk>convert_extTA\n                  extTA,P,t \\<turnstile> \\<langle>e,\n    (shr s, xs)\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n         \\<And>e'' s''.\n            \\<lbrakk>convert_extTA\n                      extTA,P,t \\<turnstile> \\<langle>e,\n        (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n       \\<langle>e'',s''\\<rangle>;\n             final_thread.actions_ok final s t ta;\n             final_thread.actions_ok final s t ta'\\<rbrakk>\n            \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n         convert_extTA\n          extTA,P,t \\<turnstile> \\<langle>e instanceof T,\n                                  (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                 \\<langle>e'',s''\\<rangle>;\n         final_thread.actions_ok final s t ta;\n         final_thread.actions_ok final s t ta'\\<rbrakk>\n        \\<Longrightarrow> ta = ta' \\<and>\n                          e' instanceof T = e'' \\<and> s' = s''\nA total of 98 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  (h'_, a_) \\<in> allocate (shr s) (Class_type C_)\n  convert_extTA\n   extTA,P,t \\<turnstile> \\<langle>new C_,\n                           (shr s, l_)\\<rangle> -ta'\\<rightarrow>\n                          \\<langle>e'',s''\\<rangle>\n  final_thread.actions_ok final s t\n   \\<lbrace>NewHeapElem a_ (Class_type C_)\\<rbrace>\n  final_thread.actions_ok final s t ta'\n\ngoal (1 subgoal):\n 1. \\<lbrace>NewHeapElem a_ (Class_type C_)\\<rbrace> = ta' \\<and>\n    addr a_ = e'' \\<and> (h'_, l_) = s''", "by(auto elim!: red_cases dest: deterministic_heap_ops_allocateD[OF det])"], ["proof (state)\nthis:\n  \\<lbrace>NewHeapElem a_ (Class_type C_)\\<rbrace> = ta' \\<and>\n  addr a_ = e'' \\<and> (h'_, l_) = s''\n\ngoal (97 subgoals):\n 1. \\<And>C l e'' s''.\n       \\<lbrakk>allocate (shr s) (Class_type C) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>new C,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 2. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         newA T\\<lfloor>e'\\<rceil> = e'' \\<and> s' = s''\n 3. \\<And>i h' a T l e'' s''.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate (shr s) (Array_type T (nat (sint i)));\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t\n         \\<lbrace>NewHeapElem a (Array_type T (nat (sint i)))\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>NewHeapElem a\n                                   (Array_type T (nat (sint i)))\\<rbrace> =\n                         ta' \\<and>\n                         addr a = e'' \\<and> (h', l) = s''\n 4. \\<And>i T xs e'' s''.\n       \\<lbrakk>i <s 0;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt NegativeArraySize) =\n                         e'' \\<and>\n                         (shr s, xs) = s''\n 5. \\<And>i T l e'' s''.\n       \\<lbrakk>0 \\<le>s i;\n        allocate (shr s) (Array_type T (nat (sint i))) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 6. \\<And>e ta e' s' C xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast C e,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> Cast C e' = e'' \\<and> s' = s''\n 7. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Val v = e'' \\<and> (shr s, xs) = s''\n 8. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt ClassCast) = e'' \\<and>\n                         (shr s, xs) = s''\n 9. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>e instanceof T,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         e' instanceof T = e'' \\<and> s' = s''\n 10. \\<And>v U b T xs e'' s''.\n        \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                 \\<lfloor>U\\<rfloor>;\n         b = (v \\<noteq> Null \\<and> P \\<turnstile> U \\<le> T);\n         convert_extTA\n          extTA,P,t \\<turnstile> \\<langle>Val v instanceof T,\n                                  (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                 \\<langle>e'',s''\\<rangle>;\n         final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n         final_thread.actions_ok final s t ta'\\<rbrakk>\n        \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                          Val (Bool b) = e'' \\<and> (shr s, xs) = s''\nA total of 97 subgoals...", "next"], ["proof (state)\ngoal (97 subgoals):\n 1. \\<And>C l e'' s''.\n       \\<lbrakk>allocate (shr s) (Class_type C) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>new C,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 2. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         newA T\\<lfloor>e'\\<rceil> = e'' \\<and> s' = s''\n 3. \\<And>i h' a T l e'' s''.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate (shr s) (Array_type T (nat (sint i)));\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t\n         \\<lbrace>NewHeapElem a (Array_type T (nat (sint i)))\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>NewHeapElem a\n                                   (Array_type T (nat (sint i)))\\<rbrace> =\n                         ta' \\<and>\n                         addr a = e'' \\<and> (h', l) = s''\n 4. \\<And>i T xs e'' s''.\n       \\<lbrakk>i <s 0;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt NegativeArraySize) =\n                         e'' \\<and>\n                         (shr s, xs) = s''\n 5. \\<And>i T l e'' s''.\n       \\<lbrakk>0 \\<le>s i;\n        allocate (shr s) (Array_type T (nat (sint i))) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 6. \\<And>e ta e' s' C xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast C e,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> Cast C e' = e'' \\<and> s' = s''\n 7. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Val v = e'' \\<and> (shr s, xs) = s''\n 8. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt ClassCast) = e'' \\<and>\n                         (shr s, xs) = s''\n 9. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>e instanceof T,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         e' instanceof T = e'' \\<and> s' = s''\n 10. \\<And>v U b T xs e'' s''.\n        \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                 \\<lfloor>U\\<rfloor>;\n         b = (v \\<noteq> Null \\<and> P \\<turnstile> U \\<le> T);\n         convert_extTA\n          extTA,P,t \\<turnstile> \\<langle>Val v instanceof T,\n                                  (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                 \\<langle>e'',s''\\<rangle>;\n         final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n         final_thread.actions_ok final s t ta'\\<rbrakk>\n        \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                          Val (Bool b) = e'' \\<and> (shr s, xs) = s''\nA total of 97 subgoals...", "case RedNewArray"], ["proof (state)\nthis:\n  0 \\<le>s i_\n  (h'_, a_) \\<in> allocate (shr s) (Array_type T_ (nat (sint i_)))\n  convert_extTA\n   extTA,P,t \\<turnstile> \\<langle>newA T_\\<lfloor>Val (Intg i_)\\<rceil>,\n                           (shr s, l_)\\<rangle> -ta'\\<rightarrow>\n                          \\<langle>e'',s''\\<rangle>\n  final_thread.actions_ok final s t\n   \\<lbrace>NewHeapElem a_ (Array_type T_ (nat (sint i_)))\\<rbrace>\n  final_thread.actions_ok final s t ta'\n\ngoal (97 subgoals):\n 1. \\<And>C l e'' s''.\n       \\<lbrakk>allocate (shr s) (Class_type C) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>new C,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 2. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         newA T\\<lfloor>e'\\<rceil> = e'' \\<and> s' = s''\n 3. \\<And>i h' a T l e'' s''.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate (shr s) (Array_type T (nat (sint i)));\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t\n         \\<lbrace>NewHeapElem a (Array_type T (nat (sint i)))\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>NewHeapElem a\n                                   (Array_type T (nat (sint i)))\\<rbrace> =\n                         ta' \\<and>\n                         addr a = e'' \\<and> (h', l) = s''\n 4. \\<And>i T xs e'' s''.\n       \\<lbrakk>i <s 0;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt NegativeArraySize) =\n                         e'' \\<and>\n                         (shr s, xs) = s''\n 5. \\<And>i T l e'' s''.\n       \\<lbrakk>0 \\<le>s i;\n        allocate (shr s) (Array_type T (nat (sint i))) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 6. \\<And>e ta e' s' C xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast C e,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> Cast C e' = e'' \\<and> s' = s''\n 7. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Val v = e'' \\<and> (shr s, xs) = s''\n 8. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt ClassCast) = e'' \\<and>\n                         (shr s, xs) = s''\n 9. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>e instanceof T,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         e' instanceof T = e'' \\<and> s' = s''\n 10. \\<And>v U b T xs e'' s''.\n        \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                 \\<lfloor>U\\<rfloor>;\n         b = (v \\<noteq> Null \\<and> P \\<turnstile> U \\<le> T);\n         convert_extTA\n          extTA,P,t \\<turnstile> \\<langle>Val v instanceof T,\n                                  (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                 \\<langle>e'',s''\\<rangle>;\n         final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n         final_thread.actions_ok final s t ta'\\<rbrakk>\n        \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                          Val (Bool b) = e'' \\<and> (shr s, xs) = s''\nA total of 97 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  0 \\<le>s i_\n  (h'_, a_) \\<in> allocate (shr s) (Array_type T_ (nat (sint i_)))\n  convert_extTA\n   extTA,P,t \\<turnstile> \\<langle>newA T_\\<lfloor>Val (Intg i_)\\<rceil>,\n                           (shr s, l_)\\<rangle> -ta'\\<rightarrow>\n                          \\<langle>e'',s''\\<rangle>\n  final_thread.actions_ok final s t\n   \\<lbrace>NewHeapElem a_ (Array_type T_ (nat (sint i_)))\\<rbrace>\n  final_thread.actions_ok final s t ta'\n\ngoal (1 subgoal):\n 1. \\<lbrace>NewHeapElem a_ (Array_type T_ (nat (sint i_)))\\<rbrace> =\n    ta' \\<and>\n    addr a_ = e'' \\<and> (h'_, l_) = s''", "by(auto elim!: red_cases dest: deterministic_heap_ops_allocateD[OF det])"], ["proof (state)\nthis:\n  \\<lbrace>NewHeapElem a_ (Array_type T_ (nat (sint i_)))\\<rbrace> =\n  ta' \\<and>\n  addr a_ = e'' \\<and> (h'_, l_) = s''\n\ngoal (96 subgoals):\n 1. \\<And>C l e'' s''.\n       \\<lbrakk>allocate (shr s) (Class_type C) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>new C,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 2. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         newA T\\<lfloor>e'\\<rceil> = e'' \\<and> s' = s''\n 3. \\<And>i T xs e'' s''.\n       \\<lbrakk>i <s 0;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt NegativeArraySize) =\n                         e'' \\<and>\n                         (shr s, xs) = s''\n 4. \\<And>i T l e'' s''.\n       \\<lbrakk>0 \\<le>s i;\n        allocate (shr s) (Array_type T (nat (sint i))) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 5. \\<And>e ta e' s' C xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast C e,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> Cast C e' = e'' \\<and> s' = s''\n 6. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Val v = e'' \\<and> (shr s, xs) = s''\n 7. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt ClassCast) = e'' \\<and>\n                         (shr s, xs) = s''\n 8. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>e instanceof T,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         e' instanceof T = e'' \\<and> s' = s''\n 9. \\<And>v U b T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        b = (v \\<noteq> Null \\<and> P \\<turnstile> U \\<le> T);\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Val v instanceof T,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Val (Bool b) = e'' \\<and> (shr s, xs) = s''\n 10. \\<And>e ta e' s' bop e2 xs e'' s''.\n        \\<lbrakk>convert_extTA\n                  extTA,P,t \\<turnstile> \\<langle>e,\n    (shr s, xs)\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n         \\<And>e'' s''.\n            \\<lbrakk>convert_extTA\n                      extTA,P,t \\<turnstile> \\<langle>e,\n        (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n       \\<langle>e'',s''\\<rangle>;\n             final_thread.actions_ok final s t ta;\n             final_thread.actions_ok final s t ta'\\<rbrakk>\n            \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n         convert_extTA\n          extTA,P,t \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e2,\n                                  (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                 \\<langle>e'',s''\\<rangle>;\n         final_thread.actions_ok final s t ta;\n         final_thread.actions_ok final s t ta'\\<rbrakk>\n        \\<Longrightarrow> ta = ta' \\<and>\n                          e' \\<guillemotleft>bop\\<guillemotright> e2 =\n                          e'' \\<and>\n                          s' = s''\nA total of 96 subgoals...", "next"], ["proof (state)\ngoal (96 subgoals):\n 1. \\<And>C l e'' s''.\n       \\<lbrakk>allocate (shr s) (Class_type C) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>new C,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 2. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         newA T\\<lfloor>e'\\<rceil> = e'' \\<and> s' = s''\n 3. \\<And>i T xs e'' s''.\n       \\<lbrakk>i <s 0;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt NegativeArraySize) =\n                         e'' \\<and>\n                         (shr s, xs) = s''\n 4. \\<And>i T l e'' s''.\n       \\<lbrakk>0 \\<le>s i;\n        allocate (shr s) (Array_type T (nat (sint i))) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 5. \\<And>e ta e' s' C xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast C e,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> Cast C e' = e'' \\<and> s' = s''\n 6. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Val v = e'' \\<and> (shr s, xs) = s''\n 7. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt ClassCast) = e'' \\<and>\n                         (shr s, xs) = s''\n 8. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>e instanceof T,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         e' instanceof T = e'' \\<and> s' = s''\n 9. \\<And>v U b T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        b = (v \\<noteq> Null \\<and> P \\<turnstile> U \\<le> T);\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Val v instanceof T,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Val (Bool b) = e'' \\<and> (shr s, xs) = s''\n 10. \\<And>e ta e' s' bop e2 xs e'' s''.\n        \\<lbrakk>convert_extTA\n                  extTA,P,t \\<turnstile> \\<langle>e,\n    (shr s, xs)\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n         \\<And>e'' s''.\n            \\<lbrakk>convert_extTA\n                      extTA,P,t \\<turnstile> \\<langle>e,\n        (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n       \\<langle>e'',s''\\<rangle>;\n             final_thread.actions_ok final s t ta;\n             final_thread.actions_ok final s t ta'\\<rbrakk>\n            \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n         convert_extTA\n          extTA,P,t \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e2,\n                                  (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                 \\<langle>e'',s''\\<rangle>;\n         final_thread.actions_ok final s t ta;\n         final_thread.actions_ok final s t ta'\\<rbrakk>\n        \\<Longrightarrow> ta = ta' \\<and>\n                          e' \\<guillemotleft>bop\\<guillemotright> e2 =\n                          e'' \\<and>\n                          s' = s''\nA total of 96 subgoals...", "case RedCall"], ["proof (state)\nthis:\n  typeof_addr (hp (shr s, xs)) a_ = \\<lfloor>hU_\\<rfloor>\n  P \\<turnstile> class_type_of\n                  hU_ sees M_: Ts_\\<rightarrow>T_ = \\<lfloor>(pns_,\n                        body_)\\<rfloor> in D_\n  length vs_ = length pns_\n  length Ts_ = length pns_\n  convert_extTA\n   extTA,P,t \\<turnstile> \\<langle>addr a_\\<bullet>M_(map Val vs_),\n                           (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                          \\<langle>e'',s''\\<rangle>\n  final_thread.actions_ok final s t \\<lbrace>\\<rbrace>\n  final_thread.actions_ok final s t ta'\n\ngoal (96 subgoals):\n 1. \\<And>C l e'' s''.\n       \\<lbrakk>allocate (shr s) (Class_type C) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>new C,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 2. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         newA T\\<lfloor>e'\\<rceil> = e'' \\<and> s' = s''\n 3. \\<And>i T xs e'' s''.\n       \\<lbrakk>i <s 0;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt NegativeArraySize) =\n                         e'' \\<and>\n                         (shr s, xs) = s''\n 4. \\<And>i T l e'' s''.\n       \\<lbrakk>0 \\<le>s i;\n        allocate (shr s) (Array_type T (nat (sint i))) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 5. \\<And>e ta e' s' C xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast C e,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> Cast C e' = e'' \\<and> s' = s''\n 6. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Val v = e'' \\<and> (shr s, xs) = s''\n 7. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt ClassCast) = e'' \\<and>\n                         (shr s, xs) = s''\n 8. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>e instanceof T,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         e' instanceof T = e'' \\<and> s' = s''\n 9. \\<And>v U b T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        b = (v \\<noteq> Null \\<and> P \\<turnstile> U \\<le> T);\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Val v instanceof T,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Val (Bool b) = e'' \\<and> (shr s, xs) = s''\n 10. \\<And>e ta e' s' bop e2 xs e'' s''.\n        \\<lbrakk>convert_extTA\n                  extTA,P,t \\<turnstile> \\<langle>e,\n    (shr s, xs)\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n         \\<And>e'' s''.\n            \\<lbrakk>convert_extTA\n                      extTA,P,t \\<turnstile> \\<langle>e,\n        (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n       \\<langle>e'',s''\\<rangle>;\n             final_thread.actions_ok final s t ta;\n             final_thread.actions_ok final s t ta'\\<rbrakk>\n            \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n         convert_extTA\n          extTA,P,t \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e2,\n                                  (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                 \\<langle>e'',s''\\<rangle>;\n         final_thread.actions_ok final s t ta;\n         final_thread.actions_ok final s t ta'\\<rbrakk>\n        \\<Longrightarrow> ta = ta' \\<and>\n                          e' \\<guillemotleft>bop\\<guillemotright> e2 =\n                          e'' \\<and>\n                          s' = s''\nA total of 96 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  typeof_addr (hp (shr s, xs)) a_ = \\<lfloor>hU_\\<rfloor>\n  P \\<turnstile> class_type_of\n                  hU_ sees M_: Ts_\\<rightarrow>T_ = \\<lfloor>(pns_,\n                        body_)\\<rfloor> in D_\n  length vs_ = length pns_\n  length Ts_ = length pns_\n  convert_extTA\n   extTA,P,t \\<turnstile> \\<langle>addr a_\\<bullet>M_(map Val vs_),\n                           (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                          \\<langle>e'',s''\\<rangle>\n  final_thread.actions_ok final s t \\<lbrace>\\<rbrace>\n  final_thread.actions_ok final s t ta'\n\ngoal (1 subgoal):\n 1. \\<lbrace>\\<rbrace> = ta' \\<and>\n    blocks (this # pns_) (Class D_ # Ts_) (Addr a_ # vs_) body_ = e'' \\<and>\n    (shr s, xs) = s''", "by(auto elim!: red_cases dest: sees_method_fun simp add: map_eq_append_conv)"], ["proof (state)\nthis:\n  \\<lbrace>\\<rbrace> = ta' \\<and>\n  blocks (this # pns_) (Class D_ # Ts_) (Addr a_ # vs_) body_ = e'' \\<and>\n  (shr s, xs) = s''\n\ngoal (95 subgoals):\n 1. \\<And>C l e'' s''.\n       \\<lbrakk>allocate (shr s) (Class_type C) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>new C,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 2. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         newA T\\<lfloor>e'\\<rceil> = e'' \\<and> s' = s''\n 3. \\<And>i T xs e'' s''.\n       \\<lbrakk>i <s 0;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt NegativeArraySize) =\n                         e'' \\<and>\n                         (shr s, xs) = s''\n 4. \\<And>i T l e'' s''.\n       \\<lbrakk>0 \\<le>s i;\n        allocate (shr s) (Array_type T (nat (sint i))) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 5. \\<And>e ta e' s' C xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast C e,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> Cast C e' = e'' \\<and> s' = s''\n 6. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Val v = e'' \\<and> (shr s, xs) = s''\n 7. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt ClassCast) = e'' \\<and>\n                         (shr s, xs) = s''\n 8. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>e instanceof T,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         e' instanceof T = e'' \\<and> s' = s''\n 9. \\<And>v U b T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        b = (v \\<noteq> Null \\<and> P \\<turnstile> U \\<le> T);\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Val v instanceof T,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Val (Bool b) = e'' \\<and> (shr s, xs) = s''\n 10. \\<And>e ta e' s' bop e2 xs e'' s''.\n        \\<lbrakk>convert_extTA\n                  extTA,P,t \\<turnstile> \\<langle>e,\n    (shr s, xs)\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n         \\<And>e'' s''.\n            \\<lbrakk>convert_extTA\n                      extTA,P,t \\<turnstile> \\<langle>e,\n        (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n       \\<langle>e'',s''\\<rangle>;\n             final_thread.actions_ok final s t ta;\n             final_thread.actions_ok final s t ta'\\<rbrakk>\n            \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n         convert_extTA\n          extTA,P,t \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e2,\n                                  (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                 \\<langle>e'',s''\\<rangle>;\n         final_thread.actions_ok final s t ta;\n         final_thread.actions_ok final s t ta'\\<rbrakk>\n        \\<Longrightarrow> ta = ta' \\<and>\n                          e' \\<guillemotleft>bop\\<guillemotright> e2 =\n                          e'' \\<and>\n                          s' = s''\nA total of 95 subgoals...", "next"], ["proof (state)\ngoal (95 subgoals):\n 1. \\<And>C l e'' s''.\n       \\<lbrakk>allocate (shr s) (Class_type C) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>new C,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 2. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         newA T\\<lfloor>e'\\<rceil> = e'' \\<and> s' = s''\n 3. \\<And>i T xs e'' s''.\n       \\<lbrakk>i <s 0;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt NegativeArraySize) =\n                         e'' \\<and>\n                         (shr s, xs) = s''\n 4. \\<And>i T l e'' s''.\n       \\<lbrakk>0 \\<le>s i;\n        allocate (shr s) (Array_type T (nat (sint i))) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 5. \\<And>e ta e' s' C xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast C e,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> Cast C e' = e'' \\<and> s' = s''\n 6. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Val v = e'' \\<and> (shr s, xs) = s''\n 7. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt ClassCast) = e'' \\<and>\n                         (shr s, xs) = s''\n 8. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>e instanceof T,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         e' instanceof T = e'' \\<and> s' = s''\n 9. \\<And>v U b T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        b = (v \\<noteq> Null \\<and> P \\<turnstile> U \\<le> T);\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Val v instanceof T,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Val (Bool b) = e'' \\<and> (shr s, xs) = s''\n 10. \\<And>e ta e' s' bop e2 xs e'' s''.\n        \\<lbrakk>convert_extTA\n                  extTA,P,t \\<turnstile> \\<langle>e,\n    (shr s, xs)\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n         \\<And>e'' s''.\n            \\<lbrakk>convert_extTA\n                      extTA,P,t \\<turnstile> \\<langle>e,\n        (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n       \\<langle>e'',s''\\<rangle>;\n             final_thread.actions_ok final s t ta;\n             final_thread.actions_ok final s t ta'\\<rbrakk>\n            \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n         convert_extTA\n          extTA,P,t \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e2,\n                                  (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                 \\<langle>e'',s''\\<rangle>;\n         final_thread.actions_ok final s t ta;\n         final_thread.actions_ok final s t ta'\\<rbrakk>\n        \\<Longrightarrow> ta = ta' \\<and>\n                          e' \\<guillemotleft>bop\\<guillemotright> e2 =\n                          e'' \\<and>\n                          s' = s''\nA total of 95 subgoals...", "case RedCallExternal"], ["proof (state)\nthis:\n  typeof_addr (hp (shr s, xs)) a_ = \\<lfloor>hU_\\<rfloor>\n  P \\<turnstile> class_type_of\n                  hU_ sees M_: Ts_\\<rightarrow>T_ = Native in D_\n  P,t \\<turnstile> \\<langle>a_\\<bullet>M_(vs_),\n                   hp (shr s,\n                       xs)\\<rangle> -ta_\\<rightarrow>ext \\<langle>va_,\n                   h'_\\<rangle>\n  ta'_ = convert_extTA extTA ta_\n  e'_ = extRet2J (addr a_\\<bullet>M_(map Val vs_)) va_\n  s'_ = (h'_, lcl (shr s, xs))\n  convert_extTA\n   extTA,P,t \\<turnstile> \\<langle>addr a_\\<bullet>M_(map Val vs_),\n                           (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                          \\<langle>e'',s''\\<rangle>\n  final_thread.actions_ok final s t ta'_\n  final_thread.actions_ok final s t ta'\n\ngoal (95 subgoals):\n 1. \\<And>C l e'' s''.\n       \\<lbrakk>allocate (shr s) (Class_type C) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>new C,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 2. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         newA T\\<lfloor>e'\\<rceil> = e'' \\<and> s' = s''\n 3. \\<And>i T xs e'' s''.\n       \\<lbrakk>i <s 0;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt NegativeArraySize) =\n                         e'' \\<and>\n                         (shr s, xs) = s''\n 4. \\<And>i T l e'' s''.\n       \\<lbrakk>0 \\<le>s i;\n        allocate (shr s) (Array_type T (nat (sint i))) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 5. \\<And>e ta e' s' C xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast C e,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> Cast C e' = e'' \\<and> s' = s''\n 6. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Val v = e'' \\<and> (shr s, xs) = s''\n 7. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt ClassCast) = e'' \\<and>\n                         (shr s, xs) = s''\n 8. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>e instanceof T,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         e' instanceof T = e'' \\<and> s' = s''\n 9. \\<And>v U b T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        b = (v \\<noteq> Null \\<and> P \\<turnstile> U \\<le> T);\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Val v instanceof T,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Val (Bool b) = e'' \\<and> (shr s, xs) = s''\n 10. \\<And>e ta e' s' bop e2 xs e'' s''.\n        \\<lbrakk>convert_extTA\n                  extTA,P,t \\<turnstile> \\<langle>e,\n    (shr s, xs)\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n         \\<And>e'' s''.\n            \\<lbrakk>convert_extTA\n                      extTA,P,t \\<turnstile> \\<langle>e,\n        (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n       \\<langle>e'',s''\\<rangle>;\n             final_thread.actions_ok final s t ta;\n             final_thread.actions_ok final s t ta'\\<rbrakk>\n            \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n         convert_extTA\n          extTA,P,t \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e2,\n                                  (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                 \\<langle>e'',s''\\<rangle>;\n         final_thread.actions_ok final s t ta;\n         final_thread.actions_ok final s t ta'\\<rbrakk>\n        \\<Longrightarrow> ta = ta' \\<and>\n                          e' \\<guillemotleft>bop\\<guillemotright> e2 =\n                          e'' \\<and>\n                          s' = s''\nA total of 95 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  typeof_addr (hp (shr s, xs)) a_ = \\<lfloor>hU_\\<rfloor>\n  P \\<turnstile> class_type_of\n                  hU_ sees M_: Ts_\\<rightarrow>T_ = Native in D_\n  P,t \\<turnstile> \\<langle>a_\\<bullet>M_(vs_),\n                   hp (shr s,\n                       xs)\\<rangle> -ta_\\<rightarrow>ext \\<langle>va_,\n                   h'_\\<rangle>\n  ta'_ = convert_extTA extTA ta_\n  e'_ = extRet2J (addr a_\\<bullet>M_(map Val vs_)) va_\n  s'_ = (h'_, lcl (shr s, xs))\n  convert_extTA\n   extTA,P,t \\<turnstile> \\<langle>addr a_\\<bullet>M_(map Val vs_),\n                           (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                          \\<langle>e'',s''\\<rangle>\n  final_thread.actions_ok final s t ta'_\n  final_thread.actions_ok final s t ta'\n\ngoal (1 subgoal):\n 1. ta'_ = ta' \\<and> e'_ = e'' \\<and> s'_ = s''", "by(auto elim!: red_cases dest: red_external_deterministic[OF det] simp add: final_thread.actions_ok_iff map_eq_append_conv dest: sees_method_fun)"], ["proof (state)\nthis:\n  ta'_ = ta' \\<and> e'_ = e'' \\<and> s'_ = s''\n\ngoal (94 subgoals):\n 1. \\<And>C l e'' s''.\n       \\<lbrakk>allocate (shr s) (Class_type C) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>new C,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 2. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         newA T\\<lfloor>e'\\<rceil> = e'' \\<and> s' = s''\n 3. \\<And>i T xs e'' s''.\n       \\<lbrakk>i <s 0;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt NegativeArraySize) =\n                         e'' \\<and>\n                         (shr s, xs) = s''\n 4. \\<And>i T l e'' s''.\n       \\<lbrakk>0 \\<le>s i;\n        allocate (shr s) (Array_type T (nat (sint i))) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 5. \\<And>e ta e' s' C xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast C e,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> Cast C e' = e'' \\<and> s' = s''\n 6. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Val v = e'' \\<and> (shr s, xs) = s''\n 7. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt ClassCast) = e'' \\<and>\n                         (shr s, xs) = s''\n 8. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>e instanceof T,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         e' instanceof T = e'' \\<and> s' = s''\n 9. \\<And>v U b T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        b = (v \\<noteq> Null \\<and> P \\<turnstile> U \\<le> T);\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Val v instanceof T,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Val (Bool b) = e'' \\<and> (shr s, xs) = s''\n 10. \\<And>e ta e' s' bop e2 xs e'' s''.\n        \\<lbrakk>convert_extTA\n                  extTA,P,t \\<turnstile> \\<langle>e,\n    (shr s, xs)\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n         \\<And>e'' s''.\n            \\<lbrakk>convert_extTA\n                      extTA,P,t \\<turnstile> \\<langle>e,\n        (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n       \\<langle>e'',s''\\<rangle>;\n             final_thread.actions_ok final s t ta;\n             final_thread.actions_ok final s t ta'\\<rbrakk>\n            \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n         convert_extTA\n          extTA,P,t \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e2,\n                                  (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                 \\<langle>e'',s''\\<rangle>;\n         final_thread.actions_ok final s t ta;\n         final_thread.actions_ok final s t ta'\\<rbrakk>\n        \\<Longrightarrow> ta = ta' \\<and>\n                          e' \\<guillemotleft>bop\\<guillemotright> e2 =\n                          e'' \\<and>\n                          s' = s''\nA total of 94 subgoals...", "next"], ["proof (state)\ngoal (94 subgoals):\n 1. \\<And>C l e'' s''.\n       \\<lbrakk>allocate (shr s) (Class_type C) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>new C,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 2. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         newA T\\<lfloor>e'\\<rceil> = e'' \\<and> s' = s''\n 3. \\<And>i T xs e'' s''.\n       \\<lbrakk>i <s 0;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt NegativeArraySize) =\n                         e'' \\<and>\n                         (shr s, xs) = s''\n 4. \\<And>i T l e'' s''.\n       \\<lbrakk>0 \\<le>s i;\n        allocate (shr s) (Array_type T (nat (sint i))) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 5. \\<And>e ta e' s' C xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast C e,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> Cast C e' = e'' \\<and> s' = s''\n 6. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Val v = e'' \\<and> (shr s, xs) = s''\n 7. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt ClassCast) = e'' \\<and>\n                         (shr s, xs) = s''\n 8. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>e instanceof T,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         e' instanceof T = e'' \\<and> s' = s''\n 9. \\<And>v U b T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        b = (v \\<noteq> Null \\<and> P \\<turnstile> U \\<le> T);\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Val v instanceof T,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Val (Bool b) = e'' \\<and> (shr s, xs) = s''\n 10. \\<And>e ta e' s' bop e2 xs e'' s''.\n        \\<lbrakk>convert_extTA\n                  extTA,P,t \\<turnstile> \\<langle>e,\n    (shr s, xs)\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n         \\<And>e'' s''.\n            \\<lbrakk>convert_extTA\n                      extTA,P,t \\<turnstile> \\<langle>e,\n        (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n       \\<langle>e'',s''\\<rangle>;\n             final_thread.actions_ok final s t ta;\n             final_thread.actions_ok final s t ta'\\<rbrakk>\n            \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n         convert_extTA\n          extTA,P,t \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e2,\n                                  (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                 \\<langle>e'',s''\\<rangle>;\n         final_thread.actions_ok final s t ta;\n         final_thread.actions_ok final s t ta'\\<rbrakk>\n        \\<Longrightarrow> ta = ta' \\<and>\n                          e' \\<guillemotleft>bop\\<guillemotright> e2 =\n                          e'' \\<and>\n                          s' = s''\nA total of 94 subgoals...", "case RedCallNull"], ["proof (state)\nthis:\n  convert_extTA\n   extTA,P,t \\<turnstile> \\<langle>null\\<bullet>M_(map Val vs_),\n                           (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                          \\<langle>e'',s''\\<rangle>\n  final_thread.actions_ok final s t \\<lbrace>\\<rbrace>\n  final_thread.actions_ok final s t ta'\n\ngoal (94 subgoals):\n 1. \\<And>C l e'' s''.\n       \\<lbrakk>allocate (shr s) (Class_type C) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>new C,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 2. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         newA T\\<lfloor>e'\\<rceil> = e'' \\<and> s' = s''\n 3. \\<And>i T xs e'' s''.\n       \\<lbrakk>i <s 0;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt NegativeArraySize) =\n                         e'' \\<and>\n                         (shr s, xs) = s''\n 4. \\<And>i T l e'' s''.\n       \\<lbrakk>0 \\<le>s i;\n        allocate (shr s) (Array_type T (nat (sint i))) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 5. \\<And>e ta e' s' C xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast C e,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> Cast C e' = e'' \\<and> s' = s''\n 6. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Val v = e'' \\<and> (shr s, xs) = s''\n 7. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt ClassCast) = e'' \\<and>\n                         (shr s, xs) = s''\n 8. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>e instanceof T,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         e' instanceof T = e'' \\<and> s' = s''\n 9. \\<And>v U b T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        b = (v \\<noteq> Null \\<and> P \\<turnstile> U \\<le> T);\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Val v instanceof T,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Val (Bool b) = e'' \\<and> (shr s, xs) = s''\n 10. \\<And>e ta e' s' bop e2 xs e'' s''.\n        \\<lbrakk>convert_extTA\n                  extTA,P,t \\<turnstile> \\<langle>e,\n    (shr s, xs)\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n         \\<And>e'' s''.\n            \\<lbrakk>convert_extTA\n                      extTA,P,t \\<turnstile> \\<langle>e,\n        (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n       \\<langle>e'',s''\\<rangle>;\n             final_thread.actions_ok final s t ta;\n             final_thread.actions_ok final s t ta'\\<rbrakk>\n            \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n         convert_extTA\n          extTA,P,t \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e2,\n                                  (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                 \\<langle>e'',s''\\<rangle>;\n         final_thread.actions_ok final s t ta;\n         final_thread.actions_ok final s t ta'\\<rbrakk>\n        \\<Longrightarrow> ta = ta' \\<and>\n                          e' \\<guillemotleft>bop\\<guillemotright> e2 =\n                          e'' \\<and>\n                          s' = s''\nA total of 94 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  convert_extTA\n   extTA,P,t \\<turnstile> \\<langle>null\\<bullet>M_(map Val vs_),\n                           (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                          \\<langle>e'',s''\\<rangle>\n  final_thread.actions_ok final s t \\<lbrace>\\<rbrace>\n  final_thread.actions_ok final s t ta'\n\ngoal (1 subgoal):\n 1. \\<lbrace>\\<rbrace> = ta' \\<and>\n    Throw (addr_of_sys_xcpt NullPointer) = e'' \\<and> (shr s, xs) = s''", "by(auto elim!: red_cases dest: sees_method_fun simp add: map_eq_append_conv)"], ["proof (state)\nthis:\n  \\<lbrace>\\<rbrace> = ta' \\<and>\n  Throw (addr_of_sys_xcpt NullPointer) = e'' \\<and> (shr s, xs) = s''\n\ngoal (93 subgoals):\n 1. \\<And>C l e'' s''.\n       \\<lbrakk>allocate (shr s) (Class_type C) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>new C,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 2. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         newA T\\<lfloor>e'\\<rceil> = e'' \\<and> s' = s''\n 3. \\<And>i T xs e'' s''.\n       \\<lbrakk>i <s 0;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt NegativeArraySize) =\n                         e'' \\<and>\n                         (shr s, xs) = s''\n 4. \\<And>i T l e'' s''.\n       \\<lbrakk>0 \\<le>s i;\n        allocate (shr s) (Array_type T (nat (sint i))) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 5. \\<And>e ta e' s' C xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast C e,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> Cast C e' = e'' \\<and> s' = s''\n 6. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Val v = e'' \\<and> (shr s, xs) = s''\n 7. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt ClassCast) = e'' \\<and>\n                         (shr s, xs) = s''\n 8. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>e instanceof T,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         e' instanceof T = e'' \\<and> s' = s''\n 9. \\<And>v U b T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        b = (v \\<noteq> Null \\<and> P \\<turnstile> U \\<le> T);\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Val v instanceof T,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Val (Bool b) = e'' \\<and> (shr s, xs) = s''\n 10. \\<And>e ta e' s' bop e2 xs e'' s''.\n        \\<lbrakk>convert_extTA\n                  extTA,P,t \\<turnstile> \\<langle>e,\n    (shr s, xs)\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n         \\<And>e'' s''.\n            \\<lbrakk>convert_extTA\n                      extTA,P,t \\<turnstile> \\<langle>e,\n        (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n       \\<langle>e'',s''\\<rangle>;\n             final_thread.actions_ok final s t ta;\n             final_thread.actions_ok final s t ta'\\<rbrakk>\n            \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n         convert_extTA\n          extTA,P,t \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e2,\n                                  (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                 \\<langle>e'',s''\\<rangle>;\n         final_thread.actions_ok final s t ta;\n         final_thread.actions_ok final s t ta'\\<rbrakk>\n        \\<Longrightarrow> ta = ta' \\<and>\n                          e' \\<guillemotleft>bop\\<guillemotright> e2 =\n                          e'' \\<and>\n                          s' = s''\nA total of 93 subgoals...", "next"], ["proof (state)\ngoal (93 subgoals):\n 1. \\<And>C l e'' s''.\n       \\<lbrakk>allocate (shr s) (Class_type C) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>new C,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 2. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         newA T\\<lfloor>e'\\<rceil> = e'' \\<and> s' = s''\n 3. \\<And>i T xs e'' s''.\n       \\<lbrakk>i <s 0;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt NegativeArraySize) =\n                         e'' \\<and>\n                         (shr s, xs) = s''\n 4. \\<And>i T l e'' s''.\n       \\<lbrakk>0 \\<le>s i;\n        allocate (shr s) (Array_type T (nat (sint i))) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 5. \\<And>e ta e' s' C xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast C e,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> Cast C e' = e'' \\<and> s' = s''\n 6. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Val v = e'' \\<and> (shr s, xs) = s''\n 7. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt ClassCast) = e'' \\<and>\n                         (shr s, xs) = s''\n 8. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>e instanceof T,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         e' instanceof T = e'' \\<and> s' = s''\n 9. \\<And>v U b T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        b = (v \\<noteq> Null \\<and> P \\<turnstile> U \\<le> T);\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Val v instanceof T,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Val (Bool b) = e'' \\<and> (shr s, xs) = s''\n 10. \\<And>e ta e' s' bop e2 xs e'' s''.\n        \\<lbrakk>convert_extTA\n                  extTA,P,t \\<turnstile> \\<langle>e,\n    (shr s, xs)\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n         \\<And>e'' s''.\n            \\<lbrakk>convert_extTA\n                      extTA,P,t \\<turnstile> \\<langle>e,\n        (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n       \\<langle>e'',s''\\<rangle>;\n             final_thread.actions_ok final s t ta;\n             final_thread.actions_ok final s t ta'\\<rbrakk>\n            \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n         convert_extTA\n          extTA,P,t \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e2,\n                                  (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                 \\<langle>e'',s''\\<rangle>;\n         final_thread.actions_ok final s t ta;\n         final_thread.actions_ok final s t ta'\\<rbrakk>\n        \\<Longrightarrow> ta = ta' \\<and>\n                          e' \\<guillemotleft>bop\\<guillemotright> e2 =\n                          e'' \\<and>\n                          s' = s''\nA total of 93 subgoals...", "case CallThrowParams"], ["proof (state)\nthis:\n  es_ = map Val vs_ @ Throw a_ # es'_\n  convert_extTA\n   extTA,P,t \\<turnstile> \\<langle>Val v_\\<bullet>M_(es_),\n                           (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                          \\<langle>e'',s''\\<rangle>\n  final_thread.actions_ok final s t \\<lbrace>\\<rbrace>\n  final_thread.actions_ok final s t ta'\n\ngoal (93 subgoals):\n 1. \\<And>C l e'' s''.\n       \\<lbrakk>allocate (shr s) (Class_type C) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>new C,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 2. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         newA T\\<lfloor>e'\\<rceil> = e'' \\<and> s' = s''\n 3. \\<And>i T xs e'' s''.\n       \\<lbrakk>i <s 0;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt NegativeArraySize) =\n                         e'' \\<and>\n                         (shr s, xs) = s''\n 4. \\<And>i T l e'' s''.\n       \\<lbrakk>0 \\<le>s i;\n        allocate (shr s) (Array_type T (nat (sint i))) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 5. \\<And>e ta e' s' C xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast C e,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> Cast C e' = e'' \\<and> s' = s''\n 6. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Val v = e'' \\<and> (shr s, xs) = s''\n 7. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt ClassCast) = e'' \\<and>\n                         (shr s, xs) = s''\n 8. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>e instanceof T,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         e' instanceof T = e'' \\<and> s' = s''\n 9. \\<And>v U b T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        b = (v \\<noteq> Null \\<and> P \\<turnstile> U \\<le> T);\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Val v instanceof T,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Val (Bool b) = e'' \\<and> (shr s, xs) = s''\n 10. \\<And>e ta e' s' bop e2 xs e'' s''.\n        \\<lbrakk>convert_extTA\n                  extTA,P,t \\<turnstile> \\<langle>e,\n    (shr s, xs)\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n         \\<And>e'' s''.\n            \\<lbrakk>convert_extTA\n                      extTA,P,t \\<turnstile> \\<langle>e,\n        (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n       \\<langle>e'',s''\\<rangle>;\n             final_thread.actions_ok final s t ta;\n             final_thread.actions_ok final s t ta'\\<rbrakk>\n            \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n         convert_extTA\n          extTA,P,t \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e2,\n                                  (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                 \\<langle>e'',s''\\<rangle>;\n         final_thread.actions_ok final s t ta;\n         final_thread.actions_ok final s t ta'\\<rbrakk>\n        \\<Longrightarrow> ta = ta' \\<and>\n                          e' \\<guillemotleft>bop\\<guillemotright> e2 =\n                          e'' \\<and>\n                          s' = s''\nA total of 93 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  es_ = map Val vs_ @ Throw a_ # es'_\n  convert_extTA\n   extTA,P,t \\<turnstile> \\<langle>Val v_\\<bullet>M_(es_),\n                           (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                          \\<langle>e'',s''\\<rangle>\n  final_thread.actions_ok final s t \\<lbrace>\\<rbrace>\n  final_thread.actions_ok final s t ta'\n\ngoal (1 subgoal):\n 1. \\<lbrace>\\<rbrace> = ta' \\<and> Throw a_ = e'' \\<and> (shr s, xs) = s''", "by(auto elim!: red_cases dest: sees_method_fun simp add: map_eq_append_conv append_eq_map_conv append_eq_append_conv2 reds_map_Val_Throw Cons_eq_append_conv append_eq_Cons_conv)"], ["proof (state)\nthis:\n  \\<lbrace>\\<rbrace> = ta' \\<and> Throw a_ = e'' \\<and> (shr s, xs) = s''\n\ngoal (92 subgoals):\n 1. \\<And>C l e'' s''.\n       \\<lbrakk>allocate (shr s) (Class_type C) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>new C,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 2. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         newA T\\<lfloor>e'\\<rceil> = e'' \\<and> s' = s''\n 3. \\<And>i T xs e'' s''.\n       \\<lbrakk>i <s 0;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt NegativeArraySize) =\n                         e'' \\<and>\n                         (shr s, xs) = s''\n 4. \\<And>i T l e'' s''.\n       \\<lbrakk>0 \\<le>s i;\n        allocate (shr s) (Array_type T (nat (sint i))) = {};\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                   (Intg i)\\<rceil>,\n                                 (shr s, l)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt OutOfMemory) = e'' \\<and>\n                         (shr s, l) = s''\n 5. \\<And>e ta e' s' C xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast C e,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> Cast C e' = e'' \\<and> s' = s''\n 6. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Val v = e'' \\<and> (shr s, xs) = s''\n 7. \\<And>v U T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Cast T (Val v),\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Throw (addr_of_sys_xcpt ClassCast) = e'' \\<and>\n                         (shr s, xs) = s''\n 8. \\<And>e ta e' s' T xs e'' s''.\n       \\<lbrakk>convert_extTA\n                 extTA,P,t \\<turnstile> \\<langle>e,\n   (shr s, xs)\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<And>e'' s''.\n           \\<lbrakk>convert_extTA\n                     extTA,P,t \\<turnstile> \\<langle>e,\n       (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n      \\<langle>e'',s''\\<rangle>;\n            final_thread.actions_ok final s t ta;\n            final_thread.actions_ok final s t ta'\\<rbrakk>\n           \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>e instanceof T,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t ta;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and>\n                         e' instanceof T = e'' \\<and> s' = s''\n 9. \\<And>v U b T xs e'' s''.\n       \\<lbrakk>typeof\\<^bsub>hp (shr s, xs)\\<^esub> v =\n                \\<lfloor>U\\<rfloor>;\n        b = (v \\<noteq> Null \\<and> P \\<turnstile> U \\<le> T);\n        convert_extTA\n         extTA,P,t \\<turnstile> \\<langle>Val v instanceof T,\n                                 (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e'',s''\\<rangle>;\n        final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        final_thread.actions_ok final s t ta'\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = ta' \\<and>\n                         Val (Bool b) = e'' \\<and> (shr s, xs) = s''\n 10. \\<And>e ta e' s' bop e2 xs e'' s''.\n        \\<lbrakk>convert_extTA\n                  extTA,P,t \\<turnstile> \\<langle>e,\n    (shr s, xs)\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n         \\<And>e'' s''.\n            \\<lbrakk>convert_extTA\n                      extTA,P,t \\<turnstile> \\<langle>e,\n        (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n       \\<langle>e'',s''\\<rangle>;\n             final_thread.actions_ok final s t ta;\n             final_thread.actions_ok final s t ta'\\<rbrakk>\n            \\<Longrightarrow> ta = ta' \\<and> e' = e'' \\<and> s' = s'';\n         convert_extTA\n          extTA,P,t \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e2,\n                                  (shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                                 \\<langle>e'',s''\\<rangle>;\n         final_thread.actions_ok final s t ta;\n         final_thread.actions_ok final s t ta'\\<rbrakk>\n        \\<Longrightarrow> ta = ta' \\<and>\n                          e' \\<guillemotleft>bop\\<guillemotright> e2 =\n                          e'' \\<and>\n                          s' = s''\nA total of 92 subgoals...", "qed(fastforce elim!: red_cases reds_cases dest: deterministic_heap_ops_readD[OF det] deterministic_heap_ops_writeD[OF det] iff: reds_map_Val_Throw)+"], ["", "lemma red_mthr_deterministic:\n  assumes det: \"deterministic_heap_ops\"\n  shows \"red_mthr.deterministic P UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. red_mthr.deterministic P UNIV", "proof(rule red_mthr.determisticI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s t x ta' x' m' ta'' x'' m''.\n       \\<lbrakk>s \\<in> UNIV;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta' x' m';\n        red_mthr.r_syntax P t x (shr s) ta'' x'' m'';\n        red_mthr.actions_ok s t ta'; red_mthr.actions_ok s t ta''\\<rbrakk>\n       \\<Longrightarrow> ta' = ta'' \\<and> x' = x'' \\<and> m' = m''\n 2. invariant3p (mredT P) UNIV", "fix s t x ta' x' m' ta'' x'' m''"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s t x ta' x' m' ta'' x'' m''.\n       \\<lbrakk>s \\<in> UNIV;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta' x' m';\n        red_mthr.r_syntax P t x (shr s) ta'' x'' m'';\n        red_mthr.actions_ok s t ta'; red_mthr.actions_ok s t ta''\\<rbrakk>\n       \\<Longrightarrow> ta' = ta'' \\<and> x' = x'' \\<and> m' = m''\n 2. invariant3p (mredT P) UNIV", "assume \"thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\"\n    and red: \"mred P t (x, shr s) ta' (x', m')\" \"mred P t (x, shr s) ta'' (x'', m'')\"\n    and aok: \"red_mthr.actions_ok s t ta'\" \"red_mthr.actions_ok s t ta''\""], ["proof (state)\nthis:\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  red_mthr.r_syntax P t x (shr s) ta' x' m'\n  red_mthr.r_syntax P t x (shr s) ta'' x'' m''\n  red_mthr.actions_ok s t ta'\n  red_mthr.actions_ok s t ta''\n\ngoal (2 subgoals):\n 1. \\<And>s t x ta' x' m' ta'' x'' m''.\n       \\<lbrakk>s \\<in> UNIV;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta' x' m';\n        red_mthr.r_syntax P t x (shr s) ta'' x'' m'';\n        red_mthr.actions_ok s t ta'; red_mthr.actions_ok s t ta''\\<rbrakk>\n       \\<Longrightarrow> ta' = ta'' \\<and> x' = x'' \\<and> m' = m''\n 2. invariant3p (mredT P) UNIV", "moreover"], ["proof (state)\nthis:\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  red_mthr.r_syntax P t x (shr s) ta' x' m'\n  red_mthr.r_syntax P t x (shr s) ta'' x'' m''\n  red_mthr.actions_ok s t ta'\n  red_mthr.actions_ok s t ta''\n\ngoal (2 subgoals):\n 1. \\<And>s t x ta' x' m' ta'' x'' m''.\n       \\<lbrakk>s \\<in> UNIV;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta' x' m';\n        red_mthr.r_syntax P t x (shr s) ta'' x'' m'';\n        red_mthr.actions_ok s t ta'; red_mthr.actions_ok s t ta''\\<rbrakk>\n       \\<Longrightarrow> ta' = ta'' \\<and> x' = x'' \\<and> m' = m''\n 2. invariant3p (mredT P) UNIV", "obtain e xs where [simp]: \"x = (e, xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e xs. x = (e, xs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases x)"], ["proof (state)\nthis:\n  x = (e, xs)\n\ngoal (2 subgoals):\n 1. \\<And>s t x ta' x' m' ta'' x'' m''.\n       \\<lbrakk>s \\<in> UNIV;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta' x' m';\n        red_mthr.r_syntax P t x (shr s) ta'' x'' m'';\n        red_mthr.actions_ok s t ta'; red_mthr.actions_ok s t ta''\\<rbrakk>\n       \\<Longrightarrow> ta' = ta'' \\<and> x' = x'' \\<and> m' = m''\n 2. invariant3p (mredT P) UNIV", "moreover"], ["proof (state)\nthis:\n  x = (e, xs)\n\ngoal (2 subgoals):\n 1. \\<And>s t x ta' x' m' ta'' x'' m''.\n       \\<lbrakk>s \\<in> UNIV;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta' x' m';\n        red_mthr.r_syntax P t x (shr s) ta'' x'' m'';\n        red_mthr.actions_ok s t ta'; red_mthr.actions_ok s t ta''\\<rbrakk>\n       \\<Longrightarrow> ta' = ta'' \\<and> x' = x'' \\<and> m' = m''\n 2. invariant3p (mredT P) UNIV", "obtain e' xs' where [simp]: \"x' = (e', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e' xs'.\n        x' = (e', xs') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases x')"], ["proof (state)\nthis:\n  x' = (e', xs')\n\ngoal (2 subgoals):\n 1. \\<And>s t x ta' x' m' ta'' x'' m''.\n       \\<lbrakk>s \\<in> UNIV;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta' x' m';\n        red_mthr.r_syntax P t x (shr s) ta'' x'' m'';\n        red_mthr.actions_ok s t ta'; red_mthr.actions_ok s t ta''\\<rbrakk>\n       \\<Longrightarrow> ta' = ta'' \\<and> x' = x'' \\<and> m' = m''\n 2. invariant3p (mredT P) UNIV", "moreover"], ["proof (state)\nthis:\n  x' = (e', xs')\n\ngoal (2 subgoals):\n 1. \\<And>s t x ta' x' m' ta'' x'' m''.\n       \\<lbrakk>s \\<in> UNIV;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta' x' m';\n        red_mthr.r_syntax P t x (shr s) ta'' x'' m'';\n        red_mthr.actions_ok s t ta'; red_mthr.actions_ok s t ta''\\<rbrakk>\n       \\<Longrightarrow> ta' = ta'' \\<and> x' = x'' \\<and> m' = m''\n 2. invariant3p (mredT P) UNIV", "obtain e'' xs'' where [simp]: \"x'' = (e'', xs'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e'' xs''.\n        x'' = (e'', xs'') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases x'')"], ["proof (state)\nthis:\n  x'' = (e'', xs'')\n\ngoal (2 subgoals):\n 1. \\<And>s t x ta' x' m' ta'' x'' m''.\n       \\<lbrakk>s \\<in> UNIV;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta' x' m';\n        red_mthr.r_syntax P t x (shr s) ta'' x'' m'';\n        red_mthr.actions_ok s t ta'; red_mthr.actions_ok s t ta''\\<rbrakk>\n       \\<Longrightarrow> ta' = ta'' \\<and> x' = x'' \\<and> m' = m''\n 2. invariant3p (mredT P) UNIV", "ultimately"], ["proof (chain)\npicking this:\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  red_mthr.r_syntax P t x (shr s) ta' x' m'\n  red_mthr.r_syntax P t x (shr s) ta'' x'' m''\n  red_mthr.actions_ok s t ta'\n  red_mthr.actions_ok s t ta''\n  x = (e, xs)\n  x' = (e', xs')\n  x'' = (e'', xs'')", "have \"extTA2J P,P,t \\<turnstile> \\<langle>e,(shr s, xs)\\<rangle> -ta'\\<rightarrow> \\<langle>e',(m', xs')\\<rangle>\"\n    and \"extTA2J P,P,t \\<turnstile> \\<langle>e,(shr s, xs)\\<rangle> -ta''\\<rightarrow> \\<langle>e'',(m'', xs'')\\<rangle>\""], ["proof (prove)\nusing this:\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  red_mthr.r_syntax P t x (shr s) ta' x' m'\n  red_mthr.r_syntax P t x (shr s) ta'' x'' m''\n  red_mthr.actions_ok s t ta'\n  red_mthr.actions_ok s t ta''\n  x = (e, xs)\n  x' = (e', xs')\n  x'' = (e'', xs'')\n\ngoal (1 subgoal):\n 1. extTA2J\n     P,P,t \\<turnstile> \\<langle>e,(shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                        \\<langle>e',(m', xs')\\<rangle> &&&\n    extTA2J\n     P,P,t \\<turnstile> \\<langle>e,(shr s, xs)\\<rangle> -ta''\\<rightarrow>\n                        \\<langle>e'',(m'', xs'')\\<rangle>", "by simp_all"], ["proof (state)\nthis:\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e,(shr s, xs)\\<rangle> -ta'\\<rightarrow>\n                      \\<langle>e',(m', xs')\\<rangle>\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e,(shr s, xs)\\<rangle> -ta''\\<rightarrow>\n                      \\<langle>e'',(m'', xs'')\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>s t x ta' x' m' ta'' x'' m''.\n       \\<lbrakk>s \\<in> UNIV;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta' x' m';\n        red_mthr.r_syntax P t x (shr s) ta'' x'' m'';\n        red_mthr.actions_ok s t ta'; red_mthr.actions_ok s t ta''\\<rbrakk>\n       \\<Longrightarrow> ta' = ta'' \\<and> x' = x'' \\<and> m' = m''\n 2. invariant3p (mredT P) UNIV", "from red_deterministic[OF det this aok]"], ["proof (chain)\npicking this:\n  ta' = ta'' \\<and> e' = e'' \\<and> (m', xs') = (m'', xs'')", "show \"ta' = ta'' \\<and> x' = x'' \\<and> m' = m''\""], ["proof (prove)\nusing this:\n  ta' = ta'' \\<and> e' = e'' \\<and> (m', xs') = (m'', xs'')\n\ngoal (1 subgoal):\n 1. ta' = ta'' \\<and> x' = x'' \\<and> m' = m''", "by simp"], ["proof (state)\nthis:\n  ta' = ta'' \\<and> x' = x'' \\<and> m' = m''\n\ngoal (1 subgoal):\n 1. invariant3p (mredT P) UNIV", "qed simp"], ["", "end"], ["", "end"]]}