{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Framework/FWBisimDeadlock.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma actions_ok1_ex_actions_ok2:\n  assumes \"r1.actions_ok s1 t ta1\"\n  and \"ta1 \\<sim>m ta2\"\n  obtains s2 where \"r2.actions_ok s2 t ta2\"", "lemma actions_ok2_ex_actions_ok1:\n  assumes \"r2.actions_ok s2 t ta2\"\n  and \"ta1 \\<sim>m ta2\"\n  obtains s1 where \"r1.actions_ok s1 t ta1\"", "lemma ex_actions_ok1_conv_ex_actions_ok2:\n  \"ta1 \\<sim>m ta2 \\<Longrightarrow> (\\<exists>s1. r1.actions_ok s1 t ta1) \\<longleftrightarrow> (\\<exists>s2. r2.actions_ok s2 t ta2)\"", "lemma no_\\<tau>Move1_\\<tau>s_to_no_\\<tau>Move2:\n  fixes no_\\<tau>moves1 no_\\<tau>moves2\n  defines \"no_\\<tau>moves1 \\<equiv> \\<lambda>s1 t. wset s1 t = None \\<and> (\\<exists>x. thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and> (\\<forall>x' m'. \\<not> r1.silent_move t (x, shr s1) (x', m')))\"\n  defines \"no_\\<tau>moves2 \\<equiv> \\<lambda>s2 t. wset s2 t = None \\<and> (\\<exists>x. thr s2 t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and> (\\<forall>x' m'. \\<not> r2.silent_move t (x, shr s2) (x', m')))\"\n  assumes mbisim: \"s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\"\n  \n  shows \"\\<exists>ts2'. r2.mthr.silent_moves (ls2, (ts2, m2), ws2, is2) (ls2, (ts2', m2), ws2, is2) \\<and> \n                (\\<forall>t. no_\\<tau>moves1 s1 t \\<longrightarrow> no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2) t) \\<and> s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\"", "lemma no_\\<tau>Move2_\\<tau>s_to_no_\\<tau>Move1:\n  fixes no_\\<tau>moves1 no_\\<tau>moves2\n  defines \"no_\\<tau>moves1 \\<equiv> \\<lambda>s1 t. wset s1 t = None \\<and> (\\<exists>x. thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and> (\\<forall>x' m'. \\<not> r1.silent_move t (x, shr s1) (x', m')))\"\n  defines \"no_\\<tau>moves2 \\<equiv> \\<lambda>s2 t. wset s2 t = None \\<and> (\\<exists>x. thr s2 t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and> (\\<forall>x' m'. \\<not> r2.silent_move t (x, shr s2) (x', m')))\"\n  assumes \"(ls1, (ts1, m1), ws1, is1) \\<approx>m s2\"\n  \n  shows \"\\<exists>ts1'. r1.mthr.silent_moves (ls1, (ts1, m1), ws1, is1) (ls1, (ts1', m1), ws1, is1) \\<and>\n                (\\<forall>t. no_\\<tau>moves2 s2 t \\<longrightarrow> no_\\<tau>moves1 (ls1, (ts1', m1), ws1, is1) t) \\<and> (ls1, (ts1', m1), ws1, is1) \\<approx>m s2\"", "lemma deadlock_mbisim_not_final_thread_pres:\n  assumes dead: \"t \\<in> r1.deadlocked s1 \\<or> r1.deadlock s1\"\n  and nfin: \"r1.not_final_thread s1 t\"\n  and fin: \"r1.final_thread s1 t \\<Longrightarrow> r2.final_thread s2 t\"\n  and mbisim: \"s1 \\<approx>m s2\"\n  shows \"r2.not_final_thread s2 t\"", "lemma deadlocked1_imp_\\<tau>s_deadlocked2:\n  assumes mbisim: \"s1 \\<approx>m s2\"\n  and dead: \"t \\<in> r1.deadlocked s1\"\n  shows \"\\<exists>s2'. r2.mthr.silent_moves s2 s2' \\<and> t \\<in> r2.deadlocked s2' \\<and> s1 \\<approx>m s2'\"", "lemma deadlocked2_imp_\\<tau>s_deadlocked1:\n  \"\\<lbrakk> s1 \\<approx>m s2; t \\<in> r2.deadlocked s2 \\<rbrakk>\n  \\<Longrightarrow> \\<exists>s1'. r1.mthr.silent_moves s1 s1' \\<and> t \\<in> r1.deadlocked s1' \\<and> s1' \\<approx>m s2\"", "lemma deadlock1_imp_\\<tau>s_deadlock2:\n  assumes mbisim: \"s1 \\<approx>m s2\"\n  and dead: \"r1.deadlock s1\"\n  shows \"\\<exists>s2'. r2.mthr.silent_moves s2 s2' \\<and> r2.deadlock s2' \\<and> s1 \\<approx>m s2'\"", "lemma deadlock2_imp_\\<tau>s_deadlock1:\n  \"\\<lbrakk> s1 \\<approx>m s2; r2.deadlock s2 \\<rbrakk>\n  \\<Longrightarrow> \\<exists>s1'. r1.mthr.silent_moves s1 s1' \\<and> r1.deadlock s1' \\<and> s1' \\<approx>m s2\"", "lemma deadlocked'1_imp_\\<tau>s_deadlocked'2:\n  \"\\<lbrakk> s1 \\<approx>m s2; r1.deadlocked' s1 \\<rbrakk>\n  \\<Longrightarrow> \\<exists>s2'. r2.mthr.silent_moves s2 s2' \\<and> r2.deadlocked' s2' \\<and> s1 \\<approx>m s2'\"", "lemma deadlocked'2_imp_\\<tau>s_deadlocked'1:\n  \"\\<lbrakk> s1 \\<approx>m s2; r2.deadlocked' s2 \\<rbrakk> \\<Longrightarrow> \\<exists>s1'. r1.mthr.silent_moves s1 s1' \\<and> r1.deadlocked' s1' \\<and> s1' \\<approx>m s2\"", "lemma mbisim_final_thread_preserve1:\n  assumes mbisim: \"s1 \\<approx>m s2\" and fin: \"r1.final_thread s1 t\"\n  shows \"r2.final_thread s2 t\"", "lemma mbisim_final_thread_preserve2:\n  \"\\<lbrakk> s1 \\<approx>m s2; r2.final_thread s2 t \\<rbrakk> \\<Longrightarrow> r1.final_thread s1 t\"", "lemma mbisim_final_thread_inv:\n  \"s1 \\<approx>m s2 \\<Longrightarrow> r1.final_thread s1 t \\<longleftrightarrow> r2.final_thread s2 t\"", "lemma mbisim_not_final_thread_inv:\n  assumes bisim: \"mbisim s1 s2\"\n  shows \"r1.not_final_thread s1 = r2.not_final_thread s2\"", "lemma mbisim_deadlocked_preserve1:\n  assumes mbisim: \"s1 \\<approx>m s2\" and dead: \"t \\<in> r1.deadlocked s1\"\n  shows \"t \\<in> r2.deadlocked s2\"", "lemma mbisim_deadlocked_preserve2:\n  \"\\<lbrakk> s1 \\<approx>m s2; t \\<in> r2.deadlocked s2 \\<rbrakk> \\<Longrightarrow> t \\<in> r1.deadlocked s1\"", "lemma mbisim_deadlocked_inv:\n  \"s1 \\<approx>m s2 \\<Longrightarrow> r1.deadlocked s1 = r2.deadlocked s2\"", "lemma mbisim_deadlocked'_inv:\n  \"s1 \\<approx>m s2 \\<Longrightarrow> r1.deadlocked' s1 \\<longleftrightarrow> r2.deadlocked' s2\"", "lemma mbisim_deadlock_inv:\n  \"s1 \\<approx>m s2 \\<Longrightarrow> r1.deadlock s1 = r2.deadlock s2\"", "lemma bisim_can_sync_preserve1:\n  assumes bisim: \"t \\<turnstile> (x1, m1) \\<approx> (x2, m2)\" and cs: \"t \\<turnstile> \\<langle>x1, m1\\<rangle> LT \\<wrong>1\"\n  shows \"t \\<turnstile> \\<langle>x2, m2\\<rangle> LT \\<wrong>2\"", "lemma bisim_can_sync_preserve2:\n  \"\\<lbrakk> t \\<turnstile> (x1, m1) \\<approx> (x2, m2); t \\<turnstile> \\<langle>x2, m2\\<rangle> LT \\<wrong>2 \\<rbrakk> \\<Longrightarrow> t \\<turnstile> \\<langle>x1, m1\\<rangle> LT \\<wrong>1\"", "lemma bisim_can_sync_inv:\n  \"t \\<turnstile> (x1, m1) \\<approx> (x2, m2) \\<Longrightarrow> t \\<turnstile> \\<langle>x1, m1\\<rangle> LT \\<wrong>1 \\<longleftrightarrow> t \\<turnstile> \\<langle>x2, m2\\<rangle> LT \\<wrong>2\"", "lemma bisim_must_sync_preserve1:\n  assumes bisim: \"t \\<turnstile> (x1, m1) \\<approx> (x2, m2)\" and ms: \"t \\<turnstile> \\<langle>x1, m1\\<rangle> \\<wrong>1\"\n  shows \"t \\<turnstile> \\<langle>x2, m2\\<rangle> \\<wrong>2\"", "lemma bisim_must_sync_preserve2:\n  \"\\<lbrakk> t \\<turnstile> (x1, m1) \\<approx> (x2, m2); t \\<turnstile> \\<langle>x2, m2\\<rangle> \\<wrong>2 \\<rbrakk> \\<Longrightarrow> t \\<turnstile> \\<langle>x1, m1\\<rangle> \\<wrong>1\"", "lemma bisim_must_sync_inv:\n  \"t \\<turnstile> (x1, m1) \\<approx> (x2, m2) \\<Longrightarrow> t \\<turnstile> \\<langle>x1, m1\\<rangle> \\<wrong>1 \\<longleftrightarrow> t \\<turnstile> \\<langle>x2, m2\\<rangle> \\<wrong>2\""], "translations": [["", "lemma actions_ok1_ex_actions_ok2:\n  assumes \"r1.actions_ok s1 t ta1\"\n  and \"ta1 \\<sim>m ta2\"\n  obtains s2 where \"r2.actions_ok s2 t ta2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s2.\n        r2.actions_ok s2 t ta2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>s2.\n        r2.actions_ok s2 t ta2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?s2 = \"(locks s1, (\\<lambda>t. map_option (\\<lambda>(x1, ln). (SOME x2. if final1 x1 then final2 x2 else \\<not> final2 x2, ln)) (thr s1 t), undefined), wset s1, interrupts s1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>s2.\n        r2.actions_ok s2 t ta2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>ta1 \\<sim>m ta2\\<close>"], ["proof (chain)\npicking this:\n  ta1 \\<sim>m ta2", "have \"\\<lbrace>ta1\\<rbrace>\\<^bsub>c\\<^esub> = \\<lbrace>ta2\\<rbrace>\\<^bsub>c\\<^esub>\""], ["proof (prove)\nusing this:\n  ta1 \\<sim>m ta2\n\ngoal (1 subgoal):\n 1. \\<lbrace>ta1\\<rbrace>\\<^bsub>c\\<^esub> =\n    \\<lbrace>ta2\\<rbrace>\\<^bsub>c\\<^esub>", "by(simp add: ta_bisim_def)"], ["proof (state)\nthis:\n  \\<lbrace>ta1\\<rbrace>\\<^bsub>c\\<^esub> =\n  \\<lbrace>ta2\\<rbrace>\\<^bsub>c\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>s2.\n        r2.actions_ok s2 t ta2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with \\<open>r1.actions_ok s1 t ta1\\<close>"], ["proof (chain)\npicking this:\n  r1.actions_ok s1 t ta1\n  \\<lbrace>ta1\\<rbrace>\\<^bsub>c\\<^esub> =\n  \\<lbrace>ta2\\<rbrace>\\<^bsub>c\\<^esub>", "have cao1: \"r1.cond_action_oks s1 t \\<lbrace>ta2\\<rbrace>\\<^bsub>c\\<^esub>\""], ["proof (prove)\nusing this:\n  r1.actions_ok s1 t ta1\n  \\<lbrace>ta1\\<rbrace>\\<^bsub>c\\<^esub> =\n  \\<lbrace>ta2\\<rbrace>\\<^bsub>c\\<^esub>\n\ngoal (1 subgoal):\n 1. r1.cond_action_oks s1 t \\<lbrace>ta2\\<rbrace>\\<^bsub>c\\<^esub>", "by auto"], ["proof (state)\nthis:\n  r1.cond_action_oks s1 t \\<lbrace>ta2\\<rbrace>\\<^bsub>c\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>s2.\n        r2.actions_ok s2 t ta2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"r2.cond_action_oks ?s2 t \\<lbrace>ta2\\<rbrace>\\<^bsub>c\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r2.cond_action_oks\n     (locks s1,\n      (\\<lambda>t.\n          map_option\n           (\\<lambda>(x1, ln).\n               (SOME x2. if final1 x1 then final2 x2 else \\<not> final2 x2,\n                ln))\n           (thr s1 t),\n       undefined),\n      wset s1, interrupts s1)\n     t \\<lbrace>ta2\\<rbrace>\\<^bsub>c\\<^esub>", "unfolding r2.cond_action_oks_conv_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (set \\<lbrace>ta2\\<rbrace>\\<^bsub>c\\<^esub>)\n     (r2.cond_action_ok\n       (locks s1,\n        (\\<lambda>t.\n            map_option\n             (\\<lambda>(x1, y).\n                 (SOME x2.\n                     if final1 x1 then final2 x2 else \\<not> final2 x2,\n                  y))\n             (thr s1 t),\n         undefined),\n        wset s1, interrupts s1)\n       t)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>c\\<^esub> \\<Longrightarrow>\n       r2.cond_action_ok\n        (locks s1,\n         (\\<lambda>t.\n             map_option\n              (\\<lambda>(x1, y).\n                  (SOME x2.\n                      if final1 x1 then final2 x2 else \\<not> final2 x2,\n                   y))\n              (thr s1 t),\n          undefined),\n         wset s1, interrupts s1)\n        t x", "fix ct"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>c\\<^esub> \\<Longrightarrow>\n       r2.cond_action_ok\n        (locks s1,\n         (\\<lambda>t.\n             map_option\n              (\\<lambda>(x1, y).\n                  (SOME x2.\n                      if final1 x1 then final2 x2 else \\<not> final2 x2,\n                   y))\n              (thr s1 t),\n          undefined),\n         wset s1, interrupts s1)\n        t x", "assume \"ct \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>c\\<^esub>\""], ["proof (state)\nthis:\n  ct \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>c\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>c\\<^esub> \\<Longrightarrow>\n       r2.cond_action_ok\n        (locks s1,\n         (\\<lambda>t.\n             map_option\n              (\\<lambda>(x1, y).\n                  (SOME x2.\n                      if final1 x1 then final2 x2 else \\<not> final2 x2,\n                   y))\n              (thr s1 t),\n          undefined),\n         wset s1, interrupts s1)\n        t x", "with cao1"], ["proof (chain)\npicking this:\n  r1.cond_action_oks s1 t \\<lbrace>ta2\\<rbrace>\\<^bsub>c\\<^esub>\n  ct \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>c\\<^esub>", "have \"r1.cond_action_ok s1 t ct\""], ["proof (prove)\nusing this:\n  r1.cond_action_oks s1 t \\<lbrace>ta2\\<rbrace>\\<^bsub>c\\<^esub>\n  ct \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>c\\<^esub>\n\ngoal (1 subgoal):\n 1. r1.cond_action_ok s1 t ct", "unfolding r1.cond_action_oks_conv_set"], ["proof (prove)\nusing this:\n  Ball (set \\<lbrace>ta2\\<rbrace>\\<^bsub>c\\<^esub>) (r1.cond_action_ok s1 t)\n  ct \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>c\\<^esub>\n\ngoal (1 subgoal):\n 1. r1.cond_action_ok s1 t ct", "by auto"], ["proof (state)\nthis:\n  r1.cond_action_ok s1 t ct\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>c\\<^esub> \\<Longrightarrow>\n       r2.cond_action_ok\n        (locks s1,\n         (\\<lambda>t.\n             map_option\n              (\\<lambda>(x1, y).\n                  (SOME x2.\n                      if final1 x1 then final2 x2 else \\<not> final2 x2,\n                   y))\n              (thr s1 t),\n          undefined),\n         wset s1, interrupts s1)\n        t x", "thus \"r2.cond_action_ok ?s2 t ct\""], ["proof (prove)\nusing this:\n  r1.cond_action_ok s1 t ct\n\ngoal (1 subgoal):\n 1. r2.cond_action_ok\n     (locks s1,\n      (\\<lambda>t.\n          map_option\n           (\\<lambda>(x1, ln).\n               (SOME x2. if final1 x1 then final2 x2 else \\<not> final2 x2,\n                ln))\n           (thr s1 t),\n       undefined),\n      wset s1, interrupts s1)\n     t ct", "using ex_final1_conv_ex_final2"], ["proof (prove)\nusing this:\n  r1.cond_action_ok s1 t ct\n  (\\<exists>x1. final1 x1) = (\\<exists>x2. final2 x2)\n\ngoal (1 subgoal):\n 1. r2.cond_action_ok\n     (locks s1,\n      (\\<lambda>t.\n          map_option\n           (\\<lambda>(x1, ln).\n               (SOME x2. if final1 x1 then final2 x2 else \\<not> final2 x2,\n                ln))\n           (thr s1 t),\n       undefined),\n      wset s1, interrupts s1)\n     t ct", "by(cases ct)(fastforce intro: someI_ex[where P=final2])+"], ["proof (state)\nthis:\n  r2.cond_action_ok\n   (locks s1,\n    (\\<lambda>t.\n        map_option\n         (\\<lambda>(x1, ln).\n             (SOME x2. if final1 x1 then final2 x2 else \\<not> final2 x2,\n              ln))\n         (thr s1 t),\n     undefined),\n    wset s1, interrupts s1)\n   t ct\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r2.cond_action_oks\n   (locks s1,\n    (\\<lambda>t.\n        map_option\n         (\\<lambda>(x1, ln).\n             (SOME x2. if final1 x1 then final2 x2 else \\<not> final2 x2,\n              ln))\n         (thr s1 t),\n     undefined),\n    wset s1, interrupts s1)\n   t \\<lbrace>ta2\\<rbrace>\\<^bsub>c\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>s2.\n        r2.actions_ok s2 t ta2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"r2.actions_ok ?s2 t ta2\""], ["proof (prove)\nusing this:\n  r2.cond_action_oks\n   (locks s1,\n    (\\<lambda>t.\n        map_option\n         (\\<lambda>(x1, ln).\n             (SOME x2. if final1 x1 then final2 x2 else \\<not> final2 x2,\n              ln))\n         (thr s1 t),\n     undefined),\n    wset s1, interrupts s1)\n   t \\<lbrace>ta2\\<rbrace>\\<^bsub>c\\<^esub>\n\ngoal (1 subgoal):\n 1. r2.actions_ok\n     (locks s1,\n      (\\<lambda>t.\n          map_option\n           (\\<lambda>(x1, ln).\n               (SOME x2. if final1 x1 then final2 x2 else \\<not> final2 x2,\n                ln))\n           (thr s1 t),\n       undefined),\n      wset s1, interrupts s1)\n     t ta2", "using assms"], ["proof (prove)\nusing this:\n  r2.cond_action_oks\n   (locks s1,\n    (\\<lambda>t.\n        map_option\n         (\\<lambda>(x1, ln).\n             (SOME x2. if final1 x1 then final2 x2 else \\<not> final2 x2,\n              ln))\n         (thr s1 t),\n     undefined),\n    wset s1, interrupts s1)\n   t \\<lbrace>ta2\\<rbrace>\\<^bsub>c\\<^esub>\n  r1.actions_ok s1 t ta1\n  ta1 \\<sim>m ta2\n\ngoal (1 subgoal):\n 1. r2.actions_ok\n     (locks s1,\n      (\\<lambda>t.\n          map_option\n           (\\<lambda>(x1, ln).\n               (SOME x2. if final1 x1 then final2 x2 else \\<not> final2 x2,\n                ln))\n           (thr s1 t),\n       undefined),\n      wset s1, interrupts s1)\n     t ta2", "by(auto simp add: ta_bisim_def split del: if_split elim: rev_iffD1[OF _ thread_oks_bisim_inv])"], ["proof (state)\nthis:\n  r2.actions_ok\n   (locks s1,\n    (\\<lambda>t.\n        map_option\n         (\\<lambda>(x1, ln).\n             (SOME x2. if final1 x1 then final2 x2 else \\<not> final2 x2,\n              ln))\n         (thr s1 t),\n     undefined),\n    wset s1, interrupts s1)\n   t ta2\n\ngoal (1 subgoal):\n 1. (\\<And>s2.\n        r2.actions_ok s2 t ta2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus thesis"], ["proof (prove)\nusing this:\n  r2.actions_ok\n   (locks s1,\n    (\\<lambda>t.\n        map_option\n         (\\<lambda>(x1, ln).\n             (SOME x2. if final1 x1 then final2 x2 else \\<not> final2 x2,\n              ln))\n         (thr s1 t),\n     undefined),\n    wset s1, interrupts s1)\n   t ta2\n\ngoal (1 subgoal):\n 1. thesis", "by(rule that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma actions_ok2_ex_actions_ok1:\n  assumes \"r2.actions_ok s2 t ta2\"\n  and \"ta1 \\<sim>m ta2\"\n  obtains s1 where \"r1.actions_ok s1 t ta1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s1.\n        r1.actions_ok s1 t ta1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using FWdelay_bisimulation_obs.actions_ok1_ex_actions_ok2[OF FWdelay_bisimulation_obs_flip] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>r2.actions_ok ?s1.0 ?t ?ta1.0;\n   ta_bisim (\\<lambda>t. flip (bisim t)) ?ta1.0 ?ta2.0;\n   \\<And>s2. r1.actions_ok s2 ?t ?ta2.0 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  r2.actions_ok s2 t ta2\n  ta1 \\<sim>m ta2\n\ngoal (1 subgoal):\n 1. (\\<And>s1.\n        r1.actions_ok s1 t ta1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding flip_simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>r2.actions_ok ?s1.0 ?t ?ta1.0; ?ta2.0 \\<sim>m ?ta1.0;\n   \\<And>s2. r1.actions_ok s2 ?t ?ta2.0 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  r2.actions_ok s2 t ta2\n  ta1 \\<sim>m ta2\n\ngoal (1 subgoal):\n 1. (\\<And>s1.\n        r1.actions_ok s1 t ta1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["", "lemma ex_actions_ok1_conv_ex_actions_ok2:\n  \"ta1 \\<sim>m ta2 \\<Longrightarrow> (\\<exists>s1. r1.actions_ok s1 t ta1) \\<longleftrightarrow> (\\<exists>s2. r2.actions_ok s2 t ta2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta1 \\<sim>m ta2 \\<Longrightarrow>\n    (\\<exists>s1. r1.actions_ok s1 t ta1) =\n    (\\<exists>s2. r2.actions_ok s2 t ta2)", "by(metis actions_ok1_ex_actions_ok2 actions_ok2_ex_actions_ok1)"], ["", "end"], ["", "context FWdelay_bisimulation_diverge begin"], ["", "lemma no_\\<tau>Move1_\\<tau>s_to_no_\\<tau>Move2:\n  fixes no_\\<tau>moves1 no_\\<tau>moves2\n  defines \"no_\\<tau>moves1 \\<equiv> \\<lambda>s1 t. wset s1 t = None \\<and> (\\<exists>x. thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and> (\\<forall>x' m'. \\<not> r1.silent_move t (x, shr s1) (x', m')))\"\n  defines \"no_\\<tau>moves2 \\<equiv> \\<lambda>s2 t. wset s2 t = None \\<and> (\\<exists>x. thr s2 t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and> (\\<forall>x' m'. \\<not> r2.silent_move t (x, shr s2) (x', m')))\"\n  assumes mbisim: \"s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\"\n  \n  shows \"\\<exists>ts2'. r2.mthr.silent_moves (ls2, (ts2, m2), ws2, is2) (ls2, (ts2', m2), ws2, is2) \\<and> \n                (\\<forall>t. no_\\<tau>moves1 s1 t \\<longrightarrow> no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2) t) \\<and> s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ts2'.\n       \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n        (ls2, (ts2', m2), ws2, is2) \\<and>\n       (\\<forall>t.\n           no_\\<tau>moves1 s1 t \\<longrightarrow>\n           no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2) t) \\<and>\n       s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ts2'.\n       \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n        (ls2, (ts2', m2), ws2, is2) \\<and>\n       (\\<forall>t.\n           no_\\<tau>moves1 s1 t \\<longrightarrow>\n           no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2) t) \\<and>\n       s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "from mbisim"], ["proof (chain)\npicking this:\n  s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)", "have \"finite (dom (thr s1))\""], ["proof (prove)\nusing this:\n  s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. finite (dom (thr s1))", "by(simp add: mbisim_def)"], ["proof (state)\nthis:\n  finite (dom (thr s1))\n\ngoal (1 subgoal):\n 1. \\<exists>ts2'.\n       \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n        (ls2, (ts2', m2), ws2, is2) \\<and>\n       (\\<forall>t.\n           no_\\<tau>moves1 s1 t \\<longrightarrow>\n           no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2) t) \\<and>\n       s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "hence \"finite {t. no_\\<tau>moves1 s1 t}\""], ["proof (prove)\nusing this:\n  finite (dom (thr s1))\n\ngoal (1 subgoal):\n 1. finite {t. no_\\<tau>moves1 s1 t}", "unfolding no_\\<tau>moves1_def"], ["proof (prove)\nusing this:\n  finite (dom (thr s1))\n\ngoal (1 subgoal):\n 1. finite\n     {t. wset s1 t = None \\<and>\n         (\\<exists>x.\n             thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n             (\\<forall>x' m'.\n                 \\<not> r1.silent_move t (x, shr s1) (x', m')))}", "by-(rule finite_subset, auto)"], ["proof (state)\nthis:\n  finite {t. no_\\<tau>moves1 s1 t}\n\ngoal (1 subgoal):\n 1. \\<exists>ts2'.\n       \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n        (ls2, (ts2', m2), ws2, is2) \\<and>\n       (\\<forall>t.\n           no_\\<tau>moves1 s1 t \\<longrightarrow>\n           no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2) t) \\<and>\n       s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite {t. no_\\<tau>moves1 s1 t}\n\ngoal (1 subgoal):\n 1. \\<exists>ts2'.\n       \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n        (ls2, (ts2', m2), ws2, is2) \\<and>\n       (\\<forall>t.\n           no_\\<tau>moves1 s1 t \\<longrightarrow>\n           no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2) t) \\<and>\n       s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "using \\<open>s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<close>"], ["proof (prove)\nusing this:\n  finite {t. no_\\<tau>moves1 s1 t}\n  s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. \\<exists>ts2'.\n       \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n        (ls2, (ts2', m2), ws2, is2) \\<and>\n       (\\<forall>t.\n           no_\\<tau>moves1 s1 t \\<longrightarrow>\n           no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2) t) \\<and>\n       s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "proof(induct A\\<equiv>\"{t. no_\\<tau>moves1 s1 t}\" arbitrary: s1 ts2 rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s1 ts2.\n       \\<lbrakk>{} = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n 2. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "case empty"], ["proof (state)\nthis:\n  {} = {a. no_\\<tau>moves1 s1 a}\n  s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\n\ngoal (2 subgoals):\n 1. \\<And>s1 ts2.\n       \\<lbrakk>{} = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n 2. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "from \\<open>{} = {t. no_\\<tau>moves1 s1 t}\\<close>[symmetric]"], ["proof (chain)\npicking this:\n  {t. no_\\<tau>moves1 s1 t} = {}", "have \"no_\\<tau>moves1 s1 = (\\<lambda>t. False)\""], ["proof (prove)\nusing this:\n  {t. no_\\<tau>moves1 s1 t} = {}\n\ngoal (1 subgoal):\n 1. no_\\<tau>moves1 s1 = (\\<lambda>t. False)", "by(auto intro: ext)"], ["proof (state)\nthis:\n  no_\\<tau>moves1 s1 = (\\<lambda>t. False)\n\ngoal (2 subgoals):\n 1. \\<And>s1 ts2.\n       \\<lbrakk>{} = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n 2. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "thus ?case"], ["proof (prove)\nusing this:\n  no_\\<tau>moves1 s1 = (\\<lambda>t. False)\n\ngoal (1 subgoal):\n 1. \\<exists>ts2'.\n       \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n        (ls2, (ts2', m2), ws2, is2) \\<and>\n       (\\<forall>t.\n           no_\\<tau>moves1 s1 t \\<longrightarrow>\n           no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2) t) \\<and>\n       s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "using \\<open>s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<close>"], ["proof (prove)\nusing this:\n  no_\\<tau>moves1 s1 = (\\<lambda>t. False)\n  s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. \\<exists>ts2'.\n       \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n        (ls2, (ts2', m2), ws2, is2) \\<and>\n       (\\<forall>t.\n           no_\\<tau>moves1 s1 t \\<longrightarrow>\n           no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2) t) \\<and>\n       s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "by auto"], ["proof (state)\nthis:\n  \\<exists>ts2'.\n     \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n      (ls2, (ts2', m2), ws2, is2) \\<and>\n     (\\<forall>t.\n         no_\\<tau>moves1 s1 t \\<longrightarrow>\n         no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2) t) \\<and>\n     s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "case (insert t A)"], ["proof (state)\nthis:\n  finite A\n  t \\<notin> A\n  \\<lbrakk>A = Collect (no_\\<tau>moves1 ?s1.14);\n   ?s1.14 \\<approx>m (ls2, (?ts2.14, m2), ws2, is2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ts2'.\n                       \\<tau>mRed2 (ls2, (?ts2.14, m2), ws2, is2)\n                        (ls2, (ts2', m2), ws2, is2) \\<and>\n                       (\\<forall>t.\n                           no_\\<tau>moves1 ?s1.14 t \\<longrightarrow>\n                           no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                            t) \\<and>\n                       ?s1.14 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n  insert t A = Collect (no_\\<tau>moves1 s1)\n  s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "note mbisim = \\<open>s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<close>"], ["proof (state)\nthis:\n  s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "from \\<open>insert t A = {t. no_\\<tau>moves1 s1 t}\\<close>"], ["proof (chain)\npicking this:\n  insert t A = {t. no_\\<tau>moves1 s1 t}", "have \"no_\\<tau>moves1 s1 t\""], ["proof (prove)\nusing this:\n  insert t A = {t. no_\\<tau>moves1 s1 t}\n\ngoal (1 subgoal):\n 1. no_\\<tau>moves1 s1 t", "by auto"], ["proof (state)\nthis:\n  no_\\<tau>moves1 s1 t\n\ngoal (1 subgoal):\n 1. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "then"], ["proof (chain)\npicking this:\n  no_\\<tau>moves1 s1 t", "obtain x1 where ts1t: \"thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>\"\n      and ws1t: \"wset s1 t = None\"\n      and \\<tau>1: \"\\<And>x1m1'. \\<not> r1.silent_move t (x1, shr s1) x1m1'\""], ["proof (prove)\nusing this:\n  no_\\<tau>moves1 s1 t\n\ngoal (1 subgoal):\n 1. (\\<And>x1.\n        \\<lbrakk>thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>;\n         wset s1 t = None;\n         \\<And>x1m1'. \\<not> r1.silent_move t (x1, shr s1) x1m1'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: no_\\<tau>moves1_def)"], ["proof (state)\nthis:\n  thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>\n  wset s1 t = None\n  \\<not> r1.silent_move t (x1, shr s1) ?x1m1'14\n\ngoal (1 subgoal):\n 1. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "from ts1t mbisim"], ["proof (chain)\npicking this:\n  thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>\n  s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)", "obtain x2 where ts2t: \"ts2 t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>\"\n      and \"t \\<turnstile> (x1, shr s1) \\<approx> (x2, m2)\""], ["proof (prove)\nusing this:\n  thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>\n  s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. (\\<And>x2.\n        \\<lbrakk>ts2 t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>;\n         t \\<turnstile> (x1, shr s1) \\<approx> (x2, m2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: mbisim_thrD1)"], ["proof (state)\nthis:\n  ts2 t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>\n  t \\<turnstile> (x1, shr s1) \\<approx> (x2, m2)\n\ngoal (1 subgoal):\n 1. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "from mbisim ws1t"], ["proof (chain)\npicking this:\n  s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\n  wset s1 t = None", "have \"ws2 t = None\""], ["proof (prove)\nusing this:\n  s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\n  wset s1 t = None\n\ngoal (1 subgoal):\n 1. ws2 t = None", "by(simp add: mbisim_def)"], ["proof (state)\nthis:\n  ws2 t = None\n\ngoal (1 subgoal):\n 1. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "let ?s1 = \"(locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "let ?s2 = \"(ls2, (ts2(t := None), m2), ws2, is2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "from \\<open>insert t A = {t. no_\\<tau>moves1 s1 t}\\<close> \\<open>t \\<notin> A\\<close>"], ["proof (chain)\npicking this:\n  insert t A = {t. no_\\<tau>moves1 s1 t}\n  t \\<notin> A", "have A: \"A = {t. no_\\<tau>moves1 ?s1 t}\""], ["proof (prove)\nusing this:\n  insert t A = {t. no_\\<tau>moves1 s1 t}\n  t \\<notin> A\n\ngoal (1 subgoal):\n 1. A =\n    {ta.\n     no_\\<tau>moves1\n      (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1) ta}", "by(auto simp add: no_\\<tau>moves1_def)"], ["proof (state)\nthis:\n  A =\n  {ta.\n   no_\\<tau>moves1\n    (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1) ta}\n\ngoal (1 subgoal):\n 1. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "have \"?s1 \\<approx>m ?s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (locks s1, ((thr s1)(t := None), shr s1), wset s1,\n     interrupts s1) \\<approx>m (ls2, (ts2(t := None), m2), ws2, is2)", "proof(rule mbisimI)"], ["proof (state)\ngoal (7 subgoals):\n 1. finite\n     (dom (thr (locks s1, ((thr s1)(t := None), shr s1), wset s1,\n                interrupts s1)))\n 2. locks\n     (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1) =\n    locks (ls2, (ts2(t := None), m2), ws2, is2)\n 3. wset (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1) =\n    wset (ls2, (ts2(t := None), m2), ws2, is2)\n 4. interrupts\n     (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1) =\n    interrupts (ls2, (ts2(t := None), m2), ws2, is2)\n 5. wset_thread_ok\n     (wset\n       (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1))\n     (thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1))\n 6. \\<And>ta.\n       thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1)\n        ta =\n       None \\<Longrightarrow>\n       thr (ls2, (ts2(t := None), m2), ws2, is2) ta = None\n 7. \\<And>ta x1 ln.\n       thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1)\n        ta =\n       \\<lfloor>(x1, ln)\\<rfloor> \\<Longrightarrow>\n       \\<exists>x2.\n          thr (ls2, (ts2(t := None), m2), ws2, is2) ta =\n          \\<lfloor>(x2, ln)\\<rfloor> \\<and>\n          ta \\<turnstile> (x1,\n                           shr (locks s1, ((thr s1)(t := None), shr s1),\n                                wset s1, interrupts s1))\n          \\<approx> (x2, shr (ls2, (ts2(t := None), m2), ws2, is2)) \\<and>\n          (wset (ls2, (ts2(t := None), m2), ws2, is2) ta = None \\<or> x1\n           \\<approx>w x2)", "from mbisim"], ["proof (chain)\npicking this:\n  s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)", "show \"finite (dom (thr ?s1))\" \"locks ?s1 = locks ?s2\" \"wset ?s1 = wset ?s2\" \"interrupts ?s1 = interrupts ?s2\""], ["proof (prove)\nusing this:\n  s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. (finite\n      (dom (thr (locks s1, ((thr s1)(t := None), shr s1), wset s1,\n                 interrupts s1))) &&&\n     locks\n      (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1) =\n     locks (ls2, (ts2(t := None), m2), ws2, is2)) &&&\n    wset (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1) =\n    wset (ls2, (ts2(t := None), m2), ws2, is2) &&&\n    interrupts\n     (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1) =\n    interrupts (ls2, (ts2(t := None), m2), ws2, is2)", "by(simp_all add: mbisim_def)"], ["proof (state)\nthis:\n  finite\n   (dom (thr (locks s1, ((thr s1)(t := None), shr s1), wset s1,\n              interrupts s1)))\n  locks (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1) =\n  locks (ls2, (ts2(t := None), m2), ws2, is2)\n  wset (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1) =\n  wset (ls2, (ts2(t := None), m2), ws2, is2)\n  interrupts\n   (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1) =\n  interrupts (ls2, (ts2(t := None), m2), ws2, is2)\n\ngoal (3 subgoals):\n 1. wset_thread_ok\n     (wset\n       (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1))\n     (thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1))\n 2. \\<And>ta.\n       thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1)\n        ta =\n       None \\<Longrightarrow>\n       thr (ls2, (ts2(t := None), m2), ws2, is2) ta = None\n 3. \\<And>ta x1 ln.\n       thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1)\n        ta =\n       \\<lfloor>(x1, ln)\\<rfloor> \\<Longrightarrow>\n       \\<exists>x2.\n          thr (ls2, (ts2(t := None), m2), ws2, is2) ta =\n          \\<lfloor>(x2, ln)\\<rfloor> \\<and>\n          ta \\<turnstile> (x1,\n                           shr (locks s1, ((thr s1)(t := None), shr s1),\n                                wset s1, interrupts s1))\n          \\<approx> (x2, shr (ls2, (ts2(t := None), m2), ws2, is2)) \\<and>\n          (wset (ls2, (ts2(t := None), m2), ws2, is2) ta = None \\<or> x1\n           \\<approx>w x2)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. wset_thread_ok\n     (wset\n       (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1))\n     (thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1))\n 2. \\<And>ta.\n       thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1)\n        ta =\n       None \\<Longrightarrow>\n       thr (ls2, (ts2(t := None), m2), ws2, is2) ta = None\n 3. \\<And>ta x1 ln.\n       thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1)\n        ta =\n       \\<lfloor>(x1, ln)\\<rfloor> \\<Longrightarrow>\n       \\<exists>x2.\n          thr (ls2, (ts2(t := None), m2), ws2, is2) ta =\n          \\<lfloor>(x2, ln)\\<rfloor> \\<and>\n          ta \\<turnstile> (x1,\n                           shr (locks s1, ((thr s1)(t := None), shr s1),\n                                wset s1, interrupts s1))\n          \\<approx> (x2, shr (ls2, (ts2(t := None), m2), ws2, is2)) \\<and>\n          (wset (ls2, (ts2(t := None), m2), ws2, is2) ta = None \\<or> x1\n           \\<approx>w x2)", "from mbisim_wset_thread_ok1[OF mbisim] ws1t"], ["proof (chain)\npicking this:\n  wset_thread_ok (wset s1) (thr s1)\n  wset s1 t = None", "show \"wset_thread_ok (wset ?s1) (thr ?s1)\""], ["proof (prove)\nusing this:\n  wset_thread_ok (wset s1) (thr s1)\n  wset s1 t = None\n\ngoal (1 subgoal):\n 1. wset_thread_ok\n     (wset\n       (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1))\n     (thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1))", "by(auto intro!: wset_thread_okI dest: wset_thread_okD split: if_split_asm)"], ["proof (state)\nthis:\n  wset_thread_ok\n   (wset (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1))\n   (thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1))\n\ngoal (2 subgoals):\n 1. \\<And>ta.\n       thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1)\n        ta =\n       None \\<Longrightarrow>\n       thr (ls2, (ts2(t := None), m2), ws2, is2) ta = None\n 2. \\<And>ta x1 ln.\n       thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1)\n        ta =\n       \\<lfloor>(x1, ln)\\<rfloor> \\<Longrightarrow>\n       \\<exists>x2.\n          thr (ls2, (ts2(t := None), m2), ws2, is2) ta =\n          \\<lfloor>(x2, ln)\\<rfloor> \\<and>\n          ta \\<turnstile> (x1,\n                           shr (locks s1, ((thr s1)(t := None), shr s1),\n                                wset s1, interrupts s1))\n          \\<approx> (x2, shr (ls2, (ts2(t := None), m2), ws2, is2)) \\<and>\n          (wset (ls2, (ts2(t := None), m2), ws2, is2) ta = None \\<or> x1\n           \\<approx>w x2)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ta.\n       thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1)\n        ta =\n       None \\<Longrightarrow>\n       thr (ls2, (ts2(t := None), m2), ws2, is2) ta = None\n 2. \\<And>ta x1 ln.\n       thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1)\n        ta =\n       \\<lfloor>(x1, ln)\\<rfloor> \\<Longrightarrow>\n       \\<exists>x2.\n          thr (ls2, (ts2(t := None), m2), ws2, is2) ta =\n          \\<lfloor>(x2, ln)\\<rfloor> \\<and>\n          ta \\<turnstile> (x1,\n                           shr (locks s1, ((thr s1)(t := None), shr s1),\n                                wset s1, interrupts s1))\n          \\<approx> (x2, shr (ls2, (ts2(t := None), m2), ws2, is2)) \\<and>\n          (wset (ls2, (ts2(t := None), m2), ws2, is2) ta = None \\<or> x1\n           \\<approx>w x2)", "fix t'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ta.\n       thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1)\n        ta =\n       None \\<Longrightarrow>\n       thr (ls2, (ts2(t := None), m2), ws2, is2) ta = None\n 2. \\<And>ta x1 ln.\n       thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1)\n        ta =\n       \\<lfloor>(x1, ln)\\<rfloor> \\<Longrightarrow>\n       \\<exists>x2.\n          thr (ls2, (ts2(t := None), m2), ws2, is2) ta =\n          \\<lfloor>(x2, ln)\\<rfloor> \\<and>\n          ta \\<turnstile> (x1,\n                           shr (locks s1, ((thr s1)(t := None), shr s1),\n                                wset s1, interrupts s1))\n          \\<approx> (x2, shr (ls2, (ts2(t := None), m2), ws2, is2)) \\<and>\n          (wset (ls2, (ts2(t := None), m2), ws2, is2) ta = None \\<or> x1\n           \\<approx>w x2)", "assume \"thr ?s1 t' = None\""], ["proof (state)\nthis:\n  thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1) t' =\n  None\n\ngoal (2 subgoals):\n 1. \\<And>ta.\n       thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1)\n        ta =\n       None \\<Longrightarrow>\n       thr (ls2, (ts2(t := None), m2), ws2, is2) ta = None\n 2. \\<And>ta x1 ln.\n       thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1)\n        ta =\n       \\<lfloor>(x1, ln)\\<rfloor> \\<Longrightarrow>\n       \\<exists>x2.\n          thr (ls2, (ts2(t := None), m2), ws2, is2) ta =\n          \\<lfloor>(x2, ln)\\<rfloor> \\<and>\n          ta \\<turnstile> (x1,\n                           shr (locks s1, ((thr s1)(t := None), shr s1),\n                                wset s1, interrupts s1))\n          \\<approx> (x2, shr (ls2, (ts2(t := None), m2), ws2, is2)) \\<and>\n          (wset (ls2, (ts2(t := None), m2), ws2, is2) ta = None \\<or> x1\n           \\<approx>w x2)", "with mbisim_thrNone_eq[OF mbisim, of t']"], ["proof (chain)\npicking this:\n  (thr s1 t' = None) = (thr (ls2, (ts2, m2), ws2, is2) t' = None)\n  thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1) t' =\n  None", "show \"thr ?s2 t' = None\""], ["proof (prove)\nusing this:\n  (thr s1 t' = None) = (thr (ls2, (ts2, m2), ws2, is2) t' = None)\n  thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1) t' =\n  None\n\ngoal (1 subgoal):\n 1. thr (ls2, (ts2(t := None), m2), ws2, is2) t' = None", "by auto"], ["proof (state)\nthis:\n  thr (ls2, (ts2(t := None), m2), ws2, is2) t' = None\n\ngoal (1 subgoal):\n 1. \\<And>ta x1 ln.\n       thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1)\n        ta =\n       \\<lfloor>(x1, ln)\\<rfloor> \\<Longrightarrow>\n       \\<exists>x2.\n          thr (ls2, (ts2(t := None), m2), ws2, is2) ta =\n          \\<lfloor>(x2, ln)\\<rfloor> \\<and>\n          ta \\<turnstile> (x1,\n                           shr (locks s1, ((thr s1)(t := None), shr s1),\n                                wset s1, interrupts s1))\n          \\<approx> (x2, shr (ls2, (ts2(t := None), m2), ws2, is2)) \\<and>\n          (wset (ls2, (ts2(t := None), m2), ws2, is2) ta = None \\<or> x1\n           \\<approx>w x2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ta x1 ln.\n       thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1)\n        ta =\n       \\<lfloor>(x1, ln)\\<rfloor> \\<Longrightarrow>\n       \\<exists>x2.\n          thr (ls2, (ts2(t := None), m2), ws2, is2) ta =\n          \\<lfloor>(x2, ln)\\<rfloor> \\<and>\n          ta \\<turnstile> (x1,\n                           shr (locks s1, ((thr s1)(t := None), shr s1),\n                                wset s1, interrupts s1))\n          \\<approx> (x2, shr (ls2, (ts2(t := None), m2), ws2, is2)) \\<and>\n          (wset (ls2, (ts2(t := None), m2), ws2, is2) ta = None \\<or> x1\n           \\<approx>w x2)", "fix t' x1 ln"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ta x1 ln.\n       thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1)\n        ta =\n       \\<lfloor>(x1, ln)\\<rfloor> \\<Longrightarrow>\n       \\<exists>x2.\n          thr (ls2, (ts2(t := None), m2), ws2, is2) ta =\n          \\<lfloor>(x2, ln)\\<rfloor> \\<and>\n          ta \\<turnstile> (x1,\n                           shr (locks s1, ((thr s1)(t := None), shr s1),\n                                wset s1, interrupts s1))\n          \\<approx> (x2, shr (ls2, (ts2(t := None), m2), ws2, is2)) \\<and>\n          (wset (ls2, (ts2(t := None), m2), ws2, is2) ta = None \\<or> x1\n           \\<approx>w x2)", "assume \"thr ?s1 t' = \\<lfloor>(x1, ln)\\<rfloor>\""], ["proof (state)\nthis:\n  thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1) t' =\n  \\<lfloor>(x1, ln)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>ta x1 ln.\n       thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1)\n        ta =\n       \\<lfloor>(x1, ln)\\<rfloor> \\<Longrightarrow>\n       \\<exists>x2.\n          thr (ls2, (ts2(t := None), m2), ws2, is2) ta =\n          \\<lfloor>(x2, ln)\\<rfloor> \\<and>\n          ta \\<turnstile> (x1,\n                           shr (locks s1, ((thr s1)(t := None), shr s1),\n                                wset s1, interrupts s1))\n          \\<approx> (x2, shr (ls2, (ts2(t := None), m2), ws2, is2)) \\<and>\n          (wset (ls2, (ts2(t := None), m2), ws2, is2) ta = None \\<or> x1\n           \\<approx>w x2)", "hence \"thr s1 t' = \\<lfloor>(x1, ln)\\<rfloor>\" \"t' \\<noteq> t\""], ["proof (prove)\nusing this:\n  thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1) t' =\n  \\<lfloor>(x1, ln)\\<rfloor>\n\ngoal (1 subgoal):\n 1. thr s1 t' = \\<lfloor>(x1, ln)\\<rfloor> &&& t' \\<noteq> t", "by(auto split: if_split_asm)"], ["proof (state)\nthis:\n  thr s1 t' = \\<lfloor>(x1, ln)\\<rfloor>\n  t' \\<noteq> t\n\ngoal (1 subgoal):\n 1. \\<And>ta x1 ln.\n       thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1)\n        ta =\n       \\<lfloor>(x1, ln)\\<rfloor> \\<Longrightarrow>\n       \\<exists>x2.\n          thr (ls2, (ts2(t := None), m2), ws2, is2) ta =\n          \\<lfloor>(x2, ln)\\<rfloor> \\<and>\n          ta \\<turnstile> (x1,\n                           shr (locks s1, ((thr s1)(t := None), shr s1),\n                                wset s1, interrupts s1))\n          \\<approx> (x2, shr (ls2, (ts2(t := None), m2), ws2, is2)) \\<and>\n          (wset (ls2, (ts2(t := None), m2), ws2, is2) ta = None \\<or> x1\n           \\<approx>w x2)", "with mbisim_thrD1[OF mbisim \\<open>thr s1 t' = \\<lfloor>(x1, ln)\\<rfloor>\\<close>] mbisim"], ["proof (chain)\npicking this:\n  \\<exists>x'.\n     thr (ls2, (ts2, m2), ws2, is2) t' = \\<lfloor>(x', ln)\\<rfloor> \\<and>\n     t' \\<turnstile> (x1, shr s1)\n     \\<approx> (x', shr (ls2, (ts2, m2), ws2, is2)) \\<and>\n     (wset s1 t' = None \\<or> x1 \\<approx>w x')\n  s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\n  thr s1 t' = \\<lfloor>(x1, ln)\\<rfloor>\n  t' \\<noteq> t", "show \"\\<exists>x2. thr ?s2 t' = \\<lfloor>(x2, ln)\\<rfloor> \\<and> t' \\<turnstile> (x1, shr ?s1) \\<approx> (x2, shr ?s2) \\<and> (wset ?s2 t' = None \\<or> x1 \\<approx>w x2)\""], ["proof (prove)\nusing this:\n  \\<exists>x'.\n     thr (ls2, (ts2, m2), ws2, is2) t' = \\<lfloor>(x', ln)\\<rfloor> \\<and>\n     t' \\<turnstile> (x1, shr s1)\n     \\<approx> (x', shr (ls2, (ts2, m2), ws2, is2)) \\<and>\n     (wset s1 t' = None \\<or> x1 \\<approx>w x')\n  s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\n  thr s1 t' = \\<lfloor>(x1, ln)\\<rfloor>\n  t' \\<noteq> t\n\ngoal (1 subgoal):\n 1. \\<exists>x2.\n       thr (ls2, (ts2(t := None), m2), ws2, is2) t' =\n       \\<lfloor>(x2, ln)\\<rfloor> \\<and>\n       t' \\<turnstile> (x1,\n                        shr (locks s1, ((thr s1)(t := None), shr s1),\n                             wset s1, interrupts s1))\n       \\<approx> (x2, shr (ls2, (ts2(t := None), m2), ws2, is2)) \\<and>\n       (wset (ls2, (ts2(t := None), m2), ws2, is2) t' = None \\<or> x1\n        \\<approx>w x2)", "by(auto simp add: mbisim_def)"], ["proof (state)\nthis:\n  \\<exists>x2.\n     thr (ls2, (ts2(t := None), m2), ws2, is2) t' =\n     \\<lfloor>(x2, ln)\\<rfloor> \\<and>\n     t' \\<turnstile> (x1,\n                      shr (locks s1, ((thr s1)(t := None), shr s1), wset s1,\n                           interrupts s1))\n     \\<approx> (x2, shr (ls2, (ts2(t := None), m2), ws2, is2)) \\<and>\n     (wset (ls2, (ts2(t := None), m2), ws2, is2) t' = None \\<or> x1\n      \\<approx>w x2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (locks s1, ((thr s1)(t := None), shr s1), wset s1,\n   interrupts s1) \\<approx>m (ls2, (ts2(t := None), m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "with A"], ["proof (chain)\npicking this:\n  A =\n  {ta.\n   no_\\<tau>moves1\n    (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1) ta}\n  (locks s1, ((thr s1)(t := None), shr s1), wset s1,\n   interrupts s1) \\<approx>m (ls2, (ts2(t := None), m2), ws2, is2)", "have \"\\<exists>ts2'. r2.mthr.silent_moves ?s2 (ls2, (ts2', m2), ws2, is2) \\<and> (\\<forall>t. no_\\<tau>moves1 ?s1 t \\<longrightarrow> no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2) t) \\<and> ?s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\""], ["proof (prove)\nusing this:\n  A =\n  {ta.\n   no_\\<tau>moves1\n    (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1) ta}\n  (locks s1, ((thr s1)(t := None), shr s1), wset s1,\n   interrupts s1) \\<approx>m (ls2, (ts2(t := None), m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. \\<exists>ts2'.\n       \\<tau>mRed2 (ls2, (ts2(t := None), m2), ws2, is2)\n        (ls2, (ts2', m2), ws2, is2) \\<and>\n       (\\<forall>ta.\n           no_\\<tau>moves1\n            (locks s1, ((thr s1)(t := None), shr s1), wset s1,\n             interrupts s1)\n            ta \\<longrightarrow>\n           no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2) ta) \\<and>\n       (locks s1, ((thr s1)(t := None), shr s1), wset s1,\n        interrupts s1) \\<approx>m (ls2, (ts2', m2), ws2, is2)", "by(rule insert)"], ["proof (state)\nthis:\n  \\<exists>ts2'.\n     \\<tau>mRed2 (ls2, (ts2(t := None), m2), ws2, is2)\n      (ls2, (ts2', m2), ws2, is2) \\<and>\n     (\\<forall>ta.\n         no_\\<tau>moves1\n          (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1)\n          ta \\<longrightarrow>\n         no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2) ta) \\<and>\n     (locks s1, ((thr s1)(t := None), shr s1), wset s1,\n      interrupts s1) \\<approx>m (ls2, (ts2', m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "then"], ["proof (chain)\npicking this:\n  \\<exists>ts2'.\n     \\<tau>mRed2 (ls2, (ts2(t := None), m2), ws2, is2)\n      (ls2, (ts2', m2), ws2, is2) \\<and>\n     (\\<forall>ta.\n         no_\\<tau>moves1\n          (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1)\n          ta \\<longrightarrow>\n         no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2) ta) \\<and>\n     (locks s1, ((thr s1)(t := None), shr s1), wset s1,\n      interrupts s1) \\<approx>m (ls2, (ts2', m2), ws2, is2)", "obtain ts2' where \"r2.mthr.silent_moves ?s2 (ls2, (ts2', m2), ws2, is2)\"\n      and no_\\<tau>: \"\\<And>t. no_\\<tau>moves1 ?s1 t \\<Longrightarrow> no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2) t\"\n      and \"?s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\""], ["proof (prove)\nusing this:\n  \\<exists>ts2'.\n     \\<tau>mRed2 (ls2, (ts2(t := None), m2), ws2, is2)\n      (ls2, (ts2', m2), ws2, is2) \\<and>\n     (\\<forall>ta.\n         no_\\<tau>moves1\n          (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1)\n          ta \\<longrightarrow>\n         no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2) ta) \\<and>\n     (locks s1, ((thr s1)(t := None), shr s1), wset s1,\n      interrupts s1) \\<approx>m (ls2, (ts2', m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. (\\<And>ts2'.\n        \\<lbrakk>\\<tau>mRed2 (ls2, (ts2(t := None), m2), ws2, is2)\n                  (ls2, (ts2', m2), ws2, is2);\n         \\<And>ta.\n            no_\\<tau>moves1\n             (locks s1, ((thr s1)(t := None), shr s1), wset s1,\n              interrupts s1)\n             ta \\<Longrightarrow>\n            no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2) ta;\n         (locks s1, ((thr s1)(t := None), shr s1), wset s1,\n          interrupts s1) \\<approx>m (ls2, (ts2', m2), ws2, is2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<tau>mRed2 (ls2, (ts2(t := None), m2), ws2, is2)\n   (ls2, (ts2', m2), ws2, is2)\n  no_\\<tau>moves1\n   (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1)\n   ?t14 \\<Longrightarrow>\n  no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2) ?t14\n  (locks s1, ((thr s1)(t := None), shr s1), wset s1,\n   interrupts s1) \\<approx>m (ls2, (ts2', m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "let ?s2' = \"(ls2, (ts2'(t \\<mapsto> (x2, no_wait_locks)), m2), ws2, is2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "from ts2t"], ["proof (chain)\npicking this:\n  ts2 t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>", "have \"ts2(t \\<mapsto> (x2, no_wait_locks)) = ts2\""], ["proof (prove)\nusing this:\n  ts2 t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. ts2(t \\<mapsto> (x2, no_wait_locks)) = ts2", "by(auto intro: ext)"], ["proof (state)\nthis:\n  ts2(t \\<mapsto> (x2, no_wait_locks)) = ts2\n\ngoal (1 subgoal):\n 1. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "with r2.\\<tau>mRedT_add_thread_inv[OF \\<open>r2.mthr.silent_moves ?s2 (ls2, (ts2', m2), ws2, is2)\\<close>, of t \"(x2, no_wait_locks)\"]"], ["proof (chain)\npicking this:\n  thr (ls2, (ts2(t := None), m2), ws2, is2) t = None \\<Longrightarrow>\n  \\<tau>mRed2\n   (locks (ls2, (ts2(t := None), m2), ws2, is2),\n    (thr (ls2, (ts2(t := None), m2), ws2, is2)(t \\<mapsto>\n     (x2, no_wait_locks)), shr (ls2, (ts2(t := None), m2), ws2, is2)),\n    wset (ls2, (ts2(t := None), m2), ws2, is2),\n    interrupts (ls2, (ts2(t := None), m2), ws2, is2))\n   (locks (ls2, (ts2', m2), ws2, is2),\n    (thr (ls2, (ts2', m2), ws2, is2)(t \\<mapsto> (x2, no_wait_locks)),\n     shr (ls2, (ts2', m2), ws2, is2)),\n    wset (ls2, (ts2', m2), ws2, is2),\n    interrupts (ls2, (ts2', m2), ws2, is2))\n  ts2(t \\<mapsto> (x2, no_wait_locks)) = ts2", "have \"r2.mthr.silent_moves (ls2, (ts2, m2), ws2, is2) ?s2'\""], ["proof (prove)\nusing this:\n  thr (ls2, (ts2(t := None), m2), ws2, is2) t = None \\<Longrightarrow>\n  \\<tau>mRed2\n   (locks (ls2, (ts2(t := None), m2), ws2, is2),\n    (thr (ls2, (ts2(t := None), m2), ws2, is2)(t \\<mapsto>\n     (x2, no_wait_locks)), shr (ls2, (ts2(t := None), m2), ws2, is2)),\n    wset (ls2, (ts2(t := None), m2), ws2, is2),\n    interrupts (ls2, (ts2(t := None), m2), ws2, is2))\n   (locks (ls2, (ts2', m2), ws2, is2),\n    (thr (ls2, (ts2', m2), ws2, is2)(t \\<mapsto> (x2, no_wait_locks)),\n     shr (ls2, (ts2', m2), ws2, is2)),\n    wset (ls2, (ts2', m2), ws2, is2),\n    interrupts (ls2, (ts2', m2), ws2, is2))\n  ts2(t \\<mapsto> (x2, no_wait_locks)) = ts2\n\ngoal (1 subgoal):\n 1. \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n     (ls2, (ts2'(t \\<mapsto> (x2, no_wait_locks)), m2), ws2, is2)", "by simp"], ["proof (state)\nthis:\n  \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n   (ls2, (ts2'(t \\<mapsto> (x2, no_wait_locks)), m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "from no_\\<tau>move1_\\<tau>s_to_no_\\<tau>move2[OF \\<open>t \\<turnstile> (x1, shr s1) \\<approx> (x2, m2)\\<close> \\<tau>1]"], ["proof (chain)\npicking this:\n  \\<exists>s2'.\n     r2.silent_moves t (x2, m2) s2' \\<and>\n     (\\<forall>s2''. \\<not> r2.silent_move t s2' s2'') \\<and>\n     t \\<turnstile> (x1, shr s1) \\<approx> s2'", "obtain x2' m2' where \"r2.silent_moves t (x2, m2) (x2', m2')\" \n      and \"\\<And>x2'' m2''. \\<not> r2.silent_move t (x2', m2') (x2'', m2'')\" \n      and \"t \\<turnstile> (x1, shr s1) \\<approx> (x2', m2')\""], ["proof (prove)\nusing this:\n  \\<exists>s2'.\n     r2.silent_moves t (x2, m2) s2' \\<and>\n     (\\<forall>s2''. \\<not> r2.silent_move t s2' s2'') \\<and>\n     t \\<turnstile> (x1, shr s1) \\<approx> s2'\n\ngoal (1 subgoal):\n 1. (\\<And>x2' m2'.\n        \\<lbrakk>r2.silent_moves t (x2, m2) (x2', m2');\n         \\<And>x2'' m2''. \\<not> r2.silent_move t (x2', m2') (x2'', m2'');\n         t \\<turnstile> (x1, shr s1) \\<approx> (x2', m2')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  r2.silent_moves t (x2, m2) (x2', m2')\n  \\<not> r2.silent_move t (x2', m2') (?x2''14, ?m2''14)\n  t \\<turnstile> (x1, shr s1) \\<approx> (x2', m2')\n\ngoal (1 subgoal):\n 1. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "let ?s2'' = \"(ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "from red2_rtrancl_\\<tau>_heapD[OF \\<open>r2.silent_moves t (x2, m2) (x2', m2')\\<close> \\<open>t \\<turnstile> (x1, shr s1) \\<approx> (x2, m2)\\<close>]"], ["proof (chain)\npicking this:\n  snd (x2', m2') = snd (x2, m2)", "have \"m2' = m2\""], ["proof (prove)\nusing this:\n  snd (x2', m2') = snd (x2, m2)\n\ngoal (1 subgoal):\n 1. m2' = m2", "by simp"], ["proof (state)\nthis:\n  m2' = m2\n\ngoal (1 subgoal):\n 1. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "with \\<open>r2.silent_moves t (x2, m2) (x2', m2')\\<close>"], ["proof (chain)\npicking this:\n  r2.silent_moves t (x2, m2) (x2', m2')\n  m2' = m2", "have \"r2.silent_moves t (x2, shr ?s2') (x2', m2)\""], ["proof (prove)\nusing this:\n  r2.silent_moves t (x2, m2) (x2', m2')\n  m2' = m2\n\ngoal (1 subgoal):\n 1. r2.silent_moves t\n     (x2, shr (ls2, (ts2'(t \\<mapsto> (x2, no_wait_locks)), m2), ws2, is2))\n     (x2', m2)", "by simp"], ["proof (state)\nthis:\n  r2.silent_moves t\n   (x2, shr (ls2, (ts2'(t \\<mapsto> (x2, no_wait_locks)), m2), ws2, is2))\n   (x2', m2)\n\ngoal (1 subgoal):\n 1. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "hence \"r2.mthr.silent_moves ?s2' (redT_upd_\\<epsilon> ?s2' t x2' m2)\""], ["proof (prove)\nusing this:\n  r2.silent_moves t\n   (x2, shr (ls2, (ts2'(t \\<mapsto> (x2, no_wait_locks)), m2), ws2, is2))\n   (x2', m2)\n\ngoal (1 subgoal):\n 1. \\<tau>mRed2 (ls2, (ts2'(t \\<mapsto> (x2, no_wait_locks)), m2), ws2, is2)\n     (redT_upd_\\<epsilon>\n       (ls2, (ts2'(t \\<mapsto> (x2, no_wait_locks)), m2), ws2, is2) t x2'\n       m2)", "by(rule red2_rtrancl_\\<tau>_into_RedT_\\<tau>)(auto simp add: \\<open>ws2 t = None\\<close> intro: \\<open>t \\<turnstile> (x1, shr s1) \\<approx> (x2, m2)\\<close>)"], ["proof (state)\nthis:\n  \\<tau>mRed2 (ls2, (ts2'(t \\<mapsto> (x2, no_wait_locks)), m2), ws2, is2)\n   (redT_upd_\\<epsilon>\n     (ls2, (ts2'(t \\<mapsto> (x2, no_wait_locks)), m2), ws2, is2) t x2' m2)\n\ngoal (1 subgoal):\n 1. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "also"], ["proof (state)\nthis:\n  \\<tau>mRed2 (ls2, (ts2'(t \\<mapsto> (x2, no_wait_locks)), m2), ws2, is2)\n   (redT_upd_\\<epsilon>\n     (ls2, (ts2'(t \\<mapsto> (x2, no_wait_locks)), m2), ws2, is2) t x2' m2)\n\ngoal (1 subgoal):\n 1. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "have \"redT_upd_\\<epsilon> ?s2' t x2' m2 = ?s2''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redT_upd_\\<epsilon>\n     (ls2, (ts2'(t \\<mapsto> (x2, no_wait_locks)), m2), ws2, is2) t x2' m2 =\n    (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)", "using \\<open>m2' = m2\\<close>"], ["proof (prove)\nusing this:\n  m2' = m2\n\ngoal (1 subgoal):\n 1. redT_upd_\\<epsilon>\n     (ls2, (ts2'(t \\<mapsto> (x2, no_wait_locks)), m2), ws2, is2) t x2' m2 =\n    (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)", "by(auto simp add: fun_eq_iff redT_updLns_def finfun_Diag_const2 o_def)"], ["proof (state)\nthis:\n  redT_upd_\\<epsilon>\n   (ls2, (ts2'(t \\<mapsto> (x2, no_wait_locks)), m2), ws2, is2) t x2' m2 =\n  (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n\ngoal (1 subgoal):\n 1. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "finally (back_subst)"], ["proof (chain)\npicking this:\n  \\<tau>mRed2 (ls2, (ts2'(t \\<mapsto> (x2, no_wait_locks)), m2), ws2, is2)\n   (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)", "have \"r2.mthr.silent_moves (ls2, (ts2, m2), ws2, is2) ?s2''\""], ["proof (prove)\nusing this:\n  \\<tau>mRed2 (ls2, (ts2'(t \\<mapsto> (x2, no_wait_locks)), m2), ws2, is2)\n   (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n\ngoal (1 subgoal):\n 1. \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n     (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)", "using \\<open>r2.mthr.silent_moves (ls2, (ts2, m2), ws2, is2) ?s2'\\<close>"], ["proof (prove)\nusing this:\n  \\<tau>mRed2 (ls2, (ts2'(t \\<mapsto> (x2, no_wait_locks)), m2), ws2, is2)\n   (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n  \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n   (ls2, (ts2'(t \\<mapsto> (x2, no_wait_locks)), m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n     (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)", "by-(rule rtranclp_trans)"], ["proof (state)\nthis:\n  \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n   (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n\ngoal (1 subgoal):\n 1. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "moreover"], ["proof (state)\nthis:\n  \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n   (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n\ngoal (1 subgoal):\n 1. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "{"], ["proof (state)\nthis:\n  \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n   (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n\ngoal (1 subgoal):\n 1. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "fix t'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "assume no_\\<tau>1: \"no_\\<tau>moves1 s1 t'\""], ["proof (state)\nthis:\n  no_\\<tau>moves1 s1 t'\n\ngoal (1 subgoal):\n 1. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "have \"no_\\<tau>moves2 ?s2'' t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_\\<tau>moves2\n     (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2) t'", "proof(cases \"t' = t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t' = t \\<Longrightarrow>\n    no_\\<tau>moves2\n     (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2) t'\n 2. t' \\<noteq> t \\<Longrightarrow>\n    no_\\<tau>moves2\n     (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2) t'", "case True"], ["proof (state)\nthis:\n  t' = t\n\ngoal (2 subgoals):\n 1. t' = t \\<Longrightarrow>\n    no_\\<tau>moves2\n     (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2) t'\n 2. t' \\<noteq> t \\<Longrightarrow>\n    no_\\<tau>moves2\n     (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2) t'", "thus ?thesis"], ["proof (prove)\nusing this:\n  t' = t\n\ngoal (1 subgoal):\n 1. no_\\<tau>moves2\n     (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2) t'", "using \\<open>ws2 t = None\\<close> \\<open>\\<And>x2'' m2''. \\<not> r2.silent_move t (x2', m2') (x2'', m2'')\\<close>"], ["proof (prove)\nusing this:\n  t' = t\n  ws2 t = None\n  \\<not> r2.silent_move t (x2', m2') (?x2'', ?m2'')\n\ngoal (1 subgoal):\n 1. no_\\<tau>moves2\n     (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2) t'", "by(simp add: no_\\<tau>moves2_def)"], ["proof (state)\nthis:\n  no_\\<tau>moves2\n   (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2) t'\n\ngoal (1 subgoal):\n 1. t' \\<noteq> t \\<Longrightarrow>\n    no_\\<tau>moves2\n     (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2) t'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t' \\<noteq> t \\<Longrightarrow>\n    no_\\<tau>moves2\n     (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2) t'", "case False"], ["proof (state)\nthis:\n  t' \\<noteq> t\n\ngoal (1 subgoal):\n 1. t' \\<noteq> t \\<Longrightarrow>\n    no_\\<tau>moves2\n     (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2) t'", "with no_\\<tau>1"], ["proof (chain)\npicking this:\n  no_\\<tau>moves1 s1 t'\n  t' \\<noteq> t", "have \"no_\\<tau>moves1 ?s1 t'\""], ["proof (prove)\nusing this:\n  no_\\<tau>moves1 s1 t'\n  t' \\<noteq> t\n\ngoal (1 subgoal):\n 1. no_\\<tau>moves1\n     (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1) t'", "by(simp add: no_\\<tau>moves1_def)"], ["proof (state)\nthis:\n  no_\\<tau>moves1\n   (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1) t'\n\ngoal (1 subgoal):\n 1. t' \\<noteq> t \\<Longrightarrow>\n    no_\\<tau>moves2\n     (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2) t'", "hence \"no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2) t'\""], ["proof (prove)\nusing this:\n  no_\\<tau>moves1\n   (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1) t'\n\ngoal (1 subgoal):\n 1. no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2) t'", "by(rule \\<open>no_\\<tau>moves1 ?s1 t' \\<Longrightarrow> no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2) t'\\<close>)"], ["proof (state)\nthis:\n  no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2) t'\n\ngoal (1 subgoal):\n 1. t' \\<noteq> t \\<Longrightarrow>\n    no_\\<tau>moves2\n     (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2) t'", "with False \\<open>m2' = m2\\<close>"], ["proof (chain)\npicking this:\n  t' \\<noteq> t\n  m2' = m2\n  no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2) t'", "show ?thesis"], ["proof (prove)\nusing this:\n  t' \\<noteq> t\n  m2' = m2\n  no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2) t'\n\ngoal (1 subgoal):\n 1. no_\\<tau>moves2\n     (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2) t'", "by(simp add: no_\\<tau>moves2_def)"], ["proof (state)\nthis:\n  no_\\<tau>moves2\n   (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2) t'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  no_\\<tau>moves2\n   (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2) t'\n\ngoal (1 subgoal):\n 1. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "}"], ["proof (state)\nthis:\n  no_\\<tau>moves1 s1 ?t'16 \\<Longrightarrow>\n  no_\\<tau>moves2\n   (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2) ?t'16\n\ngoal (1 subgoal):\n 1. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "moreover"], ["proof (state)\nthis:\n  no_\\<tau>moves1 s1 ?t'16 \\<Longrightarrow>\n  no_\\<tau>moves2\n   (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2) ?t'16\n\ngoal (1 subgoal):\n 1. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "have \"s1 \\<approx>m ?s2''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s1 \\<approx>m (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2,\n                   is2)", "proof(rule mbisimI)"], ["proof (state)\ngoal (7 subgoals):\n 1. finite (dom (thr s1))\n 2. locks s1 =\n    locks (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n 3. wset s1 =\n    wset (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n 4. interrupts s1 =\n    interrupts\n     (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n 5. wset_thread_ok (wset s1) (thr s1)\n 6. \\<And>ta.\n       thr s1 ta = None \\<Longrightarrow>\n       thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n        ta =\n       None\n 7. \\<And>ta x1 ln.\n       thr s1 ta = \\<lfloor>(x1, ln)\\<rfloor> \\<Longrightarrow>\n       \\<exists>x2.\n          thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n           ta =\n          \\<lfloor>(x2, ln)\\<rfloor> \\<and>\n          ta \\<turnstile> (x1, shr s1)\n          \\<approx> (x2,\n                     shr (ls2,\n                          (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'),\n                          ws2, is2)) \\<and>\n          (wset\n            (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n            ta =\n           None \\<or>\n           x1 \\<approx>w x2)", "from mbisim"], ["proof (chain)\npicking this:\n  s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)", "show \"finite (dom (thr s1))\" \"locks s1 = locks ?s2''\" \"wset s1 = wset ?s2''\" \"interrupts s1 = interrupts ?s2''\""], ["proof (prove)\nusing this:\n  s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. (finite (dom (thr s1)) &&&\n     locks s1 =\n     locks\n      (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)) &&&\n    wset s1 =\n    wset (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2) &&&\n    interrupts s1 =\n    interrupts\n     (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)", "by(simp_all add: mbisim_def)"], ["proof (state)\nthis:\n  finite (dom (thr s1))\n  locks s1 =\n  locks (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n  wset s1 =\n  wset (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n  interrupts s1 =\n  interrupts (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n\ngoal (3 subgoals):\n 1. wset_thread_ok (wset s1) (thr s1)\n 2. \\<And>ta.\n       thr s1 ta = None \\<Longrightarrow>\n       thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n        ta =\n       None\n 3. \\<And>ta x1 ln.\n       thr s1 ta = \\<lfloor>(x1, ln)\\<rfloor> \\<Longrightarrow>\n       \\<exists>x2.\n          thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n           ta =\n          \\<lfloor>(x2, ln)\\<rfloor> \\<and>\n          ta \\<turnstile> (x1, shr s1)\n          \\<approx> (x2,\n                     shr (ls2,\n                          (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'),\n                          ws2, is2)) \\<and>\n          (wset\n            (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n            ta =\n           None \\<or>\n           x1 \\<approx>w x2)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. wset_thread_ok (wset s1) (thr s1)\n 2. \\<And>ta.\n       thr s1 ta = None \\<Longrightarrow>\n       thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n        ta =\n       None\n 3. \\<And>ta x1 ln.\n       thr s1 ta = \\<lfloor>(x1, ln)\\<rfloor> \\<Longrightarrow>\n       \\<exists>x2.\n          thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n           ta =\n          \\<lfloor>(x2, ln)\\<rfloor> \\<and>\n          ta \\<turnstile> (x1, shr s1)\n          \\<approx> (x2,\n                     shr (ls2,\n                          (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'),\n                          ws2, is2)) \\<and>\n          (wset\n            (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n            ta =\n           None \\<or>\n           x1 \\<approx>w x2)", "from mbisim"], ["proof (chain)\npicking this:\n  s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)", "show \"wset_thread_ok (wset s1) (thr s1)\""], ["proof (prove)\nusing this:\n  s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. wset_thread_ok (wset s1) (thr s1)", "by(rule mbisim_wset_thread_ok1)"], ["proof (state)\nthis:\n  wset_thread_ok (wset s1) (thr s1)\n\ngoal (2 subgoals):\n 1. \\<And>ta.\n       thr s1 ta = None \\<Longrightarrow>\n       thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n        ta =\n       None\n 2. \\<And>ta x1 ln.\n       thr s1 ta = \\<lfloor>(x1, ln)\\<rfloor> \\<Longrightarrow>\n       \\<exists>x2.\n          thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n           ta =\n          \\<lfloor>(x2, ln)\\<rfloor> \\<and>\n          ta \\<turnstile> (x1, shr s1)\n          \\<approx> (x2,\n                     shr (ls2,\n                          (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'),\n                          ws2, is2)) \\<and>\n          (wset\n            (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n            ta =\n           None \\<or>\n           x1 \\<approx>w x2)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ta.\n       thr s1 ta = None \\<Longrightarrow>\n       thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n        ta =\n       None\n 2. \\<And>ta x1 ln.\n       thr s1 ta = \\<lfloor>(x1, ln)\\<rfloor> \\<Longrightarrow>\n       \\<exists>x2.\n          thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n           ta =\n          \\<lfloor>(x2, ln)\\<rfloor> \\<and>\n          ta \\<turnstile> (x1, shr s1)\n          \\<approx> (x2,\n                     shr (ls2,\n                          (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'),\n                          ws2, is2)) \\<and>\n          (wset\n            (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n            ta =\n           None \\<or>\n           x1 \\<approx>w x2)", "fix t'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ta.\n       thr s1 ta = None \\<Longrightarrow>\n       thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n        ta =\n       None\n 2. \\<And>ta x1 ln.\n       thr s1 ta = \\<lfloor>(x1, ln)\\<rfloor> \\<Longrightarrow>\n       \\<exists>x2.\n          thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n           ta =\n          \\<lfloor>(x2, ln)\\<rfloor> \\<and>\n          ta \\<turnstile> (x1, shr s1)\n          \\<approx> (x2,\n                     shr (ls2,\n                          (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'),\n                          ws2, is2)) \\<and>\n          (wset\n            (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n            ta =\n           None \\<or>\n           x1 \\<approx>w x2)", "assume \"thr s1 t' = None\""], ["proof (state)\nthis:\n  thr s1 t' = None\n\ngoal (2 subgoals):\n 1. \\<And>ta.\n       thr s1 ta = None \\<Longrightarrow>\n       thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n        ta =\n       None\n 2. \\<And>ta x1 ln.\n       thr s1 ta = \\<lfloor>(x1, ln)\\<rfloor> \\<Longrightarrow>\n       \\<exists>x2.\n          thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n           ta =\n          \\<lfloor>(x2, ln)\\<rfloor> \\<and>\n          ta \\<turnstile> (x1, shr s1)\n          \\<approx> (x2,\n                     shr (ls2,\n                          (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'),\n                          ws2, is2)) \\<and>\n          (wset\n            (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n            ta =\n           None \\<or>\n           x1 \\<approx>w x2)", "hence \"thr ?s1 t' = None\" \"t' \\<noteq> t\""], ["proof (prove)\nusing this:\n  thr s1 t' = None\n\ngoal (1 subgoal):\n 1. thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1)\n     t' =\n    None &&&\n    t' \\<noteq> t", "using ts1t"], ["proof (prove)\nusing this:\n  thr s1 t' = None\n  thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1)\n     t' =\n    None &&&\n    t' \\<noteq> t", "by auto"], ["proof (state)\nthis:\n  thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1) t' =\n  None\n  t' \\<noteq> t\n\ngoal (2 subgoals):\n 1. \\<And>ta.\n       thr s1 ta = None \\<Longrightarrow>\n       thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n        ta =\n       None\n 2. \\<And>ta x1 ln.\n       thr s1 ta = \\<lfloor>(x1, ln)\\<rfloor> \\<Longrightarrow>\n       \\<exists>x2.\n          thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n           ta =\n          \\<lfloor>(x2, ln)\\<rfloor> \\<and>\n          ta \\<turnstile> (x1, shr s1)\n          \\<approx> (x2,\n                     shr (ls2,\n                          (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'),\n                          ws2, is2)) \\<and>\n          (wset\n            (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n            ta =\n           None \\<or>\n           x1 \\<approx>w x2)", "with mbisim_thrNone_eq[OF \\<open>?s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\\<close>, of t']"], ["proof (chain)\npicking this:\n  (thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1)\n    t' =\n   None) =\n  (thr (ls2, (ts2', m2), ws2, is2) t' = None)\n  thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1) t' =\n  None\n  t' \\<noteq> t", "show \"thr ?s2'' t' = None\""], ["proof (prove)\nusing this:\n  (thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1)\n    t' =\n   None) =\n  (thr (ls2, (ts2', m2), ws2, is2) t' = None)\n  thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1) t' =\n  None\n  t' \\<noteq> t\n\ngoal (1 subgoal):\n 1. thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2) t' =\n    None", "by simp"], ["proof (state)\nthis:\n  thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2) t' =\n  None\n\ngoal (1 subgoal):\n 1. \\<And>ta x1 ln.\n       thr s1 ta = \\<lfloor>(x1, ln)\\<rfloor> \\<Longrightarrow>\n       \\<exists>x2.\n          thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n           ta =\n          \\<lfloor>(x2, ln)\\<rfloor> \\<and>\n          ta \\<turnstile> (x1, shr s1)\n          \\<approx> (x2,\n                     shr (ls2,\n                          (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'),\n                          ws2, is2)) \\<and>\n          (wset\n            (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n            ta =\n           None \\<or>\n           x1 \\<approx>w x2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ta x1 ln.\n       thr s1 ta = \\<lfloor>(x1, ln)\\<rfloor> \\<Longrightarrow>\n       \\<exists>x2.\n          thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n           ta =\n          \\<lfloor>(x2, ln)\\<rfloor> \\<and>\n          ta \\<turnstile> (x1, shr s1)\n          \\<approx> (x2,\n                     shr (ls2,\n                          (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'),\n                          ws2, is2)) \\<and>\n          (wset\n            (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n            ta =\n           None \\<or>\n           x1 \\<approx>w x2)", "fix t' x1' ln'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ta x1 ln.\n       thr s1 ta = \\<lfloor>(x1, ln)\\<rfloor> \\<Longrightarrow>\n       \\<exists>x2.\n          thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n           ta =\n          \\<lfloor>(x2, ln)\\<rfloor> \\<and>\n          ta \\<turnstile> (x1, shr s1)\n          \\<approx> (x2,\n                     shr (ls2,\n                          (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'),\n                          ws2, is2)) \\<and>\n          (wset\n            (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n            ta =\n           None \\<or>\n           x1 \\<approx>w x2)", "assume \"thr s1 t' = \\<lfloor>(x1', ln')\\<rfloor>\""], ["proof (state)\nthis:\n  thr s1 t' = \\<lfloor>(x1', ln')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>ta x1 ln.\n       thr s1 ta = \\<lfloor>(x1, ln)\\<rfloor> \\<Longrightarrow>\n       \\<exists>x2.\n          thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n           ta =\n          \\<lfloor>(x2, ln)\\<rfloor> \\<and>\n          ta \\<turnstile> (x1, shr s1)\n          \\<approx> (x2,\n                     shr (ls2,\n                          (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'),\n                          ws2, is2)) \\<and>\n          (wset\n            (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n            ta =\n           None \\<or>\n           x1 \\<approx>w x2)", "show \"\\<exists>x2. thr ?s2'' t' = \\<lfloor>(x2, ln')\\<rfloor> \\<and> t' \\<turnstile> (x1', shr s1) \\<approx> (x2, shr ?s2'') \\<and> (wset ?s2'' t' = None \\<or> x1' \\<approx>w x2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x2.\n       thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n        t' =\n       \\<lfloor>(x2, ln')\\<rfloor> \\<and>\n       t' \\<turnstile> (x1', shr s1)\n       \\<approx> (x2,\n                  shr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'),\n                       ws2, is2)) \\<and>\n       (wset (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n         t' =\n        None \\<or>\n        x1' \\<approx>w x2)", "proof(cases \"t = t'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t = t' \\<Longrightarrow>\n    \\<exists>x2.\n       thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n        t' =\n       \\<lfloor>(x2, ln')\\<rfloor> \\<and>\n       t' \\<turnstile> (x1', shr s1)\n       \\<approx> (x2,\n                  shr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'),\n                       ws2, is2)) \\<and>\n       (wset (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n         t' =\n        None \\<or>\n        x1' \\<approx>w x2)\n 2. t \\<noteq> t' \\<Longrightarrow>\n    \\<exists>x2.\n       thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n        t' =\n       \\<lfloor>(x2, ln')\\<rfloor> \\<and>\n       t' \\<turnstile> (x1', shr s1)\n       \\<approx> (x2,\n                  shr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'),\n                       ws2, is2)) \\<and>\n       (wset (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n         t' =\n        None \\<or>\n        x1' \\<approx>w x2)", "case True"], ["proof (state)\nthis:\n  t = t'\n\ngoal (2 subgoals):\n 1. t = t' \\<Longrightarrow>\n    \\<exists>x2.\n       thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n        t' =\n       \\<lfloor>(x2, ln')\\<rfloor> \\<and>\n       t' \\<turnstile> (x1', shr s1)\n       \\<approx> (x2,\n                  shr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'),\n                       ws2, is2)) \\<and>\n       (wset (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n         t' =\n        None \\<or>\n        x1' \\<approx>w x2)\n 2. t \\<noteq> t' \\<Longrightarrow>\n    \\<exists>x2.\n       thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n        t' =\n       \\<lfloor>(x2, ln')\\<rfloor> \\<and>\n       t' \\<turnstile> (x1', shr s1)\n       \\<approx> (x2,\n                  shr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'),\n                       ws2, is2)) \\<and>\n       (wset (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n         t' =\n        None \\<or>\n        x1' \\<approx>w x2)", "with \\<open>thr s1 t' = \\<lfloor>(x1', ln')\\<rfloor>\\<close> ts1t \\<open>t \\<turnstile> (x1, shr s1) \\<approx> (x2', m2')\\<close> \\<open>m2' = m2\\<close> \\<open>ws2 t = None\\<close>"], ["proof (chain)\npicking this:\n  thr s1 t' = \\<lfloor>(x1', ln')\\<rfloor>\n  thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>\n  t \\<turnstile> (x1, shr s1) \\<approx> (x2', m2')\n  m2' = m2\n  ws2 t = None\n  t = t'", "show ?thesis"], ["proof (prove)\nusing this:\n  thr s1 t' = \\<lfloor>(x1', ln')\\<rfloor>\n  thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>\n  t \\<turnstile> (x1, shr s1) \\<approx> (x2', m2')\n  m2' = m2\n  ws2 t = None\n  t = t'\n\ngoal (1 subgoal):\n 1. \\<exists>x2.\n       thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n        t' =\n       \\<lfloor>(x2, ln')\\<rfloor> \\<and>\n       t' \\<turnstile> (x1', shr s1)\n       \\<approx> (x2,\n                  shr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'),\n                       ws2, is2)) \\<and>\n       (wset (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n         t' =\n        None \\<or>\n        x1' \\<approx>w x2)", "by auto"], ["proof (state)\nthis:\n  \\<exists>x2.\n     thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2) t' =\n     \\<lfloor>(x2, ln')\\<rfloor> \\<and>\n     t' \\<turnstile> (x1', shr s1)\n     \\<approx> (x2,\n                shr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'),\n                     ws2, is2)) \\<and>\n     (wset (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n       t' =\n      None \\<or>\n      x1' \\<approx>w x2)\n\ngoal (1 subgoal):\n 1. t \\<noteq> t' \\<Longrightarrow>\n    \\<exists>x2.\n       thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n        t' =\n       \\<lfloor>(x2, ln')\\<rfloor> \\<and>\n       t' \\<turnstile> (x1', shr s1)\n       \\<approx> (x2,\n                  shr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'),\n                       ws2, is2)) \\<and>\n       (wset (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n         t' =\n        None \\<or>\n        x1' \\<approx>w x2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<noteq> t' \\<Longrightarrow>\n    \\<exists>x2.\n       thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n        t' =\n       \\<lfloor>(x2, ln')\\<rfloor> \\<and>\n       t' \\<turnstile> (x1', shr s1)\n       \\<approx> (x2,\n                  shr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'),\n                       ws2, is2)) \\<and>\n       (wset (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n         t' =\n        None \\<or>\n        x1' \\<approx>w x2)", "case False"], ["proof (state)\nthis:\n  t \\<noteq> t'\n\ngoal (1 subgoal):\n 1. t \\<noteq> t' \\<Longrightarrow>\n    \\<exists>x2.\n       thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n        t' =\n       \\<lfloor>(x2, ln')\\<rfloor> \\<and>\n       t' \\<turnstile> (x1', shr s1)\n       \\<approx> (x2,\n                  shr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'),\n                       ws2, is2)) \\<and>\n       (wset (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n         t' =\n        None \\<or>\n        x1' \\<approx>w x2)", "with mbisim_thrD1[OF \\<open>?s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\\<close>, of t' x1' ln'] \\<open>thr s1 t' = \\<lfloor>(x1', ln')\\<rfloor>\\<close> \\<open>m2' = m2\\<close> mbisim"], ["proof (chain)\npicking this:\n  thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1) t' =\n  \\<lfloor>(x1', ln')\\<rfloor> \\<Longrightarrow>\n  \\<exists>x'.\n     thr (ls2, (ts2', m2), ws2, is2) t' = \\<lfloor>(x', ln')\\<rfloor> \\<and>\n     t' \\<turnstile> (x1',\n                      shr (locks s1, ((thr s1)(t := None), shr s1), wset s1,\n                           interrupts s1))\n     \\<approx> (x', shr (ls2, (ts2', m2), ws2, is2)) \\<and>\n     (wset (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1)\n       t' =\n      None \\<or>\n      x1' \\<approx>w x')\n  thr s1 t' = \\<lfloor>(x1', ln')\\<rfloor>\n  m2' = m2\n  s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\n  t \\<noteq> t'", "show ?thesis"], ["proof (prove)\nusing this:\n  thr (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1) t' =\n  \\<lfloor>(x1', ln')\\<rfloor> \\<Longrightarrow>\n  \\<exists>x'.\n     thr (ls2, (ts2', m2), ws2, is2) t' = \\<lfloor>(x', ln')\\<rfloor> \\<and>\n     t' \\<turnstile> (x1',\n                      shr (locks s1, ((thr s1)(t := None), shr s1), wset s1,\n                           interrupts s1))\n     \\<approx> (x', shr (ls2, (ts2', m2), ws2, is2)) \\<and>\n     (wset (locks s1, ((thr s1)(t := None), shr s1), wset s1, interrupts s1)\n       t' =\n      None \\<or>\n      x1' \\<approx>w x')\n  thr s1 t' = \\<lfloor>(x1', ln')\\<rfloor>\n  m2' = m2\n  s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\n  t \\<noteq> t'\n\ngoal (1 subgoal):\n 1. \\<exists>x2.\n       thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n        t' =\n       \\<lfloor>(x2, ln')\\<rfloor> \\<and>\n       t' \\<turnstile> (x1', shr s1)\n       \\<approx> (x2,\n                  shr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'),\n                       ws2, is2)) \\<and>\n       (wset (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n         t' =\n        None \\<or>\n        x1' \\<approx>w x2)", "by(auto simp add: mbisim_def)"], ["proof (state)\nthis:\n  \\<exists>x2.\n     thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2) t' =\n     \\<lfloor>(x2, ln')\\<rfloor> \\<and>\n     t' \\<turnstile> (x1', shr s1)\n     \\<approx> (x2,\n                shr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'),\n                     ws2, is2)) \\<and>\n     (wset (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n       t' =\n      None \\<or>\n      x1' \\<approx>w x2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x2.\n     thr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2) t' =\n     \\<lfloor>(x2, ln')\\<rfloor> \\<and>\n     t' \\<turnstile> (x1', shr s1)\n     \\<approx> (x2,\n                shr (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'),\n                     ws2, is2)) \\<and>\n     (wset (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n       t' =\n      None \\<or>\n      x1' \\<approx>w x2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s1 \\<approx>m (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2,\n                 is2)\n\ngoal (1 subgoal):\n 1. \\<And>x F s1 ts2.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s1 ts2.\n           \\<lbrakk>F = Collect (no_\\<tau>moves1 s1);\n            s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ts2'.\n                                \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                                 (ls2, (ts2', m2), ws2, is2) \\<and>\n                                (\\<forall>t.\n                                    no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                    no_\\<tau>moves2\n                                     (ls2, (ts2', m2), ws2, is2) t) \\<and>\n                                s1 \\<approx>m (ls2, (ts2', m2), ws2, is2);\n        insert x F = Collect (no_\\<tau>moves1 s1);\n        s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts2'.\n                            \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                             (ls2, (ts2', m2), ws2, is2) \\<and>\n                            (\\<forall>t.\n                                no_\\<tau>moves1 s1 t \\<longrightarrow>\n                                no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2)\n                                 t) \\<and>\n                            s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "ultimately"], ["proof (chain)\npicking this:\n  \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n   (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n  no_\\<tau>moves1 s1 ?t'16 \\<Longrightarrow>\n  no_\\<tau>moves2\n   (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2) ?t'16\n  s1 \\<approx>m (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2,\n                 is2)", "show ?case"], ["proof (prove)\nusing this:\n  \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n   (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2)\n  no_\\<tau>moves1 s1 ?t'16 \\<Longrightarrow>\n  no_\\<tau>moves2\n   (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2, is2) ?t'16\n  s1 \\<approx>m (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2'), ws2,\n                 is2)\n\ngoal (1 subgoal):\n 1. \\<exists>ts2'.\n       \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n        (ls2, (ts2', m2), ws2, is2) \\<and>\n       (\\<forall>t.\n           no_\\<tau>moves1 s1 t \\<longrightarrow>\n           no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2) t) \\<and>\n       s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "unfolding \\<open>m2' = m2\\<close>"], ["proof (prove)\nusing this:\n  \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n   (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2), ws2, is2)\n  no_\\<tau>moves1 s1 ?t'16 \\<Longrightarrow>\n  no_\\<tau>moves2\n   (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2), ws2, is2) ?t'16\n  s1 \\<approx>m (ls2, (ts2'(t \\<mapsto> (x2', no_wait_locks)), m2), ws2,\n                 is2)\n\ngoal (1 subgoal):\n 1. \\<exists>ts2'.\n       \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n        (ls2, (ts2', m2), ws2, is2) \\<and>\n       (\\<forall>t.\n           no_\\<tau>moves1 s1 t \\<longrightarrow>\n           no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2) t) \\<and>\n       s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ts2'.\n     \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n      (ls2, (ts2', m2), ws2, is2) \\<and>\n     (\\<forall>t.\n         no_\\<tau>moves1 s1 t \\<longrightarrow>\n         no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2) t) \\<and>\n     s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ts2'.\n     \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n      (ls2, (ts2', m2), ws2, is2) \\<and>\n     (\\<forall>t.\n         no_\\<tau>moves1 s1 t \\<longrightarrow>\n         no_\\<tau>moves2 (ls2, (ts2', m2), ws2, is2) t) \\<and>\n     s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma no_\\<tau>Move2_\\<tau>s_to_no_\\<tau>Move1:\n  fixes no_\\<tau>moves1 no_\\<tau>moves2\n  defines \"no_\\<tau>moves1 \\<equiv> \\<lambda>s1 t. wset s1 t = None \\<and> (\\<exists>x. thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and> (\\<forall>x' m'. \\<not> r1.silent_move t (x, shr s1) (x', m')))\"\n  defines \"no_\\<tau>moves2 \\<equiv> \\<lambda>s2 t. wset s2 t = None \\<and> (\\<exists>x. thr s2 t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and> (\\<forall>x' m'. \\<not> r2.silent_move t (x, shr s2) (x', m')))\"\n  assumes \"(ls1, (ts1, m1), ws1, is1) \\<approx>m s2\"\n  \n  shows \"\\<exists>ts1'. r1.mthr.silent_moves (ls1, (ts1, m1), ws1, is1) (ls1, (ts1', m1), ws1, is1) \\<and>\n                (\\<forall>t. no_\\<tau>moves2 s2 t \\<longrightarrow> no_\\<tau>moves1 (ls1, (ts1', m1), ws1, is1) t) \\<and> (ls1, (ts1', m1), ws1, is1) \\<approx>m s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ts1'.\n       \\<tau>mRed1 (ls1, (ts1, m1), ws1, is1)\n        (ls1, (ts1', m1), ws1, is1) \\<and>\n       (\\<forall>t.\n           no_\\<tau>moves2 s2 t \\<longrightarrow>\n           no_\\<tau>moves1 (ls1, (ts1', m1), ws1, is1) t) \\<and>\n       (ls1, (ts1', m1), ws1, is1) \\<approx>m s2", "using assms FWdelay_bisimulation_diverge.no_\\<tau>Move1_\\<tau>s_to_no_\\<tau>Move2[OF FWdelay_bisimulation_diverge_flip]"], ["proof (prove)\nusing this:\n  no_\\<tau>moves1 \\<equiv>\n  \\<lambda>s1 t.\n     wset s1 t = None \\<and>\n     (\\<exists>x.\n         thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n         (\\<forall>x' m'. \\<not> r1.silent_move t (x, shr s1) (x', m')))\n  no_\\<tau>moves2 \\<equiv>\n  \\<lambda>s2 t.\n     wset s2 t = None \\<and>\n     (\\<exists>x.\n         thr s2 t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n         (\\<forall>x' m'. \\<not> r2.silent_move t (x, shr s2) (x', m')))\n  (ls1, (ts1, m1), ws1, is1) \\<approx>m s2\n  FWbisimulation_base.mbisim (\\<lambda>t. flip (bisim t)) (flip bisim_wait)\n   ?s1.0 (?ls2.0, (?ts2.0, ?m2.0), ?ws2.0, ?is2.0) \\<Longrightarrow>\n  \\<exists>ts2'.\n     (\\<tau>trsys.silent_move\n       (multithreaded_base.redT final1 r1 ?convert_RA)\n       m\\<tau>move1)\\<^sup>*\\<^sup>*\n      (?ls2.0, (?ts2.0, ?m2.0), ?ws2.0, ?is2.0)\n      (?ls2.0, (ts2', ?m2.0), ?ws2.0, ?is2.0) \\<and>\n     (\\<forall>t.\n         wset ?s1.0 t = None \\<and>\n         (\\<exists>x.\n             thr ?s1.0 t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n             (\\<forall>x' m'.\n                 \\<not> r2.silent_move t (x, shr ?s1.0)\n                         (x', m'))) \\<longrightarrow>\n         wset (?ls2.0, (ts2', ?m2.0), ?ws2.0, ?is2.0) t = None \\<and>\n         (\\<exists>x.\n             thr (?ls2.0, (ts2', ?m2.0), ?ws2.0, ?is2.0) t =\n             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n             (\\<forall>x' m'.\n                 \\<not> r1.silent_move t\n                         (x, shr (?ls2.0, (ts2', ?m2.0), ?ws2.0, ?is2.0))\n                         (x', m')))) \\<and>\n     FWbisimulation_base.mbisim (\\<lambda>t. flip (bisim t))\n      (flip bisim_wait) ?s1.0 (?ls2.0, (ts2', ?m2.0), ?ws2.0, ?is2.0)\n\ngoal (1 subgoal):\n 1. \\<exists>ts1'.\n       \\<tau>mRed1 (ls1, (ts1, m1), ws1, is1)\n        (ls1, (ts1', m1), ws1, is1) \\<and>\n       (\\<forall>t.\n           no_\\<tau>moves2 s2 t \\<longrightarrow>\n           no_\\<tau>moves1 (ls1, (ts1', m1), ws1, is1) t) \\<and>\n       (ls1, (ts1', m1), ws1, is1) \\<approx>m s2", "unfolding flip_simps"], ["proof (prove)\nusing this:\n  no_\\<tau>moves1 \\<equiv>\n  \\<lambda>s1 t.\n     wset s1 t = None \\<and>\n     (\\<exists>x.\n         thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n         (\\<forall>x' m'. \\<not> r1.silent_move t (x, shr s1) (x', m')))\n  no_\\<tau>moves2 \\<equiv>\n  \\<lambda>s2 t.\n     wset s2 t = None \\<and>\n     (\\<exists>x.\n         thr s2 t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n         (\\<forall>x' m'. \\<not> r2.silent_move t (x, shr s2) (x', m')))\n  (ls1, (ts1, m1), ws1, is1) \\<approx>m s2\n  (?ls2.0, (?ts2.0, ?m2.0), ?ws2.0,\n   ?is2.0) \\<approx>m ?s1.0 \\<Longrightarrow>\n  \\<exists>ts2'.\n     (\\<tau>trsys.silent_move\n       (multithreaded_base.redT final1 r1 ?convert_RA)\n       m\\<tau>move1)\\<^sup>*\\<^sup>*\n      (?ls2.0, (?ts2.0, ?m2.0), ?ws2.0, ?is2.0)\n      (?ls2.0, (ts2', ?m2.0), ?ws2.0, ?is2.0) \\<and>\n     (\\<forall>t.\n         wset ?s1.0 t = None \\<and>\n         (\\<exists>x.\n             thr ?s1.0 t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n             (\\<forall>x' m'.\n                 \\<not> r2.silent_move t (x, shr ?s1.0)\n                         (x', m'))) \\<longrightarrow>\n         wset (?ls2.0, (ts2', ?m2.0), ?ws2.0, ?is2.0) t = None \\<and>\n         (\\<exists>x.\n             thr (?ls2.0, (ts2', ?m2.0), ?ws2.0, ?is2.0) t =\n             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n             (\\<forall>x' m'.\n                 \\<not> r1.silent_move t\n                         (x, shr (?ls2.0, (ts2', ?m2.0), ?ws2.0, ?is2.0))\n                         (x', m')))) \\<and>\n     (?ls2.0, (ts2', ?m2.0), ?ws2.0, ?is2.0) \\<approx>m ?s1.0\n\ngoal (1 subgoal):\n 1. \\<exists>ts1'.\n       \\<tau>mRed1 (ls1, (ts1, m1), ws1, is1)\n        (ls1, (ts1', m1), ws1, is1) \\<and>\n       (\\<forall>t.\n           no_\\<tau>moves2 s2 t \\<longrightarrow>\n           no_\\<tau>moves1 (ls1, (ts1', m1), ws1, is1) t) \\<and>\n       (ls1, (ts1', m1), ws1, is1) \\<approx>m s2", "by blast"], ["", "lemma deadlock_mbisim_not_final_thread_pres:\n  assumes dead: \"t \\<in> r1.deadlocked s1 \\<or> r1.deadlock s1\"\n  and nfin: \"r1.not_final_thread s1 t\"\n  and fin: \"r1.final_thread s1 t \\<Longrightarrow> r2.final_thread s2 t\"\n  and mbisim: \"s1 \\<approx>m s2\"\n  shows \"r2.not_final_thread s2 t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r2.not_final_thread s2 t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. r2.not_final_thread s2 t", "from nfin"], ["proof (chain)\npicking this:\n  r1.not_final_thread s1 t", "obtain x1 ln where \"thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>\""], ["proof (prove)\nusing this:\n  r1.not_final_thread s1 t\n\ngoal (1 subgoal):\n 1. (\\<And>x1 ln.\n        thr s1 t = \\<lfloor>(x1, ln)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>\n\ngoal (1 subgoal):\n 1. r2.not_final_thread s2 t", "with mbisim"], ["proof (chain)\npicking this:\n  s1 \\<approx>m s2\n  thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>", "obtain x2 where \"thr s2 t = \\<lfloor>(x2, ln)\\<rfloor>\" \"t \\<turnstile> (x1, shr s1) \\<approx> (x2, shr s2)\" \"wset s1 t = None \\<or> x1 \\<approx>w x2\""], ["proof (prove)\nusing this:\n  s1 \\<approx>m s2\n  thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>x2.\n        \\<lbrakk>thr s2 t = \\<lfloor>(x2, ln)\\<rfloor>;\n         t \\<turnstile> (x1, shr s1) \\<approx> (x2, shr s2);\n         wset s1 t = None \\<or> x1 \\<approx>w x2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: mbisim_thrD1)"], ["proof (state)\nthis:\n  thr s2 t = \\<lfloor>(x2, ln)\\<rfloor>\n  t \\<turnstile> (x1, shr s1) \\<approx> (x2, shr s2)\n  wset s1 t = None \\<or> x1 \\<approx>w x2\n\ngoal (1 subgoal):\n 1. r2.not_final_thread s2 t", "show \"r2.not_final_thread s2 t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r2.not_final_thread s2 t", "proof(cases \"wset s1 t = None \\<and> ln = no_wait_locks\")"], ["proof (state)\ngoal (2 subgoals):\n 1. wset s1 t = None \\<and> ln = no_wait_locks \\<Longrightarrow>\n    r2.not_final_thread s2 t\n 2. \\<not> (wset s1 t = None \\<and> ln = no_wait_locks) \\<Longrightarrow>\n    r2.not_final_thread s2 t", "case False"], ["proof (state)\nthis:\n  \\<not> (wset s1 t = None \\<and> ln = no_wait_locks)\n\ngoal (2 subgoals):\n 1. wset s1 t = None \\<and> ln = no_wait_locks \\<Longrightarrow>\n    r2.not_final_thread s2 t\n 2. \\<not> (wset s1 t = None \\<and> ln = no_wait_locks) \\<Longrightarrow>\n    r2.not_final_thread s2 t", "with \\<open>r1.not_final_thread s1 t\\<close> \\<open>thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>\\<close> \\<open>thr s2 t = \\<lfloor>(x2, ln)\\<rfloor>\\<close> mbisim"], ["proof (chain)\npicking this:\n  r1.not_final_thread s1 t\n  thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>\n  thr s2 t = \\<lfloor>(x2, ln)\\<rfloor>\n  s1 \\<approx>m s2\n  \\<not> (wset s1 t = None \\<and> ln = no_wait_locks)", "show ?thesis"], ["proof (prove)\nusing this:\n  r1.not_final_thread s1 t\n  thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>\n  thr s2 t = \\<lfloor>(x2, ln)\\<rfloor>\n  s1 \\<approx>m s2\n  \\<not> (wset s1 t = None \\<and> ln = no_wait_locks)\n\ngoal (1 subgoal):\n 1. r2.not_final_thread s2 t", "by cases(auto simp add: mbisim_def r2.not_final_thread_iff)"], ["proof (state)\nthis:\n  r2.not_final_thread s2 t\n\ngoal (1 subgoal):\n 1. wset s1 t = None \\<and> ln = no_wait_locks \\<Longrightarrow>\n    r2.not_final_thread s2 t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. wset s1 t = None \\<and> ln = no_wait_locks \\<Longrightarrow>\n    r2.not_final_thread s2 t", "case True"], ["proof (state)\nthis:\n  wset s1 t = None \\<and> ln = no_wait_locks\n\ngoal (1 subgoal):\n 1. wset s1 t = None \\<and> ln = no_wait_locks \\<Longrightarrow>\n    r2.not_final_thread s2 t", "with \\<open>r1.not_final_thread s1 t\\<close> \\<open>thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  r1.not_final_thread s1 t\n  thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>\n  wset s1 t = None \\<and> ln = no_wait_locks", "have \"\\<not> final1 x1\""], ["proof (prove)\nusing this:\n  r1.not_final_thread s1 t\n  thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>\n  wset s1 t = None \\<and> ln = no_wait_locks\n\ngoal (1 subgoal):\n 1. \\<not> final1 x1", "by(cases) auto"], ["proof (state)\nthis:\n  \\<not> final1 x1\n\ngoal (1 subgoal):\n 1. wset s1 t = None \\<and> ln = no_wait_locks \\<Longrightarrow>\n    r2.not_final_thread s2 t", "have \"\\<not> final2 x2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> final2 x2", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. final2 x2 \\<Longrightarrow> False", "assume \"final2 x2\""], ["proof (state)\nthis:\n  final2 x2\n\ngoal (1 subgoal):\n 1. final2 x2 \\<Longrightarrow> False", "with final2_simulation[OF \\<open>t \\<turnstile> (x1, shr s1) \\<approx> (x2, shr s2)\\<close>]"], ["proof (chain)\npicking this:\n  case (x2, shr s2) of (x2, m) \\<Rightarrow> final2 x2 \\<Longrightarrow>\n  \\<exists>s1'.\n     r1.silent_moves t (x1, shr s1) s1' \\<and>\n     t \\<turnstile> s1' \\<approx> (x2, shr s2) \\<and>\n     (case s1' of (x1, m) \\<Rightarrow> final1 x1)\n  final2 x2", "obtain x1' m1' where \"r1.silent_moves t (x1, shr s1) (x1', m1')\" \"t \\<turnstile> (x1', m1') \\<approx> (x2, shr s2)\" \"final1 x1'\""], ["proof (prove)\nusing this:\n  case (x2, shr s2) of (x2, m) \\<Rightarrow> final2 x2 \\<Longrightarrow>\n  \\<exists>s1'.\n     r1.silent_moves t (x1, shr s1) s1' \\<and>\n     t \\<turnstile> s1' \\<approx> (x2, shr s2) \\<and>\n     (case s1' of (x1, m) \\<Rightarrow> final1 x1)\n  final2 x2\n\ngoal (1 subgoal):\n 1. (\\<And>x1' m1'.\n        \\<lbrakk>r1.silent_moves t (x1, shr s1) (x1', m1');\n         t \\<turnstile> (x1', m1') \\<approx> (x2, shr s2);\n         final1 x1'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  r1.silent_moves t (x1, shr s1) (x1', m1')\n  t \\<turnstile> (x1', m1') \\<approx> (x2, shr s2)\n  final1 x1'\n\ngoal (1 subgoal):\n 1. final2 x2 \\<Longrightarrow> False", "from \\<open>r1.silent_moves t (x1, shr s1) (x1', m1')\\<close>"], ["proof (chain)\npicking this:\n  r1.silent_moves t (x1, shr s1) (x1', m1')", "have \"x1' = x1\""], ["proof (prove)\nusing this:\n  r1.silent_moves t (x1, shr s1) (x1', m1')\n\ngoal (1 subgoal):\n 1. x1' = x1", "proof(cases rule: converse_rtranclpE2[consumes 1, case_names refl step])"], ["proof (state)\ngoal (2 subgoals):\n 1. (x1, shr s1) = (x1', m1') \\<Longrightarrow> x1' = x1\n 2. \\<And>a b.\n       \\<lbrakk>r1.silent_move t (x1, shr s1) (a, b);\n        r1.silent_moves t (a, b) (x1', m1')\\<rbrakk>\n       \\<Longrightarrow> x1' = x1", "case (step x1'' m1'')"], ["proof (state)\nthis:\n  r1.silent_move t (x1, shr s1) (x1'', m1'')\n  r1.silent_moves t (x1'', m1'') (x1', m1')\n\ngoal (2 subgoals):\n 1. (x1, shr s1) = (x1', m1') \\<Longrightarrow> x1' = x1\n 2. \\<And>a b.\n       \\<lbrakk>r1.silent_move t (x1, shr s1) (a, b);\n        r1.silent_moves t (a, b) (x1', m1')\\<rbrakk>\n       \\<Longrightarrow> x1' = x1", "from \\<open>r1.silent_move t (x1, shr s1) (x1'', m1'')\\<close>"], ["proof (chain)\npicking this:\n  r1.silent_move t (x1, shr s1) (x1'', m1'')", "have \"t \\<turnstile> (x1, shr s1) -1-\\<epsilon>\\<rightarrow> (x1'', m1'')\""], ["proof (prove)\nusing this:\n  r1.silent_move t (x1, shr s1) (x1'', m1'')\n\ngoal (1 subgoal):\n 1. r1.r_syntax t x1 (shr s1) \\<lbrace>\\<rbrace> x1'' m1''", "by(auto dest: r1.silent_tl)"], ["proof (state)\nthis:\n  r1.r_syntax t x1 (shr s1) \\<lbrace>\\<rbrace> x1'' m1''\n\ngoal (2 subgoals):\n 1. (x1, shr s1) = (x1', m1') \\<Longrightarrow> x1' = x1\n 2. \\<And>a b.\n       \\<lbrakk>r1.silent_move t (x1, shr s1) (a, b);\n        r1.silent_moves t (a, b) (x1', m1')\\<rbrakk>\n       \\<Longrightarrow> x1' = x1", "hence \"r1.redT s1 (t, \\<epsilon>) (redT_upd_\\<epsilon> s1 t x1'' m1'')\""], ["proof (prove)\nusing this:\n  r1.r_syntax t x1 (shr s1) \\<lbrace>\\<rbrace> x1'' m1''\n\ngoal (1 subgoal):\n 1. s1 -1-t\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> redT_upd_\\<epsilon>\n                      s1 t x1'' m1''", "using \\<open>thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>\\<close> True"], ["proof (prove)\nusing this:\n  r1.r_syntax t x1 (shr s1) \\<lbrace>\\<rbrace> x1'' m1''\n  thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>\n  wset s1 t = None \\<and> ln = no_wait_locks\n\ngoal (1 subgoal):\n 1. s1 -1-t\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> redT_upd_\\<epsilon>\n                      s1 t x1'' m1''", "by -(erule r1.redT_normal, auto simp add: redT_updLns_def finfun_Diag_const2 o_def redT_updWs_def)"], ["proof (state)\nthis:\n  s1 -1-t\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> redT_upd_\\<epsilon>\n                    s1 t x1'' m1''\n\ngoal (2 subgoals):\n 1. (x1, shr s1) = (x1', m1') \\<Longrightarrow> x1' = x1\n 2. \\<And>a b.\n       \\<lbrakk>r1.silent_move t (x1, shr s1) (a, b);\n        r1.silent_moves t (a, b) (x1', m1')\\<rbrakk>\n       \\<Longrightarrow> x1' = x1", "hence False"], ["proof (prove)\nusing this:\n  s1 -1-t\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> redT_upd_\\<epsilon>\n                    s1 t x1'' m1''\n\ngoal (1 subgoal):\n 1. False", "using dead"], ["proof (prove)\nusing this:\n  s1 -1-t\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> redT_upd_\\<epsilon>\n                    s1 t x1'' m1''\n  t \\<in> r1.deadlocked s1 \\<or> r1.deadlock s1\n\ngoal (1 subgoal):\n 1. False", "by(auto intro: r1.deadlock_no_red r1.red_no_deadlock)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. (x1, shr s1) = (x1', m1') \\<Longrightarrow> x1' = x1\n 2. \\<And>a b.\n       \\<lbrakk>r1.silent_move t (x1, shr s1) (a, b);\n        r1.silent_moves t (a, b) (x1', m1')\\<rbrakk>\n       \\<Longrightarrow> x1' = x1", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. x1' = x1", ".."], ["proof (state)\nthis:\n  x1' = x1\n\ngoal (1 subgoal):\n 1. (x1, shr s1) = (x1', m1') \\<Longrightarrow> x1' = x1", "qed simp"], ["proof (state)\nthis:\n  x1' = x1\n\ngoal (1 subgoal):\n 1. final2 x2 \\<Longrightarrow> False", "with \\<open>\\<not> final1 x1\\<close> \\<open>final1 x1'\\<close>"], ["proof (chain)\npicking this:\n  \\<not> final1 x1\n  final1 x1'\n  x1' = x1", "show False"], ["proof (prove)\nusing this:\n  \\<not> final1 x1\n  final1 x1'\n  x1' = x1\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> final2 x2\n\ngoal (1 subgoal):\n 1. wset s1 t = None \\<and> ln = no_wait_locks \\<Longrightarrow>\n    r2.not_final_thread s2 t", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> final2 x2\n\ngoal (1 subgoal):\n 1. r2.not_final_thread s2 t", "using \\<open>thr s2 t = \\<lfloor>(x2, ln)\\<rfloor>\\<close>"], ["proof (prove)\nusing this:\n  \\<not> final2 x2\n  thr s2 t = \\<lfloor>(x2, ln)\\<rfloor>\n\ngoal (1 subgoal):\n 1. r2.not_final_thread s2 t", "by(auto simp add: r2.not_final_thread_iff)"], ["proof (state)\nthis:\n  r2.not_final_thread s2 t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r2.not_final_thread s2 t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma deadlocked1_imp_\\<tau>s_deadlocked2:\n  assumes mbisim: \"s1 \\<approx>m s2\"\n  and dead: \"t \\<in> r1.deadlocked s1\"\n  shows \"\\<exists>s2'. r2.mthr.silent_moves s2 s2' \\<and> t \\<in> r2.deadlocked s2' \\<and> s1 \\<approx>m s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and>\n       t \\<in> r2.deadlocked s2' \\<and> s1 \\<approx>m s2'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and>\n       t \\<in> r2.deadlocked s2' \\<and> s1 \\<approx>m s2'", "from mfinal1_inv_simulation[OF mbisim]"], ["proof (chain)\npicking this:\n  \\<exists>s2'.\n     \\<tau>mRed2 s2 s2' \\<and>\n     s1 \\<approx>m s2' \\<and>\n     r1.final_threads s1 \\<subseteq> r2.final_threads s2' \\<and>\n     shr s2' = shr s2", "obtain ls2 ts2 m2 ws2 is2 where red1: \"r2.mthr.silent_moves s2 (ls2, (ts2, m2), ws2, is2)\"\n    and \"s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\" and \"m2 = shr s2\" \n    and fin: \"\\<And>t. r1.final_thread s1 t \\<Longrightarrow> r2.final_thread (ls2, (ts2, m2), ws2, is2) t\""], ["proof (prove)\nusing this:\n  \\<exists>s2'.\n     \\<tau>mRed2 s2 s2' \\<and>\n     s1 \\<approx>m s2' \\<and>\n     r1.final_threads s1 \\<subseteq> r2.final_threads s2' \\<and>\n     shr s2' = shr s2\n\ngoal (1 subgoal):\n 1. (\\<And>ls2 ts2 m2 ws2 is2.\n        \\<lbrakk>\\<tau>mRed2 s2 (ls2, (ts2, m2), ws2, is2);\n         s1 \\<approx>m (ls2, (ts2, m2), ws2, is2); m2 = shr s2;\n         \\<And>t.\n            r1.final_thread s1 t \\<Longrightarrow>\n            r2.final_thread (ls2, (ts2, m2), ws2, is2) t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<tau>mRed2 s2 (ls2, (ts2, m2), ws2, is2)\n  s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\n  m2 = shr s2\n  r1.final_thread s1 ?t14 \\<Longrightarrow>\n  r2.final_thread (ls2, (ts2, m2), ws2, is2) ?t14\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and>\n       t \\<in> r2.deadlocked s2' \\<and> s1 \\<approx>m s2'", "from no_\\<tau>Move1_\\<tau>s_to_no_\\<tau>Move2[OF \\<open>s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>ts2'.\n     \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n      (ls2, (ts2', m2), ws2, is2) \\<and>\n     (\\<forall>t.\n         wset s1 t = None \\<and>\n         (\\<exists>x.\n             thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n             (\\<forall>x' m'.\n                 \\<not> r1.silent_move t (x, shr s1)\n                         (x', m'))) \\<longrightarrow>\n         wset (ls2, (ts2', m2), ws2, is2) t = None \\<and>\n         (\\<exists>x.\n             thr (ls2, (ts2', m2), ws2, is2) t =\n             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n             (\\<forall>x' m'.\n                 \\<not> r2.silent_move t\n                         (x, shr (ls2, (ts2', m2), ws2, is2))\n                         (x', m')))) \\<and>\n     s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "obtain ts2' where red2: \"r2.mthr.silent_moves (ls2, (ts2, m2), ws2, is2) (ls2, (ts2', m2), ws2, is2)\"\n    and no_\\<tau>: \"\\<And>t x1 x2 x2' m2'. \\<lbrakk> wset s1 t = None; thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>; ts2' t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>;\n                           \\<And>x' m'. r1.silent_move t (x1, shr s1) (x', m') \\<Longrightarrow> False \\<rbrakk>\n              \\<Longrightarrow>  \\<not> r2.silent_move t (x2, m2) (x2', m2')\"\n    and mbisim: \"s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\""], ["proof (prove)\nusing this:\n  \\<exists>ts2'.\n     \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n      (ls2, (ts2', m2), ws2, is2) \\<and>\n     (\\<forall>t.\n         wset s1 t = None \\<and>\n         (\\<exists>x.\n             thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n             (\\<forall>x' m'.\n                 \\<not> r1.silent_move t (x, shr s1)\n                         (x', m'))) \\<longrightarrow>\n         wset (ls2, (ts2', m2), ws2, is2) t = None \\<and>\n         (\\<exists>x.\n             thr (ls2, (ts2', m2), ws2, is2) t =\n             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n             (\\<forall>x' m'.\n                 \\<not> r2.silent_move t\n                         (x, shr (ls2, (ts2', m2), ws2, is2))\n                         (x', m')))) \\<and>\n     s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. (\\<And>ts2'.\n        \\<lbrakk>\\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                  (ls2, (ts2', m2), ws2, is2);\n         \\<And>t x1 x2 x2' m2'.\n            \\<lbrakk>wset s1 t = None;\n             thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>;\n             ts2' t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>;\n             \\<And>x' m'.\n                r1.silent_move t (x1, shr s1) (x', m') \\<Longrightarrow>\n                False\\<rbrakk>\n            \\<Longrightarrow> \\<not> r2.silent_move t (x2, m2) (x2', m2');\n         s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2) (ls2, (ts2', m2), ws2, is2)\n  \\<lbrakk>wset s1 ?t14 = None;\n   thr s1 ?t14 = \\<lfloor>(?x1.14, no_wait_locks)\\<rfloor>;\n   ts2' ?t14 = \\<lfloor>(?x2.14, no_wait_locks)\\<rfloor>;\n   \\<And>x' m'.\n      r1.silent_move ?t14 (?x1.14, shr s1) (x', m') \\<Longrightarrow>\n      False\\<rbrakk>\n  \\<Longrightarrow> \\<not> r2.silent_move ?t14 (?x2.14, m2) (?x2'14, ?m2'14)\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and>\n       t \\<in> r2.deadlocked s2' \\<and> s1 \\<approx>m s2'", "from mbisim"], ["proof (chain)\npicking this:\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "have mbisim_eqs: \"ls2 = locks s1\" \"ws2 = wset s1\" \"is2 = interrupts s1\""], ["proof (prove)\nusing this:\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. ls2 = locks s1 &&& ws2 = wset s1 &&& is2 = interrupts s1", "by(simp_all add: mbisim_def)"], ["proof (state)\nthis:\n  ls2 = locks s1\n  ws2 = wset s1\n  is2 = interrupts s1\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and>\n       t \\<in> r2.deadlocked s2' \\<and> s1 \\<approx>m s2'", "let ?s2 = \"(ls2, (ts2', m2), ws2, is2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and>\n       t \\<in> r2.deadlocked s2' \\<and> s1 \\<approx>m s2'", "from red2"], ["proof (chain)\npicking this:\n  \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2) (ls2, (ts2', m2), ws2, is2)", "have fin': \"\\<And>t. r1.final_thread s1 t \\<Longrightarrow> r2.final_thread ?s2 t\""], ["proof (prove)\nusing this:\n  \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2) (ls2, (ts2', m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       r1.final_thread s1 t \\<Longrightarrow>\n       r2.final_thread (ls2, (ts2', m2), ws2, is2) t", "by(rule r2.\\<tau>mRedT_preserves_final_thread)(rule fin)"], ["proof (state)\nthis:\n  r1.final_thread s1 ?t14 \\<Longrightarrow>\n  r2.final_thread (ls2, (ts2', m2), ws2, is2) ?t14\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and>\n       t \\<in> r2.deadlocked s2' \\<and> s1 \\<approx>m s2'", "from dead"], ["proof (chain)\npicking this:\n  t \\<in> r1.deadlocked s1", "have \"t \\<in> r2.deadlocked ?s2\""], ["proof (prove)\nusing this:\n  t \\<in> r1.deadlocked s1\n\ngoal (1 subgoal):\n 1. t \\<in> r2.deadlocked (ls2, (ts2', m2), ws2, is2)", "proof(coinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> r1.deadlocked s1 \\<Longrightarrow>\n       (\\<exists>x.\n           thr (ls2, (ts2', m2), ws2, is2) t =\n           \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x,\n           shr (ls2, (ts2', m2), ws2, is2)\\<rangle> \\<wrong>2 \\<and>\n           wset (ls2, (ts2', m2), ws2, is2) t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x,\n               shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n               \\<wrong>2 \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                    (r1.deadlocked s1 \\<union>\n                     r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n                     r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n       (\\<exists>x ln.\n           thr (ls2, (ts2', m2), ws2, is2) t =\n           \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n            (r1.deadlocked s1 \\<union>\n             r2.deadlocked (ls2, (ts2', m2), ws2, is2)) \\<and>\n           waiting (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr (ls2, (ts2', m2), ws2, is2) t =\n           \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> r1.deadlocked s1 \\<or>\n             t' \\<in> r2.deadlocked (ls2, (ts2', m2), ws2, is2)) \\<or>\n            r2.final_thread (ls2, (ts2', m2), ws2, is2) t'))", "case (deadlocked t)"], ["proof (state)\nthis:\n  t \\<in> r1.deadlocked s1\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> r1.deadlocked s1 \\<Longrightarrow>\n       (\\<exists>x.\n           thr (ls2, (ts2', m2), ws2, is2) t =\n           \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x,\n           shr (ls2, (ts2', m2), ws2, is2)\\<rangle> \\<wrong>2 \\<and>\n           wset (ls2, (ts2', m2), ws2, is2) t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x,\n               shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n               \\<wrong>2 \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                    (r1.deadlocked s1 \\<union>\n                     r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n                     r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n       (\\<exists>x ln.\n           thr (ls2, (ts2', m2), ws2, is2) t =\n           \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n            (r1.deadlocked s1 \\<union>\n             r2.deadlocked (ls2, (ts2', m2), ws2, is2)) \\<and>\n           waiting (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr (ls2, (ts2', m2), ws2, is2) t =\n           \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> r1.deadlocked s1 \\<or>\n             t' \\<in> r2.deadlocked (ls2, (ts2', m2), ws2, is2)) \\<or>\n            r2.final_thread (ls2, (ts2', m2), ws2, is2) t'))", "thus ?case"], ["proof (prove)\nusing this:\n  t \\<in> r1.deadlocked s1\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr (ls2, (ts2', m2), ws2, is2) t =\n        \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t \\<turnstile> \\<langle>x, shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n        \\<wrong>2 \\<and>\n        wset (ls2, (ts2', m2), ws2, is2) t = None \\<and>\n        (\\<forall>LT.\n            t \\<turnstile> \\<langle>x,\n            shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n            \\<wrong>2 \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                 (r1.deadlocked s1 \\<union>\n                  r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n                  r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n    (\\<exists>x ln.\n        thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n         (r1.deadlocked s1 \\<union>\n          r2.deadlocked (ls2, (ts2', m2), ws2, is2)) \\<and>\n        waiting (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n    (\\<exists>x l t' ln.\n        thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l) t' \\<and>\n        t' \\<noteq> t \\<and>\n        ((t' \\<in> r1.deadlocked s1 \\<or>\n          t' \\<in> r2.deadlocked (ls2, (ts2', m2), ws2, is2)) \\<or>\n         r2.final_thread (ls2, (ts2', m2), ws2, is2) t'))", "proof(cases rule: r1.deadlocked_elims)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s1\\<rangle> \\<wrong>1;\n        wset s1 t = None;\n        \\<And>LT.\n           t \\<turnstile> \\<langle>x, shr s1\\<rangle> LT\n           \\<wrong>1 \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              r1.must_wait s1 t lt\n               (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "case (lock x1)"], ["proof (state)\nthis:\n  thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>\n  t \\<turnstile> \\<langle>x1, shr s1\\<rangle> \\<wrong>1\n  wset s1 t = None\n  t \\<turnstile> \\<langle>x1, shr s1\\<rangle> ?LT14\n  \\<wrong>1 \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT14.\n     r1.must_wait s1 t lt (r1.deadlocked s1 \\<union> r1.final_threads s1)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s1\\<rangle> \\<wrong>1;\n        wset s1 t = None;\n        \\<And>LT.\n           t \\<turnstile> \\<langle>x, shr s1\\<rangle> LT\n           \\<wrong>1 \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              r1.must_wait s1 t lt\n               (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "hence csmw: \"\\<And>LT. r1.can_sync t x1 (shr s1) LT \\<Longrightarrow>\n                   \\<exists>lt\\<in>LT. r1.must_wait s1 t lt (r1.deadlocked s1 \\<union> r1.final_threads s1)\""], ["proof (prove)\nusing this:\n  thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>\n  t \\<turnstile> \\<langle>x1, shr s1\\<rangle> \\<wrong>1\n  wset s1 t = None\n  t \\<turnstile> \\<langle>x1, shr s1\\<rangle> ?LT14\n  \\<wrong>1 \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT14.\n     r1.must_wait s1 t lt (r1.deadlocked s1 \\<union> r1.final_threads s1)\n\ngoal (1 subgoal):\n 1. \\<And>LT.\n       t \\<turnstile> \\<langle>x1, shr s1\\<rangle> LT\n       \\<wrong>1 \\<Longrightarrow>\n       \\<exists>lt\\<in>LT.\n          r1.must_wait s1 t lt\n           (r1.deadlocked s1 \\<union> r1.final_threads s1)", "by blast"], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x1, shr s1\\<rangle> ?LT14\n  \\<wrong>1 \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT14.\n     r1.must_wait s1 t lt (r1.deadlocked s1 \\<union> r1.final_threads s1)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s1\\<rangle> \\<wrong>1;\n        wset s1 t = None;\n        \\<And>LT.\n           t \\<turnstile> \\<langle>x, shr s1\\<rangle> LT\n           \\<wrong>1 \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              r1.must_wait s1 t lt\n               (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "from \\<open>thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>\\<close> mbisim"], ["proof (chain)\npicking this:\n  thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "obtain x2\n        where \"ts2' t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>\" and bisim: \"t \\<turnstile> (x1, shr s1) \\<approx> (x2, m2)\""], ["proof (prove)\nusing this:\n  thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. (\\<And>x2.\n        \\<lbrakk>ts2' t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>;\n         t \\<turnstile> (x1, shr s1) \\<approx> (x2, m2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: mbisim_thrD1)"], ["proof (state)\nthis:\n  ts2' t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>\n  t \\<turnstile> (x1, shr s1) \\<approx> (x2, m2)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s1\\<rangle> \\<wrong>1;\n        wset s1 t = None;\n        \\<And>LT.\n           t \\<turnstile> \\<langle>x, shr s1\\<rangle> LT\n           \\<wrong>1 \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              r1.must_wait s1 t lt\n               (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "note \\<open>ts2' t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>\\<close>"], ["proof (state)\nthis:\n  ts2' t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s1\\<rangle> \\<wrong>1;\n        wset s1 t = None;\n        \\<And>LT.\n           t \\<turnstile> \\<langle>x, shr s1\\<rangle> LT\n           \\<wrong>1 \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              r1.must_wait s1 t lt\n               (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "moreover"], ["proof (state)\nthis:\n  ts2' t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s1\\<rangle> \\<wrong>1;\n        wset s1 t = None;\n        \\<And>LT.\n           t \\<turnstile> \\<langle>x, shr s1\\<rangle> LT\n           \\<wrong>1 \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              r1.must_wait s1 t lt\n               (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "{"], ["proof (state)\nthis:\n  ts2' t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s1\\<rangle> \\<wrong>1;\n        wset s1 t = None;\n        \\<And>LT.\n           t \\<turnstile> \\<langle>x, shr s1\\<rangle> LT\n           \\<wrong>1 \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              r1.must_wait s1 t lt\n               (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "from \\<open>r1.must_sync t x1 (shr s1)\\<close>"], ["proof (chain)\npicking this:\n  t \\<turnstile> \\<langle>x1, shr s1\\<rangle> \\<wrong>1", "obtain ta1 x1' m1'\n          where r1: \"t \\<turnstile> (x1, shr s1) -1-ta1\\<rightarrow> (x1', m1')\"\n          and s1': \"\\<exists>s1'. r1.actions_ok s1' t ta1\""], ["proof (prove)\nusing this:\n  t \\<turnstile> \\<langle>x1, shr s1\\<rangle> \\<wrong>1\n\ngoal (1 subgoal):\n 1. (\\<And>ta1 x1' m1'.\n        \\<lbrakk>r1.r_syntax t x1 (shr s1) ta1 x1' m1';\n         \\<exists>s1'. r1.actions_ok s1' t ta1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim: r1.must_syncE)"], ["proof (state)\nthis:\n  r1.r_syntax t x1 (shr s1) ta1 x1' m1'\n  \\<exists>s1'. r1.actions_ok s1' t ta1\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s1\\<rangle> \\<wrong>1;\n        wset s1 t = None;\n        \\<And>LT.\n           t \\<turnstile> \\<langle>x, shr s1\\<rangle> LT\n           \\<wrong>1 \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              r1.must_wait s1 t lt\n               (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "have \"\\<not> \\<tau>move1 (x1, shr s1) ta1 (x1', m1')\" (is \"\\<not> ?\\<tau>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<tau>move1 (x1, shr s1) ta1 (x1', m1')", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<tau>move1 (x1, shr s1) ta1 (x1', m1') \\<Longrightarrow> False", "assume \"?\\<tau>\""], ["proof (state)\nthis:\n  \\<tau>move1 (x1, shr s1) ta1 (x1', m1')\n\ngoal (1 subgoal):\n 1. \\<tau>move1 (x1, shr s1) ta1 (x1', m1') \\<Longrightarrow> False", "hence \"ta1 = \\<epsilon>\""], ["proof (prove)\nusing this:\n  \\<tau>move1 (x1, shr s1) ta1 (x1', m1')\n\ngoal (1 subgoal):\n 1. ta1 = \\<lbrace>\\<rbrace>", "by(rule r1.silent_tl)"], ["proof (state)\nthis:\n  ta1 = \\<lbrace>\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<tau>move1 (x1, shr s1) ta1 (x1', m1') \\<Longrightarrow> False", "with r1"], ["proof (chain)\npicking this:\n  r1.r_syntax t x1 (shr s1) ta1 x1' m1'\n  ta1 = \\<lbrace>\\<rbrace>", "have \"r1.can_sync t x1 (shr s1) {}\""], ["proof (prove)\nusing this:\n  r1.r_syntax t x1 (shr s1) ta1 x1' m1'\n  ta1 = \\<lbrace>\\<rbrace>\n\ngoal (1 subgoal):\n 1. t \\<turnstile> \\<langle>x1, shr s1\\<rangle> {} \\<wrong>1", "by(auto intro!: r1.can_syncI simp add: collect_locks_def collect_interrupts_def)"], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x1, shr s1\\<rangle> {} \\<wrong>1\n\ngoal (1 subgoal):\n 1. \\<tau>move1 (x1, shr s1) ta1 (x1', m1') \\<Longrightarrow> False", "from csmw[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>lt\\<in>{}.\n     r1.must_wait s1 t lt (r1.deadlocked s1 \\<union> r1.final_threads s1)", "show False"], ["proof (prove)\nusing this:\n  \\<exists>lt\\<in>{}.\n     r1.must_wait s1 t lt (r1.deadlocked s1 \\<union> r1.final_threads s1)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> \\<tau>move1 (x1, shr s1) ta1 (x1', m1')\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s1\\<rangle> \\<wrong>1;\n        wset s1 t = None;\n        \\<And>LT.\n           t \\<turnstile> \\<langle>x, shr s1\\<rangle> LT\n           \\<wrong>1 \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              r1.must_wait s1 t lt\n               (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "from simulation1[OF bisim r1 this]"], ["proof (chain)\npicking this:\n  \\<exists>s2' s2'' tl2.\n     r2.silent_moves t (x2, m2) s2' \\<and>\n     t \\<turnstile> s2' -2-tl2\\<rightarrow> s2'' \\<and>\n     \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n     t \\<turnstile> (x1', m1') \\<approx> s2'' \\<and> ta1 \\<sim>m tl2", "obtain x2' m2' x2'' m2'' ta2 where r2: \"r2.silent_moves t (x2, m2) (x2', m2')\"\n          and r2': \"t \\<turnstile> (x2', m2') -2-ta2\\<rightarrow>  (x2'', m2'')\"\n          and \\<tau>2: \"\\<not> \\<tau>move2 (x2', m2') ta2 (x2'', m2'')\"\n          and bisim': \"t \\<turnstile> (x1', m1') \\<approx> (x2'', m2'')\" and tasim: \"ta1 \\<sim>m ta2\""], ["proof (prove)\nusing this:\n  \\<exists>s2' s2'' tl2.\n     r2.silent_moves t (x2, m2) s2' \\<and>\n     t \\<turnstile> s2' -2-tl2\\<rightarrow> s2'' \\<and>\n     \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n     t \\<turnstile> (x1', m1') \\<approx> s2'' \\<and> ta1 \\<sim>m tl2\n\ngoal (1 subgoal):\n 1. (\\<And>x2' m2' ta2 x2'' m2''.\n        \\<lbrakk>r2.silent_moves t (x2, m2) (x2', m2');\n         r2.r_syntax t x2' m2' ta2 x2'' m2'';\n         \\<not> \\<tau>move2 (x2', m2') ta2 (x2'', m2'');\n         t \\<turnstile> (x1', m1') \\<approx> (x2'', m2'');\n         ta1 \\<sim>m ta2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  r2.silent_moves t (x2, m2) (x2', m2')\n  r2.r_syntax t x2' m2' ta2 x2'' m2''\n  \\<not> \\<tau>move2 (x2', m2') ta2 (x2'', m2'')\n  t \\<turnstile> (x1', m1') \\<approx> (x2'', m2'')\n  ta1 \\<sim>m ta2\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s1\\<rangle> \\<wrong>1;\n        wset s1 t = None;\n        \\<And>LT.\n           t \\<turnstile> \\<langle>x, shr s1\\<rangle> LT\n           \\<wrong>1 \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              r1.must_wait s1 t lt\n               (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "from r2"], ["proof (chain)\npicking this:\n  r2.silent_moves t (x2, m2) (x2', m2')", "have \"\\<exists>ta2 x2' m2' s2'. t \\<turnstile> (x2, m2) -2-ta2\\<rightarrow> (x2', m2') \\<and> r2.actions_ok s2' t ta2\""], ["proof (prove)\nusing this:\n  r2.silent_moves t (x2, m2) (x2', m2')\n\ngoal (1 subgoal):\n 1. \\<exists>ta2 x2' m2' s2'.\n       r2.r_syntax t x2 m2 ta2 x2' m2' \\<and> r2.actions_ok s2' t ta2", "proof(cases rule: converse_rtranclpE2[consumes 1, case_names base step])"], ["proof (state)\ngoal (2 subgoals):\n 1. (x2, m2) = (x2', m2') \\<Longrightarrow>\n    \\<exists>ta2 x2' m2' s2'.\n       r2.r_syntax t x2 m2 ta2 x2' m2' \\<and> r2.actions_ok s2' t ta2\n 2. \\<And>a b.\n       \\<lbrakk>r2.silent_move t (x2, m2) (a, b);\n        r2.silent_moves t (a, b) (x2', m2')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2' s2'.\n                            r2.r_syntax t x2 m2 ta2 x2' m2' \\<and>\n                            r2.actions_ok s2' t ta2", "case base"], ["proof (state)\nthis:\n  (x2, m2) = (x2', m2')\n\ngoal (2 subgoals):\n 1. (x2, m2) = (x2', m2') \\<Longrightarrow>\n    \\<exists>ta2 x2' m2' s2'.\n       r2.r_syntax t x2 m2 ta2 x2' m2' \\<and> r2.actions_ok s2' t ta2\n 2. \\<And>a b.\n       \\<lbrakk>r2.silent_move t (x2, m2) (a, b);\n        r2.silent_moves t (a, b) (x2', m2')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2' s2'.\n                            r2.r_syntax t x2 m2 ta2 x2' m2' \\<and>\n                            r2.actions_ok s2' t ta2", "from r2'[folded base] s1'[unfolded ex_actions_ok1_conv_ex_actions_ok2[OF tasim]]"], ["proof (chain)\npicking this:\n  r2.r_syntax t x2 m2 ta2 x2'' m2''\n  \\<exists>s2. r2.actions_ok s2 t ta2", "show ?thesis"], ["proof (prove)\nusing this:\n  r2.r_syntax t x2 m2 ta2 x2'' m2''\n  \\<exists>s2. r2.actions_ok s2 t ta2\n\ngoal (1 subgoal):\n 1. \\<exists>ta2 x2' m2' s2'.\n       r2.r_syntax t x2 m2 ta2 x2' m2' \\<and> r2.actions_ok s2' t ta2", "by blast"], ["proof (state)\nthis:\n  \\<exists>ta2 x2' m2' s2'.\n     r2.r_syntax t x2 m2 ta2 x2' m2' \\<and> r2.actions_ok s2' t ta2\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>r2.silent_move t (x2, m2) (a, b);\n        r2.silent_moves t (a, b) (x2', m2')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2' s2'.\n                            r2.r_syntax t x2 m2 ta2 x2' m2' \\<and>\n                            r2.actions_ok s2' t ta2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>r2.silent_move t (x2, m2) (a, b);\n        r2.silent_moves t (a, b) (x2', m2')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2' s2'.\n                            r2.r_syntax t x2 m2 ta2 x2' m2' \\<and>\n                            r2.actions_ok s2' t ta2", "case (step x2''' m2''')"], ["proof (state)\nthis:\n  r2.silent_move t (x2, m2) (x2''', m2''')\n  r2.silent_moves t (x2''', m2''') (x2', m2')\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>r2.silent_move t (x2, m2) (a, b);\n        r2.silent_moves t (a, b) (x2', m2')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2' s2'.\n                            r2.r_syntax t x2 m2 ta2 x2' m2' \\<and>\n                            r2.actions_ok s2' t ta2", "hence \"t \\<turnstile> (x2, m2) -2-\\<epsilon>\\<rightarrow> (x2''', m2''')\""], ["proof (prove)\nusing this:\n  r2.silent_move t (x2, m2) (x2''', m2''')\n  r2.silent_moves t (x2''', m2''') (x2', m2')\n\ngoal (1 subgoal):\n 1. r2.r_syntax t x2 m2 \\<lbrace>\\<rbrace> x2''' m2'''", "by(auto dest: r2.silent_tl)"], ["proof (state)\nthis:\n  r2.r_syntax t x2 m2 \\<lbrace>\\<rbrace> x2''' m2'''\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>r2.silent_move t (x2, m2) (a, b);\n        r2.silent_moves t (a, b) (x2', m2')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2' s2'.\n                            r2.r_syntax t x2 m2 ta2 x2' m2' \\<and>\n                            r2.actions_ok s2' t ta2", "moreover"], ["proof (state)\nthis:\n  r2.r_syntax t x2 m2 \\<lbrace>\\<rbrace> x2''' m2'''\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>r2.silent_move t (x2, m2) (a, b);\n        r2.silent_moves t (a, b) (x2', m2')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2' s2'.\n                            r2.r_syntax t x2 m2 ta2 x2' m2' \\<and>\n                            r2.actions_ok s2' t ta2", "have \"r2.actions_ok (undefined, (undefined, undefined), Map.empty, undefined) t \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r2.actions_ok (undefined, (undefined, undefined), Map.empty, undefined)\n     t \\<lbrace>\\<rbrace>", "by auto"], ["proof (state)\nthis:\n  r2.actions_ok (undefined, (undefined, undefined), Map.empty, undefined) t\n   \\<lbrace>\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>r2.silent_move t (x2, m2) (a, b);\n        r2.silent_moves t (a, b) (x2', m2')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2' s2'.\n                            r2.r_syntax t x2 m2 ta2 x2' m2' \\<and>\n                            r2.actions_ok s2' t ta2", "ultimately"], ["proof (chain)\npicking this:\n  r2.r_syntax t x2 m2 \\<lbrace>\\<rbrace> x2''' m2'''\n  r2.actions_ok (undefined, (undefined, undefined), Map.empty, undefined) t\n   \\<lbrace>\\<rbrace>", "show ?thesis"], ["proof (prove)\nusing this:\n  r2.r_syntax t x2 m2 \\<lbrace>\\<rbrace> x2''' m2'''\n  r2.actions_ok (undefined, (undefined, undefined), Map.empty, undefined) t\n   \\<lbrace>\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<exists>ta2 x2' m2' s2'.\n       r2.r_syntax t x2 m2 ta2 x2' m2' \\<and> r2.actions_ok s2' t ta2", "by-(rule exI conjI|assumption)+"], ["proof (state)\nthis:\n  \\<exists>ta2 x2' m2' s2'.\n     r2.r_syntax t x2 m2 ta2 x2' m2' \\<and> r2.actions_ok s2' t ta2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ta2 x2' m2' s2'.\n     r2.r_syntax t x2 m2 ta2 x2' m2' \\<and> r2.actions_ok s2' t ta2\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s1\\<rangle> \\<wrong>1;\n        wset s1 t = None;\n        \\<And>LT.\n           t \\<turnstile> \\<langle>x, shr s1\\<rangle> LT\n           \\<wrong>1 \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              r1.must_wait s1 t lt\n               (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "hence \"r2.must_sync t x2 m2\""], ["proof (prove)\nusing this:\n  \\<exists>ta2 x2' m2' s2'.\n     r2.r_syntax t x2 m2 ta2 x2' m2' \\<and> r2.actions_ok s2' t ta2\n\ngoal (1 subgoal):\n 1. t \\<turnstile> \\<langle>x2, m2\\<rangle> \\<wrong>2", "unfolding r2.must_sync_def2"], ["proof (prove)\nusing this:\n  \\<exists>ta2 x2' m2' s2'.\n     r2.r_syntax t x2 m2 ta2 x2' m2' \\<and> r2.actions_ok s2' t ta2\n\ngoal (1 subgoal):\n 1. \\<exists>taa x' m' s.\n       r2.r_syntax t x2 m2 taa x' m' \\<and> r2.actions_ok s t taa", "."], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x2, m2\\<rangle> \\<wrong>2\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s1\\<rangle> \\<wrong>1;\n        wset s1 t = None;\n        \\<And>LT.\n           t \\<turnstile> \\<langle>x, shr s1\\<rangle> LT\n           \\<wrong>1 \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              r1.must_wait s1 t lt\n               (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "}"], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x2, m2\\<rangle> \\<wrong>2\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s1\\<rangle> \\<wrong>1;\n        wset s1 t = None;\n        \\<And>LT.\n           t \\<turnstile> \\<langle>x, shr s1\\<rangle> LT\n           \\<wrong>1 \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              r1.must_wait s1 t lt\n               (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "moreover"], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x2, m2\\<rangle> \\<wrong>2\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s1\\<rangle> \\<wrong>1;\n        wset s1 t = None;\n        \\<And>LT.\n           t \\<turnstile> \\<langle>x, shr s1\\<rangle> LT\n           \\<wrong>1 \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              r1.must_wait s1 t lt\n               (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "{"], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x2, m2\\<rangle> \\<wrong>2\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s1\\<rangle> \\<wrong>1;\n        wset s1 t = None;\n        \\<And>LT.\n           t \\<turnstile> \\<langle>x, shr s1\\<rangle> LT\n           \\<wrong>1 \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              r1.must_wait s1 t lt\n               (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "fix LT"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s1\\<rangle> \\<wrong>1;\n        wset s1 t = None;\n        \\<And>LT.\n           t \\<turnstile> \\<langle>x, shr s1\\<rangle> LT\n           \\<wrong>1 \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              r1.must_wait s1 t lt\n               (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "assume \"r2.can_sync t x2 m2 LT\""], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x2, m2\\<rangle> LT \\<wrong>2\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s1\\<rangle> \\<wrong>1;\n        wset s1 t = None;\n        \\<And>LT.\n           t \\<turnstile> \\<langle>x, shr s1\\<rangle> LT\n           \\<wrong>1 \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              r1.must_wait s1 t lt\n               (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "then"], ["proof (chain)\npicking this:\n  t \\<turnstile> \\<langle>x2, m2\\<rangle> LT \\<wrong>2", "obtain ta2 x2' m2' where r2: \"t \\<turnstile> (x2, m2) -2-ta2\\<rightarrow> (x2', m2')\"\n          and LT: \"LT = collect_locks \\<lbrace>ta2\\<rbrace>\\<^bsub>l\\<^esub> <+> collect_cond_actions \\<lbrace>ta2\\<rbrace>\\<^bsub>c\\<^esub> <+> collect_interrupts \\<lbrace>ta2\\<rbrace>\\<^bsub>i\\<^esub>\""], ["proof (prove)\nusing this:\n  t \\<turnstile> \\<langle>x2, m2\\<rangle> LT \\<wrong>2\n\ngoal (1 subgoal):\n 1. (\\<And>ta2 x2' m2'.\n        \\<lbrakk>r2.r_syntax t x2 m2 ta2 x2' m2';\n         LT = collect_waits ta2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim: r2.can_syncE)"], ["proof (state)\nthis:\n  r2.r_syntax t x2 m2 ta2 x2' m2'\n  LT = collect_waits ta2\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s1\\<rangle> \\<wrong>1;\n        wset s1 t = None;\n        \\<And>LT.\n           t \\<turnstile> \\<langle>x, shr s1\\<rangle> LT\n           \\<wrong>1 \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              r1.must_wait s1 t lt\n               (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "from \\<open>wset s1 t = None\\<close> \\<open>thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>\\<close> \\<open>ts2' t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  wset s1 t = None\n  thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>\n  ts2' t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>", "have \"\\<not> r2.silent_move t (x2, m2) (x2', m2')\""], ["proof (prove)\nusing this:\n  wset s1 t = None\n  thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>\n  ts2' t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<not> r2.silent_move t (x2, m2) (x2', m2')", "proof(rule no_\\<tau>)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x' m'.\n       r1.silent_move t (x1, shr s1) (x', m') \\<Longrightarrow> False", "fix x1' m1'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x' m'.\n       r1.silent_move t (x1, shr s1) (x', m') \\<Longrightarrow> False", "assume \"r1.silent_move t (x1, shr s1) (x1', m1')\""], ["proof (state)\nthis:\n  r1.silent_move t (x1, shr s1) (x1', m1')\n\ngoal (1 subgoal):\n 1. \\<And>x' m'.\n       r1.silent_move t (x1, shr s1) (x', m') \\<Longrightarrow> False", "hence \"t \\<turnstile> (x1, shr s1) -1-\\<epsilon>\\<rightarrow> (x1', m1')\""], ["proof (prove)\nusing this:\n  r1.silent_move t (x1, shr s1) (x1', m1')\n\ngoal (1 subgoal):\n 1. r1.r_syntax t x1 (shr s1) \\<lbrace>\\<rbrace> x1' m1'", "by(auto dest: r1.silent_tl)"], ["proof (state)\nthis:\n  r1.r_syntax t x1 (shr s1) \\<lbrace>\\<rbrace> x1' m1'\n\ngoal (1 subgoal):\n 1. \\<And>x' m'.\n       r1.silent_move t (x1, shr s1) (x', m') \\<Longrightarrow> False", "hence \"r1.can_sync t x1 (shr s1) {}\""], ["proof (prove)\nusing this:\n  r1.r_syntax t x1 (shr s1) \\<lbrace>\\<rbrace> x1' m1'\n\ngoal (1 subgoal):\n 1. t \\<turnstile> \\<langle>x1, shr s1\\<rangle> {} \\<wrong>1", "by(auto intro: r1.can_syncI simp add: collect_locks_def collect_interrupts_def)"], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x1, shr s1\\<rangle> {} \\<wrong>1\n\ngoal (1 subgoal):\n 1. \\<And>x' m'.\n       r1.silent_move t (x1, shr s1) (x', m') \\<Longrightarrow> False", "with csmw[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>lt\\<in>{}.\n     r1.must_wait s1 t lt (r1.deadlocked s1 \\<union> r1.final_threads s1)\n  t \\<turnstile> \\<langle>x1, shr s1\\<rangle> {} \\<wrong>1", "show False"], ["proof (prove)\nusing this:\n  \\<exists>lt\\<in>{}.\n     r1.must_wait s1 t lt (r1.deadlocked s1 \\<union> r1.final_threads s1)\n  t \\<turnstile> \\<langle>x1, shr s1\\<rangle> {} \\<wrong>1\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> r2.silent_move t (x2, m2) (x2', m2')\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s1\\<rangle> \\<wrong>1;\n        wset s1 t = None;\n        \\<And>LT.\n           t \\<turnstile> \\<langle>x, shr s1\\<rangle> LT\n           \\<wrong>1 \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              r1.must_wait s1 t lt\n               (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "with r2"], ["proof (chain)\npicking this:\n  r2.r_syntax t x2 m2 ta2 x2' m2'\n  \\<not> r2.silent_move t (x2, m2) (x2', m2')", "have \"\\<not> \\<tau>move2 (x2, m2) ta2 (x2', m2')\""], ["proof (prove)\nusing this:\n  r2.r_syntax t x2 m2 ta2 x2' m2'\n  \\<not> r2.silent_move t (x2, m2) (x2', m2')\n\ngoal (1 subgoal):\n 1. \\<not> \\<tau>move2 (x2, m2) ta2 (x2', m2')", "by auto"], ["proof (state)\nthis:\n  \\<not> \\<tau>move2 (x2, m2) ta2 (x2', m2')\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s1\\<rangle> \\<wrong>1;\n        wset s1 t = None;\n        \\<And>LT.\n           t \\<turnstile> \\<langle>x, shr s1\\<rangle> LT\n           \\<wrong>1 \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              r1.must_wait s1 t lt\n               (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "from simulation2[OF bisim r2 this]"], ["proof (chain)\npicking this:\n  \\<exists>s1' s1'' tl1.\n     r1.silent_moves t (x1, shr s1) s1' \\<and>\n     t \\<turnstile> s1' -1-tl1\\<rightarrow> s1'' \\<and>\n     \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n     t \\<turnstile> s1'' \\<approx> (x2', m2') \\<and> tl1 \\<sim>m ta2", "obtain x1' m1' x1'' m1'' ta1\n          where \\<tau>r1: \"r1.silent_moves t (x1, shr s1) (x1', m1')\"\n          and r1: \"t \\<turnstile> (x1', m1') -1-ta1\\<rightarrow> (x1'', m1'')\"\n          and n\\<tau>1: \"\\<not> \\<tau>move1 (x1', m1') ta1 (x1'', m1'')\"\n          and bisim': \"t \\<turnstile> (x1'', m1'') \\<approx> (x2', m2')\"\n          and tlsim: \"ta1 \\<sim>m ta2\""], ["proof (prove)\nusing this:\n  \\<exists>s1' s1'' tl1.\n     r1.silent_moves t (x1, shr s1) s1' \\<and>\n     t \\<turnstile> s1' -1-tl1\\<rightarrow> s1'' \\<and>\n     \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n     t \\<turnstile> s1'' \\<approx> (x2', m2') \\<and> tl1 \\<sim>m ta2\n\ngoal (1 subgoal):\n 1. (\\<And>x1' m1' ta1 x1'' m1''.\n        \\<lbrakk>r1.silent_moves t (x1, shr s1) (x1', m1');\n         r1.r_syntax t x1' m1' ta1 x1'' m1'';\n         \\<not> \\<tau>move1 (x1', m1') ta1 (x1'', m1'');\n         t \\<turnstile> (x1'', m1'') \\<approx> (x2', m2');\n         ta1 \\<sim>m ta2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  r1.silent_moves t (x1, shr s1) (x1', m1')\n  r1.r_syntax t x1' m1' ta1 x1'' m1''\n  \\<not> \\<tau>move1 (x1', m1') ta1 (x1'', m1'')\n  t \\<turnstile> (x1'', m1'') \\<approx> (x2', m2')\n  ta1 \\<sim>m ta2\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s1\\<rangle> \\<wrong>1;\n        wset s1 t = None;\n        \\<And>LT.\n           t \\<turnstile> \\<langle>x, shr s1\\<rangle> LT\n           \\<wrong>1 \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              r1.must_wait s1 t lt\n               (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "from \\<tau>r1"], ["proof (chain)\npicking this:\n  r1.silent_moves t (x1, shr s1) (x1', m1')", "obtain [simp]: \"x1' = x1\" \"m1' = shr s1\""], ["proof (prove)\nusing this:\n  r1.silent_moves t (x1, shr s1) (x1', m1')\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>x1' = x1; m1' = shr s1\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(cases rule: converse_rtranclpE2[consumes 1, case_names refl step])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>x1' = x1; m1' = shr s1\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     (x1, shr s1) = (x1', m1')\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a b.\n       \\<lbrakk>\\<lbrakk>x1' = x1; m1' = shr s1\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        r1.silent_move t (x1, shr s1) (a, b);\n        r1.silent_moves t (a, b) (x1', m1')\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (step X M)"], ["proof (state)\nthis:\n  r1.silent_move t (x1, shr s1) (X, M)\n  r1.silent_moves t (X, M) (x1', m1')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>x1' = x1; m1' = shr s1\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     (x1, shr s1) = (x1', m1')\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a b.\n       \\<lbrakk>\\<lbrakk>x1' = x1; m1' = shr s1\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        r1.silent_move t (x1, shr s1) (a, b);\n        r1.silent_moves t (a, b) (x1', m1')\\<rbrakk>\n       \\<Longrightarrow> thesis", "from \\<open>r1.silent_move t (x1, shr s1) (X, M)\\<close>"], ["proof (chain)\npicking this:\n  r1.silent_move t (x1, shr s1) (X, M)", "have \"t \\<turnstile> (x1, shr s1) -1-\\<epsilon>\\<rightarrow> (X, M)\""], ["proof (prove)\nusing this:\n  r1.silent_move t (x1, shr s1) (X, M)\n\ngoal (1 subgoal):\n 1. r1.r_syntax t x1 (shr s1) \\<lbrace>\\<rbrace> X M", "by(auto dest: r1.silent_tl)"], ["proof (state)\nthis:\n  r1.r_syntax t x1 (shr s1) \\<lbrace>\\<rbrace> X M\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>x1' = x1; m1' = shr s1\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     (x1, shr s1) = (x1', m1')\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a b.\n       \\<lbrakk>\\<lbrakk>x1' = x1; m1' = shr s1\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        r1.silent_move t (x1, shr s1) (a, b);\n        r1.silent_moves t (a, b) (x1', m1')\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"r1.can_sync t x1 (shr s1) {}\""], ["proof (prove)\nusing this:\n  r1.r_syntax t x1 (shr s1) \\<lbrace>\\<rbrace> X M\n\ngoal (1 subgoal):\n 1. t \\<turnstile> \\<langle>x1, shr s1\\<rangle> {} \\<wrong>1", "by(auto intro: r1.can_syncI simp add: collect_locks_def collect_interrupts_def)"], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x1, shr s1\\<rangle> {} \\<wrong>1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>x1' = x1; m1' = shr s1\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     (x1, shr s1) = (x1', m1')\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a b.\n       \\<lbrakk>\\<lbrakk>x1' = x1; m1' = shr s1\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        r1.silent_move t (x1, shr s1) (a, b);\n        r1.silent_moves t (a, b) (x1', m1')\\<rbrakk>\n       \\<Longrightarrow> thesis", "with csmw[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>lt\\<in>{}.\n     r1.must_wait s1 t lt (r1.deadlocked s1 \\<union> r1.final_threads s1)\n  t \\<turnstile> \\<langle>x1, shr s1\\<rangle> {} \\<wrong>1", "have False"], ["proof (prove)\nusing this:\n  \\<exists>lt\\<in>{}.\n     r1.must_wait s1 t lt (r1.deadlocked s1 \\<union> r1.final_threads s1)\n  t \\<turnstile> \\<langle>x1, shr s1\\<rangle> {} \\<wrong>1\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>x1' = x1; m1' = shr s1\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     (x1, shr s1) = (x1', m1')\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a b.\n       \\<lbrakk>\\<lbrakk>x1' = x1; m1' = shr s1\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        r1.silent_move t (x1, shr s1) (a, b);\n        r1.silent_moves t (a, b) (x1', m1')\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>x1' = x1; m1' = shr s1\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     (x1, shr s1) = (x1', m1')\\<rbrakk>\n    \\<Longrightarrow> thesis", "qed blast"], ["proof (state)\nthis:\n  x1' = x1\n  m1' = shr s1\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s1\\<rangle> \\<wrong>1;\n        wset s1 t = None;\n        \\<And>LT.\n           t \\<turnstile> \\<langle>x, shr s1\\<rangle> LT\n           \\<wrong>1 \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              r1.must_wait s1 t lt\n               (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "from tlsim LT"], ["proof (chain)\npicking this:\n  ta1 \\<sim>m ta2\n  LT = collect_waits ta2", "have \"LT = collect_locks \\<lbrace>ta1\\<rbrace>\\<^bsub>l\\<^esub> <+> collect_cond_actions \\<lbrace>ta1\\<rbrace>\\<^bsub>c\\<^esub> <+> collect_interrupts \\<lbrace>ta1\\<rbrace>\\<^bsub>i\\<^esub>\""], ["proof (prove)\nusing this:\n  ta1 \\<sim>m ta2\n  LT = collect_waits ta2\n\ngoal (1 subgoal):\n 1. LT = collect_waits ta1", "by(auto simp add: ta_bisim_def)"], ["proof (state)\nthis:\n  LT = collect_waits ta1\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s1\\<rangle> \\<wrong>1;\n        wset s1 t = None;\n        \\<And>LT.\n           t \\<turnstile> \\<langle>x, shr s1\\<rangle> LT\n           \\<wrong>1 \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              r1.must_wait s1 t lt\n               (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "with r1"], ["proof (chain)\npicking this:\n  r1.r_syntax t x1' m1' ta1 x1'' m1''\n  LT = collect_waits ta1", "have \"r1.can_sync t x1 (shr s1) LT\""], ["proof (prove)\nusing this:\n  r1.r_syntax t x1' m1' ta1 x1'' m1''\n  LT = collect_waits ta1\n\ngoal (1 subgoal):\n 1. t \\<turnstile> \\<langle>x1, shr s1\\<rangle> LT \\<wrong>1", "by(auto intro: r1.can_syncI)"], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x1, shr s1\\<rangle> LT \\<wrong>1\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s1\\<rangle> \\<wrong>1;\n        wset s1 t = None;\n        \\<And>LT.\n           t \\<turnstile> \\<langle>x, shr s1\\<rangle> LT\n           \\<wrong>1 \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              r1.must_wait s1 t lt\n               (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "from csmw[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>lt\\<in>LT.\n     r1.must_wait s1 t lt (r1.deadlocked s1 \\<union> r1.final_threads s1)", "obtain lt \n          where lt: \"lt \\<in> LT\" and mw: \"r1.must_wait s1 t lt (r1.deadlocked s1 \\<union> r1.final_threads s1)\""], ["proof (prove)\nusing this:\n  \\<exists>lt\\<in>LT.\n     r1.must_wait s1 t lt (r1.deadlocked s1 \\<union> r1.final_threads s1)\n\ngoal (1 subgoal):\n 1. (\\<And>lt.\n        \\<lbrakk>lt \\<in> LT;\n         r1.must_wait s1 t lt\n          (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  lt \\<in> LT\n  r1.must_wait s1 t lt (r1.deadlocked s1 \\<union> r1.final_threads s1)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s1\\<rangle> \\<wrong>1;\n        wset s1 t = None;\n        \\<And>LT.\n           t \\<turnstile> \\<langle>x, shr s1\\<rangle> LT\n           \\<wrong>1 \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              r1.must_wait s1 t lt\n               (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "have subset: \"r1.deadlocked s1 \\<union> r1.final_threads s1 \\<subseteq> r1.deadlocked s1 \\<union> r2.deadlocked s2 \\<union> r2.final_threads ?s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r1.deadlocked s1 \\<union> r1.final_threads s1\n    \\<subseteq> r1.deadlocked s1 \\<union> r2.deadlocked s2 \\<union>\n                r2.final_threads (ls2, (ts2', m2), ws2, is2)", "by(auto dest: fin')"], ["proof (state)\nthis:\n  r1.deadlocked s1 \\<union> r1.final_threads s1\n  \\<subseteq> r1.deadlocked s1 \\<union> r2.deadlocked s2 \\<union>\n              r2.final_threads (ls2, (ts2', m2), ws2, is2)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s1\\<rangle> \\<wrong>1;\n        wset s1 t = None;\n        \\<And>LT.\n           t \\<turnstile> \\<langle>x, shr s1\\<rangle> LT\n           \\<wrong>1 \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              r1.must_wait s1 t lt\n               (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "from mw"], ["proof (chain)\npicking this:\n  r1.must_wait s1 t lt (r1.deadlocked s1 \\<union> r1.final_threads s1)", "have \"r2.must_wait ?s2 t lt (r1.deadlocked s1 \\<union> r2.deadlocked ?s2 \\<union> r2.final_threads ?s2)\""], ["proof (prove)\nusing this:\n  r1.must_wait s1 t lt (r1.deadlocked s1 \\<union> r1.final_threads s1)\n\ngoal (1 subgoal):\n 1. r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n     (r1.deadlocked s1 \\<union>\n      r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n      r2.final_threads (ls2, (ts2', m2), ws2, is2))", "proof(cases rule: r1.must_wait_elims)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>l t'.\n       \\<lbrakk>lt = Inl l; has_lock (locks s1 $ l) t'; t' \\<noteq> t;\n        t' \\<in> r1.deadlocked s1 \\<union> r1.final_threads s1\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (r1.deadlocked s1 \\<union>\n                           r2.deadlocked\n                            (ls2, (ts2', m2), ws2, is2) \\<union>\n                           r2.final_threads (ls2, (ts2', m2), ws2, is2))\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); r1.not_final_thread s1 t';\n        t' \\<in> r1.deadlocked s1 \\<union> r1.final_threads s1\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (r1.deadlocked s1 \\<union>\n                           r2.deadlocked\n                            (ls2, (ts2', m2), ws2, is2) \\<union>\n                           r2.final_threads (ls2, (ts2', m2), ws2, is2))\n 3. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        r1.all_final_except s1\n         (r1.deadlocked s1 \\<union> r1.final_threads s1);\n        t' \\<notin> interrupts s1\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (r1.deadlocked s1 \\<union>\n                           r2.deadlocked\n                            (ls2, (ts2', m2), ws2, is2) \\<union>\n                           r2.final_threads (ls2, (ts2', m2), ws2, is2))", "case lock"], ["proof (state)\nthis:\n  lt = Inl l_\n  has_lock (locks s1 $ l_) t'_\n  t'_ \\<noteq> t\n  t'_ \\<in> r1.deadlocked s1 \\<union> r1.final_threads s1\n\ngoal (3 subgoals):\n 1. \\<And>l t'.\n       \\<lbrakk>lt = Inl l; has_lock (locks s1 $ l) t'; t' \\<noteq> t;\n        t' \\<in> r1.deadlocked s1 \\<union> r1.final_threads s1\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (r1.deadlocked s1 \\<union>\n                           r2.deadlocked\n                            (ls2, (ts2', m2), ws2, is2) \\<union>\n                           r2.final_threads (ls2, (ts2', m2), ws2, is2))\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); r1.not_final_thread s1 t';\n        t' \\<in> r1.deadlocked s1 \\<union> r1.final_threads s1\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (r1.deadlocked s1 \\<union>\n                           r2.deadlocked\n                            (ls2, (ts2', m2), ws2, is2) \\<union>\n                           r2.final_threads (ls2, (ts2', m2), ws2, is2))\n 3. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        r1.all_final_except s1\n         (r1.deadlocked s1 \\<union> r1.final_threads s1);\n        t' \\<notin> interrupts s1\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (r1.deadlocked s1 \\<union>\n                           r2.deadlocked\n                            (ls2, (ts2', m2), ws2, is2) \\<union>\n                           r2.final_threads (ls2, (ts2', m2), ws2, is2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  lt = Inl l_\n  has_lock (locks s1 $ l_) t'_\n  t'_ \\<noteq> t\n  t'_ \\<in> r1.deadlocked s1 \\<union> r1.final_threads s1\n\ngoal (1 subgoal):\n 1. r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n     (r1.deadlocked s1 \\<union>\n      r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n      r2.final_threads (ls2, (ts2', m2), ws2, is2))", "by(auto simp add: mbisim_eqs dest!: fin')"], ["proof (state)\nthis:\n  r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n   (r1.deadlocked s1 \\<union>\n    r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n    r2.final_threads (ls2, (ts2', m2), ws2, is2))\n\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); r1.not_final_thread s1 t';\n        t' \\<in> r1.deadlocked s1 \\<union> r1.final_threads s1\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (r1.deadlocked s1 \\<union>\n                           r2.deadlocked\n                            (ls2, (ts2', m2), ws2, is2) \\<union>\n                           r2.final_threads (ls2, (ts2', m2), ws2, is2))\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        r1.all_final_except s1\n         (r1.deadlocked s1 \\<union> r1.final_threads s1);\n        t' \\<notin> interrupts s1\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (r1.deadlocked s1 \\<union>\n                           r2.deadlocked\n                            (ls2, (ts2', m2), ws2, is2) \\<union>\n                           r2.final_threads (ls2, (ts2', m2), ws2, is2))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); r1.not_final_thread s1 t';\n        t' \\<in> r1.deadlocked s1 \\<union> r1.final_threads s1\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (r1.deadlocked s1 \\<union>\n                           r2.deadlocked\n                            (ls2, (ts2', m2), ws2, is2) \\<union>\n                           r2.final_threads (ls2, (ts2', m2), ws2, is2))\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        r1.all_final_except s1\n         (r1.deadlocked s1 \\<union> r1.final_threads s1);\n        t' \\<notin> interrupts s1\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (r1.deadlocked s1 \\<union>\n                           r2.deadlocked\n                            (ls2, (ts2', m2), ws2, is2) \\<union>\n                           r2.final_threads (ls2, (ts2', m2), ws2, is2))", "case (join t')"], ["proof (state)\nthis:\n  lt = Inr (Inl t')\n  r1.not_final_thread s1 t'\n  t' \\<in> r1.deadlocked s1 \\<union> r1.final_threads s1\n\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); r1.not_final_thread s1 t';\n        t' \\<in> r1.deadlocked s1 \\<union> r1.final_threads s1\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (r1.deadlocked s1 \\<union>\n                           r2.deadlocked\n                            (ls2, (ts2', m2), ws2, is2) \\<union>\n                           r2.final_threads (ls2, (ts2', m2), ws2, is2))\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        r1.all_final_except s1\n         (r1.deadlocked s1 \\<union> r1.final_threads s1);\n        t' \\<notin> interrupts s1\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (r1.deadlocked s1 \\<union>\n                           r2.deadlocked\n                            (ls2, (ts2', m2), ws2, is2) \\<union>\n                           r2.final_threads (ls2, (ts2', m2), ws2, is2))", "from \\<open>r1.not_final_thread s1 t'\\<close>"], ["proof (chain)\npicking this:\n  r1.not_final_thread s1 t'", "obtain x1 ln\n            where \"thr s1 t' = \\<lfloor>(x1, ln)\\<rfloor>\""], ["proof (prove)\nusing this:\n  r1.not_final_thread s1 t'\n\ngoal (1 subgoal):\n 1. (\\<And>x1 ln.\n        thr s1 t' = \\<lfloor>(x1, ln)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  thr s1 t' = \\<lfloor>(x1, ln)\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); r1.not_final_thread s1 t';\n        t' \\<in> r1.deadlocked s1 \\<union> r1.final_threads s1\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (r1.deadlocked s1 \\<union>\n                           r2.deadlocked\n                            (ls2, (ts2', m2), ws2, is2) \\<union>\n                           r2.final_threads (ls2, (ts2', m2), ws2, is2))\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        r1.all_final_except s1\n         (r1.deadlocked s1 \\<union> r1.final_threads s1);\n        t' \\<notin> interrupts s1\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (r1.deadlocked s1 \\<union>\n                           r2.deadlocked\n                            (ls2, (ts2', m2), ws2, is2) \\<union>\n                           r2.final_threads (ls2, (ts2', m2), ws2, is2))", "with mbisim"], ["proof (chain)\npicking this:\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n  thr s1 t' = \\<lfloor>(x1, ln)\\<rfloor>", "obtain x2 where \"ts2' t' = \\<lfloor>(x2, ln)\\<rfloor>\" \"t' \\<turnstile> (x1, shr s1) \\<approx> (x2, m2)\""], ["proof (prove)\nusing this:\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n  thr s1 t' = \\<lfloor>(x1, ln)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>x2.\n        \\<lbrakk>ts2' t' = \\<lfloor>(x2, ln)\\<rfloor>;\n         t' \\<turnstile> (x1, shr s1) \\<approx> (x2, m2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: mbisim_thrD1)"], ["proof (state)\nthis:\n  ts2' t' = \\<lfloor>(x2, ln)\\<rfloor>\n  t' \\<turnstile> (x1, shr s1) \\<approx> (x2, m2)\n\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); r1.not_final_thread s1 t';\n        t' \\<in> r1.deadlocked s1 \\<union> r1.final_threads s1\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (r1.deadlocked s1 \\<union>\n                           r2.deadlocked\n                            (ls2, (ts2', m2), ws2, is2) \\<union>\n                           r2.final_threads (ls2, (ts2', m2), ws2, is2))\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        r1.all_final_except s1\n         (r1.deadlocked s1 \\<union> r1.final_threads s1);\n        t' \\<notin> interrupts s1\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (r1.deadlocked s1 \\<union>\n                           r2.deadlocked\n                            (ls2, (ts2', m2), ws2, is2) \\<union>\n                           r2.final_threads (ls2, (ts2', m2), ws2, is2))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n     (r1.deadlocked s1 \\<union>\n      r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n      r2.final_threads (ls2, (ts2', m2), ws2, is2))", "proof(cases \"wset s1 t' = None \\<and> ln = no_wait_locks\")"], ["proof (state)\ngoal (2 subgoals):\n 1. wset s1 t' = None \\<and> ln = no_wait_locks \\<Longrightarrow>\n    r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n     (r1.deadlocked s1 \\<union>\n      r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n      r2.final_threads (ls2, (ts2', m2), ws2, is2))\n 2. \\<not> (wset s1 t' = None \\<and> ln = no_wait_locks) \\<Longrightarrow>\n    r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n     (r1.deadlocked s1 \\<union>\n      r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n      r2.final_threads (ls2, (ts2', m2), ws2, is2))", "case False"], ["proof (state)\nthis:\n  \\<not> (wset s1 t' = None \\<and> ln = no_wait_locks)\n\ngoal (2 subgoals):\n 1. wset s1 t' = None \\<and> ln = no_wait_locks \\<Longrightarrow>\n    r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n     (r1.deadlocked s1 \\<union>\n      r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n      r2.final_threads (ls2, (ts2', m2), ws2, is2))\n 2. \\<not> (wset s1 t' = None \\<and> ln = no_wait_locks) \\<Longrightarrow>\n    r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n     (r1.deadlocked s1 \\<union>\n      r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n      r2.final_threads (ls2, (ts2', m2), ws2, is2))", "with \\<open>r1.not_final_thread s1 t'\\<close> \\<open>thr s1 t' = \\<lfloor>(x1, ln)\\<rfloor>\\<close> \\<open>ts2' t' = \\<lfloor>(x2, ln)\\<rfloor>\\<close> \\<open>lt = Inr (Inl t')\\<close> join"], ["proof (chain)\npicking this:\n  r1.not_final_thread s1 t'\n  thr s1 t' = \\<lfloor>(x1, ln)\\<rfloor>\n  ts2' t' = \\<lfloor>(x2, ln)\\<rfloor>\n  lt = Inr (Inl t')\n  lt = Inr (Inl t')\n  r1.not_final_thread s1 t'\n  t' \\<in> r1.deadlocked s1 \\<union> r1.final_threads s1\n  \\<not> (wset s1 t' = None \\<and> ln = no_wait_locks)", "show ?thesis"], ["proof (prove)\nusing this:\n  r1.not_final_thread s1 t'\n  thr s1 t' = \\<lfloor>(x1, ln)\\<rfloor>\n  ts2' t' = \\<lfloor>(x2, ln)\\<rfloor>\n  lt = Inr (Inl t')\n  lt = Inr (Inl t')\n  r1.not_final_thread s1 t'\n  t' \\<in> r1.deadlocked s1 \\<union> r1.final_threads s1\n  \\<not> (wset s1 t' = None \\<and> ln = no_wait_locks)\n\ngoal (1 subgoal):\n 1. r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n     (r1.deadlocked s1 \\<union>\n      r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n      r2.final_threads (ls2, (ts2', m2), ws2, is2))", "by(auto simp add: mbisim_eqs r2.not_final_thread_iff r1.final_thread_def)"], ["proof (state)\nthis:\n  r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n   (r1.deadlocked s1 \\<union>\n    r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n    r2.final_threads (ls2, (ts2', m2), ws2, is2))\n\ngoal (1 subgoal):\n 1. wset s1 t' = None \\<and> ln = no_wait_locks \\<Longrightarrow>\n    r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n     (r1.deadlocked s1 \\<union>\n      r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n      r2.final_threads (ls2, (ts2', m2), ws2, is2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. wset s1 t' = None \\<and> ln = no_wait_locks \\<Longrightarrow>\n    r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n     (r1.deadlocked s1 \\<union>\n      r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n      r2.final_threads (ls2, (ts2', m2), ws2, is2))", "case True"], ["proof (state)\nthis:\n  wset s1 t' = None \\<and> ln = no_wait_locks\n\ngoal (1 subgoal):\n 1. wset s1 t' = None \\<and> ln = no_wait_locks \\<Longrightarrow>\n    r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n     (r1.deadlocked s1 \\<union>\n      r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n      r2.final_threads (ls2, (ts2', m2), ws2, is2))", "with \\<open>r1.not_final_thread s1 t'\\<close> \\<open>thr s1 t' = \\<lfloor>(x1, ln)\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  r1.not_final_thread s1 t'\n  thr s1 t' = \\<lfloor>(x1, ln)\\<rfloor>\n  wset s1 t' = None \\<and> ln = no_wait_locks", "have \"\\<not> final1 x1\""], ["proof (prove)\nusing this:\n  r1.not_final_thread s1 t'\n  thr s1 t' = \\<lfloor>(x1, ln)\\<rfloor>\n  wset s1 t' = None \\<and> ln = no_wait_locks\n\ngoal (1 subgoal):\n 1. \\<not> final1 x1", "by(cases) auto"], ["proof (state)\nthis:\n  \\<not> final1 x1\n\ngoal (1 subgoal):\n 1. wset s1 t' = None \\<and> ln = no_wait_locks \\<Longrightarrow>\n    r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n     (r1.deadlocked s1 \\<union>\n      r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n      r2.final_threads (ls2, (ts2', m2), ws2, is2))", "with join \\<open>thr s1 t' = \\<lfloor>(x1, ln)\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  lt = Inr (Inl t')\n  r1.not_final_thread s1 t'\n  t' \\<in> r1.deadlocked s1 \\<union> r1.final_threads s1\n  thr s1 t' = \\<lfloor>(x1, ln)\\<rfloor>\n  \\<not> final1 x1", "have \"t' \\<in> r1.deadlocked s1\""], ["proof (prove)\nusing this:\n  lt = Inr (Inl t')\n  r1.not_final_thread s1 t'\n  t' \\<in> r1.deadlocked s1 \\<union> r1.final_threads s1\n  thr s1 t' = \\<lfloor>(x1, ln)\\<rfloor>\n  \\<not> final1 x1\n\ngoal (1 subgoal):\n 1. t' \\<in> r1.deadlocked s1", "by(auto simp add: r1.final_thread_def)"], ["proof (state)\nthis:\n  t' \\<in> r1.deadlocked s1\n\ngoal (1 subgoal):\n 1. wset s1 t' = None \\<and> ln = no_wait_locks \\<Longrightarrow>\n    r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n     (r1.deadlocked s1 \\<union>\n      r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n      r2.final_threads (ls2, (ts2', m2), ws2, is2))", "have \"\\<not> final2 x2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> final2 x2", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. final2 x2 \\<Longrightarrow> False", "assume \"final2 x2\""], ["proof (state)\nthis:\n  final2 x2\n\ngoal (1 subgoal):\n 1. final2 x2 \\<Longrightarrow> False", "with final2_simulation[OF \\<open>t' \\<turnstile> (x1, shr s1) \\<approx> (x2, m2)\\<close>]"], ["proof (chain)\npicking this:\n  case (x2, m2) of (x2, m) \\<Rightarrow> final2 x2 \\<Longrightarrow>\n  \\<exists>s1'.\n     r1.silent_moves t' (x1, shr s1) s1' \\<and>\n     t' \\<turnstile> s1' \\<approx> (x2, m2) \\<and>\n     (case s1' of (x1, m) \\<Rightarrow> final1 x1)\n  final2 x2", "obtain x1' m1' where \"r1.silent_moves t' (x1, shr s1) (x1', m1')\"\n                and \"t' \\<turnstile> (x1', m1') \\<approx> (x2, m2)\" \"final1 x1'\""], ["proof (prove)\nusing this:\n  case (x2, m2) of (x2, m) \\<Rightarrow> final2 x2 \\<Longrightarrow>\n  \\<exists>s1'.\n     r1.silent_moves t' (x1, shr s1) s1' \\<and>\n     t' \\<turnstile> s1' \\<approx> (x2, m2) \\<and>\n     (case s1' of (x1, m) \\<Rightarrow> final1 x1)\n  final2 x2\n\ngoal (1 subgoal):\n 1. (\\<And>x1' m1'.\n        \\<lbrakk>r1.silent_moves t' (x1, shr s1) (x1', m1');\n         t' \\<turnstile> (x1', m1') \\<approx> (x2, m2); final1 x1'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  r1.silent_moves t' (x1, shr s1) (x1', m1')\n  t' \\<turnstile> (x1', m1') \\<approx> (x2, m2)\n  final1 x1'\n\ngoal (1 subgoal):\n 1. final2 x2 \\<Longrightarrow> False", "from \\<open>r1.silent_moves t' (x1, shr s1) (x1', m1')\\<close>"], ["proof (chain)\npicking this:\n  r1.silent_moves t' (x1, shr s1) (x1', m1')", "have \"x1' = x1\""], ["proof (prove)\nusing this:\n  r1.silent_moves t' (x1, shr s1) (x1', m1')\n\ngoal (1 subgoal):\n 1. x1' = x1", "proof(cases rule: converse_rtranclpE2[consumes 1, case_names refl step])"], ["proof (state)\ngoal (2 subgoals):\n 1. (x1, shr s1) = (x1', m1') \\<Longrightarrow> x1' = x1\n 2. \\<And>a b.\n       \\<lbrakk>r1.silent_move t' (x1, shr s1) (a, b);\n        r1.silent_moves t' (a, b) (x1', m1')\\<rbrakk>\n       \\<Longrightarrow> x1' = x1", "case (step x1'' m1'')"], ["proof (state)\nthis:\n  r1.silent_move t' (x1, shr s1) (x1'', m1'')\n  r1.silent_moves t' (x1'', m1'') (x1', m1')\n\ngoal (2 subgoals):\n 1. (x1, shr s1) = (x1', m1') \\<Longrightarrow> x1' = x1\n 2. \\<And>a b.\n       \\<lbrakk>r1.silent_move t' (x1, shr s1) (a, b);\n        r1.silent_moves t' (a, b) (x1', m1')\\<rbrakk>\n       \\<Longrightarrow> x1' = x1", "from \\<open>r1.silent_move t' (x1, shr s1) (x1'', m1'')\\<close>"], ["proof (chain)\npicking this:\n  r1.silent_move t' (x1, shr s1) (x1'', m1'')", "have \"t' \\<turnstile> (x1, shr s1) -1-\\<epsilon>\\<rightarrow> (x1'', m1'')\""], ["proof (prove)\nusing this:\n  r1.silent_move t' (x1, shr s1) (x1'', m1'')\n\ngoal (1 subgoal):\n 1. r1.r_syntax t' x1 (shr s1) \\<lbrace>\\<rbrace> x1'' m1''", "by(auto dest: r1.silent_tl)"], ["proof (state)\nthis:\n  r1.r_syntax t' x1 (shr s1) \\<lbrace>\\<rbrace> x1'' m1''\n\ngoal (2 subgoals):\n 1. (x1, shr s1) = (x1', m1') \\<Longrightarrow> x1' = x1\n 2. \\<And>a b.\n       \\<lbrakk>r1.silent_move t' (x1, shr s1) (a, b);\n        r1.silent_moves t' (a, b) (x1', m1')\\<rbrakk>\n       \\<Longrightarrow> x1' = x1", "hence \"r1.redT s1 (t', \\<epsilon>) (redT_upd_\\<epsilon> s1 t' x1'' m1'')\""], ["proof (prove)\nusing this:\n  r1.r_syntax t' x1 (shr s1) \\<lbrace>\\<rbrace> x1'' m1''\n\ngoal (1 subgoal):\n 1. s1 -1-t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> redT_upd_\\<epsilon>\n                       s1 t' x1'' m1''", "using \\<open>thr s1 t' = \\<lfloor>(x1, ln)\\<rfloor>\\<close> True"], ["proof (prove)\nusing this:\n  r1.r_syntax t' x1 (shr s1) \\<lbrace>\\<rbrace> x1'' m1''\n  thr s1 t' = \\<lfloor>(x1, ln)\\<rfloor>\n  wset s1 t' = None \\<and> ln = no_wait_locks\n\ngoal (1 subgoal):\n 1. s1 -1-t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> redT_upd_\\<epsilon>\n                       s1 t' x1'' m1''", "by -(erule r1.redT_normal, auto simp add: redT_updLns_def redT_updWs_def finfun_Diag_const2 o_def)"], ["proof (state)\nthis:\n  s1 -1-t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> redT_upd_\\<epsilon>\n                     s1 t' x1'' m1''\n\ngoal (2 subgoals):\n 1. (x1, shr s1) = (x1', m1') \\<Longrightarrow> x1' = x1\n 2. \\<And>a b.\n       \\<lbrakk>r1.silent_move t' (x1, shr s1) (a, b);\n        r1.silent_moves t' (a, b) (x1', m1')\\<rbrakk>\n       \\<Longrightarrow> x1' = x1", "hence False"], ["proof (prove)\nusing this:\n  s1 -1-t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> redT_upd_\\<epsilon>\n                     s1 t' x1'' m1''\n\ngoal (1 subgoal):\n 1. False", "using \\<open>t' \\<in> r1.deadlocked s1\\<close>"], ["proof (prove)\nusing this:\n  s1 -1-t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> redT_upd_\\<epsilon>\n                     s1 t' x1'' m1''\n  t' \\<in> r1.deadlocked s1\n\ngoal (1 subgoal):\n 1. False", "by(rule r1.red_no_deadlock)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. (x1, shr s1) = (x1', m1') \\<Longrightarrow> x1' = x1\n 2. \\<And>a b.\n       \\<lbrakk>r1.silent_move t' (x1, shr s1) (a, b);\n        r1.silent_moves t' (a, b) (x1', m1')\\<rbrakk>\n       \\<Longrightarrow> x1' = x1", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. x1' = x1", ".."], ["proof (state)\nthis:\n  x1' = x1\n\ngoal (1 subgoal):\n 1. (x1, shr s1) = (x1', m1') \\<Longrightarrow> x1' = x1", "qed simp"], ["proof (state)\nthis:\n  x1' = x1\n\ngoal (1 subgoal):\n 1. final2 x2 \\<Longrightarrow> False", "with \\<open>\\<not> final1 x1\\<close> \\<open>final1 x1'\\<close>"], ["proof (chain)\npicking this:\n  \\<not> final1 x1\n  final1 x1'\n  x1' = x1", "show False"], ["proof (prove)\nusing this:\n  \\<not> final1 x1\n  final1 x1'\n  x1' = x1\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> final2 x2\n\ngoal (1 subgoal):\n 1. wset s1 t' = None \\<and> ln = no_wait_locks \\<Longrightarrow>\n    r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n     (r1.deadlocked s1 \\<union>\n      r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n      r2.final_threads (ls2, (ts2', m2), ws2, is2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> final2 x2\n\ngoal (1 subgoal):\n 1. r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n     (r1.deadlocked s1 \\<union>\n      r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n      r2.final_threads (ls2, (ts2', m2), ws2, is2))", "using \\<open>ts2' t' = \\<lfloor>(x2, ln)\\<rfloor>\\<close> join"], ["proof (prove)\nusing this:\n  \\<not> final2 x2\n  ts2' t' = \\<lfloor>(x2, ln)\\<rfloor>\n  lt = Inr (Inl t')\n  r1.not_final_thread s1 t'\n  t' \\<in> r1.deadlocked s1 \\<union> r1.final_threads s1\n\ngoal (1 subgoal):\n 1. r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n     (r1.deadlocked s1 \\<union>\n      r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n      r2.final_threads (ls2, (ts2', m2), ws2, is2))", "by(auto simp add: r2.not_final_thread_iff r1.final_thread_def)"], ["proof (state)\nthis:\n  r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n   (r1.deadlocked s1 \\<union>\n    r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n    r2.final_threads (ls2, (ts2', m2), ws2, is2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n   (r1.deadlocked s1 \\<union>\n    r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n    r2.final_threads (ls2, (ts2', m2), ws2, is2))\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        r1.all_final_except s1\n         (r1.deadlocked s1 \\<union> r1.final_threads s1);\n        t' \\<notin> interrupts s1\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (r1.deadlocked s1 \\<union>\n                           r2.deadlocked\n                            (ls2, (ts2', m2), ws2, is2) \\<union>\n                           r2.final_threads (ls2, (ts2', m2), ws2, is2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        r1.all_final_except s1\n         (r1.deadlocked s1 \\<union> r1.final_threads s1);\n        t' \\<notin> interrupts s1\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (r1.deadlocked s1 \\<union>\n                           r2.deadlocked\n                            (ls2, (ts2', m2), ws2, is2) \\<union>\n                           r2.final_threads (ls2, (ts2', m2), ws2, is2))", "case (interrupt t')"], ["proof (state)\nthis:\n  lt = Inr (Inr t')\n  r1.all_final_except s1 (r1.deadlocked s1 \\<union> r1.final_threads s1)\n  t' \\<notin> interrupts s1\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        r1.all_final_except s1\n         (r1.deadlocked s1 \\<union> r1.final_threads s1);\n        t' \\<notin> interrupts s1\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (r1.deadlocked s1 \\<union>\n                           r2.deadlocked\n                            (ls2, (ts2', m2), ws2, is2) \\<union>\n                           r2.final_threads (ls2, (ts2', m2), ws2, is2))", "have \"r2.all_final_except ?s2 (r1.deadlocked s1 \\<union> r2.deadlocked ?s2 \\<union> r2.final_threads ?s2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n     (r1.deadlocked s1 \\<union>\n      r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n      r2.final_threads (ls2, (ts2', m2), ws2, is2))", "proof(rule r2.all_final_exceptI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       r2.not_final_thread (ls2, (ts2', m2), ws2, is2) t \\<Longrightarrow>\n       t \\<in> r1.deadlocked s1 \\<union>\n               r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n               r2.final_threads (ls2, (ts2', m2), ws2, is2)", "fix t''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       r2.not_final_thread (ls2, (ts2', m2), ws2, is2) t \\<Longrightarrow>\n       t \\<in> r1.deadlocked s1 \\<union>\n               r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n               r2.final_threads (ls2, (ts2', m2), ws2, is2)", "assume \"r2.not_final_thread ?s2 t''\""], ["proof (state)\nthis:\n  r2.not_final_thread (ls2, (ts2', m2), ws2, is2) t''\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       r2.not_final_thread (ls2, (ts2', m2), ws2, is2) t \\<Longrightarrow>\n       t \\<in> r1.deadlocked s1 \\<union>\n               r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n               r2.final_threads (ls2, (ts2', m2), ws2, is2)", "then"], ["proof (chain)\npicking this:\n  r2.not_final_thread (ls2, (ts2', m2), ws2, is2) t''", "obtain x2 ln where \"thr ?s2 t'' = \\<lfloor>(x2, ln)\\<rfloor>\"\n              and fin: \"\\<not> final2 x2 \\<or> ln \\<noteq> no_wait_locks \\<or> wset ?s2 t'' \\<noteq> None\""], ["proof (prove)\nusing this:\n  r2.not_final_thread (ls2, (ts2', m2), ws2, is2) t''\n\ngoal (1 subgoal):\n 1. (\\<And>x2 ln.\n        \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t'' =\n                 \\<lfloor>(x2, ln)\\<rfloor>;\n         \\<not> final2 x2 \\<or>\n         ln \\<noteq> no_wait_locks \\<or>\n         wset (ls2, (ts2', m2), ws2, is2) t'' \\<noteq> None\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: r2.not_final_thread_iff)"], ["proof (state)\nthis:\n  thr (ls2, (ts2', m2), ws2, is2) t'' = \\<lfloor>(x2, ln)\\<rfloor>\n  \\<not> final2 x2 \\<or>\n  ln \\<noteq> no_wait_locks \\<or>\n  wset (ls2, (ts2', m2), ws2, is2) t'' \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       r2.not_final_thread (ls2, (ts2', m2), ws2, is2) t \\<Longrightarrow>\n       t \\<in> r1.deadlocked s1 \\<union>\n               r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n               r2.final_threads (ls2, (ts2', m2), ws2, is2)", "from \\<open>thr ?s2 t'' = \\<lfloor>(x2, ln)\\<rfloor>\\<close> mbisim"], ["proof (chain)\npicking this:\n  thr (ls2, (ts2', m2), ws2, is2) t'' = \\<lfloor>(x2, ln)\\<rfloor>\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "obtain x1 where ts1t'': \"thr s1 t'' = \\<lfloor>(x1, ln)\\<rfloor>\" \n              and bisim'': \"t'' \\<turnstile> (x1, shr s1) \\<approx> (x2, shr ?s2)\""], ["proof (prove)\nusing this:\n  thr (ls2, (ts2', m2), ws2, is2) t'' = \\<lfloor>(x2, ln)\\<rfloor>\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. (\\<And>x1.\n        \\<lbrakk>thr s1 t'' = \\<lfloor>(x1, ln)\\<rfloor>;\n         t'' \\<turnstile> (x1, shr s1)\n         \\<approx> (x2, shr (ls2, (ts2', m2), ws2, is2))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: mbisim_thrD2)"], ["proof (state)\nthis:\n  thr s1 t'' = \\<lfloor>(x1, ln)\\<rfloor>\n  t'' \\<turnstile> (x1, shr s1)\n  \\<approx> (x2, shr (ls2, (ts2', m2), ws2, is2))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       r2.not_final_thread (ls2, (ts2', m2), ws2, is2) t \\<Longrightarrow>\n       t \\<in> r1.deadlocked s1 \\<union>\n               r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n               r2.final_threads (ls2, (ts2', m2), ws2, is2)", "have \"r1.not_final_thread s1 t''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r1.not_final_thread s1 t''", "proof(cases \"wset ?s2 t'' = None \\<and> ln = no_wait_locks\")"], ["proof (state)\ngoal (2 subgoals):\n 1. wset (ls2, (ts2', m2), ws2, is2) t'' = None \\<and>\n    ln = no_wait_locks \\<Longrightarrow>\n    r1.not_final_thread s1 t''\n 2. \\<not> (wset (ls2, (ts2', m2), ws2, is2) t'' = None \\<and>\n            ln = no_wait_locks) \\<Longrightarrow>\n    r1.not_final_thread s1 t''", "case True"], ["proof (state)\nthis:\n  wset (ls2, (ts2', m2), ws2, is2) t'' = None \\<and> ln = no_wait_locks\n\ngoal (2 subgoals):\n 1. wset (ls2, (ts2', m2), ws2, is2) t'' = None \\<and>\n    ln = no_wait_locks \\<Longrightarrow>\n    r1.not_final_thread s1 t''\n 2. \\<not> (wset (ls2, (ts2', m2), ws2, is2) t'' = None \\<and>\n            ln = no_wait_locks) \\<Longrightarrow>\n    r1.not_final_thread s1 t''", "with fin"], ["proof (chain)\npicking this:\n  \\<not> final2 x2 \\<or>\n  ln \\<noteq> no_wait_locks \\<or>\n  wset (ls2, (ts2', m2), ws2, is2) t'' \\<noteq> None\n  wset (ls2, (ts2', m2), ws2, is2) t'' = None \\<and> ln = no_wait_locks", "have \"\\<not> final2 x2\""], ["proof (prove)\nusing this:\n  \\<not> final2 x2 \\<or>\n  ln \\<noteq> no_wait_locks \\<or>\n  wset (ls2, (ts2', m2), ws2, is2) t'' \\<noteq> None\n  wset (ls2, (ts2', m2), ws2, is2) t'' = None \\<and> ln = no_wait_locks\n\ngoal (1 subgoal):\n 1. \\<not> final2 x2", "by simp"], ["proof (state)\nthis:\n  \\<not> final2 x2\n\ngoal (2 subgoals):\n 1. wset (ls2, (ts2', m2), ws2, is2) t'' = None \\<and>\n    ln = no_wait_locks \\<Longrightarrow>\n    r1.not_final_thread s1 t''\n 2. \\<not> (wset (ls2, (ts2', m2), ws2, is2) t'' = None \\<and>\n            ln = no_wait_locks) \\<Longrightarrow>\n    r1.not_final_thread s1 t''", "hence \"\\<not> final1 x1\""], ["proof (prove)\nusing this:\n  \\<not> final2 x2\n\ngoal (1 subgoal):\n 1. \\<not> final1 x1", "proof(rule contrapos_nn)"], ["proof (state)\ngoal (1 subgoal):\n 1. final1 x1 \\<Longrightarrow> final2 x2", "assume \"final1 x1\""], ["proof (state)\nthis:\n  final1 x1\n\ngoal (1 subgoal):\n 1. final1 x1 \\<Longrightarrow> final2 x2", "with final1_simulation[OF bisim'']"], ["proof (chain)\npicking this:\n  case (x1, shr s1) of (x1, m) \\<Rightarrow> final1 x1 \\<Longrightarrow>\n  \\<exists>s2'.\n     r2.silent_moves t'' (x2, shr (ls2, (ts2', m2), ws2, is2)) s2' \\<and>\n     t'' \\<turnstile> (x1, shr s1) \\<approx> s2' \\<and>\n     (case s2' of (x2, m) \\<Rightarrow> final2 x2)\n  final1 x1", "obtain x2' m2' where \\<tau>s2: \"r2.silent_moves t'' (x2, shr ?s2) (x2', m2')\"\n                  and bisim''': \"t'' \\<turnstile> (x1, shr s1) \\<approx> (x2', m2')\"\n                  and \"final2 x2'\""], ["proof (prove)\nusing this:\n  case (x1, shr s1) of (x1, m) \\<Rightarrow> final1 x1 \\<Longrightarrow>\n  \\<exists>s2'.\n     r2.silent_moves t'' (x2, shr (ls2, (ts2', m2), ws2, is2)) s2' \\<and>\n     t'' \\<turnstile> (x1, shr s1) \\<approx> s2' \\<and>\n     (case s2' of (x2, m) \\<Rightarrow> final2 x2)\n  final1 x1\n\ngoal (1 subgoal):\n 1. (\\<And>x2' m2'.\n        \\<lbrakk>r2.silent_moves t'' (x2, shr (ls2, (ts2', m2), ws2, is2))\n                  (x2', m2');\n         t'' \\<turnstile> (x1, shr s1) \\<approx> (x2', m2');\n         final2 x2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  r2.silent_moves t'' (x2, shr (ls2, (ts2', m2), ws2, is2)) (x2', m2')\n  t'' \\<turnstile> (x1, shr s1) \\<approx> (x2', m2')\n  final2 x2'\n\ngoal (1 subgoal):\n 1. final1 x1 \\<Longrightarrow> final2 x2", "from \\<tau>s2"], ["proof (chain)\npicking this:\n  r2.silent_moves t'' (x2, shr (ls2, (ts2', m2), ws2, is2)) (x2', m2')", "have \"x2' = x2\""], ["proof (prove)\nusing this:\n  r2.silent_moves t'' (x2, shr (ls2, (ts2', m2), ws2, is2)) (x2', m2')\n\ngoal (1 subgoal):\n 1. x2' = x2", "proof(cases rule: converse_rtranclpE2[consumes 1, case_names refl step])"], ["proof (state)\ngoal (2 subgoals):\n 1. (x2, shr (ls2, (ts2', m2), ws2, is2)) = (x2', m2') \\<Longrightarrow>\n    x2' = x2\n 2. \\<And>a b.\n       \\<lbrakk>r2.silent_move t'' (x2, shr (ls2, (ts2', m2), ws2, is2))\n                 (a, b);\n        r2.silent_moves t'' (a, b) (x2', m2')\\<rbrakk>\n       \\<Longrightarrow> x2' = x2", "case refl"], ["proof (state)\nthis:\n  (x2, shr (ls2, (ts2', m2), ws2, is2)) = (x2', m2')\n\ngoal (2 subgoals):\n 1. (x2, shr (ls2, (ts2', m2), ws2, is2)) = (x2', m2') \\<Longrightarrow>\n    x2' = x2\n 2. \\<And>a b.\n       \\<lbrakk>r2.silent_move t'' (x2, shr (ls2, (ts2', m2), ws2, is2))\n                 (a, b);\n        r2.silent_moves t'' (a, b) (x2', m2')\\<rbrakk>\n       \\<Longrightarrow> x2' = x2", "thus ?thesis"], ["proof (prove)\nusing this:\n  (x2, shr (ls2, (ts2', m2), ws2, is2)) = (x2', m2')\n\ngoal (1 subgoal):\n 1. x2' = x2", "by simp"], ["proof (state)\nthis:\n  x2' = x2\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>r2.silent_move t'' (x2, shr (ls2, (ts2', m2), ws2, is2))\n                 (a, b);\n        r2.silent_moves t'' (a, b) (x2', m2')\\<rbrakk>\n       \\<Longrightarrow> x2' = x2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>r2.silent_move t'' (x2, shr (ls2, (ts2', m2), ws2, is2))\n                 (a, b);\n        r2.silent_moves t'' (a, b) (x2', m2')\\<rbrakk>\n       \\<Longrightarrow> x2' = x2", "case (step x2'' m2'')"], ["proof (state)\nthis:\n  r2.silent_move t'' (x2, shr (ls2, (ts2', m2), ws2, is2)) (x2'', m2'')\n  r2.silent_moves t'' (x2'', m2'') (x2', m2')\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>r2.silent_move t'' (x2, shr (ls2, (ts2', m2), ws2, is2))\n                 (a, b);\n        r2.silent_moves t'' (a, b) (x2', m2')\\<rbrakk>\n       \\<Longrightarrow> x2' = x2", "from True"], ["proof (chain)\npicking this:\n  wset (ls2, (ts2', m2), ws2, is2) t'' = None \\<and> ln = no_wait_locks", "have \"wset s1 t'' = None\" \"thr s1 t'' = \\<lfloor>(x1, no_wait_locks)\\<rfloor>\" \"ts2' t'' = \\<lfloor>(x2, no_wait_locks)\\<rfloor>\""], ["proof (prove)\nusing this:\n  wset (ls2, (ts2', m2), ws2, is2) t'' = None \\<and> ln = no_wait_locks\n\ngoal (1 subgoal):\n 1. wset s1 t'' = None &&&\n    thr s1 t'' = \\<lfloor>(x1, no_wait_locks)\\<rfloor> &&&\n    ts2' t'' = \\<lfloor>(x2, no_wait_locks)\\<rfloor>", "using ts1t'' \\<open>thr ?s2 t'' = \\<lfloor>(x2, ln)\\<rfloor>\\<close> mbisim"], ["proof (prove)\nusing this:\n  wset (ls2, (ts2', m2), ws2, is2) t'' = None \\<and> ln = no_wait_locks\n  thr s1 t'' = \\<lfloor>(x1, ln)\\<rfloor>\n  thr (ls2, (ts2', m2), ws2, is2) t'' = \\<lfloor>(x2, ln)\\<rfloor>\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. wset s1 t'' = None &&&\n    thr s1 t'' = \\<lfloor>(x1, no_wait_locks)\\<rfloor> &&&\n    ts2' t'' = \\<lfloor>(x2, no_wait_locks)\\<rfloor>", "by(simp_all add: mbisim_def)"], ["proof (state)\nthis:\n  wset s1 t'' = None\n  thr s1 t'' = \\<lfloor>(x1, no_wait_locks)\\<rfloor>\n  ts2' t'' = \\<lfloor>(x2, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>r2.silent_move t'' (x2, shr (ls2, (ts2', m2), ws2, is2))\n                 (a, b);\n        r2.silent_moves t'' (a, b) (x2', m2')\\<rbrakk>\n       \\<Longrightarrow> x2' = x2", "hence no_\\<tau>2: \"\\<not> r2.silent_move t'' (x2, m2) (x2'', m2'')\""], ["proof (prove)\nusing this:\n  wset s1 t'' = None\n  thr s1 t'' = \\<lfloor>(x1, no_wait_locks)\\<rfloor>\n  ts2' t'' = \\<lfloor>(x2, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<not> r2.silent_move t'' (x2, m2) (x2'', m2'')", "proof(rule no_\\<tau>)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x' m'.\n       r1.silent_move t'' (x1, shr s1) (x', m') \\<Longrightarrow> False", "fix x1' m1'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x' m'.\n       r1.silent_move t'' (x1, shr s1) (x', m') \\<Longrightarrow> False", "assume \"r1.silent_move t'' (x1, shr s1) (x1', m1')\""], ["proof (state)\nthis:\n  r1.silent_move t'' (x1, shr s1) (x1', m1')\n\ngoal (1 subgoal):\n 1. \\<And>x' m'.\n       r1.silent_move t'' (x1, shr s1) (x', m') \\<Longrightarrow> False", "with \\<open>final1 x1\\<close>"], ["proof (chain)\npicking this:\n  final1 x1\n  r1.silent_move t'' (x1, shr s1) (x1', m1')", "show False"], ["proof (prove)\nusing this:\n  final1 x1\n  r1.silent_move t'' (x1, shr s1) (x1', m1')\n\ngoal (1 subgoal):\n 1. False", "by(auto dest: r1.final_no_red)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> r2.silent_move t'' (x2, m2) (x2'', m2'')\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>r2.silent_move t'' (x2, shr (ls2, (ts2', m2), ws2, is2))\n                 (a, b);\n        r2.silent_moves t'' (a, b) (x2', m2')\\<rbrakk>\n       \\<Longrightarrow> x2' = x2", "with \\<open>r2.silent_move t'' (x2, shr ?s2) (x2'', m2'')\\<close>"], ["proof (chain)\npicking this:\n  r2.silent_move t'' (x2, shr (ls2, (ts2', m2), ws2, is2)) (x2'', m2'')\n  \\<not> r2.silent_move t'' (x2, m2) (x2'', m2'')", "have False"], ["proof (prove)\nusing this:\n  r2.silent_move t'' (x2, shr (ls2, (ts2', m2), ws2, is2)) (x2'', m2'')\n  \\<not> r2.silent_move t'' (x2, m2) (x2'', m2'')\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>r2.silent_move t'' (x2, shr (ls2, (ts2', m2), ws2, is2))\n                 (a, b);\n        r2.silent_moves t'' (a, b) (x2', m2')\\<rbrakk>\n       \\<Longrightarrow> x2' = x2", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. x2' = x2", ".."], ["proof (state)\nthis:\n  x2' = x2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x2' = x2\n\ngoal (1 subgoal):\n 1. final1 x1 \\<Longrightarrow> final2 x2", "with \\<open>final2 x2'\\<close>"], ["proof (chain)\npicking this:\n  final2 x2'\n  x2' = x2", "show \"final2 x2\""], ["proof (prove)\nusing this:\n  final2 x2'\n  x2' = x2\n\ngoal (1 subgoal):\n 1. final2 x2", "by simp"], ["proof (state)\nthis:\n  final2 x2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> final1 x1\n\ngoal (2 subgoals):\n 1. wset (ls2, (ts2', m2), ws2, is2) t'' = None \\<and>\n    ln = no_wait_locks \\<Longrightarrow>\n    r1.not_final_thread s1 t''\n 2. \\<not> (wset (ls2, (ts2', m2), ws2, is2) t'' = None \\<and>\n            ln = no_wait_locks) \\<Longrightarrow>\n    r1.not_final_thread s1 t''", "with ts1t''"], ["proof (chain)\npicking this:\n  thr s1 t'' = \\<lfloor>(x1, ln)\\<rfloor>\n  \\<not> final1 x1", "show ?thesis"], ["proof (prove)\nusing this:\n  thr s1 t'' = \\<lfloor>(x1, ln)\\<rfloor>\n  \\<not> final1 x1\n\ngoal (1 subgoal):\n 1. r1.not_final_thread s1 t''", ".."], ["proof (state)\nthis:\n  r1.not_final_thread s1 t''\n\ngoal (1 subgoal):\n 1. \\<not> (wset (ls2, (ts2', m2), ws2, is2) t'' = None \\<and>\n            ln = no_wait_locks) \\<Longrightarrow>\n    r1.not_final_thread s1 t''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (wset (ls2, (ts2', m2), ws2, is2) t'' = None \\<and>\n            ln = no_wait_locks) \\<Longrightarrow>\n    r1.not_final_thread s1 t''", "case False"], ["proof (state)\nthis:\n  \\<not> (wset (ls2, (ts2', m2), ws2, is2) t'' = None \\<and>\n          ln = no_wait_locks)\n\ngoal (1 subgoal):\n 1. \\<not> (wset (ls2, (ts2', m2), ws2, is2) t'' = None \\<and>\n            ln = no_wait_locks) \\<Longrightarrow>\n    r1.not_final_thread s1 t''", "with ts1t'' mbisim"], ["proof (chain)\npicking this:\n  thr s1 t'' = \\<lfloor>(x1, ln)\\<rfloor>\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n  \\<not> (wset (ls2, (ts2', m2), ws2, is2) t'' = None \\<and>\n          ln = no_wait_locks)", "show ?thesis"], ["proof (prove)\nusing this:\n  thr s1 t'' = \\<lfloor>(x1, ln)\\<rfloor>\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n  \\<not> (wset (ls2, (ts2', m2), ws2, is2) t'' = None \\<and>\n          ln = no_wait_locks)\n\ngoal (1 subgoal):\n 1. r1.not_final_thread s1 t''", "by(auto simp add: r1.not_final_thread_iff mbisim_def)"], ["proof (state)\nthis:\n  r1.not_final_thread s1 t''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r1.not_final_thread s1 t''\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       r2.not_final_thread (ls2, (ts2', m2), ws2, is2) t \\<Longrightarrow>\n       t \\<in> r1.deadlocked s1 \\<union>\n               r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n               r2.final_threads (ls2, (ts2', m2), ws2, is2)", "with \\<open>r1.all_final_except s1 (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<close>"], ["proof (chain)\npicking this:\n  r1.all_final_except s1 (r1.deadlocked s1 \\<union> r1.final_threads s1)\n  r1.not_final_thread s1 t''", "have \"t'' \\<in> r1.deadlocked s1 \\<union> r1.final_threads s1\""], ["proof (prove)\nusing this:\n  r1.all_final_except s1 (r1.deadlocked s1 \\<union> r1.final_threads s1)\n  r1.not_final_thread s1 t''\n\ngoal (1 subgoal):\n 1. t'' \\<in> r1.deadlocked s1 \\<union> r1.final_threads s1", "by(rule r1.all_final_exceptD)"], ["proof (state)\nthis:\n  t'' \\<in> r1.deadlocked s1 \\<union> r1.final_threads s1\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       r2.not_final_thread (ls2, (ts2', m2), ws2, is2) t \\<Longrightarrow>\n       t \\<in> r1.deadlocked s1 \\<union>\n               r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n               r2.final_threads (ls2, (ts2', m2), ws2, is2)", "thus \"t'' \\<in> r1.deadlocked s1 \\<union> r2.deadlocked ?s2 \\<union> r2.final_threads ?s2\""], ["proof (prove)\nusing this:\n  t'' \\<in> r1.deadlocked s1 \\<union> r1.final_threads s1\n\ngoal (1 subgoal):\n 1. t''\n    \\<in> r1.deadlocked s1 \\<union>\n          r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n          r2.final_threads (ls2, (ts2', m2), ws2, is2)", "by(auto dest: fin' simp add: mbisim_eqs)"], ["proof (state)\nthis:\n  t''\n  \\<in> r1.deadlocked s1 \\<union>\n        r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n        r2.final_threads (ls2, (ts2', m2), ws2, is2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n   (r1.deadlocked s1 \\<union>\n    r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n    r2.final_threads (ls2, (ts2', m2), ws2, is2))\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        r1.all_final_except s1\n         (r1.deadlocked s1 \\<union> r1.final_threads s1);\n        t' \\<notin> interrupts s1\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (r1.deadlocked s1 \\<union>\n                           r2.deadlocked\n                            (ls2, (ts2', m2), ws2, is2) \\<union>\n                           r2.final_threads (ls2, (ts2', m2), ws2, is2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n   (r1.deadlocked s1 \\<union>\n    r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n    r2.final_threads (ls2, (ts2', m2), ws2, is2))\n\ngoal (1 subgoal):\n 1. r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n     (r1.deadlocked s1 \\<union>\n      r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n      r2.final_threads (ls2, (ts2', m2), ws2, is2))", "using interrupt mbisim"], ["proof (prove)\nusing this:\n  r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n   (r1.deadlocked s1 \\<union>\n    r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n    r2.final_threads (ls2, (ts2', m2), ws2, is2))\n  lt = Inr (Inr t')\n  r1.all_final_except s1 (r1.deadlocked s1 \\<union> r1.final_threads s1)\n  t' \\<notin> interrupts s1\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n     (r1.deadlocked s1 \\<union>\n      r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n      r2.final_threads (ls2, (ts2', m2), ws2, is2))", "by(auto simp add: mbisim_def)"], ["proof (state)\nthis:\n  r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n   (r1.deadlocked s1 \\<union>\n    r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n    r2.final_threads (ls2, (ts2', m2), ws2, is2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n   (r1.deadlocked s1 \\<union>\n    r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n    r2.final_threads (ls2, (ts2', m2), ws2, is2))\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s1\\<rangle> \\<wrong>1;\n        wset s1 t = None;\n        \\<And>LT.\n           t \\<turnstile> \\<langle>x, shr s1\\<rangle> LT\n           \\<wrong>1 \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              r1.must_wait s1 t lt\n               (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "hence \"\\<exists>lt\\<in>LT. r2.must_wait ?s2 t lt (r1.deadlocked s1 \\<union> r2.deadlocked ?s2 \\<union> r2.final_threads ?s2)\""], ["proof (prove)\nusing this:\n  r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n   (r1.deadlocked s1 \\<union>\n    r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n    r2.final_threads (ls2, (ts2', m2), ws2, is2))\n\ngoal (1 subgoal):\n 1. \\<exists>lt\\<in>LT.\n       r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n        (r1.deadlocked s1 \\<union>\n         r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n         r2.final_threads (ls2, (ts2', m2), ws2, is2))", "using \\<open>lt \\<in> LT\\<close>"], ["proof (prove)\nusing this:\n  r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n   (r1.deadlocked s1 \\<union>\n    r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n    r2.final_threads (ls2, (ts2', m2), ws2, is2))\n  lt \\<in> LT\n\ngoal (1 subgoal):\n 1. \\<exists>lt\\<in>LT.\n       r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n        (r1.deadlocked s1 \\<union>\n         r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n         r2.final_threads (ls2, (ts2', m2), ws2, is2))", "by blast"], ["proof (state)\nthis:\n  \\<exists>lt\\<in>LT.\n     r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n      (r1.deadlocked s1 \\<union>\n       r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n       r2.final_threads (ls2, (ts2', m2), ws2, is2))\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s1\\<rangle> \\<wrong>1;\n        wset s1 t = None;\n        \\<And>LT.\n           t \\<turnstile> \\<langle>x, shr s1\\<rangle> LT\n           \\<wrong>1 \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              r1.must_wait s1 t lt\n               (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "}"], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x2, m2\\<rangle> ?LT16 \\<wrong>2 \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT16.\n     r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n      (r1.deadlocked s1 \\<union>\n       r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n       r2.final_threads (ls2, (ts2', m2), ws2, is2))\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s1\\<rangle> \\<wrong>1;\n        wset s1 t = None;\n        \\<And>LT.\n           t \\<turnstile> \\<langle>x, shr s1\\<rangle> LT\n           \\<wrong>1 \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              r1.must_wait s1 t lt\n               (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "moreover"], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x2, m2\\<rangle> ?LT16 \\<wrong>2 \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT16.\n     r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n      (r1.deadlocked s1 \\<union>\n       r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n       r2.final_threads (ls2, (ts2', m2), ws2, is2))\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s1\\<rangle> \\<wrong>1;\n        wset s1 t = None;\n        \\<And>LT.\n           t \\<turnstile> \\<langle>x, shr s1\\<rangle> LT\n           \\<wrong>1 \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              r1.must_wait s1 t lt\n               (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "from mbisim \\<open>wset s1 t = None\\<close>"], ["proof (chain)\npicking this:\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n  wset s1 t = None", "have \"wset ?s2 t = None\""], ["proof (prove)\nusing this:\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n  wset s1 t = None\n\ngoal (1 subgoal):\n 1. wset (ls2, (ts2', m2), ws2, is2) t = None", "by(simp add: mbisim_def)"], ["proof (state)\nthis:\n  wset (ls2, (ts2', m2), ws2, is2) t = None\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s1\\<rangle> \\<wrong>1;\n        wset s1 t = None;\n        \\<And>LT.\n           t \\<turnstile> \\<langle>x, shr s1\\<rangle> LT\n           \\<wrong>1 \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              r1.must_wait s1 t lt\n               (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "ultimately"], ["proof (chain)\npicking this:\n  ts2' t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>\n  t \\<turnstile> \\<langle>x2, m2\\<rangle> \\<wrong>2\n  t \\<turnstile> \\<langle>x2, m2\\<rangle> ?LT16 \\<wrong>2 \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT16.\n     r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n      (r1.deadlocked s1 \\<union>\n       r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n       r2.final_threads (ls2, (ts2', m2), ws2, is2))\n  wset (ls2, (ts2', m2), ws2, is2) t = None", "have ?Lock"], ["proof (prove)\nusing this:\n  ts2' t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>\n  t \\<turnstile> \\<langle>x2, m2\\<rangle> \\<wrong>2\n  t \\<turnstile> \\<langle>x2, m2\\<rangle> ?LT16 \\<wrong>2 \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT16.\n     r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n      (r1.deadlocked s1 \\<union>\n       r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n       r2.final_threads (ls2, (ts2', m2), ws2, is2))\n  wset (ls2, (ts2', m2), ws2, is2) t = None\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       t \\<turnstile> \\<langle>x, shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n       \\<wrong>2 \\<and>\n       wset (ls2, (ts2', m2), ws2, is2) t = None \\<and>\n       (\\<forall>LT.\n           t \\<turnstile> \\<langle>x,\n           shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n           \\<wrong>2 \\<longrightarrow>\n           (\\<exists>lt\\<in>LT.\n               r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                (r1.deadlocked s1 \\<union>\n                 r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n                 r2.final_threads (ls2, (ts2', m2), ws2, is2))))", "by simp"], ["proof (state)\nthis:\n  \\<exists>x.\n     thr (ls2, (ts2', m2), ws2, is2) t =\n     \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n     t \\<turnstile> \\<langle>x, shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n     \\<wrong>2 \\<and>\n     wset (ls2, (ts2', m2), ws2, is2) t = None \\<and>\n     (\\<forall>LT.\n         t \\<turnstile> \\<langle>x, shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n         LT \\<wrong>2 \\<longrightarrow>\n         (\\<exists>lt\\<in>LT.\n             r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n              (r1.deadlocked s1 \\<union>\n               r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n               r2.final_threads (ls2, (ts2', m2), ws2, is2))))\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s1\\<rangle> \\<wrong>1;\n        wset s1 t = None;\n        \\<And>LT.\n           t \\<turnstile> \\<langle>x, shr s1\\<rangle> LT\n           \\<wrong>1 \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              r1.must_wait s1 t lt\n               (r1.deadlocked s1 \\<union> r1.final_threads s1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>x.\n     thr (ls2, (ts2', m2), ws2, is2) t =\n     \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n     t \\<turnstile> \\<langle>x, shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n     \\<wrong>2 \\<and>\n     wset (ls2, (ts2', m2), ws2, is2) t = None \\<and>\n     (\\<forall>LT.\n         t \\<turnstile> \\<langle>x, shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n         LT \\<wrong>2 \\<longrightarrow>\n         (\\<exists>lt\\<in>LT.\n             r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n              (r1.deadlocked s1 \\<union>\n               r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n               r2.final_threads (ls2, (ts2', m2), ws2, is2))))\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr (ls2, (ts2', m2), ws2, is2) t =\n        \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t \\<turnstile> \\<langle>x, shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n        \\<wrong>2 \\<and>\n        wset (ls2, (ts2', m2), ws2, is2) t = None \\<and>\n        (\\<forall>LT.\n            t \\<turnstile> \\<langle>x,\n            shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n            \\<wrong>2 \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                 (r1.deadlocked s1 \\<union>\n                  r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n                  r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n    (\\<exists>x ln.\n        thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n         (r1.deadlocked s1 \\<union>\n          r2.deadlocked (ls2, (ts2', m2), ws2, is2)) \\<and>\n        waiting (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n    (\\<exists>x l t' ln.\n        thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l) t' \\<and>\n        t' \\<noteq> t \\<and>\n        ((t' \\<in> r1.deadlocked s1 \\<or>\n          t' \\<in> r2.deadlocked (ls2, (ts2', m2), ws2, is2)) \\<or>\n         r2.final_thread (ls2, (ts2', m2), ws2, is2) t'))", ".."], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr (ls2, (ts2', m2), ws2, is2) t =\n      \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t \\<turnstile> \\<langle>x, shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n      \\<wrong>2 \\<and>\n      wset (ls2, (ts2', m2), ws2, is2) t = None \\<and>\n      (\\<forall>LT.\n          t \\<turnstile> \\<langle>x,\n          shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n          \\<wrong>2 \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n               (r1.deadlocked s1 \\<union>\n                r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n                r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n  (\\<exists>x ln.\n      thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n       (r1.deadlocked s1 \\<union>\n        r2.deadlocked (ls2, (ts2', m2), ws2, is2)) \\<and>\n      waiting (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n  (\\<exists>x l t' ln.\n      thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t) \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l) t' \\<and>\n      t' \\<noteq> t \\<and>\n      ((t' \\<in> r1.deadlocked s1 \\<or>\n        t' \\<in> r2.deadlocked (ls2, (ts2', m2), ws2, is2)) \\<or>\n       r2.final_thread (ls2, (ts2', m2), ws2, is2) t'))\n\ngoal (2 subgoals):\n 1. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "case (wait x1 ln)"], ["proof (state)\nthis:\n  thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>\n  r1.all_final_except s1 (r1.deadlocked s1)\n  waiting (wset s1 t)\n\ngoal (2 subgoals):\n 1. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "from mbisim \\<open>thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n  thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>", "obtain x2 where \"ts2' t = \\<lfloor>(x2, ln)\\<rfloor>\""], ["proof (prove)\nusing this:\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n  thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>x2.\n        ts2' t = \\<lfloor>(x2, ln)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: mbisim_thrD1)"], ["proof (state)\nthis:\n  ts2' t = \\<lfloor>(x2, ln)\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "moreover"], ["proof (state)\nthis:\n  ts2' t = \\<lfloor>(x2, ln)\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "have \"r2.all_final_except ?s2 (r1.deadlocked s1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r2.all_final_except (ls2, (ts2', m2), ws2, is2) (r1.deadlocked s1)", "proof(rule r2.all_final_exceptI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       r2.not_final_thread (ls2, (ts2', m2), ws2, is2) t \\<Longrightarrow>\n       t \\<in> r1.deadlocked s1", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       r2.not_final_thread (ls2, (ts2', m2), ws2, is2) t \\<Longrightarrow>\n       t \\<in> r1.deadlocked s1", "assume \"r2.not_final_thread ?s2 t\""], ["proof (state)\nthis:\n  r2.not_final_thread (ls2, (ts2', m2), ws2, is2) t\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       r2.not_final_thread (ls2, (ts2', m2), ws2, is2) t \\<Longrightarrow>\n       t \\<in> r1.deadlocked s1", "then"], ["proof (chain)\npicking this:\n  r2.not_final_thread (ls2, (ts2', m2), ws2, is2) t", "obtain x2 ln where \"ts2' t = \\<lfloor>(x2, ln)\\<rfloor>\""], ["proof (prove)\nusing this:\n  r2.not_final_thread (ls2, (ts2', m2), ws2, is2) t\n\ngoal (1 subgoal):\n 1. (\\<And>x2 ln.\n        ts2' t = \\<lfloor>(x2, ln)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: r2.not_final_thread_iff)"], ["proof (state)\nthis:\n  ts2' t = \\<lfloor>(x2, ln)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       r2.not_final_thread (ls2, (ts2', m2), ws2, is2) t \\<Longrightarrow>\n       t \\<in> r1.deadlocked s1", "with mbisim"], ["proof (chain)\npicking this:\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n  ts2' t = \\<lfloor>(x2, ln)\\<rfloor>", "obtain x1 where \"thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>\" \"t \\<turnstile> (x1, shr s1) \\<approx> (x2, m2)\""], ["proof (prove)\nusing this:\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n  ts2' t = \\<lfloor>(x2, ln)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>x1.\n        \\<lbrakk>thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>;\n         t \\<turnstile> (x1, shr s1) \\<approx> (x2, m2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: mbisim_thrD2)"], ["proof (state)\nthis:\n  thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>\n  t \\<turnstile> (x1, shr s1) \\<approx> (x2, m2)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       r2.not_final_thread (ls2, (ts2', m2), ws2, is2) t \\<Longrightarrow>\n       t \\<in> r1.deadlocked s1", "hence \"r1.not_final_thread s1 t\""], ["proof (prove)\nusing this:\n  thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>\n  t \\<turnstile> (x1, shr s1) \\<approx> (x2, m2)\n\ngoal (1 subgoal):\n 1. r1.not_final_thread s1 t", "using \\<open>r2.not_final_thread ?s2 t\\<close> \\<open>ts2' t = \\<lfloor>(x2, ln)\\<rfloor>\\<close> mbisim fin'[of t]"], ["proof (prove)\nusing this:\n  thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>\n  t \\<turnstile> (x1, shr s1) \\<approx> (x2, m2)\n  r2.not_final_thread (ls2, (ts2', m2), ws2, is2) t\n  ts2' t = \\<lfloor>(x2, ln)\\<rfloor>\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n  r1.final_thread s1 t \\<Longrightarrow>\n  r2.final_thread (ls2, (ts2', m2), ws2, is2) t\n\ngoal (1 subgoal):\n 1. r1.not_final_thread s1 t", "by(cases \"wset s1 t\")(auto simp add: r1.not_final_thread_iff r2.not_final_thread_iff mbisim_def r1.final_thread_def r2.final_thread_def)"], ["proof (state)\nthis:\n  r1.not_final_thread s1 t\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       r2.not_final_thread (ls2, (ts2', m2), ws2, is2) t \\<Longrightarrow>\n       t \\<in> r1.deadlocked s1", "with \\<open>r1.all_final_except s1 (r1.deadlocked s1)\\<close>"], ["proof (chain)\npicking this:\n  r1.all_final_except s1 (r1.deadlocked s1)\n  r1.not_final_thread s1 t", "show \"t \\<in> r1.deadlocked s1\""], ["proof (prove)\nusing this:\n  r1.all_final_except s1 (r1.deadlocked s1)\n  r1.not_final_thread s1 t\n\ngoal (1 subgoal):\n 1. t \\<in> r1.deadlocked s1", "by(rule r1.all_final_exceptD)"], ["proof (state)\nthis:\n  t \\<in> r1.deadlocked s1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r2.all_final_except (ls2, (ts2', m2), ws2, is2) (r1.deadlocked s1)\n\ngoal (2 subgoals):\n 1. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "hence \"r2.all_final_except ?s2 (r1.deadlocked s1 \\<union> r2.deadlocked ?s2)\""], ["proof (prove)\nusing this:\n  r2.all_final_except (ls2, (ts2', m2), ws2, is2) (r1.deadlocked s1)\n\ngoal (1 subgoal):\n 1. r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n     (r1.deadlocked s1 \\<union> r2.deadlocked (ls2, (ts2', m2), ws2, is2))", "by(rule r2.all_final_except_mono') blast"], ["proof (state)\nthis:\n  r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n   (r1.deadlocked s1 \\<union> r2.deadlocked (ls2, (ts2', m2), ws2, is2))\n\ngoal (2 subgoals):\n 1. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "moreover"], ["proof (state)\nthis:\n  r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n   (r1.deadlocked s1 \\<union> r2.deadlocked (ls2, (ts2', m2), ws2, is2))\n\ngoal (2 subgoals):\n 1. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "from \\<open>waiting (wset s1 t)\\<close> mbisim"], ["proof (chain)\npicking this:\n  waiting (wset s1 t)\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "have \"waiting (wset ?s2 t)\""], ["proof (prove)\nusing this:\n  waiting (wset s1 t)\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. waiting (wset (ls2, (ts2', m2), ws2, is2) t)", "by(simp add: mbisim_def)"], ["proof (state)\nthis:\n  waiting (wset (ls2, (ts2', m2), ws2, is2) t)\n\ngoal (2 subgoals):\n 1. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "ultimately"], ["proof (chain)\npicking this:\n  ts2' t = \\<lfloor>(x2, ln)\\<rfloor>\n  r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n   (r1.deadlocked s1 \\<union> r2.deadlocked (ls2, (ts2', m2), ws2, is2))\n  waiting (wset (ls2, (ts2', m2), ws2, is2) t)", "have ?Wait"], ["proof (prove)\nusing this:\n  ts2' t = \\<lfloor>(x2, ln)\\<rfloor>\n  r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n   (r1.deadlocked s1 \\<union> r2.deadlocked (ls2, (ts2', m2), ws2, is2))\n  waiting (wset (ls2, (ts2', m2), ws2, is2) t)\n\ngoal (1 subgoal):\n 1. \\<exists>x ln.\n       thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n        (r1.deadlocked s1 \\<union>\n         r2.deadlocked (ls2, (ts2', m2), ws2, is2)) \\<and>\n       waiting (wset (ls2, (ts2', m2), ws2, is2) t)", "by simp"], ["proof (state)\nthis:\n  \\<exists>x ln.\n     thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n     r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n      (r1.deadlocked s1 \\<union>\n       r2.deadlocked (ls2, (ts2', m2), ws2, is2)) \\<and>\n     waiting (wset (ls2, (ts2', m2), ws2, is2) t)\n\ngoal (2 subgoals):\n 1. \\<And>x ln.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        r1.all_final_except s1 (r1.deadlocked s1);\n        waiting (wset s1 t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))\n 2. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>x ln.\n     thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n     r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n      (r1.deadlocked s1 \\<union>\n       r2.deadlocked (ls2, (ts2', m2), ws2, is2)) \\<and>\n     waiting (wset (ls2, (ts2', m2), ws2, is2) t)\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr (ls2, (ts2', m2), ws2, is2) t =\n        \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t \\<turnstile> \\<langle>x, shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n        \\<wrong>2 \\<and>\n        wset (ls2, (ts2', m2), ws2, is2) t = None \\<and>\n        (\\<forall>LT.\n            t \\<turnstile> \\<langle>x,\n            shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n            \\<wrong>2 \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                 (r1.deadlocked s1 \\<union>\n                  r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n                  r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n    (\\<exists>x ln.\n        thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n         (r1.deadlocked s1 \\<union>\n          r2.deadlocked (ls2, (ts2', m2), ws2, is2)) \\<and>\n        waiting (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n    (\\<exists>x l t' ln.\n        thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l) t' \\<and>\n        t' \\<noteq> t \\<and>\n        ((t' \\<in> r1.deadlocked s1 \\<or>\n          t' \\<in> r2.deadlocked (ls2, (ts2', m2), ws2, is2)) \\<or>\n         r2.final_thread (ls2, (ts2', m2), ws2, is2) t'))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr (ls2, (ts2', m2), ws2, is2) t =\n      \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t \\<turnstile> \\<langle>x, shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n      \\<wrong>2 \\<and>\n      wset (ls2, (ts2', m2), ws2, is2) t = None \\<and>\n      (\\<forall>LT.\n          t \\<turnstile> \\<langle>x,\n          shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n          \\<wrong>2 \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n               (r1.deadlocked s1 \\<union>\n                r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n                r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n  (\\<exists>x ln.\n      thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n       (r1.deadlocked s1 \\<union>\n        r2.deadlocked (ls2, (ts2', m2), ws2, is2)) \\<and>\n      waiting (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n  (\\<exists>x l t' ln.\n      thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t) \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l) t' \\<and>\n      t' \\<noteq> t \\<and>\n      ((t' \\<in> r1.deadlocked s1 \\<or>\n        t' \\<in> r2.deadlocked (ls2, (ts2', m2), ws2, is2)) \\<or>\n       r2.final_thread (ls2, (ts2', m2), ws2, is2) t'))\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "case (acquire x1 ln l t')"], ["proof (state)\nthis:\n  thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>\n  \\<not> waiting (wset s1 t)\n  0 < ln $ l\n  has_lock (locks s1 $ l) t'\n  t \\<noteq> t'\n  t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "from mbisim \\<open>thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n  thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>", "obtain x2 where \"ts2' t = \\<lfloor>(x2, ln)\\<rfloor>\""], ["proof (prove)\nusing this:\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n  thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>x2.\n        ts2' t = \\<lfloor>(x2, ln)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: mbisim_thrD1)"], ["proof (state)\nthis:\n  ts2' t = \\<lfloor>(x2, ln)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "moreover"], ["proof (state)\nthis:\n  ts2' t = \\<lfloor>(x2, ln)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "from \\<open>t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<close>"], ["proof (chain)\npicking this:\n  t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'", "have \"(t' \\<in> r1.deadlocked s1 \\<or> t' \\<in> r2.deadlocked ?s2) \\<or> r2.final_thread ?s2 t'\""], ["proof (prove)\nusing this:\n  t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\n\ngoal (1 subgoal):\n 1. (t' \\<in> r1.deadlocked s1 \\<or>\n     t' \\<in> r2.deadlocked (ls2, (ts2', m2), ws2, is2)) \\<or>\n    r2.final_thread (ls2, (ts2', m2), ws2, is2) t'", "by(blast dest: fin')"], ["proof (state)\nthis:\n  (t' \\<in> r1.deadlocked s1 \\<or>\n   t' \\<in> r2.deadlocked (ls2, (ts2', m2), ws2, is2)) \\<or>\n  r2.final_thread (ls2, (ts2', m2), ws2, is2) t'\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "moreover"], ["proof (state)\nthis:\n  (t' \\<in> r1.deadlocked s1 \\<or>\n   t' \\<in> r2.deadlocked (ls2, (ts2', m2), ws2, is2)) \\<or>\n  r2.final_thread (ls2, (ts2', m2), ws2, is2) t'\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "from mbisim \\<open>has_lock (locks s1 $ l) t'\\<close>"], ["proof (chain)\npicking this:\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n  has_lock (locks s1 $ l) t'", "have \"has_lock (locks ?s2 $ l) t'\""], ["proof (prove)\nusing this:\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n  has_lock (locks s1 $ l) t'\n\ngoal (1 subgoal):\n 1. has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l) t'", "by(simp add: mbisim_def)"], ["proof (state)\nthis:\n  has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l) t'\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "ultimately"], ["proof (chain)\npicking this:\n  ts2' t = \\<lfloor>(x2, ln)\\<rfloor>\n  (t' \\<in> r1.deadlocked s1 \\<or>\n   t' \\<in> r2.deadlocked (ls2, (ts2', m2), ws2, is2)) \\<or>\n  r2.final_thread (ls2, (ts2', m2), ws2, is2) t'\n  has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l) t'", "have ?Acquire"], ["proof (prove)\nusing this:\n  ts2' t = \\<lfloor>(x2, ln)\\<rfloor>\n  (t' \\<in> r1.deadlocked s1 \\<or>\n   t' \\<in> r2.deadlocked (ls2, (ts2', m2), ws2, is2)) \\<or>\n  r2.final_thread (ls2, (ts2', m2), ws2, is2) t'\n  has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l) t'\n\ngoal (1 subgoal):\n 1. \\<exists>x l t' ln.\n       thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t) \\<and>\n       0 < ln $ l \\<and>\n       has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l) t' \\<and>\n       t' \\<noteq> t \\<and>\n       ((t' \\<in> r1.deadlocked s1 \\<or>\n         t' \\<in> r2.deadlocked (ls2, (ts2', m2), ws2, is2)) \\<or>\n        r2.final_thread (ls2, (ts2', m2), ws2, is2) t')", "using \\<open>0 < ln $ l\\<close> \\<open>t \\<noteq> t'\\<close> \\<open>\\<not> waiting (wset s1 t)\\<close> mbisim"], ["proof (prove)\nusing this:\n  ts2' t = \\<lfloor>(x2, ln)\\<rfloor>\n  (t' \\<in> r1.deadlocked s1 \\<or>\n   t' \\<in> r2.deadlocked (ls2, (ts2', m2), ws2, is2)) \\<or>\n  r2.final_thread (ls2, (ts2', m2), ws2, is2) t'\n  has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l) t'\n  0 < ln $ l\n  t \\<noteq> t'\n  \\<not> waiting (wset s1 t)\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. \\<exists>x l t' ln.\n       thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t) \\<and>\n       0 < ln $ l \\<and>\n       has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l) t' \\<and>\n       t' \\<noteq> t \\<and>\n       ((t' \\<in> r1.deadlocked s1 \\<or>\n         t' \\<in> r2.deadlocked (ls2, (ts2', m2), ws2, is2)) \\<or>\n        r2.final_thread (ls2, (ts2', m2), ws2, is2) t')", "by(auto simp add: mbisim_def)"], ["proof (state)\nthis:\n  \\<exists>x l t' ln.\n     thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n     \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t) \\<and>\n     0 < ln $ l \\<and>\n     has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l) t' \\<and>\n     t' \\<noteq> t \\<and>\n     ((t' \\<in> r1.deadlocked s1 \\<or>\n       t' \\<in> r2.deadlocked (ls2, (ts2', m2), ws2, is2)) \\<or>\n      r2.final_thread (ls2, (ts2', m2), ws2, is2) t')\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s1 t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s1 t); 0 < ln $ l; has_lock (locks s1 $ l) t';\n        t \\<noteq> t';\n        t' \\<in> r1.deadlocked s1 \\<or> r1.final_thread s1 t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                             \\<wrong>2 \\<and>\n                             wset (ls2, (ts2', m2), ws2, is2) t =\n                             None \\<and>\n                             (\\<forall>LT.\n                                 t \\<turnstile> \\<langle>x,\n                                 shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                                 \\<wrong>2 \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     r2.must_wait\n(ls2, (ts2', m2), ws2, is2) t lt\n(r1.deadlocked s1 \\<union>\n r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n                         (\\<exists>x ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n                              (r1.deadlocked s1 \\<union>\n                               r2.deadlocked\n                                (ls2, (ts2', m2), ws2, is2)) \\<and>\n                             waiting\n                              (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr (ls2, (ts2', m2), ws2, is2) t =\n                             \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting\n                                     (wset (ls2, (ts2', m2), ws2, is2)\n t) \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock\n                              (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                              t' \\<and>\n                             t' \\<noteq> t \\<and>\n                             ((t' \\<in> r1.deadlocked s1 \\<or>\n                               t' \\<in> r2.deadlocked\n   (ls2, (ts2', m2), ws2, is2)) \\<or>\n                              r2.final_thread (ls2, (ts2', m2), ws2, is2)\n                               t'))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>x l t' ln.\n     thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n     \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t) \\<and>\n     0 < ln $ l \\<and>\n     has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l) t' \\<and>\n     t' \\<noteq> t \\<and>\n     ((t' \\<in> r1.deadlocked s1 \\<or>\n       t' \\<in> r2.deadlocked (ls2, (ts2', m2), ws2, is2)) \\<or>\n      r2.final_thread (ls2, (ts2', m2), ws2, is2) t')\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr (ls2, (ts2', m2), ws2, is2) t =\n        \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t \\<turnstile> \\<langle>x, shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n        \\<wrong>2 \\<and>\n        wset (ls2, (ts2', m2), ws2, is2) t = None \\<and>\n        (\\<forall>LT.\n            t \\<turnstile> \\<langle>x,\n            shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n            \\<wrong>2 \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                 (r1.deadlocked s1 \\<union>\n                  r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n                  r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n    (\\<exists>x ln.\n        thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n         (r1.deadlocked s1 \\<union>\n          r2.deadlocked (ls2, (ts2', m2), ws2, is2)) \\<and>\n        waiting (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n    (\\<exists>x l t' ln.\n        thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l) t' \\<and>\n        t' \\<noteq> t \\<and>\n        ((t' \\<in> r1.deadlocked s1 \\<or>\n          t' \\<in> r2.deadlocked (ls2, (ts2', m2), ws2, is2)) \\<or>\n         r2.final_thread (ls2, (ts2', m2), ws2, is2) t'))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr (ls2, (ts2', m2), ws2, is2) t =\n      \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t \\<turnstile> \\<langle>x, shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n      \\<wrong>2 \\<and>\n      wset (ls2, (ts2', m2), ws2, is2) t = None \\<and>\n      (\\<forall>LT.\n          t \\<turnstile> \\<langle>x,\n          shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n          \\<wrong>2 \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n               (r1.deadlocked s1 \\<union>\n                r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n                r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n  (\\<exists>x ln.\n      thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n       (r1.deadlocked s1 \\<union>\n        r2.deadlocked (ls2, (ts2', m2), ws2, is2)) \\<and>\n      waiting (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n  (\\<exists>x l t' ln.\n      thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t) \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l) t' \\<and>\n      t' \\<noteq> t \\<and>\n      ((t' \\<in> r1.deadlocked s1 \\<or>\n        t' \\<in> r2.deadlocked (ls2, (ts2', m2), ws2, is2)) \\<or>\n       r2.final_thread (ls2, (ts2', m2), ws2, is2) t'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr (ls2, (ts2', m2), ws2, is2) t =\n      \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t \\<turnstile> \\<langle>x, shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n      \\<wrong>2 \\<and>\n      wset (ls2, (ts2', m2), ws2, is2) t = None \\<and>\n      (\\<forall>LT.\n          t \\<turnstile> \\<langle>x,\n          shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n          \\<wrong>2 \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n               (r1.deadlocked s1 \\<union>\n                r2.deadlocked (ls2, (ts2', m2), ws2, is2) \\<union>\n                r2.final_threads (ls2, (ts2', m2), ws2, is2))))) \\<or>\n  (\\<exists>x ln.\n      thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n       (r1.deadlocked s1 \\<union>\n        r2.deadlocked (ls2, (ts2', m2), ws2, is2)) \\<and>\n      waiting (wset (ls2, (ts2', m2), ws2, is2) t)) \\<or>\n  (\\<exists>x l t' ln.\n      thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t) \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l) t' \\<and>\n      t' \\<noteq> t \\<and>\n      ((t' \\<in> r1.deadlocked s1 \\<or>\n        t' \\<in> r2.deadlocked (ls2, (ts2', m2), ws2, is2)) \\<or>\n       r2.final_thread (ls2, (ts2', m2), ws2, is2) t'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<in> r2.deadlocked (ls2, (ts2', m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and>\n       t \\<in> r2.deadlocked s2' \\<and> s1 \\<approx>m s2'", "with red1 red2 mbisim"], ["proof (chain)\npicking this:\n  \\<tau>mRed2 s2 (ls2, (ts2, m2), ws2, is2)\n  \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2) (ls2, (ts2', m2), ws2, is2)\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n  t \\<in> r2.deadlocked (ls2, (ts2', m2), ws2, is2)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<tau>mRed2 s2 (ls2, (ts2, m2), ws2, is2)\n  \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2) (ls2, (ts2', m2), ws2, is2)\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n  t \\<in> r2.deadlocked (ls2, (ts2', m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and>\n       t \\<in> r2.deadlocked s2' \\<and> s1 \\<approx>m s2'", "by(blast intro: rtranclp_trans)"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     \\<tau>mRed2 s2 s2' \\<and>\n     t \\<in> r2.deadlocked s2' \\<and> s1 \\<approx>m s2'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma deadlocked2_imp_\\<tau>s_deadlocked1:\n  \"\\<lbrakk> s1 \\<approx>m s2; t \\<in> r2.deadlocked s2 \\<rbrakk>\n  \\<Longrightarrow> \\<exists>s1'. r1.mthr.silent_moves s1 s1' \\<and> t \\<in> r1.deadlocked s1' \\<and> s1' \\<approx>m s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx>m s2; t \\<in> r2.deadlocked s2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s1'.\n                         \\<tau>mRed1 s1 s1' \\<and>\n                         t \\<in> r1.deadlocked s1' \\<and> s1' \\<approx>m s2", "using FWdelay_bisimulation_diverge.deadlocked1_imp_\\<tau>s_deadlocked2[OF FWdelay_bisimulation_diverge_flip]"], ["proof (prove)\nusing this:\n  \\<lbrakk>FWbisimulation_base.mbisim (\\<lambda>t. flip (bisim t))\n            (flip bisim_wait) ?s1.0 ?s2.0;\n   ?t \\<in> r2.deadlocked ?s1.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s2'.\n                       (\\<tau>trsys.silent_move\n                         (multithreaded_base.redT final1 r1 ?convert_RA)\n                         m\\<tau>move1)\\<^sup>*\\<^sup>*\n                        ?s2.0 s2' \\<and>\n                       ?t \\<in> r1.deadlocked s2' \\<and>\n                       FWbisimulation_base.mbisim\n                        (\\<lambda>t. flip (bisim t)) (flip bisim_wait) ?s1.0\n                        s2'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx>m s2; t \\<in> r2.deadlocked s2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s1'.\n                         \\<tau>mRed1 s1 s1' \\<and>\n                         t \\<in> r1.deadlocked s1' \\<and> s1' \\<approx>m s2", "unfolding flip_simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s2.0 \\<approx>m ?s1.0; ?t \\<in> r2.deadlocked ?s1.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s2'.\n                       (\\<tau>trsys.silent_move\n                         (multithreaded_base.redT final1 r1 ?convert_RA)\n                         m\\<tau>move1)\\<^sup>*\\<^sup>*\n                        ?s2.0 s2' \\<and>\n                       ?t \\<in> r1.deadlocked s2' \\<and>\n                       s2' \\<approx>m ?s1.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx>m s2; t \\<in> r2.deadlocked s2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s1'.\n                         \\<tau>mRed1 s1 s1' \\<and>\n                         t \\<in> r1.deadlocked s1' \\<and> s1' \\<approx>m s2", "."], ["", "lemma deadlock1_imp_\\<tau>s_deadlock2:\n  assumes mbisim: \"s1 \\<approx>m s2\"\n  and dead: \"r1.deadlock s1\"\n  shows \"\\<exists>s2'. r2.mthr.silent_moves s2 s2' \\<and> r2.deadlock s2' \\<and> s1 \\<approx>m s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and> r2.deadlock s2' \\<and> s1 \\<approx>m s2'", "proof(cases \"\\<exists>t. r1.not_final_thread s1 t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>t. r1.not_final_thread s1 t \\<Longrightarrow>\n    \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and> r2.deadlock s2' \\<and> s1 \\<approx>m s2'\n 2. \\<nexists>t. r1.not_final_thread s1 t \\<Longrightarrow>\n    \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and> r2.deadlock s2' \\<and> s1 \\<approx>m s2'", "case True"], ["proof (state)\nthis:\n  \\<exists>t. r1.not_final_thread s1 t\n\ngoal (2 subgoals):\n 1. \\<exists>t. r1.not_final_thread s1 t \\<Longrightarrow>\n    \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and> r2.deadlock s2' \\<and> s1 \\<approx>m s2'\n 2. \\<nexists>t. r1.not_final_thread s1 t \\<Longrightarrow>\n    \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and> r2.deadlock s2' \\<and> s1 \\<approx>m s2'", "then"], ["proof (chain)\npicking this:\n  \\<exists>t. r1.not_final_thread s1 t", "obtain t where nfin: \"r1.not_final_thread s1 t\""], ["proof (prove)\nusing this:\n  \\<exists>t. r1.not_final_thread s1 t\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        r1.not_final_thread s1 t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  r1.not_final_thread s1 t\n\ngoal (2 subgoals):\n 1. \\<exists>t. r1.not_final_thread s1 t \\<Longrightarrow>\n    \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and> r2.deadlock s2' \\<and> s1 \\<approx>m s2'\n 2. \\<nexists>t. r1.not_final_thread s1 t \\<Longrightarrow>\n    \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and> r2.deadlock s2' \\<and> s1 \\<approx>m s2'", "from mfinal1_inv_simulation[OF mbisim]"], ["proof (chain)\npicking this:\n  \\<exists>s2'.\n     \\<tau>mRed2 s2 s2' \\<and>\n     s1 \\<approx>m s2' \\<and>\n     r1.final_threads s1 \\<subseteq> r2.final_threads s2' \\<and>\n     shr s2' = shr s2", "obtain ls2 ts2 m2 ws2 is2 where red1: \"r2.mthr.silent_moves s2 (ls2, (ts2, m2), ws2, is2)\"\n    and \"s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\" and \"m2 = shr s2\" \n    and fin: \"\\<And>t. r1.final_thread s1 t \\<Longrightarrow> r2.final_thread (ls2, (ts2, m2), ws2, is2) t\""], ["proof (prove)\nusing this:\n  \\<exists>s2'.\n     \\<tau>mRed2 s2 s2' \\<and>\n     s1 \\<approx>m s2' \\<and>\n     r1.final_threads s1 \\<subseteq> r2.final_threads s2' \\<and>\n     shr s2' = shr s2\n\ngoal (1 subgoal):\n 1. (\\<And>ls2 ts2 m2 ws2 is2.\n        \\<lbrakk>\\<tau>mRed2 s2 (ls2, (ts2, m2), ws2, is2);\n         s1 \\<approx>m (ls2, (ts2, m2), ws2, is2); m2 = shr s2;\n         \\<And>t.\n            r1.final_thread s1 t \\<Longrightarrow>\n            r2.final_thread (ls2, (ts2, m2), ws2, is2) t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<tau>mRed2 s2 (ls2, (ts2, m2), ws2, is2)\n  s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\n  m2 = shr s2\n  r1.final_thread s1 ?t14 \\<Longrightarrow>\n  r2.final_thread (ls2, (ts2, m2), ws2, is2) ?t14\n\ngoal (2 subgoals):\n 1. \\<exists>t. r1.not_final_thread s1 t \\<Longrightarrow>\n    \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and> r2.deadlock s2' \\<and> s1 \\<approx>m s2'\n 2. \\<nexists>t. r1.not_final_thread s1 t \\<Longrightarrow>\n    \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and> r2.deadlock s2' \\<and> s1 \\<approx>m s2'", "from no_\\<tau>Move1_\\<tau>s_to_no_\\<tau>Move2[OF \\<open>s1 \\<approx>m (ls2, (ts2, m2), ws2, is2)\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>ts2'.\n     \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n      (ls2, (ts2', m2), ws2, is2) \\<and>\n     (\\<forall>t.\n         wset s1 t = None \\<and>\n         (\\<exists>x.\n             thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n             (\\<forall>x' m'.\n                 \\<not> r1.silent_move t (x, shr s1)\n                         (x', m'))) \\<longrightarrow>\n         wset (ls2, (ts2', m2), ws2, is2) t = None \\<and>\n         (\\<exists>x.\n             thr (ls2, (ts2', m2), ws2, is2) t =\n             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n             (\\<forall>x' m'.\n                 \\<not> r2.silent_move t\n                         (x, shr (ls2, (ts2', m2), ws2, is2))\n                         (x', m')))) \\<and>\n     s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "obtain ts2' where red2: \"r2.mthr.silent_moves (ls2, (ts2, m2), ws2, is2) (ls2, (ts2', m2), ws2, is2)\"\n    and no_\\<tau>: \"\\<And>t x1 x2 x2' m2'. \\<lbrakk> wset s1 t = None; thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>; ts2' t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>;\n                           \\<And>x' m'. r1.silent_move t (x1, shr s1) (x', m') \\<Longrightarrow> False \\<rbrakk>\n              \\<Longrightarrow>  \\<not> r2.silent_move t (x2, m2) (x2', m2')\"\n    and mbisim: \"s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\""], ["proof (prove)\nusing this:\n  \\<exists>ts2'.\n     \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n      (ls2, (ts2', m2), ws2, is2) \\<and>\n     (\\<forall>t.\n         wset s1 t = None \\<and>\n         (\\<exists>x.\n             thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n             (\\<forall>x' m'.\n                 \\<not> r1.silent_move t (x, shr s1)\n                         (x', m'))) \\<longrightarrow>\n         wset (ls2, (ts2', m2), ws2, is2) t = None \\<and>\n         (\\<exists>x.\n             thr (ls2, (ts2', m2), ws2, is2) t =\n             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n             (\\<forall>x' m'.\n                 \\<not> r2.silent_move t\n                         (x, shr (ls2, (ts2', m2), ws2, is2))\n                         (x', m')))) \\<and>\n     s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. (\\<And>ts2'.\n        \\<lbrakk>\\<tau>mRed2 (ls2, (ts2, m2), ws2, is2)\n                  (ls2, (ts2', m2), ws2, is2);\n         \\<And>t x1 x2 x2' m2'.\n            \\<lbrakk>wset s1 t = None;\n             thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>;\n             ts2' t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>;\n             \\<And>x' m'.\n                r1.silent_move t (x1, shr s1) (x', m') \\<Longrightarrow>\n                False\\<rbrakk>\n            \\<Longrightarrow> \\<not> r2.silent_move t (x2, m2) (x2', m2');\n         s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2) (ls2, (ts2', m2), ws2, is2)\n  \\<lbrakk>wset s1 ?t14 = None;\n   thr s1 ?t14 = \\<lfloor>(?x1.14, no_wait_locks)\\<rfloor>;\n   ts2' ?t14 = \\<lfloor>(?x2.14, no_wait_locks)\\<rfloor>;\n   \\<And>x' m'.\n      r1.silent_move ?t14 (?x1.14, shr s1) (x', m') \\<Longrightarrow>\n      False\\<rbrakk>\n  \\<Longrightarrow> \\<not> r2.silent_move ?t14 (?x2.14, m2) (?x2'14, ?m2'14)\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n\ngoal (2 subgoals):\n 1. \\<exists>t. r1.not_final_thread s1 t \\<Longrightarrow>\n    \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and> r2.deadlock s2' \\<and> s1 \\<approx>m s2'\n 2. \\<nexists>t. r1.not_final_thread s1 t \\<Longrightarrow>\n    \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and> r2.deadlock s2' \\<and> s1 \\<approx>m s2'", "from mbisim"], ["proof (chain)\npicking this:\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "have mbisim_eqs: \"ls2 = locks s1\" \"ws2 = wset s1\" \"is2 = interrupts s1\""], ["proof (prove)\nusing this:\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. ls2 = locks s1 &&& ws2 = wset s1 &&& is2 = interrupts s1", "by(simp_all add: mbisim_def)"], ["proof (state)\nthis:\n  ls2 = locks s1\n  ws2 = wset s1\n  is2 = interrupts s1\n\ngoal (2 subgoals):\n 1. \\<exists>t. r1.not_final_thread s1 t \\<Longrightarrow>\n    \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and> r2.deadlock s2' \\<and> s1 \\<approx>m s2'\n 2. \\<nexists>t. r1.not_final_thread s1 t \\<Longrightarrow>\n    \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and> r2.deadlock s2' \\<and> s1 \\<approx>m s2'", "let ?s2 = \"(ls2, (ts2', m2), ws2, is2)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>t. r1.not_final_thread s1 t \\<Longrightarrow>\n    \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and> r2.deadlock s2' \\<and> s1 \\<approx>m s2'\n 2. \\<nexists>t. r1.not_final_thread s1 t \\<Longrightarrow>\n    \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and> r2.deadlock s2' \\<and> s1 \\<approx>m s2'", "from red2"], ["proof (chain)\npicking this:\n  \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2) (ls2, (ts2', m2), ws2, is2)", "have fin': \"\\<And>t. r1.final_thread s1 t \\<Longrightarrow> r2.final_thread ?s2 t\""], ["proof (prove)\nusing this:\n  \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2) (ls2, (ts2', m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       r1.final_thread s1 t \\<Longrightarrow>\n       r2.final_thread (ls2, (ts2', m2), ws2, is2) t", "by(rule r2.\\<tau>mRedT_preserves_final_thread)(rule fin)"], ["proof (state)\nthis:\n  r1.final_thread s1 ?t14 \\<Longrightarrow>\n  r2.final_thread (ls2, (ts2', m2), ws2, is2) ?t14\n\ngoal (2 subgoals):\n 1. \\<exists>t. r1.not_final_thread s1 t \\<Longrightarrow>\n    \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and> r2.deadlock s2' \\<and> s1 \\<approx>m s2'\n 2. \\<nexists>t. r1.not_final_thread s1 t \\<Longrightarrow>\n    \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and> r2.deadlock s2' \\<and> s1 \\<approx>m s2'", "have \"r2.deadlock ?s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r2.deadlock (ls2, (ts2', m2), ws2, is2)", "proof(rule r2.deadlockI, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final2 x; wset (ls2, (ts2', m2), ws2, is2) t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x,\n                         shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                         \\<wrong>2 \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                             \\<wrong>2 \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 r2.must_wait (ls2, (ts2', m2), ws2, is2) t\n                                  lt (dom\n (thr (ls2, (ts2', m2), ws2, is2)))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 3. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "case (1 t x2)"], ["proof (state)\nthis:\n  thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>\n  \\<not> final2 x2\n  wset (ls2, (ts2', m2), ws2, is2) t = None\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final2 x; wset (ls2, (ts2', m2), ws2, is2) t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x,\n                         shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                         \\<wrong>2 \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                             \\<wrong>2 \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 r2.must_wait (ls2, (ts2', m2), ws2, is2) t\n                                  lt (dom\n (thr (ls2, (ts2', m2), ws2, is2)))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 3. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "note ts2t = \\<open>thr ?s2 t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>\\<close>"], ["proof (state)\nthis:\n  thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final2 x; wset (ls2, (ts2', m2), ws2, is2) t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x,\n                         shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                         \\<wrong>2 \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                             \\<wrong>2 \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 r2.must_wait (ls2, (ts2', m2), ws2, is2) t\n                                  lt (dom\n (thr (ls2, (ts2', m2), ws2, is2)))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 3. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "with mbisim"], ["proof (chain)\npicking this:\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n  thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>", "obtain x1 where ts1t: \"thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>\"\n      and bisim: \"t \\<turnstile> (x1, shr s1) \\<approx> (x2, m2)\""], ["proof (prove)\nusing this:\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n  thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>x1.\n        \\<lbrakk>thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>;\n         t \\<turnstile> (x1, shr s1) \\<approx> (x2, m2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: mbisim_thrD2)"], ["proof (state)\nthis:\n  thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>\n  t \\<turnstile> (x1, shr s1) \\<approx> (x2, m2)\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final2 x; wset (ls2, (ts2', m2), ws2, is2) t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x,\n                         shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                         \\<wrong>2 \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                             \\<wrong>2 \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 r2.must_wait (ls2, (ts2', m2), ws2, is2) t\n                                  lt (dom\n (thr (ls2, (ts2', m2), ws2, is2)))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 3. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "from \\<open>wset ?s2 t = None\\<close> mbisim"], ["proof (chain)\npicking this:\n  wset (ls2, (ts2', m2), ws2, is2) t = None\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "have ws1t: \"wset s1 t = None\""], ["proof (prove)\nusing this:\n  wset (ls2, (ts2', m2), ws2, is2) t = None\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. wset s1 t = None", "by(simp add: mbisim_def)"], ["proof (state)\nthis:\n  wset s1 t = None\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final2 x; wset (ls2, (ts2', m2), ws2, is2) t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x,\n                         shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                         \\<wrong>2 \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                             \\<wrong>2 \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 r2.must_wait (ls2, (ts2', m2), ws2, is2) t\n                                  lt (dom\n (thr (ls2, (ts2', m2), ws2, is2)))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 3. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "have \"\\<not> final1 x1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> final1 x1", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. final1 x1 \\<Longrightarrow> False", "assume \"final1 x1\""], ["proof (state)\nthis:\n  final1 x1\n\ngoal (1 subgoal):\n 1. final1 x1 \\<Longrightarrow> False", "with ts1t ws1t"], ["proof (chain)\npicking this:\n  thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>\n  wset s1 t = None\n  final1 x1", "have \"r1.final_thread s1 t\""], ["proof (prove)\nusing this:\n  thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>\n  wset s1 t = None\n  final1 x1\n\ngoal (1 subgoal):\n 1. r1.final_thread s1 t", "by(simp add: r1.final_thread_def)"], ["proof (state)\nthis:\n  r1.final_thread s1 t\n\ngoal (1 subgoal):\n 1. final1 x1 \\<Longrightarrow> False", "hence \"r2.final_thread ?s2 t\""], ["proof (prove)\nusing this:\n  r1.final_thread s1 t\n\ngoal (1 subgoal):\n 1. r2.final_thread (ls2, (ts2', m2), ws2, is2) t", "by(rule fin')"], ["proof (state)\nthis:\n  r2.final_thread (ls2, (ts2', m2), ws2, is2) t\n\ngoal (1 subgoal):\n 1. final1 x1 \\<Longrightarrow> False", "with \\<open>\\<not> final2 x2\\<close> ts2t \\<open>wset ?s2 t = None\\<close>"], ["proof (chain)\npicking this:\n  \\<not> final2 x2\n  thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>\n  wset (ls2, (ts2', m2), ws2, is2) t = None\n  r2.final_thread (ls2, (ts2', m2), ws2, is2) t", "show False"], ["proof (prove)\nusing this:\n  \\<not> final2 x2\n  thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>\n  wset (ls2, (ts2', m2), ws2, is2) t = None\n  r2.final_thread (ls2, (ts2', m2), ws2, is2) t\n\ngoal (1 subgoal):\n 1. False", "by(simp add: r2.final_thread_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> final1 x1\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final2 x; wset (ls2, (ts2', m2), ws2, is2) t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x,\n                         shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                         \\<wrong>2 \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                             \\<wrong>2 \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 r2.must_wait (ls2, (ts2', m2), ws2, is2) t\n                                  lt (dom\n (thr (ls2, (ts2', m2), ws2, is2)))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 3. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "from r1.deadlockD1[OF dead ts1t this \\<open>wset s1 t = None\\<close>]"], ["proof (chain)\npicking this:\n  (\\<lbrakk>t \\<turnstile> \\<langle>x1, shr s1\\<rangle> \\<wrong>1;\n    \\<forall>LT.\n       t \\<turnstile> \\<langle>x1, shr s1\\<rangle> LT\n       \\<wrong>1 \\<longrightarrow>\n       (\\<exists>lt\\<in>LT. r1.must_wait s1 t lt (dom (thr s1)))\\<rbrakk>\n   \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "have ms: \"r1.must_sync t x1 (shr s1)\"\n      and csmw: \"\\<And>LT. r1.can_sync t x1 (shr s1) LT \\<Longrightarrow> \\<exists>lt\\<in>LT. r1.must_wait s1 t lt (dom (thr s1))\""], ["proof (prove)\nusing this:\n  (\\<lbrakk>t \\<turnstile> \\<langle>x1, shr s1\\<rangle> \\<wrong>1;\n    \\<forall>LT.\n       t \\<turnstile> \\<langle>x1, shr s1\\<rangle> LT\n       \\<wrong>1 \\<longrightarrow>\n       (\\<exists>lt\\<in>LT. r1.must_wait s1 t lt (dom (thr s1)))\\<rbrakk>\n   \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. t \\<turnstile> \\<langle>x1, shr s1\\<rangle> \\<wrong>1 &&&\n    (\\<And>LT.\n        t \\<turnstile> \\<langle>x1, shr s1\\<rangle> LT\n        \\<wrong>1 \\<Longrightarrow>\n        \\<exists>lt\\<in>LT. r1.must_wait s1 t lt (dom (thr s1)))", "by blast+"], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x1, shr s1\\<rangle> \\<wrong>1\n  t \\<turnstile> \\<langle>x1, shr s1\\<rangle> ?LT14\n  \\<wrong>1 \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT14. r1.must_wait s1 t lt (dom (thr s1))\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final2 x; wset (ls2, (ts2', m2), ws2, is2) t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x,\n                         shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                         \\<wrong>2 \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                             \\<wrong>2 \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 r2.must_wait (ls2, (ts2', m2), ws2, is2) t\n                                  lt (dom\n (thr (ls2, (ts2', m2), ws2, is2)))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 3. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "{"], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x1, shr s1\\<rangle> \\<wrong>1\n  t \\<turnstile> \\<langle>x1, shr s1\\<rangle> ?LT14\n  \\<wrong>1 \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT14. r1.must_wait s1 t lt (dom (thr s1))\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final2 x; wset (ls2, (ts2', m2), ws2, is2) t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x,\n                         shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                         \\<wrong>2 \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                             \\<wrong>2 \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 r2.must_wait (ls2, (ts2', m2), ws2, is2) t\n                                  lt (dom\n (thr (ls2, (ts2', m2), ws2, is2)))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 3. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "from \\<open>r1.must_sync t x1 (shr s1)\\<close>"], ["proof (chain)\npicking this:\n  t \\<turnstile> \\<langle>x1, shr s1\\<rangle> \\<wrong>1", "obtain ta1 x1' m1'\n        where r1: \"t \\<turnstile> (x1, shr s1) -1-ta1\\<rightarrow> (x1', m1')\"\n        and s1': \"\\<exists>s1'. r1.actions_ok s1' t ta1\""], ["proof (prove)\nusing this:\n  t \\<turnstile> \\<langle>x1, shr s1\\<rangle> \\<wrong>1\n\ngoal (1 subgoal):\n 1. (\\<And>ta1 x1' m1'.\n        \\<lbrakk>r1.r_syntax t x1 (shr s1) ta1 x1' m1';\n         \\<exists>s1'. r1.actions_ok s1' t ta1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim: r1.must_syncE)"], ["proof (state)\nthis:\n  r1.r_syntax t x1 (shr s1) ta1 x1' m1'\n  \\<exists>s1'. r1.actions_ok s1' t ta1\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final2 x; wset (ls2, (ts2', m2), ws2, is2) t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x,\n                         shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                         \\<wrong>2 \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                             \\<wrong>2 \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 r2.must_wait (ls2, (ts2', m2), ws2, is2) t\n                                  lt (dom\n (thr (ls2, (ts2', m2), ws2, is2)))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 3. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "have \"\\<not> \\<tau>move1 (x1, shr s1) ta1 (x1', m1')\" (is \"\\<not> ?\\<tau>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<tau>move1 (x1, shr s1) ta1 (x1', m1')", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<tau>move1 (x1, shr s1) ta1 (x1', m1') \\<Longrightarrow> False", "assume \"?\\<tau>\""], ["proof (state)\nthis:\n  \\<tau>move1 (x1, shr s1) ta1 (x1', m1')\n\ngoal (1 subgoal):\n 1. \\<tau>move1 (x1, shr s1) ta1 (x1', m1') \\<Longrightarrow> False", "hence \"ta1 = \\<epsilon>\""], ["proof (prove)\nusing this:\n  \\<tau>move1 (x1, shr s1) ta1 (x1', m1')\n\ngoal (1 subgoal):\n 1. ta1 = \\<lbrace>\\<rbrace>", "by(rule r1.silent_tl)"], ["proof (state)\nthis:\n  ta1 = \\<lbrace>\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<tau>move1 (x1, shr s1) ta1 (x1', m1') \\<Longrightarrow> False", "with r1"], ["proof (chain)\npicking this:\n  r1.r_syntax t x1 (shr s1) ta1 x1' m1'\n  ta1 = \\<lbrace>\\<rbrace>", "have \"r1.can_sync t x1 (shr s1) {}\""], ["proof (prove)\nusing this:\n  r1.r_syntax t x1 (shr s1) ta1 x1' m1'\n  ta1 = \\<lbrace>\\<rbrace>\n\ngoal (1 subgoal):\n 1. t \\<turnstile> \\<langle>x1, shr s1\\<rangle> {} \\<wrong>1", "by(auto intro!: r1.can_syncI simp add: collect_locks_def collect_interrupts_def)"], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x1, shr s1\\<rangle> {} \\<wrong>1\n\ngoal (1 subgoal):\n 1. \\<tau>move1 (x1, shr s1) ta1 (x1', m1') \\<Longrightarrow> False", "from csmw[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>lt\\<in>{}. r1.must_wait s1 t lt (dom (thr s1))", "show False"], ["proof (prove)\nusing this:\n  \\<exists>lt\\<in>{}. r1.must_wait s1 t lt (dom (thr s1))\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> \\<tau>move1 (x1, shr s1) ta1 (x1', m1')\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final2 x; wset (ls2, (ts2', m2), ws2, is2) t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x,\n                         shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                         \\<wrong>2 \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                             \\<wrong>2 \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 r2.must_wait (ls2, (ts2', m2), ws2, is2) t\n                                  lt (dom\n (thr (ls2, (ts2', m2), ws2, is2)))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 3. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "from simulation1[OF bisim r1 this]"], ["proof (chain)\npicking this:\n  \\<exists>s2' s2'' tl2.\n     r2.silent_moves t (x2, m2) s2' \\<and>\n     t \\<turnstile> s2' -2-tl2\\<rightarrow> s2'' \\<and>\n     \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n     t \\<turnstile> (x1', m1') \\<approx> s2'' \\<and> ta1 \\<sim>m tl2", "obtain x2' m2' x2'' m2'' ta2 where r2: \"r2.silent_moves t (x2, m2) (x2', m2')\"\n        and r2': \"t \\<turnstile> (x2', m2') -2-ta2\\<rightarrow>  (x2'', m2'')\"\n        and bisim': \"t \\<turnstile> (x1', m1') \\<approx> (x2'', m2'')\" and tasim: \"ta1 \\<sim>m ta2\""], ["proof (prove)\nusing this:\n  \\<exists>s2' s2'' tl2.\n     r2.silent_moves t (x2, m2) s2' \\<and>\n     t \\<turnstile> s2' -2-tl2\\<rightarrow> s2'' \\<and>\n     \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n     t \\<turnstile> (x1', m1') \\<approx> s2'' \\<and> ta1 \\<sim>m tl2\n\ngoal (1 subgoal):\n 1. (\\<And>x2' m2' ta2 x2'' m2''.\n        \\<lbrakk>r2.silent_moves t (x2, m2) (x2', m2');\n         r2.r_syntax t x2' m2' ta2 x2'' m2'';\n         t \\<turnstile> (x1', m1') \\<approx> (x2'', m2'');\n         ta1 \\<sim>m ta2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  r2.silent_moves t (x2, m2) (x2', m2')\n  r2.r_syntax t x2' m2' ta2 x2'' m2''\n  t \\<turnstile> (x1', m1') \\<approx> (x2'', m2'')\n  ta1 \\<sim>m ta2\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final2 x; wset (ls2, (ts2', m2), ws2, is2) t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x,\n                         shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                         \\<wrong>2 \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                             \\<wrong>2 \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 r2.must_wait (ls2, (ts2', m2), ws2, is2) t\n                                  lt (dom\n (thr (ls2, (ts2', m2), ws2, is2)))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 3. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "from r2"], ["proof (chain)\npicking this:\n  r2.silent_moves t (x2, m2) (x2', m2')", "have \"\\<exists>ta2 x2' m2' s2'. t \\<turnstile> (x2, m2) -2-ta2\\<rightarrow> (x2', m2') \\<and> r2.actions_ok s2' t ta2\""], ["proof (prove)\nusing this:\n  r2.silent_moves t (x2, m2) (x2', m2')\n\ngoal (1 subgoal):\n 1. \\<exists>ta2 x2' m2' s2'.\n       r2.r_syntax t x2 m2 ta2 x2' m2' \\<and> r2.actions_ok s2' t ta2", "proof(cases rule: converse_rtranclpE2[consumes 1, case_names base step])"], ["proof (state)\ngoal (2 subgoals):\n 1. (x2, m2) = (x2', m2') \\<Longrightarrow>\n    \\<exists>ta2 x2' m2' s2'.\n       r2.r_syntax t x2 m2 ta2 x2' m2' \\<and> r2.actions_ok s2' t ta2\n 2. \\<And>a b.\n       \\<lbrakk>r2.silent_move t (x2, m2) (a, b);\n        r2.silent_moves t (a, b) (x2', m2')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2' s2'.\n                            r2.r_syntax t x2 m2 ta2 x2' m2' \\<and>\n                            r2.actions_ok s2' t ta2", "case base"], ["proof (state)\nthis:\n  (x2, m2) = (x2', m2')\n\ngoal (2 subgoals):\n 1. (x2, m2) = (x2', m2') \\<Longrightarrow>\n    \\<exists>ta2 x2' m2' s2'.\n       r2.r_syntax t x2 m2 ta2 x2' m2' \\<and> r2.actions_ok s2' t ta2\n 2. \\<And>a b.\n       \\<lbrakk>r2.silent_move t (x2, m2) (a, b);\n        r2.silent_moves t (a, b) (x2', m2')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2' s2'.\n                            r2.r_syntax t x2 m2 ta2 x2' m2' \\<and>\n                            r2.actions_ok s2' t ta2", "from r2'[folded base] s1'[unfolded ex_actions_ok1_conv_ex_actions_ok2[OF tasim]]"], ["proof (chain)\npicking this:\n  r2.r_syntax t x2 m2 ta2 x2'' m2''\n  \\<exists>s2. r2.actions_ok s2 t ta2", "show ?thesis"], ["proof (prove)\nusing this:\n  r2.r_syntax t x2 m2 ta2 x2'' m2''\n  \\<exists>s2. r2.actions_ok s2 t ta2\n\ngoal (1 subgoal):\n 1. \\<exists>ta2 x2' m2' s2'.\n       r2.r_syntax t x2 m2 ta2 x2' m2' \\<and> r2.actions_ok s2' t ta2", "by blast"], ["proof (state)\nthis:\n  \\<exists>ta2 x2' m2' s2'.\n     r2.r_syntax t x2 m2 ta2 x2' m2' \\<and> r2.actions_ok s2' t ta2\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>r2.silent_move t (x2, m2) (a, b);\n        r2.silent_moves t (a, b) (x2', m2')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2' s2'.\n                            r2.r_syntax t x2 m2 ta2 x2' m2' \\<and>\n                            r2.actions_ok s2' t ta2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>r2.silent_move t (x2, m2) (a, b);\n        r2.silent_moves t (a, b) (x2', m2')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2' s2'.\n                            r2.r_syntax t x2 m2 ta2 x2' m2' \\<and>\n                            r2.actions_ok s2' t ta2", "case (step x2''' m2''')"], ["proof (state)\nthis:\n  r2.silent_move t (x2, m2) (x2''', m2''')\n  r2.silent_moves t (x2''', m2''') (x2', m2')\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>r2.silent_move t (x2, m2) (a, b);\n        r2.silent_moves t (a, b) (x2', m2')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2' s2'.\n                            r2.r_syntax t x2 m2 ta2 x2' m2' \\<and>\n                            r2.actions_ok s2' t ta2", "hence \"t \\<turnstile> (x2, m2) -2-\\<epsilon>\\<rightarrow> (x2''', m2''')\""], ["proof (prove)\nusing this:\n  r2.silent_move t (x2, m2) (x2''', m2''')\n  r2.silent_moves t (x2''', m2''') (x2', m2')\n\ngoal (1 subgoal):\n 1. r2.r_syntax t x2 m2 \\<lbrace>\\<rbrace> x2''' m2'''", "by(auto dest: r2.silent_tl)"], ["proof (state)\nthis:\n  r2.r_syntax t x2 m2 \\<lbrace>\\<rbrace> x2''' m2'''\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>r2.silent_move t (x2, m2) (a, b);\n        r2.silent_moves t (a, b) (x2', m2')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2' s2'.\n                            r2.r_syntax t x2 m2 ta2 x2' m2' \\<and>\n                            r2.actions_ok s2' t ta2", "moreover"], ["proof (state)\nthis:\n  r2.r_syntax t x2 m2 \\<lbrace>\\<rbrace> x2''' m2'''\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>r2.silent_move t (x2, m2) (a, b);\n        r2.silent_moves t (a, b) (x2', m2')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2' s2'.\n                            r2.r_syntax t x2 m2 ta2 x2' m2' \\<and>\n                            r2.actions_ok s2' t ta2", "have \"r2.actions_ok (undefined, (undefined, undefined), Map.empty, undefined) t \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r2.actions_ok (undefined, (undefined, undefined), Map.empty, undefined)\n     t \\<lbrace>\\<rbrace>", "by auto"], ["proof (state)\nthis:\n  r2.actions_ok (undefined, (undefined, undefined), Map.empty, undefined) t\n   \\<lbrace>\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>r2.silent_move t (x2, m2) (a, b);\n        r2.silent_moves t (a, b) (x2', m2')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2' s2'.\n                            r2.r_syntax t x2 m2 ta2 x2' m2' \\<and>\n                            r2.actions_ok s2' t ta2", "ultimately"], ["proof (chain)\npicking this:\n  r2.r_syntax t x2 m2 \\<lbrace>\\<rbrace> x2''' m2'''\n  r2.actions_ok (undefined, (undefined, undefined), Map.empty, undefined) t\n   \\<lbrace>\\<rbrace>", "show ?thesis"], ["proof (prove)\nusing this:\n  r2.r_syntax t x2 m2 \\<lbrace>\\<rbrace> x2''' m2'''\n  r2.actions_ok (undefined, (undefined, undefined), Map.empty, undefined) t\n   \\<lbrace>\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<exists>ta2 x2' m2' s2'.\n       r2.r_syntax t x2 m2 ta2 x2' m2' \\<and> r2.actions_ok s2' t ta2", "by-(rule exI conjI|assumption)+"], ["proof (state)\nthis:\n  \\<exists>ta2 x2' m2' s2'.\n     r2.r_syntax t x2 m2 ta2 x2' m2' \\<and> r2.actions_ok s2' t ta2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ta2 x2' m2' s2'.\n     r2.r_syntax t x2 m2 ta2 x2' m2' \\<and> r2.actions_ok s2' t ta2\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final2 x; wset (ls2, (ts2', m2), ws2, is2) t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x,\n                         shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                         \\<wrong>2 \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                             \\<wrong>2 \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 r2.must_wait (ls2, (ts2', m2), ws2, is2) t\n                                  lt (dom\n (thr (ls2, (ts2', m2), ws2, is2)))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 3. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "hence \"r2.must_sync t x2 m2\""], ["proof (prove)\nusing this:\n  \\<exists>ta2 x2' m2' s2'.\n     r2.r_syntax t x2 m2 ta2 x2' m2' \\<and> r2.actions_ok s2' t ta2\n\ngoal (1 subgoal):\n 1. t \\<turnstile> \\<langle>x2, m2\\<rangle> \\<wrong>2", "unfolding r2.must_sync_def2"], ["proof (prove)\nusing this:\n  \\<exists>ta2 x2' m2' s2'.\n     r2.r_syntax t x2 m2 ta2 x2' m2' \\<and> r2.actions_ok s2' t ta2\n\ngoal (1 subgoal):\n 1. \\<exists>taa x' m' s.\n       r2.r_syntax t x2 m2 taa x' m' \\<and> r2.actions_ok s t taa", "."], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x2, m2\\<rangle> \\<wrong>2\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final2 x; wset (ls2, (ts2', m2), ws2, is2) t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x,\n                         shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                         \\<wrong>2 \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                             \\<wrong>2 \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 r2.must_wait (ls2, (ts2', m2), ws2, is2) t\n                                  lt (dom\n (thr (ls2, (ts2', m2), ws2, is2)))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 3. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "}"], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x2, m2\\<rangle> \\<wrong>2\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final2 x; wset (ls2, (ts2', m2), ws2, is2) t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x,\n                         shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                         \\<wrong>2 \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                             \\<wrong>2 \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 r2.must_wait (ls2, (ts2', m2), ws2, is2) t\n                                  lt (dom\n (thr (ls2, (ts2', m2), ws2, is2)))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 3. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "moreover"], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x2, m2\\<rangle> \\<wrong>2\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final2 x; wset (ls2, (ts2', m2), ws2, is2) t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x,\n                         shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                         \\<wrong>2 \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                             \\<wrong>2 \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 r2.must_wait (ls2, (ts2', m2), ws2, is2) t\n                                  lt (dom\n (thr (ls2, (ts2', m2), ws2, is2)))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 3. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "{"], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x2, m2\\<rangle> \\<wrong>2\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final2 x; wset (ls2, (ts2', m2), ws2, is2) t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x,\n                         shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                         \\<wrong>2 \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                             \\<wrong>2 \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 r2.must_wait (ls2, (ts2', m2), ws2, is2) t\n                                  lt (dom\n (thr (ls2, (ts2', m2), ws2, is2)))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 3. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "fix LT"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final2 x; wset (ls2, (ts2', m2), ws2, is2) t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x,\n                         shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                         \\<wrong>2 \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                             \\<wrong>2 \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 r2.must_wait (ls2, (ts2', m2), ws2, is2) t\n                                  lt (dom\n (thr (ls2, (ts2', m2), ws2, is2)))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 3. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "assume \"r2.can_sync t x2 m2 LT\""], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x2, m2\\<rangle> LT \\<wrong>2\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final2 x; wset (ls2, (ts2', m2), ws2, is2) t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x,\n                         shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                         \\<wrong>2 \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                             \\<wrong>2 \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 r2.must_wait (ls2, (ts2', m2), ws2, is2) t\n                                  lt (dom\n (thr (ls2, (ts2', m2), ws2, is2)))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 3. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "then"], ["proof (chain)\npicking this:\n  t \\<turnstile> \\<langle>x2, m2\\<rangle> LT \\<wrong>2", "obtain ta2 x2' m2' where r2: \"t \\<turnstile> (x2, m2) -2-ta2\\<rightarrow> (x2', m2')\"\n        and LT: \"LT = collect_locks \\<lbrace>ta2\\<rbrace>\\<^bsub>l\\<^esub> <+> collect_cond_actions \\<lbrace>ta2\\<rbrace>\\<^bsub>c\\<^esub> <+> collect_interrupts \\<lbrace>ta2\\<rbrace>\\<^bsub>i\\<^esub>\""], ["proof (prove)\nusing this:\n  t \\<turnstile> \\<langle>x2, m2\\<rangle> LT \\<wrong>2\n\ngoal (1 subgoal):\n 1. (\\<And>ta2 x2' m2'.\n        \\<lbrakk>r2.r_syntax t x2 m2 ta2 x2' m2';\n         LT = collect_waits ta2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim: r2.can_syncE)"], ["proof (state)\nthis:\n  r2.r_syntax t x2 m2 ta2 x2' m2'\n  LT = collect_waits ta2\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final2 x; wset (ls2, (ts2', m2), ws2, is2) t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x,\n                         shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                         \\<wrong>2 \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                             \\<wrong>2 \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 r2.must_wait (ls2, (ts2', m2), ws2, is2) t\n                                  lt (dom\n (thr (ls2, (ts2', m2), ws2, is2)))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 3. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "from ts2t"], ["proof (chain)\npicking this:\n  thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>", "have \"ts2' t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>\""], ["proof (prove)\nusing this:\n  thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. ts2' t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  ts2' t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final2 x; wset (ls2, (ts2', m2), ws2, is2) t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x,\n                         shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                         \\<wrong>2 \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                             \\<wrong>2 \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 r2.must_wait (ls2, (ts2', m2), ws2, is2) t\n                                  lt (dom\n (thr (ls2, (ts2', m2), ws2, is2)))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 3. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "with ws1t ts1t"], ["proof (chain)\npicking this:\n  wset s1 t = None\n  thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>\n  ts2' t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>", "have \"\\<not> r2.silent_move t (x2, m2) (x2', m2')\""], ["proof (prove)\nusing this:\n  wset s1 t = None\n  thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>\n  ts2' t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<not> r2.silent_move t (x2, m2) (x2', m2')", "proof(rule no_\\<tau>)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x' m'.\n       r1.silent_move t (x1, shr s1) (x', m') \\<Longrightarrow> False", "fix x1' m1'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x' m'.\n       r1.silent_move t (x1, shr s1) (x', m') \\<Longrightarrow> False", "assume \"r1.silent_move t (x1, shr s1) (x1', m1')\""], ["proof (state)\nthis:\n  r1.silent_move t (x1, shr s1) (x1', m1')\n\ngoal (1 subgoal):\n 1. \\<And>x' m'.\n       r1.silent_move t (x1, shr s1) (x', m') \\<Longrightarrow> False", "hence \"t \\<turnstile> (x1, shr s1) -1-\\<epsilon>\\<rightarrow> (x1', m1')\""], ["proof (prove)\nusing this:\n  r1.silent_move t (x1, shr s1) (x1', m1')\n\ngoal (1 subgoal):\n 1. r1.r_syntax t x1 (shr s1) \\<lbrace>\\<rbrace> x1' m1'", "by(auto dest: r1.silent_tl)"], ["proof (state)\nthis:\n  r1.r_syntax t x1 (shr s1) \\<lbrace>\\<rbrace> x1' m1'\n\ngoal (1 subgoal):\n 1. \\<And>x' m'.\n       r1.silent_move t (x1, shr s1) (x', m') \\<Longrightarrow> False", "hence \"r1.can_sync t x1 (shr s1) {}\""], ["proof (prove)\nusing this:\n  r1.r_syntax t x1 (shr s1) \\<lbrace>\\<rbrace> x1' m1'\n\ngoal (1 subgoal):\n 1. t \\<turnstile> \\<langle>x1, shr s1\\<rangle> {} \\<wrong>1", "by(auto intro: r1.can_syncI simp add: collect_locks_def collect_interrupts_def)"], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x1, shr s1\\<rangle> {} \\<wrong>1\n\ngoal (1 subgoal):\n 1. \\<And>x' m'.\n       r1.silent_move t (x1, shr s1) (x', m') \\<Longrightarrow> False", "with csmw[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>lt\\<in>{}. r1.must_wait s1 t lt (dom (thr s1))\n  t \\<turnstile> \\<langle>x1, shr s1\\<rangle> {} \\<wrong>1", "show False"], ["proof (prove)\nusing this:\n  \\<exists>lt\\<in>{}. r1.must_wait s1 t lt (dom (thr s1))\n  t \\<turnstile> \\<langle>x1, shr s1\\<rangle> {} \\<wrong>1\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> r2.silent_move t (x2, m2) (x2', m2')\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final2 x; wset (ls2, (ts2', m2), ws2, is2) t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x,\n                         shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                         \\<wrong>2 \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                             \\<wrong>2 \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 r2.must_wait (ls2, (ts2', m2), ws2, is2) t\n                                  lt (dom\n (thr (ls2, (ts2', m2), ws2, is2)))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 3. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "with r2"], ["proof (chain)\npicking this:\n  r2.r_syntax t x2 m2 ta2 x2' m2'\n  \\<not> r2.silent_move t (x2, m2) (x2', m2')", "have \"\\<not> \\<tau>move2 (x2, m2) ta2 (x2', m2')\""], ["proof (prove)\nusing this:\n  r2.r_syntax t x2 m2 ta2 x2' m2'\n  \\<not> r2.silent_move t (x2, m2) (x2', m2')\n\ngoal (1 subgoal):\n 1. \\<not> \\<tau>move2 (x2, m2) ta2 (x2', m2')", "by auto"], ["proof (state)\nthis:\n  \\<not> \\<tau>move2 (x2, m2) ta2 (x2', m2')\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final2 x; wset (ls2, (ts2', m2), ws2, is2) t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x,\n                         shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                         \\<wrong>2 \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                             \\<wrong>2 \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 r2.must_wait (ls2, (ts2', m2), ws2, is2) t\n                                  lt (dom\n (thr (ls2, (ts2', m2), ws2, is2)))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 3. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "from simulation2[OF bisim r2 this]"], ["proof (chain)\npicking this:\n  \\<exists>s1' s1'' tl1.\n     r1.silent_moves t (x1, shr s1) s1' \\<and>\n     t \\<turnstile> s1' -1-tl1\\<rightarrow> s1'' \\<and>\n     \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n     t \\<turnstile> s1'' \\<approx> (x2', m2') \\<and> tl1 \\<sim>m ta2", "obtain x1' m1' x1'' m1'' ta1\n        where \\<tau>r1: \"r1.silent_moves t (x1, shr s1) (x1', m1')\"\n        and r1: \"t \\<turnstile> (x1', m1') -1-ta1\\<rightarrow> (x1'', m1'')\"\n        and n\\<tau>1: \"\\<not> \\<tau>move1 (x1', m1') ta1 (x1'', m1'')\"\n        and bisim': \"t \\<turnstile> (x1'', m1'') \\<approx> (x2', m2')\"\n        and tlsim: \"ta1 \\<sim>m ta2\""], ["proof (prove)\nusing this:\n  \\<exists>s1' s1'' tl1.\n     r1.silent_moves t (x1, shr s1) s1' \\<and>\n     t \\<turnstile> s1' -1-tl1\\<rightarrow> s1'' \\<and>\n     \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n     t \\<turnstile> s1'' \\<approx> (x2', m2') \\<and> tl1 \\<sim>m ta2\n\ngoal (1 subgoal):\n 1. (\\<And>x1' m1' ta1 x1'' m1''.\n        \\<lbrakk>r1.silent_moves t (x1, shr s1) (x1', m1');\n         r1.r_syntax t x1' m1' ta1 x1'' m1'';\n         \\<not> \\<tau>move1 (x1', m1') ta1 (x1'', m1'');\n         t \\<turnstile> (x1'', m1'') \\<approx> (x2', m2');\n         ta1 \\<sim>m ta2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  r1.silent_moves t (x1, shr s1) (x1', m1')\n  r1.r_syntax t x1' m1' ta1 x1'' m1''\n  \\<not> \\<tau>move1 (x1', m1') ta1 (x1'', m1'')\n  t \\<turnstile> (x1'', m1'') \\<approx> (x2', m2')\n  ta1 \\<sim>m ta2\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final2 x; wset (ls2, (ts2', m2), ws2, is2) t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x,\n                         shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                         \\<wrong>2 \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                             \\<wrong>2 \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 r2.must_wait (ls2, (ts2', m2), ws2, is2) t\n                                  lt (dom\n (thr (ls2, (ts2', m2), ws2, is2)))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 3. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "from \\<tau>r1"], ["proof (chain)\npicking this:\n  r1.silent_moves t (x1, shr s1) (x1', m1')", "obtain [simp]: \"x1' = x1\" \"m1' = shr s1\""], ["proof (prove)\nusing this:\n  r1.silent_moves t (x1, shr s1) (x1', m1')\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>x1' = x1; m1' = shr s1\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(cases rule: converse_rtranclpE2[consumes 1, case_names refl step])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>x1' = x1; m1' = shr s1\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     (x1, shr s1) = (x1', m1')\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a b.\n       \\<lbrakk>\\<lbrakk>x1' = x1; m1' = shr s1\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        r1.silent_move t (x1, shr s1) (a, b);\n        r1.silent_moves t (a, b) (x1', m1')\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (step X M)"], ["proof (state)\nthis:\n  r1.silent_move t (x1, shr s1) (X, M)\n  r1.silent_moves t (X, M) (x1', m1')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>x1' = x1; m1' = shr s1\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     (x1, shr s1) = (x1', m1')\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a b.\n       \\<lbrakk>\\<lbrakk>x1' = x1; m1' = shr s1\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        r1.silent_move t (x1, shr s1) (a, b);\n        r1.silent_moves t (a, b) (x1', m1')\\<rbrakk>\n       \\<Longrightarrow> thesis", "from \\<open>r1.silent_move t (x1, shr s1) (X, M)\\<close>"], ["proof (chain)\npicking this:\n  r1.silent_move t (x1, shr s1) (X, M)", "have \"t \\<turnstile> (x1, shr s1) -1-\\<epsilon>\\<rightarrow> (X, M)\""], ["proof (prove)\nusing this:\n  r1.silent_move t (x1, shr s1) (X, M)\n\ngoal (1 subgoal):\n 1. r1.r_syntax t x1 (shr s1) \\<lbrace>\\<rbrace> X M", "by(auto dest: r1.silent_tl)"], ["proof (state)\nthis:\n  r1.r_syntax t x1 (shr s1) \\<lbrace>\\<rbrace> X M\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>x1' = x1; m1' = shr s1\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     (x1, shr s1) = (x1', m1')\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a b.\n       \\<lbrakk>\\<lbrakk>x1' = x1; m1' = shr s1\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        r1.silent_move t (x1, shr s1) (a, b);\n        r1.silent_moves t (a, b) (x1', m1')\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"r1.can_sync t x1 (shr s1) {}\""], ["proof (prove)\nusing this:\n  r1.r_syntax t x1 (shr s1) \\<lbrace>\\<rbrace> X M\n\ngoal (1 subgoal):\n 1. t \\<turnstile> \\<langle>x1, shr s1\\<rangle> {} \\<wrong>1", "by(auto intro: r1.can_syncI simp add: collect_locks_def collect_interrupts_def)"], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x1, shr s1\\<rangle> {} \\<wrong>1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>x1' = x1; m1' = shr s1\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     (x1, shr s1) = (x1', m1')\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a b.\n       \\<lbrakk>\\<lbrakk>x1' = x1; m1' = shr s1\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        r1.silent_move t (x1, shr s1) (a, b);\n        r1.silent_moves t (a, b) (x1', m1')\\<rbrakk>\n       \\<Longrightarrow> thesis", "with csmw[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>lt\\<in>{}. r1.must_wait s1 t lt (dom (thr s1))\n  t \\<turnstile> \\<langle>x1, shr s1\\<rangle> {} \\<wrong>1", "have False"], ["proof (prove)\nusing this:\n  \\<exists>lt\\<in>{}. r1.must_wait s1 t lt (dom (thr s1))\n  t \\<turnstile> \\<langle>x1, shr s1\\<rangle> {} \\<wrong>1\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>x1' = x1; m1' = shr s1\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     (x1, shr s1) = (x1', m1')\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a b.\n       \\<lbrakk>\\<lbrakk>x1' = x1; m1' = shr s1\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        r1.silent_move t (x1, shr s1) (a, b);\n        r1.silent_moves t (a, b) (x1', m1')\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>x1' = x1; m1' = shr s1\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     (x1, shr s1) = (x1', m1')\\<rbrakk>\n    \\<Longrightarrow> thesis", "qed blast"], ["proof (state)\nthis:\n  x1' = x1\n  m1' = shr s1\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final2 x; wset (ls2, (ts2', m2), ws2, is2) t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x,\n                         shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                         \\<wrong>2 \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                             \\<wrong>2 \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 r2.must_wait (ls2, (ts2', m2), ws2, is2) t\n                                  lt (dom\n (thr (ls2, (ts2', m2), ws2, is2)))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 3. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "from tlsim LT"], ["proof (chain)\npicking this:\n  ta1 \\<sim>m ta2\n  LT = collect_waits ta2", "have \"LT = collect_locks \\<lbrace>ta1\\<rbrace>\\<^bsub>l\\<^esub> <+> collect_cond_actions \\<lbrace>ta1\\<rbrace>\\<^bsub>c\\<^esub> <+> collect_interrupts \\<lbrace>ta1\\<rbrace>\\<^bsub>i\\<^esub>\""], ["proof (prove)\nusing this:\n  ta1 \\<sim>m ta2\n  LT = collect_waits ta2\n\ngoal (1 subgoal):\n 1. LT = collect_waits ta1", "by(auto simp add: ta_bisim_def)"], ["proof (state)\nthis:\n  LT = collect_waits ta1\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final2 x; wset (ls2, (ts2', m2), ws2, is2) t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x,\n                         shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                         \\<wrong>2 \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                             \\<wrong>2 \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 r2.must_wait (ls2, (ts2', m2), ws2, is2) t\n                                  lt (dom\n (thr (ls2, (ts2', m2), ws2, is2)))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 3. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "with r1"], ["proof (chain)\npicking this:\n  r1.r_syntax t x1' m1' ta1 x1'' m1''\n  LT = collect_waits ta1", "have \"r1.can_sync t x1 (shr s1) LT\""], ["proof (prove)\nusing this:\n  r1.r_syntax t x1' m1' ta1 x1'' m1''\n  LT = collect_waits ta1\n\ngoal (1 subgoal):\n 1. t \\<turnstile> \\<langle>x1, shr s1\\<rangle> LT \\<wrong>1", "by(auto intro: r1.can_syncI)"], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x1, shr s1\\<rangle> LT \\<wrong>1\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final2 x; wset (ls2, (ts2', m2), ws2, is2) t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x,\n                         shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                         \\<wrong>2 \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                             \\<wrong>2 \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 r2.must_wait (ls2, (ts2', m2), ws2, is2) t\n                                  lt (dom\n (thr (ls2, (ts2', m2), ws2, is2)))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 3. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "from csmw[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>lt\\<in>LT. r1.must_wait s1 t lt (dom (thr s1))", "obtain lt \n        where lt: \"lt \\<in> LT\" \"r1.must_wait s1 t lt (dom (thr s1))\""], ["proof (prove)\nusing this:\n  \\<exists>lt\\<in>LT. r1.must_wait s1 t lt (dom (thr s1))\n\ngoal (1 subgoal):\n 1. (\\<And>lt.\n        \\<lbrakk>lt \\<in> LT; r1.must_wait s1 t lt (dom (thr s1))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  lt \\<in> LT\n  r1.must_wait s1 t lt (dom (thr s1))\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final2 x; wset (ls2, (ts2', m2), ws2, is2) t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x,\n                         shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                         \\<wrong>2 \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                             \\<wrong>2 \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 r2.must_wait (ls2, (ts2', m2), ws2, is2) t\n                                  lt (dom\n (thr (ls2, (ts2', m2), ws2, is2)))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 3. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "from \\<open>r1.must_wait s1 t lt (dom (thr s1))\\<close>"], ["proof (chain)\npicking this:\n  r1.must_wait s1 t lt (dom (thr s1))", "have \"r2.must_wait ?s2 t lt (dom (thr ?s2))\""], ["proof (prove)\nusing this:\n  r1.must_wait s1 t lt (dom (thr s1))\n\ngoal (1 subgoal):\n 1. r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n     (dom (thr (ls2, (ts2', m2), ws2, is2)))", "proof(cases rule: r1.must_wait_elims)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>l t'.\n       \\<lbrakk>lt = Inl l; has_lock (locks s1 $ l) t'; t' \\<noteq> t;\n        t' \\<in> dom (thr s1)\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (dom (thr (ls2, (ts2', m2), ws2, is2)))\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); r1.not_final_thread s1 t';\n        t' \\<in> dom (thr s1)\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (dom (thr (ls2, (ts2', m2), ws2, is2)))\n 3. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t'); r1.all_final_except s1 (dom (thr s1));\n        t' \\<notin> interrupts s1\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (dom (thr (ls2, (ts2', m2), ws2, is2)))", "case (lock l)"], ["proof (state)\nthis:\n  lt = Inl l\n  has_lock (locks s1 $ l) t'_\n  t'_ \\<noteq> t\n  t'_ \\<in> dom (thr s1)\n\ngoal (3 subgoals):\n 1. \\<And>l t'.\n       \\<lbrakk>lt = Inl l; has_lock (locks s1 $ l) t'; t' \\<noteq> t;\n        t' \\<in> dom (thr s1)\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (dom (thr (ls2, (ts2', m2), ws2, is2)))\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); r1.not_final_thread s1 t';\n        t' \\<in> dom (thr s1)\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (dom (thr (ls2, (ts2', m2), ws2, is2)))\n 3. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t'); r1.all_final_except s1 (dom (thr s1));\n        t' \\<notin> interrupts s1\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (dom (thr (ls2, (ts2', m2), ws2, is2)))", "with mbisim_dom_eq[OF mbisim]"], ["proof (chain)\npicking this:\n  dom (thr s1) = dom (thr (ls2, (ts2', m2), ws2, is2))\n  lt = Inl l\n  has_lock (locks s1 $ l) t'_\n  t'_ \\<noteq> t\n  t'_ \\<in> dom (thr s1)", "show ?thesis"], ["proof (prove)\nusing this:\n  dom (thr s1) = dom (thr (ls2, (ts2', m2), ws2, is2))\n  lt = Inl l\n  has_lock (locks s1 $ l) t'_\n  t'_ \\<noteq> t\n  t'_ \\<in> dom (thr s1)\n\ngoal (1 subgoal):\n 1. r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n     (dom (thr (ls2, (ts2', m2), ws2, is2)))", "by(auto simp add: mbisim_eqs)"], ["proof (state)\nthis:\n  r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n   (dom (thr (ls2, (ts2', m2), ws2, is2)))\n\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); r1.not_final_thread s1 t';\n        t' \\<in> dom (thr s1)\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (dom (thr (ls2, (ts2', m2), ws2, is2)))\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t'); r1.all_final_except s1 (dom (thr s1));\n        t' \\<notin> interrupts s1\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (dom (thr (ls2, (ts2', m2), ws2, is2)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); r1.not_final_thread s1 t';\n        t' \\<in> dom (thr s1)\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (dom (thr (ls2, (ts2', m2), ws2, is2)))\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t'); r1.all_final_except s1 (dom (thr s1));\n        t' \\<notin> interrupts s1\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (dom (thr (ls2, (ts2', m2), ws2, is2)))", "case (join t')"], ["proof (state)\nthis:\n  lt = Inr (Inl t')\n  r1.not_final_thread s1 t'\n  t' \\<in> dom (thr s1)\n\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); r1.not_final_thread s1 t';\n        t' \\<in> dom (thr s1)\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (dom (thr (ls2, (ts2', m2), ws2, is2)))\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t'); r1.all_final_except s1 (dom (thr s1));\n        t' \\<notin> interrupts s1\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (dom (thr (ls2, (ts2', m2), ws2, is2)))", "from dead deadlock_mbisim_not_final_thread_pres[OF _ \\<open>r1.not_final_thread s1 t'\\<close> fin' mbisim]"], ["proof (chain)\npicking this:\n  r1.deadlock s1\n  \\<lbrakk>t' \\<in> r1.deadlocked s1 \\<or> r1.deadlock s1;\n   r1.final_thread s1 t' \\<Longrightarrow> r1.final_thread s1 t'\\<rbrakk>\n  \\<Longrightarrow> r2.not_final_thread (ls2, (ts2', m2), ws2, is2) t'", "have \"r2.not_final_thread ?s2 t'\""], ["proof (prove)\nusing this:\n  r1.deadlock s1\n  \\<lbrakk>t' \\<in> r1.deadlocked s1 \\<or> r1.deadlock s1;\n   r1.final_thread s1 t' \\<Longrightarrow> r1.final_thread s1 t'\\<rbrakk>\n  \\<Longrightarrow> r2.not_final_thread (ls2, (ts2', m2), ws2, is2) t'\n\ngoal (1 subgoal):\n 1. r2.not_final_thread (ls2, (ts2', m2), ws2, is2) t'", "by auto"], ["proof (state)\nthis:\n  r2.not_final_thread (ls2, (ts2', m2), ws2, is2) t'\n\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); r1.not_final_thread s1 t';\n        t' \\<in> dom (thr s1)\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (dom (thr (ls2, (ts2', m2), ws2, is2)))\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t'); r1.all_final_except s1 (dom (thr s1));\n        t' \\<notin> interrupts s1\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (dom (thr (ls2, (ts2', m2), ws2, is2)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  r2.not_final_thread (ls2, (ts2', m2), ws2, is2) t'\n\ngoal (1 subgoal):\n 1. r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n     (dom (thr (ls2, (ts2', m2), ws2, is2)))", "using join mbisim_dom_eq[OF mbisim]"], ["proof (prove)\nusing this:\n  r2.not_final_thread (ls2, (ts2', m2), ws2, is2) t'\n  lt = Inr (Inl t')\n  r1.not_final_thread s1 t'\n  t' \\<in> dom (thr s1)\n  dom (thr s1) = dom (thr (ls2, (ts2', m2), ws2, is2))\n\ngoal (1 subgoal):\n 1. r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n     (dom (thr (ls2, (ts2', m2), ws2, is2)))", "by auto"], ["proof (state)\nthis:\n  r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n   (dom (thr (ls2, (ts2', m2), ws2, is2)))\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t'); r1.all_final_except s1 (dom (thr s1));\n        t' \\<notin> interrupts s1\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (dom (thr (ls2, (ts2', m2), ws2, is2)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t'); r1.all_final_except s1 (dom (thr s1));\n        t' \\<notin> interrupts s1\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (dom (thr (ls2, (ts2', m2), ws2, is2)))", "case (interrupt t')"], ["proof (state)\nthis:\n  lt = Inr (Inr t')\n  r1.all_final_except s1 (dom (thr s1))\n  t' \\<notin> interrupts s1\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t'); r1.all_final_except s1 (dom (thr s1));\n        t' \\<notin> interrupts s1\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (dom (thr (ls2, (ts2', m2), ws2, is2)))", "have \"r2.all_final_except ?s2 (dom (thr ?s2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n     (dom (thr (ls2, (ts2', m2), ws2, is2)))", "by(auto intro!: r2.all_final_exceptI)"], ["proof (state)\nthis:\n  r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n   (dom (thr (ls2, (ts2', m2), ws2, is2)))\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t'); r1.all_final_except s1 (dom (thr s1));\n        t' \\<notin> interrupts s1\\<rbrakk>\n       \\<Longrightarrow> r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n                          (dom (thr (ls2, (ts2', m2), ws2, is2)))", "with interrupt"], ["proof (chain)\npicking this:\n  lt = Inr (Inr t')\n  r1.all_final_except s1 (dom (thr s1))\n  t' \\<notin> interrupts s1\n  r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n   (dom (thr (ls2, (ts2', m2), ws2, is2)))", "show ?thesis"], ["proof (prove)\nusing this:\n  lt = Inr (Inr t')\n  r1.all_final_except s1 (dom (thr s1))\n  t' \\<notin> interrupts s1\n  r2.all_final_except (ls2, (ts2', m2), ws2, is2)\n   (dom (thr (ls2, (ts2', m2), ws2, is2)))\n\ngoal (1 subgoal):\n 1. r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n     (dom (thr (ls2, (ts2', m2), ws2, is2)))", "by(auto simp add: mbisim_eqs)"], ["proof (state)\nthis:\n  r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n   (dom (thr (ls2, (ts2', m2), ws2, is2)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n   (dom (thr (ls2, (ts2', m2), ws2, is2)))\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final2 x; wset (ls2, (ts2', m2), ws2, is2) t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x,\n                         shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                         \\<wrong>2 \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                             \\<wrong>2 \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 r2.must_wait (ls2, (ts2', m2), ws2, is2) t\n                                  lt (dom\n (thr (ls2, (ts2', m2), ws2, is2)))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 3. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "with lt"], ["proof (chain)\npicking this:\n  lt \\<in> LT\n  r1.must_wait s1 t lt (dom (thr s1))\n  r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n   (dom (thr (ls2, (ts2', m2), ws2, is2)))", "have \"\\<exists>lt\\<in>LT. r2.must_wait ?s2 t lt (dom (thr ?s2))\""], ["proof (prove)\nusing this:\n  lt \\<in> LT\n  r1.must_wait s1 t lt (dom (thr s1))\n  r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n   (dom (thr (ls2, (ts2', m2), ws2, is2)))\n\ngoal (1 subgoal):\n 1. \\<exists>lt\\<in>LT.\n       r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n        (dom (thr (ls2, (ts2', m2), ws2, is2)))", "by blast"], ["proof (state)\nthis:\n  \\<exists>lt\\<in>LT.\n     r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n      (dom (thr (ls2, (ts2', m2), ws2, is2)))\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final2 x; wset (ls2, (ts2', m2), ws2, is2) t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x,\n                         shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                         \\<wrong>2 \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                             \\<wrong>2 \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 r2.must_wait (ls2, (ts2', m2), ws2, is2) t\n                                  lt (dom\n (thr (ls2, (ts2', m2), ws2, is2)))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 3. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "}"], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x2, m2\\<rangle> ?LT16 \\<wrong>2 \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT16.\n     r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n      (dom (thr (ls2, (ts2', m2), ws2, is2)))\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final2 x; wset (ls2, (ts2', m2), ws2, is2) t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x,\n                         shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n                         \\<wrong>2 \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x,\n                             shr (ls2, (ts2', m2), ws2, is2)\\<rangle> LT\n                             \\<wrong>2 \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 r2.must_wait (ls2, (ts2', m2), ws2, is2) t\n                                  lt (dom\n (thr (ls2, (ts2', m2), ws2, is2)))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 3. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "ultimately"], ["proof (chain)\npicking this:\n  t \\<turnstile> \\<langle>x2, m2\\<rangle> \\<wrong>2\n  t \\<turnstile> \\<langle>x2, m2\\<rangle> ?LT16 \\<wrong>2 \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT16.\n     r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n      (dom (thr (ls2, (ts2', m2), ws2, is2)))", "show ?case"], ["proof (prove)\nusing this:\n  t \\<turnstile> \\<langle>x2, m2\\<rangle> \\<wrong>2\n  t \\<turnstile> \\<langle>x2, m2\\<rangle> ?LT16 \\<wrong>2 \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT16.\n     r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n      (dom (thr (ls2, (ts2', m2), ws2, is2)))\n\ngoal (1 subgoal):\n 1. t \\<turnstile> \\<langle>x2, shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n    \\<wrong>2 \\<and>\n    (\\<forall>LT.\n        t \\<turnstile> \\<langle>x2, shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n        LT \\<wrong>2 \\<longrightarrow>\n        (\\<exists>lt\\<in>LT.\n            r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n             (dom (thr (ls2, (ts2', m2), ws2, is2)))))", "by fastforce"], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x2, shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n  \\<wrong>2 \\<and>\n  (\\<forall>LT.\n      t \\<turnstile> \\<langle>x2, shr (ls2, (ts2', m2), ws2, is2)\\<rangle>\n      LT \\<wrong>2 \\<longrightarrow>\n      (\\<exists>lt\\<in>LT.\n          r2.must_wait (ls2, (ts2', m2), ws2, is2) t lt\n           (dom (thr (ls2, (ts2', m2), ws2, is2)))))\n\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 2. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 2. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "case (2 t x2 ln l)"], ["proof (state)\nthis:\n  thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x2, ln)\\<rfloor>\n  0 < ln $ l\n  \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\n\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 2. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "note dead"], ["proof (state)\nthis:\n  r1.deadlock s1\n\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 2. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "moreover"], ["proof (state)\nthis:\n  r1.deadlock s1\n\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 2. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "from mbisim \\<open>thr ?s2 t = \\<lfloor>(x2, ln)\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n  thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x2, ln)\\<rfloor>", "obtain x1 where \"thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>\""], ["proof (prove)\nusing this:\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n  thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x2, ln)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>x1.\n        thr s1 t = \\<lfloor>(x1, ln)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: mbisim_thrD2)"], ["proof (state)\nthis:\n  thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 2. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "moreover"], ["proof (state)\nthis:\n  thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 2. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "note \\<open>0 < ln $ l\\<close>"], ["proof (state)\nthis:\n  0 < ln $ l\n\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 2. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "moreover"], ["proof (state)\nthis:\n  0 < ln $ l\n\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 2. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "from \\<open>\\<not> waiting (wset ?s2 t)\\<close> mbisim"], ["proof (chain)\npicking this:\n  \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)", "have \"\\<not> waiting (wset s1 t)\""], ["proof (prove)\nusing this:\n  \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. \\<not> waiting (wset s1 t)", "by(simp add: mbisim_def)"], ["proof (state)\nthis:\n  \\<not> waiting (wset s1 t)\n\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 2. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "ultimately"], ["proof (chain)\npicking this:\n  r1.deadlock s1\n  thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>\n  0 < ln $ l\n  \\<not> waiting (wset s1 t)", "obtain l' t' where \"0 < ln $ l'\" \"t \\<noteq> t'\" \"thr s1 t' \\<noteq> None\" \"has_lock (locks s1 $ l') t'\""], ["proof (prove)\nusing this:\n  r1.deadlock s1\n  thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>\n  0 < ln $ l\n  \\<not> waiting (wset s1 t)\n\ngoal (1 subgoal):\n 1. (\\<And>l' t'.\n        \\<lbrakk>0 < ln $ l'; t \\<noteq> t'; thr s1 t' \\<noteq> None;\n         has_lock (locks s1 $ l') t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule r1.deadlockD2)"], ["proof (state)\nthis:\n  0 < ln $ l'\n  t \\<noteq> t'\n  thr s1 t' \\<noteq> None\n  has_lock (locks s1 $ l') t'\n\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr (ls2, (ts2', m2), ws2, is2) t =\n                \\<lfloor>(x, ln)\\<rfloor>;\n        0 < ln $ l;\n        \\<not> waiting (wset (ls2, (ts2', m2), ws2, is2) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq>\n                            None \\<and>\n                            has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l)\n                             t'\n 2. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "thus ?case"], ["proof (prove)\nusing this:\n  0 < ln $ l'\n  t \\<noteq> t'\n  thr s1 t' \\<noteq> None\n  has_lock (locks s1 $ l') t'\n\ngoal (1 subgoal):\n 1. \\<exists>l t'.\n       0 < ln $ l \\<and>\n       t \\<noteq> t' \\<and>\n       thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq> None \\<and>\n       has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l) t'", "using mbisim_thrNone_eq[OF mbisim, of t'] mbisim"], ["proof (prove)\nusing this:\n  0 < ln $ l'\n  t \\<noteq> t'\n  thr s1 t' \\<noteq> None\n  has_lock (locks s1 $ l') t'\n  (thr s1 t' = None) = (thr (ls2, (ts2', m2), ws2, is2) t' = None)\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. \\<exists>l t'.\n       0 < ln $ l \\<and>\n       t \\<noteq> t' \\<and>\n       thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq> None \\<and>\n       has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l) t'", "by(auto simp add: mbisim_def)"], ["proof (state)\nthis:\n  \\<exists>l t'.\n     0 < ln $ l \\<and>\n     t \\<noteq> t' \\<and>\n     thr (ls2, (ts2', m2), ws2, is2) t' \\<noteq> None \\<and>\n     has_lock (locks (ls2, (ts2', m2), ws2, is2) $ l) t'\n\ngoal (1 subgoal):\n 1. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "case (3 t x2 w)"], ["proof (state)\nthis:\n  thr (ls2, (ts2', m2), ws2, is2) t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "from mbisim_thrD2[OF mbisim this]"], ["proof (chain)\npicking this:\n  \\<exists>x'.\n     thr s1 t = \\<lfloor>(x', no_wait_locks)\\<rfloor> \\<and>\n     t \\<turnstile> (x', shr s1)\n     \\<approx> (x2, shr (ls2, (ts2', m2), ws2, is2)) \\<and>\n     (wset (ls2, (ts2', m2), ws2, is2) t = None \\<or> x' \\<approx>w x2)", "obtain x1 where \"thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>\""], ["proof (prove)\nusing this:\n  \\<exists>x'.\n     thr s1 t = \\<lfloor>(x', no_wait_locks)\\<rfloor> \\<and>\n     t \\<turnstile> (x', shr s1)\n     \\<approx> (x2, shr (ls2, (ts2', m2), ws2, is2)) \\<and>\n     (wset (ls2, (ts2', m2), ws2, is2) t = None \\<or> x' \\<approx>w x2)\n\ngoal (1 subgoal):\n 1. (\\<And>x1.\n        thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "with dead"], ["proof (chain)\npicking this:\n  r1.deadlock s1\n  thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>", "have \"wset s1 t \\<noteq> \\<lfloor>PostWS w\\<rfloor>\""], ["proof (prove)\nusing this:\n  r1.deadlock s1\n  thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. wset s1 t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "by(rule r1.deadlockD3[rule_format])"], ["proof (state)\nthis:\n  wset s1 t \\<noteq> \\<lfloor>PostWS w\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>t x w.\n       thr (ls2, (ts2', m2), ws2, is2) t =\n       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset (ls2, (ts2', m2), ws2, is2) t \\<noteq>\n       \\<lfloor>PostWS w\\<rfloor>", "with mbisim"], ["proof (chain)\npicking this:\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n  wset s1 t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n  wset s1 t \\<noteq> \\<lfloor>PostWS w\\<rfloor>\n\ngoal (1 subgoal):\n 1. wset (ls2, (ts2', m2), ws2, is2) t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "by(simp add: mbisim_def)"], ["proof (state)\nthis:\n  wset (ls2, (ts2', m2), ws2, is2) t \\<noteq> \\<lfloor>PostWS w\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r2.deadlock (ls2, (ts2', m2), ws2, is2)\n\ngoal (2 subgoals):\n 1. \\<exists>t. r1.not_final_thread s1 t \\<Longrightarrow>\n    \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and> r2.deadlock s2' \\<and> s1 \\<approx>m s2'\n 2. \\<nexists>t. r1.not_final_thread s1 t \\<Longrightarrow>\n    \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and> r2.deadlock s2' \\<and> s1 \\<approx>m s2'", "with red1 red2 mbisim"], ["proof (chain)\npicking this:\n  \\<tau>mRed2 s2 (ls2, (ts2, m2), ws2, is2)\n  \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2) (ls2, (ts2', m2), ws2, is2)\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n  r2.deadlock (ls2, (ts2', m2), ws2, is2)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<tau>mRed2 s2 (ls2, (ts2, m2), ws2, is2)\n  \\<tau>mRed2 (ls2, (ts2, m2), ws2, is2) (ls2, (ts2', m2), ws2, is2)\n  s1 \\<approx>m (ls2, (ts2', m2), ws2, is2)\n  r2.deadlock (ls2, (ts2', m2), ws2, is2)\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and> r2.deadlock s2' \\<and> s1 \\<approx>m s2'", "by(blast intro: rtranclp_trans)"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     \\<tau>mRed2 s2 s2' \\<and> r2.deadlock s2' \\<and> s1 \\<approx>m s2'\n\ngoal (1 subgoal):\n 1. \\<nexists>t. r1.not_final_thread s1 t \\<Longrightarrow>\n    \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and> r2.deadlock s2' \\<and> s1 \\<approx>m s2'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>t. r1.not_final_thread s1 t \\<Longrightarrow>\n    \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and> r2.deadlock s2' \\<and> s1 \\<approx>m s2'", "case False"], ["proof (state)\nthis:\n  \\<nexists>t. r1.not_final_thread s1 t\n\ngoal (1 subgoal):\n 1. \\<nexists>t. r1.not_final_thread s1 t \\<Longrightarrow>\n    \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and> r2.deadlock s2' \\<and> s1 \\<approx>m s2'", "hence \"r1.mfinal s1\""], ["proof (prove)\nusing this:\n  \\<nexists>t. r1.not_final_thread s1 t\n\ngoal (1 subgoal):\n 1. r1.mfinal s1", "by(auto intro: r1.mfinalI simp add: r1.not_final_thread_iff)"], ["proof (state)\nthis:\n  r1.mfinal s1\n\ngoal (1 subgoal):\n 1. \\<nexists>t. r1.not_final_thread s1 t \\<Longrightarrow>\n    \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and> r2.deadlock s2' \\<and> s1 \\<approx>m s2'", "from mfinal1_simulation[OF mbisim this]"], ["proof (chain)\npicking this:\n  \\<exists>s2'.\n     \\<tau>mRed2 s2 s2' \\<and>\n     s1 \\<approx>m s2' \\<and> r2.mfinal s2' \\<and> shr s2' = shr s2", "obtain s2' where \"\\<tau>mRed2 s2 s2'\" \"s1 \\<approx>m s2'\" \"r2.mfinal s2'\" \"shr s2' = shr s2\""], ["proof (prove)\nusing this:\n  \\<exists>s2'.\n     \\<tau>mRed2 s2 s2' \\<and>\n     s1 \\<approx>m s2' \\<and> r2.mfinal s2' \\<and> shr s2' = shr s2\n\ngoal (1 subgoal):\n 1. (\\<And>s2'.\n        \\<lbrakk>\\<tau>mRed2 s2 s2'; s1 \\<approx>m s2'; r2.mfinal s2';\n         shr s2' = shr s2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<tau>mRed2 s2 s2'\n  s1 \\<approx>m s2'\n  r2.mfinal s2'\n  shr s2' = shr s2\n\ngoal (1 subgoal):\n 1. \\<nexists>t. r1.not_final_thread s1 t \\<Longrightarrow>\n    \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and> r2.deadlock s2' \\<and> s1 \\<approx>m s2'", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<tau>mRed2 s2 s2'\n  s1 \\<approx>m s2'\n  r2.mfinal s2'\n  shr s2' = shr s2\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       \\<tau>mRed2 s2 s2' \\<and> r2.deadlock s2' \\<and> s1 \\<approx>m s2'", "by(blast intro: r2.mfinal_deadlock)"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     \\<tau>mRed2 s2 s2' \\<and> r2.deadlock s2' \\<and> s1 \\<approx>m s2'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma deadlock2_imp_\\<tau>s_deadlock1:\n  \"\\<lbrakk> s1 \\<approx>m s2; r2.deadlock s2 \\<rbrakk>\n  \\<Longrightarrow> \\<exists>s1'. r1.mthr.silent_moves s1 s1' \\<and> r1.deadlock s1' \\<and> s1' \\<approx>m s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx>m s2; r2.deadlock s2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s1'.\n                         \\<tau>mRed1 s1 s1' \\<and>\n                         r1.deadlock s1' \\<and> s1' \\<approx>m s2", "using FWdelay_bisimulation_diverge.deadlock1_imp_\\<tau>s_deadlock2[OF FWdelay_bisimulation_diverge_flip]"], ["proof (prove)\nusing this:\n  \\<lbrakk>FWbisimulation_base.mbisim (\\<lambda>t. flip (bisim t))\n            (flip bisim_wait) ?s1.0 ?s2.0;\n   r2.deadlock ?s1.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s2'.\n                       (\\<tau>trsys.silent_move\n                         (multithreaded_base.redT final1 r1 ?convert_RA)\n                         m\\<tau>move1)\\<^sup>*\\<^sup>*\n                        ?s2.0 s2' \\<and>\n                       r1.deadlock s2' \\<and>\n                       FWbisimulation_base.mbisim\n                        (\\<lambda>t. flip (bisim t)) (flip bisim_wait) ?s1.0\n                        s2'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx>m s2; r2.deadlock s2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s1'.\n                         \\<tau>mRed1 s1 s1' \\<and>\n                         r1.deadlock s1' \\<and> s1' \\<approx>m s2", "unfolding flip_simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s2.0 \\<approx>m ?s1.0; r2.deadlock ?s1.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s2'.\n                       (\\<tau>trsys.silent_move\n                         (multithreaded_base.redT final1 r1 ?convert_RA)\n                         m\\<tau>move1)\\<^sup>*\\<^sup>*\n                        ?s2.0 s2' \\<and>\n                       r1.deadlock s2' \\<and> s2' \\<approx>m ?s1.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx>m s2; r2.deadlock s2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s1'.\n                         \\<tau>mRed1 s1 s1' \\<and>\n                         r1.deadlock s1' \\<and> s1' \\<approx>m s2", "."], ["", "lemma deadlocked'1_imp_\\<tau>s_deadlocked'2:\n  \"\\<lbrakk> s1 \\<approx>m s2; r1.deadlocked' s1 \\<rbrakk>\n  \\<Longrightarrow> \\<exists>s2'. r2.mthr.silent_moves s2 s2' \\<and> r2.deadlocked' s2' \\<and> s1 \\<approx>m s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx>m s2; r1.deadlocked' s1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         \\<tau>mRed2 s2 s2' \\<and>\n                         r2.deadlocked' s2' \\<and> s1 \\<approx>m s2'", "unfolding r1.deadlock_eq_deadlocked'[symmetric] r2.deadlock_eq_deadlocked'[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx>m s2; r1.deadlock s1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         \\<tau>mRed2 s2 s2' \\<and>\n                         r2.deadlock s2' \\<and> s1 \\<approx>m s2'", "by(rule deadlock1_imp_\\<tau>s_deadlock2)"], ["", "lemma deadlocked'2_imp_\\<tau>s_deadlocked'1:\n  \"\\<lbrakk> s1 \\<approx>m s2; r2.deadlocked' s2 \\<rbrakk> \\<Longrightarrow> \\<exists>s1'. r1.mthr.silent_moves s1 s1' \\<and> r1.deadlocked' s1' \\<and> s1' \\<approx>m s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx>m s2; r2.deadlocked' s2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s1'.\n                         \\<tau>mRed1 s1 s1' \\<and>\n                         r1.deadlocked' s1' \\<and> s1' \\<approx>m s2", "unfolding r1.deadlock_eq_deadlocked'[symmetric] r2.deadlock_eq_deadlocked'[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx>m s2; r2.deadlock s2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s1'.\n                         \\<tau>mRed1 s1 s1' \\<and>\n                         r1.deadlock s1' \\<and> s1' \\<approx>m s2", "by(rule deadlock2_imp_\\<tau>s_deadlock1)"], ["", "end"], ["", "context FWbisimulation begin"], ["", "lemma mbisim_final_thread_preserve1:\n  assumes mbisim: \"s1 \\<approx>m s2\" and fin: \"r1.final_thread s1 t\"\n  shows \"r2.final_thread s2 t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r2.final_thread s2 t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. r2.final_thread s2 t", "from fin"], ["proof (chain)\npicking this:\n  r1.final_thread s1 t", "obtain x1 where ts1t: \"thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>\"\n    and fin1: \"final1 x1\" and ws1t: \"wset s1 t = None\""], ["proof (prove)\nusing this:\n  r1.final_thread s1 t\n\ngoal (1 subgoal):\n 1. (\\<And>x1.\n        \\<lbrakk>thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>;\n         final1 x1; wset s1 t = None\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim: r1.final_threadE)"], ["proof (state)\nthis:\n  thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>\n  final1 x1\n  wset s1 t = None\n\ngoal (1 subgoal):\n 1. r2.final_thread s2 t", "from mbisim ts1t"], ["proof (chain)\npicking this:\n  s1 \\<approx>m s2\n  thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>", "obtain x2 \n    where ts2t: \"thr s2 t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>\"\n    and bisim: \"t \\<turnstile> (x1, shr s1) \\<approx> (x2, shr s2)\""], ["proof (prove)\nusing this:\n  s1 \\<approx>m s2\n  thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>x2.\n        \\<lbrakk>thr s2 t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>;\n         t \\<turnstile> (x1, shr s1) \\<approx> (x2, shr s2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: mbisim_thrD1)"], ["proof (state)\nthis:\n  thr s2 t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>\n  t \\<turnstile> (x1, shr s1) \\<approx> (x2, shr s2)\n\ngoal (1 subgoal):\n 1. r2.final_thread s2 t", "note ts2t"], ["proof (state)\nthis:\n  thr s2 t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. r2.final_thread s2 t", "moreover"], ["proof (state)\nthis:\n  thr s2 t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. r2.final_thread s2 t", "from fin1 bisim"], ["proof (chain)\npicking this:\n  final1 x1\n  t \\<turnstile> (x1, shr s1) \\<approx> (x2, shr s2)", "have \"final2 x2\""], ["proof (prove)\nusing this:\n  final1 x1\n  t \\<turnstile> (x1, shr s1) \\<approx> (x2, shr s2)\n\ngoal (1 subgoal):\n 1. final2 x2", "by(auto dest: bisim_final)"], ["proof (state)\nthis:\n  final2 x2\n\ngoal (1 subgoal):\n 1. r2.final_thread s2 t", "moreover"], ["proof (state)\nthis:\n  final2 x2\n\ngoal (1 subgoal):\n 1. r2.final_thread s2 t", "from mbisim ws1t"], ["proof (chain)\npicking this:\n  s1 \\<approx>m s2\n  wset s1 t = None", "have \"wset s2 t = None\""], ["proof (prove)\nusing this:\n  s1 \\<approx>m s2\n  wset s1 t = None\n\ngoal (1 subgoal):\n 1. wset s2 t = None", "by(simp add: mbisim_def)"], ["proof (state)\nthis:\n  wset s2 t = None\n\ngoal (1 subgoal):\n 1. r2.final_thread s2 t", "ultimately"], ["proof (chain)\npicking this:\n  thr s2 t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>\n  final2 x2\n  wset s2 t = None", "show ?thesis"], ["proof (prove)\nusing this:\n  thr s2 t = \\<lfloor>(x2, no_wait_locks)\\<rfloor>\n  final2 x2\n  wset s2 t = None\n\ngoal (1 subgoal):\n 1. r2.final_thread s2 t", "by(rule r2.final_threadI)"], ["proof (state)\nthis:\n  r2.final_thread s2 t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mbisim_final_thread_preserve2:\n  \"\\<lbrakk> s1 \\<approx>m s2; r2.final_thread s2 t \\<rbrakk> \\<Longrightarrow> r1.final_thread s1 t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx>m s2; r2.final_thread s2 t\\<rbrakk>\n    \\<Longrightarrow> r1.final_thread s1 t", "using FWbisimulation.mbisim_final_thread_preserve1[OF FWbisimulation_flip]"], ["proof (prove)\nusing this:\n  \\<lbrakk>FWbisimulation_base.mbisim (\\<lambda>t. flip (bisim t))\n            (\\<lambda>x1 x2. True) ?s1.0 ?s2.0;\n   r2.final_thread ?s1.0 ?t\\<rbrakk>\n  \\<Longrightarrow> r1.final_thread ?s2.0 ?t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx>m s2; r2.final_thread s2 t\\<rbrakk>\n    \\<Longrightarrow> r1.final_thread s1 t", "unfolding flip_simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s2.0 \\<approx>m ?s1.0; r2.final_thread ?s1.0 ?t\\<rbrakk>\n  \\<Longrightarrow> r1.final_thread ?s2.0 ?t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx>m s2; r2.final_thread s2 t\\<rbrakk>\n    \\<Longrightarrow> r1.final_thread s1 t", "."], ["", "lemma mbisim_final_thread_inv:\n  \"s1 \\<approx>m s2 \\<Longrightarrow> r1.final_thread s1 t \\<longleftrightarrow> r2.final_thread s2 t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s1 \\<approx>m s2 \\<Longrightarrow>\n    r1.final_thread s1 t = r2.final_thread s2 t", "by(blast intro: mbisim_final_thread_preserve1 mbisim_final_thread_preserve2)"], ["", "lemma mbisim_not_final_thread_inv:\n  assumes bisim: \"mbisim s1 s2\"\n  shows \"r1.not_final_thread s1 = r2.not_final_thread s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r1.not_final_thread s1 = r2.not_final_thread s2", "proof(rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. r1.not_final_thread s1 x = r2.not_final_thread s2 x", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. r1.not_final_thread s1 x = r2.not_final_thread s2 x", "show \"r1.not_final_thread s1 t = r2.not_final_thread s2 t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r1.not_final_thread s1 t = r2.not_final_thread s2 t", "proof(cases \"thr s1 t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. thr s1 t = None \\<Longrightarrow>\n    r1.not_final_thread s1 t = r2.not_final_thread s2 t\n 2. \\<And>a.\n       thr s1 t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       r1.not_final_thread s1 t = r2.not_final_thread s2 t", "case None"], ["proof (state)\nthis:\n  thr s1 t = None\n\ngoal (2 subgoals):\n 1. thr s1 t = None \\<Longrightarrow>\n    r1.not_final_thread s1 t = r2.not_final_thread s2 t\n 2. \\<And>a.\n       thr s1 t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       r1.not_final_thread s1 t = r2.not_final_thread s2 t", "with mbisim_thrNone_eq[OF bisim, of t]"], ["proof (chain)\npicking this:\n  (thr s1 t = None) = (thr s2 t = None)\n  thr s1 t = None", "have \"thr s2 t = None\""], ["proof (prove)\nusing this:\n  (thr s1 t = None) = (thr s2 t = None)\n  thr s1 t = None\n\ngoal (1 subgoal):\n 1. thr s2 t = None", "by simp"], ["proof (state)\nthis:\n  thr s2 t = None\n\ngoal (2 subgoals):\n 1. thr s1 t = None \\<Longrightarrow>\n    r1.not_final_thread s1 t = r2.not_final_thread s2 t\n 2. \\<And>a.\n       thr s1 t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       r1.not_final_thread s1 t = r2.not_final_thread s2 t", "with None"], ["proof (chain)\npicking this:\n  thr s1 t = None\n  thr s2 t = None", "show ?thesis"], ["proof (prove)\nusing this:\n  thr s1 t = None\n  thr s2 t = None\n\ngoal (1 subgoal):\n 1. r1.not_final_thread s1 t = r2.not_final_thread s2 t", "by(auto elim!: r2.not_final_thread.cases r1.not_final_thread.cases\n             intro: r2.not_final_thread.intros r1.not_final_thread.intros)"], ["proof (state)\nthis:\n  r1.not_final_thread s1 t = r2.not_final_thread s2 t\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       thr s1 t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       r1.not_final_thread s1 t = r2.not_final_thread s2 t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       thr s1 t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       r1.not_final_thread s1 t = r2.not_final_thread s2 t", "case (Some a)"], ["proof (state)\nthis:\n  thr s1 t = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       thr s1 t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       r1.not_final_thread s1 t = r2.not_final_thread s2 t", "then"], ["proof (chain)\npicking this:\n  thr s1 t = \\<lfloor>a\\<rfloor>", "obtain x1 ln where tst1: \"thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>\""], ["proof (prove)\nusing this:\n  thr s1 t = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>x1 ln.\n        thr s1 t = \\<lfloor>(x1, ln)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases a) auto"], ["proof (state)\nthis:\n  thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       thr s1 t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       r1.not_final_thread s1 t = r2.not_final_thread s2 t", "from mbisim_thrD1[OF bisim tst1]"], ["proof (chain)\npicking this:\n  \\<exists>x'.\n     thr s2 t = \\<lfloor>(x', ln)\\<rfloor> \\<and>\n     t \\<turnstile> (x1, shr s1) \\<approx> (x', shr s2) \\<and>\n     (wset s1 t = None \\<or> True)", "obtain x2\n      where tst2: \"thr s2 t = \\<lfloor>(x2, ln)\\<rfloor>\" and bisimt: \"t \\<turnstile> (x1, shr s1) \\<approx> (x2, shr s2)\""], ["proof (prove)\nusing this:\n  \\<exists>x'.\n     thr s2 t = \\<lfloor>(x', ln)\\<rfloor> \\<and>\n     t \\<turnstile> (x1, shr s1) \\<approx> (x', shr s2) \\<and>\n     (wset s1 t = None \\<or> True)\n\ngoal (1 subgoal):\n 1. (\\<And>x2.\n        \\<lbrakk>thr s2 t = \\<lfloor>(x2, ln)\\<rfloor>;\n         t \\<turnstile> (x1, shr s1) \\<approx> (x2, shr s2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  thr s2 t = \\<lfloor>(x2, ln)\\<rfloor>\n  t \\<turnstile> (x1, shr s1) \\<approx> (x2, shr s2)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       thr s1 t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       r1.not_final_thread s1 t = r2.not_final_thread s2 t", "from bisim"], ["proof (chain)\npicking this:\n  s1 \\<approx>m s2", "have \"wset s2 = wset s1\""], ["proof (prove)\nusing this:\n  s1 \\<approx>m s2\n\ngoal (1 subgoal):\n 1. wset s2 = wset s1", "by(simp add: mbisim_def)"], ["proof (state)\nthis:\n  wset s2 = wset s1\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       thr s1 t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       r1.not_final_thread s1 t = r2.not_final_thread s2 t", "with tst2 tst1 bisim_final[OF bisimt]"], ["proof (chain)\npicking this:\n  thr s2 t = \\<lfloor>(x2, ln)\\<rfloor>\n  thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>\n  final1 x1 = final2 x2\n  wset s2 = wset s1", "show ?thesis"], ["proof (prove)\nusing this:\n  thr s2 t = \\<lfloor>(x2, ln)\\<rfloor>\n  thr s1 t = \\<lfloor>(x1, ln)\\<rfloor>\n  final1 x1 = final2 x2\n  wset s2 = wset s1\n\ngoal (1 subgoal):\n 1. r1.not_final_thread s1 t = r2.not_final_thread s2 t", "by(simp add: r1.not_final_thread_conv r2.not_final_thread_conv)(rule mbisim_final_thread_inv[OF bisim])"], ["proof (state)\nthis:\n  r1.not_final_thread s1 t = r2.not_final_thread s2 t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r1.not_final_thread s1 t = r2.not_final_thread s2 t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mbisim_deadlocked_preserve1:\n  assumes mbisim: \"s1 \\<approx>m s2\" and dead: \"t \\<in> r1.deadlocked s1\"\n  shows \"t \\<in> r2.deadlocked s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> r2.deadlocked s2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in> r2.deadlocked s2", "from deadlocked1_imp_\\<tau>s_deadlocked2[OF mbisim dead]"], ["proof (chain)\npicking this:\n  \\<exists>s2'.\n     mthr.trsys2.silent_moves m\\<tau>move2 s2 s2' \\<and>\n     t \\<in> r2.deadlocked s2' \\<and> s1 \\<approx>m s2'", "obtain s2' where \"r2.mthr.silent_moves s2 s2'\"\n    and \"t \\<in> r2.deadlocked s2'\""], ["proof (prove)\nusing this:\n  \\<exists>s2'.\n     mthr.trsys2.silent_moves m\\<tau>move2 s2 s2' \\<and>\n     t \\<in> r2.deadlocked s2' \\<and> s1 \\<approx>m s2'\n\ngoal (1 subgoal):\n 1. (\\<And>s2'.\n        \\<lbrakk>mthr.trsys2.silent_moves m\\<tau>move2 s2 s2';\n         t \\<in> r2.deadlocked s2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  mthr.trsys2.silent_moves m\\<tau>move2 s2 s2'\n  t \\<in> r2.deadlocked s2'\n\ngoal (1 subgoal):\n 1. t \\<in> r2.deadlocked s2", "from \\<open>r2.mthr.silent_moves s2 s2'\\<close>"], ["proof (chain)\npicking this:\n  mthr.trsys2.silent_moves m\\<tau>move2 s2 s2'", "have \"s2' = s2\""], ["proof (prove)\nusing this:\n  mthr.trsys2.silent_moves m\\<tau>move2 s2 s2'\n\ngoal (1 subgoal):\n 1. s2' = s2", "by(rule converse_rtranclpE)(auto elim: r2.m\\<tau>move.cases)"], ["proof (state)\nthis:\n  s2' = s2\n\ngoal (1 subgoal):\n 1. t \\<in> r2.deadlocked s2", "with \\<open>t \\<in> r2.deadlocked s2'\\<close>"], ["proof (chain)\npicking this:\n  t \\<in> r2.deadlocked s2'\n  s2' = s2", "show ?thesis"], ["proof (prove)\nusing this:\n  t \\<in> r2.deadlocked s2'\n  s2' = s2\n\ngoal (1 subgoal):\n 1. t \\<in> r2.deadlocked s2", "by simp"], ["proof (state)\nthis:\n  t \\<in> r2.deadlocked s2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mbisim_deadlocked_preserve2:\n  \"\\<lbrakk> s1 \\<approx>m s2; t \\<in> r2.deadlocked s2 \\<rbrakk> \\<Longrightarrow> t \\<in> r1.deadlocked s1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx>m s2; t \\<in> r2.deadlocked s2\\<rbrakk>\n    \\<Longrightarrow> t \\<in> r1.deadlocked s1", "using FWbisimulation.mbisim_deadlocked_preserve1[OF FWbisimulation_flip]"], ["proof (prove)\nusing this:\n  \\<lbrakk>FWbisimulation_base.mbisim (\\<lambda>t. flip (bisim t))\n            (\\<lambda>x1 x2. True) ?s1.0 ?s2.0;\n   ?t \\<in> r2.deadlocked ?s1.0\\<rbrakk>\n  \\<Longrightarrow> ?t \\<in> r1.deadlocked ?s2.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx>m s2; t \\<in> r2.deadlocked s2\\<rbrakk>\n    \\<Longrightarrow> t \\<in> r1.deadlocked s1", "unfolding flip_simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s2.0 \\<approx>m ?s1.0; ?t \\<in> r2.deadlocked ?s1.0\\<rbrakk>\n  \\<Longrightarrow> ?t \\<in> r1.deadlocked ?s2.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx>m s2; t \\<in> r2.deadlocked s2\\<rbrakk>\n    \\<Longrightarrow> t \\<in> r1.deadlocked s1", "."], ["", "lemma mbisim_deadlocked_inv:\n  \"s1 \\<approx>m s2 \\<Longrightarrow> r1.deadlocked s1 = r2.deadlocked s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s1 \\<approx>m s2 \\<Longrightarrow> r1.deadlocked s1 = r2.deadlocked s2", "by(blast intro!: mbisim_deadlocked_preserve1 mbisim_deadlocked_preserve2)"], ["", "lemma mbisim_deadlocked'_inv:\n  \"s1 \\<approx>m s2 \\<Longrightarrow> r1.deadlocked' s1 \\<longleftrightarrow> r2.deadlocked' s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s1 \\<approx>m s2 \\<Longrightarrow> r1.deadlocked' s1 = r2.deadlocked' s2", "unfolding r1.deadlocked'_def r2.deadlocked'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s1 \\<approx>m s2 \\<Longrightarrow>\n    (\\<forall>t.\n        r1.not_final_thread s1 t \\<longrightarrow>\n        t \\<in> r1.deadlocked s1) =\n    (\\<forall>t.\n        r2.not_final_thread s2 t \\<longrightarrow> t \\<in> r2.deadlocked s2)", "by(simp add: mbisim_not_final_thread_inv mbisim_deadlocked_inv)"], ["", "lemma mbisim_deadlock_inv:\n  \"s1 \\<approx>m s2 \\<Longrightarrow> r1.deadlock s1 = r2.deadlock s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s1 \\<approx>m s2 \\<Longrightarrow> r1.deadlock s1 = r2.deadlock s2", "unfolding r1.deadlock_eq_deadlocked' r2.deadlock_eq_deadlocked'"], ["proof (prove)\ngoal (1 subgoal):\n 1. s1 \\<approx>m s2 \\<Longrightarrow> r1.deadlocked' s1 = r2.deadlocked' s2", "by(rule mbisim_deadlocked'_inv)"], ["", "end"], ["", "(* Nice to have, but not needed any more *)"], ["", "context FWbisimulation begin"], ["", "lemma bisim_can_sync_preserve1:\n  assumes bisim: \"t \\<turnstile> (x1, m1) \\<approx> (x2, m2)\" and cs: \"t \\<turnstile> \\<langle>x1, m1\\<rangle> LT \\<wrong>1\"\n  shows \"t \\<turnstile> \\<langle>x2, m2\\<rangle> LT \\<wrong>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<turnstile> \\<langle>x2, m2\\<rangle> LT \\<wrong>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<turnstile> \\<langle>x2, m2\\<rangle> LT \\<wrong>2", "from cs"], ["proof (chain)\npicking this:\n  t \\<turnstile> \\<langle>x1, m1\\<rangle> LT \\<wrong>1", "obtain ta1 x1' m1' where red1: \"t \\<turnstile> (x1, m1) -1-ta1\\<rightarrow> (x1', m1')\"\n    and LT: \"LT = collect_locks \\<lbrace>ta1\\<rbrace>\\<^bsub>l\\<^esub> <+> collect_cond_actions \\<lbrace>ta1\\<rbrace>\\<^bsub>c\\<^esub> <+> collect_interrupts \\<lbrace>ta1\\<rbrace>\\<^bsub>i\\<^esub>\""], ["proof (prove)\nusing this:\n  t \\<turnstile> \\<langle>x1, m1\\<rangle> LT \\<wrong>1\n\ngoal (1 subgoal):\n 1. (\\<And>ta1 x1' m1'.\n        \\<lbrakk>r1.r_syntax t x1 m1 ta1 x1' m1';\n         LT = collect_waits ta1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule r1.can_syncE)"], ["proof (state)\nthis:\n  r1.r_syntax t x1 m1 ta1 x1' m1'\n  LT = collect_waits ta1\n\ngoal (1 subgoal):\n 1. t \\<turnstile> \\<langle>x2, m2\\<rangle> LT \\<wrong>2", "from bisimulation.simulation1[OF bisimulation_axioms, OF bisim red1]"], ["proof (chain)\npicking this:\n  \\<exists>s2' tl2.\n     t \\<turnstile> (x2, m2) -2-tl2\\<rightarrow> s2' \\<and>\n     t \\<turnstile> (x1', m1') \\<approx> s2' \\<and> ta1 \\<sim>m tl2", "obtain x2' ta2 m2'\n    where red2: \"t \\<turnstile> (x2, m2) -2-ta2\\<rightarrow> (x2', m2')\" \n    and tasim: \"ta1 \\<sim>m ta2\""], ["proof (prove)\nusing this:\n  \\<exists>s2' tl2.\n     t \\<turnstile> (x2, m2) -2-tl2\\<rightarrow> s2' \\<and>\n     t \\<turnstile> (x1', m1') \\<approx> s2' \\<and> ta1 \\<sim>m tl2\n\ngoal (1 subgoal):\n 1. (\\<And>ta2 x2' m2'.\n        \\<lbrakk>r2.r_syntax t x2 m2 ta2 x2' m2'; ta1 \\<sim>m ta2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  r2.r_syntax t x2 m2 ta2 x2' m2'\n  ta1 \\<sim>m ta2\n\ngoal (1 subgoal):\n 1. t \\<turnstile> \\<langle>x2, m2\\<rangle> LT \\<wrong>2", "from tasim LT"], ["proof (chain)\npicking this:\n  ta1 \\<sim>m ta2\n  LT = collect_waits ta1", "have \"LT = collect_locks \\<lbrace>ta2\\<rbrace>\\<^bsub>l\\<^esub> <+> collect_cond_actions \\<lbrace>ta2\\<rbrace>\\<^bsub>c\\<^esub> <+> collect_interrupts \\<lbrace>ta2\\<rbrace>\\<^bsub>i\\<^esub>\""], ["proof (prove)\nusing this:\n  ta1 \\<sim>m ta2\n  LT = collect_waits ta1\n\ngoal (1 subgoal):\n 1. LT = collect_waits ta2", "by(auto simp add: ta_bisim_def)"], ["proof (state)\nthis:\n  LT = collect_waits ta2\n\ngoal (1 subgoal):\n 1. t \\<turnstile> \\<langle>x2, m2\\<rangle> LT \\<wrong>2", "with red2"], ["proof (chain)\npicking this:\n  r2.r_syntax t x2 m2 ta2 x2' m2'\n  LT = collect_waits ta2", "show ?thesis"], ["proof (prove)\nusing this:\n  r2.r_syntax t x2 m2 ta2 x2' m2'\n  LT = collect_waits ta2\n\ngoal (1 subgoal):\n 1. t \\<turnstile> \\<langle>x2, m2\\<rangle> LT \\<wrong>2", "by(rule r2.can_syncI)"], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x2, m2\\<rangle> LT \\<wrong>2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bisim_can_sync_preserve2:\n  \"\\<lbrakk> t \\<turnstile> (x1, m1) \\<approx> (x2, m2); t \\<turnstile> \\<langle>x2, m2\\<rangle> LT \\<wrong>2 \\<rbrakk> \\<Longrightarrow> t \\<turnstile> \\<langle>x1, m1\\<rangle> LT \\<wrong>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<turnstile> (x1, m1) \\<approx> (x2, m2);\n     t \\<turnstile> \\<langle>x2, m2\\<rangle> LT \\<wrong>2\\<rbrakk>\n    \\<Longrightarrow> t \\<turnstile> \\<langle>x1, m1\\<rangle> LT \\<wrong>1", "using FWbisimulation.bisim_can_sync_preserve1[OF FWbisimulation_flip]"], ["proof (prove)\nusing this:\n  \\<lbrakk>flip (bisim ?t) (?x1.0, ?m1.0) (?x2.0, ?m2.0);\n   ?t \\<turnstile> \\<langle>?x1.0, ?m1.0\\<rangle> ?LT \\<wrong>2\\<rbrakk>\n  \\<Longrightarrow> ?t \\<turnstile> \\<langle>?x2.0, ?m2.0\\<rangle> ?LT\n                    \\<wrong>1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<turnstile> (x1, m1) \\<approx> (x2, m2);\n     t \\<turnstile> \\<langle>x2, m2\\<rangle> LT \\<wrong>2\\<rbrakk>\n    \\<Longrightarrow> t \\<turnstile> \\<langle>x1, m1\\<rangle> LT \\<wrong>1", "unfolding flip_simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>?t \\<turnstile> (?x2.0, ?m2.0) \\<approx> (?x1.0, ?m1.0);\n   ?t \\<turnstile> \\<langle>?x1.0, ?m1.0\\<rangle> ?LT \\<wrong>2\\<rbrakk>\n  \\<Longrightarrow> ?t \\<turnstile> \\<langle>?x2.0, ?m2.0\\<rangle> ?LT\n                    \\<wrong>1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<turnstile> (x1, m1) \\<approx> (x2, m2);\n     t \\<turnstile> \\<langle>x2, m2\\<rangle> LT \\<wrong>2\\<rbrakk>\n    \\<Longrightarrow> t \\<turnstile> \\<langle>x1, m1\\<rangle> LT \\<wrong>1", "."], ["", "lemma bisim_can_sync_inv:\n  \"t \\<turnstile> (x1, m1) \\<approx> (x2, m2) \\<Longrightarrow> t \\<turnstile> \\<langle>x1, m1\\<rangle> LT \\<wrong>1 \\<longleftrightarrow> t \\<turnstile> \\<langle>x2, m2\\<rangle> LT \\<wrong>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<turnstile> (x1, m1) \\<approx> (x2, m2) \\<Longrightarrow>\n    t \\<turnstile> \\<langle>x1, m1\\<rangle> LT \\<wrong>1 =\n    t \\<turnstile> \\<langle>x2, m2\\<rangle> LT \\<wrong>2", "by(blast intro: bisim_can_sync_preserve1 bisim_can_sync_preserve2)"], ["", "lemma bisim_must_sync_preserve1:\n  assumes bisim: \"t \\<turnstile> (x1, m1) \\<approx> (x2, m2)\" and ms: \"t \\<turnstile> \\<langle>x1, m1\\<rangle> \\<wrong>1\"\n  shows \"t \\<turnstile> \\<langle>x2, m2\\<rangle> \\<wrong>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<turnstile> \\<langle>x2, m2\\<rangle> \\<wrong>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<turnstile> \\<langle>x2, m2\\<rangle> \\<wrong>2", "from ms"], ["proof (chain)\npicking this:\n  t \\<turnstile> \\<langle>x1, m1\\<rangle> \\<wrong>1", "obtain ta1 x1' m1' where red1: \"t \\<turnstile> (x1, m1) -1-ta1\\<rightarrow> (x1', m1')\"\n    and s1': \"\\<exists>s1'. r1.actions_ok s1' t ta1\""], ["proof (prove)\nusing this:\n  t \\<turnstile> \\<langle>x1, m1\\<rangle> \\<wrong>1\n\ngoal (1 subgoal):\n 1. (\\<And>ta1 x1' m1'.\n        \\<lbrakk>r1.r_syntax t x1 m1 ta1 x1' m1';\n         \\<exists>s1'. r1.actions_ok s1' t ta1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim: r1.must_syncE)"], ["proof (state)\nthis:\n  r1.r_syntax t x1 m1 ta1 x1' m1'\n  \\<exists>s1'. r1.actions_ok s1' t ta1\n\ngoal (1 subgoal):\n 1. t \\<turnstile> \\<langle>x2, m2\\<rangle> \\<wrong>2", "from bisimulation.simulation1[OF bisimulation_axioms, OF bisim red1]"], ["proof (chain)\npicking this:\n  \\<exists>s2' tl2.\n     t \\<turnstile> (x2, m2) -2-tl2\\<rightarrow> s2' \\<and>\n     t \\<turnstile> (x1', m1') \\<approx> s2' \\<and> ta1 \\<sim>m tl2", "obtain x2' ta2 m2'\n    where red2: \"t \\<turnstile> (x2, m2) -2-ta2\\<rightarrow> (x2', m2')\" \n    and tasim: \"ta1 \\<sim>m ta2\""], ["proof (prove)\nusing this:\n  \\<exists>s2' tl2.\n     t \\<turnstile> (x2, m2) -2-tl2\\<rightarrow> s2' \\<and>\n     t \\<turnstile> (x1', m1') \\<approx> s2' \\<and> ta1 \\<sim>m tl2\n\ngoal (1 subgoal):\n 1. (\\<And>ta2 x2' m2'.\n        \\<lbrakk>r2.r_syntax t x2 m2 ta2 x2' m2'; ta1 \\<sim>m ta2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  r2.r_syntax t x2 m2 ta2 x2' m2'\n  ta1 \\<sim>m ta2\n\ngoal (1 subgoal):\n 1. t \\<turnstile> \\<langle>x2, m2\\<rangle> \\<wrong>2", "from ex_actions_ok1_conv_ex_actions_ok2[OF tasim, of t] s1' red2"], ["proof (chain)\npicking this:\n  (\\<exists>s1. r1.actions_ok s1 t ta1) =\n  (\\<exists>s2. r2.actions_ok s2 t ta2)\n  \\<exists>s1'. r1.actions_ok s1' t ta1\n  r2.r_syntax t x2 m2 ta2 x2' m2'", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<exists>s1. r1.actions_ok s1 t ta1) =\n  (\\<exists>s2. r2.actions_ok s2 t ta2)\n  \\<exists>s1'. r1.actions_ok s1' t ta1\n  r2.r_syntax t x2 m2 ta2 x2' m2'\n\ngoal (1 subgoal):\n 1. t \\<turnstile> \\<langle>x2, m2\\<rangle> \\<wrong>2", "unfolding r2.must_sync_def2"], ["proof (prove)\nusing this:\n  (\\<exists>s1. r1.actions_ok s1 t ta1) =\n  (\\<exists>s2. r2.actions_ok s2 t ta2)\n  \\<exists>s1'. r1.actions_ok s1' t ta1\n  r2.r_syntax t x2 m2 ta2 x2' m2'\n\ngoal (1 subgoal):\n 1. \\<exists>ta x' m' s.\n       r2.r_syntax t x2 m2 ta x' m' \\<and> r2.actions_ok s t ta", "by blast"], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x2, m2\\<rangle> \\<wrong>2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bisim_must_sync_preserve2:\n  \"\\<lbrakk> t \\<turnstile> (x1, m1) \\<approx> (x2, m2); t \\<turnstile> \\<langle>x2, m2\\<rangle> \\<wrong>2 \\<rbrakk> \\<Longrightarrow> t \\<turnstile> \\<langle>x1, m1\\<rangle> \\<wrong>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<turnstile> (x1, m1) \\<approx> (x2, m2);\n     t \\<turnstile> \\<langle>x2, m2\\<rangle> \\<wrong>2\\<rbrakk>\n    \\<Longrightarrow> t \\<turnstile> \\<langle>x1, m1\\<rangle> \\<wrong>1", "using FWbisimulation.bisim_must_sync_preserve1[OF FWbisimulation_flip]"], ["proof (prove)\nusing this:\n  \\<lbrakk>flip (bisim ?t) (?x1.0, ?m1.0) (?x2.0, ?m2.0);\n   ?t \\<turnstile> \\<langle>?x1.0, ?m1.0\\<rangle> \\<wrong>2\\<rbrakk>\n  \\<Longrightarrow> ?t \\<turnstile> \\<langle>?x2.0, ?m2.0\\<rangle> \\<wrong>1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<turnstile> (x1, m1) \\<approx> (x2, m2);\n     t \\<turnstile> \\<langle>x2, m2\\<rangle> \\<wrong>2\\<rbrakk>\n    \\<Longrightarrow> t \\<turnstile> \\<langle>x1, m1\\<rangle> \\<wrong>1", "unfolding flip_simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>?t \\<turnstile> (?x2.0, ?m2.0) \\<approx> (?x1.0, ?m1.0);\n   ?t \\<turnstile> \\<langle>?x1.0, ?m1.0\\<rangle> \\<wrong>2\\<rbrakk>\n  \\<Longrightarrow> ?t \\<turnstile> \\<langle>?x2.0, ?m2.0\\<rangle> \\<wrong>1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<turnstile> (x1, m1) \\<approx> (x2, m2);\n     t \\<turnstile> \\<langle>x2, m2\\<rangle> \\<wrong>2\\<rbrakk>\n    \\<Longrightarrow> t \\<turnstile> \\<langle>x1, m1\\<rangle> \\<wrong>1", "."], ["", "lemma bisim_must_sync_inv:\n  \"t \\<turnstile> (x1, m1) \\<approx> (x2, m2) \\<Longrightarrow> t \\<turnstile> \\<langle>x1, m1\\<rangle> \\<wrong>1 \\<longleftrightarrow> t \\<turnstile> \\<langle>x2, m2\\<rangle> \\<wrong>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<turnstile> (x1, m1) \\<approx> (x2, m2) \\<Longrightarrow>\n    t \\<turnstile> \\<langle>x1, m1\\<rangle> \\<wrong>1 =\n    t \\<turnstile> \\<langle>x2, m2\\<rangle> \\<wrong>2", "by(blast intro: bisim_must_sync_preserve1 bisim_must_sync_preserve2)"], ["", "end"], ["", "end"]]}