{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Basic/Set_Monad.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma member_SUP: (* FIXME delete candidate: should be subsumed by default simpset as soon as SUP_apply is included *)\n  \"x \\<in> \\<Union>(f ` A) = (SUP B\\<in>A. (\\<lambda>x. x \\<in> f B)) x\"", "lemmas bind_def = Set.bind_def", "lemmas bind_bind = Set.bind_bind", "lemmas empty_bind = Set.empty_bind", "lemmas bind_const = Set.bind_const", "lemmas member_of_pred = Predicate.member_set_of_pred", "lemmas member_of_seq = Predicate.member_set_of_seq", "lemma undefined_code [code_unfold]:\n  \"undefined = Undefined ()\"", "lemma bind_single [simp, code_unfold]:\n  \"A \\<bind> single = A\"", "lemma single_bind [simp, code_unfold]:\n  \"single a \\<bind> B = B a\"", "lemma member_single [simp]:\n  \"x \\<in> single a \\<longleftrightarrow> x = a\"", "lemma single_sup_simps [simp, code_unfold]:\n  shows single_sup: \"sup (single a) A = insert a A\"\n  and sup_single: \"sup A (single a) = insert a A\"", "lemma single_code [code]:\n  \"single a = set [a]\""], "translations": [["", "lemma member_SUP: (* FIXME delete candidate: should be subsumed by default simpset as soon as SUP_apply is included *)\n  \"x \\<in> \\<Union>(f ` A) = (SUP B\\<in>A. (\\<lambda>x. x \\<in> f B)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> \\<Union> (f ` A)) = (SUP B\\<in>A. (\\<lambda>x. x \\<in> f B)) x", "by auto"], ["", "abbreviation (input) \"of_pred == Predicate.set_of_pred\""], ["", "(* FIXME delte alias *)"], ["", "abbreviation (input) \"of_seq == Predicate.set_of_seq\""], ["", "(* FIXME delte alias *)"], ["", "lemmas bind_def = Set.bind_def"], ["", "(* FIXME delte alias *)"], ["", "lemmas bind_bind = Set.bind_bind"], ["", "(* FIXME delte alias *)"], ["", "lemmas empty_bind = Set.empty_bind"], ["", "(* FIXME delte alias *)"], ["", "lemmas bind_const = Set.bind_const"], ["", "(* FIXME delte alias *)"], ["", "lemmas member_of_pred = Predicate.member_set_of_pred"], ["", "(* FIXME delte alias *)"], ["", "lemmas member_of_seq = Predicate.member_set_of_seq"], ["", "(* FIXME delte alias *)"], ["", "definition single :: \"'a \\<Rightarrow> 'a set\"\n  where \"single a = {a}\""], ["", "definition undefined :: \"'a set\"\n  where [simp]: \"undefined = Collect HOL.undefined\""], ["", "declare [[code abort: undefined]]"], ["", "definition Undefined :: \"unit \\<Rightarrow> 'a set\"\n  where \"Undefined _ = Collect HOL.undefined\""], ["", "declare [[code abort: Undefined]]"], ["", "lemma undefined_code [code_unfold]:\n  \"undefined = Undefined ()\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Set_Monad.undefined = Undefined ()", "by (simp add: Undefined_def)"], ["", "lemma bind_single [simp, code_unfold]:\n  \"A \\<bind> single = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<bind> single = A", "by (simp add: bind_def single_def)"], ["", "lemma single_bind [simp, code_unfold]:\n  \"single a \\<bind> B = B a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single a \\<bind> B = B a", "by (simp add: bind_def single_def)"], ["", "declare Set.empty_bind [code_unfold]"], ["", "lemma member_single [simp]:\n  \"x \\<in> single a \\<longleftrightarrow> x = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> single a) = (x = a)", "by (simp add: single_def)"], ["", "lemma single_sup_simps [simp, code_unfold]:\n  shows single_sup: \"sup (single a) A = insert a A\"\n  and sup_single: \"sup A (single a) = insert a A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single a \\<union> A = insert a A &&& A \\<union> single a = insert a A", "by (unfold set_eq_iff) auto"], ["", "lemma single_code [code]:\n  \"single a = set [a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single a = set [a]", "by (simp add: set_eq_iff)"], ["", "end"]]}