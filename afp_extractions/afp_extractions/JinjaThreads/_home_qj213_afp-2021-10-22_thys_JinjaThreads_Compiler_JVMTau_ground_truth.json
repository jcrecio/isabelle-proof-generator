{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Compiler/JVMTau.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma \\<tau>moves2xcp: \"pc < length (compEs2 es) \\<Longrightarrow> \\<tau>moves2 P h stk es pc \\<lfloor>xcp\\<rfloor>\"", "lemma \\<tau>move2_intros':\n  shows \\<tau>move2CastRed': \"pc = length (compE2 e) \\<Longrightarrow> \\<tau>move2 P h stk (Cast T e) pc None\"\n  and \\<tau>move2InstanceOfRed': \"pc = length (compE2 e) \\<Longrightarrow> \\<tau>move2 P h stk (e instanceof T) pc None\"\n  and \\<tau>move2BinOp2': \"\\<lbrakk> \\<tau>move2 P h stk e2 pc xcp; pc' = length (compE2 e1) + pc \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk (e1\\<guillemotleft>bop\\<guillemotright>e2) pc' xcp\"\n  and \\<tau>move2BinOp': \"pc = length (compE2 e1) + length (compE2 e2) \\<Longrightarrow> \\<tau>move2 P h stk (e1\\<guillemotleft>bop\\<guillemotright>e2) pc None\"\n  and \\<tau>move2LAssRed1': \"pc = length (compE2 e) \\<Longrightarrow> \\<tau>move2 P h stk (V:=e) pc None\"\n  and \\<tau>move2LAssRed2': \"pc = Suc (length (compE2 e)) \\<Longrightarrow> \\<tau>move2 P h stk (V:=e) pc None\"\n  and \\<tau>move2AAcc2': \"\\<lbrakk> \\<tau>move2 P h stk i pc xcp; pc' = length (compE2 a) + pc \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk (a\\<lfloor>i\\<rceil>) pc' xcp\"\n  and \\<tau>move2AAss2': \"\\<lbrakk> \\<tau>move2 P h stk i pc xcp; pc' = length (compE2 a) + pc \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk (a\\<lfloor>i\\<rceil> := e) pc' xcp\"\n  and \\<tau>move2AAss3': \"\\<lbrakk> \\<tau>move2 P h stk e pc xcp; pc' = length (compE2 a) + length (compE2 i) + pc \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk (a\\<lfloor>i\\<rceil> := e) pc' xcp\"\n  and \\<tau>move2AAssRed': \"pc = Suc (length (compE2 a) + length (compE2 i) + length (compE2 e)) \\<Longrightarrow> \\<tau>move2 P h stk (a\\<lfloor>i\\<rceil> := e) pc None\"\n  and \\<tau>move2FAss2': \"\\<lbrakk> \\<tau>move2 P h stk e' pc xcp; pc' = length (compE2 e) + pc \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk (e\\<bullet>F{D} := e') pc' xcp\"\n  and \\<tau>move2FAssRed': \"pc = Suc (length (compE2 e) + length (compE2 e')) \\<Longrightarrow> \\<tau>move2 P h stk (e\\<bullet>F{D} := e') pc None\"\n  and \\<tau>move2CAS2': \"\\<lbrakk> \\<tau>move2 P h stk e2 pc xcp; pc' = length (compE2 e1) + pc \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) pc' xcp\"\n  and \\<tau>move2CAS3': \"\\<lbrakk> \\<tau>move2 P h stk e3 pc xcp; pc' = length (compE2 e1) + length (compE2 e2) + pc \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) pc' xcp\"\n  and \\<tau>move2CallParams': \"\\<lbrakk> \\<tau>moves2 P h stk ps pc xcp; pc' = length (compE2 obj) + pc \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk (obj\\<bullet>M(ps)) pc' xcp\"\n  and \\<tau>move2Call': \"\\<lbrakk> pc = length (compE2 obj) + length (compEs2 ps); length ps < length stk; \n                     stk ! length ps = Null \\<or> \n                     (\\<forall>T Ts Tr D. typeof_addr h (the_Addr (stk ! length ps)) = \\<lfloor>T\\<rfloor> \\<longrightarrow> P \\<turnstile> class_type_of T sees M:Ts\\<rightarrow>Tr = Native in D \\<longrightarrow> \\<tau>external_defs D M) \\<rbrakk>\n                   \\<Longrightarrow> \\<tau>move2 P h stk (obj\\<bullet>M(ps)) pc None\"\n  and \\<tau>move2BlockSome2: \"pc = Suc 0 \\<Longrightarrow> \\<tau>move2 P h stk {V:T=\\<lfloor>v\\<rfloor>; e} pc None\"\n  and \\<tau>move2BlockSome': \"\\<lbrakk> \\<tau>move2 P h stk e pc xcp; pc' = Suc (Suc pc) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk {V:T=\\<lfloor>v\\<rfloor>; e} pc' xcp\"\n  and \\<tau>move2Sync2': \"pc = length (compE2 o') \\<Longrightarrow> \\<tau>move2 P h stk (sync\\<^bsub>V\\<^esub> (o') e) pc None\"\n  and \\<tau>move2Sync3': \"pc = Suc (length (compE2 o')) \\<Longrightarrow> \\<tau>move2 P h stk (sync\\<^bsub>V\\<^esub> (o') e) pc None\"\n  and \\<tau>move2Sync4': \"\\<lbrakk> \\<tau>move2 P h stk e pc xcp; pc' = Suc (Suc (Suc (length (compE2 o') + pc))) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk (sync\\<^bsub>V\\<^esub> (o') e) pc' xcp\"\n  and \\<tau>move2Sync5': \"pc = Suc (Suc (Suc (length (compE2 o') + length (compE2 e)))) \\<Longrightarrow> \\<tau>move2 P h stk (sync\\<^bsub>V\\<^esub> (o') e) pc None\"\n  and \\<tau>move2Sync6': \"pc = 5 + length (compE2 o') + length (compE2 e) \\<Longrightarrow> \\<tau>move2 P h stk (sync\\<^bsub>V\\<^esub> (o') e) pc None\"\n  and \\<tau>move2Sync7': \"pc = 6 + length (compE2 o') + length (compE2 e) \\<Longrightarrow> \\<tau>move2 P h stk (sync\\<^bsub>V\\<^esub> (o') e) pc None\"\n  and \\<tau>move2Sync8': \"pc = 8 + length (compE2 o') + length (compE2 e) \\<Longrightarrow> \\<tau>move2 P h stk (sync\\<^bsub>V\\<^esub> (o') e) pc None\"\n  and \\<tau>move2SeqRed': \"pc = length (compE2 e) \\<Longrightarrow> \\<tau>move2 P h stk (e;;e') pc None\"\n  and \\<tau>move2Seq2': \"\\<lbrakk> \\<tau>move2 P h stk e' pc xcp; pc' = Suc (length (compE2 e) + pc) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk (e;;e') pc' xcp\"\n  and \\<tau>move2CondRed': \"pc = length (compE2 e) \\<Longrightarrow> \\<tau>move2 P h stk (if (e) e1 else e2) pc None\"\n  and \\<tau>move2CondThen': \"\\<lbrakk> \\<tau>move2 P h stk e1 pc xcp; pc' = Suc (length (compE2 e) + pc) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk (if (e) e1 else e2) pc' xcp\"\n  and \\<tau>move2CondThenExit': \"pc = Suc (length (compE2 e) + length (compE2 e1)) \\<Longrightarrow> \\<tau>move2 P h stk (if (e) e1 else e2) pc None\"\n  and \\<tau>move2CondElse': \"\\<lbrakk> \\<tau>move2 P h stk e2 pc xcp; pc' = Suc (Suc (length (compE2 e) + length (compE2 e1) + pc)) \\<rbrakk> \n                        \\<Longrightarrow> \\<tau>move2 P h stk (if (e) e1 else e2) pc' xcp\"\n  and \\<tau>move2While2': \"\\<lbrakk> \\<tau>move2 P h stk e pc xcp; pc' = Suc (length (compE2 c) + pc) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk (while (c) e) pc' xcp\"\n  and \\<tau>move2While3': \"pc = Suc (Suc (length (compE2 c) + length (compE2 e))) \\<Longrightarrow> \\<tau>move2 P h stk (while (c) e) pc None\"\n  and \\<tau>move2While4': \"pc = Suc (Suc (Suc (length (compE2 c) + length (compE2 e)))) \\<Longrightarrow> \\<tau>move2 P h stk (while (c) e) pc None\"\n  and \\<tau>move2While5': \"pc = length (compE2 c) \\<Longrightarrow> \\<tau>move2 P h stk (while (c) e) pc None\"\n  and \\<tau>move2While6': \"pc = Suc (length (compE2 c) + length (compE2 e)) \\<Longrightarrow> \\<tau>move2 P h stk (while (c) e) pc None\"\n  and \\<tau>move2Throw2': \"pc = length (compE2 e) \\<Longrightarrow> \\<tau>move2 P h stk (throw e) pc None\"\n  and \\<tau>move2TryJump': \"pc = length (compE2 e) \\<Longrightarrow> \\<tau>move2 P h stk (try e catch(C V) e') pc None\"\n  and \\<tau>move2TryCatch2': \"pc = Suc (length (compE2 e)) \\<Longrightarrow> \\<tau>move2 P h stk (try e catch(C V) e') pc None\"\n  and \\<tau>move2Try2': \"\\<lbrakk> \\<tau>move2 P h stk {V:T=None; e'} pc xcp; pc' = Suc (Suc (length (compE2 e) + pc)) \\<rbrakk>\n                    \\<Longrightarrow> \\<tau>move2 P h stk (try e catch(C V) e') pc' xcp\"\n  and \\<tau>moves2Tl': \"\\<lbrakk> \\<tau>moves2 P h stk es pc xcp; pc' = length (compE2 e) + pc \\<rbrakk> \\<Longrightarrow> \\<tau>moves2 P h stk (e # es) pc' xcp\"", "lemma \\<tau>move2_iff: \"\\<tau>move2 P h stk e pc xcp \\<longleftrightarrow> pc < length (compE2 e) \\<and> (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compE2 e ! pc))\" (is \"?lhs1 \\<longleftrightarrow> ?rhs1\")\n  and \\<tau>moves2_iff: \"\\<tau>moves2 P h stk es pc xcp \\<longleftrightarrow> pc < length (compEs2 es) \\<and> (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compEs2 es ! pc))\" (is \"?lhs2 \\<longleftrightarrow> ?rhs2\")", "lemma \\<tau>move2_pc_length_compE2: \"\\<tau>move2 P h stk e pc xcp \\<Longrightarrow> pc < length (compE2 e)\"\n  and \\<tau>moves2_pc_length_compEs2: \"\\<tau>moves2 P h stk es pc xcp \\<Longrightarrow> pc < length (compEs2 es)\"", "lemma \\<tau>move2_pc_length_compE2_conv: \"pc \\<ge> length (compE2 e) \\<Longrightarrow> \\<not> \\<tau>move2 P h stk e pc xcp\"", "lemma \\<tau>moves2_pc_length_compEs2_conv: \"pc \\<ge> length (compEs2 es) \\<Longrightarrow> \\<not> \\<tau>moves2 P h stk es pc xcp\"", "lemma \\<tau>moves2_append [elim]:\n  \"\\<tau>moves2 P h stk es pc xcp \\<Longrightarrow> \\<tau>moves2 P h stk (es @ es') pc xcp\"", "lemma append_\\<tau>moves2:\n  \"\\<tau>moves2 P h stk es pc xcp \\<Longrightarrow> \\<tau>moves2 P h stk (es' @ es) (length (compEs2 es') + pc) xcp\"", "lemma [dest]:\n  shows \\<tau>move2_NewArrayD: \"\\<lbrakk> \\<tau>move2 P h stk (newA T\\<lfloor>e\\<rceil>) pc xcp; pc < length (compE2 e) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp\"\n  and \\<tau>move2_CastD: \"\\<lbrakk> \\<tau>move2 P h stk (Cast T e) pc xcp; pc < length (compE2 e) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp\"\n  and \\<tau>move2_InstanceOfD: \"\\<lbrakk> \\<tau>move2 P h stk (e instanceof T) pc xcp; pc < length (compE2 e) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp\"\n  and \\<tau>move2_BinOp1D: \"\\<lbrakk> \\<tau>move2 P h stk (e1 \\<guillemotleft>bop\\<guillemotright> e2) pc' xcp'; pc' < length (compE2 e1) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e1 pc' xcp'\"\n  and \\<tau>move2_BinOp2D:\n  \"\\<lbrakk> \\<tau>move2 P h stk (e1 \\<guillemotleft>bop\\<guillemotright> e2) (length (compE2 e1) + pc') xcp'; pc' < length (compE2 e2) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e2 pc' xcp'\"\n  and \\<tau>move2_LAssD: \"\\<lbrakk> \\<tau>move2 P h stk (V := e) pc xcp; pc < length (compE2 e) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp\"\n  and \\<tau>move2_AAccD1: \"\\<lbrakk> \\<tau>move2 P h stk (a\\<lfloor>i\\<rceil>) pc xcp; pc < length (compE2 a) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk a pc xcp\"\n  and \\<tau>move2_AAccD2: \"\\<lbrakk> \\<tau>move2 P h stk (a\\<lfloor>i\\<rceil>) (length (compE2 a) + pc) xcp; pc < length (compE2 i) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk i pc xcp\"\n  and \\<tau>move2_AAssD1: \"\\<lbrakk> \\<tau>move2 P h stk (a\\<lfloor>i\\<rceil> := e) pc xcp; pc < length (compE2 a) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk a pc xcp\"\n  and \\<tau>move2_AAssD2: \"\\<lbrakk> \\<tau>move2 P h stk (a\\<lfloor>i\\<rceil> := e) (length (compE2 a) + pc) xcp; pc < length (compE2 i) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk i pc xcp\"\n  and \\<tau>move2_AAssD3:\n  \"\\<lbrakk> \\<tau>move2 P h stk (a\\<lfloor>i\\<rceil> := e) (length (compE2 a) + length (compE2 i) + pc) xcp; pc < length (compE2 e) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp\"\n  and \\<tau>move2_ALengthD: \"\\<lbrakk> \\<tau>move2 P h stk (a\\<bullet>length) pc xcp; pc < length (compE2 a) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk a pc xcp\"\n  and \\<tau>move2_FAccD: \"\\<lbrakk> \\<tau>move2 P h stk (e\\<bullet>F{D}) pc xcp; pc < length (compE2 e) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp\"\n  and \\<tau>move2_FAssD1: \"\\<lbrakk> \\<tau>move2 P h stk (e\\<bullet>F{D} := e') pc xcp; pc < length (compE2 e) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp\"\n  and \\<tau>move2_FAssD2: \"\\<lbrakk> \\<tau>move2 P h stk (e\\<bullet>F{D} := e') (length (compE2 e) + pc) xcp; pc < length (compE2 e') \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e' pc xcp\"\n  and \\<tau>move2_CASD1: \"\\<lbrakk> \\<tau>move2 P h stk (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) pc xcp; pc < length (compE2 e1) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e1 pc xcp\"\n  and \\<tau>move2_CASD2: \"\\<lbrakk> \\<tau>move2 P h stk (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) (length (compE2 e1) + pc) xcp; pc < length (compE2 e2) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e2 pc xcp\"\n  and \\<tau>move2_CASD3:\n  \"\\<lbrakk> \\<tau>move2 P h stk (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) (length (compE2 e1) + length (compE2 e2) + pc) xcp; pc < length (compE2 e3) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e3 pc xcp\"\n  and \\<tau>move2_CallObjD: \"\\<lbrakk> \\<tau>move2 P h stk (e\\<bullet>M(es)) pc xcp; pc < length (compE2 e) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp\"\n  and \\<tau>move2_BlockNoneD: \"\\<tau>move2 P h stk {V:T=None; e} pc xcp \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp\"\n  and \\<tau>move2_BlockSomeD: \"\\<tau>move2 P h stk {V:T=\\<lfloor>v\\<rfloor>; e} (Suc (Suc pc)) xcp \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp\"\n  and \\<tau>move2_sync1D: \"\\<lbrakk> \\<tau>move2 P h stk (sync\\<^bsub>V\\<^esub> (o') e) pc xcp; pc < length (compE2 o') \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk o' pc xcp\"\n  and \\<tau>move2_sync2D:\n  \"\\<lbrakk> \\<tau>move2 P h stk (sync\\<^bsub>V\\<^esub> (o') e) (Suc (Suc (Suc (length (compE2 o') + pc)))) xcp; pc < length (compE2 e) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp\"\n  and \\<tau>move2_Seq1D: \"\\<lbrakk> \\<tau>move2 P h stk (e1;; e2) pc xcp; pc < length (compE2 e1) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e1 pc xcp\"\n  and \\<tau>move2_Seq2D: \"\\<tau>move2 P h stk (e1;; e2) (Suc (length (compE2 e1) + pc')) xcp' \\<Longrightarrow> \\<tau>move2 P h stk e2 pc' xcp'\"\n  and \\<tau>move2_IfCondD: \"\\<lbrakk> \\<tau>move2 P h stk (if (e) e1 else e2) pc xcp; pc < length (compE2 e) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp\"\n  and \\<tau>move2_IfThenD:\n  \"\\<lbrakk> \\<tau>move2 P h stk (if (e) e1 else e2) (Suc (length (compE2 e) + pc')) xcp'; pc' < length (compE2 e1) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e1 pc' xcp'\"\n  and \\<tau>move2_IfElseD:\n  \"\\<tau>move2 P h stk (if (e) e1 else e2) (Suc (Suc (length (compE2 e) + length (compE2 e1) + pc'))) xcp' \\<Longrightarrow> \\<tau>move2 P h stk e2 pc' xcp'\"\n  and \\<tau>move2_WhileCondD: \"\\<lbrakk> \\<tau>move2 P h stk (while (c) b) pc xcp; pc < length (compE2 c) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk c pc xcp\"\n  and \\<tau>move2_ThrowD: \"\\<lbrakk> \\<tau>move2 P h stk (throw e) pc xcp; pc < length (compE2 e) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp\"\n  and \\<tau>move2_Try1D: \"\\<lbrakk> \\<tau>move2 P h stk (try e1 catch(C' V) e2) pc xcp; pc < length (compE2 e1) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e1 pc xcp\"", "lemma \\<tau>move2_Invoke:\n  \"\\<lbrakk>\\<tau>move2 P h stk e pc None; compE2 e ! pc = Invoke M n \\<rbrakk>\n  \\<Longrightarrow> n < length stk \\<and> (stk ! n = Null \\<or> (\\<forall>T Ts Tr D. typeof_addr h (the_Addr (stk ! n)) = \\<lfloor>T\\<rfloor> \\<longrightarrow> P \\<turnstile> class_type_of T sees M:Ts\\<rightarrow>Tr = Native in D \\<longrightarrow> \\<tau>external_defs D M))\"\n\n  and \\<tau>moves2_Invoke: \n  \"\\<lbrakk>\\<tau>moves2 P h stk es pc None; compEs2 es ! pc = Invoke M n \\<rbrakk> \n  \\<Longrightarrow> n < length stk \\<and> (stk ! n = Null \\<or> (\\<forall>T C Ts Tr D. typeof_addr h (the_Addr (stk ! n)) = \\<lfloor>T\\<rfloor> \\<longrightarrow> P \\<turnstile> class_type_of T sees M:Ts\\<rightarrow>Tr = Native in D \\<longrightarrow> \\<tau>external_defs D M))\"", "lemmas \\<tau>move2_compE2_not_Invoke = \\<tau>move2_Invoke", "lemmas \\<tau>moves2_compEs2_not_Invoke = \\<tau>moves2_Invoke", "lemma \\<tau>move2_blocks1 [simp]:\n  \"\\<tau>move2 P h stk (blocks1 n Ts body) pc' xcp' = \\<tau>move2 P h stk body pc' xcp'\"", "lemma \\<tau>instr_stk_append:\n  \"\\<tau>instr P h stk i \\<Longrightarrow> \\<tau>instr P h (stk @ vs) i\"", "lemma \\<tau>move2_stk_append:\n  \"\\<tau>move2 P h stk e pc xcp \\<Longrightarrow> \\<tau>move2 P h (stk @ vs) e pc xcp\"", "lemma \\<tau>moves2_stk_append:\n  \"\\<tau>moves2 P h stk es pc xcp \\<Longrightarrow> \\<tau>moves2 P h (stk @ vs) es pc xcp\"", "lemma \\<tau>Move2_iff:\n  \"\\<tau>Move2 P \\<sigma> = (let (xcp, h, frs) = \\<sigma>\n                 in case frs of [] \\<Rightarrow> False\n     | (stk, loc, C, M, pc) # frs' \\<Rightarrow> \n       (let (_,_,_,meth) = method P C M; (_,_,ins,xt) = the meth\n        in (pc < length ins \\<and> (xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc)))))\"", "lemma \\<tau>instr_compP [simp]: \"\\<tau>instr (compP f P) h stk i \\<longleftrightarrow> \\<tau>instr P h stk i\"", "lemma [simp]: fixes e :: \"'addr expr1\" and es :: \"'addr expr1 list\"\n  shows \\<tau>move2_compP: \"\\<tau>move2 (compP f P) h stk e = \\<tau>move2 P h stk e\"\n  and \\<tau>moves2_compP: \"\\<tau>moves2 (compP f P) h stk es = \\<tau>moves2 P h stk es\"", "lemma \\<tau>Move2_compP2:\n  \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>body\\<rfloor> in D \\<Longrightarrow> \n   \\<tau>Move2 (compP2 P) (xcp, h, (stk, loc, C, M, pc) # frs) =\n   (case xcp of None \\<Rightarrow> \\<tau>move2 P h stk body pc xcp \\<or> pc = length (compE2 body) | Some a \\<Rightarrow> pc < Suc (length (compE2 body)))\"", "lemma \\<tau>jvmd_heap_unchanged: \n  \"\\<lbrakk> P,t \\<turnstile> Normal (xcp, h, frs) -\\<epsilon>-jvmd\\<rightarrow> Normal (xcp', h', frs'); \\<tau>Move2 P (xcp, h, frs) \\<rbrakk>\n  \\<Longrightarrow> h = h'\"", "lemma mexecd_\\<tau>mthr_wf:\n  \"\\<tau>multithreaded_wf JVM_final (mexecd P) (\\<tau>MOVE2 P)\"", "lemma \\<tau>exec_1_taD:\n  assumes exec: \"exec_1_d P t (Normal (xcp, h, frs)) ta (Normal (xcp', h', frs'))\"\n  and \\<tau>: \"\\<tau>Move2 P (xcp, h, frs)\"\n  shows \"ta = \\<epsilon>\""], "translations": [["", "lemma \\<tau>moves2xcp: \"pc < length (compEs2 es) \\<Longrightarrow> \\<tau>moves2 P h stk es pc \\<lfloor>xcp\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (compEs2 es) \\<Longrightarrow>\n    \\<tau>moves2 P h stk es pc \\<lfloor>xcp\\<rfloor>", "proof(induct es arbitrary: pc)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>pc.\n       pc < length (compEs2 []) \\<Longrightarrow>\n       \\<tau>moves2 P h stk [] pc \\<lfloor>xcp\\<rfloor>\n 2. \\<And>a es pc.\n       \\<lbrakk>\\<And>pc.\n                   pc < length (compEs2 es) \\<Longrightarrow>\n                   \\<tau>moves2 P h stk es pc \\<lfloor>xcp\\<rfloor>;\n        pc < length (compEs2 (a # es))\\<rbrakk>\n       \\<Longrightarrow> \\<tau>moves2 P h stk (a # es) pc\n                          \\<lfloor>xcp\\<rfloor>", "case Nil"], ["proof (state)\nthis:\n  pc < length (compEs2 [])\n\ngoal (2 subgoals):\n 1. \\<And>pc.\n       pc < length (compEs2 []) \\<Longrightarrow>\n       \\<tau>moves2 P h stk [] pc \\<lfloor>xcp\\<rfloor>\n 2. \\<And>a es pc.\n       \\<lbrakk>\\<And>pc.\n                   pc < length (compEs2 es) \\<Longrightarrow>\n                   \\<tau>moves2 P h stk es pc \\<lfloor>xcp\\<rfloor>;\n        pc < length (compEs2 (a # es))\\<rbrakk>\n       \\<Longrightarrow> \\<tau>moves2 P h stk (a # es) pc\n                          \\<lfloor>xcp\\<rfloor>", "thus ?case"], ["proof (prove)\nusing this:\n  pc < length (compEs2 [])\n\ngoal (1 subgoal):\n 1. \\<tau>moves2 P h stk [] pc \\<lfloor>xcp\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  \\<tau>moves2 P h stk [] pc \\<lfloor>xcp\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a es pc.\n       \\<lbrakk>\\<And>pc.\n                   pc < length (compEs2 es) \\<Longrightarrow>\n                   \\<tau>moves2 P h stk es pc \\<lfloor>xcp\\<rfloor>;\n        pc < length (compEs2 (a # es))\\<rbrakk>\n       \\<Longrightarrow> \\<tau>moves2 P h stk (a # es) pc\n                          \\<lfloor>xcp\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a es pc.\n       \\<lbrakk>\\<And>pc.\n                   pc < length (compEs2 es) \\<Longrightarrow>\n                   \\<tau>moves2 P h stk es pc \\<lfloor>xcp\\<rfloor>;\n        pc < length (compEs2 (a # es))\\<rbrakk>\n       \\<Longrightarrow> \\<tau>moves2 P h stk (a # es) pc\n                          \\<lfloor>xcp\\<rfloor>", "case (Cons e es)"], ["proof (state)\nthis:\n  ?pc20 < length (compEs2 es) \\<Longrightarrow>\n  \\<tau>moves2 P h stk es ?pc20 \\<lfloor>xcp\\<rfloor>\n  pc < length (compEs2 (e # es))\n\ngoal (1 subgoal):\n 1. \\<And>a es pc.\n       \\<lbrakk>\\<And>pc.\n                   pc < length (compEs2 es) \\<Longrightarrow>\n                   \\<tau>moves2 P h stk es pc \\<lfloor>xcp\\<rfloor>;\n        pc < length (compEs2 (a # es))\\<rbrakk>\n       \\<Longrightarrow> \\<tau>moves2 P h stk (a # es) pc\n                          \\<lfloor>xcp\\<rfloor>", "note IH = \\<open>\\<And>pc. pc < length (compEs2 es) \\<Longrightarrow> \\<tau>moves2 P h stk es pc \\<lfloor>xcp\\<rfloor>\\<close>"], ["proof (state)\nthis:\n  ?pc < length (compEs2 es) \\<Longrightarrow>\n  \\<tau>moves2 P h stk es ?pc \\<lfloor>xcp\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a es pc.\n       \\<lbrakk>\\<And>pc.\n                   pc < length (compEs2 es) \\<Longrightarrow>\n                   \\<tau>moves2 P h stk es pc \\<lfloor>xcp\\<rfloor>;\n        pc < length (compEs2 (a # es))\\<rbrakk>\n       \\<Longrightarrow> \\<tau>moves2 P h stk (a # es) pc\n                          \\<lfloor>xcp\\<rfloor>", "note pc = \\<open>pc < length (compEs2 (e # es))\\<close>"], ["proof (state)\nthis:\n  pc < length (compEs2 (e # es))\n\ngoal (1 subgoal):\n 1. \\<And>a es pc.\n       \\<lbrakk>\\<And>pc.\n                   pc < length (compEs2 es) \\<Longrightarrow>\n                   \\<tau>moves2 P h stk es pc \\<lfloor>xcp\\<rfloor>;\n        pc < length (compEs2 (a # es))\\<rbrakk>\n       \\<Longrightarrow> \\<tau>moves2 P h stk (a # es) pc\n                          \\<lfloor>xcp\\<rfloor>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>moves2 P h stk (e # es) pc \\<lfloor>xcp\\<rfloor>", "proof(cases \"pc < length (compE2 e)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. pc < length (compE2 e) \\<Longrightarrow>\n    \\<tau>moves2 P h stk (e # es) pc \\<lfloor>xcp\\<rfloor>\n 2. \\<not> pc < length (compE2 e) \\<Longrightarrow>\n    \\<tau>moves2 P h stk (e # es) pc \\<lfloor>xcp\\<rfloor>", "case True"], ["proof (state)\nthis:\n  pc < length (compE2 e)\n\ngoal (2 subgoals):\n 1. pc < length (compE2 e) \\<Longrightarrow>\n    \\<tau>moves2 P h stk (e # es) pc \\<lfloor>xcp\\<rfloor>\n 2. \\<not> pc < length (compE2 e) \\<Longrightarrow>\n    \\<tau>moves2 P h stk (e # es) pc \\<lfloor>xcp\\<rfloor>", "thus ?thesis"], ["proof (prove)\nusing this:\n  pc < length (compE2 e)\n\ngoal (1 subgoal):\n 1. \\<tau>moves2 P h stk (e # es) pc \\<lfloor>xcp\\<rfloor>", "by(auto intro: \\<tau>moves2Hd \\<tau>move2xcp)"], ["proof (state)\nthis:\n  \\<tau>moves2 P h stk (e # es) pc \\<lfloor>xcp\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<not> pc < length (compE2 e) \\<Longrightarrow>\n    \\<tau>moves2 P h stk (e # es) pc \\<lfloor>xcp\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> pc < length (compE2 e) \\<Longrightarrow>\n    \\<tau>moves2 P h stk (e # es) pc \\<lfloor>xcp\\<rfloor>", "case False"], ["proof (state)\nthis:\n  \\<not> pc < length (compE2 e)\n\ngoal (1 subgoal):\n 1. \\<not> pc < length (compE2 e) \\<Longrightarrow>\n    \\<tau>moves2 P h stk (e # es) pc \\<lfloor>xcp\\<rfloor>", "with pc IH[of \"pc - length (compE2 e)\"]"], ["proof (chain)\npicking this:\n  pc < length (compEs2 (e # es))\n  pc - length (compE2 e) < length (compEs2 es) \\<Longrightarrow>\n  \\<tau>moves2 P h stk es (pc - length (compE2 e)) \\<lfloor>xcp\\<rfloor>\n  \\<not> pc < length (compE2 e)", "have \"\\<tau>moves2 P h stk es (pc - length (compE2 e)) \\<lfloor>xcp\\<rfloor>\""], ["proof (prove)\nusing this:\n  pc < length (compEs2 (e # es))\n  pc - length (compE2 e) < length (compEs2 es) \\<Longrightarrow>\n  \\<tau>moves2 P h stk es (pc - length (compE2 e)) \\<lfloor>xcp\\<rfloor>\n  \\<not> pc < length (compE2 e)\n\ngoal (1 subgoal):\n 1. \\<tau>moves2 P h stk es (pc - length (compE2 e)) \\<lfloor>xcp\\<rfloor>", "by(simp)"], ["proof (state)\nthis:\n  \\<tau>moves2 P h stk es (pc - length (compE2 e)) \\<lfloor>xcp\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<not> pc < length (compE2 e) \\<Longrightarrow>\n    \\<tau>moves2 P h stk (e # es) pc \\<lfloor>xcp\\<rfloor>", "hence \"\\<tau>moves2 P h stk (e # es) (length (compE2 e) + (pc - length (compE2 e))) \\<lfloor>xcp\\<rfloor>\""], ["proof (prove)\nusing this:\n  \\<tau>moves2 P h stk es (pc - length (compE2 e)) \\<lfloor>xcp\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<tau>moves2 P h stk (e # es)\n     (length (compE2 e) + (pc - length (compE2 e))) \\<lfloor>xcp\\<rfloor>", "by(rule \\<tau>moves2Tl)"], ["proof (state)\nthis:\n  \\<tau>moves2 P h stk (e # es)\n   (length (compE2 e) + (pc - length (compE2 e))) \\<lfloor>xcp\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<not> pc < length (compE2 e) \\<Longrightarrow>\n    \\<tau>moves2 P h stk (e # es) pc \\<lfloor>xcp\\<rfloor>", "with False"], ["proof (chain)\npicking this:\n  \\<not> pc < length (compE2 e)\n  \\<tau>moves2 P h stk (e # es)\n   (length (compE2 e) + (pc - length (compE2 e))) \\<lfloor>xcp\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> pc < length (compE2 e)\n  \\<tau>moves2 P h stk (e # es)\n   (length (compE2 e) + (pc - length (compE2 e))) \\<lfloor>xcp\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<tau>moves2 P h stk (e # es) pc \\<lfloor>xcp\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  \\<tau>moves2 P h stk (e # es) pc \\<lfloor>xcp\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<tau>moves2 P h stk (e # es) pc \\<lfloor>xcp\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<tau>move2_intros':\n  shows \\<tau>move2CastRed': \"pc = length (compE2 e) \\<Longrightarrow> \\<tau>move2 P h stk (Cast T e) pc None\"\n  and \\<tau>move2InstanceOfRed': \"pc = length (compE2 e) \\<Longrightarrow> \\<tau>move2 P h stk (e instanceof T) pc None\"\n  and \\<tau>move2BinOp2': \"\\<lbrakk> \\<tau>move2 P h stk e2 pc xcp; pc' = length (compE2 e1) + pc \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk (e1\\<guillemotleft>bop\\<guillemotright>e2) pc' xcp\"\n  and \\<tau>move2BinOp': \"pc = length (compE2 e1) + length (compE2 e2) \\<Longrightarrow> \\<tau>move2 P h stk (e1\\<guillemotleft>bop\\<guillemotright>e2) pc None\"\n  and \\<tau>move2LAssRed1': \"pc = length (compE2 e) \\<Longrightarrow> \\<tau>move2 P h stk (V:=e) pc None\"\n  and \\<tau>move2LAssRed2': \"pc = Suc (length (compE2 e)) \\<Longrightarrow> \\<tau>move2 P h stk (V:=e) pc None\"\n  and \\<tau>move2AAcc2': \"\\<lbrakk> \\<tau>move2 P h stk i pc xcp; pc' = length (compE2 a) + pc \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk (a\\<lfloor>i\\<rceil>) pc' xcp\"\n  and \\<tau>move2AAss2': \"\\<lbrakk> \\<tau>move2 P h stk i pc xcp; pc' = length (compE2 a) + pc \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk (a\\<lfloor>i\\<rceil> := e) pc' xcp\"\n  and \\<tau>move2AAss3': \"\\<lbrakk> \\<tau>move2 P h stk e pc xcp; pc' = length (compE2 a) + length (compE2 i) + pc \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk (a\\<lfloor>i\\<rceil> := e) pc' xcp\"\n  and \\<tau>move2AAssRed': \"pc = Suc (length (compE2 a) + length (compE2 i) + length (compE2 e)) \\<Longrightarrow> \\<tau>move2 P h stk (a\\<lfloor>i\\<rceil> := e) pc None\"\n  and \\<tau>move2FAss2': \"\\<lbrakk> \\<tau>move2 P h stk e' pc xcp; pc' = length (compE2 e) + pc \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk (e\\<bullet>F{D} := e') pc' xcp\"\n  and \\<tau>move2FAssRed': \"pc = Suc (length (compE2 e) + length (compE2 e')) \\<Longrightarrow> \\<tau>move2 P h stk (e\\<bullet>F{D} := e') pc None\"\n  and \\<tau>move2CAS2': \"\\<lbrakk> \\<tau>move2 P h stk e2 pc xcp; pc' = length (compE2 e1) + pc \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) pc' xcp\"\n  and \\<tau>move2CAS3': \"\\<lbrakk> \\<tau>move2 P h stk e3 pc xcp; pc' = length (compE2 e1) + length (compE2 e2) + pc \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) pc' xcp\"\n  and \\<tau>move2CallParams': \"\\<lbrakk> \\<tau>moves2 P h stk ps pc xcp; pc' = length (compE2 obj) + pc \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk (obj\\<bullet>M(ps)) pc' xcp\"\n  and \\<tau>move2Call': \"\\<lbrakk> pc = length (compE2 obj) + length (compEs2 ps); length ps < length stk; \n                     stk ! length ps = Null \\<or> \n                     (\\<forall>T Ts Tr D. typeof_addr h (the_Addr (stk ! length ps)) = \\<lfloor>T\\<rfloor> \\<longrightarrow> P \\<turnstile> class_type_of T sees M:Ts\\<rightarrow>Tr = Native in D \\<longrightarrow> \\<tau>external_defs D M) \\<rbrakk>\n                   \\<Longrightarrow> \\<tau>move2 P h stk (obj\\<bullet>M(ps)) pc None\"\n  and \\<tau>move2BlockSome2: \"pc = Suc 0 \\<Longrightarrow> \\<tau>move2 P h stk {V:T=\\<lfloor>v\\<rfloor>; e} pc None\"\n  and \\<tau>move2BlockSome': \"\\<lbrakk> \\<tau>move2 P h stk e pc xcp; pc' = Suc (Suc pc) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk {V:T=\\<lfloor>v\\<rfloor>; e} pc' xcp\"\n  and \\<tau>move2Sync2': \"pc = length (compE2 o') \\<Longrightarrow> \\<tau>move2 P h stk (sync\\<^bsub>V\\<^esub> (o') e) pc None\"\n  and \\<tau>move2Sync3': \"pc = Suc (length (compE2 o')) \\<Longrightarrow> \\<tau>move2 P h stk (sync\\<^bsub>V\\<^esub> (o') e) pc None\"\n  and \\<tau>move2Sync4': \"\\<lbrakk> \\<tau>move2 P h stk e pc xcp; pc' = Suc (Suc (Suc (length (compE2 o') + pc))) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk (sync\\<^bsub>V\\<^esub> (o') e) pc' xcp\"\n  and \\<tau>move2Sync5': \"pc = Suc (Suc (Suc (length (compE2 o') + length (compE2 e)))) \\<Longrightarrow> \\<tau>move2 P h stk (sync\\<^bsub>V\\<^esub> (o') e) pc None\"\n  and \\<tau>move2Sync6': \"pc = 5 + length (compE2 o') + length (compE2 e) \\<Longrightarrow> \\<tau>move2 P h stk (sync\\<^bsub>V\\<^esub> (o') e) pc None\"\n  and \\<tau>move2Sync7': \"pc = 6 + length (compE2 o') + length (compE2 e) \\<Longrightarrow> \\<tau>move2 P h stk (sync\\<^bsub>V\\<^esub> (o') e) pc None\"\n  and \\<tau>move2Sync8': \"pc = 8 + length (compE2 o') + length (compE2 e) \\<Longrightarrow> \\<tau>move2 P h stk (sync\\<^bsub>V\\<^esub> (o') e) pc None\"\n  and \\<tau>move2SeqRed': \"pc = length (compE2 e) \\<Longrightarrow> \\<tau>move2 P h stk (e;;e') pc None\"\n  and \\<tau>move2Seq2': \"\\<lbrakk> \\<tau>move2 P h stk e' pc xcp; pc' = Suc (length (compE2 e) + pc) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk (e;;e') pc' xcp\"\n  and \\<tau>move2CondRed': \"pc = length (compE2 e) \\<Longrightarrow> \\<tau>move2 P h stk (if (e) e1 else e2) pc None\"\n  and \\<tau>move2CondThen': \"\\<lbrakk> \\<tau>move2 P h stk e1 pc xcp; pc' = Suc (length (compE2 e) + pc) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk (if (e) e1 else e2) pc' xcp\"\n  and \\<tau>move2CondThenExit': \"pc = Suc (length (compE2 e) + length (compE2 e1)) \\<Longrightarrow> \\<tau>move2 P h stk (if (e) e1 else e2) pc None\"\n  and \\<tau>move2CondElse': \"\\<lbrakk> \\<tau>move2 P h stk e2 pc xcp; pc' = Suc (Suc (length (compE2 e) + length (compE2 e1) + pc)) \\<rbrakk> \n                        \\<Longrightarrow> \\<tau>move2 P h stk (if (e) e1 else e2) pc' xcp\"\n  and \\<tau>move2While2': \"\\<lbrakk> \\<tau>move2 P h stk e pc xcp; pc' = Suc (length (compE2 c) + pc) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk (while (c) e) pc' xcp\"\n  and \\<tau>move2While3': \"pc = Suc (Suc (length (compE2 c) + length (compE2 e))) \\<Longrightarrow> \\<tau>move2 P h stk (while (c) e) pc None\"\n  and \\<tau>move2While4': \"pc = Suc (Suc (Suc (length (compE2 c) + length (compE2 e)))) \\<Longrightarrow> \\<tau>move2 P h stk (while (c) e) pc None\"\n  and \\<tau>move2While5': \"pc = length (compE2 c) \\<Longrightarrow> \\<tau>move2 P h stk (while (c) e) pc None\"\n  and \\<tau>move2While6': \"pc = Suc (length (compE2 c) + length (compE2 e)) \\<Longrightarrow> \\<tau>move2 P h stk (while (c) e) pc None\"\n  and \\<tau>move2Throw2': \"pc = length (compE2 e) \\<Longrightarrow> \\<tau>move2 P h stk (throw e) pc None\"\n  and \\<tau>move2TryJump': \"pc = length (compE2 e) \\<Longrightarrow> \\<tau>move2 P h stk (try e catch(C V) e') pc None\"\n  and \\<tau>move2TryCatch2': \"pc = Suc (length (compE2 e)) \\<Longrightarrow> \\<tau>move2 P h stk (try e catch(C V) e') pc None\"\n  and \\<tau>move2Try2': \"\\<lbrakk> \\<tau>move2 P h stk {V:T=None; e'} pc xcp; pc' = Suc (Suc (length (compE2 e) + pc)) \\<rbrakk>\n                    \\<Longrightarrow> \\<tau>move2 P h stk (try e catch(C V) e') pc' xcp\"\n  and \\<tau>moves2Tl': \"\\<lbrakk> \\<tau>moves2 P h stk es pc xcp; pc' = length (compE2 e) + pc \\<rbrakk> \\<Longrightarrow> \\<tau>moves2 P h stk (e # es) pc' xcp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((((pc = length (compE2 e) \\<Longrightarrow>\n         \\<tau>move2 P h stk (Cast T e) pc None) &&&\n        (pc = length (compE2 e) \\<Longrightarrow>\n         \\<tau>move2 P h stk (e instanceof T) pc None)) &&&\n       (\\<lbrakk>\\<tau>move2 P h stk e2 pc xcp;\n         pc' = length (compE2 e1) + pc\\<rbrakk>\n        \\<Longrightarrow> \\<tau>move2 P h stk\n                           (e1 \\<guillemotleft>bop\\<guillemotright> e2) pc'\n                           xcp) &&&\n       (pc = length (compE2 e1) + length (compE2 e2) \\<Longrightarrow>\n        \\<tau>move2 P h stk (e1 \\<guillemotleft>bop\\<guillemotright> e2) pc\n         None) &&&\n       (pc = length (compE2 e) \\<Longrightarrow>\n        \\<tau>move2 P h stk (V:=e) pc None)) &&&\n      ((pc = Suc (length (compE2 e)) \\<Longrightarrow>\n        \\<tau>move2 P h stk (V:=e) pc None) &&&\n       (\\<lbrakk>\\<tau>move2 P h stk i pc xcp;\n         pc' = length (compE2 a) + pc\\<rbrakk>\n        \\<Longrightarrow> \\<tau>move2 P h stk (a\\<lfloor>i\\<rceil>) pc'\n                           xcp)) &&&\n      (\\<lbrakk>\\<tau>move2 P h stk i pc xcp;\n        pc' = length (compE2 a) + pc\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move2 P h stk (a\\<lfloor>i\\<rceil> := e) pc'\n                          xcp) &&&\n      (\\<lbrakk>\\<tau>move2 P h stk e pc xcp;\n        pc' = length (compE2 a) + length (compE2 i) + pc\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move2 P h stk (a\\<lfloor>i\\<rceil> := e) pc'\n                          xcp) &&&\n      (pc =\n       Suc (length (compE2 a) + length (compE2 i) +\n            length (compE2 e)) \\<Longrightarrow>\n       \\<tau>move2 P h stk (a\\<lfloor>i\\<rceil> := e) pc None)) &&&\n     (((\\<lbrakk>\\<tau>move2 P h stk e' pc xcp;\n         pc' = length (compE2 e) + pc\\<rbrakk>\n        \\<Longrightarrow> \\<tau>move2 P h stk (e\\<bullet>F{D} := e') pc'\n                           xcp) &&&\n       (pc = Suc (length (compE2 e) + length (compE2 e')) \\<Longrightarrow>\n        \\<tau>move2 P h stk (e\\<bullet>F{D} := e') pc None)) &&&\n      (\\<lbrakk>\\<tau>move2 P h stk e2 pc xcp;\n        pc' = length (compE2 e1) + pc\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move2 P h stk\n                          (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3))\n                          pc' xcp) &&&\n      (\\<lbrakk>\\<tau>move2 P h stk e3 pc xcp;\n        pc' = length (compE2 e1) + length (compE2 e2) + pc\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move2 P h stk\n                          (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3))\n                          pc' xcp) &&&\n      (\\<lbrakk>\\<tau>moves2 P h stk ps pc xcp;\n        pc' = length (compE2 obj) + pc\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move2 P h stk (obj\\<bullet>M(ps)) pc'\n                          xcp)) &&&\n     ((\\<lbrakk>pc = length (compE2 obj) + length (compEs2 ps);\n        length ps < length stk;\n        stk ! length ps = Null \\<or>\n        (\\<forall>T Ts Tr D.\n            typeof_addr h (the_Addr (stk ! length ps)) =\n            \\<lfloor>T\\<rfloor> \\<longrightarrow>\n            P \\<turnstile> class_type_of\n                            T sees M: Ts\\<rightarrow>Tr = Native in D \\<longrightarrow>\n            \\<tau>external_defs D M)\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move2 P h stk (obj\\<bullet>M(ps)) pc\n                          None) &&&\n      (pc = Suc 0 \\<Longrightarrow>\n       \\<tau>move2 P h stk {V:T=\\<lfloor>v\\<rfloor>; e} pc None)) &&&\n     (\\<lbrakk>\\<tau>move2 P h stk e pc xcp; pc' = Suc (Suc pc)\\<rbrakk>\n      \\<Longrightarrow> \\<tau>move2 P h stk {V:T=\\<lfloor>v\\<rfloor>; e} pc'\n                         xcp) &&&\n     (pc = length (compE2 o') \\<Longrightarrow>\n      \\<tau>move2 P h stk (sync\\<^bsub>V\\<^esub> (o') e) pc None) &&&\n     (pc = Suc (length (compE2 o')) \\<Longrightarrow>\n      \\<tau>move2 P h stk (sync\\<^bsub>V\\<^esub> (o') e) pc None)) &&&\n    ((((\\<lbrakk>\\<tau>move2 P h stk e pc xcp;\n         pc' = Suc (Suc (Suc (length (compE2 o') + pc)))\\<rbrakk>\n        \\<Longrightarrow> \\<tau>move2 P h stk (sync\\<^bsub>V\\<^esub> (o') e)\n                           pc' xcp) &&&\n       (pc =\n        Suc (Suc (Suc (length (compE2 o') +\n                       length (compE2 e)))) \\<Longrightarrow>\n        \\<tau>move2 P h stk (sync\\<^bsub>V\\<^esub> (o') e) pc None)) &&&\n      (pc = 5 + length (compE2 o') + length (compE2 e) \\<Longrightarrow>\n       \\<tau>move2 P h stk (sync\\<^bsub>V\\<^esub> (o') e) pc None) &&&\n      (pc = 6 + length (compE2 o') + length (compE2 e) \\<Longrightarrow>\n       \\<tau>move2 P h stk (sync\\<^bsub>V\\<^esub> (o') e) pc None) &&&\n      (pc = 8 + length (compE2 o') + length (compE2 e) \\<Longrightarrow>\n       \\<tau>move2 P h stk (sync\\<^bsub>V\\<^esub> (o') e) pc None)) &&&\n     ((pc = length (compE2 e) \\<Longrightarrow>\n       \\<tau>move2 P h stk (e;; e') pc None) &&&\n      (\\<lbrakk>\\<tau>move2 P h stk e' pc xcp;\n        pc' = Suc (length (compE2 e) + pc)\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move2 P h stk (e;; e') pc' xcp)) &&&\n     (pc = length (compE2 e) \\<Longrightarrow>\n      \\<tau>move2 P h stk (if (e) e1 else e2) pc None) &&&\n     (\\<lbrakk>\\<tau>move2 P h stk e1 pc xcp;\n       pc' = Suc (length (compE2 e) + pc)\\<rbrakk>\n      \\<Longrightarrow> \\<tau>move2 P h stk (if (e) e1 else e2) pc' xcp) &&&\n     (pc = Suc (length (compE2 e) + length (compE2 e1)) \\<Longrightarrow>\n      \\<tau>move2 P h stk (if (e) e1 else e2) pc None)) &&&\n    (((\\<lbrakk>\\<tau>move2 P h stk e2 pc xcp;\n        pc' =\n        Suc (Suc (length (compE2 e) + length (compE2 e1) + pc))\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move2 P h stk (if (e) e1 else e2) pc'\n                          xcp) &&&\n      (\\<lbrakk>\\<tau>move2 P h stk e pc xcp;\n        pc' = Suc (length (compE2 c) + pc)\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move2 P h stk (while (c) e) pc' xcp)) &&&\n     (pc =\n      Suc (Suc (length (compE2 c) + length (compE2 e))) \\<Longrightarrow>\n      \\<tau>move2 P h stk (while (c) e) pc None) &&&\n     (pc =\n      Suc (Suc (Suc (length (compE2 c) +\n                     length (compE2 e)))) \\<Longrightarrow>\n      \\<tau>move2 P h stk (while (c) e) pc None) &&&\n     (pc = length (compE2 c) \\<Longrightarrow>\n      \\<tau>move2 P h stk (while (c) e) pc None)) &&&\n    ((pc = Suc (length (compE2 c) + length (compE2 e)) \\<Longrightarrow>\n      \\<tau>move2 P h stk (while (c) e) pc None) &&&\n     (pc = length (compE2 e) \\<Longrightarrow>\n      \\<tau>move2 P h stk (throw e) pc None) &&&\n     (pc = length (compE2 e) \\<Longrightarrow>\n      \\<tau>move2 P h stk (try e catch(C V) e') pc None)) &&&\n    (pc = Suc (length (compE2 e)) \\<Longrightarrow>\n     \\<tau>move2 P h stk (try e catch(C V) e') pc None) &&&\n    (\\<lbrakk>\\<tau>move2 P h stk {V:T=None; e'} pc xcp;\n      pc' = Suc (Suc (length (compE2 e) + pc))\\<rbrakk>\n     \\<Longrightarrow> \\<tau>move2 P h stk (try e catch(C V) e') pc'\n                        xcp) &&&\n    (\\<lbrakk>\\<tau>moves2 P h stk es pc xcp;\n      pc' = length (compE2 e) + pc\\<rbrakk>\n     \\<Longrightarrow> \\<tau>moves2 P h stk (e # es) pc' xcp)", "apply(blast intro: \\<tau>move2_\\<tau>moves2.intros)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \\<tau>move2_iff: \"\\<tau>move2 P h stk e pc xcp \\<longleftrightarrow> pc < length (compE2 e) \\<and> (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compE2 e ! pc))\" (is \"?lhs1 \\<longleftrightarrow> ?rhs1\")\n  and \\<tau>moves2_iff: \"\\<tau>moves2 P h stk es pc xcp \\<longleftrightarrow> pc < length (compEs2 es) \\<and> (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compEs2 es ! pc))\" (is \"?lhs2 \\<longleftrightarrow> ?rhs2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>move2 P h stk e pc xcp =\n    (pc < length (compE2 e) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compE2 e ! pc))) &&&\n    \\<tau>moves2 P h stk es pc xcp =\n    (pc < length (compEs2 es) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compEs2 es ! pc)))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<tau>move2 P h stk e pc xcp =\n    (pc < length (compE2 e) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compE2 e ! pc)))\n 2. \\<tau>moves2 P h stk es pc xcp =\n    (pc < length (compEs2 es) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compEs2 es ! pc)))", "have rhs1lhs1: \"\\<lbrakk> \\<tau>instr P h stk (compE2 e ! pc); pc < length (compE2 e) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e pc None\"\n    and rhs2lhs2: \"\\<lbrakk> \\<tau>instr P h stk (compEs2 es ! pc); pc < length (compEs2 es) \\<rbrakk> \\<Longrightarrow> \\<tau>moves2 P h stk es pc None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<tau>instr P h stk (compE2 e ! pc);\n      pc < length (compE2 e)\\<rbrakk>\n     \\<Longrightarrow> \\<tau>move2 P h stk e pc None) &&&\n    (\\<lbrakk>\\<tau>instr P h stk (compEs2 es ! pc);\n      pc < length (compEs2 es)\\<rbrakk>\n     \\<Longrightarrow> \\<tau>moves2 P h stk es pc None)", "apply(induct e and es arbitrary: pc and pc rule: compE2.induct compEs2.induct)"], ["proof (prove)\ngoal (25 subgoals):\n 1. \\<And>x pc.\n       \\<lbrakk>\\<tau>instr P h stk (compE2 (new x) ! pc);\n        pc < length (compE2 (new x))\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move2 P h stk (new x) pc None\n 2. \\<And>x1 x2 pc.\n       \\<lbrakk>\\<And>pc.\n                   \\<lbrakk>\\<tau>instr P h stk (compE2 x2 ! pc);\n                    pc < length (compE2 x2)\\<rbrakk>\n                   \\<Longrightarrow> \\<tau>move2 P h stk x2 pc None;\n        \\<tau>instr P h stk (compE2 (newA x1\\<lfloor>x2\\<rceil>) ! pc);\n        pc < length (compE2 (newA x1\\<lfloor>x2\\<rceil>))\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move2 P h stk (newA x1\\<lfloor>x2\\<rceil>) pc\n                          None\n 3. \\<And>x1 x2 pc.\n       \\<lbrakk>\\<And>pc.\n                   \\<lbrakk>\\<tau>instr P h stk (compE2 x2 ! pc);\n                    pc < length (compE2 x2)\\<rbrakk>\n                   \\<Longrightarrow> \\<tau>move2 P h stk x2 pc None;\n        \\<tau>instr P h stk (compE2 (Cast x1 x2) ! pc);\n        pc < length (compE2 (Cast x1 x2))\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move2 P h stk (Cast x1 x2) pc None\n 4. \\<And>x1 x2 pc.\n       \\<lbrakk>\\<And>pc.\n                   \\<lbrakk>\\<tau>instr P h stk (compE2 x1 ! pc);\n                    pc < length (compE2 x1)\\<rbrakk>\n                   \\<Longrightarrow> \\<tau>move2 P h stk x1 pc None;\n        \\<tau>instr P h stk (compE2 (x1 instanceof x2) ! pc);\n        pc < length (compE2 (x1 instanceof x2))\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move2 P h stk (x1 instanceof x2) pc None\n 5. \\<And>x pc.\n       \\<lbrakk>\\<tau>instr P h stk (compE2 (Val x) ! pc);\n        pc < length (compE2 (Val x))\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move2 P h stk (Val x) pc None\n 6. \\<And>x1 x2 x3 pc.\n       \\<lbrakk>\\<And>pc.\n                   \\<lbrakk>\\<tau>instr P h stk (compE2 x1 ! pc);\n                    pc < length (compE2 x1)\\<rbrakk>\n                   \\<Longrightarrow> \\<tau>move2 P h stk x1 pc None;\n        \\<And>pc.\n           \\<lbrakk>\\<tau>instr P h stk (compE2 x3 ! pc);\n            pc < length (compE2 x3)\\<rbrakk>\n           \\<Longrightarrow> \\<tau>move2 P h stk x3 pc None;\n        \\<tau>instr P h stk\n         (compE2 (x1 \\<guillemotleft>x2\\<guillemotright> x3) ! pc);\n        pc < length\n              (compE2 (x1 \\<guillemotleft>x2\\<guillemotright> x3))\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move2 P h stk\n                          (x1 \\<guillemotleft>x2\\<guillemotright> x3) pc\n                          None\n 7. \\<And>x pc.\n       \\<lbrakk>\\<tau>instr P h stk (compE2 (Var x) ! pc);\n        pc < length (compE2 (Var x))\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move2 P h stk (Var x) pc None\n 8. \\<And>x1 x2 pc.\n       \\<lbrakk>\\<And>pc.\n                   \\<lbrakk>\\<tau>instr P h stk (compE2 x2 ! pc);\n                    pc < length (compE2 x2)\\<rbrakk>\n                   \\<Longrightarrow> \\<tau>move2 P h stk x2 pc None;\n        \\<tau>instr P h stk (compE2 (x1:=x2) ! pc);\n        pc < length (compE2 (x1:=x2))\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move2 P h stk (x1:=x2) pc None\n 9. \\<And>x1 x2 pc.\n       \\<lbrakk>\\<And>pc.\n                   \\<lbrakk>\\<tau>instr P h stk (compE2 x1 ! pc);\n                    pc < length (compE2 x1)\\<rbrakk>\n                   \\<Longrightarrow> \\<tau>move2 P h stk x1 pc None;\n        \\<And>pc.\n           \\<lbrakk>\\<tau>instr P h stk (compE2 x2 ! pc);\n            pc < length (compE2 x2)\\<rbrakk>\n           \\<Longrightarrow> \\<tau>move2 P h stk x2 pc None;\n        \\<tau>instr P h stk (compE2 (x1\\<lfloor>x2\\<rceil>) ! pc);\n        pc < length (compE2 (x1\\<lfloor>x2\\<rceil>))\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move2 P h stk (x1\\<lfloor>x2\\<rceil>) pc None\n 10. \\<And>x1 x2 x3 pc.\n        \\<lbrakk>\\<And>pc.\n                    \\<lbrakk>\\<tau>instr P h stk (compE2 x1 ! pc);\n                     pc < length (compE2 x1)\\<rbrakk>\n                    \\<Longrightarrow> \\<tau>move2 P h stk x1 pc None;\n         \\<And>pc.\n            \\<lbrakk>\\<tau>instr P h stk (compE2 x2 ! pc);\n             pc < length (compE2 x2)\\<rbrakk>\n            \\<Longrightarrow> \\<tau>move2 P h stk x2 pc None;\n         \\<And>pc.\n            \\<lbrakk>\\<tau>instr P h stk (compE2 x3 ! pc);\n             pc < length (compE2 x3)\\<rbrakk>\n            \\<Longrightarrow> \\<tau>move2 P h stk x3 pc None;\n         \\<tau>instr P h stk (compE2 (x1\\<lfloor>x2\\<rceil> := x3) ! pc);\n         pc < length (compE2 (x1\\<lfloor>x2\\<rceil> := x3))\\<rbrakk>\n        \\<Longrightarrow> \\<tau>move2 P h stk (x1\\<lfloor>x2\\<rceil> := x3)\n                           pc None\nA total of 25 subgoals...", "apply(force intro: \\<tau>move2_\\<tau>moves2.intros \\<tau>move2_intros' simp add: nth_append nth_Cons' not_less_eq split: if_split_asm)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>\\<tau>instr P h stk (compE2 e ! pc);\n   pc < length (compE2 e)\\<rbrakk>\n  \\<Longrightarrow> \\<tau>move2 P h stk e pc None\n  \\<lbrakk>\\<tau>instr P h stk (compEs2 es ! pc);\n   pc < length (compEs2 es)\\<rbrakk>\n  \\<Longrightarrow> \\<tau>moves2 P h stk es pc None\n\ngoal (2 subgoals):\n 1. \\<tau>move2 P h stk e pc xcp =\n    (pc < length (compE2 e) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compE2 e ! pc)))\n 2. \\<tau>moves2 P h stk es pc xcp =\n    (pc < length (compEs2 es) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compEs2 es ! pc)))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>\\<tau>instr P h stk (compE2 e ! pc);\n   pc < length (compE2 e)\\<rbrakk>\n  \\<Longrightarrow> \\<tau>move2 P h stk e pc None\n  \\<lbrakk>\\<tau>instr P h stk (compEs2 es ! pc);\n   pc < length (compEs2 es)\\<rbrakk>\n  \\<Longrightarrow> \\<tau>moves2 P h stk es pc None\n\ngoal (2 subgoals):\n 1. \\<tau>move2 P h stk e pc xcp =\n    (pc < length (compE2 e) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compE2 e ! pc)))\n 2. \\<tau>moves2 P h stk es pc xcp =\n    (pc < length (compEs2 es) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compEs2 es ! pc)))", "assume \"pc < length (compE2 e)\" \"xcp \\<noteq> None\""], ["proof (state)\nthis:\n  pc < length (compE2 e)\n  xcp \\<noteq> None\n\ngoal (2 subgoals):\n 1. \\<tau>move2 P h stk e pc xcp =\n    (pc < length (compE2 e) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compE2 e ! pc)))\n 2. \\<tau>moves2 P h stk es pc xcp =\n    (pc < length (compEs2 es) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compEs2 es ! pc)))", "hence \"\\<tau>move2 P h stk e pc xcp\""], ["proof (prove)\nusing this:\n  pc < length (compE2 e)\n  xcp \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<tau>move2 P h stk e pc xcp", "by(auto intro: \\<tau>move2xcp)"], ["proof (state)\nthis:\n  \\<tau>move2 P h stk e pc xcp\n\ngoal (2 subgoals):\n 1. \\<tau>move2 P h stk e pc xcp =\n    (pc < length (compE2 e) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compE2 e ! pc)))\n 2. \\<tau>moves2 P h stk es pc xcp =\n    (pc < length (compEs2 es) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compEs2 es ! pc)))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>pc < length (compE2 e); xcp \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp\n\ngoal (2 subgoals):\n 1. \\<tau>move2 P h stk e pc xcp =\n    (pc < length (compE2 e) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compE2 e ! pc)))\n 2. \\<tau>moves2 P h stk es pc xcp =\n    (pc < length (compEs2 es) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compEs2 es ! pc)))", "with rhs1lhs1"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<tau>instr P h stk (compE2 e ! pc);\n   pc < length (compE2 e)\\<rbrakk>\n  \\<Longrightarrow> \\<tau>move2 P h stk e pc None\n  \\<lbrakk>pc < length (compE2 e); xcp \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp", "have \"?rhs1 \\<Longrightarrow> ?lhs1\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<tau>instr P h stk (compE2 e ! pc);\n   pc < length (compE2 e)\\<rbrakk>\n  \\<Longrightarrow> \\<tau>move2 P h stk e pc None\n  \\<lbrakk>pc < length (compE2 e); xcp \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp\n\ngoal (1 subgoal):\n 1. pc < length (compE2 e) \\<and>\n    (xcp = None \\<longrightarrow>\n     \\<tau>instr P h stk (compE2 e ! pc)) \\<Longrightarrow>\n    \\<tau>move2 P h stk e pc xcp", "by(cases xcp) auto"], ["proof (state)\nthis:\n  pc < length (compE2 e) \\<and>\n  (xcp = None \\<longrightarrow>\n   \\<tau>instr P h stk (compE2 e ! pc)) \\<Longrightarrow>\n  \\<tau>move2 P h stk e pc xcp\n\ngoal (2 subgoals):\n 1. \\<tau>move2 P h stk e pc xcp =\n    (pc < length (compE2 e) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compE2 e ! pc)))\n 2. \\<tau>moves2 P h stk es pc xcp =\n    (pc < length (compEs2 es) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compEs2 es ! pc)))", "moreover"], ["proof (state)\nthis:\n  pc < length (compE2 e) \\<and>\n  (xcp = None \\<longrightarrow>\n   \\<tau>instr P h stk (compE2 e ! pc)) \\<Longrightarrow>\n  \\<tau>move2 P h stk e pc xcp\n\ngoal (2 subgoals):\n 1. \\<tau>move2 P h stk e pc xcp =\n    (pc < length (compE2 e) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compE2 e ! pc)))\n 2. \\<tau>moves2 P h stk es pc xcp =\n    (pc < length (compEs2 es) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compEs2 es ! pc)))", "{"], ["proof (state)\nthis:\n  pc < length (compE2 e) \\<and>\n  (xcp = None \\<longrightarrow>\n   \\<tau>instr P h stk (compE2 e ! pc)) \\<Longrightarrow>\n  \\<tau>move2 P h stk e pc xcp\n\ngoal (2 subgoals):\n 1. \\<tau>move2 P h stk e pc xcp =\n    (pc < length (compE2 e) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compE2 e ! pc)))\n 2. \\<tau>moves2 P h stk es pc xcp =\n    (pc < length (compEs2 es) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compEs2 es ! pc)))", "assume \"pc < length (compEs2 es)\" \"xcp \\<noteq> None\""], ["proof (state)\nthis:\n  pc < length (compEs2 es)\n  xcp \\<noteq> None\n\ngoal (2 subgoals):\n 1. \\<tau>move2 P h stk e pc xcp =\n    (pc < length (compE2 e) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compE2 e ! pc)))\n 2. \\<tau>moves2 P h stk es pc xcp =\n    (pc < length (compEs2 es) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compEs2 es ! pc)))", "hence \"\\<tau>moves2 P h stk es pc xcp\""], ["proof (prove)\nusing this:\n  pc < length (compEs2 es)\n  xcp \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<tau>moves2 P h stk es pc xcp", "by(auto intro: \\<tau>moves2xcp)"], ["proof (state)\nthis:\n  \\<tau>moves2 P h stk es pc xcp\n\ngoal (2 subgoals):\n 1. \\<tau>move2 P h stk e pc xcp =\n    (pc < length (compE2 e) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compE2 e ! pc)))\n 2. \\<tau>moves2 P h stk es pc xcp =\n    (pc < length (compEs2 es) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compEs2 es ! pc)))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>pc < length (compEs2 es); xcp \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> \\<tau>moves2 P h stk es pc xcp\n\ngoal (2 subgoals):\n 1. \\<tau>move2 P h stk e pc xcp =\n    (pc < length (compE2 e) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compE2 e ! pc)))\n 2. \\<tau>moves2 P h stk es pc xcp =\n    (pc < length (compEs2 es) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compEs2 es ! pc)))", "with rhs2lhs2"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<tau>instr P h stk (compEs2 es ! pc);\n   pc < length (compEs2 es)\\<rbrakk>\n  \\<Longrightarrow> \\<tau>moves2 P h stk es pc None\n  \\<lbrakk>pc < length (compEs2 es); xcp \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> \\<tau>moves2 P h stk es pc xcp", "have \"?rhs2 \\<Longrightarrow> ?lhs2\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<tau>instr P h stk (compEs2 es ! pc);\n   pc < length (compEs2 es)\\<rbrakk>\n  \\<Longrightarrow> \\<tau>moves2 P h stk es pc None\n  \\<lbrakk>pc < length (compEs2 es); xcp \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> \\<tau>moves2 P h stk es pc xcp\n\ngoal (1 subgoal):\n 1. pc < length (compEs2 es) \\<and>\n    (xcp = None \\<longrightarrow>\n     \\<tau>instr P h stk (compEs2 es ! pc)) \\<Longrightarrow>\n    \\<tau>moves2 P h stk es pc xcp", "by(cases xcp) auto"], ["proof (state)\nthis:\n  pc < length (compEs2 es) \\<and>\n  (xcp = None \\<longrightarrow>\n   \\<tau>instr P h stk (compEs2 es ! pc)) \\<Longrightarrow>\n  \\<tau>moves2 P h stk es pc xcp\n\ngoal (2 subgoals):\n 1. \\<tau>move2 P h stk e pc xcp =\n    (pc < length (compE2 e) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compE2 e ! pc)))\n 2. \\<tau>moves2 P h stk es pc xcp =\n    (pc < length (compEs2 es) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compEs2 es ! pc)))", "moreover"], ["proof (state)\nthis:\n  pc < length (compEs2 es) \\<and>\n  (xcp = None \\<longrightarrow>\n   \\<tau>instr P h stk (compEs2 es ! pc)) \\<Longrightarrow>\n  \\<tau>moves2 P h stk es pc xcp\n\ngoal (2 subgoals):\n 1. \\<tau>move2 P h stk e pc xcp =\n    (pc < length (compE2 e) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compE2 e ! pc)))\n 2. \\<tau>moves2 P h stk es pc xcp =\n    (pc < length (compEs2 es) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compEs2 es ! pc)))", "have \"?lhs1 \\<Longrightarrow> ?rhs1\" and \"?lhs2 \\<Longrightarrow> ?rhs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau>move2 P h stk e pc xcp \\<Longrightarrow>\n     pc < length (compE2 e) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compE2 e ! pc))) &&&\n    (\\<tau>moves2 P h stk es pc xcp \\<Longrightarrow>\n     pc < length (compEs2 es) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compEs2 es ! pc)))", "by(induct rule: \\<tau>move2_\\<tau>moves2.inducts)(fastforce simp add: nth_append eval_nat_numeral)+"], ["proof (state)\nthis:\n  \\<tau>move2 P h stk e pc xcp \\<Longrightarrow>\n  pc < length (compE2 e) \\<and>\n  (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compE2 e ! pc))\n  \\<tau>moves2 P h stk es pc xcp \\<Longrightarrow>\n  pc < length (compEs2 es) \\<and>\n  (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compEs2 es ! pc))\n\ngoal (2 subgoals):\n 1. \\<tau>move2 P h stk e pc xcp =\n    (pc < length (compE2 e) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compE2 e ! pc)))\n 2. \\<tau>moves2 P h stk es pc xcp =\n    (pc < length (compEs2 es) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compEs2 es ! pc)))", "ultimately"], ["proof (chain)\npicking this:\n  pc < length (compE2 e) \\<and>\n  (xcp = None \\<longrightarrow>\n   \\<tau>instr P h stk (compE2 e ! pc)) \\<Longrightarrow>\n  \\<tau>move2 P h stk e pc xcp\n  pc < length (compEs2 es) \\<and>\n  (xcp = None \\<longrightarrow>\n   \\<tau>instr P h stk (compEs2 es ! pc)) \\<Longrightarrow>\n  \\<tau>moves2 P h stk es pc xcp\n  \\<tau>move2 P h stk e pc xcp \\<Longrightarrow>\n  pc < length (compE2 e) \\<and>\n  (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compE2 e ! pc))\n  \\<tau>moves2 P h stk es pc xcp \\<Longrightarrow>\n  pc < length (compEs2 es) \\<and>\n  (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compEs2 es ! pc))", "show \"?lhs1 \\<longleftrightarrow> ?rhs1\" \"?lhs2 \\<longleftrightarrow> ?rhs2\""], ["proof (prove)\nusing this:\n  pc < length (compE2 e) \\<and>\n  (xcp = None \\<longrightarrow>\n   \\<tau>instr P h stk (compE2 e ! pc)) \\<Longrightarrow>\n  \\<tau>move2 P h stk e pc xcp\n  pc < length (compEs2 es) \\<and>\n  (xcp = None \\<longrightarrow>\n   \\<tau>instr P h stk (compEs2 es ! pc)) \\<Longrightarrow>\n  \\<tau>moves2 P h stk es pc xcp\n  \\<tau>move2 P h stk e pc xcp \\<Longrightarrow>\n  pc < length (compE2 e) \\<and>\n  (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compE2 e ! pc))\n  \\<tau>moves2 P h stk es pc xcp \\<Longrightarrow>\n  pc < length (compEs2 es) \\<and>\n  (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compEs2 es ! pc))\n\ngoal (1 subgoal):\n 1. \\<tau>move2 P h stk e pc xcp =\n    (pc < length (compE2 e) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compE2 e ! pc))) &&&\n    \\<tau>moves2 P h stk es pc xcp =\n    (pc < length (compEs2 es) \\<and>\n     (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compEs2 es ! pc)))", "by blast+"], ["proof (state)\nthis:\n  \\<tau>move2 P h stk e pc xcp =\n  (pc < length (compE2 e) \\<and>\n   (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compE2 e ! pc)))\n  \\<tau>moves2 P h stk es pc xcp =\n  (pc < length (compEs2 es) \\<and>\n   (xcp = None \\<longrightarrow> \\<tau>instr P h stk (compEs2 es ! pc)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<tau>move2_pc_length_compE2: \"\\<tau>move2 P h stk e pc xcp \\<Longrightarrow> pc < length (compE2 e)\"\n  and \\<tau>moves2_pc_length_compEs2: \"\\<tau>moves2 P h stk es pc xcp \\<Longrightarrow> pc < length (compEs2 es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau>move2 P h stk e pc xcp \\<Longrightarrow>\n     pc < length (compE2 e)) &&&\n    (\\<tau>moves2 P h stk es pc xcp \\<Longrightarrow>\n     pc < length (compEs2 es))", "by(simp_all add: \\<tau>move2_iff \\<tau>moves2_iff)"], ["", "lemma \\<tau>move2_pc_length_compE2_conv: \"pc \\<ge> length (compE2 e) \\<Longrightarrow> \\<not> \\<tau>move2 P h stk e pc xcp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (compE2 e) \\<le> pc \\<Longrightarrow>\n    \\<not> \\<tau>move2 P h stk e pc xcp", "by(auto dest: \\<tau>move2_pc_length_compE2)"], ["", "lemma \\<tau>moves2_pc_length_compEs2_conv: \"pc \\<ge> length (compEs2 es) \\<Longrightarrow> \\<not> \\<tau>moves2 P h stk es pc xcp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (compEs2 es) \\<le> pc \\<Longrightarrow>\n    \\<not> \\<tau>moves2 P h stk es pc xcp", "by(auto dest: \\<tau>moves2_pc_length_compEs2)"], ["", "lemma \\<tau>moves2_append [elim]:\n  \"\\<tau>moves2 P h stk es pc xcp \\<Longrightarrow> \\<tau>moves2 P h stk (es @ es') pc xcp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>moves2 P h stk es pc xcp \\<Longrightarrow>\n    \\<tau>moves2 P h stk (es @ es') pc xcp", "by(auto simp add: \\<tau>moves2_iff nth_append)"], ["", "lemma append_\\<tau>moves2:\n  \"\\<tau>moves2 P h stk es pc xcp \\<Longrightarrow> \\<tau>moves2 P h stk (es' @ es) (length (compEs2 es') + pc) xcp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>moves2 P h stk es pc xcp \\<Longrightarrow>\n    \\<tau>moves2 P h stk (es' @ es) (length (compEs2 es') + pc) xcp", "by(simp add: \\<tau>moves2_iff)"], ["", "lemma [dest]:\n  shows \\<tau>move2_NewArrayD: \"\\<lbrakk> \\<tau>move2 P h stk (newA T\\<lfloor>e\\<rceil>) pc xcp; pc < length (compE2 e) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp\"\n  and \\<tau>move2_CastD: \"\\<lbrakk> \\<tau>move2 P h stk (Cast T e) pc xcp; pc < length (compE2 e) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp\"\n  and \\<tau>move2_InstanceOfD: \"\\<lbrakk> \\<tau>move2 P h stk (e instanceof T) pc xcp; pc < length (compE2 e) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp\"\n  and \\<tau>move2_BinOp1D: \"\\<lbrakk> \\<tau>move2 P h stk (e1 \\<guillemotleft>bop\\<guillemotright> e2) pc' xcp'; pc' < length (compE2 e1) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e1 pc' xcp'\"\n  and \\<tau>move2_BinOp2D:\n  \"\\<lbrakk> \\<tau>move2 P h stk (e1 \\<guillemotleft>bop\\<guillemotright> e2) (length (compE2 e1) + pc') xcp'; pc' < length (compE2 e2) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e2 pc' xcp'\"\n  and \\<tau>move2_LAssD: \"\\<lbrakk> \\<tau>move2 P h stk (V := e) pc xcp; pc < length (compE2 e) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp\"\n  and \\<tau>move2_AAccD1: \"\\<lbrakk> \\<tau>move2 P h stk (a\\<lfloor>i\\<rceil>) pc xcp; pc < length (compE2 a) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk a pc xcp\"\n  and \\<tau>move2_AAccD2: \"\\<lbrakk> \\<tau>move2 P h stk (a\\<lfloor>i\\<rceil>) (length (compE2 a) + pc) xcp; pc < length (compE2 i) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk i pc xcp\"\n  and \\<tau>move2_AAssD1: \"\\<lbrakk> \\<tau>move2 P h stk (a\\<lfloor>i\\<rceil> := e) pc xcp; pc < length (compE2 a) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk a pc xcp\"\n  and \\<tau>move2_AAssD2: \"\\<lbrakk> \\<tau>move2 P h stk (a\\<lfloor>i\\<rceil> := e) (length (compE2 a) + pc) xcp; pc < length (compE2 i) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk i pc xcp\"\n  and \\<tau>move2_AAssD3:\n  \"\\<lbrakk> \\<tau>move2 P h stk (a\\<lfloor>i\\<rceil> := e) (length (compE2 a) + length (compE2 i) + pc) xcp; pc < length (compE2 e) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp\"\n  and \\<tau>move2_ALengthD: \"\\<lbrakk> \\<tau>move2 P h stk (a\\<bullet>length) pc xcp; pc < length (compE2 a) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk a pc xcp\"\n  and \\<tau>move2_FAccD: \"\\<lbrakk> \\<tau>move2 P h stk (e\\<bullet>F{D}) pc xcp; pc < length (compE2 e) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp\"\n  and \\<tau>move2_FAssD1: \"\\<lbrakk> \\<tau>move2 P h stk (e\\<bullet>F{D} := e') pc xcp; pc < length (compE2 e) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp\"\n  and \\<tau>move2_FAssD2: \"\\<lbrakk> \\<tau>move2 P h stk (e\\<bullet>F{D} := e') (length (compE2 e) + pc) xcp; pc < length (compE2 e') \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e' pc xcp\"\n  and \\<tau>move2_CASD1: \"\\<lbrakk> \\<tau>move2 P h stk (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) pc xcp; pc < length (compE2 e1) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e1 pc xcp\"\n  and \\<tau>move2_CASD2: \"\\<lbrakk> \\<tau>move2 P h stk (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) (length (compE2 e1) + pc) xcp; pc < length (compE2 e2) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e2 pc xcp\"\n  and \\<tau>move2_CASD3:\n  \"\\<lbrakk> \\<tau>move2 P h stk (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) (length (compE2 e1) + length (compE2 e2) + pc) xcp; pc < length (compE2 e3) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e3 pc xcp\"\n  and \\<tau>move2_CallObjD: \"\\<lbrakk> \\<tau>move2 P h stk (e\\<bullet>M(es)) pc xcp; pc < length (compE2 e) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp\"\n  and \\<tau>move2_BlockNoneD: \"\\<tau>move2 P h stk {V:T=None; e} pc xcp \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp\"\n  and \\<tau>move2_BlockSomeD: \"\\<tau>move2 P h stk {V:T=\\<lfloor>v\\<rfloor>; e} (Suc (Suc pc)) xcp \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp\"\n  and \\<tau>move2_sync1D: \"\\<lbrakk> \\<tau>move2 P h stk (sync\\<^bsub>V\\<^esub> (o') e) pc xcp; pc < length (compE2 o') \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk o' pc xcp\"\n  and \\<tau>move2_sync2D:\n  \"\\<lbrakk> \\<tau>move2 P h stk (sync\\<^bsub>V\\<^esub> (o') e) (Suc (Suc (Suc (length (compE2 o') + pc)))) xcp; pc < length (compE2 e) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp\"\n  and \\<tau>move2_Seq1D: \"\\<lbrakk> \\<tau>move2 P h stk (e1;; e2) pc xcp; pc < length (compE2 e1) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e1 pc xcp\"\n  and \\<tau>move2_Seq2D: \"\\<tau>move2 P h stk (e1;; e2) (Suc (length (compE2 e1) + pc')) xcp' \\<Longrightarrow> \\<tau>move2 P h stk e2 pc' xcp'\"\n  and \\<tau>move2_IfCondD: \"\\<lbrakk> \\<tau>move2 P h stk (if (e) e1 else e2) pc xcp; pc < length (compE2 e) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp\"\n  and \\<tau>move2_IfThenD:\n  \"\\<lbrakk> \\<tau>move2 P h stk (if (e) e1 else e2) (Suc (length (compE2 e) + pc')) xcp'; pc' < length (compE2 e1) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e1 pc' xcp'\"\n  and \\<tau>move2_IfElseD:\n  \"\\<tau>move2 P h stk (if (e) e1 else e2) (Suc (Suc (length (compE2 e) + length (compE2 e1) + pc'))) xcp' \\<Longrightarrow> \\<tau>move2 P h stk e2 pc' xcp'\"\n  and \\<tau>move2_WhileCondD: \"\\<lbrakk> \\<tau>move2 P h stk (while (c) b) pc xcp; pc < length (compE2 c) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk c pc xcp\"\n  and \\<tau>move2_ThrowD: \"\\<lbrakk> \\<tau>move2 P h stk (throw e) pc xcp; pc < length (compE2 e) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp\"\n  and \\<tau>move2_Try1D: \"\\<lbrakk> \\<tau>move2 P h stk (try e1 catch(C' V) e2) pc xcp; pc < length (compE2 e1) \\<rbrakk> \\<Longrightarrow> \\<tau>move2 P h stk e1 pc xcp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((((\\<lbrakk>\\<tau>move2 P h stk (newA T\\<lfloor>e\\<rceil>) pc xcp;\n         pc < length (compE2 e)\\<rbrakk>\n        \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp) &&&\n       (\\<lbrakk>\\<tau>move2 P h stk (Cast T e) pc xcp;\n         pc < length (compE2 e)\\<rbrakk>\n        \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp) &&&\n       (\\<lbrakk>\\<tau>move2 P h stk (e instanceof T) pc xcp;\n         pc < length (compE2 e)\\<rbrakk>\n        \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp)) &&&\n      ((\\<lbrakk>\\<tau>move2 P h stk\n                  (e1 \\<guillemotleft>bop\\<guillemotright> e2) pc' xcp';\n         pc' < length (compE2 e1)\\<rbrakk>\n        \\<Longrightarrow> \\<tau>move2 P h stk e1 pc' xcp') &&&\n       (\\<lbrakk>\\<tau>move2 P h stk\n                  (e1 \\<guillemotleft>bop\\<guillemotright> e2)\n                  (length (compE2 e1) + pc') xcp';\n         pc' < length (compE2 e2)\\<rbrakk>\n        \\<Longrightarrow> \\<tau>move2 P h stk e2 pc' xcp')) &&&\n      (\\<lbrakk>\\<tau>move2 P h stk (V:=e) pc xcp;\n        pc < length (compE2 e)\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp) &&&\n      (\\<lbrakk>\\<tau>move2 P h stk (a\\<lfloor>i\\<rceil>) pc xcp;\n        pc < length (compE2 a)\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move2 P h stk a pc xcp)) &&&\n     (((\\<lbrakk>\\<tau>move2 P h stk (a\\<lfloor>i\\<rceil>)\n                  (length (compE2 a) + pc) xcp;\n         pc < length (compE2 i)\\<rbrakk>\n        \\<Longrightarrow> \\<tau>move2 P h stk i pc xcp) &&&\n       (\\<lbrakk>\\<tau>move2 P h stk (a\\<lfloor>i\\<rceil> := e) pc xcp;\n         pc < length (compE2 a)\\<rbrakk>\n        \\<Longrightarrow> \\<tau>move2 P h stk a pc xcp)) &&&\n      (\\<lbrakk>\\<tau>move2 P h stk (a\\<lfloor>i\\<rceil> := e)\n                 (length (compE2 a) + pc) xcp;\n        pc < length (compE2 i)\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move2 P h stk i pc xcp) &&&\n      (\\<lbrakk>\\<tau>move2 P h stk (a\\<lfloor>i\\<rceil> := e)\n                 (length (compE2 a) + length (compE2 i) + pc) xcp;\n        pc < length (compE2 e)\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp)) &&&\n     ((\\<lbrakk>\\<tau>move2 P h stk (a\\<bullet>length) pc xcp;\n        pc < length (compE2 a)\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move2 P h stk a pc xcp) &&&\n      (\\<lbrakk>\\<tau>move2 P h stk (e\\<bullet>F{D}) pc xcp;\n        pc < length (compE2 e)\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp)) &&&\n     (\\<lbrakk>\\<tau>move2 P h stk (e\\<bullet>F{D} := e') pc xcp;\n       pc < length (compE2 e)\\<rbrakk>\n      \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp) &&&\n     (\\<lbrakk>\\<tau>move2 P h stk (e\\<bullet>F{D} := e')\n                (length (compE2 e) + pc) xcp;\n       pc < length (compE2 e')\\<rbrakk>\n      \\<Longrightarrow> \\<tau>move2 P h stk e' pc xcp)) &&&\n    ((((\\<lbrakk>\\<tau>move2 P h stk\n                  (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) pc xcp;\n         pc < length (compE2 e1)\\<rbrakk>\n        \\<Longrightarrow> \\<tau>move2 P h stk e1 pc xcp) &&&\n       (\\<lbrakk>\\<tau>move2 P h stk\n                  (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3))\n                  (length (compE2 e1) + pc) xcp;\n         pc < length (compE2 e2)\\<rbrakk>\n        \\<Longrightarrow> \\<tau>move2 P h stk e2 pc xcp)) &&&\n      (\\<lbrakk>\\<tau>move2 P h stk\n                 (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3))\n                 (length (compE2 e1) + length (compE2 e2) + pc) xcp;\n        pc < length (compE2 e3)\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move2 P h stk e3 pc xcp) &&&\n      (\\<lbrakk>\\<tau>move2 P h stk (e\\<bullet>M(es)) pc xcp;\n        pc < length (compE2 e)\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp)) &&&\n     ((\\<tau>move2 P h stk {V:T=None; e} pc xcp \\<Longrightarrow>\n       \\<tau>move2 P h stk e pc xcp) &&&\n      (\\<tau>move2 P h stk {V:T=\\<lfloor>v\\<rfloor>; e} (Suc (Suc pc))\n        xcp \\<Longrightarrow>\n       \\<tau>move2 P h stk e pc xcp)) &&&\n     (\\<lbrakk>\\<tau>move2 P h stk (sync\\<^bsub>V\\<^esub> (o') e) pc xcp;\n       pc < length (compE2 o')\\<rbrakk>\n      \\<Longrightarrow> \\<tau>move2 P h stk o' pc xcp) &&&\n     (\\<lbrakk>\\<tau>move2 P h stk (sync\\<^bsub>V\\<^esub> (o') e)\n                (Suc (Suc (Suc (length (compE2 o') + pc)))) xcp;\n       pc < length (compE2 e)\\<rbrakk>\n      \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp)) &&&\n    (((\\<lbrakk>\\<tau>move2 P h stk (e1;; e2) pc xcp;\n        pc < length (compE2 e1)\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move2 P h stk e1 pc xcp) &&&\n      (\\<tau>move2 P h stk (e1;; e2) (Suc (length (compE2 e1) + pc'))\n        xcp' \\<Longrightarrow>\n       \\<tau>move2 P h stk e2 pc' xcp')) &&&\n     (\\<lbrakk>\\<tau>move2 P h stk (if (e) e1 else e2) pc xcp;\n       pc < length (compE2 e)\\<rbrakk>\n      \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp) &&&\n     (\\<lbrakk>\\<tau>move2 P h stk (if (e) e1 else e2)\n                (Suc (length (compE2 e) + pc')) xcp';\n       pc' < length (compE2 e1)\\<rbrakk>\n      \\<Longrightarrow> \\<tau>move2 P h stk e1 pc' xcp')) &&&\n    ((\\<tau>move2 P h stk (if (e) e1 else e2)\n       (Suc (Suc (length (compE2 e) + length (compE2 e1) + pc')))\n       xcp' \\<Longrightarrow>\n      \\<tau>move2 P h stk e2 pc' xcp') &&&\n     (\\<lbrakk>\\<tau>move2 P h stk (while (c) b) pc xcp;\n       pc < length (compE2 c)\\<rbrakk>\n      \\<Longrightarrow> \\<tau>move2 P h stk c pc xcp)) &&&\n    (\\<lbrakk>\\<tau>move2 P h stk (throw e) pc xcp;\n      pc < length (compE2 e)\\<rbrakk>\n     \\<Longrightarrow> \\<tau>move2 P h stk e pc xcp) &&&\n    (\\<lbrakk>\\<tau>move2 P h stk (try e1 catch(C' V) e2) pc xcp;\n      pc < length (compE2 e1)\\<rbrakk>\n     \\<Longrightarrow> \\<tau>move2 P h stk e1 pc xcp)", "apply(auto elim!: \\<tau>move2_cases intro: \\<tau>move2xcp dest: \\<tau>move2_pc_length_compE2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \\<tau>move2_Invoke:\n  \"\\<lbrakk>\\<tau>move2 P h stk e pc None; compE2 e ! pc = Invoke M n \\<rbrakk>\n  \\<Longrightarrow> n < length stk \\<and> (stk ! n = Null \\<or> (\\<forall>T Ts Tr D. typeof_addr h (the_Addr (stk ! n)) = \\<lfloor>T\\<rfloor> \\<longrightarrow> P \\<turnstile> class_type_of T sees M:Ts\\<rightarrow>Tr = Native in D \\<longrightarrow> \\<tau>external_defs D M))\"\n\n  and \\<tau>moves2_Invoke: \n  \"\\<lbrakk>\\<tau>moves2 P h stk es pc None; compEs2 es ! pc = Invoke M n \\<rbrakk> \n  \\<Longrightarrow> n < length stk \\<and> (stk ! n = Null \\<or> (\\<forall>T C Ts Tr D. typeof_addr h (the_Addr (stk ! n)) = \\<lfloor>T\\<rfloor> \\<longrightarrow> P \\<turnstile> class_type_of T sees M:Ts\\<rightarrow>Tr = Native in D \\<longrightarrow> \\<tau>external_defs D M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<tau>move2 P h stk e pc None;\n      compE2 e ! pc = Invoke M n\\<rbrakk>\n     \\<Longrightarrow> n < length stk \\<and>\n                       (stk ! n = Null \\<or>\n                        (\\<forall>T Ts Tr D.\n                            typeof_addr h (the_Addr (stk ! n)) =\n                            \\<lfloor>T\\<rfloor> \\<longrightarrow>\n                            P \\<turnstile> class_type_of\n      T sees M: Ts\\<rightarrow>Tr = Native in D \\<longrightarrow>\n                            \\<tau>external_defs D M))) &&&\n    (\\<lbrakk>\\<tau>moves2 P h stk es pc None;\n      compEs2 es ! pc = Invoke M n\\<rbrakk>\n     \\<Longrightarrow> n < length stk \\<and>\n                       (stk ! n = Null \\<or>\n                        (\\<forall>T C Ts Tr D.\n                            typeof_addr h (the_Addr (stk ! n)) =\n                            \\<lfloor>T\\<rfloor> \\<longrightarrow>\n                            P \\<turnstile> class_type_of\n      T sees M: Ts\\<rightarrow>Tr = Native in D \\<longrightarrow>\n                            \\<tau>external_defs D M)))", "by(simp_all add: \\<tau>move2_iff \\<tau>moves2_iff split_beta)"], ["", "lemmas \\<tau>move2_compE2_not_Invoke = \\<tau>move2_Invoke"], ["", "lemmas \\<tau>moves2_compEs2_not_Invoke = \\<tau>moves2_Invoke"], ["", "lemma \\<tau>move2_blocks1 [simp]:\n  \"\\<tau>move2 P h stk (blocks1 n Ts body) pc' xcp' = \\<tau>move2 P h stk body pc' xcp'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>move2 P h stk (blocks1 n Ts body) pc' xcp' =\n    \\<tau>move2 P h stk body pc' xcp'", "by(simp add: \\<tau>move2_iff)"], ["", "lemma \\<tau>instr_stk_append:\n  \"\\<tau>instr P h stk i \\<Longrightarrow> \\<tau>instr P h (stk @ vs) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>instr P h stk i \\<Longrightarrow> \\<tau>instr P h (stk @ vs) i", "by(cases i)(auto simp add: nth_append)"], ["", "lemma \\<tau>move2_stk_append:\n  \"\\<tau>move2 P h stk e pc xcp \\<Longrightarrow> \\<tau>move2 P h (stk @ vs) e pc xcp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>move2 P h stk e pc xcp \\<Longrightarrow>\n    \\<tau>move2 P h (stk @ vs) e pc xcp", "by(simp add: \\<tau>move2_iff \\<tau>instr_stk_append)"], ["", "lemma \\<tau>moves2_stk_append:\n  \"\\<tau>moves2 P h stk es pc xcp \\<Longrightarrow> \\<tau>moves2 P h (stk @ vs) es pc xcp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>moves2 P h stk es pc xcp \\<Longrightarrow>\n    \\<tau>moves2 P h (stk @ vs) es pc xcp", "by(simp add: \\<tau>moves2_iff \\<tau>instr_stk_append)"], ["", "fun \\<tau>Move2 :: \"'addr jvm_prog \\<Rightarrow> ('addr, 'heap) jvm_state \\<Rightarrow> bool\"\nwhere \n  \"\\<tau>Move2 P (xcp, h, []) = False\"\n| \"\\<tau>Move2 P (xcp, h, (stk, loc, C, M, pc) # frs) =\n       (let (_,_,_,meth) = method P C M; (_,_,ins,xt) = the meth\n        in (pc < length ins \\<and> (xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc))))\""], ["", "lemma \\<tau>Move2_iff:\n  \"\\<tau>Move2 P \\<sigma> = (let (xcp, h, frs) = \\<sigma>\n                 in case frs of [] \\<Rightarrow> False\n     | (stk, loc, C, M, pc) # frs' \\<Rightarrow> \n       (let (_,_,_,meth) = method P C M; (_,_,ins,xt) = the meth\n        in (pc < length ins \\<and> (xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Move2 P \\<sigma> =\n    (let (xcp, h, frs) = \\<sigma>\n     in case frs of [] \\<Rightarrow> False\n        | (stk, loc, C, M, pc) # frs' \\<Rightarrow>\n            let (uu_, uu_, uu_, meth) = method P C M;\n                (uu_, uu_, ins, xt) = the meth\n            in pc < length ins \\<and>\n               (xcp = None \\<longrightarrow>\n                \\<tau>instr P h stk (ins ! pc)))", "by(cases \\<sigma>)(clarsimp split: list.splits simp add: fun_eq_iff split_beta)"], ["", "lemma \\<tau>instr_compP [simp]: \"\\<tau>instr (compP f P) h stk i \\<longleftrightarrow> \\<tau>instr P h stk i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>instr (compP f P) h stk i = \\<tau>instr P h stk i", "by(cases i) auto"], ["", "lemma [simp]: fixes e :: \"'addr expr1\" and es :: \"'addr expr1 list\"\n  shows \\<tau>move2_compP: \"\\<tau>move2 (compP f P) h stk e = \\<tau>move2 P h stk e\"\n  and \\<tau>moves2_compP: \"\\<tau>moves2 (compP f P) h stk es = \\<tau>moves2 P h stk es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>move2 (compP f P) h stk e = \\<tau>move2 P h stk e &&&\n    \\<tau>moves2 (compP f P) h stk es = \\<tau>moves2 P h stk es", "by(auto simp add: \\<tau>move2_iff \\<tau>moves2_iff fun_eq_iff)"], ["", "lemma \\<tau>Move2_compP2:\n  \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>body\\<rfloor> in D \\<Longrightarrow> \n   \\<tau>Move2 (compP2 P) (xcp, h, (stk, loc, C, M, pc) # frs) =\n   (case xcp of None \\<Rightarrow> \\<tau>move2 P h stk body pc xcp \\<or> pc = length (compE2 body) | Some a \\<Rightarrow> pc < Suc (length (compE2 body)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D \\<Longrightarrow>\n    \\<tau>Move2 (compP2 P) (xcp, h, (stk, loc, C, M, pc) # frs) =\n    (case xcp of\n     None \\<Rightarrow>\n       \\<tau>move2 P h stk body pc xcp \\<or> pc = length (compE2 body)\n     | \\<lfloor>a\\<rfloor> \\<Rightarrow> pc < Suc (length (compE2 body)))", "by(clarsimp simp add: \\<tau>move2_iff compP2_def compMb2_def nth_append nth_Cons' split: option.splits if_split_asm)"], ["", "abbreviation \\<tau>MOVE2 ::\n  \"'addr jvm_prog \\<Rightarrow> (('addr option \\<times> 'addr frame list) \\<times> 'heap, ('addr, 'thread_id, 'heap) jvm_thread_action) trsys\"\nwhere \"\\<tau>MOVE2 P \\<equiv> \\<lambda>((xcp, frs), h) ta s. \\<tau>Move2 P (xcp, h, frs) \\<and> ta = \\<epsilon>\""], ["", "lemma \\<tau>jvmd_heap_unchanged: \n  \"\\<lbrakk> P,t \\<turnstile> Normal (xcp, h, frs) -\\<epsilon>-jvmd\\<rightarrow> Normal (xcp', h', frs'); \\<tau>Move2 P (xcp, h, frs) \\<rbrakk>\n  \\<Longrightarrow> h = h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,t \\<turnstile> Normal\n                               (xcp, h,\n                                frs) -\\<lbrace>\\<rbrace>-jvmd\\<rightarrow> Normal\n(xcp', h', frs');\n     \\<tau>Move2 P (xcp, h, frs)\\<rbrakk>\n    \\<Longrightarrow> h = h'", "apply(erule jvmd_NormalE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xcpa ha f frsa.\n       \\<lbrakk>\\<tau>Move2 P (xcp, h, frs); check P (xcp, h, frs);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs') \\<in> exec P t (xcp, h, frs);\n        (xcp, h, frs) = (xcpa, ha, f # frsa)\\<rbrakk>\n       \\<Longrightarrow> h = h'", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac b frsa x ad ae ba xa af ag bb.\n       \\<lbrakk>check P (xcp, h, (a, aa, ab, ac, b) # frsa);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (a, aa, ab, ac, b) # frsa);\n        frs = (a, aa, ab, ac, b) # frsa; method P ab ac = (x, ad, ae, ba);\n        the ba = (xa, af, ag, bb); b < length ag;\n        xcp = None \\<longrightarrow> \\<tau>instr P h a (ag ! b)\\<rbrakk>\n       \\<Longrightarrow> h = h'", "apply(cases xcp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa ab ac b frsa x ad ae ba xa af ag bb.\n       \\<lbrakk>check P (xcp, h, (a, aa, ab, ac, b) # frsa);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (a, aa, ab, ac, b) # frsa);\n        frs = (a, aa, ab, ac, b) # frsa; method P ab ac = (x, ad, ae, ba);\n        the ba = (xa, af, ag, bb); b < length ag;\n        xcp = None \\<longrightarrow> \\<tau>instr P h a (ag ! b);\n        xcp = None\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 2. \\<And>a aa ab ac b frsa x ad ae ba xa af ag bb ah.\n       \\<lbrakk>check P (xcp, h, (a, aa, ab, ac, b) # frsa);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (a, aa, ab, ac, b) # frsa);\n        frs = (a, aa, ab, ac, b) # frsa; method P ab ac = (x, ad, ae, ba);\n        the ba = (xa, af, ag, bb); b < length ag;\n        xcp = None \\<longrightarrow> \\<tau>instr P h a (ag ! b);\n        xcp = \\<lfloor>ah\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> h = h'", "apply(rename_tac stk loc C M pc FRS M' Ts T meth mxs mxl ins xt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 2. \\<And>a aa ab ac b frsa x ad ae ba xa af ag bb ah.\n       \\<lbrakk>check P (xcp, h, (a, aa, ab, ac, b) # frsa);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (a, aa, ab, ac, b) # frsa);\n        frs = (a, aa, ab, ac, b) # frsa; method P ab ac = (x, ad, ae, ba);\n        the ba = (xa, af, ag, bb); b < length ag;\n        xcp = None \\<longrightarrow> \\<tau>instr P h a (ag ! b);\n        xcp = \\<lfloor>ah\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> h = h'", "apply(case_tac \"ins ! pc\")"], ["proof (prove)\ngoal (25 subgoals):\n 1. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt x1.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 2. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt x2.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 3. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt x3.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 4. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt x4.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 5. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt x5.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 6. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = ALoad\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 7. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = AStore\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 8. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = ALength\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 9. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt x91 x92.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 10. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt x101 x102.\n        \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n         (\\<lbrace>\\<rbrace>, xcp', h', frs')\n         \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n         frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n         the meth = (mxs, mxl, ins, xt); pc < length ins;\n         xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n         xcp = None; ins ! pc = Putfield x101 x102\\<rbrakk>\n        \\<Longrightarrow> h = h'\nA total of 25 subgoals...", "prefer 19 \\<comment> \\<open>BinOpInstr\\<close>"], ["proof (prove)\ngoal (25 subgoals):\n 1. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt x19.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = BinOpInstr x19\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 2. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt x1.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 3. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt x2.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 4. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt x3.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 5. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt x4.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 6. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt x5.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 7. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = ALoad\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 8. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = AStore\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 9. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = ALength\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 10. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt x91 x92.\n        \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n         (\\<lbrace>\\<rbrace>, xcp', h', frs')\n         \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n         frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n         the meth = (mxs, mxl, ins, xt); pc < length ins;\n         xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n         xcp = None; ins ! pc = Getfield x91 x92\\<rbrakk>\n        \\<Longrightarrow> h = h'\nA total of 25 subgoals...", "apply(rename_tac bop)"], ["proof (prove)\ngoal (25 subgoals):\n 1. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt bop.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = BinOpInstr bop\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 2. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt x1.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 3. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt x2.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 4. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt x3.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 5. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt x4.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 6. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt x5.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 7. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = ALoad\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 8. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = AStore\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 9. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = ALength\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 10. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt x91 x92.\n        \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n         (\\<lbrace>\\<rbrace>, xcp', h', frs')\n         \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n         frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n         the meth = (mxs, mxl, ins, xt); pc < length ins;\n         xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n         xcp = None; ins ! pc = Getfield x91 x92\\<rbrakk>\n        \\<Longrightarrow> h = h'\nA total of 25 subgoals...", "apply(case_tac \"the (binop bop (hd (tl stk)) (hd stk))\")"], ["proof (prove)\ngoal (26 subgoals):\n 1. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt bop a.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = BinOpInstr bop;\n        the (binop bop (hd (tl stk)) (hd stk)) = Inl a\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 2. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt bop b.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = BinOpInstr bop;\n        the (binop bop (hd (tl stk)) (hd stk)) = Inr b\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 3. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt x1.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 4. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt x2.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 5. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt x3.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 6. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt x4.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 7. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt x5.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 8. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = ALoad\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 9. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt.\n       \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n        frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n        the meth = (mxs, mxl, ins, xt); pc < length ins;\n        xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n        xcp = None; ins ! pc = AStore\\<rbrakk>\n       \\<Longrightarrow> h = h'\n 10. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt.\n        \\<lbrakk>check P (xcp, h, (stk, loc, C, M, pc) # FRS);\n         (\\<lbrace>\\<rbrace>, xcp', h', frs')\n         \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # FRS);\n         frs = (stk, loc, C, M, pc) # FRS; method P C M = (M', Ts, T, meth);\n         the meth = (mxs, mxl, ins, xt); pc < length ins;\n         xcp = None \\<longrightarrow> \\<tau>instr P h stk (ins ! pc);\n         xcp = None; ins ! pc = ALength\\<rbrakk>\n        \\<Longrightarrow> h = h'\nA total of 26 subgoals...", "apply(auto simp add: split_beta \\<tau>external_def split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stk loc C M pc FRS M' Ts T meth mxs mxl ins xt x141 x142 va.\n       \\<lbrakk>frs = (stk, loc, C, M, pc) # FRS;\n        method P C M = (M', Ts, T, meth); the meth = (mxs, mxl, ins, xt);\n        pc < length ins; xcp = None; ins ! pc = Invoke x141 x142;\n        check P (None, h, (stk, loc, C, M, pc) # FRS);\n        stk ! x142 \\<noteq> Null; x142 < length stk;\n        \\<forall>T.\n           typeof_addr h (the_Addr (stk ! x142)) =\n           \\<lfloor>T\\<rfloor> \\<longrightarrow>\n           (\\<forall>Ts Tr D.\n               P \\<turnstile> class_type_of\n                               T sees x141: Ts\\<rightarrow>Tr = Native in D \\<longrightarrow>\n               \\<tau>external_defs D x141);\n        snd (snd (snd (method P\n                        (class_type_of\n                          (the (typeof_addr h (the_Addr (stk ! x142)))))\n                        x141))) =\n        None;\n        case va of\n        RetVal v \\<Rightarrow>\n          xcp' = None \\<and>\n          frs' = (v # drop (Suc x142) stk, loc, C, M, pc + 1) # FRS\n        | RetExc a \\<Rightarrow>\n            xcp' = \\<lfloor>a\\<rfloor> \\<and>\n            frs' = (stk, loc, C, M, pc) # FRS\n        | RetStaySame \\<Rightarrow>\n            xcp' = None \\<and> frs' = (stk, loc, C, M, pc) # FRS;\n        (\\<lbrace>\\<rbrace>, va, h')\n        \\<in> red_external_aggr P t (the_Addr (stk ! x142)) x141\n               (rev (take x142 stk)) h\\<rbrakk>\n       \\<Longrightarrow> h = h'", "apply(fastforce simp add: check_def has_method_def \\<tau>external_def dest: \\<tau>external_red_external_aggr_heap_unchanged)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mexecd_\\<tau>mthr_wf:\n  \"\\<tau>multithreaded_wf JVM_final (mexecd P) (\\<tau>MOVE2 P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>multithreaded_wf JVM_final (mexecd P)\n     (\\<lambda>((xcp, frs), h) ta s.\n         \\<tau>Move2 P (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m'.\n       \\<lbrakk>execd_mthr.r_syntax P t x m ta x' m';\n        (case (x, m) of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (xcp, frs) \\<Rightarrow>\n              \\<lambda>h ta s.\n                 \\<tau>Move2 P (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n            xa)\n         ta (x', m')\\<rbrakk>\n       \\<Longrightarrow> m = m'\n 2. \\<And>s ta s'.\n       (case s of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (xcp, frs) \\<Rightarrow>\n             \\<lambda>h ta s.\n                \\<tau>Move2 P (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n           xa)\n        ta s' \\<Longrightarrow>\n       ta = \\<lbrace>\\<rbrace>", "fix t x h ta x' h'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m'.\n       \\<lbrakk>execd_mthr.r_syntax P t x m ta x' m';\n        (case (x, m) of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (xcp, frs) \\<Rightarrow>\n              \\<lambda>h ta s.\n                 \\<tau>Move2 P (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n            xa)\n         ta (x', m')\\<rbrakk>\n       \\<Longrightarrow> m = m'\n 2. \\<And>s ta s'.\n       (case s of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (xcp, frs) \\<Rightarrow>\n             \\<lambda>h ta s.\n                \\<tau>Move2 P (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n           xa)\n        ta s' \\<Longrightarrow>\n       ta = \\<lbrace>\\<rbrace>", "assume \"mexecd P t (x, h) ta (x', h')\"\n    and \"\\<tau>MOVE2 P (x, h) ta (x', h')\""], ["proof (state)\nthis:\n  execd_mthr.r_syntax P t x h ta x' h'\n  (case (x, h) of\n   (x, xa) \\<Rightarrow>\n     (case x of\n      (xcp, frs) \\<Rightarrow>\n        \\<lambda>h ta s.\n           \\<tau>Move2 P (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n      xa)\n   ta (x', h')\n\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m'.\n       \\<lbrakk>execd_mthr.r_syntax P t x m ta x' m';\n        (case (x, m) of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (xcp, frs) \\<Rightarrow>\n              \\<lambda>h ta s.\n                 \\<tau>Move2 P (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n            xa)\n         ta (x', m')\\<rbrakk>\n       \\<Longrightarrow> m = m'\n 2. \\<And>s ta s'.\n       (case s of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (xcp, frs) \\<Rightarrow>\n             \\<lambda>h ta s.\n                \\<tau>Move2 P (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n           xa)\n        ta s' \\<Longrightarrow>\n       ta = \\<lbrace>\\<rbrace>", "thus \"h = h'\""], ["proof (prove)\nusing this:\n  execd_mthr.r_syntax P t x h ta x' h'\n  (case (x, h) of\n   (x, xa) \\<Rightarrow>\n     (case x of\n      (xcp, frs) \\<Rightarrow>\n        \\<lambda>h ta s.\n           \\<tau>Move2 P (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n      xa)\n   ta (x', h')\n\ngoal (1 subgoal):\n 1. h = h'", "by(cases x)(cases x', auto dest: \\<tau>jvmd_heap_unchanged)"], ["proof (state)\nthis:\n  h = h'\n\ngoal (1 subgoal):\n 1. \\<And>s ta s'.\n       (case s of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (xcp, frs) \\<Rightarrow>\n             \\<lambda>h ta s.\n                \\<tau>Move2 P (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n           xa)\n        ta s' \\<Longrightarrow>\n       ta = \\<lbrace>\\<rbrace>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s ta s'.\n       (case s of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (xcp, frs) \\<Rightarrow>\n             \\<lambda>h ta s.\n                \\<tau>Move2 P (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n           xa)\n        ta s' \\<Longrightarrow>\n       ta = \\<lbrace>\\<rbrace>", "fix s ta s'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s ta s'.\n       (case s of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (xcp, frs) \\<Rightarrow>\n             \\<lambda>h ta s.\n                \\<tau>Move2 P (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n           xa)\n        ta s' \\<Longrightarrow>\n       ta = \\<lbrace>\\<rbrace>", "assume \"\\<tau>MOVE2 P s ta s'\""], ["proof (state)\nthis:\n  (case s of\n   (x, xa) \\<Rightarrow>\n     (case x of\n      (xcp, frs) \\<Rightarrow>\n        \\<lambda>h ta s.\n           \\<tau>Move2 P (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n      xa)\n   ta s'\n\ngoal (1 subgoal):\n 1. \\<And>s ta s'.\n       (case s of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (xcp, frs) \\<Rightarrow>\n             \\<lambda>h ta s.\n                \\<tau>Move2 P (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n           xa)\n        ta s' \\<Longrightarrow>\n       ta = \\<lbrace>\\<rbrace>", "thus \"ta = \\<epsilon>\""], ["proof (prove)\nusing this:\n  (case s of\n   (x, xa) \\<Rightarrow>\n     (case x of\n      (xcp, frs) \\<Rightarrow>\n        \\<lambda>h ta s.\n           \\<tau>Move2 P (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n      xa)\n   ta s'\n\ngoal (1 subgoal):\n 1. ta = \\<lbrace>\\<rbrace>", "by(simp add: split_beta)"], ["proof (state)\nthis:\n  ta = \\<lbrace>\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "sublocale JVM_heap_base < execd_mthr: \n  \\<tau>multithreaded_wf \n    JVM_final\n    \"mexecd P\"\n    convert_RA\n    \"\\<tau>MOVE2 P\"\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>multithreaded_wf JVM_final (mexecd P)\n     (\\<lambda>((xcp, frs), h) ta s.\n         \\<tau>Move2 P (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)", "by(rule mexecd_\\<tau>mthr_wf)"], ["", "context JVM_heap_base begin"], ["", "lemma \\<tau>exec_1_taD:\n  assumes exec: \"exec_1_d P t (Normal (xcp, h, frs)) ta (Normal (xcp', h', frs'))\"\n  and \\<tau>: \"\\<tau>Move2 P (xcp, h, frs)\"\n  shows \"ta = \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta = \\<lbrace>\\<rbrace>", "using assms"], ["proof (prove)\nusing this:\n  P,t \\<turnstile> Normal\n                    (xcp, h,\n                     frs) -ta-jvmd\\<rightarrow> Normal (xcp', h', frs')\n  \\<tau>Move2 P (xcp, h, frs)\n\ngoal (1 subgoal):\n 1. ta = \\<lbrace>\\<rbrace>", "apply(auto elim!: jvmd_NormalE simp add: split_beta)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac b frsa.\n       \\<lbrakk>check P (xcp, h, (a, aa, ab, ac, b) # frsa);\n        (ta, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (a, aa, ab, ac, b) # frsa);\n        frs = (a, aa, ab, ac, b) # frsa; b < length (instrs_of P ab ac);\n        \\<tau>instr P h a (instrs_of P ab ac ! b)\\<rbrakk>\n       \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>", "apply(cases xcp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa ab ac b frsa.\n       \\<lbrakk>check P (xcp, h, (a, aa, ab, ac, b) # frsa);\n        (ta, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (a, aa, ab, ac, b) # frsa);\n        frs = (a, aa, ab, ac, b) # frsa; b < length (instrs_of P ab ac);\n        \\<tau>instr P h a (instrs_of P ab ac ! b); xcp = None\\<rbrakk>\n       \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>\n 2. \\<And>a aa ab ac b frsa ad.\n       \\<lbrakk>check P (xcp, h, (a, aa, ab, ac, b) # frsa);\n        (ta, xcp', h', frs')\n        \\<in> exec P t (xcp, h, (a, aa, ab, ac, b) # frsa);\n        frs = (a, aa, ab, ac, b) # frsa; b < length (instrs_of P ab ac);\n        \\<tau>instr P h a (instrs_of P ab ac ! b);\n        xcp = \\<lfloor>ad\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac b frsa.\n       \\<lbrakk>check P (None, h, (a, aa, ab, ac, b) # frsa);\n        (ta, xcp', h', frs')\n        \\<in> exec_instr (instrs_of P ab ac ! b) P t h a aa ab ac b frsa;\n        frs = (a, aa, ab, ac, b) # frsa; b < length (instrs_of P ab ac);\n        \\<tau>instr P h a (instrs_of P ab ac ! b); xcp = None\\<rbrakk>\n       \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>", "apply(rename_tac stk loc C M pc FRS)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stk loc C M pc FRS.\n       \\<lbrakk>check P (None, h, (stk, loc, C, M, pc) # FRS);\n        (ta, xcp', h', frs')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc FRS;\n        frs = (stk, loc, C, M, pc) # FRS; pc < length (instrs_of P C M);\n        \\<tau>instr P h stk (instrs_of P C M ! pc); xcp = None\\<rbrakk>\n       \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>", "apply(case_tac \"instrs_of P C M ! pc\")"], ["proof (prove)\ngoal (24 subgoals):\n 1. \\<And>stk loc C M pc FRS x1.\n       \\<lbrakk>check P (None, h, (stk, loc, C, M, pc) # FRS);\n        (ta, xcp', h', frs')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc FRS;\n        frs = (stk, loc, C, M, pc) # FRS; pc < length (instrs_of P C M);\n        \\<tau>instr P h stk (instrs_of P C M ! pc); xcp = None;\n        instrs_of P C M ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>\n 2. \\<And>stk loc C M pc FRS x2.\n       \\<lbrakk>check P (None, h, (stk, loc, C, M, pc) # FRS);\n        (ta, xcp', h', frs')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc FRS;\n        frs = (stk, loc, C, M, pc) # FRS; pc < length (instrs_of P C M);\n        \\<tau>instr P h stk (instrs_of P C M ! pc); xcp = None;\n        instrs_of P C M ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>\n 3. \\<And>stk loc C M pc FRS x3.\n       \\<lbrakk>check P (None, h, (stk, loc, C, M, pc) # FRS);\n        (ta, xcp', h', frs')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc FRS;\n        frs = (stk, loc, C, M, pc) # FRS; pc < length (instrs_of P C M);\n        \\<tau>instr P h stk (instrs_of P C M ! pc); xcp = None;\n        instrs_of P C M ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>\n 4. \\<And>stk loc C M pc FRS x4.\n       \\<lbrakk>check P (None, h, (stk, loc, C, M, pc) # FRS);\n        (ta, xcp', h', frs')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc FRS;\n        frs = (stk, loc, C, M, pc) # FRS; pc < length (instrs_of P C M);\n        \\<tau>instr P h stk (instrs_of P C M ! pc); xcp = None;\n        instrs_of P C M ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>\n 5. \\<And>stk loc C M pc FRS x5.\n       \\<lbrakk>check P (None, h, (stk, loc, C, M, pc) # FRS);\n        (ta, xcp', h', frs')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc FRS;\n        frs = (stk, loc, C, M, pc) # FRS; pc < length (instrs_of P C M);\n        \\<tau>instr P h stk (instrs_of P C M ! pc); xcp = None;\n        instrs_of P C M ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>\n 6. \\<And>stk loc C M pc FRS.\n       \\<lbrakk>check P (None, h, (stk, loc, C, M, pc) # FRS);\n        (ta, xcp', h', frs')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc FRS;\n        frs = (stk, loc, C, M, pc) # FRS; pc < length (instrs_of P C M);\n        \\<tau>instr P h stk (instrs_of P C M ! pc); xcp = None;\n        instrs_of P C M ! pc = ALoad\\<rbrakk>\n       \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>\n 7. \\<And>stk loc C M pc FRS.\n       \\<lbrakk>check P (None, h, (stk, loc, C, M, pc) # FRS);\n        (ta, xcp', h', frs')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc FRS;\n        frs = (stk, loc, C, M, pc) # FRS; pc < length (instrs_of P C M);\n        \\<tau>instr P h stk (instrs_of P C M ! pc); xcp = None;\n        instrs_of P C M ! pc = AStore\\<rbrakk>\n       \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>\n 8. \\<And>stk loc C M pc FRS.\n       \\<lbrakk>check P (None, h, (stk, loc, C, M, pc) # FRS);\n        (ta, xcp', h', frs')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc FRS;\n        frs = (stk, loc, C, M, pc) # FRS; pc < length (instrs_of P C M);\n        \\<tau>instr P h stk (instrs_of P C M ! pc); xcp = None;\n        instrs_of P C M ! pc = ALength\\<rbrakk>\n       \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>\n 9. \\<And>stk loc C M pc FRS x91 x92.\n       \\<lbrakk>check P (None, h, (stk, loc, C, M, pc) # FRS);\n        (ta, xcp', h', frs')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc FRS;\n        frs = (stk, loc, C, M, pc) # FRS; pc < length (instrs_of P C M);\n        \\<tau>instr P h stk (instrs_of P C M ! pc); xcp = None;\n        instrs_of P C M ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>\n 10. \\<And>stk loc C M pc FRS x101 x102.\n        \\<lbrakk>check P (None, h, (stk, loc, C, M, pc) # FRS);\n         (ta, xcp', h', frs')\n         \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc FRS;\n         frs = (stk, loc, C, M, pc) # FRS; pc < length (instrs_of P C M);\n         \\<tau>instr P h stk (instrs_of P C M ! pc); xcp = None;\n         instrs_of P C M ! pc = Putfield x101 x102\\<rbrakk>\n        \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>\nA total of 24 subgoals...", "apply(simp_all split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stk loc C M pc FRS x141 x142.\n       \\<lbrakk>frs = (stk, loc, C, M, pc) # FRS;\n        pc < length (instrs_of P C M); xcp = None;\n        instrs_of P C M ! pc = Invoke x141 x142;\n        check P (None, h, (stk, loc, C, M, pc) # FRS);\n        stk ! x142 \\<noteq> Null; x142 < length stk;\n        \\<forall>T.\n           typeof_addr h (the_Addr (stk ! x142)) =\n           \\<lfloor>T\\<rfloor> \\<longrightarrow>\n           (\\<forall>Ts Tr D.\n               P \\<turnstile> class_type_of\n                               T sees x141: Ts\\<rightarrow>Tr = Native in D \\<longrightarrow>\n               \\<tau>external_defs D x141);\n        (ta, xcp', h', frs')\n        \\<in> (case method P\n                     (class_type_of\n                       (the (typeof_addr h (the_Addr (stk ! x142)))))\n                     x141 of\n               (D, M', Ts, None) \\<Rightarrow>\n                 {((a, map (convert_new_thread_action (extNTA2JVM P)) aa,\n                    aaa, aaaa, aaaaa, b),\n                   extRet2JVM x142 h' stk loc C M pc FRS va) |\n                  a aa aaa aaaa aaaaa b va h'.\n                  ((a, aa, aaa, aaaa, aaaaa, b), va, h')\n                  \\<in> red_external_aggr P t (the_Addr (stk ! x142)) x141\n                         (rev (take x142 stk)) h}\n               | (D, M', Ts,\n                  \\<lfloor>(mxs, mxl\\<^sub>0, ins,\n                            xt)\\<rfloor>) \\<Rightarrow>\n                   {(\\<lbrace>\\<rbrace>, None, h,\n                     ([],\n                      stk ! x142 #\n                      rev (take x142 stk) @\n                      replicate mxl\\<^sub>0 undefined_value,\n                      D, x141, 0) #\n                     (stk, loc, C, M, pc) # FRS)})\\<rbrakk>\n       \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>", "apply(auto simp add: check_def has_method_def \\<tau>external_def dest!: \\<tau>external_red_external_aggr_TA_empty)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"]]}