{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Common/SemiType.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma is_type_widen1: \n  assumes icO: \"is_class P Object\"\n  shows \"P \\<turnstile> T <\\<^sup>1 U \\<Longrightarrow> is_type P T\"", "lemma widen1_NT_Array:\n  assumes \"is_NT_Array T\"\n  shows \"\\<not> P \\<turnstile> T\\<lfloor>\\<rceil> <\\<^sup>1 U\"", "lemma widen1_is_type:\n  assumes wfP: \"wf_prog wfmd P\"\n  shows \"(A, B) \\<in> widen1 P \\<Longrightarrow> is_type P B\"", "lemma widen1_trancl_is_type:\n  assumes wfP: \"wf_prog wfmd P\"\n  shows \"(A, B) \\<in> (widen1 P)^+ \\<Longrightarrow> is_type P B\"", "lemma single_valued_widen1:\n  assumes wf: \"wf_prog wf_md P\"\n  shows \"single_valued (widen1 P)\"", "lemma subtype_measure_measure:\n  assumes acyclic: \"acyclicP (subcls1 P)\"\n  and widen1: \"P \\<turnstile> x <\\<^sup>1 y\"\n  shows \"subtype_measure P y < subtype_measure P x\"", "lemma wf_converse_widen1:\n  assumes wfP: \"wf_prog wfmc P\"\n  shows \"wf ((widen1 P)^-1)\"", "lemma superI:\n  \"P \\<turnstile> T <\\<^sup>1 U \\<Longrightarrow> super P T = U\"", "lemma Class_widen1_super:\n  \"P \\<turnstile> Class C' <\\<^sup>1 U' \\<longleftrightarrow> is_class P C' \\<and> C' \\<noteq> Object \\<and> U' = super P (Class C')\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma super_widen1:\n  assumes icO: \"is_class P Object\"\n  shows \"P \\<turnstile> T <\\<^sup>1 U \\<longleftrightarrow> is_type P T \\<and> (case T of Class C  \\<Rightarrow> (C \\<noteq> Object \\<and> U = super P T) \n                                              | Array T' \\<Rightarrow> U = super P T \n                                              | _        \\<Rightarrow> False)\"", "lemma sup_def':\n  \"sup P = (\\<lambda>T U.\n   if is_refT T \\<and> is_refT U\n   then OK (if U = NT then T\n            else if T = NT then U\n            else exec_lub (widen1 P) (super P) T U)\n   else if (T = U) then OK T else Err)\"", "lemma order_widen [intro,simp]: \n  \"wf_prog m P \\<Longrightarrow> order (widen P)\"", "lemma subcls1_trancl_widen1_trancl:\n  \"(subcls1 P)^++ C D \\<Longrightarrow> P \\<turnstile> Class C <\\<^sup>+ Class D\"", "lemma subcls_into_widen1_rtrancl:\n  \"P \\<turnstile> C \\<preceq>\\<^sup>* D \\<Longrightarrow> P \\<turnstile> Class C <\\<^sup>* Class D\"", "lemma not_widen1_NT_Array:\n  \"P \\<turnstile> U <\\<^sup>1 T \\<Longrightarrow> \\<not> is_NT_Array T\"", "lemma widen1_trancl_into_Array_widen1_trancl:\n  \"\\<lbrakk> P \\<turnstile> A <\\<^sup>+ B; \\<not> is_NT_Array A \\<rbrakk> \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ B\\<lfloor>\\<rceil>\"", "lemma widen1_rtrancl_into_Array_widen1_rtrancl:\n  \"\\<lbrakk> P \\<turnstile> A <\\<^sup>* B; \\<not> is_NT_Array A \\<rbrakk> \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>* B\\<lfloor>\\<rceil>\"", "lemma Array_Object_widen1_trancl:\n  assumes wf: \"wf_prog wmdc P\"\n  and itA: \"is_type P (A\\<lfloor>\\<rceil>)\"\n  shows \"P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\"", "lemma widen_into_widen1_trancl:\n  assumes wf: \"wf_prog wfmd P\"\n  shows \"\\<lbrakk> P \\<turnstile> A \\<le> B; A \\<noteq> B; A \\<noteq> NT; is_type P A \\<rbrakk> \\<Longrightarrow> P \\<turnstile> A <\\<^sup>+ B\"", "lemma wf_prog_impl_acc_widen:\n  assumes wfP: \"wf_prog wfmd P\"\n  shows \"acc (types P) (widen P)\"", "lemmas wf_widen_acc = wf_prog_impl_acc_widen", "lemma acyclic_widen1:\n  \"wf_prog wfmc P \\<Longrightarrow> acyclic (widen1 P)\"", "lemma widen1_into_widen:\n  \"(A, B) \\<in> widen1 P \\<Longrightarrow> P \\<turnstile> A \\<le> B\"", "lemma widen1_rtrancl_into_widen:\n  \"P \\<turnstile> A <\\<^sup>* B \\<Longrightarrow> P \\<turnstile> A \\<le> B\"", "lemma widen_eq_widen1_trancl:\n  \"\\<lbrakk> wf_prog wf_md P; T \\<noteq> NT; T \\<noteq> U; is_type P T \\<rbrakk> \\<Longrightarrow> P \\<turnstile> T \\<le> U \\<longleftrightarrow> P \\<turnstile> T <\\<^sup>+ U\"", "lemma sup_is_type:\n  assumes wf: \"wf_prog wf_md P\"\n  and itA: \"is_type P A\"\n  and itB: \"is_type P B\"\n  and sup: \"sup P A B = OK T\"\n  shows \"is_type P T\"", "lemma closed_err_types:\n  assumes wfP: \"wf_prog wf_mb P\"\n  shows \"closed (err (types P)) (lift2 (sup P))\"", "lemma widen_into_widen1_rtrancl:\n  \"\\<lbrakk>wf_prog wfmd P; widen P A B; A \\<noteq> NT; is_type P A \\<rbrakk> \\<Longrightarrow> (A, B) \\<in> (widen1 P)\\<^sup>*\"", "lemma sup_widen_greater:\n  assumes wfP: \"wf_prog wf_mb P\"\n  and it1: \"is_type P t1\"\n  and it2: \"is_type P t2\"\n  and sup: \"sup P t1 t2 = OK s\"\n  shows \"widen P t1 s \\<and> widen P t2 s\"", "lemma sup_widen_smallest:\n  assumes wfP: \"wf_prog wf_mb P\"\n  and itT: \"is_type P T\"\n  and itU: \"is_type P U\"\n  and TwV: \"P \\<turnstile> T \\<le> V\"\n  and UwV: \"P \\<turnstile> U \\<le> V\"\n  and sup: \"sup P T U = OK W\"\n  shows \"widen P W V\"", "lemma sup_exists:\n  \"\\<lbrakk> widen P a c; widen P b c \\<rbrakk> \\<Longrightarrow> \\<exists>T. sup P a b = OK T\"", "lemma err_semilat_JType_esl:\n  assumes wf_prog: \"wf_prog wf_mb P\"\n  shows \"err_semilat (esl P)\"", "lemma sup_is_lubI:\n  assumes wf: \"wf_prog wf_md P\"\n  and it: \"is_type P T\" \"is_type P U\"\n  and sup: \"sup P T U = OK V\"\n  shows \"P \\<turnstile> lub(T, U) = V\"", "lemma is_lub_subD:\n  assumes wf: \"wf_prog wf_md P\"\n  and it: \"is_type P T\" \"is_type P U\"\n  and lub: \"P \\<turnstile> lub(T, U) = V\"\n  shows \"sup P T U = OK V\"", "lemma is_lub_is_type:\n  \"\\<lbrakk> wf_prog wf_md P; is_type P T; is_type P U; P \\<turnstile> lub(T, U) = V \\<rbrakk> \\<Longrightarrow> is_type P V\"", "lemmas [code] = widen1_def", "lemma eval_widen1p_i_i_o_conv:\n  \"Predicate.eval (widen1p_i_i_o P T) = (\\<lambda>U. P \\<turnstile> T <\\<^sup>1 U)\"", "lemma rtrancl_widen1_code [code_unfold]:\n  \"(widen1 P)^* = {(a, b). Predicate.holds (rtrancl_tab_FioB_i_i_i (widen1p_i_i_o P) [] a b)}\""], "translations": [["", "lemma is_type_widen1: \n  assumes icO: \"is_class P Object\"\n  shows \"P \\<turnstile> T <\\<^sup>1 U \\<Longrightarrow> is_type P T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T <\\<^sup>1 U \\<Longrightarrow> is_type P T", "by(induct rule: widen1.induct)(auto intro: subcls_is_class icO split: ty.split dest: is_type_ground_type)"], ["", "lemma widen1_NT_Array:\n  assumes \"is_NT_Array T\"\n  shows \"\\<not> P \\<turnstile> T\\<lfloor>\\<rceil> <\\<^sup>1 U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (T\\<lfloor>\\<rceil>, U) \\<notin> widen1 P", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<turnstile> T\\<lfloor>\\<rceil> <\\<^sup>1 U \\<Longrightarrow> False", "assume \"P \\<turnstile> T\\<lfloor>\\<rceil> <\\<^sup>1 U\""], ["proof (state)\nthis:\n  P \\<turnstile> T\\<lfloor>\\<rceil> <\\<^sup>1 U\n\ngoal (1 subgoal):\n 1. P \\<turnstile> T\\<lfloor>\\<rceil> <\\<^sup>1 U \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  P \\<turnstile> T\\<lfloor>\\<rceil> <\\<^sup>1 U\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  P \\<turnstile> T\\<lfloor>\\<rceil> <\\<^sup>1 U\n  is_NT_Array T\n\ngoal (1 subgoal):\n 1. False", "by(induct \"T\\<lfloor>\\<rceil>\" U arbitrary: T) auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma widen1_is_type:\n  assumes wfP: \"wf_prog wfmd P\"\n  shows \"(A, B) \\<in> widen1 P \\<Longrightarrow> is_type P B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> A <\\<^sup>1 B \\<Longrightarrow> is_type P B", "proof(induct rule: widen1.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. is_type P (Class Object)\n 2. is_type P (Class Object)\n 3. is_type P (Class Object)\n 4. is_type P (Class Object)\n 5. \\<And>C D.\n       P \\<turnstile> C \\<prec>\\<^sup>1 D \\<Longrightarrow>\n       is_type P (Class D)\n 6. \\<And>T U.\n       \\<lbrakk>P \\<turnstile> T <\\<^sup>1 U; is_type P U;\n        ground_type T \\<noteq> NT\\<rbrakk>\n       \\<Longrightarrow> is_type P (U\\<lfloor>\\<rceil>)", "case (widen1_Class C D)"], ["proof (state)\nthis:\n  P \\<turnstile> C \\<prec>\\<^sup>1 D\n\ngoal (6 subgoals):\n 1. is_type P (Class Object)\n 2. is_type P (Class Object)\n 3. is_type P (Class Object)\n 4. is_type P (Class Object)\n 5. \\<And>C D.\n       P \\<turnstile> C \\<prec>\\<^sup>1 D \\<Longrightarrow>\n       is_type P (Class D)\n 6. \\<And>T U.\n       \\<lbrakk>P \\<turnstile> T <\\<^sup>1 U; is_type P U;\n        ground_type T \\<noteq> NT\\<rbrakk>\n       \\<Longrightarrow> is_type P (U\\<lfloor>\\<rceil>)", "hence \"is_class P C\" \"is_class P D\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C \\<prec>\\<^sup>1 D\n\ngoal (1 subgoal):\n 1. is_class P C &&& is_class P D", "by(auto intro: subcls_is_class converse_subcls_is_class[OF wfP])"], ["proof (state)\nthis:\n  is_class P C\n  is_class P D\n\ngoal (6 subgoals):\n 1. is_type P (Class Object)\n 2. is_type P (Class Object)\n 3. is_type P (Class Object)\n 4. is_type P (Class Object)\n 5. \\<And>C D.\n       P \\<turnstile> C \\<prec>\\<^sup>1 D \\<Longrightarrow>\n       is_type P (Class D)\n 6. \\<And>T U.\n       \\<lbrakk>P \\<turnstile> T <\\<^sup>1 U; is_type P U;\n        ground_type T \\<noteq> NT\\<rbrakk>\n       \\<Longrightarrow> is_type P (U\\<lfloor>\\<rceil>)", "thus ?case"], ["proof (prove)\nusing this:\n  is_class P C\n  is_class P D\n\ngoal (1 subgoal):\n 1. is_type P (Class D)", "by simp"], ["proof (state)\nthis:\n  is_type P (Class D)\n\ngoal (5 subgoals):\n 1. is_type P (Class Object)\n 2. is_type P (Class Object)\n 3. is_type P (Class Object)\n 4. is_type P (Class Object)\n 5. \\<And>T U.\n       \\<lbrakk>P \\<turnstile> T <\\<^sup>1 U; is_type P U;\n        ground_type T \\<noteq> NT\\<rbrakk>\n       \\<Longrightarrow> is_type P (U\\<lfloor>\\<rceil>)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. is_type P (Class Object)\n 2. is_type P (Class Object)\n 3. is_type P (Class Object)\n 4. is_type P (Class Object)\n 5. \\<And>T U.\n       \\<lbrakk>P \\<turnstile> T <\\<^sup>1 U; is_type P U;\n        ground_type T \\<noteq> NT\\<rbrakk>\n       \\<Longrightarrow> is_type P (U\\<lfloor>\\<rceil>)", "case (widen1_Array_Array T U)"], ["proof (state)\nthis:\n  P \\<turnstile> T <\\<^sup>1 U\n  is_type P U\n  ground_type T \\<noteq> NT\n\ngoal (5 subgoals):\n 1. is_type P (Class Object)\n 2. is_type P (Class Object)\n 3. is_type P (Class Object)\n 4. is_type P (Class Object)\n 5. \\<And>T U.\n       \\<lbrakk>P \\<turnstile> T <\\<^sup>1 U; is_type P U;\n        ground_type T \\<noteq> NT\\<rbrakk>\n       \\<Longrightarrow> is_type P (U\\<lfloor>\\<rceil>)", "thus ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> T <\\<^sup>1 U\n  is_type P U\n  ground_type T \\<noteq> NT\n\ngoal (1 subgoal):\n 1. is_type P (U\\<lfloor>\\<rceil>)", "by(cases U)(auto elim: widen1.cases)"], ["proof (state)\nthis:\n  is_type P (U\\<lfloor>\\<rceil>)\n\ngoal (4 subgoals):\n 1. is_type P (Class Object)\n 2. is_type P (Class Object)\n 3. is_type P (Class Object)\n 4. is_type P (Class Object)", "qed(insert wfP, auto)"], ["", "lemma widen1_trancl_is_type:\n  assumes wfP: \"wf_prog wfmd P\"\n  shows \"(A, B) \\<in> (widen1 P)^+ \\<Longrightarrow> is_type P B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> A <\\<^sup>+ B \\<Longrightarrow> is_type P B", "apply(induct rule: trancl_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y. P \\<turnstile> A <\\<^sup>1 y \\<Longrightarrow> is_type P y\n 2. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> A <\\<^sup>+ y; P \\<turnstile> y <\\<^sup>1 z;\n        is_type P y\\<rbrakk>\n       \\<Longrightarrow> is_type P z", "apply(auto intro: widen1_is_type[OF wfP])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma single_valued_widen1:\n  assumes wf: \"wf_prog wf_md P\"\n  shows \"single_valued (widen1 P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (widen1 P)", "proof(rule single_valuedI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>P \\<turnstile> x <\\<^sup>1 y;\n        P \\<turnstile> x <\\<^sup>1 z\\<rbrakk>\n       \\<Longrightarrow> y = z", "fix x y z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>P \\<turnstile> x <\\<^sup>1 y;\n        P \\<turnstile> x <\\<^sup>1 z\\<rbrakk>\n       \\<Longrightarrow> y = z", "assume \"P \\<turnstile> x <\\<^sup>1 y\" \"P \\<turnstile> x <\\<^sup>1 z\""], ["proof (state)\nthis:\n  P \\<turnstile> x <\\<^sup>1 y\n  P \\<turnstile> x <\\<^sup>1 z\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>P \\<turnstile> x <\\<^sup>1 y;\n        P \\<turnstile> x <\\<^sup>1 z\\<rbrakk>\n       \\<Longrightarrow> y = z", "thus \"y = z\""], ["proof (prove)\nusing this:\n  P \\<turnstile> x <\\<^sup>1 y\n  P \\<turnstile> x <\\<^sup>1 z\n\ngoal (1 subgoal):\n 1. y = z", "proof(induct arbitrary: z rule: widen1.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>z.\n       P \\<turnstile> Class\n                       Object\\<lfloor>\\<rceil> <\\<^sup>1 z \\<Longrightarrow>\n       Class Object = z\n 2. \\<And>z.\n       P \\<turnstile> Integer\\<lfloor>\\<rceil> <\\<^sup>1 z \\<Longrightarrow>\n       Class Object = z\n 3. \\<And>z.\n       P \\<turnstile> Boolean\\<lfloor>\\<rceil> <\\<^sup>1 z \\<Longrightarrow>\n       Class Object = z\n 4. \\<And>z.\n       P \\<turnstile> Void\\<lfloor>\\<rceil> <\\<^sup>1 z \\<Longrightarrow>\n       Class Object = z\n 5. \\<And>C D z.\n       \\<lbrakk>P \\<turnstile> C \\<prec>\\<^sup>1 D;\n        P \\<turnstile> Class C <\\<^sup>1 z\\<rbrakk>\n       \\<Longrightarrow> Class D = z\n 6. \\<And>T U z.\n       \\<lbrakk>P \\<turnstile> T <\\<^sup>1 U;\n        \\<And>z. P \\<turnstile> T <\\<^sup>1 z \\<Longrightarrow> U = z;\n        ground_type T \\<noteq> NT;\n        P \\<turnstile> T\\<lfloor>\\<rceil> <\\<^sup>1 z\\<rbrakk>\n       \\<Longrightarrow> U\\<lfloor>\\<rceil> = z", "case widen1_Class"], ["proof (state)\nthis:\n  P \\<turnstile> C_ \\<prec>\\<^sup>1 D_\n  P \\<turnstile> Class C_ <\\<^sup>1 z\n\ngoal (6 subgoals):\n 1. \\<And>z.\n       P \\<turnstile> Class\n                       Object\\<lfloor>\\<rceil> <\\<^sup>1 z \\<Longrightarrow>\n       Class Object = z\n 2. \\<And>z.\n       P \\<turnstile> Integer\\<lfloor>\\<rceil> <\\<^sup>1 z \\<Longrightarrow>\n       Class Object = z\n 3. \\<And>z.\n       P \\<turnstile> Boolean\\<lfloor>\\<rceil> <\\<^sup>1 z \\<Longrightarrow>\n       Class Object = z\n 4. \\<And>z.\n       P \\<turnstile> Void\\<lfloor>\\<rceil> <\\<^sup>1 z \\<Longrightarrow>\n       Class Object = z\n 5. \\<And>C D z.\n       \\<lbrakk>P \\<turnstile> C \\<prec>\\<^sup>1 D;\n        P \\<turnstile> Class C <\\<^sup>1 z\\<rbrakk>\n       \\<Longrightarrow> Class D = z\n 6. \\<And>T U z.\n       \\<lbrakk>P \\<turnstile> T <\\<^sup>1 U;\n        \\<And>z. P \\<turnstile> T <\\<^sup>1 z \\<Longrightarrow> U = z;\n        ground_type T \\<noteq> NT;\n        P \\<turnstile> T\\<lfloor>\\<rceil> <\\<^sup>1 z\\<rbrakk>\n       \\<Longrightarrow> U\\<lfloor>\\<rceil> = z", "with single_valued_subcls1[OF wf]"], ["proof (chain)\npicking this:\n  single_valuedp (subcls1 P)\n  P \\<turnstile> C_ \\<prec>\\<^sup>1 D_\n  P \\<turnstile> Class C_ <\\<^sup>1 z", "show ?case"], ["proof (prove)\nusing this:\n  single_valuedp (subcls1 P)\n  P \\<turnstile> C_ \\<prec>\\<^sup>1 D_\n  P \\<turnstile> Class C_ <\\<^sup>1 z\n\ngoal (1 subgoal):\n 1. Class D_ = z", "by(auto dest: single_valuedpD)"], ["proof (state)\nthis:\n  Class D_ = z\n\ngoal (5 subgoals):\n 1. \\<And>z.\n       P \\<turnstile> Class\n                       Object\\<lfloor>\\<rceil> <\\<^sup>1 z \\<Longrightarrow>\n       Class Object = z\n 2. \\<And>z.\n       P \\<turnstile> Integer\\<lfloor>\\<rceil> <\\<^sup>1 z \\<Longrightarrow>\n       Class Object = z\n 3. \\<And>z.\n       P \\<turnstile> Boolean\\<lfloor>\\<rceil> <\\<^sup>1 z \\<Longrightarrow>\n       Class Object = z\n 4. \\<And>z.\n       P \\<turnstile> Void\\<lfloor>\\<rceil> <\\<^sup>1 z \\<Longrightarrow>\n       Class Object = z\n 5. \\<And>T U z.\n       \\<lbrakk>P \\<turnstile> T <\\<^sup>1 U;\n        \\<And>z. P \\<turnstile> T <\\<^sup>1 z \\<Longrightarrow> U = z;\n        ground_type T \\<noteq> NT;\n        P \\<turnstile> T\\<lfloor>\\<rceil> <\\<^sup>1 z\\<rbrakk>\n       \\<Longrightarrow> U\\<lfloor>\\<rceil> = z", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>z.\n       P \\<turnstile> Class\n                       Object\\<lfloor>\\<rceil> <\\<^sup>1 z \\<Longrightarrow>\n       Class Object = z\n 2. \\<And>z.\n       P \\<turnstile> Integer\\<lfloor>\\<rceil> <\\<^sup>1 z \\<Longrightarrow>\n       Class Object = z\n 3. \\<And>z.\n       P \\<turnstile> Boolean\\<lfloor>\\<rceil> <\\<^sup>1 z \\<Longrightarrow>\n       Class Object = z\n 4. \\<And>z.\n       P \\<turnstile> Void\\<lfloor>\\<rceil> <\\<^sup>1 z \\<Longrightarrow>\n       Class Object = z\n 5. \\<And>T U z.\n       \\<lbrakk>P \\<turnstile> T <\\<^sup>1 U;\n        \\<And>z. P \\<turnstile> T <\\<^sup>1 z \\<Longrightarrow> U = z;\n        ground_type T \\<noteq> NT;\n        P \\<turnstile> T\\<lfloor>\\<rceil> <\\<^sup>1 z\\<rbrakk>\n       \\<Longrightarrow> U\\<lfloor>\\<rceil> = z", "case (widen1_Array_Array T U z)"], ["proof (state)\nthis:\n  P \\<turnstile> T <\\<^sup>1 U\n  P \\<turnstile> T <\\<^sup>1 ?z \\<Longrightarrow> U = ?z\n  ground_type T \\<noteq> NT\n  P \\<turnstile> T\\<lfloor>\\<rceil> <\\<^sup>1 z\n\ngoal (5 subgoals):\n 1. \\<And>z.\n       P \\<turnstile> Class\n                       Object\\<lfloor>\\<rceil> <\\<^sup>1 z \\<Longrightarrow>\n       Class Object = z\n 2. \\<And>z.\n       P \\<turnstile> Integer\\<lfloor>\\<rceil> <\\<^sup>1 z \\<Longrightarrow>\n       Class Object = z\n 3. \\<And>z.\n       P \\<turnstile> Boolean\\<lfloor>\\<rceil> <\\<^sup>1 z \\<Longrightarrow>\n       Class Object = z\n 4. \\<And>z.\n       P \\<turnstile> Void\\<lfloor>\\<rceil> <\\<^sup>1 z \\<Longrightarrow>\n       Class Object = z\n 5. \\<And>T U z.\n       \\<lbrakk>P \\<turnstile> T <\\<^sup>1 U;\n        \\<And>z. P \\<turnstile> T <\\<^sup>1 z \\<Longrightarrow> U = z;\n        ground_type T \\<noteq> NT;\n        P \\<turnstile> T\\<lfloor>\\<rceil> <\\<^sup>1 z\\<rbrakk>\n       \\<Longrightarrow> U\\<lfloor>\\<rceil> = z", "from \\<open>P \\<turnstile> T\\<lfloor>\\<rceil> <\\<^sup>1 z\\<close> \\<open>P \\<turnstile> T <\\<^sup>1 U\\<close> \\<open>\\<not> is_NT_Array T\\<close>"], ["proof (chain)\npicking this:\n  P \\<turnstile> T\\<lfloor>\\<rceil> <\\<^sup>1 z\n  P \\<turnstile> T <\\<^sup>1 U\n  ground_type T \\<noteq> NT", "obtain z' where z': \"z = z'\\<lfloor>\\<rceil>\" and Tz': \"P \\<turnstile> T <\\<^sup>1 z'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> T\\<lfloor>\\<rceil> <\\<^sup>1 z\n  P \\<turnstile> T <\\<^sup>1 U\n  ground_type T \\<noteq> NT\n\ngoal (1 subgoal):\n 1. (\\<And>z'.\n        \\<lbrakk>z = z'\\<lfloor>\\<rceil>;\n         P \\<turnstile> T <\\<^sup>1 z'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim: widen1.cases)"], ["proof (state)\nthis:\n  z = z'\\<lfloor>\\<rceil>\n  P \\<turnstile> T <\\<^sup>1 z'\n\ngoal (5 subgoals):\n 1. \\<And>z.\n       P \\<turnstile> Class\n                       Object\\<lfloor>\\<rceil> <\\<^sup>1 z \\<Longrightarrow>\n       Class Object = z\n 2. \\<And>z.\n       P \\<turnstile> Integer\\<lfloor>\\<rceil> <\\<^sup>1 z \\<Longrightarrow>\n       Class Object = z\n 3. \\<And>z.\n       P \\<turnstile> Boolean\\<lfloor>\\<rceil> <\\<^sup>1 z \\<Longrightarrow>\n       Class Object = z\n 4. \\<And>z.\n       P \\<turnstile> Void\\<lfloor>\\<rceil> <\\<^sup>1 z \\<Longrightarrow>\n       Class Object = z\n 5. \\<And>T U z.\n       \\<lbrakk>P \\<turnstile> T <\\<^sup>1 U;\n        \\<And>z. P \\<turnstile> T <\\<^sup>1 z \\<Longrightarrow> U = z;\n        ground_type T \\<noteq> NT;\n        P \\<turnstile> T\\<lfloor>\\<rceil> <\\<^sup>1 z\\<rbrakk>\n       \\<Longrightarrow> U\\<lfloor>\\<rceil> = z", "with \\<open>P \\<turnstile> T <\\<^sup>1 z' \\<Longrightarrow> U = z'\\<close>"], ["proof (chain)\npicking this:\n  P \\<turnstile> T <\\<^sup>1 z' \\<Longrightarrow> U = z'\n  z = z'\\<lfloor>\\<rceil>\n  P \\<turnstile> T <\\<^sup>1 z'", "have \"U = z'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> T <\\<^sup>1 z' \\<Longrightarrow> U = z'\n  z = z'\\<lfloor>\\<rceil>\n  P \\<turnstile> T <\\<^sup>1 z'\n\ngoal (1 subgoal):\n 1. U = z'", "by blast"], ["proof (state)\nthis:\n  U = z'\n\ngoal (5 subgoals):\n 1. \\<And>z.\n       P \\<turnstile> Class\n                       Object\\<lfloor>\\<rceil> <\\<^sup>1 z \\<Longrightarrow>\n       Class Object = z\n 2. \\<And>z.\n       P \\<turnstile> Integer\\<lfloor>\\<rceil> <\\<^sup>1 z \\<Longrightarrow>\n       Class Object = z\n 3. \\<And>z.\n       P \\<turnstile> Boolean\\<lfloor>\\<rceil> <\\<^sup>1 z \\<Longrightarrow>\n       Class Object = z\n 4. \\<And>z.\n       P \\<turnstile> Void\\<lfloor>\\<rceil> <\\<^sup>1 z \\<Longrightarrow>\n       Class Object = z\n 5. \\<And>T U z.\n       \\<lbrakk>P \\<turnstile> T <\\<^sup>1 U;\n        \\<And>z. P \\<turnstile> T <\\<^sup>1 z \\<Longrightarrow> U = z;\n        ground_type T \\<noteq> NT;\n        P \\<turnstile> T\\<lfloor>\\<rceil> <\\<^sup>1 z\\<rbrakk>\n       \\<Longrightarrow> U\\<lfloor>\\<rceil> = z", "with z'"], ["proof (chain)\npicking this:\n  z = z'\\<lfloor>\\<rceil>\n  U = z'", "show ?case"], ["proof (prove)\nusing this:\n  z = z'\\<lfloor>\\<rceil>\n  U = z'\n\ngoal (1 subgoal):\n 1. U\\<lfloor>\\<rceil> = z", "by simp"], ["proof (state)\nthis:\n  U\\<lfloor>\\<rceil> = z\n\ngoal (4 subgoals):\n 1. \\<And>z.\n       P \\<turnstile> Class\n                       Object\\<lfloor>\\<rceil> <\\<^sup>1 z \\<Longrightarrow>\n       Class Object = z\n 2. \\<And>z.\n       P \\<turnstile> Integer\\<lfloor>\\<rceil> <\\<^sup>1 z \\<Longrightarrow>\n       Class Object = z\n 3. \\<And>z.\n       P \\<turnstile> Boolean\\<lfloor>\\<rceil> <\\<^sup>1 z \\<Longrightarrow>\n       Class Object = z\n 4. \\<And>z.\n       P \\<turnstile> Void\\<lfloor>\\<rceil> <\\<^sup>1 z \\<Longrightarrow>\n       Class Object = z", "qed simp_all"], ["proof (state)\nthis:\n  y = z\n\ngoal:\nNo subgoals!", "qed"], ["", "function inheritance_level :: \"'a prog \\<Rightarrow> cname \\<Rightarrow> nat\" where\n  \"inheritance_level P C =\n   (if acyclicP (subcls1 P) \\<and> is_class P C \\<and> C \\<noteq> Object\n    then Suc (inheritance_level P (fst (the (class P C))))\n    else 0)\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>Pa C. x = (Pa, C) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>P C Pa Ca.\n       (P, C) = (Pa, Ca) \\<Longrightarrow>\n       (if acyclicP (subcls1 P) \\<and> is_class P C \\<and> C \\<noteq> Object\n        then Suc (inheritance_level_sumC (P, fst (the (class P C))))\n        else 0) =\n       (if acyclicP (subcls1 Pa) \\<and>\n           is_class Pa Ca \\<and> Ca \\<noteq> Object\n        then Suc (inheritance_level_sumC (Pa, fst (the (class Pa Ca))))\n        else 0)", "by(pat_completeness, auto)"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All inheritance_level_dom", "proof(relation \"same_fst (\\<lambda>P. acyclicP (subcls1 P)) (\\<lambda>P. {(C, C'). (subcls1 P)\\<inverse>\\<inverse> C C'})\")"], ["proof (state)\ngoal (2 subgoals):\n 1. wf (same_fst (\\<lambda>P. acyclicP (subcls1 P))\n         (\\<lambda>P. {(C, C'). (subcls1 P)\\<inverse>\\<inverse> C C'}))\n 2. \\<And>P C.\n       acyclicP (subcls1 P) \\<and>\n       is_class P C \\<and> C \\<noteq> Object \\<Longrightarrow>\n       ((P, fst (the (class P C))), P, C)\n       \\<in> same_fst (\\<lambda>P. acyclicP (subcls1 P))\n              (\\<lambda>P. {(C, C'). (subcls1 P)\\<inverse>\\<inverse> C C'})", "show \"wf (same_fst (\\<lambda>P. acyclicP (subcls1 P)) (\\<lambda>P. {(C, C'). (subcls1 P)\\<inverse>\\<inverse> C C'}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (same_fst (\\<lambda>P. acyclicP (subcls1 P))\n         (\\<lambda>P. {(C, C'). (subcls1 P)\\<inverse>\\<inverse> C C'}))", "by(rule wf_same_fst)(rule acyclicP_wf_subcls1[unfolded wfP_def])"], ["proof (state)\nthis:\n  wf (same_fst (\\<lambda>P. acyclicP (subcls1 P))\n       (\\<lambda>P. {(C, C'). (subcls1 P)\\<inverse>\\<inverse> C C'}))\n\ngoal (1 subgoal):\n 1. \\<And>P C.\n       acyclicP (subcls1 P) \\<and>\n       is_class P C \\<and> C \\<noteq> Object \\<Longrightarrow>\n       ((P, fst (the (class P C))), P, C)\n       \\<in> same_fst (\\<lambda>P. acyclicP (subcls1 P))\n              (\\<lambda>P. {(C, C'). (subcls1 P)\\<inverse>\\<inverse> C C'})", "qed(auto simp add: is_class_def intro: subcls1I)"], ["", "fun subtype_measure :: \"'a prog \\<Rightarrow> ty \\<Rightarrow> nat\" where\n  \"subtype_measure P (Class C) = inheritance_level P C\"\n| \"subtype_measure P (Array T) = 1 + subtype_measure P T\"\n| \"subtype_measure P T = 0\""], ["", "lemma subtype_measure_measure:\n  assumes acyclic: \"acyclicP (subcls1 P)\"\n  and widen1: \"P \\<turnstile> x <\\<^sup>1 y\"\n  shows \"subtype_measure P y < subtype_measure P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subtype_measure P y < subtype_measure P x", "using widen1"], ["proof (prove)\nusing this:\n  P \\<turnstile> x <\\<^sup>1 y\n\ngoal (1 subgoal):\n 1. subtype_measure P y < subtype_measure P x", "proof(induct rule: widen1.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. subtype_measure P (Class Object)\n    < subtype_measure P (Class Object\\<lfloor>\\<rceil>)\n 2. subtype_measure P (Class Object)\n    < subtype_measure P (Integer\\<lfloor>\\<rceil>)\n 3. subtype_measure P (Class Object)\n    < subtype_measure P (Boolean\\<lfloor>\\<rceil>)\n 4. subtype_measure P (Class Object)\n    < subtype_measure P (Void\\<lfloor>\\<rceil>)\n 5. \\<And>C D.\n       P \\<turnstile> C \\<prec>\\<^sup>1 D \\<Longrightarrow>\n       subtype_measure P (Class D) < subtype_measure P (Class C)\n 6. \\<And>T U.\n       \\<lbrakk>P \\<turnstile> T <\\<^sup>1 U;\n        subtype_measure P U < subtype_measure P T;\n        ground_type T \\<noteq> NT\\<rbrakk>\n       \\<Longrightarrow> subtype_measure P (U\\<lfloor>\\<rceil>)\n                         < subtype_measure P (T\\<lfloor>\\<rceil>)", "case (widen1_Class C D)"], ["proof (state)\nthis:\n  P \\<turnstile> C \\<prec>\\<^sup>1 D\n\ngoal (6 subgoals):\n 1. subtype_measure P (Class Object)\n    < subtype_measure P (Class Object\\<lfloor>\\<rceil>)\n 2. subtype_measure P (Class Object)\n    < subtype_measure P (Integer\\<lfloor>\\<rceil>)\n 3. subtype_measure P (Class Object)\n    < subtype_measure P (Boolean\\<lfloor>\\<rceil>)\n 4. subtype_measure P (Class Object)\n    < subtype_measure P (Void\\<lfloor>\\<rceil>)\n 5. \\<And>C D.\n       P \\<turnstile> C \\<prec>\\<^sup>1 D \\<Longrightarrow>\n       subtype_measure P (Class D) < subtype_measure P (Class C)\n 6. \\<And>T U.\n       \\<lbrakk>P \\<turnstile> T <\\<^sup>1 U;\n        subtype_measure P U < subtype_measure P T;\n        ground_type T \\<noteq> NT\\<rbrakk>\n       \\<Longrightarrow> subtype_measure P (U\\<lfloor>\\<rceil>)\n                         < subtype_measure P (T\\<lfloor>\\<rceil>)", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> C \\<prec>\\<^sup>1 D", "obtain rest where \"is_class P C\" \"C \\<noteq> Object\" \"class P C = \\<lfloor>(D, rest)\\<rfloor>\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C \\<prec>\\<^sup>1 D\n\ngoal (1 subgoal):\n 1. (\\<And>rest.\n        \\<lbrakk>is_class P C; C \\<noteq> Object;\n         class P C = \\<lfloor>(D, rest)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim!: subcls1.cases simp: is_class_def)"], ["proof (state)\nthis:\n  is_class P C\n  C \\<noteq> Object\n  class P C = \\<lfloor>(D, rest)\\<rfloor>\n\ngoal (6 subgoals):\n 1. subtype_measure P (Class Object)\n    < subtype_measure P (Class Object\\<lfloor>\\<rceil>)\n 2. subtype_measure P (Class Object)\n    < subtype_measure P (Integer\\<lfloor>\\<rceil>)\n 3. subtype_measure P (Class Object)\n    < subtype_measure P (Boolean\\<lfloor>\\<rceil>)\n 4. subtype_measure P (Class Object)\n    < subtype_measure P (Void\\<lfloor>\\<rceil>)\n 5. \\<And>C D.\n       P \\<turnstile> C \\<prec>\\<^sup>1 D \\<Longrightarrow>\n       subtype_measure P (Class D) < subtype_measure P (Class C)\n 6. \\<And>T U.\n       \\<lbrakk>P \\<turnstile> T <\\<^sup>1 U;\n        subtype_measure P U < subtype_measure P T;\n        ground_type T \\<noteq> NT\\<rbrakk>\n       \\<Longrightarrow> subtype_measure P (U\\<lfloor>\\<rceil>)\n                         < subtype_measure P (T\\<lfloor>\\<rceil>)", "thus ?case"], ["proof (prove)\nusing this:\n  is_class P C\n  C \\<noteq> Object\n  class P C = \\<lfloor>(D, rest)\\<rfloor>\n\ngoal (1 subgoal):\n 1. subtype_measure P (Class D) < subtype_measure P (Class C)", "using acyclic"], ["proof (prove)\nusing this:\n  is_class P C\n  C \\<noteq> Object\n  class P C = \\<lfloor>(D, rest)\\<rfloor>\n  acyclicP (subcls1 P)\n\ngoal (1 subgoal):\n 1. subtype_measure P (Class D) < subtype_measure P (Class C)", "by(simp)"], ["proof (state)\nthis:\n  subtype_measure P (Class D) < subtype_measure P (Class C)\n\ngoal (5 subgoals):\n 1. subtype_measure P (Class Object)\n    < subtype_measure P (Class Object\\<lfloor>\\<rceil>)\n 2. subtype_measure P (Class Object)\n    < subtype_measure P (Integer\\<lfloor>\\<rceil>)\n 3. subtype_measure P (Class Object)\n    < subtype_measure P (Boolean\\<lfloor>\\<rceil>)\n 4. subtype_measure P (Class Object)\n    < subtype_measure P (Void\\<lfloor>\\<rceil>)\n 5. \\<And>T U.\n       \\<lbrakk>P \\<turnstile> T <\\<^sup>1 U;\n        subtype_measure P U < subtype_measure P T;\n        ground_type T \\<noteq> NT\\<rbrakk>\n       \\<Longrightarrow> subtype_measure P (U\\<lfloor>\\<rceil>)\n                         < subtype_measure P (T\\<lfloor>\\<rceil>)", "qed(simp_all)"], ["", "lemma wf_converse_widen1:\n  assumes wfP: \"wf_prog wfmc P\"\n  shows \"wf ((widen1 P)^-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf ((widen1 P)\\<inverse>)", "proof(rule wf_subset)"], ["proof (state)\ngoal (2 subgoals):\n 1. wf ?r\n 2. (widen1 P)\\<inverse> \\<subseteq> ?r", "from wfP"], ["proof (chain)\npicking this:\n  wf_prog wfmc P", "have \"acyclicP (subcls1 P)\""], ["proof (prove)\nusing this:\n  wf_prog wfmc P\n\ngoal (1 subgoal):\n 1. acyclicP (subcls1 P)", "by(rule acyclic_subcls1)"], ["proof (state)\nthis:\n  acyclicP (subcls1 P)\n\ngoal (2 subgoals):\n 1. wf ?r\n 2. (widen1 P)\\<inverse> \\<subseteq> ?r", "thus \"(widen1 P)\\<inverse> \\<subseteq> measure (subtype_measure P)\""], ["proof (prove)\nusing this:\n  acyclicP (subcls1 P)\n\ngoal (1 subgoal):\n 1. (widen1 P)\\<inverse> \\<subseteq> measure (subtype_measure P)", "by(auto dest: subtype_measure_measure)"], ["proof (state)\nthis:\n  (widen1 P)\\<inverse> \\<subseteq> measure (subtype_measure P)\n\ngoal (1 subgoal):\n 1. wf (measure (subtype_measure P))", "qed simp"], ["", "fun super :: \"'a prog \\<Rightarrow> ty \\<Rightarrow> ty\"\nwhere\n  \"super P (Array Integer) = Class Object\"\n| \"super P (Array Boolean) = Class Object\"\n| \"super P (Array Void) = Class Object\"\n| \"super P (Array (Class C)) = (if C = Object then Class Object else Array (super P (Class C)))\"\n| \"super P (Array (Array T)) = Array (super P (Array T))\"\n| \"super P (Class C) = Class (fst (the (class P C)))\""], ["", "lemma superI:\n  \"P \\<turnstile> T <\\<^sup>1 U \\<Longrightarrow> super P T = U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T <\\<^sup>1 U \\<Longrightarrow> super P T = U", "proof(induct rule: widen1.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. super P (Class Object\\<lfloor>\\<rceil>) = Class Object\n 2. super P (Integer\\<lfloor>\\<rceil>) = Class Object\n 3. super P (Boolean\\<lfloor>\\<rceil>) = Class Object\n 4. super P (Void\\<lfloor>\\<rceil>) = Class Object\n 5. \\<And>C D.\n       P \\<turnstile> C \\<prec>\\<^sup>1 D \\<Longrightarrow>\n       super P (Class C) = Class D\n 6. \\<And>T U.\n       \\<lbrakk>P \\<turnstile> T <\\<^sup>1 U; super P T = U;\n        ground_type T \\<noteq> NT\\<rbrakk>\n       \\<Longrightarrow> super P (T\\<lfloor>\\<rceil>) = U\\<lfloor>\\<rceil>", "case (widen1_Array_Array T U)"], ["proof (state)\nthis:\n  P \\<turnstile> T <\\<^sup>1 U\n  super P T = U\n  ground_type T \\<noteq> NT\n\ngoal (6 subgoals):\n 1. super P (Class Object\\<lfloor>\\<rceil>) = Class Object\n 2. super P (Integer\\<lfloor>\\<rceil>) = Class Object\n 3. super P (Boolean\\<lfloor>\\<rceil>) = Class Object\n 4. super P (Void\\<lfloor>\\<rceil>) = Class Object\n 5. \\<And>C D.\n       P \\<turnstile> C \\<prec>\\<^sup>1 D \\<Longrightarrow>\n       super P (Class C) = Class D\n 6. \\<And>T U.\n       \\<lbrakk>P \\<turnstile> T <\\<^sup>1 U; super P T = U;\n        ground_type T \\<noteq> NT\\<rbrakk>\n       \\<Longrightarrow> super P (T\\<lfloor>\\<rceil>) = U\\<lfloor>\\<rceil>", "thus ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> T <\\<^sup>1 U\n  super P T = U\n  ground_type T \\<noteq> NT\n\ngoal (1 subgoal):\n 1. super P (T\\<lfloor>\\<rceil>) = U\\<lfloor>\\<rceil>", "by(cases T) auto"], ["proof (state)\nthis:\n  super P (T\\<lfloor>\\<rceil>) = U\\<lfloor>\\<rceil>\n\ngoal (5 subgoals):\n 1. super P (Class Object\\<lfloor>\\<rceil>) = Class Object\n 2. super P (Integer\\<lfloor>\\<rceil>) = Class Object\n 3. super P (Boolean\\<lfloor>\\<rceil>) = Class Object\n 4. super P (Void\\<lfloor>\\<rceil>) = Class Object\n 5. \\<And>C D.\n       P \\<turnstile> C \\<prec>\\<^sup>1 D \\<Longrightarrow>\n       super P (Class C) = Class D", "qed(auto dest: subcls1D)"], ["", "lemma Class_widen1_super:\n  \"P \\<turnstile> Class C' <\\<^sup>1 U' \\<longleftrightarrow> is_class P C' \\<and> C' \\<noteq> Object \\<and> U' = super P (Class C')\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Class C' <\\<^sup>1 U' =\n    (is_class P C' \\<and> C' \\<noteq> Object \\<and> U' = super P (Class C'))", "proof(rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. P \\<turnstile> Class C' <\\<^sup>1 U' \\<Longrightarrow>\n    is_class P C' \\<and> C' \\<noteq> Object \\<and> U' = super P (Class C')\n 2. is_class P C' \\<and>\n    C' \\<noteq> Object \\<and> U' = super P (Class C') \\<Longrightarrow>\n    P \\<turnstile> Class C' <\\<^sup>1 U'", "assume ?lhs"], ["proof (state)\nthis:\n  P \\<turnstile> Class C' <\\<^sup>1 U'\n\ngoal (2 subgoals):\n 1. P \\<turnstile> Class C' <\\<^sup>1 U' \\<Longrightarrow>\n    is_class P C' \\<and> C' \\<noteq> Object \\<and> U' = super P (Class C')\n 2. is_class P C' \\<and>\n    C' \\<noteq> Object \\<and> U' = super P (Class C') \\<Longrightarrow>\n    P \\<turnstile> Class C' <\\<^sup>1 U'", "thus ?rhs"], ["proof (prove)\nusing this:\n  P \\<turnstile> Class C' <\\<^sup>1 U'\n\ngoal (1 subgoal):\n 1. is_class P C' \\<and> C' \\<noteq> Object \\<and> U' = super P (Class C')", "by(auto intro: subcls_is_class simp add: superI simp del: super.simps)"], ["proof (state)\nthis:\n  is_class P C' \\<and> C' \\<noteq> Object \\<and> U' = super P (Class C')\n\ngoal (1 subgoal):\n 1. is_class P C' \\<and>\n    C' \\<noteq> Object \\<and> U' = super P (Class C') \\<Longrightarrow>\n    P \\<turnstile> Class C' <\\<^sup>1 U'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. is_class P C' \\<and>\n    C' \\<noteq> Object \\<and> U' = super P (Class C') \\<Longrightarrow>\n    P \\<turnstile> Class C' <\\<^sup>1 U'", "assume ?rhs"], ["proof (state)\nthis:\n  is_class P C' \\<and> C' \\<noteq> Object \\<and> U' = super P (Class C')\n\ngoal (1 subgoal):\n 1. is_class P C' \\<and>\n    C' \\<noteq> Object \\<and> U' = super P (Class C') \\<Longrightarrow>\n    P \\<turnstile> Class C' <\\<^sup>1 U'", "thus ?lhs"], ["proof (prove)\nusing this:\n  is_class P C' \\<and> C' \\<noteq> Object \\<and> U' = super P (Class C')\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Class C' <\\<^sup>1 U'", "by(auto simp add: is_class_def intro: subcls1.intros)"], ["proof (state)\nthis:\n  P \\<turnstile> Class C' <\\<^sup>1 U'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma super_widen1:\n  assumes icO: \"is_class P Object\"\n  shows \"P \\<turnstile> T <\\<^sup>1 U \\<longleftrightarrow> is_type P T \\<and> (case T of Class C  \\<Rightarrow> (C \\<noteq> Object \\<and> U = super P T) \n                                              | Array T' \\<Rightarrow> U = super P T \n                                              | _        \\<Rightarrow> False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T <\\<^sup>1 U =\n    (is_type P T \\<and>\n     (case T of Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P T\n      | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P T\n      | _ \\<Rightarrow> False))", "proof(induct T arbitrary: U)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>U.\n       P \\<turnstile> Void <\\<^sup>1 U =\n       (is_type P Void \\<and>\n        (case Void of\n         Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P Void\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P Void\n         | _ \\<Rightarrow> False))\n 2. \\<And>U.\n       P \\<turnstile> Boolean <\\<^sup>1 U =\n       (is_type P Boolean \\<and>\n        (case Boolean of\n         Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P Boolean\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P Boolean\n         | _ \\<Rightarrow> False))\n 3. \\<And>U.\n       P \\<turnstile> Integer <\\<^sup>1 U =\n       (is_type P Integer \\<and>\n        (case Integer of\n         Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P Integer\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P Integer\n         | _ \\<Rightarrow> False))\n 4. \\<And>U.\n       P \\<turnstile> NT <\\<^sup>1 U =\n       (is_type P NT \\<and>\n        (case NT of\n         Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P NT\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P NT\n         | _ \\<Rightarrow> False))\n 5. \\<And>x U.\n       P \\<turnstile> Class x <\\<^sup>1 U =\n       (is_type P (Class x) \\<and>\n        (case Class x of\n         Class C \\<Rightarrow>\n           C \\<noteq> Object \\<and> U = super P (Class x)\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P (Class x)\n         | _ \\<Rightarrow> False))\n 6. \\<And>T U.\n       (\\<And>U.\n           P \\<turnstile> T <\\<^sup>1 U =\n           (is_type P T \\<and>\n            (case T of\n             Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P T\n             | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P T\n             | _ \\<Rightarrow> False))) \\<Longrightarrow>\n       P \\<turnstile> T\\<lfloor>\\<rceil> <\\<^sup>1 U =\n       (is_type P (T\\<lfloor>\\<rceil>) \\<and>\n        (case T\\<lfloor>\\<rceil> of\n         Class C \\<Rightarrow>\n           C \\<noteq> Object \\<and> U = super P (T\\<lfloor>\\<rceil>)\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow>\n             U = super P (T\\<lfloor>\\<rceil>)\n         | _ \\<Rightarrow> False))", "case Class"], ["proof (state)\nthis:\n  \n\ngoal (6 subgoals):\n 1. \\<And>U.\n       P \\<turnstile> Void <\\<^sup>1 U =\n       (is_type P Void \\<and>\n        (case Void of\n         Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P Void\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P Void\n         | _ \\<Rightarrow> False))\n 2. \\<And>U.\n       P \\<turnstile> Boolean <\\<^sup>1 U =\n       (is_type P Boolean \\<and>\n        (case Boolean of\n         Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P Boolean\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P Boolean\n         | _ \\<Rightarrow> False))\n 3. \\<And>U.\n       P \\<turnstile> Integer <\\<^sup>1 U =\n       (is_type P Integer \\<and>\n        (case Integer of\n         Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P Integer\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P Integer\n         | _ \\<Rightarrow> False))\n 4. \\<And>U.\n       P \\<turnstile> NT <\\<^sup>1 U =\n       (is_type P NT \\<and>\n        (case NT of\n         Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P NT\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P NT\n         | _ \\<Rightarrow> False))\n 5. \\<And>x U.\n       P \\<turnstile> Class x <\\<^sup>1 U =\n       (is_type P (Class x) \\<and>\n        (case Class x of\n         Class C \\<Rightarrow>\n           C \\<noteq> Object \\<and> U = super P (Class x)\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P (Class x)\n         | _ \\<Rightarrow> False))\n 6. \\<And>T U.\n       (\\<And>U.\n           P \\<turnstile> T <\\<^sup>1 U =\n           (is_type P T \\<and>\n            (case T of\n             Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P T\n             | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P T\n             | _ \\<Rightarrow> False))) \\<Longrightarrow>\n       P \\<turnstile> T\\<lfloor>\\<rceil> <\\<^sup>1 U =\n       (is_type P (T\\<lfloor>\\<rceil>) \\<and>\n        (case T\\<lfloor>\\<rceil> of\n         Class C \\<Rightarrow>\n           C \\<noteq> Object \\<and> U = super P (T\\<lfloor>\\<rceil>)\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow>\n             U = super P (T\\<lfloor>\\<rceil>)\n         | _ \\<Rightarrow> False))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Class x_ <\\<^sup>1 U =\n    (is_type P (Class x_) \\<and>\n     (case Class x_ of\n      Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P (Class x_)\n      | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P (Class x_)\n      | _ \\<Rightarrow> False))", "using Class_widen1_super"], ["proof (prove)\nusing this:\n  ?P \\<turnstile> Class ?C' <\\<^sup>1 ?U' =\n  (is_class ?P ?C' \\<and>\n   ?C' \\<noteq> Object \\<and> ?U' = super ?P (Class ?C'))\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Class x_ <\\<^sup>1 U =\n    (is_type P (Class x_) \\<and>\n     (case Class x_ of\n      Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P (Class x_)\n      | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P (Class x_)\n      | _ \\<Rightarrow> False))", "by(simp)"], ["proof (state)\nthis:\n  P \\<turnstile> Class x_ <\\<^sup>1 U =\n  (is_type P (Class x_) \\<and>\n   (case Class x_ of\n    Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P (Class x_)\n    | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P (Class x_)\n    | _ \\<Rightarrow> False))\n\ngoal (5 subgoals):\n 1. \\<And>U.\n       P \\<turnstile> Void <\\<^sup>1 U =\n       (is_type P Void \\<and>\n        (case Void of\n         Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P Void\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P Void\n         | _ \\<Rightarrow> False))\n 2. \\<And>U.\n       P \\<turnstile> Boolean <\\<^sup>1 U =\n       (is_type P Boolean \\<and>\n        (case Boolean of\n         Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P Boolean\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P Boolean\n         | _ \\<Rightarrow> False))\n 3. \\<And>U.\n       P \\<turnstile> Integer <\\<^sup>1 U =\n       (is_type P Integer \\<and>\n        (case Integer of\n         Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P Integer\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P Integer\n         | _ \\<Rightarrow> False))\n 4. \\<And>U.\n       P \\<turnstile> NT <\\<^sup>1 U =\n       (is_type P NT \\<and>\n        (case NT of\n         Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P NT\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P NT\n         | _ \\<Rightarrow> False))\n 5. \\<And>T U.\n       (\\<And>U.\n           P \\<turnstile> T <\\<^sup>1 U =\n           (is_type P T \\<and>\n            (case T of\n             Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P T\n             | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P T\n             | _ \\<Rightarrow> False))) \\<Longrightarrow>\n       P \\<turnstile> T\\<lfloor>\\<rceil> <\\<^sup>1 U =\n       (is_type P (T\\<lfloor>\\<rceil>) \\<and>\n        (case T\\<lfloor>\\<rceil> of\n         Class C \\<Rightarrow>\n           C \\<noteq> Object \\<and> U = super P (T\\<lfloor>\\<rceil>)\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow>\n             U = super P (T\\<lfloor>\\<rceil>)\n         | _ \\<Rightarrow> False))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>U.\n       P \\<turnstile> Void <\\<^sup>1 U =\n       (is_type P Void \\<and>\n        (case Void of\n         Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P Void\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P Void\n         | _ \\<Rightarrow> False))\n 2. \\<And>U.\n       P \\<turnstile> Boolean <\\<^sup>1 U =\n       (is_type P Boolean \\<and>\n        (case Boolean of\n         Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P Boolean\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P Boolean\n         | _ \\<Rightarrow> False))\n 3. \\<And>U.\n       P \\<turnstile> Integer <\\<^sup>1 U =\n       (is_type P Integer \\<and>\n        (case Integer of\n         Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P Integer\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P Integer\n         | _ \\<Rightarrow> False))\n 4. \\<And>U.\n       P \\<turnstile> NT <\\<^sup>1 U =\n       (is_type P NT \\<and>\n        (case NT of\n         Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P NT\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P NT\n         | _ \\<Rightarrow> False))\n 5. \\<And>T U.\n       (\\<And>U.\n           P \\<turnstile> T <\\<^sup>1 U =\n           (is_type P T \\<and>\n            (case T of\n             Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P T\n             | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P T\n             | _ \\<Rightarrow> False))) \\<Longrightarrow>\n       P \\<turnstile> T\\<lfloor>\\<rceil> <\\<^sup>1 U =\n       (is_type P (T\\<lfloor>\\<rceil>) \\<and>\n        (case T\\<lfloor>\\<rceil> of\n         Class C \\<Rightarrow>\n           C \\<noteq> Object \\<and> U = super P (T\\<lfloor>\\<rceil>)\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow>\n             U = super P (T\\<lfloor>\\<rceil>)\n         | _ \\<Rightarrow> False))", "case (Array T' U')"], ["proof (state)\nthis:\n  P \\<turnstile> T' <\\<^sup>1 ?U =\n  (is_type P T' \\<and>\n   (case T' of\n    Class C \\<Rightarrow> C \\<noteq> Object \\<and> ?U = super P T'\n    | T'a\\<lfloor>\\<rceil> \\<Rightarrow> ?U = super P T'\n    | _ \\<Rightarrow> False))\n\ngoal (5 subgoals):\n 1. \\<And>U.\n       P \\<turnstile> Void <\\<^sup>1 U =\n       (is_type P Void \\<and>\n        (case Void of\n         Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P Void\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P Void\n         | _ \\<Rightarrow> False))\n 2. \\<And>U.\n       P \\<turnstile> Boolean <\\<^sup>1 U =\n       (is_type P Boolean \\<and>\n        (case Boolean of\n         Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P Boolean\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P Boolean\n         | _ \\<Rightarrow> False))\n 3. \\<And>U.\n       P \\<turnstile> Integer <\\<^sup>1 U =\n       (is_type P Integer \\<and>\n        (case Integer of\n         Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P Integer\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P Integer\n         | _ \\<Rightarrow> False))\n 4. \\<And>U.\n       P \\<turnstile> NT <\\<^sup>1 U =\n       (is_type P NT \\<and>\n        (case NT of\n         Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P NT\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P NT\n         | _ \\<Rightarrow> False))\n 5. \\<And>T U.\n       (\\<And>U.\n           P \\<turnstile> T <\\<^sup>1 U =\n           (is_type P T \\<and>\n            (case T of\n             Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P T\n             | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P T\n             | _ \\<Rightarrow> False))) \\<Longrightarrow>\n       P \\<turnstile> T\\<lfloor>\\<rceil> <\\<^sup>1 U =\n       (is_type P (T\\<lfloor>\\<rceil>) \\<and>\n        (case T\\<lfloor>\\<rceil> of\n         Class C \\<Rightarrow>\n           C \\<noteq> Object \\<and> U = super P (T\\<lfloor>\\<rceil>)\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow>\n             U = super P (T\\<lfloor>\\<rceil>)\n         | _ \\<Rightarrow> False))", "note IH = this"], ["proof (state)\nthis:\n  P \\<turnstile> T' <\\<^sup>1 ?U =\n  (is_type P T' \\<and>\n   (case T' of\n    Class C \\<Rightarrow> C \\<noteq> Object \\<and> ?U = super P T'\n    | T'a\\<lfloor>\\<rceil> \\<Rightarrow> ?U = super P T'\n    | _ \\<Rightarrow> False))\n\ngoal (5 subgoals):\n 1. \\<And>U.\n       P \\<turnstile> Void <\\<^sup>1 U =\n       (is_type P Void \\<and>\n        (case Void of\n         Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P Void\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P Void\n         | _ \\<Rightarrow> False))\n 2. \\<And>U.\n       P \\<turnstile> Boolean <\\<^sup>1 U =\n       (is_type P Boolean \\<and>\n        (case Boolean of\n         Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P Boolean\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P Boolean\n         | _ \\<Rightarrow> False))\n 3. \\<And>U.\n       P \\<turnstile> Integer <\\<^sup>1 U =\n       (is_type P Integer \\<and>\n        (case Integer of\n         Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P Integer\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P Integer\n         | _ \\<Rightarrow> False))\n 4. \\<And>U.\n       P \\<turnstile> NT <\\<^sup>1 U =\n       (is_type P NT \\<and>\n        (case NT of\n         Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P NT\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P NT\n         | _ \\<Rightarrow> False))\n 5. \\<And>T U.\n       (\\<And>U.\n           P \\<turnstile> T <\\<^sup>1 U =\n           (is_type P T \\<and>\n            (case T of\n             Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P T\n             | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P T\n             | _ \\<Rightarrow> False))) \\<Longrightarrow>\n       P \\<turnstile> T\\<lfloor>\\<rceil> <\\<^sup>1 U =\n       (is_type P (T\\<lfloor>\\<rceil>) \\<and>\n        (case T\\<lfloor>\\<rceil> of\n         Class C \\<Rightarrow>\n           C \\<noteq> Object \\<and> U = super P (T\\<lfloor>\\<rceil>)\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow>\n             U = super P (T\\<lfloor>\\<rceil>)\n         | _ \\<Rightarrow> False))", "have \"P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U' = (is_type P (T'\\<lfloor>\\<rceil>) \\<and> U' = super P (T'\\<lfloor>\\<rceil>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U' =\n    (is_type P (T'\\<lfloor>\\<rceil>) \\<and>\n     U' = super P (T'\\<lfloor>\\<rceil>))", "proof(rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U' \\<Longrightarrow>\n    is_type P (T'\\<lfloor>\\<rceil>) \\<and>\n    U' = super P (T'\\<lfloor>\\<rceil>)\n 2. is_type P (T'\\<lfloor>\\<rceil>) \\<and>\n    U' = super P (T'\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'", "assume wd: \"P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'\""], ["proof (state)\nthis:\n  P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'\n\ngoal (2 subgoals):\n 1. P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U' \\<Longrightarrow>\n    is_type P (T'\\<lfloor>\\<rceil>) \\<and>\n    U' = super P (T'\\<lfloor>\\<rceil>)\n 2. is_type P (T'\\<lfloor>\\<rceil>) \\<and>\n    U' = super P (T'\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'", "with icO"], ["proof (chain)\npicking this:\n  is_class P Object\n  P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'", "have \"is_type P (T'\\<lfloor>\\<rceil>)\""], ["proof (prove)\nusing this:\n  is_class P Object\n  P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'\n\ngoal (1 subgoal):\n 1. is_type P (T'\\<lfloor>\\<rceil>)", "by(rule is_type_widen1)"], ["proof (state)\nthis:\n  is_type P (T'\\<lfloor>\\<rceil>)\n\ngoal (2 subgoals):\n 1. P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U' \\<Longrightarrow>\n    is_type P (T'\\<lfloor>\\<rceil>) \\<and>\n    U' = super P (T'\\<lfloor>\\<rceil>)\n 2. is_type P (T'\\<lfloor>\\<rceil>) \\<and>\n    U' = super P (T'\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'", "moreover"], ["proof (state)\nthis:\n  is_type P (T'\\<lfloor>\\<rceil>)\n\ngoal (2 subgoals):\n 1. P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U' \\<Longrightarrow>\n    is_type P (T'\\<lfloor>\\<rceil>) \\<and>\n    U' = super P (T'\\<lfloor>\\<rceil>)\n 2. is_type P (T'\\<lfloor>\\<rceil>) \\<and>\n    U' = super P (T'\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'", "from wd"], ["proof (chain)\npicking this:\n  P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'", "have \"super P (T'\\<lfloor>\\<rceil>) = U'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'\n\ngoal (1 subgoal):\n 1. super P (T'\\<lfloor>\\<rceil>) = U'", "by(rule superI)"], ["proof (state)\nthis:\n  super P (T'\\<lfloor>\\<rceil>) = U'\n\ngoal (2 subgoals):\n 1. P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U' \\<Longrightarrow>\n    is_type P (T'\\<lfloor>\\<rceil>) \\<and>\n    U' = super P (T'\\<lfloor>\\<rceil>)\n 2. is_type P (T'\\<lfloor>\\<rceil>) \\<and>\n    U' = super P (T'\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'", "ultimately"], ["proof (chain)\npicking this:\n  is_type P (T'\\<lfloor>\\<rceil>)\n  super P (T'\\<lfloor>\\<rceil>) = U'", "show \"is_type P (T'\\<lfloor>\\<rceil>) \\<and> U' = super P (T'\\<lfloor>\\<rceil>)\""], ["proof (prove)\nusing this:\n  is_type P (T'\\<lfloor>\\<rceil>)\n  super P (T'\\<lfloor>\\<rceil>) = U'\n\ngoal (1 subgoal):\n 1. is_type P (T'\\<lfloor>\\<rceil>) \\<and>\n    U' = super P (T'\\<lfloor>\\<rceil>)", "by simp"], ["proof (state)\nthis:\n  is_type P (T'\\<lfloor>\\<rceil>) \\<and> U' = super P (T'\\<lfloor>\\<rceil>)\n\ngoal (1 subgoal):\n 1. is_type P (T'\\<lfloor>\\<rceil>) \\<and>\n    U' = super P (T'\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. is_type P (T'\\<lfloor>\\<rceil>) \\<and>\n    U' = super P (T'\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'", "assume \"is_type P (T'\\<lfloor>\\<rceil>) \\<and> U' = super P (T'\\<lfloor>\\<rceil>)\""], ["proof (state)\nthis:\n  is_type P (T'\\<lfloor>\\<rceil>) \\<and> U' = super P (T'\\<lfloor>\\<rceil>)\n\ngoal (1 subgoal):\n 1. is_type P (T'\\<lfloor>\\<rceil>) \\<and>\n    U' = super P (T'\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'", "then"], ["proof (chain)\npicking this:\n  is_type P (T'\\<lfloor>\\<rceil>) \\<and> U' = super P (T'\\<lfloor>\\<rceil>)", "obtain \"is_type P (T'\\<lfloor>\\<rceil>)\" and U': \"U' = super P (T'\\<lfloor>\\<rceil>)\""], ["proof (prove)\nusing this:\n  is_type P (T'\\<lfloor>\\<rceil>) \\<and> U' = super P (T'\\<lfloor>\\<rceil>)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>is_type P (T'\\<lfloor>\\<rceil>);\n      U' = super P (T'\\<lfloor>\\<rceil>)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  is_type P (T'\\<lfloor>\\<rceil>)\n  U' = super P (T'\\<lfloor>\\<rceil>)\n\ngoal (1 subgoal):\n 1. is_type P (T'\\<lfloor>\\<rceil>) \\<and>\n    U' = super P (T'\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'", "thus \"P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'\""], ["proof (prove)\nusing this:\n  is_type P (T'\\<lfloor>\\<rceil>)\n  U' = super P (T'\\<lfloor>\\<rceil>)\n\ngoal (1 subgoal):\n 1. P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'", "proof(cases T')"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<lbrakk>is_type P (T'\\<lfloor>\\<rceil>);\n     U' = super P (T'\\<lfloor>\\<rceil>); T' = Void\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'\n 2. \\<lbrakk>is_type P (T'\\<lfloor>\\<rceil>);\n     U' = super P (T'\\<lfloor>\\<rceil>); T' = Boolean\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'\n 3. \\<lbrakk>is_type P (T'\\<lfloor>\\<rceil>);\n     U' = super P (T'\\<lfloor>\\<rceil>); T' = Integer\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'\n 4. \\<lbrakk>is_type P (T'\\<lfloor>\\<rceil>);\n     U' = super P (T'\\<lfloor>\\<rceil>); T' = NT\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'\n 5. \\<And>x5.\n       \\<lbrakk>is_type P (T'\\<lfloor>\\<rceil>);\n        U' = super P (T'\\<lfloor>\\<rceil>); T' = Class x5\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'\n 6. \\<And>x6.\n       \\<lbrakk>is_type P (T'\\<lfloor>\\<rceil>);\n        U' = super P (T'\\<lfloor>\\<rceil>);\n        T' = x6\\<lfloor>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'", "case (Class D)"], ["proof (state)\nthis:\n  T' = Class D\n\ngoal (6 subgoals):\n 1. \\<lbrakk>is_type P (T'\\<lfloor>\\<rceil>);\n     U' = super P (T'\\<lfloor>\\<rceil>); T' = Void\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'\n 2. \\<lbrakk>is_type P (T'\\<lfloor>\\<rceil>);\n     U' = super P (T'\\<lfloor>\\<rceil>); T' = Boolean\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'\n 3. \\<lbrakk>is_type P (T'\\<lfloor>\\<rceil>);\n     U' = super P (T'\\<lfloor>\\<rceil>); T' = Integer\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'\n 4. \\<lbrakk>is_type P (T'\\<lfloor>\\<rceil>);\n     U' = super P (T'\\<lfloor>\\<rceil>); T' = NT\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'\n 5. \\<And>x5.\n       \\<lbrakk>is_type P (T'\\<lfloor>\\<rceil>);\n        U' = super P (T'\\<lfloor>\\<rceil>); T' = Class x5\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'\n 6. \\<And>x6.\n       \\<lbrakk>is_type P (T'\\<lfloor>\\<rceil>);\n        U' = super P (T'\\<lfloor>\\<rceil>);\n        T' = x6\\<lfloor>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'", "thus ?thesis"], ["proof (prove)\nusing this:\n  T' = Class D\n\ngoal (1 subgoal):\n 1. P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'", "using U' icO \\<open>is_type P (T'\\<lfloor>\\<rceil>)\\<close>"], ["proof (prove)\nusing this:\n  T' = Class D\n  U' = super P (T'\\<lfloor>\\<rceil>)\n  is_class P Object\n  is_type P (T'\\<lfloor>\\<rceil>)\n\ngoal (1 subgoal):\n 1. P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'", "by(cases \"D = Object\")(auto simp add: is_class_def intro: subcls1.intros)"], ["proof (state)\nthis:\n  P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'\n\ngoal (5 subgoals):\n 1. \\<lbrakk>is_type P (T'\\<lfloor>\\<rceil>);\n     U' = super P (T'\\<lfloor>\\<rceil>); T' = Void\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'\n 2. \\<lbrakk>is_type P (T'\\<lfloor>\\<rceil>);\n     U' = super P (T'\\<lfloor>\\<rceil>); T' = Boolean\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'\n 3. \\<lbrakk>is_type P (T'\\<lfloor>\\<rceil>);\n     U' = super P (T'\\<lfloor>\\<rceil>); T' = Integer\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'\n 4. \\<lbrakk>is_type P (T'\\<lfloor>\\<rceil>);\n     U' = super P (T'\\<lfloor>\\<rceil>); T' = NT\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'\n 5. \\<And>x6.\n       \\<lbrakk>is_type P (T'\\<lfloor>\\<rceil>);\n        U' = super P (T'\\<lfloor>\\<rceil>);\n        T' = x6\\<lfloor>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<lbrakk>is_type P (T'\\<lfloor>\\<rceil>);\n     U' = super P (T'\\<lfloor>\\<rceil>); T' = Void\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'\n 2. \\<lbrakk>is_type P (T'\\<lfloor>\\<rceil>);\n     U' = super P (T'\\<lfloor>\\<rceil>); T' = Boolean\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'\n 3. \\<lbrakk>is_type P (T'\\<lfloor>\\<rceil>);\n     U' = super P (T'\\<lfloor>\\<rceil>); T' = Integer\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'\n 4. \\<lbrakk>is_type P (T'\\<lfloor>\\<rceil>);\n     U' = super P (T'\\<lfloor>\\<rceil>); T' = NT\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'\n 5. \\<And>x6.\n       \\<lbrakk>is_type P (T'\\<lfloor>\\<rceil>);\n        U' = super P (T'\\<lfloor>\\<rceil>);\n        T' = x6\\<lfloor>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'", "case Array"], ["proof (state)\nthis:\n  T' = x6_\\<lfloor>\\<rceil>\n\ngoal (5 subgoals):\n 1. \\<lbrakk>is_type P (T'\\<lfloor>\\<rceil>);\n     U' = super P (T'\\<lfloor>\\<rceil>); T' = Void\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'\n 2. \\<lbrakk>is_type P (T'\\<lfloor>\\<rceil>);\n     U' = super P (T'\\<lfloor>\\<rceil>); T' = Boolean\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'\n 3. \\<lbrakk>is_type P (T'\\<lfloor>\\<rceil>);\n     U' = super P (T'\\<lfloor>\\<rceil>); T' = Integer\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'\n 4. \\<lbrakk>is_type P (T'\\<lfloor>\\<rceil>);\n     U' = super P (T'\\<lfloor>\\<rceil>); T' = NT\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'\n 5. \\<And>x6.\n       \\<lbrakk>is_type P (T'\\<lfloor>\\<rceil>);\n        U' = super P (T'\\<lfloor>\\<rceil>);\n        T' = x6\\<lfloor>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'", "thus ?thesis"], ["proof (prove)\nusing this:\n  T' = x6_\\<lfloor>\\<rceil>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'", "using IH \\<open>is_type P (T'\\<lfloor>\\<rceil>)\\<close> U'"], ["proof (prove)\nusing this:\n  T' = x6_\\<lfloor>\\<rceil>\n  P \\<turnstile> T' <\\<^sup>1 ?U =\n  (is_type P T' \\<and>\n   (case T' of\n    Class C \\<Rightarrow> C \\<noteq> Object \\<and> ?U = super P T'\n    | T'a\\<lfloor>\\<rceil> \\<Rightarrow> ?U = super P T'\n    | _ \\<Rightarrow> False))\n  is_type P (T'\\<lfloor>\\<rceil>)\n  U' = super P (T'\\<lfloor>\\<rceil>)\n\ngoal (1 subgoal):\n 1. P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'", "by(auto simp add: ty.split_asm)"], ["proof (state)\nthis:\n  P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'\n\ngoal (4 subgoals):\n 1. \\<lbrakk>is_type P (T'\\<lfloor>\\<rceil>);\n     U' = super P (T'\\<lfloor>\\<rceil>); T' = Void\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'\n 2. \\<lbrakk>is_type P (T'\\<lfloor>\\<rceil>);\n     U' = super P (T'\\<lfloor>\\<rceil>); T' = Boolean\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'\n 3. \\<lbrakk>is_type P (T'\\<lfloor>\\<rceil>);\n     U' = super P (T'\\<lfloor>\\<rceil>); T' = Integer\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'\n 4. \\<lbrakk>is_type P (T'\\<lfloor>\\<rceil>);\n     U' = super P (T'\\<lfloor>\\<rceil>); T' = NT\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'", "qed simp_all"], ["proof (state)\nthis:\n  P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U' =\n  (is_type P (T'\\<lfloor>\\<rceil>) \\<and>\n   U' = super P (T'\\<lfloor>\\<rceil>))\n\ngoal (5 subgoals):\n 1. \\<And>U.\n       P \\<turnstile> Void <\\<^sup>1 U =\n       (is_type P Void \\<and>\n        (case Void of\n         Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P Void\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P Void\n         | _ \\<Rightarrow> False))\n 2. \\<And>U.\n       P \\<turnstile> Boolean <\\<^sup>1 U =\n       (is_type P Boolean \\<and>\n        (case Boolean of\n         Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P Boolean\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P Boolean\n         | _ \\<Rightarrow> False))\n 3. \\<And>U.\n       P \\<turnstile> Integer <\\<^sup>1 U =\n       (is_type P Integer \\<and>\n        (case Integer of\n         Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P Integer\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P Integer\n         | _ \\<Rightarrow> False))\n 4. \\<And>U.\n       P \\<turnstile> NT <\\<^sup>1 U =\n       (is_type P NT \\<and>\n        (case NT of\n         Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P NT\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P NT\n         | _ \\<Rightarrow> False))\n 5. \\<And>T U.\n       (\\<And>U.\n           P \\<turnstile> T <\\<^sup>1 U =\n           (is_type P T \\<and>\n            (case T of\n             Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P T\n             | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P T\n             | _ \\<Rightarrow> False))) \\<Longrightarrow>\n       P \\<turnstile> T\\<lfloor>\\<rceil> <\\<^sup>1 U =\n       (is_type P (T\\<lfloor>\\<rceil>) \\<and>\n        (case T\\<lfloor>\\<rceil> of\n         Class C \\<Rightarrow>\n           C \\<noteq> Object \\<and> U = super P (T\\<lfloor>\\<rceil>)\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow>\n             U = super P (T\\<lfloor>\\<rceil>)\n         | _ \\<Rightarrow> False))", "thus ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U' =\n  (is_type P (T'\\<lfloor>\\<rceil>) \\<and>\n   U' = super P (T'\\<lfloor>\\<rceil>))\n\ngoal (1 subgoal):\n 1. P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U' =\n    (is_type P (T'\\<lfloor>\\<rceil>) \\<and>\n     (case T'\\<lfloor>\\<rceil> of\n      Class C \\<Rightarrow>\n        C \\<noteq> Object \\<and> U' = super P (T'\\<lfloor>\\<rceil>)\n      | T'a\\<lfloor>\\<rceil> \\<Rightarrow>\n          U' = super P (T'\\<lfloor>\\<rceil>)\n      | _ \\<Rightarrow> False))", "by(simp)"], ["proof (state)\nthis:\n  P \\<turnstile> T'\\<lfloor>\\<rceil> <\\<^sup>1 U' =\n  (is_type P (T'\\<lfloor>\\<rceil>) \\<and>\n   (case T'\\<lfloor>\\<rceil> of\n    Class C \\<Rightarrow>\n      C \\<noteq> Object \\<and> U' = super P (T'\\<lfloor>\\<rceil>)\n    | T'a\\<lfloor>\\<rceil> \\<Rightarrow> U' = super P (T'\\<lfloor>\\<rceil>)\n    | _ \\<Rightarrow> False))\n\ngoal (4 subgoals):\n 1. \\<And>U.\n       P \\<turnstile> Void <\\<^sup>1 U =\n       (is_type P Void \\<and>\n        (case Void of\n         Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P Void\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P Void\n         | _ \\<Rightarrow> False))\n 2. \\<And>U.\n       P \\<turnstile> Boolean <\\<^sup>1 U =\n       (is_type P Boolean \\<and>\n        (case Boolean of\n         Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P Boolean\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P Boolean\n         | _ \\<Rightarrow> False))\n 3. \\<And>U.\n       P \\<turnstile> Integer <\\<^sup>1 U =\n       (is_type P Integer \\<and>\n        (case Integer of\n         Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P Integer\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P Integer\n         | _ \\<Rightarrow> False))\n 4. \\<And>U.\n       P \\<turnstile> NT <\\<^sup>1 U =\n       (is_type P NT \\<and>\n        (case NT of\n         Class C \\<Rightarrow> C \\<noteq> Object \\<and> U = super P NT\n         | T'\\<lfloor>\\<rceil> \\<Rightarrow> U = super P NT\n         | _ \\<Rightarrow> False))", "qed(simp_all)"], ["", "definition sup :: \"'c prog \\<Rightarrow> ty \\<Rightarrow> ty \\<Rightarrow> ty err\" where\n  \"sup P T U \\<equiv>\n   if is_refT T \\<and> is_refT U\n   then OK (if U = NT then T\n            else if T = NT then U\n            else exec_lub (widen1 P) (super P) T U)\n   else if (T = U) then OK T else Err\""], ["", "lemma sup_def':\n  \"sup P = (\\<lambda>T U.\n   if is_refT T \\<and> is_refT U\n   then OK (if U = NT then T\n            else if T = NT then U\n            else exec_lub (widen1 P) (super P) T U)\n   else if (T = U) then OK T else Err)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SemiType.sup P =\n    (\\<lambda>T U.\n        if is_refT T \\<and> is_refT U\n        then OK (if U = NT then T\n                 else if T = NT then U\n                      else exec_lub (widen1 P) (super P) T U)\n        else if T = U then OK T else Err)", "by (simp add: fun_eq_iff sup_def)"], ["", "definition esl :: \"'m prog \\<Rightarrow> ty esl\"\nwhere\n  \"esl P = (types P, widen P, sup P)\""], ["", "lemma order_widen [intro,simp]: \n  \"wf_prog m P \\<Longrightarrow> order (widen P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog m P \\<Longrightarrow> order (widen P)", "unfolding Semilat.order_def lesub_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog m P \\<Longrightarrow>\n    (\\<forall>x. P \\<turnstile> x \\<le> x) \\<and>\n    (\\<forall>x y.\n        P \\<turnstile> x \\<le> y \\<and>\n        P \\<turnstile> y \\<le> x \\<longrightarrow>\n        x = y) \\<and>\n    (\\<forall>x y z.\n        P \\<turnstile> x \\<le> y \\<and>\n        P \\<turnstile> y \\<le> z \\<longrightarrow>\n        P \\<turnstile> x \\<le> z)", "by (auto intro: widen_trans widen_antisym)"], ["", "lemma subcls1_trancl_widen1_trancl:\n  \"(subcls1 P)^++ C D \\<Longrightarrow> P \\<turnstile> Class C <\\<^sup>+ Class D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (subcls1 P)\\<^sup>+\\<^sup>+ C D \\<Longrightarrow>\n    P \\<turnstile> Class C <\\<^sup>+ Class D", "by(induct rule: tranclp_induct[consumes 1, case_names base step])\n  (auto intro: trancl_into_trancl)"], ["", "lemma subcls_into_widen1_rtrancl:\n  \"P \\<turnstile> C \\<preceq>\\<^sup>* D \\<Longrightarrow> P \\<turnstile> Class C <\\<^sup>* Class D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C \\<preceq>\\<^sup>* D \\<Longrightarrow>\n    P \\<turnstile> Class C <\\<^sup>* Class D", "by(induct rule: rtranclp_induct)(auto intro: rtrancl_into_rtrancl)"], ["", "lemma not_widen1_NT_Array:\n  \"P \\<turnstile> U <\\<^sup>1 T \\<Longrightarrow> \\<not> is_NT_Array T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> U <\\<^sup>1 T \\<Longrightarrow> ground_type T \\<noteq> NT", "by(induct rule: widen1.induct)(auto)"], ["", "lemma widen1_trancl_into_Array_widen1_trancl:\n  \"\\<lbrakk> P \\<turnstile> A <\\<^sup>+ B; \\<not> is_NT_Array A \\<rbrakk> \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ B\\<lfloor>\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> A <\\<^sup>+ B;\n     ground_type A \\<noteq> NT\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ B\\<lfloor>\\<rceil>", "by(induct rule: converse_trancl_induct)\n  (auto intro: trancl_into_trancl2 widen1_Array_Array dest: not_widen1_NT_Array)"], ["", "lemma widen1_rtrancl_into_Array_widen1_rtrancl:\n  \"\\<lbrakk> P \\<turnstile> A <\\<^sup>* B; \\<not> is_NT_Array A \\<rbrakk> \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>* B\\<lfloor>\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> A <\\<^sup>* B;\n     ground_type A \\<noteq> NT\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>* B\\<lfloor>\\<rceil>", "by(blast elim: rtranclE intro: trancl_into_rtrancl widen1_trancl_into_Array_widen1_trancl rtrancl_into_trancl1)"], ["", "lemma Array_Object_widen1_trancl:\n  assumes wf: \"wf_prog wmdc P\"\n  and itA: \"is_type P (A\\<lfloor>\\<rceil>)\"\n  shows \"P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ Class Object", "using itA"], ["proof (prove)\nusing this:\n  is_type P (A\\<lfloor>\\<rceil>)\n\ngoal (1 subgoal):\n 1. P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ Class Object", "proof(induction A)"], ["proof (state)\ngoal (6 subgoals):\n 1. is_type P (Void\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Void\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 2. is_type P (Boolean\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Boolean\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 3. is_type P (Integer\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Integer\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 4. is_type P (NT\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> NT\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 5. \\<And>x.\n       is_type P (Class x\\<lfloor>\\<rceil>) \\<Longrightarrow>\n       P \\<turnstile> Class x\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 6. \\<And>A.\n       \\<lbrakk>is_type P (A\\<lfloor>\\<rceil>) \\<Longrightarrow>\n                P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ Class Object;\n        is_type P (A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil> <\\<^sup>+ Class\n           Object", "case (Class C)"], ["proof (state)\nthis:\n  is_type P (Class C\\<lfloor>\\<rceil>)\n\ngoal (6 subgoals):\n 1. is_type P (Void\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Void\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 2. is_type P (Boolean\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Boolean\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 3. is_type P (Integer\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Integer\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 4. is_type P (NT\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> NT\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 5. \\<And>x.\n       is_type P (Class x\\<lfloor>\\<rceil>) \\<Longrightarrow>\n       P \\<turnstile> Class x\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 6. \\<And>A.\n       \\<lbrakk>is_type P (A\\<lfloor>\\<rceil>) \\<Longrightarrow>\n                P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ Class Object;\n        is_type P (A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil> <\\<^sup>+ Class\n           Object", "hence \"is_class P C\""], ["proof (prove)\nusing this:\n  is_type P (Class C\\<lfloor>\\<rceil>)\n\ngoal (1 subgoal):\n 1. is_class P C", "by simp"], ["proof (state)\nthis:\n  is_class P C\n\ngoal (6 subgoals):\n 1. is_type P (Void\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Void\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 2. is_type P (Boolean\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Boolean\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 3. is_type P (Integer\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Integer\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 4. is_type P (NT\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> NT\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 5. \\<And>x.\n       is_type P (Class x\\<lfloor>\\<rceil>) \\<Longrightarrow>\n       P \\<turnstile> Class x\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 6. \\<And>A.\n       \\<lbrakk>is_type P (A\\<lfloor>\\<rceil>) \\<Longrightarrow>\n                P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ Class Object;\n        is_type P (A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil> <\\<^sup>+ Class\n           Object", "hence \"P \\<turnstile> C \\<preceq>\\<^sup>* Object\""], ["proof (prove)\nusing this:\n  is_class P C\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C \\<preceq>\\<^sup>* Object", "by(rule subcls_C_Object[OF _ wf])"], ["proof (state)\nthis:\n  P \\<turnstile> C \\<preceq>\\<^sup>* Object\n\ngoal (6 subgoals):\n 1. is_type P (Void\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Void\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 2. is_type P (Boolean\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Boolean\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 3. is_type P (Integer\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Integer\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 4. is_type P (NT\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> NT\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 5. \\<And>x.\n       is_type P (Class x\\<lfloor>\\<rceil>) \\<Longrightarrow>\n       P \\<turnstile> Class x\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 6. \\<And>A.\n       \\<lbrakk>is_type P (A\\<lfloor>\\<rceil>) \\<Longrightarrow>\n                P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ Class Object;\n        is_type P (A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil> <\\<^sup>+ Class\n           Object", "hence \"P \\<turnstile> Class C <\\<^sup>* Class Object\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* Object\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Class C <\\<^sup>* Class Object", "by(rule subcls_into_widen1_rtrancl)"], ["proof (state)\nthis:\n  P \\<turnstile> Class C <\\<^sup>* Class Object\n\ngoal (6 subgoals):\n 1. is_type P (Void\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Void\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 2. is_type P (Boolean\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Boolean\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 3. is_type P (Integer\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Integer\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 4. is_type P (NT\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> NT\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 5. \\<And>x.\n       is_type P (Class x\\<lfloor>\\<rceil>) \\<Longrightarrow>\n       P \\<turnstile> Class x\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 6. \\<And>A.\n       \\<lbrakk>is_type P (A\\<lfloor>\\<rceil>) \\<Longrightarrow>\n                P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ Class Object;\n        is_type P (A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil> <\\<^sup>+ Class\n           Object", "hence \"P \\<turnstile> Class C\\<lfloor>\\<rceil> <\\<^sup>* Class Object\\<lfloor>\\<rceil>\""], ["proof (prove)\nusing this:\n  P \\<turnstile> Class C <\\<^sup>* Class Object\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Class\n                    C\\<lfloor>\\<rceil> <\\<^sup>* Class\n            Object\\<lfloor>\\<rceil>", "by(rule widen1_rtrancl_into_Array_widen1_rtrancl) simp"], ["proof (state)\nthis:\n  P \\<turnstile> Class\n                  C\\<lfloor>\\<rceil> <\\<^sup>* Class Object\\<lfloor>\\<rceil>\n\ngoal (6 subgoals):\n 1. is_type P (Void\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Void\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 2. is_type P (Boolean\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Boolean\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 3. is_type P (Integer\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Integer\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 4. is_type P (NT\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> NT\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 5. \\<And>x.\n       is_type P (Class x\\<lfloor>\\<rceil>) \\<Longrightarrow>\n       P \\<turnstile> Class x\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 6. \\<And>A.\n       \\<lbrakk>is_type P (A\\<lfloor>\\<rceil>) \\<Longrightarrow>\n                P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ Class Object;\n        is_type P (A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil> <\\<^sup>+ Class\n           Object", "thus ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> Class\n                  C\\<lfloor>\\<rceil> <\\<^sup>* Class Object\\<lfloor>\\<rceil>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Class C\\<lfloor>\\<rceil> <\\<^sup>+ Class Object", "by(rule rtrancl_into_trancl1) simp"], ["proof (state)\nthis:\n  P \\<turnstile> Class C\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n\ngoal (5 subgoals):\n 1. is_type P (Void\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Void\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 2. is_type P (Boolean\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Boolean\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 3. is_type P (Integer\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Integer\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 4. is_type P (NT\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> NT\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 5. \\<And>A.\n       \\<lbrakk>is_type P (A\\<lfloor>\\<rceil>) \\<Longrightarrow>\n                P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ Class Object;\n        is_type P (A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil> <\\<^sup>+ Class\n           Object", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. is_type P (Void\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Void\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 2. is_type P (Boolean\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Boolean\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 3. is_type P (Integer\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Integer\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 4. is_type P (NT\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> NT\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 5. \\<And>A.\n       \\<lbrakk>is_type P (A\\<lfloor>\\<rceil>) \\<Longrightarrow>\n                P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ Class Object;\n        is_type P (A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil> <\\<^sup>+ Class\n           Object", "case (Array A)"], ["proof (state)\nthis:\n  is_type P (A\\<lfloor>\\<rceil>) \\<Longrightarrow>\n  P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n  is_type P (A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil>)\n\ngoal (5 subgoals):\n 1. is_type P (Void\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Void\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 2. is_type P (Boolean\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Boolean\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 3. is_type P (Integer\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Integer\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 4. is_type P (NT\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> NT\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 5. \\<And>A.\n       \\<lbrakk>is_type P (A\\<lfloor>\\<rceil>) \\<Longrightarrow>\n                P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ Class Object;\n        is_type P (A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil> <\\<^sup>+ Class\n           Object", "from \\<open>is_type P (A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil>)\\<close>"], ["proof (chain)\npicking this:\n  is_type P (A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil>)", "have \"is_type P (A\\<lfloor>\\<rceil>)\""], ["proof (prove)\nusing this:\n  is_type P (A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil>)\n\ngoal (1 subgoal):\n 1. is_type P (A\\<lfloor>\\<rceil>)", "by(rule is_type_ArrayD)"], ["proof (state)\nthis:\n  is_type P (A\\<lfloor>\\<rceil>)\n\ngoal (5 subgoals):\n 1. is_type P (Void\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Void\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 2. is_type P (Boolean\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Boolean\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 3. is_type P (Integer\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Integer\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 4. is_type P (NT\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> NT\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 5. \\<And>A.\n       \\<lbrakk>is_type P (A\\<lfloor>\\<rceil>) \\<Longrightarrow>\n                P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ Class Object;\n        is_type P (A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil> <\\<^sup>+ Class\n           Object", "hence \"P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\""], ["proof (prove)\nusing this:\n  is_type P (A\\<lfloor>\\<rceil>)\n\ngoal (1 subgoal):\n 1. P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ Class Object", "by(rule Array.IH)"], ["proof (state)\nthis:\n  P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n\ngoal (5 subgoals):\n 1. is_type P (Void\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Void\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 2. is_type P (Boolean\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Boolean\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 3. is_type P (Integer\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Integer\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 4. is_type P (NT\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> NT\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 5. \\<And>A.\n       \\<lbrakk>is_type P (A\\<lfloor>\\<rceil>) \\<Longrightarrow>\n                P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ Class Object;\n        is_type P (A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil> <\\<^sup>+ Class\n           Object", "moreover"], ["proof (state)\nthis:\n  P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n\ngoal (5 subgoals):\n 1. is_type P (Void\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Void\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 2. is_type P (Boolean\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Boolean\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 3. is_type P (Integer\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Integer\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 4. is_type P (NT\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> NT\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 5. \\<And>A.\n       \\<lbrakk>is_type P (A\\<lfloor>\\<rceil>) \\<Longrightarrow>\n                P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ Class Object;\n        is_type P (A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil> <\\<^sup>+ Class\n           Object", "from \\<open>is_type P (A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil>)\\<close>"], ["proof (chain)\npicking this:\n  is_type P (A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil>)", "have \"\\<not> is_NT_Array (A\\<lfloor>\\<rceil>)\""], ["proof (prove)\nusing this:\n  is_type P (A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil>)\n\ngoal (1 subgoal):\n 1. ground_type (A\\<lfloor>\\<rceil>) \\<noteq> NT", "by auto"], ["proof (state)\nthis:\n  ground_type (A\\<lfloor>\\<rceil>) \\<noteq> NT\n\ngoal (5 subgoals):\n 1. is_type P (Void\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Void\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 2. is_type P (Boolean\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Boolean\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 3. is_type P (Integer\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Integer\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 4. is_type P (NT\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> NT\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 5. \\<And>A.\n       \\<lbrakk>is_type P (A\\<lfloor>\\<rceil>) \\<Longrightarrow>\n                P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ Class Object;\n        is_type P (A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil> <\\<^sup>+ Class\n           Object", "ultimately"], ["proof (chain)\npicking this:\n  P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n  ground_type (A\\<lfloor>\\<rceil>) \\<noteq> NT", "have \"P \\<turnstile> A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\\<lfloor>\\<rceil>\""], ["proof (prove)\nusing this:\n  P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n  ground_type (A\\<lfloor>\\<rceil>) \\<noteq> NT\n\ngoal (1 subgoal):\n 1. P \\<turnstile> A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil> <\\<^sup>+ Class\n                            Object\\<lfloor>\\<rceil>", "by(rule widen1_trancl_into_Array_widen1_trancl)"], ["proof (state)\nthis:\n  P \\<turnstile> A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil> <\\<^sup>+ Class\n                          Object\\<lfloor>\\<rceil>\n\ngoal (5 subgoals):\n 1. is_type P (Void\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Void\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 2. is_type P (Boolean\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Boolean\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 3. is_type P (Integer\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Integer\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 4. is_type P (NT\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> NT\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 5. \\<And>A.\n       \\<lbrakk>is_type P (A\\<lfloor>\\<rceil>) \\<Longrightarrow>\n                P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ Class Object;\n        is_type P (A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil> <\\<^sup>+ Class\n           Object", "thus ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil> <\\<^sup>+ Class\n                          Object\\<lfloor>\\<rceil>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil> <\\<^sup>+ Class\n                            Object", "by(rule trancl_into_trancl) simp"], ["proof (state)\nthis:\n  P \\<turnstile> A\\<lfloor>\\<rceil>\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n\ngoal (4 subgoals):\n 1. is_type P (Void\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Void\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 2. is_type P (Boolean\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Boolean\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 3. is_type P (Integer\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> Integer\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n 4. is_type P (NT\\<lfloor>\\<rceil>) \\<Longrightarrow>\n    P \\<turnstile> NT\\<lfloor>\\<rceil> <\\<^sup>+ Class Object", "qed auto"], ["", "lemma widen_into_widen1_trancl:\n  assumes wf: \"wf_prog wfmd P\"\n  shows \"\\<lbrakk> P \\<turnstile> A \\<le> B; A \\<noteq> B; A \\<noteq> NT; is_type P A \\<rbrakk> \\<Longrightarrow> P \\<turnstile> A <\\<^sup>+ B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> A \\<le> B; A \\<noteq> B; A \\<noteq> NT;\n     is_type P A\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> A <\\<^sup>+ B", "proof(induct rule: widen.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>T.\n       \\<lbrakk>T \\<noteq> T; T \\<noteq> NT; is_type P T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> T <\\<^sup>+ T\n 2. \\<And>C D.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        Class C \\<noteq> Class D; Class C \\<noteq> NT;\n        is_type P (Class C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Class C <\\<^sup>+ Class D\n 3. \\<And>C.\n       \\<lbrakk>NT \\<noteq> Class C; NT \\<noteq> NT; is_type P NT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> NT <\\<^sup>+ Class C\n 4. \\<And>A.\n       \\<lbrakk>NT \\<noteq> A\\<lfloor>\\<rceil>; NT \\<noteq> NT;\n        is_type P NT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> NT <\\<^sup>+ A\\<lfloor>\\<rceil>\n 5. \\<And>A.\n       \\<lbrakk>A\\<lfloor>\\<rceil> \\<noteq> Class Object;\n        A\\<lfloor>\\<rceil> \\<noteq> NT;\n        is_type P (A\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ Class\n                                Object\n 6. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        \\<lbrakk>A \\<noteq> B; A \\<noteq> NT; is_type P A\\<rbrakk>\n        \\<Longrightarrow> P \\<turnstile> A <\\<^sup>+ B;\n        A\\<lfloor>\\<rceil> \\<noteq> B\\<lfloor>\\<rceil>;\n        A\\<lfloor>\\<rceil> \\<noteq> NT;\n        is_type P (A\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ B\\<lfloor>\\<rceil>", "case (widen_subcls C D)"], ["proof (state)\nthis:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  Class C \\<noteq> Class D\n  Class C \\<noteq> NT\n  is_type P (Class C)\n\ngoal (6 subgoals):\n 1. \\<And>T.\n       \\<lbrakk>T \\<noteq> T; T \\<noteq> NT; is_type P T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> T <\\<^sup>+ T\n 2. \\<And>C D.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        Class C \\<noteq> Class D; Class C \\<noteq> NT;\n        is_type P (Class C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Class C <\\<^sup>+ Class D\n 3. \\<And>C.\n       \\<lbrakk>NT \\<noteq> Class C; NT \\<noteq> NT; is_type P NT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> NT <\\<^sup>+ Class C\n 4. \\<And>A.\n       \\<lbrakk>NT \\<noteq> A\\<lfloor>\\<rceil>; NT \\<noteq> NT;\n        is_type P NT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> NT <\\<^sup>+ A\\<lfloor>\\<rceil>\n 5. \\<And>A.\n       \\<lbrakk>A\\<lfloor>\\<rceil> \\<noteq> Class Object;\n        A\\<lfloor>\\<rceil> \\<noteq> NT;\n        is_type P (A\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ Class\n                                Object\n 6. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        \\<lbrakk>A \\<noteq> B; A \\<noteq> NT; is_type P A\\<rbrakk>\n        \\<Longrightarrow> P \\<turnstile> A <\\<^sup>+ B;\n        A\\<lfloor>\\<rceil> \\<noteq> B\\<lfloor>\\<rceil>;\n        A\\<lfloor>\\<rceil> \\<noteq> NT;\n        is_type P (A\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ B\\<lfloor>\\<rceil>", "from \\<open>Class C \\<noteq> Class D\\<close> \\<open>P \\<turnstile> C \\<preceq>\\<^sup>* D\\<close>"], ["proof (chain)\npicking this:\n  Class C \\<noteq> Class D\n  P \\<turnstile> C \\<preceq>\\<^sup>* D", "have \"(subcls1 P)\\<^sup>+\\<^sup>+ C D\""], ["proof (prove)\nusing this:\n  Class C \\<noteq> Class D\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. (subcls1 P)\\<^sup>+\\<^sup>+ C D", "by(auto elim: rtranclp.cases intro: rtranclp_into_tranclp1)"], ["proof (state)\nthis:\n  (subcls1 P)\\<^sup>+\\<^sup>+ C D\n\ngoal (6 subgoals):\n 1. \\<And>T.\n       \\<lbrakk>T \\<noteq> T; T \\<noteq> NT; is_type P T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> T <\\<^sup>+ T\n 2. \\<And>C D.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        Class C \\<noteq> Class D; Class C \\<noteq> NT;\n        is_type P (Class C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Class C <\\<^sup>+ Class D\n 3. \\<And>C.\n       \\<lbrakk>NT \\<noteq> Class C; NT \\<noteq> NT; is_type P NT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> NT <\\<^sup>+ Class C\n 4. \\<And>A.\n       \\<lbrakk>NT \\<noteq> A\\<lfloor>\\<rceil>; NT \\<noteq> NT;\n        is_type P NT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> NT <\\<^sup>+ A\\<lfloor>\\<rceil>\n 5. \\<And>A.\n       \\<lbrakk>A\\<lfloor>\\<rceil> \\<noteq> Class Object;\n        A\\<lfloor>\\<rceil> \\<noteq> NT;\n        is_type P (A\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ Class\n                                Object\n 6. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        \\<lbrakk>A \\<noteq> B; A \\<noteq> NT; is_type P A\\<rbrakk>\n        \\<Longrightarrow> P \\<turnstile> A <\\<^sup>+ B;\n        A\\<lfloor>\\<rceil> \\<noteq> B\\<lfloor>\\<rceil>;\n        A\\<lfloor>\\<rceil> \\<noteq> NT;\n        is_type P (A\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ B\\<lfloor>\\<rceil>", "thus ?case"], ["proof (prove)\nusing this:\n  (subcls1 P)\\<^sup>+\\<^sup>+ C D\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Class C <\\<^sup>+ Class D", "by(rule subcls1_trancl_widen1_trancl)"], ["proof (state)\nthis:\n  P \\<turnstile> Class C <\\<^sup>+ Class D\n\ngoal (5 subgoals):\n 1. \\<And>T.\n       \\<lbrakk>T \\<noteq> T; T \\<noteq> NT; is_type P T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> T <\\<^sup>+ T\n 2. \\<And>C.\n       \\<lbrakk>NT \\<noteq> Class C; NT \\<noteq> NT; is_type P NT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> NT <\\<^sup>+ Class C\n 3. \\<And>A.\n       \\<lbrakk>NT \\<noteq> A\\<lfloor>\\<rceil>; NT \\<noteq> NT;\n        is_type P NT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> NT <\\<^sup>+ A\\<lfloor>\\<rceil>\n 4. \\<And>A.\n       \\<lbrakk>A\\<lfloor>\\<rceil> \\<noteq> Class Object;\n        A\\<lfloor>\\<rceil> \\<noteq> NT;\n        is_type P (A\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ Class\n                                Object\n 5. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        \\<lbrakk>A \\<noteq> B; A \\<noteq> NT; is_type P A\\<rbrakk>\n        \\<Longrightarrow> P \\<turnstile> A <\\<^sup>+ B;\n        A\\<lfloor>\\<rceil> \\<noteq> B\\<lfloor>\\<rceil>;\n        A\\<lfloor>\\<rceil> \\<noteq> NT;\n        is_type P (A\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ B\\<lfloor>\\<rceil>", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>T.\n       \\<lbrakk>T \\<noteq> T; T \\<noteq> NT; is_type P T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> T <\\<^sup>+ T\n 2. \\<And>C.\n       \\<lbrakk>NT \\<noteq> Class C; NT \\<noteq> NT; is_type P NT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> NT <\\<^sup>+ Class C\n 3. \\<And>A.\n       \\<lbrakk>NT \\<noteq> A\\<lfloor>\\<rceil>; NT \\<noteq> NT;\n        is_type P NT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> NT <\\<^sup>+ A\\<lfloor>\\<rceil>\n 4. \\<And>A.\n       \\<lbrakk>A\\<lfloor>\\<rceil> \\<noteq> Class Object;\n        A\\<lfloor>\\<rceil> \\<noteq> NT;\n        is_type P (A\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ Class\n                                Object\n 5. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        \\<lbrakk>A \\<noteq> B; A \\<noteq> NT; is_type P A\\<rbrakk>\n        \\<Longrightarrow> P \\<turnstile> A <\\<^sup>+ B;\n        A\\<lfloor>\\<rceil> \\<noteq> B\\<lfloor>\\<rceil>;\n        A\\<lfloor>\\<rceil> \\<noteq> NT;\n        is_type P (A\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ B\\<lfloor>\\<rceil>", "case widen_array_object"], ["proof (state)\nthis:\n  A_\\<lfloor>\\<rceil> \\<noteq> Class Object\n  A_\\<lfloor>\\<rceil> \\<noteq> NT\n  is_type P (A_\\<lfloor>\\<rceil>)\n\ngoal (5 subgoals):\n 1. \\<And>T.\n       \\<lbrakk>T \\<noteq> T; T \\<noteq> NT; is_type P T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> T <\\<^sup>+ T\n 2. \\<And>C.\n       \\<lbrakk>NT \\<noteq> Class C; NT \\<noteq> NT; is_type P NT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> NT <\\<^sup>+ Class C\n 3. \\<And>A.\n       \\<lbrakk>NT \\<noteq> A\\<lfloor>\\<rceil>; NT \\<noteq> NT;\n        is_type P NT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> NT <\\<^sup>+ A\\<lfloor>\\<rceil>\n 4. \\<And>A.\n       \\<lbrakk>A\\<lfloor>\\<rceil> \\<noteq> Class Object;\n        A\\<lfloor>\\<rceil> \\<noteq> NT;\n        is_type P (A\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ Class\n                                Object\n 5. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        \\<lbrakk>A \\<noteq> B; A \\<noteq> NT; is_type P A\\<rbrakk>\n        \\<Longrightarrow> P \\<turnstile> A <\\<^sup>+ B;\n        A\\<lfloor>\\<rceil> \\<noteq> B\\<lfloor>\\<rceil>;\n        A\\<lfloor>\\<rceil> \\<noteq> NT;\n        is_type P (A\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ B\\<lfloor>\\<rceil>", "thus ?case"], ["proof (prove)\nusing this:\n  A_\\<lfloor>\\<rceil> \\<noteq> Class Object\n  A_\\<lfloor>\\<rceil> \\<noteq> NT\n  is_type P (A_\\<lfloor>\\<rceil>)\n\ngoal (1 subgoal):\n 1. P \\<turnstile> A_\\<lfloor>\\<rceil> <\\<^sup>+ Class Object", "by(auto intro: Array_Object_widen1_trancl[OF wf])"], ["proof (state)\nthis:\n  P \\<turnstile> A_\\<lfloor>\\<rceil> <\\<^sup>+ Class Object\n\ngoal (4 subgoals):\n 1. \\<And>T.\n       \\<lbrakk>T \\<noteq> T; T \\<noteq> NT; is_type P T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> T <\\<^sup>+ T\n 2. \\<And>C.\n       \\<lbrakk>NT \\<noteq> Class C; NT \\<noteq> NT; is_type P NT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> NT <\\<^sup>+ Class C\n 3. \\<And>A.\n       \\<lbrakk>NT \\<noteq> A\\<lfloor>\\<rceil>; NT \\<noteq> NT;\n        is_type P NT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> NT <\\<^sup>+ A\\<lfloor>\\<rceil>\n 4. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        \\<lbrakk>A \\<noteq> B; A \\<noteq> NT; is_type P A\\<rbrakk>\n        \\<Longrightarrow> P \\<turnstile> A <\\<^sup>+ B;\n        A\\<lfloor>\\<rceil> \\<noteq> B\\<lfloor>\\<rceil>;\n        A\\<lfloor>\\<rceil> \\<noteq> NT;\n        is_type P (A\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ B\\<lfloor>\\<rceil>", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>T.\n       \\<lbrakk>T \\<noteq> T; T \\<noteq> NT; is_type P T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> T <\\<^sup>+ T\n 2. \\<And>C.\n       \\<lbrakk>NT \\<noteq> Class C; NT \\<noteq> NT; is_type P NT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> NT <\\<^sup>+ Class C\n 3. \\<And>A.\n       \\<lbrakk>NT \\<noteq> A\\<lfloor>\\<rceil>; NT \\<noteq> NT;\n        is_type P NT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> NT <\\<^sup>+ A\\<lfloor>\\<rceil>\n 4. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        \\<lbrakk>A \\<noteq> B; A \\<noteq> NT; is_type P A\\<rbrakk>\n        \\<Longrightarrow> P \\<turnstile> A <\\<^sup>+ B;\n        A\\<lfloor>\\<rceil> \\<noteq> B\\<lfloor>\\<rceil>;\n        A\\<lfloor>\\<rceil> \\<noteq> NT;\n        is_type P (A\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ B\\<lfloor>\\<rceil>", "case (widen_array_array A B)"], ["proof (state)\nthis:\n  P \\<turnstile> A \\<le> B\n  \\<lbrakk>A \\<noteq> B; A \\<noteq> NT; is_type P A\\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> A <\\<^sup>+ B\n  A\\<lfloor>\\<rceil> \\<noteq> B\\<lfloor>\\<rceil>\n  A\\<lfloor>\\<rceil> \\<noteq> NT\n  is_type P (A\\<lfloor>\\<rceil>)\n\ngoal (4 subgoals):\n 1. \\<And>T.\n       \\<lbrakk>T \\<noteq> T; T \\<noteq> NT; is_type P T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> T <\\<^sup>+ T\n 2. \\<And>C.\n       \\<lbrakk>NT \\<noteq> Class C; NT \\<noteq> NT; is_type P NT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> NT <\\<^sup>+ Class C\n 3. \\<And>A.\n       \\<lbrakk>NT \\<noteq> A\\<lfloor>\\<rceil>; NT \\<noteq> NT;\n        is_type P NT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> NT <\\<^sup>+ A\\<lfloor>\\<rceil>\n 4. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        \\<lbrakk>A \\<noteq> B; A \\<noteq> NT; is_type P A\\<rbrakk>\n        \\<Longrightarrow> P \\<turnstile> A <\\<^sup>+ B;\n        A\\<lfloor>\\<rceil> \\<noteq> B\\<lfloor>\\<rceil>;\n        A\\<lfloor>\\<rceil> \\<noteq> NT;\n        is_type P (A\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ B\\<lfloor>\\<rceil>", "hence \"P \\<turnstile> A <\\<^sup>+ B\""], ["proof (prove)\nusing this:\n  P \\<turnstile> A \\<le> B\n  \\<lbrakk>A \\<noteq> B; A \\<noteq> NT; is_type P A\\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> A <\\<^sup>+ B\n  A\\<lfloor>\\<rceil> \\<noteq> B\\<lfloor>\\<rceil>\n  A\\<lfloor>\\<rceil> \\<noteq> NT\n  is_type P (A\\<lfloor>\\<rceil>)\n\ngoal (1 subgoal):\n 1. P \\<turnstile> A <\\<^sup>+ B", "by(cases A) auto"], ["proof (state)\nthis:\n  P \\<turnstile> A <\\<^sup>+ B\n\ngoal (4 subgoals):\n 1. \\<And>T.\n       \\<lbrakk>T \\<noteq> T; T \\<noteq> NT; is_type P T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> T <\\<^sup>+ T\n 2. \\<And>C.\n       \\<lbrakk>NT \\<noteq> Class C; NT \\<noteq> NT; is_type P NT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> NT <\\<^sup>+ Class C\n 3. \\<And>A.\n       \\<lbrakk>NT \\<noteq> A\\<lfloor>\\<rceil>; NT \\<noteq> NT;\n        is_type P NT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> NT <\\<^sup>+ A\\<lfloor>\\<rceil>\n 4. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        \\<lbrakk>A \\<noteq> B; A \\<noteq> NT; is_type P A\\<rbrakk>\n        \\<Longrightarrow> P \\<turnstile> A <\\<^sup>+ B;\n        A\\<lfloor>\\<rceil> \\<noteq> B\\<lfloor>\\<rceil>;\n        A\\<lfloor>\\<rceil> \\<noteq> NT;\n        is_type P (A\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ B\\<lfloor>\\<rceil>", "with \\<open>is_type P (A\\<lfloor>\\<rceil>)\\<close>"], ["proof (chain)\npicking this:\n  is_type P (A\\<lfloor>\\<rceil>)\n  P \\<turnstile> A <\\<^sup>+ B", "show ?case"], ["proof (prove)\nusing this:\n  is_type P (A\\<lfloor>\\<rceil>)\n  P \\<turnstile> A <\\<^sup>+ B\n\ngoal (1 subgoal):\n 1. P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ B\\<lfloor>\\<rceil>", "by(auto intro: widen1_trancl_into_Array_widen1_trancl)"], ["proof (state)\nthis:\n  P \\<turnstile> A\\<lfloor>\\<rceil> <\\<^sup>+ B\\<lfloor>\\<rceil>\n\ngoal (3 subgoals):\n 1. \\<And>T.\n       \\<lbrakk>T \\<noteq> T; T \\<noteq> NT; is_type P T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> T <\\<^sup>+ T\n 2. \\<And>C.\n       \\<lbrakk>NT \\<noteq> Class C; NT \\<noteq> NT; is_type P NT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> NT <\\<^sup>+ Class C\n 3. \\<And>A.\n       \\<lbrakk>NT \\<noteq> A\\<lfloor>\\<rceil>; NT \\<noteq> NT;\n        is_type P NT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> NT <\\<^sup>+ A\\<lfloor>\\<rceil>", "qed(auto)"], ["", "lemma wf_prog_impl_acc_widen:\n  assumes wfP: \"wf_prog wfmd P\"\n  shows \"acc (types P) (widen P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acc (types P) (widen P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. acc (types P) (widen P)", "from wf_converse_widen1[OF wfP]"], ["proof (chain)\npicking this:\n  wf ((widen1 P)\\<inverse>)", "have \"wf (((widen1 P)^-1)^+)\""], ["proof (prove)\nusing this:\n  wf ((widen1 P)\\<inverse>)\n\ngoal (1 subgoal):\n 1. wf (((widen1 P)\\<inverse>)\\<^sup>+)", "by(rule wf_trancl)"], ["proof (state)\nthis:\n  wf (((widen1 P)\\<inverse>)\\<^sup>+)\n\ngoal (1 subgoal):\n 1. acc (types P) (widen P)", "hence wfw1t: \"\\<And>M T. T \\<in> M \\<Longrightarrow> (\\<exists>z\\<in>M. \\<forall>y. (y, z) \\<in> ((widen1 P)\\<inverse>)\\<^sup>+ \\<longrightarrow> y \\<notin> M)\""], ["proof (prove)\nusing this:\n  wf (((widen1 P)\\<inverse>)\\<^sup>+)\n\ngoal (1 subgoal):\n 1. \\<And>M T.\n       T \\<in> M \\<Longrightarrow>\n       \\<exists>z\\<in>M.\n          \\<forall>y.\n             (y, z) \\<in> ((widen1 P)\\<inverse>)\\<^sup>+ \\<longrightarrow>\n             y \\<notin> M", "by(auto simp only: wf_eq_minimal)"], ["proof (state)\nthis:\n  ?T \\<in> ?M \\<Longrightarrow>\n  \\<exists>z\\<in>?M.\n     \\<forall>y.\n        (y, z) \\<in> ((widen1 P)\\<inverse>)\\<^sup>+ \\<longrightarrow>\n        y \\<notin> ?M\n\ngoal (1 subgoal):\n 1. acc (types P) (widen P)", "have \"wf {(y, x). is_type P x \\<and> is_type P y \\<and> widen P x y \\<and> x \\<noteq> y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(y, x).\n        is_type P x \\<and>\n        is_type P y \\<and> P \\<turnstile> x \\<le> y \\<and> x \\<noteq> y}", "unfolding wf_eq_minimal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              (y, z)\n              \\<in> {(y, x).\n                     is_type P x \\<and>\n                     is_type P y \\<and>\n                     P \\<turnstile> x \\<le> y \\<and>\n                     x \\<noteq> y} \\<longrightarrow>\n              y \\<notin> Q)", "proof(intro strip)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       x \\<in> Q \\<Longrightarrow>\n       \\<exists>z\\<in>Q.\n          \\<forall>y.\n             (y, z)\n             \\<in> {(y, x).\n                    is_type P x \\<and>\n                    is_type P y \\<and>\n                    P \\<turnstile> x \\<le> y \\<and>\n                    x \\<noteq> y} \\<longrightarrow>\n             y \\<notin> Q", "fix M and T :: ty"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       x \\<in> Q \\<Longrightarrow>\n       \\<exists>z\\<in>Q.\n          \\<forall>y.\n             (y, z)\n             \\<in> {(y, x).\n                    is_type P x \\<and>\n                    is_type P y \\<and>\n                    P \\<turnstile> x \\<le> y \\<and>\n                    x \\<noteq> y} \\<longrightarrow>\n             y \\<notin> Q", "assume TM: \"T \\<in> M\""], ["proof (state)\nthis:\n  T \\<in> M\n\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       x \\<in> Q \\<Longrightarrow>\n       \\<exists>z\\<in>Q.\n          \\<forall>y.\n             (y, z)\n             \\<in> {(y, x).\n                    is_type P x \\<and>\n                    is_type P y \\<and>\n                    P \\<turnstile> x \\<le> y \\<and>\n                    x \\<noteq> y} \\<longrightarrow>\n             y \\<notin> Q", "show \"\\<exists>z\\<in>M. \\<forall>y. (y, z) \\<in> {(y, T). is_type P T \\<and> is_type P y \\<and> widen P T y \\<and> T \\<noteq> y} \\<longrightarrow> y \\<notin> M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M", "proof(cases \"(\\<exists>C. Class C \\<in> M \\<and> is_class P C) \\<or> (\\<exists>U. U\\<lfloor>\\<rceil> \\<in> M \\<and> is_type P (U\\<lfloor>\\<rceil>))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<exists>C. Class C \\<in> M \\<and> is_class P C) \\<or>\n    (\\<exists>U.\n        U\\<lfloor>\\<rceil> \\<in> M \\<and>\n        is_type P (U\\<lfloor>\\<rceil>)) \\<Longrightarrow>\n    \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M\n 2. \\<not> ((\\<exists>C. Class C \\<in> M \\<and> is_class P C) \\<or>\n            (\\<exists>U.\n                U\\<lfloor>\\<rceil> \\<in> M \\<and>\n                is_type P (U\\<lfloor>\\<rceil>))) \\<Longrightarrow>\n    \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M", "case True"], ["proof (state)\nthis:\n  (\\<exists>C. Class C \\<in> M \\<and> is_class P C) \\<or>\n  (\\<exists>U.\n      U\\<lfloor>\\<rceil> \\<in> M \\<and> is_type P (U\\<lfloor>\\<rceil>))\n\ngoal (2 subgoals):\n 1. (\\<exists>C. Class C \\<in> M \\<and> is_class P C) \\<or>\n    (\\<exists>U.\n        U\\<lfloor>\\<rceil> \\<in> M \\<and>\n        is_type P (U\\<lfloor>\\<rceil>)) \\<Longrightarrow>\n    \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M\n 2. \\<not> ((\\<exists>C. Class C \\<in> M \\<and> is_class P C) \\<or>\n            (\\<exists>U.\n                U\\<lfloor>\\<rceil> \\<in> M \\<and>\n                is_type P (U\\<lfloor>\\<rceil>))) \\<Longrightarrow>\n    \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M", "have BNTthesis: \"\\<And>B. \\<lbrakk> B \\<in> (M \\<inter> types P) - {NT} \\<rbrakk> \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B.\n       B \\<in> M \\<inter> types P - {NT} \\<Longrightarrow>\n       \\<exists>z\\<in>M.\n          \\<forall>y.\n             (y, z)\n             \\<in> {(y, T).\n                    is_type P T \\<and>\n                    is_type P y \\<and>\n                    P \\<turnstile> T \\<le> y \\<and>\n                    T \\<noteq> y} \\<longrightarrow>\n             y \\<notin> M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B.\n       B \\<in> M \\<inter> types P - {NT} \\<Longrightarrow>\n       \\<exists>z\\<in>M.\n          \\<forall>y.\n             (y, z)\n             \\<in> {(y, T).\n                    is_type P T \\<and>\n                    is_type P y \\<and>\n                    P \\<turnstile> T \\<le> y \\<and>\n                    T \\<noteq> y} \\<longrightarrow>\n             y \\<notin> M", "fix B"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B.\n       B \\<in> M \\<inter> types P - {NT} \\<Longrightarrow>\n       \\<exists>z\\<in>M.\n          \\<forall>y.\n             (y, z)\n             \\<in> {(y, T).\n                    is_type P T \\<and>\n                    is_type P y \\<and>\n                    P \\<turnstile> T \\<le> y \\<and>\n                    T \\<noteq> y} \\<longrightarrow>\n             y \\<notin> M", "assume BM: \"B \\<in> M \\<inter> types P - {NT}\""], ["proof (state)\nthis:\n  B \\<in> M \\<inter> types P - {NT}\n\ngoal (1 subgoal):\n 1. \\<And>B.\n       B \\<in> M \\<inter> types P - {NT} \\<Longrightarrow>\n       \\<exists>z\\<in>M.\n          \\<forall>y.\n             (y, z)\n             \\<in> {(y, T).\n                    is_type P T \\<and>\n                    is_type P y \\<and>\n                    P \\<turnstile> T \\<le> y \\<and>\n                    T \\<noteq> y} \\<longrightarrow>\n             y \\<notin> M", "from wfw1t[OF BM]"], ["proof (chain)\npicking this:\n  \\<exists>z\\<in>M \\<inter> types P - {NT}.\n     \\<forall>y.\n        (y, z) \\<in> ((widen1 P)\\<inverse>)\\<^sup>+ \\<longrightarrow>\n        y \\<notin> M \\<inter> types P - {NT}", "obtain z\n          where zM: \"z \\<in> M\"\n          and znnt: \"z \\<noteq> NT\"\n          and itz: \"is_type P z\"\n          and y: \"\\<And>y. (y, z) \\<in> ((widen1 P)\\<inverse>)\\<^sup>+ \\<Longrightarrow> y \\<notin> M \\<inter> types P - {NT}\""], ["proof (prove)\nusing this:\n  \\<exists>z\\<in>M \\<inter> types P - {NT}.\n     \\<forall>y.\n        (y, z) \\<in> ((widen1 P)\\<inverse>)\\<^sup>+ \\<longrightarrow>\n        y \\<notin> M \\<inter> types P - {NT}\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> M; z \\<noteq> NT; is_type P z;\n         \\<And>y.\n            (y, z) \\<in> ((widen1 P)\\<inverse>)\\<^sup>+ \\<Longrightarrow>\n            y \\<notin> M \\<inter> types P - {NT}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  z \\<in> M\n  z \\<noteq> NT\n  is_type P z\n  (?y, z) \\<in> ((widen1 P)\\<inverse>)\\<^sup>+ \\<Longrightarrow>\n  ?y \\<notin> M \\<inter> types P - {NT}\n\ngoal (1 subgoal):\n 1. \\<And>B.\n       B \\<in> M \\<inter> types P - {NT} \\<Longrightarrow>\n       \\<exists>z\\<in>M.\n          \\<forall>y.\n             (y, z)\n             \\<in> {(y, T).\n                    is_type P T \\<and>\n                    is_type P y \\<and>\n                    P \\<turnstile> T \\<le> y \\<and>\n                    T \\<noteq> y} \\<longrightarrow>\n             y \\<notin> M", "show \"?thesis B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M", "proof(rule bexI[OF _ zM], rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       (y, z)\n       \\<in> {(y, T).\n              is_type P T \\<and>\n              is_type P y \\<and>\n              P \\<turnstile> T \\<le> y \\<and>\n              T \\<noteq> y} \\<Longrightarrow>\n       y \\<notin> M", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       (y, z)\n       \\<in> {(y, T).\n              is_type P T \\<and>\n              is_type P y \\<and>\n              P \\<turnstile> T \\<le> y \\<and>\n              T \\<noteq> y} \\<Longrightarrow>\n       y \\<notin> M", "assume \"(y, z) \\<in> {(y, T). is_type P T \\<and> is_type P y \\<and> widen P T y \\<and> T \\<noteq> y}\""], ["proof (state)\nthis:\n  (y, z)\n  \\<in> {(y, T).\n         is_type P T \\<and>\n         is_type P y \\<and> P \\<turnstile> T \\<le> y \\<and> T \\<noteq> y}\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       (y, z)\n       \\<in> {(y, T).\n              is_type P T \\<and>\n              is_type P y \\<and>\n              P \\<turnstile> T \\<le> y \\<and>\n              T \\<noteq> y} \\<Longrightarrow>\n       y \\<notin> M", "hence Pzy: \"P \\<turnstile> z \\<le> y\" and zy: \"z \\<noteq> y\" and \"is_type P y\""], ["proof (prove)\nusing this:\n  (y, z)\n  \\<in> {(y, T).\n         is_type P T \\<and>\n         is_type P y \\<and> P \\<turnstile> T \\<le> y \\<and> T \\<noteq> y}\n\ngoal (1 subgoal):\n 1. P \\<turnstile> z \\<le> y &&& z \\<noteq> y &&& is_type P y", "by auto"], ["proof (state)\nthis:\n  P \\<turnstile> z \\<le> y\n  z \\<noteq> y\n  is_type P y\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       (y, z)\n       \\<in> {(y, T).\n              is_type P T \\<and>\n              is_type P y \\<and>\n              P \\<turnstile> T \\<le> y \\<and>\n              T \\<noteq> y} \\<Longrightarrow>\n       y \\<notin> M", "hence \"P \\<turnstile> z <\\<^sup>+ y\""], ["proof (prove)\nusing this:\n  P \\<turnstile> z \\<le> y\n  z \\<noteq> y\n  is_type P y\n\ngoal (1 subgoal):\n 1. P \\<turnstile> z <\\<^sup>+ y", "using znnt itz"], ["proof (prove)\nusing this:\n  P \\<turnstile> z \\<le> y\n  z \\<noteq> y\n  is_type P y\n  z \\<noteq> NT\n  is_type P z\n\ngoal (1 subgoal):\n 1. P \\<turnstile> z <\\<^sup>+ y", "by -(rule widen_into_widen1_trancl[OF wfP])"], ["proof (state)\nthis:\n  P \\<turnstile> z <\\<^sup>+ y\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       (y, z)\n       \\<in> {(y, T).\n              is_type P T \\<and>\n              is_type P y \\<and>\n              P \\<turnstile> T \\<le> y \\<and>\n              T \\<noteq> y} \\<Longrightarrow>\n       y \\<notin> M", "hence ynM: \"y \\<notin> M \\<inter> types P - {NT}\""], ["proof (prove)\nusing this:\n  P \\<turnstile> z <\\<^sup>+ y\n\ngoal (1 subgoal):\n 1. y \\<notin> M \\<inter> types P - {NT}", "by -(rule y, simp add: trancl_converse)"], ["proof (state)\nthis:\n  y \\<notin> M \\<inter> types P - {NT}\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       (y, z)\n       \\<in> {(y, T).\n              is_type P T \\<and>\n              is_type P y \\<and>\n              P \\<turnstile> T \\<le> y \\<and>\n              T \\<noteq> y} \\<Longrightarrow>\n       y \\<notin> M", "thus \"y \\<notin> M\""], ["proof (prove)\nusing this:\n  y \\<notin> M \\<inter> types P - {NT}\n\ngoal (1 subgoal):\n 1. y \\<notin> M", "using Pzy znnt \\<open>is_type P y\\<close>"], ["proof (prove)\nusing this:\n  y \\<notin> M \\<inter> types P - {NT}\n  P \\<turnstile> z \\<le> y\n  z \\<noteq> NT\n  is_type P y\n\ngoal (1 subgoal):\n 1. y \\<notin> M", "by auto"], ["proof (state)\nthis:\n  y \\<notin> M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>z\\<in>M.\n     \\<forall>y.\n        (y, z)\n        \\<in> {(y, T).\n               is_type P T \\<and>\n               is_type P y \\<and>\n               P \\<turnstile> T \\<le> y \\<and>\n               T \\<noteq> y} \\<longrightarrow>\n        y \\<notin> M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?B \\<in> M \\<inter> types P - {NT} \\<Longrightarrow>\n  \\<exists>z\\<in>M.\n     \\<forall>y.\n        (y, z)\n        \\<in> {(y, T).\n               is_type P T \\<and>\n               is_type P y \\<and>\n               P \\<turnstile> T \\<le> y \\<and>\n               T \\<noteq> y} \\<longrightarrow>\n        y \\<notin> M\n\ngoal (2 subgoals):\n 1. (\\<exists>C. Class C \\<in> M \\<and> is_class P C) \\<or>\n    (\\<exists>U.\n        U\\<lfloor>\\<rceil> \\<in> M \\<and>\n        is_type P (U\\<lfloor>\\<rceil>)) \\<Longrightarrow>\n    \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M\n 2. \\<not> ((\\<exists>C. Class C \\<in> M \\<and> is_class P C) \\<or>\n            (\\<exists>U.\n                U\\<lfloor>\\<rceil> \\<in> M \\<and>\n                is_type P (U\\<lfloor>\\<rceil>))) \\<Longrightarrow>\n    \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M", "from True"], ["proof (chain)\npicking this:\n  (\\<exists>C. Class C \\<in> M \\<and> is_class P C) \\<or>\n  (\\<exists>U.\n      U\\<lfloor>\\<rceil> \\<in> M \\<and> is_type P (U\\<lfloor>\\<rceil>))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<exists>C. Class C \\<in> M \\<and> is_class P C) \\<or>\n  (\\<exists>U.\n      U\\<lfloor>\\<rceil> \\<in> M \\<and> is_type P (U\\<lfloor>\\<rceil>))\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M", "by(fastforce intro: BNTthesis)"], ["proof (state)\nthis:\n  \\<exists>z\\<in>M.\n     \\<forall>y.\n        (y, z)\n        \\<in> {(y, T).\n               is_type P T \\<and>\n               is_type P y \\<and>\n               P \\<turnstile> T \\<le> y \\<and>\n               T \\<noteq> y} \\<longrightarrow>\n        y \\<notin> M\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>C. Class C \\<in> M \\<and> is_class P C) \\<or>\n            (\\<exists>U.\n                U\\<lfloor>\\<rceil> \\<in> M \\<and>\n                is_type P (U\\<lfloor>\\<rceil>))) \\<Longrightarrow>\n    \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>C. Class C \\<in> M \\<and> is_class P C) \\<or>\n            (\\<exists>U.\n                U\\<lfloor>\\<rceil> \\<in> M \\<and>\n                is_type P (U\\<lfloor>\\<rceil>))) \\<Longrightarrow>\n    \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M", "case False"], ["proof (state)\nthis:\n  \\<not> ((\\<exists>C. Class C \\<in> M \\<and> is_class P C) \\<or>\n          (\\<exists>U.\n              U\\<lfloor>\\<rceil> \\<in> M \\<and>\n              is_type P (U\\<lfloor>\\<rceil>)))\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>C. Class C \\<in> M \\<and> is_class P C) \\<or>\n            (\\<exists>U.\n                U\\<lfloor>\\<rceil> \\<in> M \\<and>\n                is_type P (U\\<lfloor>\\<rceil>))) \\<Longrightarrow>\n    \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M", "hence not_is_class: \"\\<And>C. Class C \\<in> M \\<Longrightarrow> \\<not> is_class P C\"\n        and not_is_array: \"\\<And>U. U\\<lfloor>\\<rceil> \\<in> M \\<Longrightarrow> \\<not> is_type P (U\\<lfloor>\\<rceil>)\""], ["proof (prove)\nusing this:\n  \\<not> ((\\<exists>C. Class C \\<in> M \\<and> is_class P C) \\<or>\n          (\\<exists>U.\n              U\\<lfloor>\\<rceil> \\<in> M \\<and>\n              is_type P (U\\<lfloor>\\<rceil>)))\n\ngoal (1 subgoal):\n 1. (\\<And>C. Class C \\<in> M \\<Longrightarrow> \\<not> is_class P C) &&&\n    (\\<And>U.\n        U\\<lfloor>\\<rceil> \\<in> M \\<Longrightarrow>\n        \\<not> is_type P (U\\<lfloor>\\<rceil>))", "by simp_all"], ["proof (state)\nthis:\n  Class ?C \\<in> M \\<Longrightarrow> \\<not> is_class P ?C\n  ?U\\<lfloor>\\<rceil> \\<in> M \\<Longrightarrow>\n  \\<not> is_type P (?U\\<lfloor>\\<rceil>)\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>C. Class C \\<in> M \\<and> is_class P C) \\<or>\n            (\\<exists>U.\n                U\\<lfloor>\\<rceil> \\<in> M \\<and>\n                is_type P (U\\<lfloor>\\<rceil>))) \\<Longrightarrow>\n    \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M", "proof(cases \"\\<exists>C. Class C \\<in> M\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>C. Class C \\<in> M \\<Longrightarrow>\n    \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M\n 2. \\<nexists>C. Class C \\<in> M \\<Longrightarrow>\n    \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M", "case True"], ["proof (state)\nthis:\n  \\<exists>C. Class C \\<in> M\n\ngoal (2 subgoals):\n 1. \\<exists>C. Class C \\<in> M \\<Longrightarrow>\n    \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M\n 2. \\<nexists>C. Class C \\<in> M \\<Longrightarrow>\n    \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M", "then"], ["proof (chain)\npicking this:\n  \\<exists>C. Class C \\<in> M", "obtain C where \"Class C \\<in> M\""], ["proof (prove)\nusing this:\n  \\<exists>C. Class C \\<in> M\n\ngoal (1 subgoal):\n 1. (\\<And>C. Class C \\<in> M \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  Class C \\<in> M\n\ngoal (2 subgoals):\n 1. \\<exists>C. Class C \\<in> M \\<Longrightarrow>\n    \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M\n 2. \\<nexists>C. Class C \\<in> M \\<Longrightarrow>\n    \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M", "with not_is_class[of C]"], ["proof (chain)\npicking this:\n  Class C \\<in> M \\<Longrightarrow> \\<not> is_class P C\n  Class C \\<in> M", "show ?thesis"], ["proof (prove)\nusing this:\n  Class C \\<in> M \\<Longrightarrow> \\<not> is_class P C\n  Class C \\<in> M\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M", "by(blast dest: rtranclpD subcls_is_class Class_widen)"], ["proof (state)\nthis:\n  \\<exists>z\\<in>M.\n     \\<forall>y.\n        (y, z)\n        \\<in> {(y, T).\n               is_type P T \\<and>\n               is_type P y \\<and>\n               P \\<turnstile> T \\<le> y \\<and>\n               T \\<noteq> y} \\<longrightarrow>\n        y \\<notin> M\n\ngoal (1 subgoal):\n 1. \\<nexists>C. Class C \\<in> M \\<Longrightarrow>\n    \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>C. Class C \\<in> M \\<Longrightarrow>\n    \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M", "case False"], ["proof (state)\nthis:\n  \\<nexists>C. Class C \\<in> M\n\ngoal (1 subgoal):\n 1. \\<nexists>C. Class C \\<in> M \\<Longrightarrow>\n    \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M", "proof(cases \"\\<exists>T. Array T \\<in> M\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>T. T\\<lfloor>\\<rceil> \\<in> M \\<Longrightarrow>\n    \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M\n 2. \\<nexists>T. T\\<lfloor>\\<rceil> \\<in> M \\<Longrightarrow>\n    \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M", "case True"], ["proof (state)\nthis:\n  \\<exists>T. T\\<lfloor>\\<rceil> \\<in> M\n\ngoal (2 subgoals):\n 1. \\<exists>T. T\\<lfloor>\\<rceil> \\<in> M \\<Longrightarrow>\n    \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M\n 2. \\<nexists>T. T\\<lfloor>\\<rceil> \\<in> M \\<Longrightarrow>\n    \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M", "then"], ["proof (chain)\npicking this:\n  \\<exists>T. T\\<lfloor>\\<rceil> \\<in> M", "obtain U where U: \"Array U \\<in> M\""], ["proof (prove)\nusing this:\n  \\<exists>T. T\\<lfloor>\\<rceil> \\<in> M\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        U\\<lfloor>\\<rceil> \\<in> M \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  U\\<lfloor>\\<rceil> \\<in> M\n\ngoal (2 subgoals):\n 1. \\<exists>T. T\\<lfloor>\\<rceil> \\<in> M \\<Longrightarrow>\n    \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M\n 2. \\<nexists>T. T\\<lfloor>\\<rceil> \\<in> M \\<Longrightarrow>\n    \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M", "hence \"\\<not> is_type P (U\\<lfloor>\\<rceil>)\""], ["proof (prove)\nusing this:\n  U\\<lfloor>\\<rceil> \\<in> M\n\ngoal (1 subgoal):\n 1. \\<not> is_type P (U\\<lfloor>\\<rceil>)", "by(rule not_is_array)"], ["proof (state)\nthis:\n  \\<not> is_type P (U\\<lfloor>\\<rceil>)\n\ngoal (2 subgoals):\n 1. \\<exists>T. T\\<lfloor>\\<rceil> \\<in> M \\<Longrightarrow>\n    \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M\n 2. \\<nexists>T. T\\<lfloor>\\<rceil> \\<in> M \\<Longrightarrow>\n    \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> is_type P (U\\<lfloor>\\<rceil>)\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M", "using U"], ["proof (prove)\nusing this:\n  \\<not> is_type P (U\\<lfloor>\\<rceil>)\n  U\\<lfloor>\\<rceil> \\<in> M\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M", "by(auto simp del: is_type.simps)"], ["proof (state)\nthis:\n  \\<exists>z\\<in>M.\n     \\<forall>y.\n        (y, z)\n        \\<in> {(y, T).\n               is_type P T \\<and>\n               is_type P y \\<and>\n               P \\<turnstile> T \\<le> y \\<and>\n               T \\<noteq> y} \\<longrightarrow>\n        y \\<notin> M\n\ngoal (1 subgoal):\n 1. \\<nexists>T. T\\<lfloor>\\<rceil> \\<in> M \\<Longrightarrow>\n    \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>T. T\\<lfloor>\\<rceil> \\<in> M \\<Longrightarrow>\n    \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M", "case False"], ["proof (state)\nthis:\n  \\<nexists>T. T\\<lfloor>\\<rceil> \\<in> M\n\ngoal (1 subgoal):\n 1. \\<nexists>T. T\\<lfloor>\\<rceil> \\<in> M \\<Longrightarrow>\n    \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M", "with \\<open>\\<not> (\\<exists>C. Class C \\<in> M)\\<close> TM"], ["proof (chain)\npicking this:\n  \\<nexists>C. Class C \\<in> M\n  T \\<in> M\n  \\<nexists>T. T\\<lfloor>\\<rceil> \\<in> M", "have \"\\<forall>y. P \\<turnstile> T \\<le> y \\<and> T \\<noteq> y \\<longrightarrow> y \\<notin> M\""], ["proof (prove)\nusing this:\n  \\<nexists>C. Class C \\<in> M\n  T \\<in> M\n  \\<nexists>T. T\\<lfloor>\\<rceil> \\<in> M\n\ngoal (1 subgoal):\n 1. \\<forall>y.\n       P \\<turnstile> T \\<le> y \\<and> T \\<noteq> y \\<longrightarrow>\n       y \\<notin> M", "by(cases T)(fastforce simp add: NT_widen)+"], ["proof (state)\nthis:\n  \\<forall>y.\n     P \\<turnstile> T \\<le> y \\<and> T \\<noteq> y \\<longrightarrow>\n     y \\<notin> M\n\ngoal (1 subgoal):\n 1. \\<nexists>T. T\\<lfloor>\\<rceil> \\<in> M \\<Longrightarrow>\n    \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     P \\<turnstile> T \\<le> y \\<and> T \\<noteq> y \\<longrightarrow>\n     y \\<notin> M\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M", "using TM"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     P \\<turnstile> T \\<le> y \\<and> T \\<noteq> y \\<longrightarrow>\n     y \\<notin> M\n  T \\<in> M\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>M.\n       \\<forall>y.\n          (y, z)\n          \\<in> {(y, T).\n                 is_type P T \\<and>\n                 is_type P y \\<and>\n                 P \\<turnstile> T \\<le> y \\<and>\n                 T \\<noteq> y} \\<longrightarrow>\n          y \\<notin> M", "by blast"], ["proof (state)\nthis:\n  \\<exists>z\\<in>M.\n     \\<forall>y.\n        (y, z)\n        \\<in> {(y, T).\n               is_type P T \\<and>\n               is_type P y \\<and>\n               P \\<turnstile> T \\<le> y \\<and>\n               T \\<noteq> y} \\<longrightarrow>\n        y \\<notin> M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>z\\<in>M.\n     \\<forall>y.\n        (y, z)\n        \\<in> {(y, T).\n               is_type P T \\<and>\n               is_type P y \\<and>\n               P \\<turnstile> T \\<le> y \\<and>\n               T \\<noteq> y} \\<longrightarrow>\n        y \\<notin> M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>z\\<in>M.\n     \\<forall>y.\n        (y, z)\n        \\<in> {(y, T).\n               is_type P T \\<and>\n               is_type P y \\<and>\n               P \\<turnstile> T \\<le> y \\<and>\n               T \\<noteq> y} \\<longrightarrow>\n        y \\<notin> M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>z\\<in>M.\n     \\<forall>y.\n        (y, z)\n        \\<in> {(y, T).\n               is_type P T \\<and>\n               is_type P y \\<and>\n               P \\<turnstile> T \\<le> y \\<and>\n               T \\<noteq> y} \\<longrightarrow>\n        y \\<notin> M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wf {(y, x).\n      is_type P x \\<and>\n      is_type P y \\<and> P \\<turnstile> x \\<le> y \\<and> x \\<noteq> y}\n\ngoal (1 subgoal):\n 1. acc (types P) (widen P)", "thus ?thesis"], ["proof (prove)\nusing this:\n  wf {(y, x).\n      is_type P x \\<and>\n      is_type P y \\<and> P \\<turnstile> x \\<le> y \\<and> x \\<noteq> y}\n\ngoal (1 subgoal):\n 1. acc (types P) (widen P)", "by(simp add: Semilat.acc_def lesssub_def lesub_def)"], ["proof (state)\nthis:\n  acc (types P) (widen P)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas wf_widen_acc = wf_prog_impl_acc_widen"], ["", "declare wf_widen_acc [intro, simp]"], ["", "lemma acyclic_widen1:\n  \"wf_prog wfmc P \\<Longrightarrow> acyclic (widen1 P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wfmc P \\<Longrightarrow> acyclic (widen1 P)", "by(auto dest: wf_converse_widen1 wf_acyclic simp add: acyclic_converse)"], ["", "lemma widen1_into_widen:\n  \"(A, B) \\<in> widen1 P \\<Longrightarrow> P \\<turnstile> A \\<le> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> A <\\<^sup>1 B \\<Longrightarrow> P \\<turnstile> A \\<le> B", "by(induct rule: widen1.induct)(auto intro: widen.intros)"], ["", "lemma widen1_rtrancl_into_widen:\n  \"P \\<turnstile> A <\\<^sup>* B \\<Longrightarrow> P \\<turnstile> A \\<le> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> A <\\<^sup>* B \\<Longrightarrow> P \\<turnstile> A \\<le> B", "by(induct rule: rtrancl_induct)(auto dest!: widen1_into_widen elim: widen_trans)"], ["", "lemma widen_eq_widen1_trancl:\n  \"\\<lbrakk> wf_prog wf_md P; T \\<noteq> NT; T \\<noteq> U; is_type P T \\<rbrakk> \\<Longrightarrow> P \\<turnstile> T \\<le> U \\<longleftrightarrow> P \\<turnstile> T <\\<^sup>+ U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; T \\<noteq> NT; T \\<noteq> U;\n     is_type P T\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T \\<le> U =\n                      P \\<turnstile> T <\\<^sup>+ U", "by(blast intro: widen_into_widen1_trancl widen1_rtrancl_into_widen trancl_into_rtrancl)"], ["", "lemma sup_is_type:\n  assumes wf: \"wf_prog wf_md P\"\n  and itA: \"is_type P A\"\n  and itB: \"is_type P B\"\n  and sup: \"sup P A B = OK T\"\n  shows \"is_type P T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_type P T", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_type P T", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. is_type P T", "assume ANT: \"A \\<noteq> NT\"\n      and BNT: \"B \\<noteq> NT\"\n      and AnB: \"A \\<noteq> B\"\n      and RTA: \"is_refT A\"\n      and RTB: \"is_refT B\""], ["proof (state)\nthis:\n  A \\<noteq> NT\n  B \\<noteq> NT\n  A \\<noteq> B\n  is_refT A\n  is_refT B\n\ngoal (1 subgoal):\n 1. is_type P T", "with itA itB"], ["proof (chain)\npicking this:\n  is_type P A\n  is_type P B\n  A \\<noteq> NT\n  B \\<noteq> NT\n  A \\<noteq> B\n  is_refT A\n  is_refT B", "have AObject: \"P \\<turnstile> A \\<le> Class Object\"\n      and BObject: \"P \\<turnstile> B \\<le> Class Object\""], ["proof (prove)\nusing this:\n  is_type P A\n  is_type P B\n  A \\<noteq> NT\n  B \\<noteq> NT\n  A \\<noteq> B\n  is_refT A\n  is_refT B\n\ngoal (1 subgoal):\n 1. P \\<turnstile> A \\<le> Class Object &&&\n    P \\<turnstile> B \\<le> Class Object", "by(auto intro: is_refType_widen_Object[OF wf])"], ["proof (state)\nthis:\n  P \\<turnstile> A \\<le> Class Object\n  P \\<turnstile> B \\<le> Class Object\n\ngoal (1 subgoal):\n 1. is_type P T", "have \"is_type P (exec_lub (widen1 P) (super P) A B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_type P (exec_lub (widen1 P) (super P) A B)", "proof(cases \"A = Class Object \\<or> B = Class Object\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A = Class Object \\<or> B = Class Object \\<Longrightarrow>\n    is_type P (exec_lub (widen1 P) (super P) A B)\n 2. \\<not> (A = Class Object \\<or> B = Class Object) \\<Longrightarrow>\n    is_type P (exec_lub (widen1 P) (super P) A B)", "case True"], ["proof (state)\nthis:\n  A = Class Object \\<or> B = Class Object\n\ngoal (2 subgoals):\n 1. A = Class Object \\<or> B = Class Object \\<Longrightarrow>\n    is_type P (exec_lub (widen1 P) (super P) A B)\n 2. \\<not> (A = Class Object \\<or> B = Class Object) \\<Longrightarrow>\n    is_type P (exec_lub (widen1 P) (super P) A B)", "hence \"exec_lub (widen1 P) (super P) A B = Class Object\""], ["proof (prove)\nusing this:\n  A = Class Object \\<or> B = Class Object\n\ngoal (1 subgoal):\n 1. exec_lub (widen1 P) (super P) A B = Class Object", "proof(rule disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. A = Class Object \\<Longrightarrow>\n    exec_lub (widen1 P) (super P) A B = Class Object\n 2. B = Class Object \\<Longrightarrow>\n    exec_lub (widen1 P) (super P) A B = Class Object", "assume A: \"A = Class Object\""], ["proof (state)\nthis:\n  A = Class Object\n\ngoal (2 subgoals):\n 1. A = Class Object \\<Longrightarrow>\n    exec_lub (widen1 P) (super P) A B = Class Object\n 2. B = Class Object \\<Longrightarrow>\n    exec_lub (widen1 P) (super P) A B = Class Object", "moreover"], ["proof (state)\nthis:\n  A = Class Object\n\ngoal (2 subgoals):\n 1. A = Class Object \\<Longrightarrow>\n    exec_lub (widen1 P) (super P) A B = Class Object\n 2. B = Class Object \\<Longrightarrow>\n    exec_lub (widen1 P) (super P) A B = Class Object", "from BObject BNT itB"], ["proof (chain)\npicking this:\n  P \\<turnstile> B \\<le> Class Object\n  B \\<noteq> NT\n  is_type P B", "have \"P \\<turnstile> B <\\<^sup>* Class Object\""], ["proof (prove)\nusing this:\n  P \\<turnstile> B \\<le> Class Object\n  B \\<noteq> NT\n  is_type P B\n\ngoal (1 subgoal):\n 1. P \\<turnstile> B <\\<^sup>* Class Object", "by(cases \"B = Class Object\")(auto intro: trancl_into_rtrancl widen_into_widen1_trancl[OF wf])"], ["proof (state)\nthis:\n  P \\<turnstile> B <\\<^sup>* Class Object\n\ngoal (2 subgoals):\n 1. A = Class Object \\<Longrightarrow>\n    exec_lub (widen1 P) (super P) A B = Class Object\n 2. B = Class Object \\<Longrightarrow>\n    exec_lub (widen1 P) (super P) A B = Class Object", "hence \"is_ub ((widen1 P)\\<^sup>*) (Class Object) B (Class Object)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> B <\\<^sup>* Class Object\n\ngoal (1 subgoal):\n 1. is_ub ((widen1 P)\\<^sup>*) (Class Object) B (Class Object)", "by(auto intro: is_ubI)"], ["proof (state)\nthis:\n  is_ub ((widen1 P)\\<^sup>*) (Class Object) B (Class Object)\n\ngoal (2 subgoals):\n 1. A = Class Object \\<Longrightarrow>\n    exec_lub (widen1 P) (super P) A B = Class Object\n 2. B = Class Object \\<Longrightarrow>\n    exec_lub (widen1 P) (super P) A B = Class Object", "hence \"is_lub ((widen1 P)\\<^sup>*) (Class Object) B (Class Object)\""], ["proof (prove)\nusing this:\n  is_ub ((widen1 P)\\<^sup>*) (Class Object) B (Class Object)\n\ngoal (1 subgoal):\n 1. Semilat.is_lub ((widen1 P)\\<^sup>*) (Class Object) B (Class Object)", "by(auto simp add: is_lub_def dest: is_ubD)"], ["proof (state)\nthis:\n  Semilat.is_lub ((widen1 P)\\<^sup>*) (Class Object) B (Class Object)\n\ngoal (2 subgoals):\n 1. A = Class Object \\<Longrightarrow>\n    exec_lub (widen1 P) (super P) A B = Class Object\n 2. B = Class Object \\<Longrightarrow>\n    exec_lub (widen1 P) (super P) A B = Class Object", "with acyclic_widen1[OF wf]"], ["proof (chain)\npicking this:\n  acyclic (widen1 P)\n  Semilat.is_lub ((widen1 P)\\<^sup>*) (Class Object) B (Class Object)", "have \"exec_lub (widen1 P) (super P) (Class Object) B = Class Object\""], ["proof (prove)\nusing this:\n  acyclic (widen1 P)\n  Semilat.is_lub ((widen1 P)\\<^sup>*) (Class Object) B (Class Object)\n\ngoal (1 subgoal):\n 1. exec_lub (widen1 P) (super P) (Class Object) B = Class Object", "by(auto intro: exec_lub_conv superI)"], ["proof (state)\nthis:\n  exec_lub (widen1 P) (super P) (Class Object) B = Class Object\n\ngoal (2 subgoals):\n 1. A = Class Object \\<Longrightarrow>\n    exec_lub (widen1 P) (super P) A B = Class Object\n 2. B = Class Object \\<Longrightarrow>\n    exec_lub (widen1 P) (super P) A B = Class Object", "ultimately"], ["proof (chain)\npicking this:\n  A = Class Object\n  exec_lub (widen1 P) (super P) (Class Object) B = Class Object", "show \"exec_lub (widen1 P) (super P) A B = Class Object\""], ["proof (prove)\nusing this:\n  A = Class Object\n  exec_lub (widen1 P) (super P) (Class Object) B = Class Object\n\ngoal (1 subgoal):\n 1. exec_lub (widen1 P) (super P) A B = Class Object", "by simp"], ["proof (state)\nthis:\n  exec_lub (widen1 P) (super P) A B = Class Object\n\ngoal (1 subgoal):\n 1. B = Class Object \\<Longrightarrow>\n    exec_lub (widen1 P) (super P) A B = Class Object", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. B = Class Object \\<Longrightarrow>\n    exec_lub (widen1 P) (super P) A B = Class Object", "assume B: \"B = Class Object\""], ["proof (state)\nthis:\n  B = Class Object\n\ngoal (1 subgoal):\n 1. B = Class Object \\<Longrightarrow>\n    exec_lub (widen1 P) (super P) A B = Class Object", "moreover"], ["proof (state)\nthis:\n  B = Class Object\n\ngoal (1 subgoal):\n 1. B = Class Object \\<Longrightarrow>\n    exec_lub (widen1 P) (super P) A B = Class Object", "from AObject ANT itA"], ["proof (chain)\npicking this:\n  P \\<turnstile> A \\<le> Class Object\n  A \\<noteq> NT\n  is_type P A", "have \"(A, Class Object) \\<in> (widen1 P)\\<^sup>*\""], ["proof (prove)\nusing this:\n  P \\<turnstile> A \\<le> Class Object\n  A \\<noteq> NT\n  is_type P A\n\ngoal (1 subgoal):\n 1. P \\<turnstile> A <\\<^sup>* Class Object", "by(cases \"A = Class Object\", auto intro: trancl_into_rtrancl widen_into_widen1_trancl[OF wf])"], ["proof (state)\nthis:\n  P \\<turnstile> A <\\<^sup>* Class Object\n\ngoal (1 subgoal):\n 1. B = Class Object \\<Longrightarrow>\n    exec_lub (widen1 P) (super P) A B = Class Object", "hence \"is_ub ((widen1 P)\\<^sup>*) (Class Object) A (Class Object)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> A <\\<^sup>* Class Object\n\ngoal (1 subgoal):\n 1. is_ub ((widen1 P)\\<^sup>*) (Class Object) A (Class Object)", "by(auto intro: is_ubI)"], ["proof (state)\nthis:\n  is_ub ((widen1 P)\\<^sup>*) (Class Object) A (Class Object)\n\ngoal (1 subgoal):\n 1. B = Class Object \\<Longrightarrow>\n    exec_lub (widen1 P) (super P) A B = Class Object", "hence \"is_lub ((widen1 P)\\<^sup>*) (Class Object) A (Class Object)\""], ["proof (prove)\nusing this:\n  is_ub ((widen1 P)\\<^sup>*) (Class Object) A (Class Object)\n\ngoal (1 subgoal):\n 1. Semilat.is_lub ((widen1 P)\\<^sup>*) (Class Object) A (Class Object)", "by(auto simp add: is_lub_def dest: is_ubD)"], ["proof (state)\nthis:\n  Semilat.is_lub ((widen1 P)\\<^sup>*) (Class Object) A (Class Object)\n\ngoal (1 subgoal):\n 1. B = Class Object \\<Longrightarrow>\n    exec_lub (widen1 P) (super P) A B = Class Object", "with acyclic_widen1[OF wf]"], ["proof (chain)\npicking this:\n  acyclic (widen1 P)\n  Semilat.is_lub ((widen1 P)\\<^sup>*) (Class Object) A (Class Object)", "have \"exec_lub (widen1 P) (super P) A (Class Object) = Class Object\""], ["proof (prove)\nusing this:\n  acyclic (widen1 P)\n  Semilat.is_lub ((widen1 P)\\<^sup>*) (Class Object) A (Class Object)\n\ngoal (1 subgoal):\n 1. exec_lub (widen1 P) (super P) A (Class Object) = Class Object", "by(auto intro: exec_lub_conv superI)"], ["proof (state)\nthis:\n  exec_lub (widen1 P) (super P) A (Class Object) = Class Object\n\ngoal (1 subgoal):\n 1. B = Class Object \\<Longrightarrow>\n    exec_lub (widen1 P) (super P) A B = Class Object", "ultimately"], ["proof (chain)\npicking this:\n  B = Class Object\n  exec_lub (widen1 P) (super P) A (Class Object) = Class Object", "show \"exec_lub (widen1 P) (super P) A B = Class Object\""], ["proof (prove)\nusing this:\n  B = Class Object\n  exec_lub (widen1 P) (super P) A (Class Object) = Class Object\n\ngoal (1 subgoal):\n 1. exec_lub (widen1 P) (super P) A B = Class Object", "by simp"], ["proof (state)\nthis:\n  exec_lub (widen1 P) (super P) A B = Class Object\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  exec_lub (widen1 P) (super P) A B = Class Object\n\ngoal (2 subgoals):\n 1. A = Class Object \\<or> B = Class Object \\<Longrightarrow>\n    is_type P (exec_lub (widen1 P) (super P) A B)\n 2. \\<not> (A = Class Object \\<or> B = Class Object) \\<Longrightarrow>\n    is_type P (exec_lub (widen1 P) (super P) A B)", "with wf"], ["proof (chain)\npicking this:\n  wf_prog wf_md P\n  exec_lub (widen1 P) (super P) A B = Class Object", "show ?thesis"], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  exec_lub (widen1 P) (super P) A B = Class Object\n\ngoal (1 subgoal):\n 1. is_type P (exec_lub (widen1 P) (super P) A B)", "by(simp)"], ["proof (state)\nthis:\n  is_type P (exec_lub (widen1 P) (super P) A B)\n\ngoal (1 subgoal):\n 1. \\<not> (A = Class Object \\<or> B = Class Object) \\<Longrightarrow>\n    is_type P (exec_lub (widen1 P) (super P) A B)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (A = Class Object \\<or> B = Class Object) \\<Longrightarrow>\n    is_type P (exec_lub (widen1 P) (super P) A B)", "case False"], ["proof (state)\nthis:\n  \\<not> (A = Class Object \\<or> B = Class Object)\n\ngoal (1 subgoal):\n 1. \\<not> (A = Class Object \\<or> B = Class Object) \\<Longrightarrow>\n    is_type P (exec_lub (widen1 P) (super P) A B)", "hence AnObject: \"A \\<noteq> Class Object\"\n        and BnObject: \"B \\<noteq> Class Object\""], ["proof (prove)\nusing this:\n  \\<not> (A = Class Object \\<or> B = Class Object)\n\ngoal (1 subgoal):\n 1. A \\<noteq> Class Object &&& B \\<noteq> Class Object", "by auto"], ["proof (state)\nthis:\n  A \\<noteq> Class Object\n  B \\<noteq> Class Object\n\ngoal (1 subgoal):\n 1. \\<not> (A = Class Object \\<or> B = Class Object) \\<Longrightarrow>\n    is_type P (exec_lub (widen1 P) (super P) A B)", "from widen_into_widen1_trancl[OF wf AObject AnObject ANT itA]"], ["proof (chain)\npicking this:\n  P \\<turnstile> A <\\<^sup>+ Class Object", "have \"P \\<turnstile> A <\\<^sup>* Class Object\""], ["proof (prove)\nusing this:\n  P \\<turnstile> A <\\<^sup>+ Class Object\n\ngoal (1 subgoal):\n 1. P \\<turnstile> A <\\<^sup>* Class Object", "by(rule trancl_into_rtrancl)"], ["proof (state)\nthis:\n  P \\<turnstile> A <\\<^sup>* Class Object\n\ngoal (1 subgoal):\n 1. \\<not> (A = Class Object \\<or> B = Class Object) \\<Longrightarrow>\n    is_type P (exec_lub (widen1 P) (super P) A B)", "moreover"], ["proof (state)\nthis:\n  P \\<turnstile> A <\\<^sup>* Class Object\n\ngoal (1 subgoal):\n 1. \\<not> (A = Class Object \\<or> B = Class Object) \\<Longrightarrow>\n    is_type P (exec_lub (widen1 P) (super P) A B)", "from widen_into_widen1_trancl[OF wf BObject BnObject BNT itB]"], ["proof (chain)\npicking this:\n  P \\<turnstile> B <\\<^sup>+ Class Object", "have \"P \\<turnstile> B <\\<^sup>* Class Object\""], ["proof (prove)\nusing this:\n  P \\<turnstile> B <\\<^sup>+ Class Object\n\ngoal (1 subgoal):\n 1. P \\<turnstile> B <\\<^sup>* Class Object", "by(rule trancl_into_rtrancl)"], ["proof (state)\nthis:\n  P \\<turnstile> B <\\<^sup>* Class Object\n\ngoal (1 subgoal):\n 1. \\<not> (A = Class Object \\<or> B = Class Object) \\<Longrightarrow>\n    is_type P (exec_lub (widen1 P) (super P) A B)", "ultimately"], ["proof (chain)\npicking this:\n  P \\<turnstile> A <\\<^sup>* Class Object\n  P \\<turnstile> B <\\<^sup>* Class Object", "have \"is_lub ((widen1 P)\\<^sup>*) A B (exec_lub (widen1 P) (super P) A B)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> A <\\<^sup>* Class Object\n  P \\<turnstile> B <\\<^sup>* Class Object\n\ngoal (1 subgoal):\n 1. Semilat.is_lub ((widen1 P)\\<^sup>*) A B\n     (exec_lub (widen1 P) (super P) A B)", "by(rule is_lub_exec_lub[OF single_valued_widen1[OF wf] acyclic_widen1[OF wf]])(auto intro: superI)"], ["proof (state)\nthis:\n  Semilat.is_lub ((widen1 P)\\<^sup>*) A B\n   (exec_lub (widen1 P) (super P) A B)\n\ngoal (1 subgoal):\n 1. \\<not> (A = Class Object \\<or> B = Class Object) \\<Longrightarrow>\n    is_type P (exec_lub (widen1 P) (super P) A B)", "hence Aew1: \"P \\<turnstile> A <\\<^sup>* exec_lub (widen1 P) (super P) A B\""], ["proof (prove)\nusing this:\n  Semilat.is_lub ((widen1 P)\\<^sup>*) A B\n   (exec_lub (widen1 P) (super P) A B)\n\ngoal (1 subgoal):\n 1. P \\<turnstile> A <\\<^sup>* exec_lub (widen1 P) (super P) A B", "by(auto simp add: is_lub_def dest!: is_ubD)"], ["proof (state)\nthis:\n  P \\<turnstile> A <\\<^sup>* exec_lub (widen1 P) (super P) A B\n\ngoal (1 subgoal):\n 1. \\<not> (A = Class Object \\<or> B = Class Object) \\<Longrightarrow>\n    is_type P (exec_lub (widen1 P) (super P) A B)", "thus ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> A <\\<^sup>* exec_lub (widen1 P) (super P) A B\n\ngoal (1 subgoal):\n 1. is_type P (exec_lub (widen1 P) (super P) A B)", "proof(rule rtranclE)"], ["proof (state)\ngoal (2 subgoals):\n 1. A = exec_lub (widen1 P) (super P) A B \\<Longrightarrow>\n    is_type P (exec_lub (widen1 P) (super P) A B)\n 2. \\<And>y.\n       \\<lbrakk>P \\<turnstile> A <\\<^sup>* y;\n        P \\<turnstile> y <\\<^sup>1 exec_lub (widen1 P) (super P) A\n                                    B\\<rbrakk>\n       \\<Longrightarrow> is_type P (exec_lub (widen1 P) (super P) A B)", "assume \"A = exec_lub (widen1 P) (super P) A B\""], ["proof (state)\nthis:\n  A = exec_lub (widen1 P) (super P) A B\n\ngoal (2 subgoals):\n 1. A = exec_lub (widen1 P) (super P) A B \\<Longrightarrow>\n    is_type P (exec_lub (widen1 P) (super P) A B)\n 2. \\<And>y.\n       \\<lbrakk>P \\<turnstile> A <\\<^sup>* y;\n        P \\<turnstile> y <\\<^sup>1 exec_lub (widen1 P) (super P) A\n                                    B\\<rbrakk>\n       \\<Longrightarrow> is_type P (exec_lub (widen1 P) (super P) A B)", "with itA"], ["proof (chain)\npicking this:\n  is_type P A\n  A = exec_lub (widen1 P) (super P) A B", "show ?thesis"], ["proof (prove)\nusing this:\n  is_type P A\n  A = exec_lub (widen1 P) (super P) A B\n\ngoal (1 subgoal):\n 1. is_type P (exec_lub (widen1 P) (super P) A B)", "by simp"], ["proof (state)\nthis:\n  is_type P (exec_lub (widen1 P) (super P) A B)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>P \\<turnstile> A <\\<^sup>* y;\n        P \\<turnstile> y <\\<^sup>1 exec_lub (widen1 P) (super P) A\n                                    B\\<rbrakk>\n       \\<Longrightarrow> is_type P (exec_lub (widen1 P) (super P) A B)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>P \\<turnstile> A <\\<^sup>* y;\n        P \\<turnstile> y <\\<^sup>1 exec_lub (widen1 P) (super P) A\n                                    B\\<rbrakk>\n       \\<Longrightarrow> is_type P (exec_lub (widen1 P) (super P) A B)", "fix A'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>P \\<turnstile> A <\\<^sup>* y;\n        P \\<turnstile> y <\\<^sup>1 exec_lub (widen1 P) (super P) A\n                                    B\\<rbrakk>\n       \\<Longrightarrow> is_type P (exec_lub (widen1 P) (super P) A B)", "assume \"P \\<turnstile> A' <\\<^sup>1 exec_lub (widen1 P) (super P) A B\""], ["proof (state)\nthis:\n  P \\<turnstile> A' <\\<^sup>1 exec_lub (widen1 P) (super P) A B\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>P \\<turnstile> A <\\<^sup>* y;\n        P \\<turnstile> y <\\<^sup>1 exec_lub (widen1 P) (super P) A\n                                    B\\<rbrakk>\n       \\<Longrightarrow> is_type P (exec_lub (widen1 P) (super P) A B)", "thus ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> A' <\\<^sup>1 exec_lub (widen1 P) (super P) A B\n\ngoal (1 subgoal):\n 1. is_type P (exec_lub (widen1 P) (super P) A B)", "by(rule widen1_is_type[OF wf])"], ["proof (state)\nthis:\n  is_type P (exec_lub (widen1 P) (super P) A B)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_type P (exec_lub (widen1 P) (super P) A B)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_type P (exec_lub (widen1 P) (super P) A B)\n\ngoal (1 subgoal):\n 1. is_type P T", "}"], ["proof (state)\nthis:\n  \\<lbrakk>A \\<noteq> NT; B \\<noteq> NT; A \\<noteq> B; is_refT A;\n   is_refT B\\<rbrakk>\n  \\<Longrightarrow> is_type P (exec_lub (widen1 P) (super P) A B)\n\ngoal (1 subgoal):\n 1. is_type P T", "with is_class_Object[OF wf] sup itA itB"], ["proof (chain)\npicking this:\n  is_class P Object\n  SemiType.sup P A B = OK T\n  is_type P A\n  is_type P B\n  \\<lbrakk>A \\<noteq> NT; B \\<noteq> NT; A \\<noteq> B; is_refT A;\n   is_refT B\\<rbrakk>\n  \\<Longrightarrow> is_type P (exec_lub (widen1 P) (super P) A B)", "show ?thesis"], ["proof (prove)\nusing this:\n  is_class P Object\n  SemiType.sup P A B = OK T\n  is_type P A\n  is_type P B\n  \\<lbrakk>A \\<noteq> NT; B \\<noteq> NT; A \\<noteq> B; is_refT A;\n   is_refT B\\<rbrakk>\n  \\<Longrightarrow> is_type P (exec_lub (widen1 P) (super P) A B)\n\ngoal (1 subgoal):\n 1. is_type P T", "unfolding sup_def"], ["proof (prove)\nusing this:\n  is_class P Object\n  (if is_refT A \\<and> is_refT B\n   then OK (if B = NT then A\n            else if A = NT then B else exec_lub (widen1 P) (super P) A B)\n   else if A = B then OK A else Err) =\n  OK T\n  is_type P A\n  is_type P B\n  \\<lbrakk>A \\<noteq> NT; B \\<noteq> NT; A \\<noteq> B; is_refT A;\n   is_refT B\\<rbrakk>\n  \\<Longrightarrow> is_type P (exec_lub (widen1 P) (super P) A B)\n\ngoal (1 subgoal):\n 1. is_type P T", "by(cases \"A = B\")(auto split: if_split_asm simp add: exec_lub_refl)"], ["proof (state)\nthis:\n  is_type P T\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma closed_err_types:\n  assumes wfP: \"wf_prog wf_mb P\"\n  shows \"closed (err (types P)) (lift2 (sup P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Semilat.closed (err (types P)) (lift2 (SemiType.sup P))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Semilat.closed (err (types P)) (lift2 (SemiType.sup P))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. Semilat.closed (err (types P)) (lift2 (SemiType.sup P))", "fix A B"], ["proof (state)\ngoal (1 subgoal):\n 1. Semilat.closed (err (types P)) (lift2 (SemiType.sup P))", "assume it: \"is_type P A\" \"is_type P B\"\n      and \"A \\<noteq> NT\" \"B \\<noteq> NT\" \"A \\<noteq> B\"\n      and \"is_refT A\" \"is_refT B\""], ["proof (state)\nthis:\n  is_type P A\n  is_type P B\n  A \\<noteq> NT\n  B \\<noteq> NT\n  A \\<noteq> B\n  is_refT A\n  is_refT B\n\ngoal (1 subgoal):\n 1. Semilat.closed (err (types P)) (lift2 (SemiType.sup P))", "hence \"is_type P (exec_lub (widen1 P) (super P) A B)\""], ["proof (prove)\nusing this:\n  is_type P A\n  is_type P B\n  A \\<noteq> NT\n  B \\<noteq> NT\n  A \\<noteq> B\n  is_refT A\n  is_refT B\n\ngoal (1 subgoal):\n 1. is_type P (exec_lub (widen1 P) (super P) A B)", "using sup_is_type[OF wfP it]"], ["proof (prove)\nusing this:\n  is_type P A\n  is_type P B\n  A \\<noteq> NT\n  B \\<noteq> NT\n  A \\<noteq> B\n  is_refT A\n  is_refT B\n  SemiType.sup P A B = OK ?T \\<Longrightarrow> is_type P ?T\n\ngoal (1 subgoal):\n 1. is_type P (exec_lub (widen1 P) (super P) A B)", "by(simp add: sup_def)"], ["proof (state)\nthis:\n  is_type P (exec_lub (widen1 P) (super P) A B)\n\ngoal (1 subgoal):\n 1. Semilat.closed (err (types P)) (lift2 (SemiType.sup P))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>is_type P ?A2; is_type P ?B2; ?A2 \\<noteq> NT; ?B2 \\<noteq> NT;\n   ?A2 \\<noteq> ?B2; is_refT ?A2; is_refT ?B2\\<rbrakk>\n  \\<Longrightarrow> is_type P (exec_lub (widen1 P) (super P) ?A2 ?B2)\n\ngoal (1 subgoal):\n 1. Semilat.closed (err (types P)) (lift2 (SemiType.sup P))", "with is_class_Object[OF wfP]"], ["proof (chain)\npicking this:\n  is_class P Object\n  \\<lbrakk>is_type P ?A2; is_type P ?B2; ?A2 \\<noteq> NT; ?B2 \\<noteq> NT;\n   ?A2 \\<noteq> ?B2; is_refT ?A2; is_refT ?B2\\<rbrakk>\n  \\<Longrightarrow> is_type P (exec_lub (widen1 P) (super P) ?A2 ?B2)", "show ?thesis"], ["proof (prove)\nusing this:\n  is_class P Object\n  \\<lbrakk>is_type P ?A2; is_type P ?B2; ?A2 \\<noteq> NT; ?B2 \\<noteq> NT;\n   ?A2 \\<noteq> ?B2; is_refT ?A2; is_refT ?B2\\<rbrakk>\n  \\<Longrightarrow> is_type P (exec_lub (widen1 P) (super P) ?A2 ?B2)\n\ngoal (1 subgoal):\n 1. Semilat.closed (err (types P)) (lift2 (SemiType.sup P))", "unfolding closed_def plussub_def lift2_def sup_def'"], ["proof (prove)\nusing this:\n  is_class P Object\n  \\<lbrakk>is_type P ?A2; is_type P ?B2; ?A2 \\<noteq> NT; ?B2 \\<noteq> NT;\n   ?A2 \\<noteq> ?B2; is_refT ?A2; is_refT ?B2\\<rbrakk>\n  \\<Longrightarrow> is_type P (exec_lub (widen1 P) (super P) ?A2 ?B2)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>err (types P).\n       \\<forall>y\\<in>err (types P).\n          (case x of Err \\<Rightarrow> Err\n           | OK x \\<Rightarrow>\n               case y of Err \\<Rightarrow> Err\n               | OK U \\<Rightarrow>\n                   if is_refT x \\<and> is_refT U\n                   then OK (if U = NT then x\n                            else if x = NT then U\n                                 else exec_lub (widen1 P) (super P) x U)\n                   else if x = U then OK x else Err)\n          \\<in> err (types P)", "by(auto split: err.split ty.splits)(auto simp add: exec_lub_refl)"], ["proof (state)\nthis:\n  Semilat.closed (err (types P)) (lift2 (SemiType.sup P))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma widen_into_widen1_rtrancl:\n  \"\\<lbrakk>wf_prog wfmd P; widen P A B; A \\<noteq> NT; is_type P A \\<rbrakk> \\<Longrightarrow> (A, B) \\<in> (widen1 P)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wfmd P; P \\<turnstile> A \\<le> B; A \\<noteq> NT;\n     is_type P A\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> A <\\<^sup>* B", "by(cases \"A = B\")(auto intro: trancl_into_rtrancl widen_into_widen1_trancl)"], ["", "lemma sup_widen_greater:\n  assumes wfP: \"wf_prog wf_mb P\"\n  and it1: \"is_type P t1\"\n  and it2: \"is_type P t2\"\n  and sup: \"sup P t1 t2 = OK s\"\n  shows \"widen P t1 s \\<and> widen P t2 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> t1 \\<le> s \\<and> P \\<turnstile> t2 \\<le> s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<turnstile> t1 \\<le> s \\<and> P \\<turnstile> t2 \\<le> s", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<turnstile> t1 \\<le> s \\<and> P \\<turnstile> t2 \\<le> s", "assume t1: \"is_refT t1\"\n      and t2: \"is_refT t2\"\n      and t1NT: \"t1 \\<noteq> NT\"\n      and t2NT: \"t2 \\<noteq> NT\""], ["proof (state)\nthis:\n  is_refT t1\n  is_refT t2\n  t1 \\<noteq> NT\n  t2 \\<noteq> NT\n\ngoal (1 subgoal):\n 1. P \\<turnstile> t1 \\<le> s \\<and> P \\<turnstile> t2 \\<le> s", "with it1 it2 wfP"], ["proof (chain)\npicking this:\n  is_type P t1\n  is_type P t2\n  wf_prog wf_mb P\n  is_refT t1\n  is_refT t2\n  t1 \\<noteq> NT\n  t2 \\<noteq> NT", "have \"P \\<turnstile> t1 \\<le> Class Object\" \"P \\<turnstile> t2 \\<le> Class Object\""], ["proof (prove)\nusing this:\n  is_type P t1\n  is_type P t2\n  wf_prog wf_mb P\n  is_refT t1\n  is_refT t2\n  t1 \\<noteq> NT\n  t2 \\<noteq> NT\n\ngoal (1 subgoal):\n 1. P \\<turnstile> t1 \\<le> Class Object &&&\n    P \\<turnstile> t2 \\<le> Class Object", "by(auto intro: is_refType_widen_Object)"], ["proof (state)\nthis:\n  P \\<turnstile> t1 \\<le> Class Object\n  P \\<turnstile> t2 \\<le> Class Object\n\ngoal (1 subgoal):\n 1. P \\<turnstile> t1 \\<le> s \\<and> P \\<turnstile> t2 \\<le> s", "with t1NT t2NT it1 it2"], ["proof (chain)\npicking this:\n  t1 \\<noteq> NT\n  t2 \\<noteq> NT\n  is_type P t1\n  is_type P t2\n  P \\<turnstile> t1 \\<le> Class Object\n  P \\<turnstile> t2 \\<le> Class Object", "have \"P \\<turnstile> t1 <\\<^sup>* Class Object\" \"P \\<turnstile> t2 <\\<^sup>* Class Object\""], ["proof (prove)\nusing this:\n  t1 \\<noteq> NT\n  t2 \\<noteq> NT\n  is_type P t1\n  is_type P t2\n  P \\<turnstile> t1 \\<le> Class Object\n  P \\<turnstile> t2 \\<le> Class Object\n\ngoal (1 subgoal):\n 1. P \\<turnstile> t1 <\\<^sup>* Class Object &&&\n    P \\<turnstile> t2 <\\<^sup>* Class Object", "by(auto intro: widen_into_widen1_rtrancl[OF wfP])"], ["proof (state)\nthis:\n  P \\<turnstile> t1 <\\<^sup>* Class Object\n  P \\<turnstile> t2 <\\<^sup>* Class Object\n\ngoal (1 subgoal):\n 1. P \\<turnstile> t1 \\<le> s \\<and> P \\<turnstile> t2 \\<le> s", "with single_valued_widen1[OF wfP]"], ["proof (chain)\npicking this:\n  single_valued (widen1 P)\n  P \\<turnstile> t1 <\\<^sup>* Class Object\n  P \\<turnstile> t2 <\\<^sup>* Class Object", "obtain u where \"is_lub ((widen1 P)^*) t1 t2 u\""], ["proof (prove)\nusing this:\n  single_valued (widen1 P)\n  P \\<turnstile> t1 <\\<^sup>* Class Object\n  P \\<turnstile> t2 <\\<^sup>* Class Object\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        Semilat.is_lub ((widen1 P)\\<^sup>*) t1 t2 u \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: single_valued_has_lubs)"], ["proof (state)\nthis:\n  Semilat.is_lub ((widen1 P)\\<^sup>*) t1 t2 u\n\ngoal (1 subgoal):\n 1. P \\<turnstile> t1 \\<le> s \\<and> P \\<turnstile> t2 \\<le> s", "hence \"P \\<turnstile> t1 \\<le> exec_lub (widen1 P) (super P) t1 t2 \\<and>\n           P \\<turnstile> t2 \\<le> exec_lub (widen1 P) (super P) t1 t2\""], ["proof (prove)\nusing this:\n  Semilat.is_lub ((widen1 P)\\<^sup>*) t1 t2 u\n\ngoal (1 subgoal):\n 1. P \\<turnstile> t1 \\<le> exec_lub (widen1 P) (super P) t1 t2 \\<and>\n    P \\<turnstile> t2 \\<le> exec_lub (widen1 P) (super P) t1 t2", "using acyclic_widen1[OF wfP] superI[of _ _ P]"], ["proof (prove)\nusing this:\n  Semilat.is_lub ((widen1 P)\\<^sup>*) t1 t2 u\n  acyclic (widen1 P)\n  P \\<turnstile> ?T <\\<^sup>1 ?U \\<Longrightarrow> super P ?T = ?U\n\ngoal (1 subgoal):\n 1. P \\<turnstile> t1 \\<le> exec_lub (widen1 P) (super P) t1 t2 \\<and>\n    P \\<turnstile> t2 \\<le> exec_lub (widen1 P) (super P) t1 t2", "by(simp add: exec_lub_conv)(blast dest: is_lubD is_ubD intro: widen1_rtrancl_into_widen)"], ["proof (state)\nthis:\n  P \\<turnstile> t1 \\<le> exec_lub (widen1 P) (super P) t1 t2 \\<and>\n  P \\<turnstile> t2 \\<le> exec_lub (widen1 P) (super P) t1 t2\n\ngoal (1 subgoal):\n 1. P \\<turnstile> t1 \\<le> s \\<and> P \\<turnstile> t2 \\<le> s", "}"], ["proof (state)\nthis:\n  \\<lbrakk>is_refT t1; is_refT t2; t1 \\<noteq> NT; t2 \\<noteq> NT\\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> t1 \\<le> exec_lub (widen1 P) (super P) t1\n       t2 \\<and>\n                    P \\<turnstile> t2 \\<le> exec_lub (widen1 P) (super P) t1\n       t2\n\ngoal (1 subgoal):\n 1. P \\<turnstile> t1 \\<le> s \\<and> P \\<turnstile> t2 \\<le> s", "with it1 it2 sup"], ["proof (chain)\npicking this:\n  is_type P t1\n  is_type P t2\n  SemiType.sup P t1 t2 = OK s\n  \\<lbrakk>is_refT t1; is_refT t2; t1 \\<noteq> NT; t2 \\<noteq> NT\\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> t1 \\<le> exec_lub (widen1 P) (super P) t1\n       t2 \\<and>\n                    P \\<turnstile> t2 \\<le> exec_lub (widen1 P) (super P) t1\n       t2", "show ?thesis"], ["proof (prove)\nusing this:\n  is_type P t1\n  is_type P t2\n  SemiType.sup P t1 t2 = OK s\n  \\<lbrakk>is_refT t1; is_refT t2; t1 \\<noteq> NT; t2 \\<noteq> NT\\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> t1 \\<le> exec_lub (widen1 P) (super P) t1\n       t2 \\<and>\n                    P \\<turnstile> t2 \\<le> exec_lub (widen1 P) (super P) t1\n       t2\n\ngoal (1 subgoal):\n 1. P \\<turnstile> t1 \\<le> s \\<and> P \\<turnstile> t2 \\<le> s", "by (cases s) (auto simp add: sup_def split: if_split_asm elim: refTE)"], ["proof (state)\nthis:\n  P \\<turnstile> t1 \\<le> s \\<and> P \\<turnstile> t2 \\<le> s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sup_widen_smallest:\n  assumes wfP: \"wf_prog wf_mb P\"\n  and itT: \"is_type P T\"\n  and itU: \"is_type P U\"\n  and TwV: \"P \\<turnstile> T \\<le> V\"\n  and UwV: \"P \\<turnstile> U \\<le> V\"\n  and sup: \"sup P T U = OK W\"\n  shows \"widen P W V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> W \\<le> V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<turnstile> W \\<le> V", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<turnstile> W \\<le> V", "assume rT: \"is_refT T\"\n      and rU: \"is_refT U\"\n      and UNT: \"U \\<noteq> NT\"\n      and TNT: \"T \\<noteq> NT\"\n      and W: \"exec_lub (widen1 P) (super P) T U = W\""], ["proof (state)\nthis:\n  is_refT T\n  is_refT U\n  U \\<noteq> NT\n  T \\<noteq> NT\n  exec_lub (widen1 P) (super P) T U = W\n\ngoal (1 subgoal):\n 1. P \\<turnstile> W \\<le> V", "from itU itT rT rU UNT TNT"], ["proof (chain)\npicking this:\n  is_type P U\n  is_type P T\n  is_refT T\n  is_refT U\n  U \\<noteq> NT\n  T \\<noteq> NT", "have \"P \\<turnstile> T \\<le> Class Object\" \"P \\<turnstile> U \\<le> Class Object\""], ["proof (prove)\nusing this:\n  is_type P U\n  is_type P T\n  is_refT T\n  is_refT U\n  U \\<noteq> NT\n  T \\<noteq> NT\n\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> Class Object &&&\n    P \\<turnstile> U \\<le> Class Object", "by(auto intro:is_refType_widen_Object[OF wfP])"], ["proof (state)\nthis:\n  P \\<turnstile> T \\<le> Class Object\n  P \\<turnstile> U \\<le> Class Object\n\ngoal (1 subgoal):\n 1. P \\<turnstile> W \\<le> V", "with UNT TNT itT itU"], ["proof (chain)\npicking this:\n  U \\<noteq> NT\n  T \\<noteq> NT\n  is_type P T\n  is_type P U\n  P \\<turnstile> T \\<le> Class Object\n  P \\<turnstile> U \\<le> Class Object", "have \"P \\<turnstile> T <\\<^sup>* Class Object\" \"P \\<turnstile> U <\\<^sup>* Class Object\""], ["proof (prove)\nusing this:\n  U \\<noteq> NT\n  T \\<noteq> NT\n  is_type P T\n  is_type P U\n  P \\<turnstile> T \\<le> Class Object\n  P \\<turnstile> U \\<le> Class Object\n\ngoal (1 subgoal):\n 1. P \\<turnstile> T <\\<^sup>* Class Object &&&\n    P \\<turnstile> U <\\<^sup>* Class Object", "by(auto intro: widen_into_widen1_rtrancl[OF wfP])"], ["proof (state)\nthis:\n  P \\<turnstile> T <\\<^sup>* Class Object\n  P \\<turnstile> U <\\<^sup>* Class Object\n\ngoal (1 subgoal):\n 1. P \\<turnstile> W \\<le> V", "with single_valued_widen1[OF wfP]"], ["proof (chain)\npicking this:\n  single_valued (widen1 P)\n  P \\<turnstile> T <\\<^sup>* Class Object\n  P \\<turnstile> U <\\<^sup>* Class Object", "obtain X where lub: \"is_lub ((widen1 P)^* ) T U X\""], ["proof (prove)\nusing this:\n  single_valued (widen1 P)\n  P \\<turnstile> T <\\<^sup>* Class Object\n  P \\<turnstile> U <\\<^sup>* Class Object\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        Semilat.is_lub ((widen1 P)\\<^sup>*) T U X \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: single_valued_has_lubs)"], ["proof (state)\nthis:\n  Semilat.is_lub ((widen1 P)\\<^sup>*) T U X\n\ngoal (1 subgoal):\n 1. P \\<turnstile> W \\<le> V", "with acyclic_widen1[OF wfP]"], ["proof (chain)\npicking this:\n  acyclic (widen1 P)\n  Semilat.is_lub ((widen1 P)\\<^sup>*) T U X", "have \"exec_lub (widen1 P) (super P) T U = X\""], ["proof (prove)\nusing this:\n  acyclic (widen1 P)\n  Semilat.is_lub ((widen1 P)\\<^sup>*) T U X\n\ngoal (1 subgoal):\n 1. exec_lub (widen1 P) (super P) T U = X", "by (blast intro: superI exec_lub_conv)"], ["proof (state)\nthis:\n  exec_lub (widen1 P) (super P) T U = X\n\ngoal (1 subgoal):\n 1. P \\<turnstile> W \\<le> V", "also"], ["proof (state)\nthis:\n  exec_lub (widen1 P) (super P) T U = X\n\ngoal (1 subgoal):\n 1. P \\<turnstile> W \\<le> V", "from TwV TNT UwV UNT itT itU"], ["proof (chain)\npicking this:\n  P \\<turnstile> T \\<le> V\n  T \\<noteq> NT\n  P \\<turnstile> U \\<le> V\n  U \\<noteq> NT\n  is_type P T\n  is_type P U", "have \"P \\<turnstile> T <\\<^sup>* V\" \"P \\<turnstile> U <\\<^sup>* V\""], ["proof (prove)\nusing this:\n  P \\<turnstile> T \\<le> V\n  T \\<noteq> NT\n  P \\<turnstile> U \\<le> V\n  U \\<noteq> NT\n  is_type P T\n  is_type P U\n\ngoal (1 subgoal):\n 1. P \\<turnstile> T <\\<^sup>* V &&& P \\<turnstile> U <\\<^sup>* V", "by(auto intro: widen_into_widen1_rtrancl[OF wfP])"], ["proof (state)\nthis:\n  P \\<turnstile> T <\\<^sup>* V\n  P \\<turnstile> U <\\<^sup>* V\n\ngoal (1 subgoal):\n 1. P \\<turnstile> W \\<le> V", "with lub"], ["proof (chain)\npicking this:\n  Semilat.is_lub ((widen1 P)\\<^sup>*) T U X\n  P \\<turnstile> T <\\<^sup>* V\n  P \\<turnstile> U <\\<^sup>* V", "have \"P \\<turnstile> X <\\<^sup>* V\""], ["proof (prove)\nusing this:\n  Semilat.is_lub ((widen1 P)\\<^sup>*) T U X\n  P \\<turnstile> T <\\<^sup>* V\n  P \\<turnstile> U <\\<^sup>* V\n\ngoal (1 subgoal):\n 1. P \\<turnstile> X <\\<^sup>* V", "by (clarsimp simp add: is_lub_def is_ub_def)"], ["proof (state)\nthis:\n  P \\<turnstile> X <\\<^sup>* V\n\ngoal (1 subgoal):\n 1. P \\<turnstile> W \\<le> V", "finally"], ["proof (chain)\npicking this:\n  P \\<turnstile> exec_lub (widen1 P) (super P) T U <\\<^sup>* V", "have \"P \\<turnstile> exec_lub (widen1 P) (super P) T U \\<le> V\""], ["proof (prove)\nusing this:\n  P \\<turnstile> exec_lub (widen1 P) (super P) T U <\\<^sup>* V\n\ngoal (1 subgoal):\n 1. P \\<turnstile> exec_lub (widen1 P) (super P) T U \\<le> V", "by(rule widen1_rtrancl_into_widen)"], ["proof (state)\nthis:\n  P \\<turnstile> exec_lub (widen1 P) (super P) T U \\<le> V\n\ngoal (1 subgoal):\n 1. P \\<turnstile> W \\<le> V", "with W"], ["proof (chain)\npicking this:\n  exec_lub (widen1 P) (super P) T U = W\n  P \\<turnstile> exec_lub (widen1 P) (super P) T U \\<le> V", "have \"P \\<turnstile> W \\<le> V\""], ["proof (prove)\nusing this:\n  exec_lub (widen1 P) (super P) T U = W\n  P \\<turnstile> exec_lub (widen1 P) (super P) T U \\<le> V\n\ngoal (1 subgoal):\n 1. P \\<turnstile> W \\<le> V", "by simp"], ["proof (state)\nthis:\n  P \\<turnstile> W \\<le> V\n\ngoal (1 subgoal):\n 1. P \\<turnstile> W \\<le> V", "}"], ["proof (state)\nthis:\n  \\<lbrakk>is_refT T; is_refT U; U \\<noteq> NT; T \\<noteq> NT;\n   exec_lub (widen1 P) (super P) T U = W\\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> W \\<le> V\n\ngoal (1 subgoal):\n 1. P \\<turnstile> W \\<le> V", "with sup itT itU TwV UwV"], ["proof (chain)\npicking this:\n  SemiType.sup P T U = OK W\n  is_type P T\n  is_type P U\n  P \\<turnstile> T \\<le> V\n  P \\<turnstile> U \\<le> V\n  \\<lbrakk>is_refT T; is_refT U; U \\<noteq> NT; T \\<noteq> NT;\n   exec_lub (widen1 P) (super P) T U = W\\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> W \\<le> V", "show ?thesis"], ["proof (prove)\nusing this:\n  SemiType.sup P T U = OK W\n  is_type P T\n  is_type P U\n  P \\<turnstile> T \\<le> V\n  P \\<turnstile> U \\<le> V\n  \\<lbrakk>is_refT T; is_refT U; U \\<noteq> NT; T \\<noteq> NT;\n   exec_lub (widen1 P) (super P) T U = W\\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> W \\<le> V\n\ngoal (1 subgoal):\n 1. P \\<turnstile> W \\<le> V", "by(simp add: sup_def split: if_split_asm)"], ["proof (state)\nthis:\n  P \\<turnstile> W \\<le> V\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sup_exists:\n  \"\\<lbrakk> widen P a c; widen P b c \\<rbrakk> \\<Longrightarrow> \\<exists>T. sup P a b = OK T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> a \\<le> c; P \\<turnstile> b \\<le> c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T. SemiType.sup P a b = OK T", "by(cases b a rule: ty.exhaust[case_product ty.exhaust])(auto simp add: sup_def)"], ["", "lemma err_semilat_JType_esl:\n  assumes wf_prog: \"wf_prog wf_mb P\"\n  shows \"err_semilat (esl P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. err_semilat (SemiType.esl P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. err_semilat (SemiType.esl P)", "from wf_prog"], ["proof (chain)\npicking this:\n  wf_prog wf_mb P", "have \"order (widen P)\""], ["proof (prove)\nusing this:\n  wf_prog wf_mb P\n\ngoal (1 subgoal):\n 1. order (widen P)", ".."], ["proof (state)\nthis:\n  order (widen P)\n\ngoal (1 subgoal):\n 1. err_semilat (SemiType.esl P)", "moreover"], ["proof (state)\nthis:\n  order (widen P)\n\ngoal (1 subgoal):\n 1. err_semilat (SemiType.esl P)", "from wf_prog"], ["proof (chain)\npicking this:\n  wf_prog wf_mb P", "have \"closed (err (types P)) (lift2 (sup P))\""], ["proof (prove)\nusing this:\n  wf_prog wf_mb P\n\ngoal (1 subgoal):\n 1. Semilat.closed (err (types P)) (lift2 (SemiType.sup P))", "by (rule closed_err_types)"], ["proof (state)\nthis:\n  Semilat.closed (err (types P)) (lift2 (SemiType.sup P))\n\ngoal (1 subgoal):\n 1. err_semilat (SemiType.esl P)", "moreover"], ["proof (state)\nthis:\n  Semilat.closed (err (types P)) (lift2 (SemiType.sup P))\n\ngoal (1 subgoal):\n 1. err_semilat (SemiType.esl P)", "from wf_prog"], ["proof (chain)\npicking this:\n  wf_prog wf_mb P", "have\n    \"(\\<forall>x\\<in>err (types P). \\<forall>y\\<in>err (types P). x \\<sqsubseteq>\\<^bsub>Err.le (widen P)\\<^esub> x \\<squnion>\\<^bsub>lift2 (sup P)\\<^esub> y) \\<and> \n     (\\<forall>x\\<in>err (types P). \\<forall>y\\<in>err (types P). y \\<sqsubseteq>\\<^bsub>Err.le (widen P)\\<^esub> x \\<squnion>\\<^bsub>lift2 (sup P)\\<^esub> y)\""], ["proof (prove)\nusing this:\n  wf_prog wf_mb P\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>err (types P).\n        \\<forall>y\\<in>err (types P).\n           x \\<sqsubseteq>\\<^bsub>Err.le\n                                   (widen\n                                     P)\\<^esub> x \n          \\<squnion>\\<^bsub>lift2 (SemiType.sup P)\\<^esub> y) \\<and>\n    (\\<forall>x\\<in>err (types P).\n        \\<forall>y\\<in>err (types P).\n           y \\<sqsubseteq>\\<^bsub>Err.le\n                                   (widen\n                                     P)\\<^esub> x \n          \\<squnion>\\<^bsub>lift2 (SemiType.sup P)\\<^esub> y)", "by(auto simp add: lesub_def plussub_def Err.le_def lift2_def sup_widen_greater split: err.split)"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>err (types P).\n      \\<forall>y\\<in>err (types P).\n         x \\<sqsubseteq>\\<^bsub>Err.le\n                                 (widen\n                                   P)\\<^esub> x \n        \\<squnion>\\<^bsub>lift2 (SemiType.sup P)\\<^esub> y) \\<and>\n  (\\<forall>x\\<in>err (types P).\n      \\<forall>y\\<in>err (types P).\n         y \\<sqsubseteq>\\<^bsub>Err.le\n                                 (widen\n                                   P)\\<^esub> x \n        \\<squnion>\\<^bsub>lift2 (SemiType.sup P)\\<^esub> y)\n\ngoal (1 subgoal):\n 1. err_semilat (SemiType.esl P)", "moreover"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>err (types P).\n      \\<forall>y\\<in>err (types P).\n         x \\<sqsubseteq>\\<^bsub>Err.le\n                                 (widen\n                                   P)\\<^esub> x \n        \\<squnion>\\<^bsub>lift2 (SemiType.sup P)\\<^esub> y) \\<and>\n  (\\<forall>x\\<in>err (types P).\n      \\<forall>y\\<in>err (types P).\n         y \\<sqsubseteq>\\<^bsub>Err.le\n                                 (widen\n                                   P)\\<^esub> x \n        \\<squnion>\\<^bsub>lift2 (SemiType.sup P)\\<^esub> y)\n\ngoal (1 subgoal):\n 1. err_semilat (SemiType.esl P)", "from wf_prog"], ["proof (chain)\npicking this:\n  wf_prog wf_mb P", "have\n    \"\\<forall>x\\<in>err (types P). \\<forall>y\\<in>err (types P). \\<forall>z\\<in>err (types P). \n    x \\<sqsubseteq>\\<^bsub>Err.le (widen P)\\<^esub> z \\<and> y \\<sqsubseteq>\\<^bsub>Err.le (widen P)\\<^esub> z \\<longrightarrow> x \\<squnion>\\<^bsub>lift2 (sup P)\\<^esub> y \\<sqsubseteq>\\<^bsub>Err.le (widen P)\\<^esub> z\""], ["proof (prove)\nusing this:\n  wf_prog wf_mb P\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>err (types P).\n       \\<forall>y\\<in>err (types P).\n          \\<forall>z\\<in>err (types P).\n             x \\<sqsubseteq>\\<^bsub>Err.le (widen P)\\<^esub> z \\<and>\n             y \\<sqsubseteq>\\<^bsub>Err.le\n                                     (widen P)\\<^esub> z \\<longrightarrow>\n             x \\<squnion>\\<^bsub>lift2 (SemiType.sup P)\\<^esub> y \n             \\<sqsubseteq>\\<^bsub>Err.le (widen P)\\<^esub> z", "unfolding lift2_def plussub_def lesub_def Err.le_def"], ["proof (prove)\nusing this:\n  wf_prog wf_mb P\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>err (types P).\n       \\<forall>y\\<in>err (types P).\n          \\<forall>z\\<in>err (types P).\n             (case z of Err \\<Rightarrow> True\n              | OK y \\<Rightarrow>\n                  case x of Err \\<Rightarrow> False\n                  | OK x \\<Rightarrow> P \\<turnstile> x \\<le> y) \\<and>\n             (case z of Err \\<Rightarrow> True\n              | OK ya \\<Rightarrow>\n                  case y of Err \\<Rightarrow> False\n                  | OK x \\<Rightarrow>\n                      P \\<turnstile> x \\<le> ya) \\<longrightarrow>\n             (case z of Err \\<Rightarrow> True\n              | OK ya \\<Rightarrow>\n                  case case x of Err \\<Rightarrow> Err\n                       | OK x \\<Rightarrow>\n                           case y of Err \\<Rightarrow> Err\n                           | OK xa \\<Rightarrow> SemiType.sup P x xa of\n                  Err \\<Rightarrow> False\n                  | OK x \\<Rightarrow> P \\<turnstile> x \\<le> ya)", "by(auto intro: sup_widen_smallest dest:sup_exists simp add: split: err.split)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>err (types P).\n     \\<forall>y\\<in>err (types P).\n        \\<forall>z\\<in>err (types P).\n           x \\<sqsubseteq>\\<^bsub>Err.le (widen P)\\<^esub> z \\<and>\n           y \\<sqsubseteq>\\<^bsub>Err.le\n                                   (widen P)\\<^esub> z \\<longrightarrow>\n           x \\<squnion>\\<^bsub>lift2 (SemiType.sup P)\\<^esub> y \n           \\<sqsubseteq>\\<^bsub>Err.le (widen P)\\<^esub> z\n\ngoal (1 subgoal):\n 1. err_semilat (SemiType.esl P)", "ultimately"], ["proof (chain)\npicking this:\n  order (widen P)\n  Semilat.closed (err (types P)) (lift2 (SemiType.sup P))\n  (\\<forall>x\\<in>err (types P).\n      \\<forall>y\\<in>err (types P).\n         x \\<sqsubseteq>\\<^bsub>Err.le\n                                 (widen\n                                   P)\\<^esub> x \n        \\<squnion>\\<^bsub>lift2 (SemiType.sup P)\\<^esub> y) \\<and>\n  (\\<forall>x\\<in>err (types P).\n      \\<forall>y\\<in>err (types P).\n         y \\<sqsubseteq>\\<^bsub>Err.le\n                                 (widen\n                                   P)\\<^esub> x \n        \\<squnion>\\<^bsub>lift2 (SemiType.sup P)\\<^esub> y)\n  \\<forall>x\\<in>err (types P).\n     \\<forall>y\\<in>err (types P).\n        \\<forall>z\\<in>err (types P).\n           x \\<sqsubseteq>\\<^bsub>Err.le (widen P)\\<^esub> z \\<and>\n           y \\<sqsubseteq>\\<^bsub>Err.le\n                                   (widen P)\\<^esub> z \\<longrightarrow>\n           x \\<squnion>\\<^bsub>lift2 (SemiType.sup P)\\<^esub> y \n           \\<sqsubseteq>\\<^bsub>Err.le (widen P)\\<^esub> z", "show ?thesis"], ["proof (prove)\nusing this:\n  order (widen P)\n  Semilat.closed (err (types P)) (lift2 (SemiType.sup P))\n  (\\<forall>x\\<in>err (types P).\n      \\<forall>y\\<in>err (types P).\n         x \\<sqsubseteq>\\<^bsub>Err.le\n                                 (widen\n                                   P)\\<^esub> x \n        \\<squnion>\\<^bsub>lift2 (SemiType.sup P)\\<^esub> y) \\<and>\n  (\\<forall>x\\<in>err (types P).\n      \\<forall>y\\<in>err (types P).\n         y \\<sqsubseteq>\\<^bsub>Err.le\n                                 (widen\n                                   P)\\<^esub> x \n        \\<squnion>\\<^bsub>lift2 (SemiType.sup P)\\<^esub> y)\n  \\<forall>x\\<in>err (types P).\n     \\<forall>y\\<in>err (types P).\n        \\<forall>z\\<in>err (types P).\n           x \\<sqsubseteq>\\<^bsub>Err.le (widen P)\\<^esub> z \\<and>\n           y \\<sqsubseteq>\\<^bsub>Err.le\n                                   (widen P)\\<^esub> z \\<longrightarrow>\n           x \\<squnion>\\<^bsub>lift2 (SemiType.sup P)\\<^esub> y \n           \\<sqsubseteq>\\<^bsub>Err.le (widen P)\\<^esub> z\n\ngoal (1 subgoal):\n 1. err_semilat (SemiType.esl P)", "by (simp add: esl_def semilat_def sl_def Err.sl_def)"], ["proof (state)\nthis:\n  err_semilat (SemiType.esl P)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Relation between @{term \"sup P T U = OK V\"} and @{term \"P \\<turnstile> lub(T, U) = V\"}\\<close>"], ["", "lemma sup_is_lubI:\n  assumes wf: \"wf_prog wf_md P\"\n  and it: \"is_type P T\" \"is_type P U\"\n  and sup: \"sup P T U = OK V\"\n  shows \"P \\<turnstile> lub(T, U) = V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> lub(T, U) = V", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. P \\<turnstile> T \\<le> V\n 2. P \\<turnstile> U \\<le> V\n 3. \\<And>T'.\n       \\<lbrakk>P \\<turnstile> T \\<le> T';\n        P \\<turnstile> U \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> V \\<le> T'", "from sup_widen_greater[OF wf it sup]"], ["proof (chain)\npicking this:\n  P \\<turnstile> T \\<le> V \\<and> P \\<turnstile> U \\<le> V", "show \"P \\<turnstile> T \\<le> V\" \"P \\<turnstile> U \\<le> V\""], ["proof (prove)\nusing this:\n  P \\<turnstile> T \\<le> V \\<and> P \\<turnstile> U \\<le> V\n\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> V &&& P \\<turnstile> U \\<le> V", "by blast+"], ["proof (state)\nthis:\n  P \\<turnstile> T \\<le> V\n  P \\<turnstile> U \\<le> V\n\ngoal (1 subgoal):\n 1. \\<And>T'.\n       \\<lbrakk>P \\<turnstile> T \\<le> T';\n        P \\<turnstile> U \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> V \\<le> T'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T'.\n       \\<lbrakk>P \\<turnstile> T \\<le> T';\n        P \\<turnstile> U \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> V \\<le> T'", "fix T'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T'.\n       \\<lbrakk>P \\<turnstile> T \\<le> T';\n        P \\<turnstile> U \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> V \\<le> T'", "assume \"P \\<turnstile> T \\<le> T'\" \"P \\<turnstile> U \\<le> T'\""], ["proof (state)\nthis:\n  P \\<turnstile> T \\<le> T'\n  P \\<turnstile> U \\<le> T'\n\ngoal (1 subgoal):\n 1. \\<And>T'.\n       \\<lbrakk>P \\<turnstile> T \\<le> T';\n        P \\<turnstile> U \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> V \\<le> T'", "thus \"P \\<turnstile> V \\<le> T'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> T \\<le> T'\n  P \\<turnstile> U \\<le> T'\n\ngoal (1 subgoal):\n 1. P \\<turnstile> V \\<le> T'", "using sup"], ["proof (prove)\nusing this:\n  P \\<turnstile> T \\<le> T'\n  P \\<turnstile> U \\<le> T'\n  SemiType.sup P T U = OK V\n\ngoal (1 subgoal):\n 1. P \\<turnstile> V \\<le> T'", "by(rule sup_widen_smallest[OF wf it])"], ["proof (state)\nthis:\n  P \\<turnstile> V \\<le> T'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_lub_subD:\n  assumes wf: \"wf_prog wf_md P\"\n  and it: \"is_type P T\" \"is_type P U\"\n  and lub: \"P \\<turnstile> lub(T, U) = V\"\n  shows \"sup P T U = OK V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SemiType.sup P T U = OK V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. SemiType.sup P T U = OK V", "from lub"], ["proof (chain)\npicking this:\n  P \\<turnstile> lub(T, U) = V", "have \"P \\<turnstile> T \\<le> V\" \"P \\<turnstile> U \\<le> V\""], ["proof (prove)\nusing this:\n  P \\<turnstile> lub(T, U) = V\n\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> V &&& P \\<turnstile> U \\<le> V", "by(blast dest: is_lub_upper)+"], ["proof (state)\nthis:\n  P \\<turnstile> T \\<le> V\n  P \\<turnstile> U \\<le> V\n\ngoal (1 subgoal):\n 1. SemiType.sup P T U = OK V", "from sup_exists[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>Ta. SemiType.sup P T U = OK Ta", "obtain W where \"sup P T U = OK W\""], ["proof (prove)\nusing this:\n  \\<exists>Ta. SemiType.sup P T U = OK Ta\n\ngoal (1 subgoal):\n 1. (\\<And>W.\n        SemiType.sup P T U = OK W \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  SemiType.sup P T U = OK W\n\ngoal (1 subgoal):\n 1. SemiType.sup P T U = OK V", "moreover"], ["proof (state)\nthis:\n  SemiType.sup P T U = OK W\n\ngoal (1 subgoal):\n 1. SemiType.sup P T U = OK V", "with wf it"], ["proof (chain)\npicking this:\n  wf_prog wf_md P\n  is_type P T\n  is_type P U\n  SemiType.sup P T U = OK W", "have \"P \\<turnstile> lub(T, U) = W\""], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  is_type P T\n  is_type P U\n  SemiType.sup P T U = OK W\n\ngoal (1 subgoal):\n 1. P \\<turnstile> lub(T, U) = W", "by(rule sup_is_lubI)"], ["proof (state)\nthis:\n  P \\<turnstile> lub(T, U) = W\n\ngoal (1 subgoal):\n 1. SemiType.sup P T U = OK V", "with lub"], ["proof (chain)\npicking this:\n  P \\<turnstile> lub(T, U) = V\n  P \\<turnstile> lub(T, U) = W", "have \"V = W\""], ["proof (prove)\nusing this:\n  P \\<turnstile> lub(T, U) = V\n  P \\<turnstile> lub(T, U) = W\n\ngoal (1 subgoal):\n 1. V = W", "by(auto dest: is_lub_unique[OF wf])"], ["proof (state)\nthis:\n  V = W\n\ngoal (1 subgoal):\n 1. SemiType.sup P T U = OK V", "ultimately"], ["proof (chain)\npicking this:\n  SemiType.sup P T U = OK W\n  V = W", "show ?thesis"], ["proof (prove)\nusing this:\n  SemiType.sup P T U = OK W\n  V = W\n\ngoal (1 subgoal):\n 1. SemiType.sup P T U = OK V", "by simp"], ["proof (state)\nthis:\n  SemiType.sup P T U = OK V\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_lub_is_type:\n  \"\\<lbrakk> wf_prog wf_md P; is_type P T; is_type P U; P \\<turnstile> lub(T, U) = V \\<rbrakk> \\<Longrightarrow> is_type P V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; is_type P T; is_type P U;\n     P \\<turnstile> lub(T, U) = V\\<rbrakk>\n    \\<Longrightarrow> is_type P V", "by(frule (3) is_lub_subD)(erule (3) sup_is_type)"], ["", "subsection \\<open>Code generator setup\\<close>"], ["", "code_pred widen1p"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemmas [code] = widen1_def"], ["", "lemma eval_widen1p_i_i_o_conv:\n  \"Predicate.eval (widen1p_i_i_o P T) = (\\<lambda>U. P \\<turnstile> T <\\<^sup>1 U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred.eval (widen1p_i_i_o P T) = widen1_syntax P T", "by(auto elim: widen1p_i_i_oE intro: widen1p_i_i_oI simp add: widen1_def fun_eq_iff)"], ["", "lemma rtrancl_widen1_code [code_unfold]:\n  \"(widen1 P)^* = {(a, b). Predicate.holds (rtrancl_tab_FioB_i_i_i (widen1p_i_i_o P) [] a b)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (widen1 P)\\<^sup>* =\n    {(a, b).\n     Predicate.holds (rtrancl_tab_FioB_i_i_i (widen1p_i_i_o P) [] a b)}", "by(auto simp add: fun_eq_iff Predicate.holds_eq widen1_def rtrancl_def rtranclp_eq_rtrancl_tab_nil eval_widen1p_i_i_o_conv intro!: rtrancl_tab_FioB_i_i_iI elim!: rtrancl_tab_FioB_i_i_iE)"], ["", "declare exec_lub_def [code_unfold]"], ["", "end"]]}