{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Framework/Bisimulation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma bisimulation_flip:\n  \"bisimulation trsys2 trsys1 (flip bisim) (flip tlsim)\"", "lemma bisimulation_flip_simps [flip_simps]:\n  \"bisimulation trsys2 trsys1 (flip bisim) (flip tlsim) = bisimulation trsys1 trsys2 bisim tlsim\"", "lemma simulation1_rtrancl:\n  \"\\<lbrakk>s1 -1-tls1\\<rightarrow>* s1'; s1 \\<approx> s2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s2' tls2. s2 -2-tls2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2' \\<and> tls1 [\\<sim>] tls2\"", "lemma simulation2_rtrancl:\n  \"\\<lbrakk>s2 -2-tls2\\<rightarrow>* s2'; s1 \\<approx> s2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s1' tls1. s1 -1-tls1\\<rightarrow>* s1' \\<and> s1' \\<approx> s2' \\<and> tls1 [\\<sim>] tls2\"", "lemma simulation1_inf_step:\n  assumes red1: \"s1 -1-tls1\\<rightarrow>* \\<infinity>\" and bisim: \"s1 \\<approx> s2\"\n  shows \"\\<exists>tls2. s2 -2-tls2\\<rightarrow>* \\<infinity> \\<and> tls1 [[\\<sim>]] tls2\"", "lemma simulation2_inf_step:\n  \"\\<lbrakk> s2 -2-tls2\\<rightarrow>* \\<infinity>; s1 \\<approx> s2 \\<rbrakk> \\<Longrightarrow> \\<exists>tls1. s1 -1-tls1\\<rightarrow>* \\<infinity> \\<and> tls1 [[\\<sim>]] tls2\"", "lemma bisimulation_final_flip:\n  \"bisimulation_final trsys2 trsys1 (flip bisim) (flip tlsim) final2 final1\"", "lemma bisimulation_final_flip_simps [flip_simps]:\n  \"bisimulation_final trsys2 trsys1 (flip bisim) (flip tlsim) final2 final1 =\n   bisimulation_final trsys1 trsys2 bisim tlsim final1 final2\"", "lemma final_simulation1:\n  \"\\<lbrakk> s1 \\<approx> s2; s1 -1-tls1\\<rightarrow>* s1'; final1 s1' \\<rbrakk>\n  \\<Longrightarrow> \\<exists>s2' tls2. s2 -2-tls2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2' \\<and> final2 s2' \\<and> tls1 [\\<sim>] tls2\"", "lemma final_simulation2:\n  \"\\<lbrakk> s1 \\<approx> s2; s2 -2-tls2\\<rightarrow>* s2'; final2 s2' \\<rbrakk>\n  \\<Longrightarrow> \\<exists>s1' tls1. s1 -1-tls1\\<rightarrow>* s1' \\<and> s1' \\<approx> s2' \\<and> final1 s1' \\<and> tls1 [\\<sim>] tls2\"", "lemma simulation_silent1I':\n  assumes \"\\<exists>s2'. (if \\<mu>1 s1' s1 then trsys2.silent_moves else trsys2.silent_movet) s2 s2' \\<and> s1' \\<approx> s2'\"\n  shows \"s1' \\<approx> s2 \\<and> \\<mu>1^++ s1' s1 \\<or> (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')\"", "lemma simulation_silent2I':\n  assumes \"\\<exists>s1'. (if \\<mu>2 s2' s2 then trsys1.silent_moves else trsys1.silent_movet) s1 s1' \\<and> s1' \\<approx> s2'\"\n  shows \"s1 \\<approx> s2' \\<and> \\<mu>2^++ s2' s2 \\<or> (\\<exists>s1'. s1 -\\<tau>1\\<rightarrow>+ s1' \\<and> s1' \\<approx> s2')\"", "lemma delay_bisimulation_obs_flip: \"delay_bisimulation_obs trsys2 trsys1 (flip bisim) (flip tlsim) \\<tau>move2 \\<tau>move1\"", "lemma delay_bisimulation_obs_flip_simps [flip_simps]:\n  \"delay_bisimulation_obs trsys2 trsys1 (flip bisim) (flip tlsim) \\<tau>move2 \\<tau>move1 =\n   delay_bisimulation_obs trsys1 trsys2 bisim tlsim \\<tau>move1 \\<tau>move2\"", "lemma delay_bisimulation_diverge_flip: \"delay_bisimulation_diverge trsys2 trsys1 (flip bisim) (flip tlsim) \\<tau>move2 \\<tau>move1\"", "lemma delay_bisimulation_diverge_flip_simps [flip_simps]:\n  \"delay_bisimulation_diverge trsys2 trsys1 (flip bisim) (flip tlsim) \\<tau>move2 \\<tau>move1 =\n   delay_bisimulation_diverge trsys1 trsys2 bisim tlsim \\<tau>move1 \\<tau>move2\"", "lemma simulation_silents1:\n  assumes bisim: \"s1 \\<approx> s2\" and moves: \"s1 -\\<tau>1\\<rightarrow>* s1'\"\n  shows \"\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2'\"", "lemma simulation_silents2:\n  \"\\<lbrakk> s1 \\<approx> s2; s2 -\\<tau>2\\<rightarrow>* s2' \\<rbrakk> \\<Longrightarrow> \\<exists>s1'. s1 -\\<tau>1\\<rightarrow>* s1' \\<and> s1' \\<approx> s2'\"", "lemma simulation1_\\<tau>rtrancl3p:\n  \"\\<lbrakk> s1 -\\<tau>1-tls1\\<rightarrow>* s1'; s1 \\<approx> s2 \\<rbrakk>\n  \\<Longrightarrow> \\<exists>tls2 s2'. s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2' \\<and> tls1 [\\<sim>] tls2\"", "lemma simulation2_\\<tau>rtrancl3p:\n  \"\\<lbrakk> s2 -\\<tau>2-tls2\\<rightarrow>* s2'; s1 \\<approx> s2 \\<rbrakk>\n  \\<Longrightarrow> \\<exists>tls1 s1'. s1 -\\<tau>1-tls1\\<rightarrow>* s1' \\<and> s1' \\<approx> s2' \\<and> tls1 [\\<sim>] tls2\"", "lemma simulation1_\\<tau>inf_step:\n  assumes \\<tau>inf1: \"s1 -\\<tau>1-tls1\\<rightarrow>* \\<infinity>\" and bisim: \"s1 \\<approx> s2\"\n  shows \"\\<exists>tls2. s2 -\\<tau>2-tls2\\<rightarrow>* \\<infinity> \\<and> tls1 [[\\<sim>]] tls2\"", "lemma simulation2_\\<tau>inf_step:\n  \"\\<lbrakk> s2 -\\<tau>2-tls2\\<rightarrow>* \\<infinity>; s1 \\<approx> s2 \\<rbrakk> \\<Longrightarrow> \\<exists>tls1. s1 -\\<tau>1-tls1\\<rightarrow>* \\<infinity> \\<and> tls1 [[\\<sim>]] tls2\"", "lemma no_\\<tau>move1_\\<tau>s_to_no_\\<tau>move2:\n  assumes \"s1 \\<approx> s2\"\n  and no_\\<tau>moves1: \"\\<And>s1'. \\<not> s1 -\\<tau>1\\<rightarrow> s1'\"\n  shows \"\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> (\\<forall>s2''. \\<not> s2' -\\<tau>2\\<rightarrow> s2'') \\<and> s1 \\<approx> s2'\"", "lemma no_\\<tau>move2_\\<tau>s_to_no_\\<tau>move1:\n  \"\\<lbrakk> s1 \\<approx> s2; \\<And>s2'. \\<not> s2 -\\<tau>2\\<rightarrow> s2' \\<rbrakk> \\<Longrightarrow> \\<exists>s1'. s1 -\\<tau>1\\<rightarrow>* s1' \\<and> (\\<forall>s1''. \\<not> s1' -\\<tau>1\\<rightarrow> s1'') \\<and> s1' \\<approx> s2\"", "lemma no_move1_to_no_move2:\n  assumes \"s1 \\<approx> s2\"\n  and no_moves1: \"\\<And>tl1 s1'. \\<not> s1 -1-tl1\\<rightarrow> s1'\"\n  shows \"\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> (\\<forall>tl2 s2''. \\<not> s2' -2-tl2\\<rightarrow> s2'') \\<and> s1 \\<approx> s2'\"", "lemma no_move2_to_no_move1:\n  \"\\<lbrakk> s1 \\<approx> s2; \\<And>tl2 s2'. \\<not> s2 -2-tl2\\<rightarrow> s2' \\<rbrakk>\n  \\<Longrightarrow> \\<exists>s1'. s1 -\\<tau>1\\<rightarrow>* s1' \\<and> (\\<forall>tl1 s1''. \\<not> s1' -1-tl1\\<rightarrow> s1'') \\<and> s1' \\<approx> s2\"", "lemma simulation_\\<tau>Runs_table1:\n  assumes bisim: \"s1 \\<approx> s2\"\n  and run1: \"trsys1.\\<tau>Runs_table s1 stlsss1\"\n  shows \"\\<exists>stlsss2. trsys2.\\<tau>Runs_table s2 stlsss2 \\<and> tllist_all2 (\\<lambda>(tl1, s1'') (tl2, s2''). tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'') (rel_option bisim) stlsss1 stlsss2\"", "lemma simulation_\\<tau>Runs_table2:\n  assumes \"s1 \\<approx> s2\"\n  and \"trsys2.\\<tau>Runs_table s2 stlsss2\"\n  shows \"\\<exists>stlsss1. trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> tllist_all2 (\\<lambda>(tl1, s1'') (tl2, s2''). tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'') (rel_option bisim) stlsss1 stlsss2\"", "lemma simulation_\\<tau>Runs1:\n  assumes bisim: \"s1 \\<approx> s2\"\n  and run1: \"s1 \\<Down>1 tls1\"\n  shows \"\\<exists>tls2. s2 \\<Down>2 tls2 \\<and> tllist_all2 tlsim (rel_option bisim) tls1 tls2\"", "lemma simulation_\\<tau>Runs2:\n  \"\\<lbrakk> s1 \\<approx> s2; s2 \\<Down>2 tls2 \\<rbrakk>\n  \\<Longrightarrow> \\<exists>tls1. s1 \\<Down>1 tls1 \\<and> tllist_all2 tlsim (rel_option bisim) tls1 tls2\"", "lemma delay_bisimulation_final_base_flip:\n  \"delay_bisimulation_final_base trsys2 trsys1 (flip bisim) \\<tau>move2 \\<tau>move1 final2 final1\"", "lemma delay_bisimulation_final_base_flip_simps [flip_simps]:\n  \"delay_bisimulation_final_base trsys2 trsys1 (flip bisim) \\<tau>move2 \\<tau>move1 final2 final1 =\n  delay_bisimulation_final_base trsys1 trsys2 bisim \\<tau>move1 \\<tau>move2 final1 final2\"", "lemma \\<tau>Runs_terminate_final1:\n  assumes \"s1 \\<Down>1 tls1\"\n  and \"s2 \\<Down>2 tls2\"\n  and \"tllist_all2 tlsim (rel_option bisim) tls1 tls2\"\n  and \"tfinite tls1\"\n  and \"terminal tls1 = Some s1'\"\n  and \"final1 s1'\"\n  shows \"\\<exists>s2'. tfinite tls2 \\<and> terminal tls2 = Some s2' \\<and> final2 s2'\"", "lemma \\<tau>Runs_terminate_final2:\n  \"\\<lbrakk> s1 \\<Down>1 tls1; s2 \\<Down>2 tls2; tllist_all2 tlsim (rel_option bisim) tls1 tls2;\n     tfinite tls2; terminal tls2 = Some s2'; final2 s2' \\<rbrakk>\n  \\<Longrightarrow> \\<exists>s1'. tfinite tls1 \\<and> terminal tls1 = Some s1' \\<and> final1 s1'\"", "lemma delay_bisimulation_diverge_final_flip:\n  \"delay_bisimulation_diverge_final trsys2 trsys1 (flip bisim) (flip tlsim) \\<tau>move2 \\<tau>move1 final2 final1\"", "lemma delay_bisimulation_diverge_final_flip_simps [flip_simps]:\n  \"delay_bisimulation_diverge_final trsys2 trsys1 (flip bisim) (flip tlsim) \\<tau>move2 \\<tau>move1 final2 final1 =\n   delay_bisimulation_diverge_final trsys1 trsys2 bisim tlsim \\<tau>move1 \\<tau>move2 final1 final2\"", "lemma delay_bisimulation_diverge:\n  \"delay_bisimulation_diverge trsys1 trsys2 bisim tlsim \\<tau>move1 \\<tau>move2\"", "lemma delay_bisimulation_final_base:\n  \"delay_bisimulation_final_base trsys1 trsys2 bisim \\<tau>move1 \\<tau>move2 final1 final2\"", "lemma final_simulation1:\n  \"\\<lbrakk> s1 \\<approx> s2; s1 -\\<tau>1-tls1\\<rightarrow>* s1'; final1 s1' \\<rbrakk>\n  \\<Longrightarrow> \\<exists>s2' tls2. s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2' \\<and> final2 s2' \\<and> tls1 [\\<sim>] tls2\"", "lemma final_simulation2:\n  \"\\<lbrakk> s1 \\<approx> s2; s2 -\\<tau>2-tls2\\<rightarrow>* s2'; final2 s2' \\<rbrakk>\n  \\<Longrightarrow> \\<exists>s1' tls1. s1 -\\<tau>1-tls1\\<rightarrow>* s1' \\<and> s1' \\<approx> s2' \\<and> final1 s1' \\<and> tls1 [\\<sim>] tls2\"", "lemma delay_bisimulation_measure_flip:\n  \"delay_bisimulation_measure trsys2 trsys1 (flip bisim) (flip tlsim) \\<tau>move2 \\<tau>move1 \\<mu>2 \\<mu>1\"", "lemma delay_bisimulation_measure_flip_simps [flip_simps]:\n  \"delay_bisimulation_measure trsys2 trsys1 (flip bisim) (flip tlsim) \\<tau>move2 \\<tau>move1 \\<mu>2 \\<mu>1 =\n   delay_bisimulation_measure trsys1 trsys2 bisim tlsim \\<tau>move1 \\<tau>move2 \\<mu>1 \\<mu>2\"", "lemma simulation_silentst1:\n  assumes bisim: \"s1 \\<approx> s2\" and moves: \"s1 -\\<tau>1\\<rightarrow>+ s1'\"\n  shows \"s1' \\<approx> s2 \\<and> \\<mu>1^++ s1' s1 \\<or> (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')\"", "lemma simulation_silentst2:\n  \"\\<lbrakk> s1 \\<approx> s2; s2 -\\<tau>2\\<rightarrow>+ s2' \\<rbrakk> \\<Longrightarrow> s1 \\<approx> s2' \\<and> \\<mu>2^++ s2' s2 \\<or> (\\<exists>s1'. s1 -\\<tau>1\\<rightarrow>+ s1' \\<and> s1' \\<approx> s2')\"", "lemma \\<tau>diverge_simulation1:\n  assumes diverge1: \"s1 -\\<tau>1\\<rightarrow> \\<infinity>\"\n  and bisim: \"s1 \\<approx> s2\"\n  shows \"s2 -\\<tau>2\\<rightarrow> \\<infinity>\"", "lemma \\<tau>diverge_simulation2:\n  \"\\<lbrakk> s2 -\\<tau>2\\<rightarrow> \\<infinity>; s1 \\<approx> s2 \\<rbrakk> \\<Longrightarrow> s1 -\\<tau>1\\<rightarrow> \\<infinity>\"", "lemma \\<tau>diverge_bisim_inv:\n  \"s1 \\<approx> s2 \\<Longrightarrow> s1 -\\<tau>1\\<rightarrow> \\<infinity> \\<longleftrightarrow> s2 -\\<tau>2\\<rightarrow> \\<infinity>\"", "lemma \\<tau>inv_flip:\n  \"\\<tau>inv trsys2 trsys1 (flip bisim) (flip tlsim) \\<tau>move2 \\<tau>move1\"", "lemma \\<tau>inv_flip_simps [flip_simps]:\n  \"\\<tau>inv trsys2 trsys1 (flip bisim) (flip tlsim) \\<tau>move2 \\<tau>move1 = \\<tau>inv trsys1 trsys2 bisim tlsim \\<tau>move1 \\<tau>move2\"", "lemma bisimulation_into_delay_flip:\n  \"bisimulation_into_delay trsys2 trsys1 (flip bisim) (flip tlsim) \\<tau>move2 \\<tau>move1\"", "lemma bisimulation_into_delay_flip_simps [flip_simps]:\n  \"bisimulation_into_delay trsys2 trsys1 (flip bisim) (flip tlsim) \\<tau>move2 \\<tau>move1 =\n   bisimulation_into_delay trsys1 trsys2 bisim tlsim \\<tau>move1 \\<tau>move2\"", "lemma simulation_silent1_aux:\n  assumes bisim: \"s1 \\<approx> s2\" and \"s1 -\\<tau>1\\<rightarrow> s1'\"\n  shows \"s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or> (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')\"", "lemma simulation_silent2_aux:\n  \"\\<lbrakk> s1 \\<approx> s2; s2 -\\<tau>2\\<rightarrow> s2' \\<rbrakk> \\<Longrightarrow> s1 \\<approx> s2' \\<and> \\<mu>2\\<^sup>+\\<^sup>+ s2' s2 \\<or> (\\<exists>s1'. s1 -\\<tau>1\\<rightarrow>+ s1' \\<and> s1' \\<approx> s2')\"", "lemma simulation1_aux:\n  assumes bisim: \"s1 \\<approx> s2\" and tr1: \"s1 -1-tl1\\<rightarrow> s1'\" and \\<tau>1: \"\\<not> \\<tau>move1 s1 tl1 s1'\"\n  shows \"\\<exists>s2' s2'' tl2. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s2' -2-tl2\\<rightarrow> s2'' \\<and> \\<not> \\<tau>move2 s2' tl2 s2'' \\<and> s1' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\"", "lemma simulation2_aux:\n  \"\\<lbrakk> s1 \\<approx> s2; s2 -2-tl2\\<rightarrow> s2'; \\<not> \\<tau>move2 s2 tl2 s2' \\<rbrakk>\n  \\<Longrightarrow> \\<exists>s1' s1'' tl1. s1 -\\<tau>1\\<rightarrow>* s1' \\<and> s1' -1-tl1\\<rightarrow> s1'' \\<and> \\<not> \\<tau>move1 s1' tl1 s1'' \\<and> s1'' \\<approx> s2' \\<and> tl1 \\<sim> tl2\"", "lemma delay_bisimulation_measure:\n  assumes wf_\\<mu>1: \"wfP \\<mu>1\"\n  and wf_\\<mu>2: \"wfP \\<mu>2\"\n  shows \"delay_bisimulation_measure trsys1 trsys2 bisim tlsim \\<tau>move1 \\<tau>move2 \\<mu>1 \\<mu>2\"", "lemma delay_bisimulation:\n  \"delay_bisimulation_diverge trsys1 trsys2 bisim tlsim \\<tau>move1 \\<tau>move2\"", "lemma delay_bisimulation_conv_bisimulation:\n  \"delay_bisimulation_diverge trsys1 trsys2 bisim tlsim (\\<lambda>s tl s'. False) (\\<lambda>s tl s'. False) =\n   bisimulation trsys1 trsys2 bisim tlsim\"\n  (is \"?lhs = ?rhs\")", "lemma delay_bisimulation_final_base: \n  \"delay_bisimulation_final_base trsys1 trsys2 bisim \\<tau>move1 \\<tau>move2 final1 final2\"", "lemma bisim_composeI [intro]:\n  \"\\<lbrakk> bisim12 s1 s2; bisim23 s2 s3 \\<rbrakk> \\<Longrightarrow> (bisim12 \\<circ>\\<^sub>B bisim23) s1 s3\"", "lemma bisim_composeE [elim!]:\n  assumes bisim: \"(bisim12 \\<circ>\\<^sub>B bisim23) s1 s3\"\n  obtains s2 where \"bisim12 s1 s2\" \"bisim23 s2 s3\"", "lemma bisim_compose_assoc [simp]:\n  \"(bisim12 \\<circ>\\<^sub>B bisim23) \\<circ>\\<^sub>B bisim34 = bisim12 \\<circ>\\<^sub>B bisim23 \\<circ>\\<^sub>B bisim34\"", "lemma bisim_compose_conv_relcomp:\n  \"case_prod (bisim_compose bisim12 bisim23) = (\\<lambda>x. x \\<in> relcomp (Collect (case_prod bisim12)) (Collect (case_prod bisim23)))\"", "lemma list_all2_bisim_composeI:\n  \"\\<lbrakk> list_all2 A xs ys; list_all2 B ys zs \\<rbrakk>\n  \\<Longrightarrow> list_all2 (A \\<circ>\\<^sub>B B) xs zs\"", "lemma delay_bisimulation_diverge_compose:\n  assumes wbisim12: \"delay_bisimulation_diverge trsys1 trsys2 bisim12 tlsim12 \\<tau>move1 \\<tau>move2\"\n  and wbisim23: \"delay_bisimulation_diverge trsys2 trsys3 bisim23 tlsim23 \\<tau>move2 \\<tau>move3\"\n  shows \"delay_bisimulation_diverge trsys1 trsys3 (bisim12 \\<circ>\\<^sub>B bisim23) (tlsim12 \\<circ>\\<^sub>B tlsim23) \\<tau>move1 \\<tau>move3\"", "lemma bisimulation_bisim_compose:\n  \"\\<lbrakk> bisimulation trsys1 trsys2 bisim12 tlsim12; bisimulation trsys2 trsys3 bisim23 tlsim23 \\<rbrakk>\n  \\<Longrightarrow> bisimulation trsys1 trsys3 (bisim_compose bisim12 bisim23) (bisim_compose tlsim12 tlsim23)\"", "lemma delay_bisimulation_diverge_final_compose:\n  fixes \\<tau>move1 \\<tau>move2\n  assumes wbisim12: \"delay_bisimulation_diverge_final trsys1 trsys2 bisim12 tlsim12 \\<tau>move1 \\<tau>move2 final1 final2\"\n  and wbisim23: \"delay_bisimulation_diverge_final trsys2 trsys3 bisim23 tlsim23 \\<tau>move2 \\<tau>move3 final2 final3\"\n  shows \"delay_bisimulation_diverge_final trsys1 trsys3 (bisim12 \\<circ>\\<^sub>B bisim23) (tlsim12 \\<circ>\\<^sub>B tlsim23) \\<tau>move1 \\<tau>move3 final1 final3\""], "translations": [["", "lemma bisimulation_flip:\n  \"bisimulation trsys2 trsys1 (flip bisim) (flip tlsim)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisimulation trsys2 trsys1 (flip bisim) (flip tlsim)", "by(unfold_locales)(unfold flip_simps,(blast intro: simulation1 simulation2)+)"], ["", "end"], ["", "lemma bisimulation_flip_simps [flip_simps]:\n  \"bisimulation trsys2 trsys1 (flip bisim) (flip tlsim) = bisimulation trsys1 trsys2 bisim tlsim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisimulation trsys2 trsys1 (flip bisim) (flip tlsim) =\n    bisimulation trsys1 trsys2 bisim tlsim", "by(auto dest: bisimulation.bisimulation_flip simp only: flip_flip)"], ["", "context bisimulation begin"], ["", "lemma simulation1_rtrancl:\n  \"\\<lbrakk>s1 -1-tls1\\<rightarrow>* s1'; s1 \\<approx> s2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s2' tls2. s2 -2-tls2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2' \\<and> tls1 [\\<sim>] tls2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 -1-tls1\\<rightarrow>* s1'; s1 \\<approx> s2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2' tls2.\n                         s2 -2-tls2\\<rightarrow>* s2' \\<and>\n                         s1' \\<approx> s2' \\<and> tls1 [\\<sim>] tls2", "proof(induct rule: rtrancl3p.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       a \\<approx> s2 \\<Longrightarrow>\n       \\<exists>s2' tls2.\n          s2 -2-tls2\\<rightarrow>* s2' \\<and>\n          a \\<approx> s2' \\<and> [] [\\<sim>] tls2\n 2. \\<And>a bs a' b a''.\n       \\<lbrakk>a -1-bs\\<rightarrow>* a';\n        a \\<approx> s2 \\<Longrightarrow>\n        \\<exists>s2' tls2.\n           s2 -2-tls2\\<rightarrow>* s2' \\<and>\n           a' \\<approx> s2' \\<and> bs [\\<sim>] tls2;\n        a' -1-b\\<rightarrow> a''; a \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' tls2.\n                            s2 -2-tls2\\<rightarrow>* s2' \\<and>\n                            a'' \\<approx> s2' \\<and> bs @ [b] [\\<sim>] tls2", "case rtrancl3p_refl"], ["proof (state)\nthis:\n  a_ \\<approx> s2\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       a \\<approx> s2 \\<Longrightarrow>\n       \\<exists>s2' tls2.\n          s2 -2-tls2\\<rightarrow>* s2' \\<and>\n          a \\<approx> s2' \\<and> [] [\\<sim>] tls2\n 2. \\<And>a bs a' b a''.\n       \\<lbrakk>a -1-bs\\<rightarrow>* a';\n        a \\<approx> s2 \\<Longrightarrow>\n        \\<exists>s2' tls2.\n           s2 -2-tls2\\<rightarrow>* s2' \\<and>\n           a' \\<approx> s2' \\<and> bs [\\<sim>] tls2;\n        a' -1-b\\<rightarrow> a''; a \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' tls2.\n                            s2 -2-tls2\\<rightarrow>* s2' \\<and>\n                            a'' \\<approx> s2' \\<and> bs @ [b] [\\<sim>] tls2", "thus ?case"], ["proof (prove)\nusing this:\n  a_ \\<approx> s2\n\ngoal (1 subgoal):\n 1. \\<exists>s2' tls2.\n       s2 -2-tls2\\<rightarrow>* s2' \\<and>\n       a_ \\<approx> s2' \\<and> [] [\\<sim>] tls2", "by(auto intro: rtrancl3p.rtrancl3p_refl)"], ["proof (state)\nthis:\n  \\<exists>s2' tls2.\n     s2 -2-tls2\\<rightarrow>* s2' \\<and>\n     a_ \\<approx> s2' \\<and> [] [\\<sim>] tls2\n\ngoal (1 subgoal):\n 1. \\<And>a bs a' b a''.\n       \\<lbrakk>a -1-bs\\<rightarrow>* a';\n        a \\<approx> s2 \\<Longrightarrow>\n        \\<exists>s2' tls2.\n           s2 -2-tls2\\<rightarrow>* s2' \\<and>\n           a' \\<approx> s2' \\<and> bs [\\<sim>] tls2;\n        a' -1-b\\<rightarrow> a''; a \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' tls2.\n                            s2 -2-tls2\\<rightarrow>* s2' \\<and>\n                            a'' \\<approx> s2' \\<and> bs @ [b] [\\<sim>] tls2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a bs a' b a''.\n       \\<lbrakk>a -1-bs\\<rightarrow>* a';\n        a \\<approx> s2 \\<Longrightarrow>\n        \\<exists>s2' tls2.\n           s2 -2-tls2\\<rightarrow>* s2' \\<and>\n           a' \\<approx> s2' \\<and> bs [\\<sim>] tls2;\n        a' -1-b\\<rightarrow> a''; a \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' tls2.\n                            s2 -2-tls2\\<rightarrow>* s2' \\<and>\n                            a'' \\<approx> s2' \\<and> bs @ [b] [\\<sim>] tls2", "case (rtrancl3p_step s1 tls1 s1' tl1 s1'')"], ["proof (state)\nthis:\n  s1 -1-tls1\\<rightarrow>* s1'\n  s1 \\<approx> s2 \\<Longrightarrow>\n  \\<exists>s2' tls2.\n     s2 -2-tls2\\<rightarrow>* s2' \\<and>\n     s1' \\<approx> s2' \\<and> tls1 [\\<sim>] tls2\n  s1' -1-tl1\\<rightarrow> s1''\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. \\<And>a bs a' b a''.\n       \\<lbrakk>a -1-bs\\<rightarrow>* a';\n        a \\<approx> s2 \\<Longrightarrow>\n        \\<exists>s2' tls2.\n           s2 -2-tls2\\<rightarrow>* s2' \\<and>\n           a' \\<approx> s2' \\<and> bs [\\<sim>] tls2;\n        a' -1-b\\<rightarrow> a''; a \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' tls2.\n                            s2 -2-tls2\\<rightarrow>* s2' \\<and>\n                            a'' \\<approx> s2' \\<and> bs @ [b] [\\<sim>] tls2", "from \\<open>s1 \\<approx> s2 \\<Longrightarrow> \\<exists>s2' tls2. s2 -2-tls2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2' \\<and> tls1 [\\<sim>] tls2\\<close> \\<open>s1 \\<approx> s2\\<close>"], ["proof (chain)\npicking this:\n  s1 \\<approx> s2 \\<Longrightarrow>\n  \\<exists>s2' tls2.\n     s2 -2-tls2\\<rightarrow>* s2' \\<and>\n     s1' \\<approx> s2' \\<and> tls1 [\\<sim>] tls2\n  s1 \\<approx> s2", "obtain s2' tls2 where \"s2 -2-tls2\\<rightarrow>* s2'\" \"s1' \\<approx> s2'\" \"tls1 [\\<sim>] tls2\""], ["proof (prove)\nusing this:\n  s1 \\<approx> s2 \\<Longrightarrow>\n  \\<exists>s2' tls2.\n     s2 -2-tls2\\<rightarrow>* s2' \\<and>\n     s1' \\<approx> s2' \\<and> tls1 [\\<sim>] tls2\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. (\\<And>tls2 s2'.\n        \\<lbrakk>s2 -2-tls2\\<rightarrow>* s2'; s1' \\<approx> s2';\n         tls1 [\\<sim>] tls2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s2 -2-tls2\\<rightarrow>* s2'\n  s1' \\<approx> s2'\n  tls1 [\\<sim>] tls2\n\ngoal (1 subgoal):\n 1. \\<And>a bs a' b a''.\n       \\<lbrakk>a -1-bs\\<rightarrow>* a';\n        a \\<approx> s2 \\<Longrightarrow>\n        \\<exists>s2' tls2.\n           s2 -2-tls2\\<rightarrow>* s2' \\<and>\n           a' \\<approx> s2' \\<and> bs [\\<sim>] tls2;\n        a' -1-b\\<rightarrow> a''; a \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' tls2.\n                            s2 -2-tls2\\<rightarrow>* s2' \\<and>\n                            a'' \\<approx> s2' \\<and> bs @ [b] [\\<sim>] tls2", "moreover"], ["proof (state)\nthis:\n  s2 -2-tls2\\<rightarrow>* s2'\n  s1' \\<approx> s2'\n  tls1 [\\<sim>] tls2\n\ngoal (1 subgoal):\n 1. \\<And>a bs a' b a''.\n       \\<lbrakk>a -1-bs\\<rightarrow>* a';\n        a \\<approx> s2 \\<Longrightarrow>\n        \\<exists>s2' tls2.\n           s2 -2-tls2\\<rightarrow>* s2' \\<and>\n           a' \\<approx> s2' \\<and> bs [\\<sim>] tls2;\n        a' -1-b\\<rightarrow> a''; a \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' tls2.\n                            s2 -2-tls2\\<rightarrow>* s2' \\<and>\n                            a'' \\<approx> s2' \\<and> bs @ [b] [\\<sim>] tls2", "from \\<open>s1' -1-tl1\\<rightarrow> s1''\\<close> \\<open>s1' \\<approx> s2'\\<close>"], ["proof (chain)\npicking this:\n  s1' -1-tl1\\<rightarrow> s1''\n  s1' \\<approx> s2'", "obtain s2'' tl2 where \"s2' -2-tl2\\<rightarrow> s2''\" \"s1'' \\<approx> s2''\" \"tl1 \\<sim> tl2\""], ["proof (prove)\nusing this:\n  s1' -1-tl1\\<rightarrow> s1''\n  s1' \\<approx> s2'\n\ngoal (1 subgoal):\n 1. (\\<And>tl2 s2''.\n        \\<lbrakk>s2' -2-tl2\\<rightarrow> s2''; s1'' \\<approx> s2'';\n         tl1 \\<sim> tl2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: simulation1)"], ["proof (state)\nthis:\n  s2' -2-tl2\\<rightarrow> s2''\n  s1'' \\<approx> s2''\n  tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. \\<And>a bs a' b a''.\n       \\<lbrakk>a -1-bs\\<rightarrow>* a';\n        a \\<approx> s2 \\<Longrightarrow>\n        \\<exists>s2' tls2.\n           s2 -2-tls2\\<rightarrow>* s2' \\<and>\n           a' \\<approx> s2' \\<and> bs [\\<sim>] tls2;\n        a' -1-b\\<rightarrow> a''; a \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' tls2.\n                            s2 -2-tls2\\<rightarrow>* s2' \\<and>\n                            a'' \\<approx> s2' \\<and> bs @ [b] [\\<sim>] tls2", "ultimately"], ["proof (chain)\npicking this:\n  s2 -2-tls2\\<rightarrow>* s2'\n  s1' \\<approx> s2'\n  tls1 [\\<sim>] tls2\n  s2' -2-tl2\\<rightarrow> s2''\n  s1'' \\<approx> s2''\n  tl1 \\<sim> tl2", "have \"s2 -2-tls2 @ [tl2]\\<rightarrow>* s2''\" \"tls1 @ [tl1] [\\<sim>] tls2 @ [tl2]\""], ["proof (prove)\nusing this:\n  s2 -2-tls2\\<rightarrow>* s2'\n  s1' \\<approx> s2'\n  tls1 [\\<sim>] tls2\n  s2' -2-tl2\\<rightarrow> s2''\n  s1'' \\<approx> s2''\n  tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. s2 -2-tls2 @ [tl2]\\<rightarrow>* s2'' &&&\n    tls1 @ [tl1] [\\<sim>] tls2 @ [tl2]", "by(auto intro: rtrancl3p.rtrancl3p_step list_all2_appendI)"], ["proof (state)\nthis:\n  s2 -2-tls2 @ [tl2]\\<rightarrow>* s2''\n  tls1 @ [tl1] [\\<sim>] tls2 @ [tl2]\n\ngoal (1 subgoal):\n 1. \\<And>a bs a' b a''.\n       \\<lbrakk>a -1-bs\\<rightarrow>* a';\n        a \\<approx> s2 \\<Longrightarrow>\n        \\<exists>s2' tls2.\n           s2 -2-tls2\\<rightarrow>* s2' \\<and>\n           a' \\<approx> s2' \\<and> bs [\\<sim>] tls2;\n        a' -1-b\\<rightarrow> a''; a \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' tls2.\n                            s2 -2-tls2\\<rightarrow>* s2' \\<and>\n                            a'' \\<approx> s2' \\<and> bs @ [b] [\\<sim>] tls2", "with \\<open>s1'' \\<approx> s2''\\<close>"], ["proof (chain)\npicking this:\n  s1'' \\<approx> s2''\n  s2 -2-tls2 @ [tl2]\\<rightarrow>* s2''\n  tls1 @ [tl1] [\\<sim>] tls2 @ [tl2]", "show ?case"], ["proof (prove)\nusing this:\n  s1'' \\<approx> s2''\n  s2 -2-tls2 @ [tl2]\\<rightarrow>* s2''\n  tls1 @ [tl1] [\\<sim>] tls2 @ [tl2]\n\ngoal (1 subgoal):\n 1. \\<exists>s2' tls2.\n       s2 -2-tls2\\<rightarrow>* s2' \\<and>\n       s1'' \\<approx> s2' \\<and> tls1 @ [tl1] [\\<sim>] tls2", "by(blast)"], ["proof (state)\nthis:\n  \\<exists>s2' tls2.\n     s2 -2-tls2\\<rightarrow>* s2' \\<and>\n     s1'' \\<approx> s2' \\<and> tls1 @ [tl1] [\\<sim>] tls2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma simulation2_rtrancl:\n  \"\\<lbrakk>s2 -2-tls2\\<rightarrow>* s2'; s1 \\<approx> s2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s1' tls1. s1 -1-tls1\\<rightarrow>* s1' \\<and> s1' \\<approx> s2' \\<and> tls1 [\\<sim>] tls2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s2 -2-tls2\\<rightarrow>* s2'; s1 \\<approx> s2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s1' tls1.\n                         s1 -1-tls1\\<rightarrow>* s1' \\<and>\n                         s1' \\<approx> s2' \\<and> tls1 [\\<sim>] tls2", "using bisimulation.simulation1_rtrancl[OF bisimulation_flip]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s1.0 -2-?tls1.0\\<rightarrow>* ?s1';\n   flip bisim ?s1.0 ?s2.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s2' tls2.\n                       ?s2.0 -1-tls2\\<rightarrow>* s2' \\<and>\n                       flip bisim ?s1' s2' \\<and>\n                       list_all2 (flip tlsim) ?tls1.0 tls2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s2 -2-tls2\\<rightarrow>* s2'; s1 \\<approx> s2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s1' tls1.\n                         s1 -1-tls1\\<rightarrow>* s1' \\<and>\n                         s1' \\<approx> s2' \\<and> tls1 [\\<sim>] tls2", "unfolding flip_simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s1.0 -2-?tls1.0\\<rightarrow>* ?s1';\n   ?s2.0 \\<approx> ?s1.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s2' tls2.\n                       ?s2.0 -1-tls2\\<rightarrow>* s2' \\<and>\n                       s2' \\<approx> ?s1' \\<and> tls2 [\\<sim>] ?tls1.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s2 -2-tls2\\<rightarrow>* s2'; s1 \\<approx> s2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s1' tls1.\n                         s1 -1-tls1\\<rightarrow>* s1' \\<and>\n                         s1' \\<approx> s2' \\<and> tls1 [\\<sim>] tls2", "."], ["", "lemma simulation1_inf_step:\n  assumes red1: \"s1 -1-tls1\\<rightarrow>* \\<infinity>\" and bisim: \"s1 \\<approx> s2\"\n  shows \"\\<exists>tls2. s2 -2-tls2\\<rightarrow>* \\<infinity> \\<and> tls1 [[\\<sim>]] tls2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>tls2.\n       s2 -2-tls2\\<rightarrow>* \\<infinity> \\<and> tls1 [[\\<sim>]] tls2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>tls2.\n       s2 -2-tls2\\<rightarrow>* \\<infinity> \\<and> tls1 [[\\<sim>]] tls2", "from r1.inf_step_imp_inf_step_table[OF red1]"], ["proof (chain)\npicking this:\n  \\<exists>stls.\n     s1 -1-stls\\<rightarrow>*t \\<infinity> \\<and>\n     tls1 = lmap (fst \\<circ> snd) stls", "obtain stls1 where red1': \"s1 -1-stls1\\<rightarrow>*t \\<infinity>\" \n    and tls1: \"tls1 = lmap (fst \\<circ> snd) stls1\""], ["proof (prove)\nusing this:\n  \\<exists>stls.\n     s1 -1-stls\\<rightarrow>*t \\<infinity> \\<and>\n     tls1 = lmap (fst \\<circ> snd) stls\n\ngoal (1 subgoal):\n 1. (\\<And>stls1.\n        \\<lbrakk>s1 -1-stls1\\<rightarrow>*t \\<infinity>;\n         tls1 = lmap (fst \\<circ> snd) stls1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s1 -1-stls1\\<rightarrow>*t \\<infinity>\n  tls1 = lmap (fst \\<circ> snd) stls1\n\ngoal (1 subgoal):\n 1. \\<exists>tls2.\n       s2 -2-tls2\\<rightarrow>* \\<infinity> \\<and> tls1 [[\\<sim>]] tls2", "define tl1_to_tl2 where \"tl1_to_tl2 s2 stls1 = unfold_llist\n     (\\<lambda>(s2, stls1). lnull stls1)\n     (\\<lambda>(s2, stls1). let (s1, tl1, s1') = lhd stls1;\n                        (tl2, s2') = SOME (tl2, s2'). trsys2 s2 tl2 s2' \\<and> s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2\n                    in (s2, tl2, s2'))\n     (\\<lambda>(s2, stls1). let (s1, tl1, s1') = lhd stls1;\n                        (tl2, s2') = SOME (tl2, s2'). trsys2 s2 tl2 s2' \\<and> s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2\n                    in (s2', ltl stls1))\n     (s2, stls1)\"\n    for s2 :: 's2 and stls1 :: \"('s1 \\<times> 'tl1 \\<times> 's1) llist\""], ["proof (state)\nthis:\n  tl1_to_tl2 ?s2.0 ?stls1.0 =\n  unfold_llist (\\<lambda>(s2, stls1). lnull stls1)\n   (\\<lambda>(s2, stls1).\n       let (s1, tl1, s1') = lhd stls1;\n           (tl2, s2') =\n             SOME (tl2, s2').\n                s2 -2-tl2\\<rightarrow> s2' \\<and>\n                s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2\n       in (s2, tl2, s2'))\n   (\\<lambda>(s2, stls1).\n       let (s1, tl1, s1') = lhd stls1;\n           (tl2, s2') =\n             SOME (tl2, s2').\n                s2 -2-tl2\\<rightarrow> s2' \\<and>\n                s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2\n       in (s2', ltl stls1))\n   (?s2.0, ?stls1.0)\n\ngoal (1 subgoal):\n 1. \\<exists>tls2.\n       s2 -2-tls2\\<rightarrow>* \\<infinity> \\<and> tls1 [[\\<sim>]] tls2", "have tl1_to_tl2_simps [simp]:\n    \"\\<And>s2 stls1. lnull (tl1_to_tl2 s2 stls1) \\<longleftrightarrow> lnull stls1\"\n    \"\\<And>s2 stls1. \\<not> lnull stls1 \\<Longrightarrow> lhd (tl1_to_tl2 s2 stls1) =\n    (let (s1, tl1, s1') = lhd stls1;\n         (tl2, s2') = SOME (tl2, s2'). trsys2 s2 tl2 s2' \\<and> s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2\n     in (s2, tl2, s2'))\"\n    \"\\<And>s2 stls1. \\<not> lnull stls1 \\<Longrightarrow> ltl (tl1_to_tl2 s2 stls1) =\n    (let (s1, tl1, s1') = lhd stls1;\n         (tl2, s2') = SOME (tl2, s2'). trsys2 s2 tl2 s2' \\<and> s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2\n     in tl1_to_tl2 s2' (ltl stls1))\"\n    \"\\<And>s2. tl1_to_tl2 s2 LNil = LNil\"\n    \"\\<And>s2 s1 tl1 s1' stls1'. tl1_to_tl2 s2 (LCons (s1, tl1, s1') stls1') =\n        LCons (s2, SOME (tl2, s2'). trsys2 s2 tl2 s2' \\<and> s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2) \n              (tl1_to_tl2 (snd (SOME (tl2, s2'). trsys2 s2 tl2 s2' \\<and> s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2)) stls1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>s2 stls1. lnull (tl1_to_tl2 s2 stls1) = lnull stls1) &&&\n     (\\<And>s2 stls1.\n         \\<not> lnull stls1 \\<Longrightarrow>\n         lhd (tl1_to_tl2 s2 stls1) =\n         (let (s1, tl1, s1') = lhd stls1;\n              (tl2, s2') =\n                SOME (tl2, s2').\n                   s2 -2-tl2\\<rightarrow> s2' \\<and>\n                   s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2\n          in (s2, tl2, s2')))) &&&\n    (\\<And>s2 stls1.\n        \\<not> lnull stls1 \\<Longrightarrow>\n        ltl (tl1_to_tl2 s2 stls1) =\n        (let (s1, tl1, s1') = lhd stls1;\n             (tl2, s2') =\n               SOME (tl2, s2').\n                  s2 -2-tl2\\<rightarrow> s2' \\<and>\n                  s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2\n         in tl1_to_tl2 s2' (ltl stls1))) &&&\n    (\\<And>s2. tl1_to_tl2 s2 LNil = LNil) &&&\n    (\\<And>s2 s1 tl1 s1' stls1'.\n        tl1_to_tl2 s2 (LCons (s1, tl1, s1') stls1') =\n        LCons\n         (s2,\n          SOME (tl2, s2').\n             s2 -2-tl2\\<rightarrow> s2' \\<and>\n             s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2)\n         (tl1_to_tl2\n           (snd (SOME (tl2, s2').\n                    s2 -2-tl2\\<rightarrow> s2' \\<and>\n                    s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2))\n           stls1'))", "by(simp_all add: tl1_to_tl2_def split_beta)"], ["proof (state)\nthis:\n  lnull (tl1_to_tl2 ?s2.0 ?stls1.0) = lnull ?stls1.0\n  \\<not> lnull ?stls1.0 \\<Longrightarrow>\n  lhd (tl1_to_tl2 ?s2.0 ?stls1.0) =\n  (let (s1, tl1, s1') = lhd ?stls1.0;\n       (tl2, s2') =\n         SOME (tl2, s2').\n            ?s2.0 -2-tl2\\<rightarrow> s2' \\<and>\n            s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2\n   in (?s2.0, tl2, s2'))\n  \\<not> lnull ?stls1.0 \\<Longrightarrow>\n  ltl (tl1_to_tl2 ?s2.0 ?stls1.0) =\n  (let (s1, tl1, s1') = lhd ?stls1.0;\n       (tl2, s2') =\n         SOME (tl2, s2').\n            ?s2.0 -2-tl2\\<rightarrow> s2' \\<and>\n            s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2\n   in tl1_to_tl2 s2' (ltl ?stls1.0))\n  tl1_to_tl2 ?s2.0 LNil = LNil\n  tl1_to_tl2 ?s2.0 (LCons (?s1.0, ?tl1.0, ?s1') ?stls1') =\n  LCons\n   (?s2.0,\n    SOME (tl2, s2').\n       ?s2.0 -2-tl2\\<rightarrow> s2' \\<and>\n       ?s1' \\<approx> s2' \\<and> ?tl1.0 \\<sim> tl2)\n   (tl1_to_tl2\n     (snd (SOME (tl2, s2').\n              ?s2.0 -2-tl2\\<rightarrow> s2' \\<and>\n              ?s1' \\<approx> s2' \\<and> ?tl1.0 \\<sim> tl2))\n     ?stls1')\n\ngoal (1 subgoal):\n 1. \\<exists>tls2.\n       s2 -2-tls2\\<rightarrow>* \\<infinity> \\<and> tls1 [[\\<sim>]] tls2", "have [simp]: \"llength (tl1_to_tl2 s2 stls1) = llength stls1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (tl1_to_tl2 s2 stls1) = llength stls1", "by(coinduction arbitrary: s2 stls1 rule: enat_coinduct)(auto simp add: epred_llength split_beta)"], ["proof (state)\nthis:\n  llength (tl1_to_tl2 s2 stls1) = llength stls1\n\ngoal (1 subgoal):\n 1. \\<exists>tls2.\n       s2 -2-tls2\\<rightarrow>* \\<infinity> \\<and> tls1 [[\\<sim>]] tls2", "from red1' bisim"], ["proof (chain)\npicking this:\n  s1 -1-stls1\\<rightarrow>*t \\<infinity>\n  s1 \\<approx> s2", "have \"s2 -2-tl1_to_tl2 s2 stls1\\<rightarrow>*t \\<infinity>\""], ["proof (prove)\nusing this:\n  s1 -1-stls1\\<rightarrow>*t \\<infinity>\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. s2 -2-tl1_to_tl2 s2 stls1\\<rightarrow>*t \\<infinity>", "proof(coinduction arbitrary: s2 s1 stls1)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s2 s1 stls1.\n       \\<lbrakk>s1 -1-stls1\\<rightarrow>*t \\<infinity>;\n        s1 \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s s' stls tl.\n                            s2 = s \\<and>\n                            tl1_to_tl2 s2 stls1 =\n                            LCons (s, tl, s') stls \\<and>\n                            s -2-tl\\<rightarrow> s' \\<and>\n                            ((\\<exists>s2 s1 stls1.\n                                 s' = s2 \\<and>\n                                 stls = tl1_to_tl2 s2 stls1 \\<and>\n                                 s1 -1-stls1\\<rightarrow>*t \\<infinity> \\<and>\n                                 s1 \\<approx> s2) \\<or>\n                             s' -2-stls\\<rightarrow>*t \\<infinity>)", "case (inf_step_table s2 s1 stls1)"], ["proof (state)\nthis:\n  s1 -1-stls1\\<rightarrow>*t \\<infinity>\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. \\<And>s2 s1 stls1.\n       \\<lbrakk>s1 -1-stls1\\<rightarrow>*t \\<infinity>;\n        s1 \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s s' stls tl.\n                            s2 = s \\<and>\n                            tl1_to_tl2 s2 stls1 =\n                            LCons (s, tl, s') stls \\<and>\n                            s -2-tl\\<rightarrow> s' \\<and>\n                            ((\\<exists>s2 s1 stls1.\n                                 s' = s2 \\<and>\n                                 stls = tl1_to_tl2 s2 stls1 \\<and>\n                                 s1 -1-stls1\\<rightarrow>*t \\<infinity> \\<and>\n                                 s1 \\<approx> s2) \\<or>\n                             s' -2-stls\\<rightarrow>*t \\<infinity>)", "note red1' = \\<open>s1 -1-stls1\\<rightarrow>*t \\<infinity>\\<close> and bisim = \\<open>s1 \\<approx> s2\\<close>"], ["proof (state)\nthis:\n  s1 -1-stls1\\<rightarrow>*t \\<infinity>\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. \\<And>s2 s1 stls1.\n       \\<lbrakk>s1 -1-stls1\\<rightarrow>*t \\<infinity>;\n        s1 \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s s' stls tl.\n                            s2 = s \\<and>\n                            tl1_to_tl2 s2 stls1 =\n                            LCons (s, tl, s') stls \\<and>\n                            s -2-tl\\<rightarrow> s' \\<and>\n                            ((\\<exists>s2 s1 stls1.\n                                 s' = s2 \\<and>\n                                 stls = tl1_to_tl2 s2 stls1 \\<and>\n                                 s1 -1-stls1\\<rightarrow>*t \\<infinity> \\<and>\n                                 s1 \\<approx> s2) \\<or>\n                             s' -2-stls\\<rightarrow>*t \\<infinity>)", "from red1'"], ["proof (chain)\npicking this:\n  s1 -1-stls1\\<rightarrow>*t \\<infinity>", "show ?case"], ["proof (prove)\nusing this:\n  s1 -1-stls1\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>s s' stls tl.\n       s2 = s \\<and>\n       tl1_to_tl2 s2 stls1 = LCons (s, tl, s') stls \\<and>\n       s -2-tl\\<rightarrow> s' \\<and>\n       ((\\<exists>s2 s1 stls1.\n            s' = s2 \\<and>\n            stls = tl1_to_tl2 s2 stls1 \\<and>\n            s1 -1-stls1\\<rightarrow>*t \\<infinity> \\<and> s1\n            \\<approx> s2) \\<or>\n        s' -2-stls\\<rightarrow>*t \\<infinity>)", "proof(cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s' stls tl.\n       \\<lbrakk>stls1 = LCons (s1, tl, s') stls; s1 -1-tl\\<rightarrow> s';\n        s' -1-stls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s s' stls tl.\n                            s2 = s \\<and>\n                            tl1_to_tl2 s2 stls1 =\n                            LCons (s, tl, s') stls \\<and>\n                            s -2-tl\\<rightarrow> s' \\<and>\n                            ((\\<exists>s2 s1 stls1.\n                                 s' = s2 \\<and>\n                                 stls = tl1_to_tl2 s2 stls1 \\<and>\n                                 s1 -1-stls1\\<rightarrow>*t \\<infinity> \\<and>\n                                 s1 \\<approx> s2) \\<or>\n                             s' -2-stls\\<rightarrow>*t \\<infinity>)", "case (inf_step_tableI s1' stls1' tl1)"], ["proof (state)\nthis:\n  stls1 = LCons (s1, tl1, s1') stls1'\n  s1 -1-tl1\\<rightarrow> s1'\n  s1' -1-stls1'\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>s' stls tl.\n       \\<lbrakk>stls1 = LCons (s1, tl, s') stls; s1 -1-tl\\<rightarrow> s';\n        s' -1-stls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s s' stls tl.\n                            s2 = s \\<and>\n                            tl1_to_tl2 s2 stls1 =\n                            LCons (s, tl, s') stls \\<and>\n                            s -2-tl\\<rightarrow> s' \\<and>\n                            ((\\<exists>s2 s1 stls1.\n                                 s' = s2 \\<and>\n                                 stls = tl1_to_tl2 s2 stls1 \\<and>\n                                 s1 -1-stls1\\<rightarrow>*t \\<infinity> \\<and>\n                                 s1 \\<approx> s2) \\<or>\n                             s' -2-stls\\<rightarrow>*t \\<infinity>)", "hence stls1: \"stls1 = LCons (s1, tl1, s1') stls1'\"\n        and r: \"s1 -1-tl1\\<rightarrow> s1'\" and reds1: \"s1' -1-stls1'\\<rightarrow>*t \\<infinity>\""], ["proof (prove)\nusing this:\n  stls1 = LCons (s1, tl1, s1') stls1'\n  s1 -1-tl1\\<rightarrow> s1'\n  s1' -1-stls1'\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. stls1 = LCons (s1, tl1, s1') stls1' &&&\n    s1 -1-tl1\\<rightarrow> s1' &&& s1' -1-stls1'\\<rightarrow>*t \\<infinity>", "by simp_all"], ["proof (state)\nthis:\n  stls1 = LCons (s1, tl1, s1') stls1'\n  s1 -1-tl1\\<rightarrow> s1'\n  s1' -1-stls1'\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>s' stls tl.\n       \\<lbrakk>stls1 = LCons (s1, tl, s') stls; s1 -1-tl\\<rightarrow> s';\n        s' -1-stls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s s' stls tl.\n                            s2 = s \\<and>\n                            tl1_to_tl2 s2 stls1 =\n                            LCons (s, tl, s') stls \\<and>\n                            s -2-tl\\<rightarrow> s' \\<and>\n                            ((\\<exists>s2 s1 stls1.\n                                 s' = s2 \\<and>\n                                 stls = tl1_to_tl2 s2 stls1 \\<and>\n                                 s1 -1-stls1\\<rightarrow>*t \\<infinity> \\<and>\n                                 s1 \\<approx> s2) \\<or>\n                             s' -2-stls\\<rightarrow>*t \\<infinity>)", "let ?tl2s2' = \"SOME (tl2, s2'). s2 -2-tl2\\<rightarrow> s2' \\<and> s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s' stls tl.\n       \\<lbrakk>stls1 = LCons (s1, tl, s') stls; s1 -1-tl\\<rightarrow> s';\n        s' -1-stls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s s' stls tl.\n                            s2 = s \\<and>\n                            tl1_to_tl2 s2 stls1 =\n                            LCons (s, tl, s') stls \\<and>\n                            s -2-tl\\<rightarrow> s' \\<and>\n                            ((\\<exists>s2 s1 stls1.\n                                 s' = s2 \\<and>\n                                 stls = tl1_to_tl2 s2 stls1 \\<and>\n                                 s1 -1-stls1\\<rightarrow>*t \\<infinity> \\<and>\n                                 s1 \\<approx> s2) \\<or>\n                             s' -2-stls\\<rightarrow>*t \\<infinity>)", "let ?tl2 = \"fst ?tl2s2'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s' stls tl.\n       \\<lbrakk>stls1 = LCons (s1, tl, s') stls; s1 -1-tl\\<rightarrow> s';\n        s' -1-stls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s s' stls tl.\n                            s2 = s \\<and>\n                            tl1_to_tl2 s2 stls1 =\n                            LCons (s, tl, s') stls \\<and>\n                            s -2-tl\\<rightarrow> s' \\<and>\n                            ((\\<exists>s2 s1 stls1.\n                                 s' = s2 \\<and>\n                                 stls = tl1_to_tl2 s2 stls1 \\<and>\n                                 s1 -1-stls1\\<rightarrow>*t \\<infinity> \\<and>\n                                 s1 \\<approx> s2) \\<or>\n                             s' -2-stls\\<rightarrow>*t \\<infinity>)", "let ?s2' = \"snd ?tl2s2'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s' stls tl.\n       \\<lbrakk>stls1 = LCons (s1, tl, s') stls; s1 -1-tl\\<rightarrow> s';\n        s' -1-stls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s s' stls tl.\n                            s2 = s \\<and>\n                            tl1_to_tl2 s2 stls1 =\n                            LCons (s, tl, s') stls \\<and>\n                            s -2-tl\\<rightarrow> s' \\<and>\n                            ((\\<exists>s2 s1 stls1.\n                                 s' = s2 \\<and>\n                                 stls = tl1_to_tl2 s2 stls1 \\<and>\n                                 s1 -1-stls1\\<rightarrow>*t \\<infinity> \\<and>\n                                 s1 \\<approx> s2) \\<or>\n                             s' -2-stls\\<rightarrow>*t \\<infinity>)", "from simulation1[OF bisim r]"], ["proof (chain)\npicking this:\n  \\<exists>s2' tl2.\n     s2 -2-tl2\\<rightarrow> s2' \\<and>\n     s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2", "obtain s2' tl2\n        where \"s2 -2-tl2\\<rightarrow> s2'\" \"s1' \\<approx> s2'\" \"tl1 \\<sim> tl2\""], ["proof (prove)\nusing this:\n  \\<exists>s2' tl2.\n     s2 -2-tl2\\<rightarrow> s2' \\<and>\n     s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. (\\<And>tl2 s2'.\n        \\<lbrakk>s2 -2-tl2\\<rightarrow> s2'; s1' \\<approx> s2';\n         tl1 \\<sim> tl2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s2 -2-tl2\\<rightarrow> s2'\n  s1' \\<approx> s2'\n  tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. \\<And>s' stls tl.\n       \\<lbrakk>stls1 = LCons (s1, tl, s') stls; s1 -1-tl\\<rightarrow> s';\n        s' -1-stls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s s' stls tl.\n                            s2 = s \\<and>\n                            tl1_to_tl2 s2 stls1 =\n                            LCons (s, tl, s') stls \\<and>\n                            s -2-tl\\<rightarrow> s' \\<and>\n                            ((\\<exists>s2 s1 stls1.\n                                 s' = s2 \\<and>\n                                 stls = tl1_to_tl2 s2 stls1 \\<and>\n                                 s1 -1-stls1\\<rightarrow>*t \\<infinity> \\<and>\n                                 s1 \\<approx> s2) \\<or>\n                             s' -2-stls\\<rightarrow>*t \\<infinity>)", "hence \"(\\<lambda>(tl2, s2'). s2 -2-tl2\\<rightarrow> s2' \\<and> s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2) (tl2, s2')\""], ["proof (prove)\nusing this:\n  s2 -2-tl2\\<rightarrow> s2'\n  s1' \\<approx> s2'\n  tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. case (tl2, s2') of\n    (tl2, s2') \\<Rightarrow>\n      s2 -2-tl2\\<rightarrow> s2' \\<and>\n      s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2", "by simp"], ["proof (state)\nthis:\n  case (tl2, s2') of\n  (tl2, s2') \\<Rightarrow>\n    s2 -2-tl2\\<rightarrow> s2' \\<and>\n    s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. \\<And>s' stls tl.\n       \\<lbrakk>stls1 = LCons (s1, tl, s') stls; s1 -1-tl\\<rightarrow> s';\n        s' -1-stls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s s' stls tl.\n                            s2 = s \\<and>\n                            tl1_to_tl2 s2 stls1 =\n                            LCons (s, tl, s') stls \\<and>\n                            s -2-tl\\<rightarrow> s' \\<and>\n                            ((\\<exists>s2 s1 stls1.\n                                 s' = s2 \\<and>\n                                 stls = tl1_to_tl2 s2 stls1 \\<and>\n                                 s1 -1-stls1\\<rightarrow>*t \\<infinity> \\<and>\n                                 s1 \\<approx> s2) \\<or>\n                             s' -2-stls\\<rightarrow>*t \\<infinity>)", "hence \"(\\<lambda>(tl2, s2'). s2 -2-tl2\\<rightarrow> s2' \\<and> s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2) ?tl2s2'\""], ["proof (prove)\nusing this:\n  case (tl2, s2') of\n  (tl2, s2') \\<Rightarrow>\n    s2 -2-tl2\\<rightarrow> s2' \\<and>\n    s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. case SOME (tl2, s2').\n            s2 -2-tl2\\<rightarrow> s2' \\<and>\n            s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2 of\n    (tl2, s2') \\<Rightarrow>\n      s2 -2-tl2\\<rightarrow> s2' \\<and>\n      s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2", "by(rule someI)"], ["proof (state)\nthis:\n  case SOME (tl2, s2').\n          s2 -2-tl2\\<rightarrow> s2' \\<and>\n          s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2 of\n  (tl2, s2') \\<Rightarrow>\n    s2 -2-tl2\\<rightarrow> s2' \\<and>\n    s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. \\<And>s' stls tl.\n       \\<lbrakk>stls1 = LCons (s1, tl, s') stls; s1 -1-tl\\<rightarrow> s';\n        s' -1-stls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s s' stls tl.\n                            s2 = s \\<and>\n                            tl1_to_tl2 s2 stls1 =\n                            LCons (s, tl, s') stls \\<and>\n                            s -2-tl\\<rightarrow> s' \\<and>\n                            ((\\<exists>s2 s1 stls1.\n                                 s' = s2 \\<and>\n                                 stls = tl1_to_tl2 s2 stls1 \\<and>\n                                 s1 -1-stls1\\<rightarrow>*t \\<infinity> \\<and>\n                                 s1 \\<approx> s2) \\<or>\n                             s' -2-stls\\<rightarrow>*t \\<infinity>)", "hence \"s2 -2-?tl2\\<rightarrow> ?s2'\" \"s1' \\<approx> ?s2'\" \"tl1 \\<sim> ?tl2\""], ["proof (prove)\nusing this:\n  case SOME (tl2, s2').\n          s2 -2-tl2\\<rightarrow> s2' \\<and>\n          s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2 of\n  (tl2, s2') \\<Rightarrow>\n    s2 -2-tl2\\<rightarrow> s2' \\<and>\n    s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. s2 -2-fst (SOME (tl2, s2').\n                  s2 -2-tl2\\<rightarrow> s2' \\<and>\n                  s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2)\\<rightarrow>\n    snd (SOME (tl2, s2').\n            s2 -2-tl2\\<rightarrow> s2' \\<and>\n            s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2) &&&\n    s1'\n    \\<approx> snd (SOME (tl2, s2').\n                      s2 -2-tl2\\<rightarrow> s2' \\<and>\n                      s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2) &&&\n    tl1\n    \\<sim> fst (SOME (tl2, s2').\n                   s2 -2-tl2\\<rightarrow> s2' \\<and>\n                   s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2)", "by(simp_all add: split_beta)"], ["proof (state)\nthis:\n  s2 -2-fst (SOME (tl2, s2').\n                s2 -2-tl2\\<rightarrow> s2' \\<and>\n                s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2)\\<rightarrow>\n  snd (SOME (tl2, s2').\n          s2 -2-tl2\\<rightarrow> s2' \\<and>\n          s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2)\n  s1'\n  \\<approx> snd (SOME (tl2, s2').\n                    s2 -2-tl2\\<rightarrow> s2' \\<and>\n                    s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2)\n  tl1\n  \\<sim> fst (SOME (tl2, s2').\n                 s2 -2-tl2\\<rightarrow> s2' \\<and>\n                 s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2)\n\ngoal (1 subgoal):\n 1. \\<And>s' stls tl.\n       \\<lbrakk>stls1 = LCons (s1, tl, s') stls; s1 -1-tl\\<rightarrow> s';\n        s' -1-stls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s s' stls tl.\n                            s2 = s \\<and>\n                            tl1_to_tl2 s2 stls1 =\n                            LCons (s, tl, s') stls \\<and>\n                            s -2-tl\\<rightarrow> s' \\<and>\n                            ((\\<exists>s2 s1 stls1.\n                                 s' = s2 \\<and>\n                                 stls = tl1_to_tl2 s2 stls1 \\<and>\n                                 s1 -1-stls1\\<rightarrow>*t \\<infinity> \\<and>\n                                 s1 \\<approx> s2) \\<or>\n                             s' -2-stls\\<rightarrow>*t \\<infinity>)", "then"], ["proof (chain)\npicking this:\n  s2 -2-fst (SOME (tl2, s2').\n                s2 -2-tl2\\<rightarrow> s2' \\<and>\n                s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2)\\<rightarrow>\n  snd (SOME (tl2, s2').\n          s2 -2-tl2\\<rightarrow> s2' \\<and>\n          s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2)\n  s1'\n  \\<approx> snd (SOME (tl2, s2').\n                    s2 -2-tl2\\<rightarrow> s2' \\<and>\n                    s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2)\n  tl1\n  \\<sim> fst (SOME (tl2, s2').\n                 s2 -2-tl2\\<rightarrow> s2' \\<and>\n                 s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2)", "show ?thesis"], ["proof (prove)\nusing this:\n  s2 -2-fst (SOME (tl2, s2').\n                s2 -2-tl2\\<rightarrow> s2' \\<and>\n                s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2)\\<rightarrow>\n  snd (SOME (tl2, s2').\n          s2 -2-tl2\\<rightarrow> s2' \\<and>\n          s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2)\n  s1'\n  \\<approx> snd (SOME (tl2, s2').\n                    s2 -2-tl2\\<rightarrow> s2' \\<and>\n                    s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2)\n  tl1\n  \\<sim> fst (SOME (tl2, s2').\n                 s2 -2-tl2\\<rightarrow> s2' \\<and>\n                 s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2)\n\ngoal (1 subgoal):\n 1. \\<exists>s s' stls tl.\n       s2 = s \\<and>\n       tl1_to_tl2 s2 stls1 = LCons (s, tl, s') stls \\<and>\n       s -2-tl\\<rightarrow> s' \\<and>\n       ((\\<exists>s2 s1 stls1.\n            s' = s2 \\<and>\n            stls = tl1_to_tl2 s2 stls1 \\<and>\n            s1 -1-stls1\\<rightarrow>*t \\<infinity> \\<and> s1\n            \\<approx> s2) \\<or>\n        s' -2-stls\\<rightarrow>*t \\<infinity>)", "using reds1 stls1"], ["proof (prove)\nusing this:\n  s2 -2-fst (SOME (tl2, s2').\n                s2 -2-tl2\\<rightarrow> s2' \\<and>\n                s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2)\\<rightarrow>\n  snd (SOME (tl2, s2').\n          s2 -2-tl2\\<rightarrow> s2' \\<and>\n          s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2)\n  s1'\n  \\<approx> snd (SOME (tl2, s2').\n                    s2 -2-tl2\\<rightarrow> s2' \\<and>\n                    s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2)\n  tl1\n  \\<sim> fst (SOME (tl2, s2').\n                 s2 -2-tl2\\<rightarrow> s2' \\<and>\n                 s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2)\n  s1' -1-stls1'\\<rightarrow>*t \\<infinity>\n  stls1 = LCons (s1, tl1, s1') stls1'\n\ngoal (1 subgoal):\n 1. \\<exists>s s' stls tl.\n       s2 = s \\<and>\n       tl1_to_tl2 s2 stls1 = LCons (s, tl, s') stls \\<and>\n       s -2-tl\\<rightarrow> s' \\<and>\n       ((\\<exists>s2 s1 stls1.\n            s' = s2 \\<and>\n            stls = tl1_to_tl2 s2 stls1 \\<and>\n            s1 -1-stls1\\<rightarrow>*t \\<infinity> \\<and> s1\n            \\<approx> s2) \\<or>\n        s' -2-stls\\<rightarrow>*t \\<infinity>)", "by(fastforce intro: prod_eqI)"], ["proof (state)\nthis:\n  \\<exists>s s' stls tl.\n     s2 = s \\<and>\n     tl1_to_tl2 s2 stls1 = LCons (s, tl, s') stls \\<and>\n     s -2-tl\\<rightarrow> s' \\<and>\n     ((\\<exists>s2 s1 stls1.\n          s' = s2 \\<and>\n          stls = tl1_to_tl2 s2 stls1 \\<and>\n          s1 -1-stls1\\<rightarrow>*t \\<infinity> \\<and> s1\n          \\<approx> s2) \\<or>\n      s' -2-stls\\<rightarrow>*t \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s s' stls tl.\n     s2 = s \\<and>\n     tl1_to_tl2 s2 stls1 = LCons (s, tl, s') stls \\<and>\n     s -2-tl\\<rightarrow> s' \\<and>\n     ((\\<exists>s2 s1 stls1.\n          s' = s2 \\<and>\n          stls = tl1_to_tl2 s2 stls1 \\<and>\n          s1 -1-stls1\\<rightarrow>*t \\<infinity> \\<and> s1\n          \\<approx> s2) \\<or>\n      s' -2-stls\\<rightarrow>*t \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s2 -2-tl1_to_tl2 s2 stls1\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>tls2.\n       s2 -2-tls2\\<rightarrow>* \\<infinity> \\<and> tls1 [[\\<sim>]] tls2", "hence \"s2 -2-lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)\\<rightarrow>* \\<infinity>\""], ["proof (prove)\nusing this:\n  s2 -2-tl1_to_tl2 s2 stls1\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. s2 -2-lmap (fst \\<circ> snd)\n           (tl1_to_tl2 s2 stls1)\\<rightarrow>* \\<infinity>", "by(rule r2.inf_step_table_imp_inf_step)"], ["proof (state)\nthis:\n  s2 -2-lmap (fst \\<circ> snd)\n         (tl1_to_tl2 s2 stls1)\\<rightarrow>* \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>tls2.\n       s2 -2-tls2\\<rightarrow>* \\<infinity> \\<and> tls1 [[\\<sim>]] tls2", "moreover"], ["proof (state)\nthis:\n  s2 -2-lmap (fst \\<circ> snd)\n         (tl1_to_tl2 s2 stls1)\\<rightarrow>* \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>tls2.\n       s2 -2-tls2\\<rightarrow>* \\<infinity> \\<and> tls1 [[\\<sim>]] tls2", "have \"tls1 [[\\<sim>]] lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tls1 [[\\<sim>]] lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)", "proof(rule llist_all2_all_lnthI)"], ["proof (state)\ngoal (2 subgoals):\n 1. llength tls1 = llength (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1))\n 2. \\<And>n.\n       enat n < llength tls1 \\<Longrightarrow>\n       lnth tls1 n\n       \\<sim> lnth (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)) n", "show \"llength tls1 = llength (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength tls1 = llength (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1))", "using tls1"], ["proof (prove)\nusing this:\n  tls1 = lmap (fst \\<circ> snd) stls1\n\ngoal (1 subgoal):\n 1. llength tls1 = llength (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1))", "by simp"], ["proof (state)\nthis:\n  llength tls1 = llength (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       enat n < llength tls1 \\<Longrightarrow>\n       lnth tls1 n\n       \\<sim> lnth (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)) n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       enat n < llength tls1 \\<Longrightarrow>\n       lnth tls1 n\n       \\<sim> lnth (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)) n", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       enat n < llength tls1 \\<Longrightarrow>\n       lnth tls1 n\n       \\<sim> lnth (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)) n", "assume \"enat n < llength tls1\""], ["proof (state)\nthis:\n  enat n < llength tls1\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       enat n < llength tls1 \\<Longrightarrow>\n       lnth tls1 n\n       \\<sim> lnth (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)) n", "thus \"lnth tls1 n \\<sim> lnth (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)) n\""], ["proof (prove)\nusing this:\n  enat n < llength tls1\n\ngoal (1 subgoal):\n 1. lnth tls1 n \\<sim> lnth (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)) n", "using red1' bisim"], ["proof (prove)\nusing this:\n  enat n < llength tls1\n  s1 -1-stls1\\<rightarrow>*t \\<infinity>\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. lnth tls1 n \\<sim> lnth (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)) n", "unfolding tls1"], ["proof (prove)\nusing this:\n  enat n < llength (lmap (fst \\<circ> snd) stls1)\n  s1 -1-stls1\\<rightarrow>*t \\<infinity>\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. lnth (lmap (fst \\<circ> snd) stls1) n\n    \\<sim> lnth (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)) n", "proof(induct n arbitrary: s1 s2 stls1 rule: nat_less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n s1 s2 stls1.\n       \\<lbrakk>\\<forall>m<n.\n                   \\<forall>x xa xb.\n                      enat m\n                      < llength\n                         (lmap (fst \\<circ> snd) xb) \\<longrightarrow>\n                      x -1-xb\\<rightarrow>*t \\<infinity> \\<longrightarrow>\n                      x \\<approx> xa \\<longrightarrow>\n                      lnth (lmap (fst \\<circ> snd) xb) m\n                      \\<sim> lnth\n                              (lmap (fst \\<circ> snd) (tl1_to_tl2 xa xb)) m;\n        enat n < llength (lmap (fst \\<circ> snd) stls1);\n        s1 -1-stls1\\<rightarrow>*t \\<infinity>; s1 \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap (fst \\<circ> snd) stls1) n\n                         \\<sim> lnth\n                                 (lmap (fst \\<circ> snd)\n                                   (tl1_to_tl2 s2 stls1))\n                                 n", "case (1 n)"], ["proof (state)\nthis:\n  \\<forall>m<n.\n     \\<forall>x xa xb.\n        enat m < llength (lmap (fst \\<circ> snd) xb) \\<longrightarrow>\n        x -1-xb\\<rightarrow>*t \\<infinity> \\<longrightarrow>\n        x \\<approx> xa \\<longrightarrow> lnth (lmap (fst \\<circ> snd) xb) m\n        \\<sim> lnth (lmap (fst \\<circ> snd) (tl1_to_tl2 xa xb)) m\n  enat n < llength (lmap (fst \\<circ> snd) stls1)\n  s1 -1-stls1\\<rightarrow>*t \\<infinity>\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. \\<And>n s1 s2 stls1.\n       \\<lbrakk>\\<forall>m<n.\n                   \\<forall>x xa xb.\n                      enat m\n                      < llength\n                         (lmap (fst \\<circ> snd) xb) \\<longrightarrow>\n                      x -1-xb\\<rightarrow>*t \\<infinity> \\<longrightarrow>\n                      x \\<approx> xa \\<longrightarrow>\n                      lnth (lmap (fst \\<circ> snd) xb) m\n                      \\<sim> lnth\n                              (lmap (fst \\<circ> snd) (tl1_to_tl2 xa xb)) m;\n        enat n < llength (lmap (fst \\<circ> snd) stls1);\n        s1 -1-stls1\\<rightarrow>*t \\<infinity>; s1 \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap (fst \\<circ> snd) stls1) n\n                         \\<sim> lnth\n                                 (lmap (fst \\<circ> snd)\n                                   (tl1_to_tl2 s2 stls1))\n                                 n", "hence IH: \"\\<And>m s1 s2 stls1. \\<lbrakk> m < n; enat m < llength (lmap (fst \\<circ> snd) stls1);\n                                   s1 -1-stls1\\<rightarrow>*t \\<infinity>; s1 \\<approx> s2 \\<rbrakk>\n                 \\<Longrightarrow> lnth (lmap (fst \\<circ> snd) stls1) m \\<sim> lnth (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)) m\""], ["proof (prove)\nusing this:\n  \\<forall>m<n.\n     \\<forall>x xa xb.\n        enat m < llength (lmap (fst \\<circ> snd) xb) \\<longrightarrow>\n        x -1-xb\\<rightarrow>*t \\<infinity> \\<longrightarrow>\n        x \\<approx> xa \\<longrightarrow> lnth (lmap (fst \\<circ> snd) xb) m\n        \\<sim> lnth (lmap (fst \\<circ> snd) (tl1_to_tl2 xa xb)) m\n  enat n < llength (lmap (fst \\<circ> snd) stls1)\n  s1 -1-stls1\\<rightarrow>*t \\<infinity>\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. \\<And>m s1 s2 stls1.\n       \\<lbrakk>m < n; enat m < llength (lmap (fst \\<circ> snd) stls1);\n        s1 -1-stls1\\<rightarrow>*t \\<infinity>; s1 \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap (fst \\<circ> snd) stls1) m\n                         \\<sim> lnth\n                                 (lmap (fst \\<circ> snd)\n                                   (tl1_to_tl2 s2 stls1))\n                                 m", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?m < n; enat ?m < llength (lmap (fst \\<circ> snd) ?stls1.0);\n   ?s1.0 -1-?stls1.0\\<rightarrow>*t \\<infinity>;\n   ?s1.0 \\<approx> ?s2.0\\<rbrakk>\n  \\<Longrightarrow> lnth (lmap (fst \\<circ> snd) ?stls1.0) ?m\n                    \\<sim> lnth\n                            (lmap (fst \\<circ> snd)\n                              (tl1_to_tl2 ?s2.0 ?stls1.0))\n                            ?m\n\ngoal (1 subgoal):\n 1. \\<And>n s1 s2 stls1.\n       \\<lbrakk>\\<forall>m<n.\n                   \\<forall>x xa xb.\n                      enat m\n                      < llength\n                         (lmap (fst \\<circ> snd) xb) \\<longrightarrow>\n                      x -1-xb\\<rightarrow>*t \\<infinity> \\<longrightarrow>\n                      x \\<approx> xa \\<longrightarrow>\n                      lnth (lmap (fst \\<circ> snd) xb) m\n                      \\<sim> lnth\n                              (lmap (fst \\<circ> snd) (tl1_to_tl2 xa xb)) m;\n        enat n < llength (lmap (fst \\<circ> snd) stls1);\n        s1 -1-stls1\\<rightarrow>*t \\<infinity>; s1 \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap (fst \\<circ> snd) stls1) n\n                         \\<sim> lnth\n                                 (lmap (fst \\<circ> snd)\n                                   (tl1_to_tl2 s2 stls1))\n                                 n", "from \\<open>s1 -1-stls1\\<rightarrow>*t \\<infinity>\\<close>"], ["proof (chain)\npicking this:\n  s1 -1-stls1\\<rightarrow>*t \\<infinity>", "show ?case"], ["proof (prove)\nusing this:\n  s1 -1-stls1\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. lnth (lmap (fst \\<circ> snd) stls1) n\n    \\<sim> lnth (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)) n", "proof cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s' stls tl.\n       \\<lbrakk>stls1 = LCons (s1, tl, s') stls; s1 -1-tl\\<rightarrow> s';\n        s' -1-stls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap (fst \\<circ> snd) stls1) n\n                         \\<sim> lnth\n                                 (lmap (fst \\<circ> snd)\n                                   (tl1_to_tl2 s2 stls1))\n                                 n", "case (inf_step_tableI s1' stls1' tl1)"], ["proof (state)\nthis:\n  stls1 = LCons (s1, tl1, s1') stls1'\n  s1 -1-tl1\\<rightarrow> s1'\n  s1' -1-stls1'\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>s' stls tl.\n       \\<lbrakk>stls1 = LCons (s1, tl, s') stls; s1 -1-tl\\<rightarrow> s';\n        s' -1-stls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap (fst \\<circ> snd) stls1) n\n                         \\<sim> lnth\n                                 (lmap (fst \\<circ> snd)\n                                   (tl1_to_tl2 s2 stls1))\n                                 n", "hence  stls1: \"stls1 = LCons (s1, tl1, s1') stls1'\"\n          and r: \"s1 -1-tl1\\<rightarrow> s1'\" and reds: \"s1' -1-stls1'\\<rightarrow>*t \\<infinity>\""], ["proof (prove)\nusing this:\n  stls1 = LCons (s1, tl1, s1') stls1'\n  s1 -1-tl1\\<rightarrow> s1'\n  s1' -1-stls1'\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. stls1 = LCons (s1, tl1, s1') stls1' &&&\n    s1 -1-tl1\\<rightarrow> s1' &&& s1' -1-stls1'\\<rightarrow>*t \\<infinity>", "by simp_all"], ["proof (state)\nthis:\n  stls1 = LCons (s1, tl1, s1') stls1'\n  s1 -1-tl1\\<rightarrow> s1'\n  s1' -1-stls1'\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>s' stls tl.\n       \\<lbrakk>stls1 = LCons (s1, tl, s') stls; s1 -1-tl\\<rightarrow> s';\n        s' -1-stls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap (fst \\<circ> snd) stls1) n\n                         \\<sim> lnth\n                                 (lmap (fst \\<circ> snd)\n                                   (tl1_to_tl2 s2 stls1))\n                                 n", "let ?tl2s2' = \"SOME (tl2, s2').  s2 -2-tl2\\<rightarrow> s2' \\<and> s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s' stls tl.\n       \\<lbrakk>stls1 = LCons (s1, tl, s') stls; s1 -1-tl\\<rightarrow> s';\n        s' -1-stls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap (fst \\<circ> snd) stls1) n\n                         \\<sim> lnth\n                                 (lmap (fst \\<circ> snd)\n                                   (tl1_to_tl2 s2 stls1))\n                                 n", "let ?tl2 = \"fst ?tl2s2'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s' stls tl.\n       \\<lbrakk>stls1 = LCons (s1, tl, s') stls; s1 -1-tl\\<rightarrow> s';\n        s' -1-stls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap (fst \\<circ> snd) stls1) n\n                         \\<sim> lnth\n                                 (lmap (fst \\<circ> snd)\n                                   (tl1_to_tl2 s2 stls1))\n                                 n", "let ?s2' = \"snd ?tl2s2'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s' stls tl.\n       \\<lbrakk>stls1 = LCons (s1, tl, s') stls; s1 -1-tl\\<rightarrow> s';\n        s' -1-stls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap (fst \\<circ> snd) stls1) n\n                         \\<sim> lnth\n                                 (lmap (fst \\<circ> snd)\n                                   (tl1_to_tl2 s2 stls1))\n                                 n", "from simulation1[OF \\<open>s1 \\<approx> s2\\<close> r]"], ["proof (chain)\npicking this:\n  \\<exists>s2' tl2.\n     s2 -2-tl2\\<rightarrow> s2' \\<and>\n     s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2", "obtain s2' tl2\n          where \"s2 -2-tl2\\<rightarrow> s2' \\<and> s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2\""], ["proof (prove)\nusing this:\n  \\<exists>s2' tl2.\n     s2 -2-tl2\\<rightarrow> s2' \\<and>\n     s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. (\\<And>tl2 s2'.\n        s2 -2-tl2\\<rightarrow> s2' \\<and>\n        s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s2 -2-tl2\\<rightarrow> s2' \\<and> s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. \\<And>s' stls tl.\n       \\<lbrakk>stls1 = LCons (s1, tl, s') stls; s1 -1-tl\\<rightarrow> s';\n        s' -1-stls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap (fst \\<circ> snd) stls1) n\n                         \\<sim> lnth\n                                 (lmap (fst \\<circ> snd)\n                                   (tl1_to_tl2 s2 stls1))\n                                 n", "hence \"(\\<lambda>(tl2, s2'). s2 -2-tl2\\<rightarrow> s2' \\<and> s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2) (tl2, s2')\""], ["proof (prove)\nusing this:\n  s2 -2-tl2\\<rightarrow> s2' \\<and> s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. case (tl2, s2') of\n    (tl2, s2') \\<Rightarrow>\n      s2 -2-tl2\\<rightarrow> s2' \\<and>\n      s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2", "by simp"], ["proof (state)\nthis:\n  case (tl2, s2') of\n  (tl2, s2') \\<Rightarrow>\n    s2 -2-tl2\\<rightarrow> s2' \\<and>\n    s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. \\<And>s' stls tl.\n       \\<lbrakk>stls1 = LCons (s1, tl, s') stls; s1 -1-tl\\<rightarrow> s';\n        s' -1-stls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap (fst \\<circ> snd) stls1) n\n                         \\<sim> lnth\n                                 (lmap (fst \\<circ> snd)\n                                   (tl1_to_tl2 s2 stls1))\n                                 n", "hence \"(\\<lambda>(tl2, s2'). s2 -2-tl2\\<rightarrow> s2' \\<and> s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2) ?tl2s2'\""], ["proof (prove)\nusing this:\n  case (tl2, s2') of\n  (tl2, s2') \\<Rightarrow>\n    s2 -2-tl2\\<rightarrow> s2' \\<and>\n    s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. case SOME (tl2, s2').\n            s2 -2-tl2\\<rightarrow> s2' \\<and>\n            s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2 of\n    (tl2, s2') \\<Rightarrow>\n      s2 -2-tl2\\<rightarrow> s2' \\<and>\n      s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2", "by(rule someI)"], ["proof (state)\nthis:\n  case SOME (tl2, s2').\n          s2 -2-tl2\\<rightarrow> s2' \\<and>\n          s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2 of\n  (tl2, s2') \\<Rightarrow>\n    s2 -2-tl2\\<rightarrow> s2' \\<and>\n    s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. \\<And>s' stls tl.\n       \\<lbrakk>stls1 = LCons (s1, tl, s') stls; s1 -1-tl\\<rightarrow> s';\n        s' -1-stls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap (fst \\<circ> snd) stls1) n\n                         \\<sim> lnth\n                                 (lmap (fst \\<circ> snd)\n                                   (tl1_to_tl2 s2 stls1))\n                                 n", "hence bisim': \"s1' \\<approx> ?s2'\" and tlsim: \"tl1 \\<sim> ?tl2\""], ["proof (prove)\nusing this:\n  case SOME (tl2, s2').\n          s2 -2-tl2\\<rightarrow> s2' \\<and>\n          s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2 of\n  (tl2, s2') \\<Rightarrow>\n    s2 -2-tl2\\<rightarrow> s2' \\<and>\n    s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. s1'\n    \\<approx> snd (SOME (tl2, s2').\n                      s2 -2-tl2\\<rightarrow> s2' \\<and>\n                      s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2) &&&\n    tl1\n    \\<sim> fst (SOME (tl2, s2').\n                   s2 -2-tl2\\<rightarrow> s2' \\<and>\n                   s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2)", "by(simp_all add: split_beta)"], ["proof (state)\nthis:\n  s1'\n  \\<approx> snd (SOME (tl2, s2').\n                    s2 -2-tl2\\<rightarrow> s2' \\<and>\n                    s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2)\n  tl1\n  \\<sim> fst (SOME (tl2, s2').\n                 s2 -2-tl2\\<rightarrow> s2' \\<and>\n                 s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2)\n\ngoal (1 subgoal):\n 1. \\<And>s' stls tl.\n       \\<lbrakk>stls1 = LCons (s1, tl, s') stls; s1 -1-tl\\<rightarrow> s';\n        s' -1-stls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap (fst \\<circ> snd) stls1) n\n                         \\<sim> lnth\n                                 (lmap (fst \\<circ> snd)\n                                   (tl1_to_tl2 s2 stls1))\n                                 n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lnth (lmap (fst \\<circ> snd) stls1) n\n    \\<sim> lnth (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)) n", "proof(cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    lnth (lmap (fst \\<circ> snd) stls1) n\n    \\<sim> lnth (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)) n\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       lnth (lmap (fst \\<circ> snd) stls1) n\n       \\<sim> lnth (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)) n", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    lnth (lmap (fst \\<circ> snd) stls1) n\n    \\<sim> lnth (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)) n\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       lnth (lmap (fst \\<circ> snd) stls1) n\n       \\<sim> lnth (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)) n", "with stls1 tlsim"], ["proof (chain)\npicking this:\n  stls1 = LCons (s1, tl1, s1') stls1'\n  tl1\n  \\<sim> fst (SOME (tl2, s2').\n                 s2 -2-tl2\\<rightarrow> s2' \\<and>\n                 s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2)\n  n = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  stls1 = LCons (s1, tl1, s1') stls1'\n  tl1\n  \\<sim> fst (SOME (tl2, s2').\n                 s2 -2-tl2\\<rightarrow> s2' \\<and>\n                 s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2)\n  n = 0\n\ngoal (1 subgoal):\n 1. lnth (lmap (fst \\<circ> snd) stls1) n\n    \\<sim> lnth (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)) n", "by simp"], ["proof (state)\nthis:\n  lnth (lmap (fst \\<circ> snd) stls1) n\n  \\<sim> lnth (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)) n\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       lnth (lmap (fst \\<circ> snd) stls1) n\n       \\<sim> lnth (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)) n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       lnth (lmap (fst \\<circ> snd) stls1) n\n       \\<sim> lnth (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)) n", "case (Suc m)"], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       lnth (lmap (fst \\<circ> snd) stls1) n\n       \\<sim> lnth (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)) n", "hence \"m < n\""], ["proof (prove)\nusing this:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. m < n", "by simp"], ["proof (state)\nthis:\n  m < n\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       lnth (lmap (fst \\<circ> snd) stls1) n\n       \\<sim> lnth (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)) n", "moreover"], ["proof (state)\nthis:\n  m < n\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       lnth (lmap (fst \\<circ> snd) stls1) n\n       \\<sim> lnth (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)) n", "have \"enat m < llength (lmap (fst \\<circ> snd) stls1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat m < llength (lmap (fst \\<circ> snd) stls1')", "using stls1 \\<open>enat n < llength (lmap (fst \\<circ> snd) stls1)\\<close> Suc"], ["proof (prove)\nusing this:\n  stls1 = LCons (s1, tl1, s1') stls1'\n  enat n < llength (lmap (fst \\<circ> snd) stls1)\n  n = Suc m\n\ngoal (1 subgoal):\n 1. enat m < llength (lmap (fst \\<circ> snd) stls1')", "by(simp add: Suc_ile_eq)"], ["proof (state)\nthis:\n  enat m < llength (lmap (fst \\<circ> snd) stls1')\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       lnth (lmap (fst \\<circ> snd) stls1) n\n       \\<sim> lnth (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)) n", "ultimately"], ["proof (chain)\npicking this:\n  m < n\n  enat m < llength (lmap (fst \\<circ> snd) stls1')", "have \"lnth (lmap (fst \\<circ> snd) stls1') m \\<sim> lnth (lmap (fst \\<circ> snd) (tl1_to_tl2 ?s2' stls1')) m\""], ["proof (prove)\nusing this:\n  m < n\n  enat m < llength (lmap (fst \\<circ> snd) stls1')\n\ngoal (1 subgoal):\n 1. lnth (lmap (fst \\<circ> snd) stls1') m\n    \\<sim> lnth\n            (lmap (fst \\<circ> snd)\n              (tl1_to_tl2\n                (snd (SOME (tl2, s2').\n                         s2 -2-tl2\\<rightarrow> s2' \\<and>\n                         s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2))\n                stls1'))\n            m", "using reds bisim'"], ["proof (prove)\nusing this:\n  m < n\n  enat m < llength (lmap (fst \\<circ> snd) stls1')\n  s1' -1-stls1'\\<rightarrow>*t \\<infinity>\n  s1'\n  \\<approx> snd (SOME (tl2, s2').\n                    s2 -2-tl2\\<rightarrow> s2' \\<and>\n                    s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2)\n\ngoal (1 subgoal):\n 1. lnth (lmap (fst \\<circ> snd) stls1') m\n    \\<sim> lnth\n            (lmap (fst \\<circ> snd)\n              (tl1_to_tl2\n                (snd (SOME (tl2, s2').\n                         s2 -2-tl2\\<rightarrow> s2' \\<and>\n                         s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2))\n                stls1'))\n            m", "by(rule IH)"], ["proof (state)\nthis:\n  lnth (lmap (fst \\<circ> snd) stls1') m\n  \\<sim> lnth\n          (lmap (fst \\<circ> snd)\n            (tl1_to_tl2\n              (snd (SOME (tl2, s2').\n                       s2 -2-tl2\\<rightarrow> s2' \\<and>\n                       s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2))\n              stls1'))\n          m\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       lnth (lmap (fst \\<circ> snd) stls1) n\n       \\<sim> lnth (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)) n", "with Suc stls1"], ["proof (chain)\npicking this:\n  n = Suc m\n  stls1 = LCons (s1, tl1, s1') stls1'\n  lnth (lmap (fst \\<circ> snd) stls1') m\n  \\<sim> lnth\n          (lmap (fst \\<circ> snd)\n            (tl1_to_tl2\n              (snd (SOME (tl2, s2').\n                       s2 -2-tl2\\<rightarrow> s2' \\<and>\n                       s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2))\n              stls1'))\n          m", "show ?thesis"], ["proof (prove)\nusing this:\n  n = Suc m\n  stls1 = LCons (s1, tl1, s1') stls1'\n  lnth (lmap (fst \\<circ> snd) stls1') m\n  \\<sim> lnth\n          (lmap (fst \\<circ> snd)\n            (tl1_to_tl2\n              (snd (SOME (tl2, s2').\n                       s2 -2-tl2\\<rightarrow> s2' \\<and>\n                       s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2))\n              stls1'))\n          m\n\ngoal (1 subgoal):\n 1. lnth (lmap (fst \\<circ> snd) stls1) n\n    \\<sim> lnth (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)) n", "by(simp del: o_apply)"], ["proof (state)\nthis:\n  lnth (lmap (fst \\<circ> snd) stls1) n\n  \\<sim> lnth (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)) n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lnth (lmap (fst \\<circ> snd) stls1) n\n  \\<sim> lnth (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)) n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lnth (lmap (fst \\<circ> snd) stls1) n\n  \\<sim> lnth (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)) n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lnth tls1 n \\<sim> lnth (lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)) n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  tls1 [[\\<sim>]] lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)\n\ngoal (1 subgoal):\n 1. \\<exists>tls2.\n       s2 -2-tls2\\<rightarrow>* \\<infinity> \\<and> tls1 [[\\<sim>]] tls2", "ultimately"], ["proof (chain)\npicking this:\n  s2 -2-lmap (fst \\<circ> snd)\n         (tl1_to_tl2 s2 stls1)\\<rightarrow>* \\<infinity>\n  tls1 [[\\<sim>]] lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)", "show ?thesis"], ["proof (prove)\nusing this:\n  s2 -2-lmap (fst \\<circ> snd)\n         (tl1_to_tl2 s2 stls1)\\<rightarrow>* \\<infinity>\n  tls1 [[\\<sim>]] lmap (fst \\<circ> snd) (tl1_to_tl2 s2 stls1)\n\ngoal (1 subgoal):\n 1. \\<exists>tls2.\n       s2 -2-tls2\\<rightarrow>* \\<infinity> \\<and> tls1 [[\\<sim>]] tls2", "by blast"], ["proof (state)\nthis:\n  \\<exists>tls2.\n     s2 -2-tls2\\<rightarrow>* \\<infinity> \\<and> tls1 [[\\<sim>]] tls2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma simulation2_inf_step:\n  \"\\<lbrakk> s2 -2-tls2\\<rightarrow>* \\<infinity>; s1 \\<approx> s2 \\<rbrakk> \\<Longrightarrow> \\<exists>tls1. s1 -1-tls1\\<rightarrow>* \\<infinity> \\<and> tls1 [[\\<sim>]] tls2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s2 -2-tls2\\<rightarrow>* \\<infinity>; s1 \\<approx> s2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tls1.\n                         s1 -1-tls1\\<rightarrow>* \\<infinity> \\<and> tls1\n                         [[\\<sim>]] tls2", "using bisimulation.simulation1_inf_step[OF bisimulation_flip]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s1.0 -2-?tls1.0\\<rightarrow>* \\<infinity>;\n   flip bisim ?s1.0 ?s2.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tls2.\n                       ?s2.0 -1-tls2\\<rightarrow>* \\<infinity> \\<and>\n                       llist_all2 (flip tlsim) ?tls1.0 tls2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s2 -2-tls2\\<rightarrow>* \\<infinity>; s1 \\<approx> s2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tls1.\n                         s1 -1-tls1\\<rightarrow>* \\<infinity> \\<and> tls1\n                         [[\\<sim>]] tls2", "unfolding flip_simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s1.0 -2-?tls1.0\\<rightarrow>* \\<infinity>;\n   ?s2.0 \\<approx> ?s1.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tls2.\n                       ?s2.0 -1-tls2\\<rightarrow>* \\<infinity> \\<and> tls2\n                       [[\\<sim>]] ?tls1.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s2 -2-tls2\\<rightarrow>* \\<infinity>; s1 \\<approx> s2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tls1.\n                         s1 -1-tls1\\<rightarrow>* \\<infinity> \\<and> tls1\n                         [[\\<sim>]] tls2", "."], ["", "end"], ["", "locale bisimulation_final_base =\n  bisimulation_base + \n  constrains trsys1 :: \"('s1, 'tl1) trsys\"\n  and trsys2 :: \"('s2, 'tl2) trsys\"\n  and bisim :: \"('s1, 's2) bisim\"\n  and tlsim :: \"('tl1, 'tl2) bisim\"\n  fixes final1 :: \"'s1 \\<Rightarrow> bool\"\n  and final2 :: \"'s2 \\<Rightarrow> bool\""], ["", "locale bisimulation_final = bisimulation_final_base + bisimulation +\n  constrains trsys1 :: \"('s1, 'tl1) trsys\"\n  and trsys2 :: \"('s2, 'tl2) trsys\"\n  and bisim :: \"('s1, 's2) bisim\"\n  and tlsim :: \"('tl1, 'tl2) bisim\"\n  and final1 :: \"'s1 \\<Rightarrow> bool\"\n  and final2 :: \"'s2 \\<Rightarrow> bool\"\n  assumes bisim_final: \"s1 \\<approx> s2 \\<Longrightarrow> final1 s1 \\<longleftrightarrow> final2 s2\"\n\nbegin"], ["", "lemma bisimulation_final_flip:\n  \"bisimulation_final trsys2 trsys1 (flip bisim) (flip tlsim) final2 final1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisimulation_final trsys2 trsys1 (flip bisim) (flip tlsim) final2 final1", "apply(intro_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. bisimulation trsys2 trsys1 (flip bisim) (flip tlsim)\n 2. bisimulation_final_axioms (flip bisim) final2 final1", "apply(rule bisimulation_flip)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bisimulation_final_axioms (flip bisim) final2 final1", "apply(unfold_locales)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s1 s2. flip bisim s1 s2 \\<Longrightarrow> final2 s1 = final1 s2", "by(unfold flip_simps, rule bisim_final[symmetric])"], ["", "end"], ["", "lemma bisimulation_final_flip_simps [flip_simps]:\n  \"bisimulation_final trsys2 trsys1 (flip bisim) (flip tlsim) final2 final1 =\n   bisimulation_final trsys1 trsys2 bisim tlsim final1 final2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisimulation_final trsys2 trsys1 (flip bisim) (flip tlsim) final2\n     final1 =\n    bisimulation_final trsys1 trsys2 bisim tlsim final1 final2", "by(auto dest: bisimulation_final.bisimulation_final_flip simp only: flip_flip)"], ["", "context bisimulation_final begin"], ["", "lemma final_simulation1:\n  \"\\<lbrakk> s1 \\<approx> s2; s1 -1-tls1\\<rightarrow>* s1'; final1 s1' \\<rbrakk>\n  \\<Longrightarrow> \\<exists>s2' tls2. s2 -2-tls2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2' \\<and> final2 s2' \\<and> tls1 [\\<sim>] tls2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx> s2; s1 -1-tls1\\<rightarrow>* s1';\n     final1 s1'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2' tls2.\n                         s2 -2-tls2\\<rightarrow>* s2' \\<and>\n                         s1' \\<approx> s2' \\<and>\n                         final2 s2' \\<and> tls1 [\\<sim>] tls2", "by(auto dest: bisim_final dest!: simulation1_rtrancl)"], ["", "lemma final_simulation2:\n  \"\\<lbrakk> s1 \\<approx> s2; s2 -2-tls2\\<rightarrow>* s2'; final2 s2' \\<rbrakk>\n  \\<Longrightarrow> \\<exists>s1' tls1. s1 -1-tls1\\<rightarrow>* s1' \\<and> s1' \\<approx> s2' \\<and> final1 s1' \\<and> tls1 [\\<sim>] tls2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx> s2; s2 -2-tls2\\<rightarrow>* s2';\n     final2 s2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s1' tls1.\n                         s1 -1-tls1\\<rightarrow>* s1' \\<and>\n                         s1' \\<approx> s2' \\<and>\n                         final1 s1' \\<and> tls1 [\\<sim>] tls2", "by(auto dest: bisim_final dest!: simulation2_rtrancl)"], ["", "end"], ["", "subsection \\<open>Delay bisimulation\\<close>"], ["", "locale delay_bisimulation_base =\n  bisimulation_base +\n  trsys1?: \\<tau>trsys trsys1 \\<tau>move1 +\n  trsys2?: \\<tau>trsys trsys2 \\<tau>move2 \n  for \\<tau>move1 \\<tau>move2 +\n  constrains trsys1 :: \"('s1, 'tl1) trsys\"\n  and trsys2 :: \"('s2, 'tl2) trsys\"\n  and bisim :: \"('s1, 's2) bisim\"\n  and tlsim :: \"('tl1, 'tl2) bisim\"\n  and \\<tau>move1 :: \"('s1, 'tl1) trsys\"\n  and \\<tau>move2 :: \"('s2, 'tl2) trsys\"\nbegin"], ["", "notation\n  trsys1.silent_move (\"_/ -\\<tau>1\\<rightarrow> _\" [50, 50] 60) and\n  trsys2.silent_move (\"_/ -\\<tau>2\\<rightarrow> _\" [50, 50] 60)"], ["", "notation\n  trsys1.silent_moves (\"_/ -\\<tau>1\\<rightarrow>* _\" [50, 50] 60) and\n  trsys2.silent_moves (\"_/ -\\<tau>2\\<rightarrow>* _\" [50, 50] 60)"], ["", "notation\n  trsys1.silent_movet (\"_/ -\\<tau>1\\<rightarrow>+ _\" [50, 50] 60) and\n  trsys2.silent_movet (\"_/ -\\<tau>2\\<rightarrow>+ _\" [50, 50] 60)"], ["", "notation\n  trsys1.\\<tau>rtrancl3p (\"_ -\\<tau>1-_\\<rightarrow>* _\" [50, 0, 50] 60) and\n  trsys2.\\<tau>rtrancl3p (\"_ -\\<tau>2-_\\<rightarrow>* _\" [50, 0, 50] 60)"], ["", "notation\n  trsys1.\\<tau>inf_step (\"_ -\\<tau>1-_\\<rightarrow>* \\<infinity>\" [50, 0] 80) and\n  trsys2.\\<tau>inf_step (\"_ -\\<tau>2-_\\<rightarrow>* \\<infinity>\" [50, 0] 80)"], ["", "notation\n  trsys1.\\<tau>diverge (\"_ -\\<tau>1\\<rightarrow> \\<infinity>\" [50] 80) and\n  trsys2.\\<tau>diverge (\"_ -\\<tau>2\\<rightarrow> \\<infinity>\" [50] 80)"], ["", "notation\n  trsys1.\\<tau>inf_step_table (\"_ -\\<tau>1-_\\<rightarrow>*t \\<infinity>\" [50, 0] 80) and\n  trsys2.\\<tau>inf_step_table (\"_ -\\<tau>2-_\\<rightarrow>*t \\<infinity>\" [50, 0] 80)"], ["", "notation\n  trsys1.\\<tau>Runs (\"_ \\<Down>1 _\" [50, 50] 51) and\n  trsys2.\\<tau>Runs (\"_ \\<Down>2 _\" [50, 50] 51)"], ["", "lemma simulation_silent1I':\n  assumes \"\\<exists>s2'. (if \\<mu>1 s1' s1 then trsys2.silent_moves else trsys2.silent_movet) s2 s2' \\<and> s1' \\<approx> s2'\"\n  shows \"s1' \\<approx> s2 \\<and> \\<mu>1^++ s1' s1 \\<or> (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')", "from assms"], ["proof (chain)\npicking this:\n  \\<exists>s2'.\n     (if \\<mu>1 s1' s1 then trsys2.silent_moves else trsys2.silent_movet) s2\n      s2' \\<and>\n     s1' \\<approx> s2'", "obtain s2' where red: \"(if \\<mu>1 s1' s1 then trsys2.silent_moves else trsys2.silent_movet) s2 s2'\" \n    and bisim: \"s1' \\<approx> s2'\""], ["proof (prove)\nusing this:\n  \\<exists>s2'.\n     (if \\<mu>1 s1' s1 then trsys2.silent_moves else trsys2.silent_movet) s2\n      s2' \\<and>\n     s1' \\<approx> s2'\n\ngoal (1 subgoal):\n 1. (\\<And>s2'.\n        \\<lbrakk>(if \\<mu>1 s1' s1 then trsys2.silent_moves\n                  else trsys2.silent_movet)\n                  s2 s2';\n         s1' \\<approx> s2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (if \\<mu>1 s1' s1 then trsys2.silent_moves else trsys2.silent_movet) s2\n   s2'\n  s1' \\<approx> s2'\n\ngoal (1 subgoal):\n 1. s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')", "proof(cases \"\\<mu>1 s1' s1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<mu>1 s1' s1 \\<Longrightarrow>\n    s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')\n 2. \\<not> \\<mu>1 s1' s1 \\<Longrightarrow>\n    s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')", "case True"], ["proof (state)\nthis:\n  \\<mu>1 s1' s1\n\ngoal (2 subgoals):\n 1. \\<mu>1 s1' s1 \\<Longrightarrow>\n    s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')\n 2. \\<not> \\<mu>1 s1' s1 \\<Longrightarrow>\n    s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')", "with red"], ["proof (chain)\npicking this:\n  (if \\<mu>1 s1' s1 then trsys2.silent_moves else trsys2.silent_movet) s2\n   s2'\n  \\<mu>1 s1' s1", "have \"s2 -\\<tau>2\\<rightarrow>* s2'\""], ["proof (prove)\nusing this:\n  (if \\<mu>1 s1' s1 then trsys2.silent_moves else trsys2.silent_movet) s2\n   s2'\n  \\<mu>1 s1' s1\n\ngoal (1 subgoal):\n 1. s2 -\\<tau>2\\<rightarrow>* s2'", "by simp"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n\ngoal (2 subgoals):\n 1. \\<mu>1 s1' s1 \\<Longrightarrow>\n    s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')\n 2. \\<not> \\<mu>1 s1' s1 \\<Longrightarrow>\n    s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')", "thus ?thesis"], ["proof (prove)\nusing this:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n\ngoal (1 subgoal):\n 1. s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')", "using bisim True"], ["proof (prove)\nusing this:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  s1' \\<approx> s2'\n  \\<mu>1 s1' s1\n\ngoal (1 subgoal):\n 1. s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')", "by cases(blast intro: rtranclp_into_tranclp1)+"], ["proof (state)\nthis:\n  s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n  (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')\n\ngoal (1 subgoal):\n 1. \\<not> \\<mu>1 s1' s1 \\<Longrightarrow>\n    s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<mu>1 s1' s1 \\<Longrightarrow>\n    s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')", "case False"], ["proof (state)\nthis:\n  \\<not> \\<mu>1 s1' s1\n\ngoal (1 subgoal):\n 1. \\<not> \\<mu>1 s1' s1 \\<Longrightarrow>\n    s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')", "with red bisim"], ["proof (chain)\npicking this:\n  (if \\<mu>1 s1' s1 then trsys2.silent_moves else trsys2.silent_movet) s2\n   s2'\n  s1' \\<approx> s2'\n  \\<not> \\<mu>1 s1' s1", "show ?thesis"], ["proof (prove)\nusing this:\n  (if \\<mu>1 s1' s1 then trsys2.silent_moves else trsys2.silent_movet) s2\n   s2'\n  s1' \\<approx> s2'\n  \\<not> \\<mu>1 s1' s1\n\ngoal (1 subgoal):\n 1. s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')", "by auto"], ["proof (state)\nthis:\n  s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n  (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n  (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma simulation_silent2I':\n  assumes \"\\<exists>s1'. (if \\<mu>2 s2' s2 then trsys1.silent_moves else trsys1.silent_movet) s1 s1' \\<and> s1' \\<approx> s2'\"\n  shows \"s1 \\<approx> s2' \\<and> \\<mu>2^++ s2' s2 \\<or> (\\<exists>s1'. s1 -\\<tau>1\\<rightarrow>+ s1' \\<and> s1' \\<approx> s2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s1 \\<approx> s2' \\<and> \\<mu>2\\<^sup>+\\<^sup>+ s2' s2 \\<or>\n    (\\<exists>s1'. s1 -\\<tau>1\\<rightarrow>+ s1' \\<and> s1' \\<approx> s2')", "using assms"], ["proof (prove)\nusing this:\n  \\<exists>s1'.\n     (if \\<mu>2 s2' s2 then trsys1.silent_moves else trsys1.silent_movet) s1\n      s1' \\<and>\n     s1' \\<approx> s2'\n\ngoal (1 subgoal):\n 1. s1 \\<approx> s2' \\<and> \\<mu>2\\<^sup>+\\<^sup>+ s2' s2 \\<or>\n    (\\<exists>s1'. s1 -\\<tau>1\\<rightarrow>+ s1' \\<and> s1' \\<approx> s2')", "by(rule delay_bisimulation_base.simulation_silent1I')"], ["", "end"], ["", "locale delay_bisimulation_obs = delay_bisimulation_base _ _ _ _ \\<tau>move1 \\<tau>move2\n  for \\<tau>move1 :: \"'s1 \\<Rightarrow> 'tl1 \\<Rightarrow> 's1 \\<Rightarrow> bool\"\n  and \\<tau>move2 :: \"'s2 \\<Rightarrow> 'tl2 \\<Rightarrow> 's2 \\<Rightarrow> bool\" +\n  assumes simulation1:\n  \"\\<lbrakk> s1 \\<approx> s2; s1 -1-tl1\\<rightarrow> s1'; \\<not> \\<tau>move1 s1 tl1 s1' \\<rbrakk>\n  \\<Longrightarrow> \\<exists>s2' s2'' tl2. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s2' -2-tl2\\<rightarrow> s2'' \\<and> \\<not> \\<tau>move2 s2' tl2 s2'' \\<and> s1' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\"\n  and simulation2:\n  \"\\<lbrakk> s1 \\<approx> s2; s2 -2-tl2\\<rightarrow> s2'; \\<not> \\<tau>move2 s2 tl2 s2' \\<rbrakk>\n  \\<Longrightarrow> \\<exists>s1' s1'' tl1. s1 -\\<tau>1\\<rightarrow>* s1' \\<and> s1' -1-tl1\\<rightarrow> s1'' \\<and> \\<not> \\<tau>move1 s1' tl1 s1'' \\<and> s1'' \\<approx> s2' \\<and> tl1 \\<sim> tl2\"\nbegin"], ["", "lemma delay_bisimulation_obs_flip: \"delay_bisimulation_obs trsys2 trsys1 (flip bisim) (flip tlsim) \\<tau>move2 \\<tau>move1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_obs trsys2 trsys1 (flip bisim) (flip tlsim)\n     \\<tau>move2 \\<tau>move1", "apply(unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>flip bisim s1 s2; s1 -2-tl1\\<rightarrow> s1';\n        \\<not> \\<tau>move2 s1 tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            s2 -\\<tau>1\\<rightarrow>* s2' \\<and>\n                            s2' -1-tl2\\<rightarrow> s2'' \\<and>\n                            \\<not> \\<tau>move1 s2' tl2 s2'' \\<and>\n                            flip bisim s1' s2'' \\<and> flip tlsim tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>flip bisim s1 s2; s2 -1-tl2\\<rightarrow> s2';\n        \\<not> \\<tau>move1 s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            s1 -\\<tau>2\\<rightarrow>* s1' \\<and>\n                            s1' -2-tl1\\<rightarrow> s1'' \\<and>\n                            \\<not> \\<tau>move2 s1' tl1 s1'' \\<and>\n                            flip bisim s1'' s2' \\<and> flip tlsim tl1 tl2", "apply(unfold flip_simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>s2 \\<approx> s1; s1 -2-tl1\\<rightarrow> s1';\n        \\<not> \\<tau>move2 s1 tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            s2 -\\<tau>1\\<rightarrow>* s2' \\<and>\n                            s2' -1-tl2\\<rightarrow> s2'' \\<and>\n                            \\<not> \\<tau>move1 s2' tl2 s2'' \\<and>\n                            s2'' \\<approx> s1' \\<and> tl2 \\<sim> tl1\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>s2 \\<approx> s1; s2 -1-tl2\\<rightarrow> s2';\n        \\<not> \\<tau>move1 s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            s1 -\\<tau>2\\<rightarrow>* s1' \\<and>\n                            s1' -2-tl1\\<rightarrow> s1'' \\<and>\n                            \\<not> \\<tau>move2 s1' tl1 s1'' \\<and>\n                            s2' \\<approx> s1'' \\<and> tl2 \\<sim> tl1", "by(blast intro: simulation1 simulation2)+"], ["", "end"], ["", "lemma delay_bisimulation_obs_flip_simps [flip_simps]:\n  \"delay_bisimulation_obs trsys2 trsys1 (flip bisim) (flip tlsim) \\<tau>move2 \\<tau>move1 =\n   delay_bisimulation_obs trsys1 trsys2 bisim tlsim \\<tau>move1 \\<tau>move2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_obs trsys2 trsys1 (flip bisim) (flip tlsim)\n     \\<tau>move2 \\<tau>move1 =\n    delay_bisimulation_obs trsys1 trsys2 bisim tlsim \\<tau>move1 \\<tau>move2", "by(auto dest: delay_bisimulation_obs.delay_bisimulation_obs_flip simp only: flip_flip)"], ["", "locale delay_bisimulation_diverge = delay_bisimulation_obs _ _ _ _ \\<tau>move1 \\<tau>move2\n  for \\<tau>move1 :: \"'s1 \\<Rightarrow> 'tl1 \\<Rightarrow> 's1 \\<Rightarrow> bool\"\n  and \\<tau>move2 :: \"'s2 \\<Rightarrow> 'tl2 \\<Rightarrow> 's2 \\<Rightarrow> bool\" +\n  assumes simulation_silent1:\n  \"\\<lbrakk> s1 \\<approx> s2; s1 -\\<tau>1\\<rightarrow> s1' \\<rbrakk> \\<Longrightarrow> \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2'\"\n  and simulation_silent2:\n  \"\\<lbrakk> s1 \\<approx> s2; s2 -\\<tau>2\\<rightarrow> s2' \\<rbrakk> \\<Longrightarrow> \\<exists>s1'. s1 -\\<tau>1\\<rightarrow>* s1' \\<and> s1' \\<approx> s2'\"\n  and \\<tau>diverge_bisim_inv: \"s1 \\<approx> s2 \\<Longrightarrow> s1 -\\<tau>1\\<rightarrow> \\<infinity> \\<longleftrightarrow> s2 -\\<tau>2\\<rightarrow> \\<infinity>\"\nbegin"], ["", "lemma delay_bisimulation_diverge_flip: \"delay_bisimulation_diverge trsys2 trsys1 (flip bisim) (flip tlsim) \\<tau>move2 \\<tau>move1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge trsys2 trsys1 (flip bisim) (flip tlsim)\n     \\<tau>move2 \\<tau>move1", "apply(rule delay_bisimulation_diverge.intro)"], ["proof (prove)\ngoal (2 subgoals):\n 1. delay_bisimulation_obs trsys2 trsys1 (flip bisim) (flip tlsim)\n     \\<tau>move2 \\<tau>move1\n 2. delay_bisimulation_diverge_axioms trsys2 trsys1 (flip bisim) \\<tau>move2\n     \\<tau>move1", "apply(rule delay_bisimulation_obs_flip)"], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge_axioms trsys2 trsys1 (flip bisim) \\<tau>move2\n     \\<tau>move1", "apply(unfold_locales)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s1 s2 s1'.\n       \\<lbrakk>flip bisim s1 s2; s1 -\\<tau>2\\<rightarrow> s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            s2 -\\<tau>1\\<rightarrow>* s2' \\<and>\n                            flip bisim s1' s2'\n 2. \\<And>s1 s2 s2'.\n       \\<lbrakk>flip bisim s1 s2; s2 -\\<tau>1\\<rightarrow> s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>2\\<rightarrow>* s1' \\<and>\n                            flip bisim s1' s2'\n 3. \\<And>s1 s2.\n       flip bisim s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>2\\<rightarrow> \\<infinity> =\n       s2 -\\<tau>1\\<rightarrow> \\<infinity>", "apply(unfold flip_simps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s1 s2 s1'.\n       \\<lbrakk>s2 \\<approx> s1; s1 -\\<tau>2\\<rightarrow> s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            s2 -\\<tau>1\\<rightarrow>* s2' \\<and> s2'\n                            \\<approx> s1'\n 2. \\<And>s1 s2 s2'.\n       \\<lbrakk>s2 \\<approx> s1; s2 -\\<tau>1\\<rightarrow> s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>2\\<rightarrow>* s1' \\<and> s2'\n                            \\<approx> s1'\n 3. \\<And>s1 s2.\n       s2 \\<approx> s1 \\<Longrightarrow>\n       s1 -\\<tau>2\\<rightarrow> \\<infinity> =\n       s2 -\\<tau>1\\<rightarrow> \\<infinity>", "by(blast intro: simulation_silent1 simulation_silent2 \\<tau>diverge_bisim_inv[symmetric] del: iffI)+"], ["", "end"], ["", "lemma delay_bisimulation_diverge_flip_simps [flip_simps]:\n  \"delay_bisimulation_diverge trsys2 trsys1 (flip bisim) (flip tlsim) \\<tau>move2 \\<tau>move1 =\n   delay_bisimulation_diverge trsys1 trsys2 bisim tlsim \\<tau>move1 \\<tau>move2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge trsys2 trsys1 (flip bisim) (flip tlsim)\n     \\<tau>move2 \\<tau>move1 =\n    delay_bisimulation_diverge trsys1 trsys2 bisim tlsim \\<tau>move1\n     \\<tau>move2", "by(auto dest: delay_bisimulation_diverge.delay_bisimulation_diverge_flip simp only: flip_flip)"], ["", "context delay_bisimulation_diverge begin"], ["", "lemma simulation_silents1:\n  assumes bisim: \"s1 \\<approx> s2\" and moves: \"s1 -\\<tau>1\\<rightarrow>* s1'\"\n  shows \"\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2'", "using moves bisim"], ["proof (prove)\nusing this:\n  s1 -\\<tau>1\\<rightarrow>* s1'\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2'", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. s1 \\<approx> s2 \\<Longrightarrow>\n    \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1 \\<approx> s2'\n 2. \\<And>y z.\n       \\<lbrakk>s1 -\\<tau>1\\<rightarrow>* y; y -\\<tau>1\\<rightarrow> z;\n        s1 \\<approx> s2 \\<Longrightarrow>\n        \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> y \\<approx> s2';\n        s1 \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            s2 -\\<tau>2\\<rightarrow>* s2' \\<and> z\n                            \\<approx> s2'", "case base"], ["proof (state)\nthis:\n  s1 \\<approx> s2\n\ngoal (2 subgoals):\n 1. s1 \\<approx> s2 \\<Longrightarrow>\n    \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1 \\<approx> s2'\n 2. \\<And>y z.\n       \\<lbrakk>s1 -\\<tau>1\\<rightarrow>* y; y -\\<tau>1\\<rightarrow> z;\n        s1 \\<approx> s2 \\<Longrightarrow>\n        \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> y \\<approx> s2';\n        s1 \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            s2 -\\<tau>2\\<rightarrow>* s2' \\<and> z\n                            \\<approx> s2'", "thus ?case"], ["proof (prove)\nusing this:\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1 \\<approx> s2'", "by(blast)"], ["proof (state)\nthis:\n  \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1 \\<approx> s2'\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>s1 -\\<tau>1\\<rightarrow>* y; y -\\<tau>1\\<rightarrow> z;\n        s1 \\<approx> s2 \\<Longrightarrow>\n        \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> y \\<approx> s2';\n        s1 \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            s2 -\\<tau>2\\<rightarrow>* s2' \\<and> z\n                            \\<approx> s2'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>s1 -\\<tau>1\\<rightarrow>* y; y -\\<tau>1\\<rightarrow> z;\n        s1 \\<approx> s2 \\<Longrightarrow>\n        \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> y \\<approx> s2';\n        s1 \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            s2 -\\<tau>2\\<rightarrow>* s2' \\<and> z\n                            \\<approx> s2'", "case (step s1' s1'')"], ["proof (state)\nthis:\n  s1 -\\<tau>1\\<rightarrow>* s1'\n  s1' -\\<tau>1\\<rightarrow> s1''\n  s1 \\<approx> s2 \\<Longrightarrow>\n  \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2'\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>s1 -\\<tau>1\\<rightarrow>* y; y -\\<tau>1\\<rightarrow> z;\n        s1 \\<approx> s2 \\<Longrightarrow>\n        \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> y \\<approx> s2';\n        s1 \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            s2 -\\<tau>2\\<rightarrow>* s2' \\<and> z\n                            \\<approx> s2'", "from \\<open>s1 \\<approx> s2 \\<Longrightarrow> \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2'\\<close> \\<open>s1 \\<approx> s2\\<close>"], ["proof (chain)\npicking this:\n  s1 \\<approx> s2 \\<Longrightarrow>\n  \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2'\n  s1 \\<approx> s2", "obtain s2' where \"s2 -\\<tau>2\\<rightarrow>* s2'\" \"s1' \\<approx> s2'\""], ["proof (prove)\nusing this:\n  s1 \\<approx> s2 \\<Longrightarrow>\n  \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2'\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. (\\<And>s2'.\n        \\<lbrakk>s2 -\\<tau>2\\<rightarrow>* s2'; s1' \\<approx> s2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  s1' \\<approx> s2'\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>s1 -\\<tau>1\\<rightarrow>* y; y -\\<tau>1\\<rightarrow> z;\n        s1 \\<approx> s2 \\<Longrightarrow>\n        \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> y \\<approx> s2';\n        s1 \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            s2 -\\<tau>2\\<rightarrow>* s2' \\<and> z\n                            \\<approx> s2'", "from simulation_silent1[OF \\<open>s1' \\<approx> s2'\\<close> \\<open>s1' -\\<tau>1\\<rightarrow> s1''\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>s2'a. s2' -\\<tau>2\\<rightarrow>* s2'a \\<and> s1'' \\<approx> s2'a", "obtain s2'' where \"s2' -\\<tau>2\\<rightarrow>* s2''\" \"s1'' \\<approx> s2''\""], ["proof (prove)\nusing this:\n  \\<exists>s2'a. s2' -\\<tau>2\\<rightarrow>* s2'a \\<and> s1'' \\<approx> s2'a\n\ngoal (1 subgoal):\n 1. (\\<And>s2''.\n        \\<lbrakk>s2' -\\<tau>2\\<rightarrow>* s2'';\n         s1'' \\<approx> s2''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s2' -\\<tau>2\\<rightarrow>* s2''\n  s1'' \\<approx> s2''\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>s1 -\\<tau>1\\<rightarrow>* y; y -\\<tau>1\\<rightarrow> z;\n        s1 \\<approx> s2 \\<Longrightarrow>\n        \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> y \\<approx> s2';\n        s1 \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            s2 -\\<tau>2\\<rightarrow>* s2' \\<and> z\n                            \\<approx> s2'", "from \\<open>s2 -\\<tau>2\\<rightarrow>* s2'\\<close> \\<open>s2' -\\<tau>2\\<rightarrow>* s2''\\<close>"], ["proof (chain)\npicking this:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  s2' -\\<tau>2\\<rightarrow>* s2''", "have \"s2 -\\<tau>2\\<rightarrow>* s2''\""], ["proof (prove)\nusing this:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  s2' -\\<tau>2\\<rightarrow>* s2''\n\ngoal (1 subgoal):\n 1. s2 -\\<tau>2\\<rightarrow>* s2''", "by(rule rtranclp_trans)"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow>* s2''\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>s1 -\\<tau>1\\<rightarrow>* y; y -\\<tau>1\\<rightarrow> z;\n        s1 \\<approx> s2 \\<Longrightarrow>\n        \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> y \\<approx> s2';\n        s1 \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            s2 -\\<tau>2\\<rightarrow>* s2' \\<and> z\n                            \\<approx> s2'", "with \\<open>s1'' \\<approx> s2''\\<close>"], ["proof (chain)\npicking this:\n  s1'' \\<approx> s2''\n  s2 -\\<tau>2\\<rightarrow>* s2''", "show ?case"], ["proof (prove)\nusing this:\n  s1'' \\<approx> s2''\n  s2 -\\<tau>2\\<rightarrow>* s2''\n\ngoal (1 subgoal):\n 1. \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1'' \\<approx> s2'", "by blast"], ["proof (state)\nthis:\n  \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1'' \\<approx> s2'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma simulation_silents2:\n  \"\\<lbrakk> s1 \\<approx> s2; s2 -\\<tau>2\\<rightarrow>* s2' \\<rbrakk> \\<Longrightarrow> \\<exists>s1'. s1 -\\<tau>1\\<rightarrow>* s1' \\<and> s1' \\<approx> s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx> s2; s2 -\\<tau>2\\<rightarrow>* s2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s1'.\n                         s1 -\\<tau>1\\<rightarrow>* s1' \\<and> s1'\n                         \\<approx> s2'", "using delay_bisimulation_diverge.simulation_silents1[OF delay_bisimulation_diverge_flip]"], ["proof (prove)\nusing this:\n  \\<lbrakk>flip bisim ?s1.0 ?s2.0;\n   ?s1.0 -\\<tau>2\\<rightarrow>* ?s1'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s2'.\n                       ?s2.0 -\\<tau>1\\<rightarrow>* s2' \\<and>\n                       flip bisim ?s1' s2'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx> s2; s2 -\\<tau>2\\<rightarrow>* s2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s1'.\n                         s1 -\\<tau>1\\<rightarrow>* s1' \\<and> s1'\n                         \\<approx> s2'", "unfolding flip_simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s2.0 \\<approx> ?s1.0; ?s1.0 -\\<tau>2\\<rightarrow>* ?s1'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s2'.\n                       ?s2.0 -\\<tau>1\\<rightarrow>* s2' \\<and> s2'\n                       \\<approx> ?s1'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx> s2; s2 -\\<tau>2\\<rightarrow>* s2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s1'.\n                         s1 -\\<tau>1\\<rightarrow>* s1' \\<and> s1'\n                         \\<approx> s2'", "."], ["", "lemma simulation1_\\<tau>rtrancl3p:\n  \"\\<lbrakk> s1 -\\<tau>1-tls1\\<rightarrow>* s1'; s1 \\<approx> s2 \\<rbrakk>\n  \\<Longrightarrow> \\<exists>tls2 s2'. s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2' \\<and> tls1 [\\<sim>] tls2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 -\\<tau>1-tls1\\<rightarrow>* s1'; s1 \\<approx> s2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tls2 s2'.\n                         s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n                         s1' \\<approx> s2' \\<and> tls1 [\\<sim>] tls2", "proof(induct arbitrary: s2 rule: trsys1.\\<tau>rtrancl3p.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s s2.\n       s \\<approx> s2 \\<Longrightarrow>\n       \\<exists>tls2 s2'.\n          s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n          s \\<approx> s2' \\<and> [] [\\<sim>] tls2\n 2. \\<And>s s' tls s'' tl s2.\n       \\<lbrakk>s -1-tl\\<rightarrow> s'; \\<not> \\<tau>move1 s tl s';\n        s' -\\<tau>1-tls\\<rightarrow>* s'';\n        \\<And>s2.\n           s' \\<approx> s2 \\<Longrightarrow>\n           \\<exists>tls2 s2'.\n              s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n              s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2;\n        s \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tls2 s2'.\n                            s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n                            s'' \\<approx> s2' \\<and> tl # tls [\\<sim>] tls2\n 3. \\<And>s s' tls s'' tl s2.\n       \\<lbrakk>s -1-tl\\<rightarrow> s'; \\<tau>move1 s tl s';\n        s' -\\<tau>1-tls\\<rightarrow>* s'';\n        \\<And>s2.\n           s' \\<approx> s2 \\<Longrightarrow>\n           \\<exists>tls2 s2'.\n              s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n              s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2;\n        s \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tls2 s2'.\n                            s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n                            s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2", "case (\\<tau>rtrancl3p_refl s)"], ["proof (state)\nthis:\n  s \\<approx> s2\n\ngoal (3 subgoals):\n 1. \\<And>s s2.\n       s \\<approx> s2 \\<Longrightarrow>\n       \\<exists>tls2 s2'.\n          s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n          s \\<approx> s2' \\<and> [] [\\<sim>] tls2\n 2. \\<And>s s' tls s'' tl s2.\n       \\<lbrakk>s -1-tl\\<rightarrow> s'; \\<not> \\<tau>move1 s tl s';\n        s' -\\<tau>1-tls\\<rightarrow>* s'';\n        \\<And>s2.\n           s' \\<approx> s2 \\<Longrightarrow>\n           \\<exists>tls2 s2'.\n              s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n              s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2;\n        s \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tls2 s2'.\n                            s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n                            s'' \\<approx> s2' \\<and> tl # tls [\\<sim>] tls2\n 3. \\<And>s s' tls s'' tl s2.\n       \\<lbrakk>s -1-tl\\<rightarrow> s'; \\<tau>move1 s tl s';\n        s' -\\<tau>1-tls\\<rightarrow>* s'';\n        \\<And>s2.\n           s' \\<approx> s2 \\<Longrightarrow>\n           \\<exists>tls2 s2'.\n              s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n              s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2;\n        s \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tls2 s2'.\n                            s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n                            s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2", "thus ?case"], ["proof (prove)\nusing this:\n  s \\<approx> s2\n\ngoal (1 subgoal):\n 1. \\<exists>tls2 s2'.\n       s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n       s \\<approx> s2' \\<and> [] [\\<sim>] tls2", "by(auto intro: \\<tau>trsys.\\<tau>rtrancl3p.intros)"], ["proof (state)\nthis:\n  \\<exists>tls2 s2'.\n     s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n     s \\<approx> s2' \\<and> [] [\\<sim>] tls2\n\ngoal (2 subgoals):\n 1. \\<And>s s' tls s'' tl s2.\n       \\<lbrakk>s -1-tl\\<rightarrow> s'; \\<not> \\<tau>move1 s tl s';\n        s' -\\<tau>1-tls\\<rightarrow>* s'';\n        \\<And>s2.\n           s' \\<approx> s2 \\<Longrightarrow>\n           \\<exists>tls2 s2'.\n              s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n              s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2;\n        s \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tls2 s2'.\n                            s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n                            s'' \\<approx> s2' \\<and> tl # tls [\\<sim>] tls2\n 2. \\<And>s s' tls s'' tl s2.\n       \\<lbrakk>s -1-tl\\<rightarrow> s'; \\<tau>move1 s tl s';\n        s' -\\<tau>1-tls\\<rightarrow>* s'';\n        \\<And>s2.\n           s' \\<approx> s2 \\<Longrightarrow>\n           \\<exists>tls2 s2'.\n              s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n              s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2;\n        s \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tls2 s2'.\n                            s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n                            s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s s' tls s'' tl s2.\n       \\<lbrakk>s -1-tl\\<rightarrow> s'; \\<not> \\<tau>move1 s tl s';\n        s' -\\<tau>1-tls\\<rightarrow>* s'';\n        \\<And>s2.\n           s' \\<approx> s2 \\<Longrightarrow>\n           \\<exists>tls2 s2'.\n              s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n              s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2;\n        s \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tls2 s2'.\n                            s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n                            s'' \\<approx> s2' \\<and> tl # tls [\\<sim>] tls2\n 2. \\<And>s s' tls s'' tl s2.\n       \\<lbrakk>s -1-tl\\<rightarrow> s'; \\<tau>move1 s tl s';\n        s' -\\<tau>1-tls\\<rightarrow>* s'';\n        \\<And>s2.\n           s' \\<approx> s2 \\<Longrightarrow>\n           \\<exists>tls2 s2'.\n              s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n              s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2;\n        s \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tls2 s2'.\n                            s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n                            s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2", "case (\\<tau>rtrancl3p_step s1 s1' tls1 s1'' tl1)"], ["proof (state)\nthis:\n  s1 -1-tl1\\<rightarrow> s1'\n  \\<not> \\<tau>move1 s1 tl1 s1'\n  s1' -\\<tau>1-tls1\\<rightarrow>* s1''\n  s1' \\<approx> ?s2.0 \\<Longrightarrow>\n  \\<exists>tls2 s2'.\n     ?s2.0 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n     s1'' \\<approx> s2' \\<and> tls1 [\\<sim>] tls2\n  s1 \\<approx> s2\n\ngoal (2 subgoals):\n 1. \\<And>s s' tls s'' tl s2.\n       \\<lbrakk>s -1-tl\\<rightarrow> s'; \\<not> \\<tau>move1 s tl s';\n        s' -\\<tau>1-tls\\<rightarrow>* s'';\n        \\<And>s2.\n           s' \\<approx> s2 \\<Longrightarrow>\n           \\<exists>tls2 s2'.\n              s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n              s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2;\n        s \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tls2 s2'.\n                            s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n                            s'' \\<approx> s2' \\<and> tl # tls [\\<sim>] tls2\n 2. \\<And>s s' tls s'' tl s2.\n       \\<lbrakk>s -1-tl\\<rightarrow> s'; \\<tau>move1 s tl s';\n        s' -\\<tau>1-tls\\<rightarrow>* s'';\n        \\<And>s2.\n           s' \\<approx> s2 \\<Longrightarrow>\n           \\<exists>tls2 s2'.\n              s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n              s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2;\n        s \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tls2 s2'.\n                            s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n                            s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2", "from simulation1[OF \\<open>s1 \\<approx> s2\\<close> \\<open>s1 -1-tl1\\<rightarrow> s1'\\<close> \\<open>\\<not> \\<tau>move1 s1 tl1 s1'\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>s2' s2'' tl2.\n     s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n     s2' -2-tl2\\<rightarrow> s2'' \\<and>\n     \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n     s1' \\<approx> s2'' \\<and> tl1 \\<sim> tl2", "obtain s2' s2'' tl2 where \\<tau>red: \"s2 -\\<tau>2\\<rightarrow>* s2'\"\n    and red: \"s2' -2-tl2\\<rightarrow> s2''\" and n\\<tau>: \"\\<not> \\<tau>move2 s2' tl2 s2''\"\n    and bisim': \"s1' \\<approx> s2''\" and tlsim: \"tl1 \\<sim> tl2\""], ["proof (prove)\nusing this:\n  \\<exists>s2' s2'' tl2.\n     s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n     s2' -2-tl2\\<rightarrow> s2'' \\<and>\n     \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n     s1' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. (\\<And>s2' tl2 s2''.\n        \\<lbrakk>s2 -\\<tau>2\\<rightarrow>* s2';\n         s2' -2-tl2\\<rightarrow> s2''; \\<not> \\<tau>move2 s2' tl2 s2'';\n         s1' \\<approx> s2''; tl1 \\<sim> tl2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  s2' -2-tl2\\<rightarrow> s2''\n  \\<not> \\<tau>move2 s2' tl2 s2''\n  s1' \\<approx> s2''\n  tl1 \\<sim> tl2\n\ngoal (2 subgoals):\n 1. \\<And>s s' tls s'' tl s2.\n       \\<lbrakk>s -1-tl\\<rightarrow> s'; \\<not> \\<tau>move1 s tl s';\n        s' -\\<tau>1-tls\\<rightarrow>* s'';\n        \\<And>s2.\n           s' \\<approx> s2 \\<Longrightarrow>\n           \\<exists>tls2 s2'.\n              s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n              s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2;\n        s \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tls2 s2'.\n                            s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n                            s'' \\<approx> s2' \\<and> tl # tls [\\<sim>] tls2\n 2. \\<And>s s' tls s'' tl s2.\n       \\<lbrakk>s -1-tl\\<rightarrow> s'; \\<tau>move1 s tl s';\n        s' -\\<tau>1-tls\\<rightarrow>* s'';\n        \\<And>s2.\n           s' \\<approx> s2 \\<Longrightarrow>\n           \\<exists>tls2 s2'.\n              s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n              s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2;\n        s \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tls2 s2'.\n                            s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n                            s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2", "from bisim' \\<open>s1' \\<approx> s2'' \\<Longrightarrow> \\<exists>tls2 s2'. s2'' -\\<tau>2-tls2\\<rightarrow>* s2' \\<and> s1'' \\<approx> s2' \\<and> tls1 [\\<sim>] tls2\\<close>"], ["proof (chain)\npicking this:\n  s1' \\<approx> s2''\n  s1' \\<approx> s2'' \\<Longrightarrow>\n  \\<exists>tls2 s2'.\n     s2'' -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n     s1'' \\<approx> s2' \\<and> tls1 [\\<sim>] tls2", "obtain tls2 s2''' where IH: \"s2'' -\\<tau>2-tls2\\<rightarrow>* s2'''\" \"s1'' \\<approx> s2'''\" \"tls1 [\\<sim>] tls2\""], ["proof (prove)\nusing this:\n  s1' \\<approx> s2''\n  s1' \\<approx> s2'' \\<Longrightarrow>\n  \\<exists>tls2 s2'.\n     s2'' -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n     s1'' \\<approx> s2' \\<and> tls1 [\\<sim>] tls2\n\ngoal (1 subgoal):\n 1. (\\<And>tls2 s2'''.\n        \\<lbrakk>s2'' -\\<tau>2-tls2\\<rightarrow>* s2''';\n         s1'' \\<approx> s2'''; tls1 [\\<sim>] tls2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s2'' -\\<tau>2-tls2\\<rightarrow>* s2'''\n  s1'' \\<approx> s2'''\n  tls1 [\\<sim>] tls2\n\ngoal (2 subgoals):\n 1. \\<And>s s' tls s'' tl s2.\n       \\<lbrakk>s -1-tl\\<rightarrow> s'; \\<not> \\<tau>move1 s tl s';\n        s' -\\<tau>1-tls\\<rightarrow>* s'';\n        \\<And>s2.\n           s' \\<approx> s2 \\<Longrightarrow>\n           \\<exists>tls2 s2'.\n              s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n              s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2;\n        s \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tls2 s2'.\n                            s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n                            s'' \\<approx> s2' \\<and> tl # tls [\\<sim>] tls2\n 2. \\<And>s s' tls s'' tl s2.\n       \\<lbrakk>s -1-tl\\<rightarrow> s'; \\<tau>move1 s tl s';\n        s' -\\<tau>1-tls\\<rightarrow>* s'';\n        \\<And>s2.\n           s' \\<approx> s2 \\<Longrightarrow>\n           \\<exists>tls2 s2'.\n              s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n              s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2;\n        s \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tls2 s2'.\n                            s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n                            s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2", "from \\<tau>red"], ["proof (chain)\npicking this:\n  s2 -\\<tau>2\\<rightarrow>* s2'", "have \"s2 -\\<tau>2-[]\\<rightarrow>* s2'\""], ["proof (prove)\nusing this:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n\ngoal (1 subgoal):\n 1. s2 -\\<tau>2-[]\\<rightarrow>* s2'", "by(rule trsys2.silent_moves_into_\\<tau>rtrancl3p)"], ["proof (state)\nthis:\n  s2 -\\<tau>2-[]\\<rightarrow>* s2'\n\ngoal (2 subgoals):\n 1. \\<And>s s' tls s'' tl s2.\n       \\<lbrakk>s -1-tl\\<rightarrow> s'; \\<not> \\<tau>move1 s tl s';\n        s' -\\<tau>1-tls\\<rightarrow>* s'';\n        \\<And>s2.\n           s' \\<approx> s2 \\<Longrightarrow>\n           \\<exists>tls2 s2'.\n              s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n              s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2;\n        s \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tls2 s2'.\n                            s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n                            s'' \\<approx> s2' \\<and> tl # tls [\\<sim>] tls2\n 2. \\<And>s s' tls s'' tl s2.\n       \\<lbrakk>s -1-tl\\<rightarrow> s'; \\<tau>move1 s tl s';\n        s' -\\<tau>1-tls\\<rightarrow>* s'';\n        \\<And>s2.\n           s' \\<approx> s2 \\<Longrightarrow>\n           \\<exists>tls2 s2'.\n              s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n              s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2;\n        s \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tls2 s2'.\n                            s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n                            s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2", "also"], ["proof (state)\nthis:\n  s2 -\\<tau>2-[]\\<rightarrow>* s2'\n\ngoal (2 subgoals):\n 1. \\<And>s s' tls s'' tl s2.\n       \\<lbrakk>s -1-tl\\<rightarrow> s'; \\<not> \\<tau>move1 s tl s';\n        s' -\\<tau>1-tls\\<rightarrow>* s'';\n        \\<And>s2.\n           s' \\<approx> s2 \\<Longrightarrow>\n           \\<exists>tls2 s2'.\n              s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n              s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2;\n        s \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tls2 s2'.\n                            s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n                            s'' \\<approx> s2' \\<and> tl # tls [\\<sim>] tls2\n 2. \\<And>s s' tls s'' tl s2.\n       \\<lbrakk>s -1-tl\\<rightarrow> s'; \\<tau>move1 s tl s';\n        s' -\\<tau>1-tls\\<rightarrow>* s'';\n        \\<And>s2.\n           s' \\<approx> s2 \\<Longrightarrow>\n           \\<exists>tls2 s2'.\n              s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n              s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2;\n        s \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tls2 s2'.\n                            s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n                            s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2", "from red n\\<tau> IH(1)"], ["proof (chain)\npicking this:\n  s2' -2-tl2\\<rightarrow> s2''\n  \\<not> \\<tau>move2 s2' tl2 s2''\n  s2'' -\\<tau>2-tls2\\<rightarrow>* s2'''", "have \"s2' -\\<tau>2-tl2 # tls2\\<rightarrow>* s2'''\""], ["proof (prove)\nusing this:\n  s2' -2-tl2\\<rightarrow> s2''\n  \\<not> \\<tau>move2 s2' tl2 s2''\n  s2'' -\\<tau>2-tls2\\<rightarrow>* s2'''\n\ngoal (1 subgoal):\n 1. s2' -\\<tau>2-tl2 # tls2\\<rightarrow>* s2'''", "by(rule \\<tau>rtrancl3p.\\<tau>rtrancl3p_step)"], ["proof (state)\nthis:\n  s2' -\\<tau>2-tl2 # tls2\\<rightarrow>* s2'''\n\ngoal (2 subgoals):\n 1. \\<And>s s' tls s'' tl s2.\n       \\<lbrakk>s -1-tl\\<rightarrow> s'; \\<not> \\<tau>move1 s tl s';\n        s' -\\<tau>1-tls\\<rightarrow>* s'';\n        \\<And>s2.\n           s' \\<approx> s2 \\<Longrightarrow>\n           \\<exists>tls2 s2'.\n              s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n              s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2;\n        s \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tls2 s2'.\n                            s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n                            s'' \\<approx> s2' \\<and> tl # tls [\\<sim>] tls2\n 2. \\<And>s s' tls s'' tl s2.\n       \\<lbrakk>s -1-tl\\<rightarrow> s'; \\<tau>move1 s tl s';\n        s' -\\<tau>1-tls\\<rightarrow>* s'';\n        \\<And>s2.\n           s' \\<approx> s2 \\<Longrightarrow>\n           \\<exists>tls2 s2'.\n              s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n              s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2;\n        s \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tls2 s2'.\n                            s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n                            s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2", "finally"], ["proof (chain)\npicking this:\n  s2 -\\<tau>2-[] @ tl2 # tls2\\<rightarrow>* s2'''", "show ?case"], ["proof (prove)\nusing this:\n  s2 -\\<tau>2-[] @ tl2 # tls2\\<rightarrow>* s2'''\n\ngoal (1 subgoal):\n 1. \\<exists>tls2 s2'.\n       s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n       s1'' \\<approx> s2' \\<and> tl1 # tls1 [\\<sim>] tls2", "using IH tlsim"], ["proof (prove)\nusing this:\n  s2 -\\<tau>2-[] @ tl2 # tls2\\<rightarrow>* s2'''\n  s2'' -\\<tau>2-tls2\\<rightarrow>* s2'''\n  s1'' \\<approx> s2'''\n  tls1 [\\<sim>] tls2\n  tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. \\<exists>tls2 s2'.\n       s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n       s1'' \\<approx> s2' \\<and> tl1 # tls1 [\\<sim>] tls2", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tls2 s2'.\n     s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n     s1'' \\<approx> s2' \\<and> tl1 # tls1 [\\<sim>] tls2\n\ngoal (1 subgoal):\n 1. \\<And>s s' tls s'' tl s2.\n       \\<lbrakk>s -1-tl\\<rightarrow> s'; \\<tau>move1 s tl s';\n        s' -\\<tau>1-tls\\<rightarrow>* s'';\n        \\<And>s2.\n           s' \\<approx> s2 \\<Longrightarrow>\n           \\<exists>tls2 s2'.\n              s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n              s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2;\n        s \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tls2 s2'.\n                            s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n                            s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s s' tls s'' tl s2.\n       \\<lbrakk>s -1-tl\\<rightarrow> s'; \\<tau>move1 s tl s';\n        s' -\\<tau>1-tls\\<rightarrow>* s'';\n        \\<And>s2.\n           s' \\<approx> s2 \\<Longrightarrow>\n           \\<exists>tls2 s2'.\n              s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n              s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2;\n        s \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tls2 s2'.\n                            s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n                            s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2", "case (\\<tau>rtrancl3p_\\<tau>step s1 s1' tls1 s1'' tl1)"], ["proof (state)\nthis:\n  s1 -1-tl1\\<rightarrow> s1'\n  \\<tau>move1 s1 tl1 s1'\n  s1' -\\<tau>1-tls1\\<rightarrow>* s1''\n  s1' \\<approx> ?s2.0 \\<Longrightarrow>\n  \\<exists>tls2 s2'.\n     ?s2.0 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n     s1'' \\<approx> s2' \\<and> tls1 [\\<sim>] tls2\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. \\<And>s s' tls s'' tl s2.\n       \\<lbrakk>s -1-tl\\<rightarrow> s'; \\<tau>move1 s tl s';\n        s' -\\<tau>1-tls\\<rightarrow>* s'';\n        \\<And>s2.\n           s' \\<approx> s2 \\<Longrightarrow>\n           \\<exists>tls2 s2'.\n              s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n              s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2;\n        s \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tls2 s2'.\n                            s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n                            s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2", "from \\<open>s1 -1-tl1\\<rightarrow> s1'\\<close> \\<open>\\<tau>move1 s1 tl1 s1'\\<close>"], ["proof (chain)\npicking this:\n  s1 -1-tl1\\<rightarrow> s1'\n  \\<tau>move1 s1 tl1 s1'", "have \"s1 -\\<tau>1\\<rightarrow> s1'\""], ["proof (prove)\nusing this:\n  s1 -1-tl1\\<rightarrow> s1'\n  \\<tau>move1 s1 tl1 s1'\n\ngoal (1 subgoal):\n 1. s1 -\\<tau>1\\<rightarrow> s1'", ".."], ["proof (state)\nthis:\n  s1 -\\<tau>1\\<rightarrow> s1'\n\ngoal (1 subgoal):\n 1. \\<And>s s' tls s'' tl s2.\n       \\<lbrakk>s -1-tl\\<rightarrow> s'; \\<tau>move1 s tl s';\n        s' -\\<tau>1-tls\\<rightarrow>* s'';\n        \\<And>s2.\n           s' \\<approx> s2 \\<Longrightarrow>\n           \\<exists>tls2 s2'.\n              s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n              s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2;\n        s \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tls2 s2'.\n                            s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n                            s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2", "from simulation_silent1[OF \\<open>s1 \\<approx> s2\\<close> this]"], ["proof (chain)\npicking this:\n  \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2'", "obtain s2' where \\<tau>red: \"s2 -\\<tau>2\\<rightarrow>* s2'\" and bisim': \"s1' \\<approx> s2'\""], ["proof (prove)\nusing this:\n  \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2'\n\ngoal (1 subgoal):\n 1. (\\<And>s2'.\n        \\<lbrakk>s2 -\\<tau>2\\<rightarrow>* s2'; s1' \\<approx> s2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  s1' \\<approx> s2'\n\ngoal (1 subgoal):\n 1. \\<And>s s' tls s'' tl s2.\n       \\<lbrakk>s -1-tl\\<rightarrow> s'; \\<tau>move1 s tl s';\n        s' -\\<tau>1-tls\\<rightarrow>* s'';\n        \\<And>s2.\n           s' \\<approx> s2 \\<Longrightarrow>\n           \\<exists>tls2 s2'.\n              s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n              s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2;\n        s \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tls2 s2'.\n                            s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n                            s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2", "from \\<tau>red"], ["proof (chain)\npicking this:\n  s2 -\\<tau>2\\<rightarrow>* s2'", "have \"s2 -\\<tau>2-[]\\<rightarrow>* s2'\""], ["proof (prove)\nusing this:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n\ngoal (1 subgoal):\n 1. s2 -\\<tau>2-[]\\<rightarrow>* s2'", "by(rule trsys2.silent_moves_into_\\<tau>rtrancl3p)"], ["proof (state)\nthis:\n  s2 -\\<tau>2-[]\\<rightarrow>* s2'\n\ngoal (1 subgoal):\n 1. \\<And>s s' tls s'' tl s2.\n       \\<lbrakk>s -1-tl\\<rightarrow> s'; \\<tau>move1 s tl s';\n        s' -\\<tau>1-tls\\<rightarrow>* s'';\n        \\<And>s2.\n           s' \\<approx> s2 \\<Longrightarrow>\n           \\<exists>tls2 s2'.\n              s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n              s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2;\n        s \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tls2 s2'.\n                            s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n                            s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2", "also"], ["proof (state)\nthis:\n  s2 -\\<tau>2-[]\\<rightarrow>* s2'\n\ngoal (1 subgoal):\n 1. \\<And>s s' tls s'' tl s2.\n       \\<lbrakk>s -1-tl\\<rightarrow> s'; \\<tau>move1 s tl s';\n        s' -\\<tau>1-tls\\<rightarrow>* s'';\n        \\<And>s2.\n           s' \\<approx> s2 \\<Longrightarrow>\n           \\<exists>tls2 s2'.\n              s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n              s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2;\n        s \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tls2 s2'.\n                            s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n                            s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2", "from bisim' \\<open>s1' \\<approx> s2' \\<Longrightarrow> \\<exists>tls2 s2''. s2' -\\<tau>2-tls2\\<rightarrow>* s2'' \\<and> s1'' \\<approx> s2'' \\<and> tls1 [\\<sim>] tls2\\<close>"], ["proof (chain)\npicking this:\n  s1' \\<approx> s2'\n  s1' \\<approx> s2' \\<Longrightarrow>\n  \\<exists>tls2 s2''.\n     s2' -\\<tau>2-tls2\\<rightarrow>* s2'' \\<and>\n     s1'' \\<approx> s2'' \\<and> tls1 [\\<sim>] tls2", "obtain tls2 s2'' where IH: \"s2' -\\<tau>2-tls2\\<rightarrow>* s2''\" \"s1'' \\<approx> s2''\" \"tls1 [\\<sim>] tls2\""], ["proof (prove)\nusing this:\n  s1' \\<approx> s2'\n  s1' \\<approx> s2' \\<Longrightarrow>\n  \\<exists>tls2 s2''.\n     s2' -\\<tau>2-tls2\\<rightarrow>* s2'' \\<and>\n     s1'' \\<approx> s2'' \\<and> tls1 [\\<sim>] tls2\n\ngoal (1 subgoal):\n 1. (\\<And>tls2 s2''.\n        \\<lbrakk>s2' -\\<tau>2-tls2\\<rightarrow>* s2''; s1'' \\<approx> s2'';\n         tls1 [\\<sim>] tls2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s2' -\\<tau>2-tls2\\<rightarrow>* s2''\n  s1'' \\<approx> s2''\n  tls1 [\\<sim>] tls2\n\ngoal (1 subgoal):\n 1. \\<And>s s' tls s'' tl s2.\n       \\<lbrakk>s -1-tl\\<rightarrow> s'; \\<tau>move1 s tl s';\n        s' -\\<tau>1-tls\\<rightarrow>* s'';\n        \\<And>s2.\n           s' \\<approx> s2 \\<Longrightarrow>\n           \\<exists>tls2 s2'.\n              s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n              s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2;\n        s \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tls2 s2'.\n                            s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n                            s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2", "note \\<open>s2' -\\<tau>2-tls2\\<rightarrow>* s2''\\<close>"], ["proof (state)\nthis:\n  s2' -\\<tau>2-tls2\\<rightarrow>* s2''\n\ngoal (1 subgoal):\n 1. \\<And>s s' tls s'' tl s2.\n       \\<lbrakk>s -1-tl\\<rightarrow> s'; \\<tau>move1 s tl s';\n        s' -\\<tau>1-tls\\<rightarrow>* s'';\n        \\<And>s2.\n           s' \\<approx> s2 \\<Longrightarrow>\n           \\<exists>tls2 s2'.\n              s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n              s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2;\n        s \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tls2 s2'.\n                            s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n                            s'' \\<approx> s2' \\<and> tls [\\<sim>] tls2", "finally"], ["proof (chain)\npicking this:\n  s2 -\\<tau>2-[] @ tls2\\<rightarrow>* s2''", "show ?case"], ["proof (prove)\nusing this:\n  s2 -\\<tau>2-[] @ tls2\\<rightarrow>* s2''\n\ngoal (1 subgoal):\n 1. \\<exists>tls2 s2'.\n       s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n       s1'' \\<approx> s2' \\<and> tls1 [\\<sim>] tls2", "using IH"], ["proof (prove)\nusing this:\n  s2 -\\<tau>2-[] @ tls2\\<rightarrow>* s2''\n  s2' -\\<tau>2-tls2\\<rightarrow>* s2''\n  s1'' \\<approx> s2''\n  tls1 [\\<sim>] tls2\n\ngoal (1 subgoal):\n 1. \\<exists>tls2 s2'.\n       s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n       s1'' \\<approx> s2' \\<and> tls1 [\\<sim>] tls2", "by auto"], ["proof (state)\nthis:\n  \\<exists>tls2 s2'.\n     s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n     s1'' \\<approx> s2' \\<and> tls1 [\\<sim>] tls2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma simulation2_\\<tau>rtrancl3p:\n  \"\\<lbrakk> s2 -\\<tau>2-tls2\\<rightarrow>* s2'; s1 \\<approx> s2 \\<rbrakk>\n  \\<Longrightarrow> \\<exists>tls1 s1'. s1 -\\<tau>1-tls1\\<rightarrow>* s1' \\<and> s1' \\<approx> s2' \\<and> tls1 [\\<sim>] tls2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s2 -\\<tau>2-tls2\\<rightarrow>* s2'; s1 \\<approx> s2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tls1 s1'.\n                         s1 -\\<tau>1-tls1\\<rightarrow>* s1' \\<and>\n                         s1' \\<approx> s2' \\<and> tls1 [\\<sim>] tls2", "using delay_bisimulation_diverge.simulation1_\\<tau>rtrancl3p[OF delay_bisimulation_diverge_flip]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s1.0 -\\<tau>2-?tls1.0\\<rightarrow>* ?s1';\n   flip bisim ?s1.0 ?s2.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tls2 s2'.\n                       ?s2.0 -\\<tau>1-tls2\\<rightarrow>* s2' \\<and>\n                       flip bisim ?s1' s2' \\<and>\n                       list_all2 (flip tlsim) ?tls1.0 tls2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s2 -\\<tau>2-tls2\\<rightarrow>* s2'; s1 \\<approx> s2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tls1 s1'.\n                         s1 -\\<tau>1-tls1\\<rightarrow>* s1' \\<and>\n                         s1' \\<approx> s2' \\<and> tls1 [\\<sim>] tls2", "unfolding flip_simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s1.0 -\\<tau>2-?tls1.0\\<rightarrow>* ?s1';\n   ?s2.0 \\<approx> ?s1.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tls2 s2'.\n                       ?s2.0 -\\<tau>1-tls2\\<rightarrow>* s2' \\<and>\n                       s2' \\<approx> ?s1' \\<and> tls2 [\\<sim>] ?tls1.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s2 -\\<tau>2-tls2\\<rightarrow>* s2'; s1 \\<approx> s2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tls1 s1'.\n                         s1 -\\<tau>1-tls1\\<rightarrow>* s1' \\<and>\n                         s1' \\<approx> s2' \\<and> tls1 [\\<sim>] tls2", "."], ["", "lemma simulation1_\\<tau>inf_step:\n  assumes \\<tau>inf1: \"s1 -\\<tau>1-tls1\\<rightarrow>* \\<infinity>\" and bisim: \"s1 \\<approx> s2\"\n  shows \"\\<exists>tls2. s2 -\\<tau>2-tls2\\<rightarrow>* \\<infinity> \\<and> tls1 [[\\<sim>]] tls2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>tls2.\n       s2 -\\<tau>2-tls2\\<rightarrow>* \\<infinity> \\<and> tls1\n       [[\\<sim>]] tls2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>tls2.\n       s2 -\\<tau>2-tls2\\<rightarrow>* \\<infinity> \\<and> tls1\n       [[\\<sim>]] tls2", "from trsys1.\\<tau>inf_step_imp_\\<tau>inf_step_table[OF \\<tau>inf1]"], ["proof (chain)\npicking this:\n  \\<exists>sstls.\n     s1 -\\<tau>1-sstls\\<rightarrow>*t \\<infinity> \\<and>\n     tls1 = lmap (fst \\<circ> snd \\<circ> snd) sstls", "obtain sstls1 where \\<tau>inf1': \"s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity>\" \n    and tls1: \"tls1 = lmap (fst \\<circ> snd \\<circ> snd) sstls1\""], ["proof (prove)\nusing this:\n  \\<exists>sstls.\n     s1 -\\<tau>1-sstls\\<rightarrow>*t \\<infinity> \\<and>\n     tls1 = lmap (fst \\<circ> snd \\<circ> snd) sstls\n\ngoal (1 subgoal):\n 1. (\\<And>sstls1.\n        \\<lbrakk>s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity>;\n         tls1 = lmap (fst \\<circ> snd \\<circ> snd) sstls1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity>\n  tls1 = lmap (fst \\<circ> snd \\<circ> snd) sstls1\n\ngoal (1 subgoal):\n 1. \\<exists>tls2.\n       s2 -\\<tau>2-tls2\\<rightarrow>* \\<infinity> \\<and> tls1\n       [[\\<sim>]] tls2", "define tl1_to_tl2 where \"tl1_to_tl2 s2 sstls1 = unfold_llist\n     (\\<lambda>(s2, sstls1). lnull sstls1)\n     (\\<lambda>(s2, sstls1).\n        let (s1, s1', tl1, s1'') = lhd sstls1;\n            (s2', tl2, s2'') = SOME (s2', tl2, s2''). s2 -\\<tau>2\\<rightarrow>* s2' \\<and> trsys2 s2' tl2 s2'' \\<and>\n                                     \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>  s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n        in (s2, s2', tl2, s2''))\n     (\\<lambda>(s2, sstls1). \n        let (s1, s1', tl1, s1'') = lhd sstls1;\n            (s2', tl2, s2'') = SOME (s2', tl2, s2''). s2 -\\<tau>2\\<rightarrow>* s2' \\<and> trsys2 s2' tl2 s2'' \\<and>\n                                     \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>  s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n        in (s2'', ltl sstls1))\n     (s2, sstls1)\"\n    for s2 :: 's2 and sstls1 :: \"('s1 \\<times> 's1 \\<times> 'tl1 \\<times> 's1) llist\""], ["proof (state)\nthis:\n  tl1_to_tl2 ?s2.0 ?sstls1.0 =\n  unfold_llist (\\<lambda>(s2, sstls1). lnull sstls1)\n   (\\<lambda>(s2, sstls1).\n       let (s1, s1', tl1, s1'') = lhd sstls1;\n           (s2', tl2, s2'') =\n             SOME (s2', tl2, s2'').\n                s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                s2' -2-tl2\\<rightarrow> s2'' \\<and>\n                \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n                s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n       in (s2, s2', tl2, s2''))\n   (\\<lambda>(s2, sstls1).\n       let (s1, s1', tl1, s1'') = lhd sstls1;\n           (s2', tl2, s2'') =\n             SOME (s2', tl2, s2'').\n                s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                s2' -2-tl2\\<rightarrow> s2'' \\<and>\n                \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n                s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n       in (s2'', ltl sstls1))\n   (?s2.0, ?sstls1.0)\n\ngoal (1 subgoal):\n 1. \\<exists>tls2.\n       s2 -\\<tau>2-tls2\\<rightarrow>* \\<infinity> \\<and> tls1\n       [[\\<sim>]] tls2", "have [simp]:\n    \"\\<And>s2 sstls1. lnull (tl1_to_tl2 s2 sstls1) \\<longleftrightarrow> lnull sstls1\"\n    \"\\<And>s2 sstls1. \\<not> lnull sstls1 \\<Longrightarrow> lhd (tl1_to_tl2 s2 sstls1) =\n        (let (s1, s1', tl1, s1'') = lhd sstls1;\n            (s2', tl2, s2'') = SOME (s2', tl2, s2''). s2 -\\<tau>2\\<rightarrow>* s2' \\<and> trsys2 s2' tl2 s2'' \\<and>\n                                     \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>  s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n        in (s2, s2', tl2, s2''))\"\n    \"\\<And>s2 sstls1. \\<not> lnull sstls1 \\<Longrightarrow> ltl (tl1_to_tl2 s2 sstls1) =\n        (let (s1, s1', tl1, s1'') = lhd sstls1;\n            (s2', tl2, s2'') = SOME (s2', tl2, s2''). s2 -\\<tau>2\\<rightarrow>* s2' \\<and> trsys2 s2' tl2 s2'' \\<and>\n                                     \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>  s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n        in tl1_to_tl2 s2'' (ltl sstls1))\"\n    \"\\<And>s2. tl1_to_tl2 s2 LNil = LNil\"\n    \"\\<And>s2 s1 s1' tl1 s1'' stls1'. tl1_to_tl2 s2 (LCons (s1, s1', tl1, s1'') stls1') =\n        LCons (s2, SOME (s2', tl2, s2''). s2 -\\<tau>2\\<rightarrow>* s2' \\<and> trsys2 s2' tl2 s2'' \\<and> \n                                          \\<not> \\<tau>move2 s2' tl2 s2'' \\<and> s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2) \n              (tl1_to_tl2 (snd (snd (SOME (s2', tl2, s2''). s2 -\\<tau>2\\<rightarrow>* s2' \\<and> trsys2 s2' tl2 s2'' \\<and>\n                                                            \\<not> \\<tau>move2 s2' tl2 s2'' \\<and> s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2)))\n                           stls1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>s2 sstls1. lnull (tl1_to_tl2 s2 sstls1) = lnull sstls1) &&&\n     (\\<And>s2 sstls1.\n         \\<not> lnull sstls1 \\<Longrightarrow>\n         lhd (tl1_to_tl2 s2 sstls1) =\n         (let (s1, s1', tl1, s1'') = lhd sstls1;\n              (s2', tl2, s2'') =\n                SOME (s2', tl2, s2'').\n                   s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                   s2' -2-tl2\\<rightarrow> s2'' \\<and>\n                   \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n                   s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n          in (s2, s2', tl2, s2'')))) &&&\n    (\\<And>s2 sstls1.\n        \\<not> lnull sstls1 \\<Longrightarrow>\n        ltl (tl1_to_tl2 s2 sstls1) =\n        (let (s1, s1', tl1, s1'') = lhd sstls1;\n             (s2', tl2, s2'') =\n               SOME (s2', tl2, s2'').\n                  s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                  s2' -2-tl2\\<rightarrow> s2'' \\<and>\n                  \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n                  s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n         in tl1_to_tl2 s2'' (ltl sstls1))) &&&\n    (\\<And>s2. tl1_to_tl2 s2 LNil = LNil) &&&\n    (\\<And>s2 s1 s1' tl1 s1'' stls1'.\n        tl1_to_tl2 s2 (LCons (s1, s1', tl1, s1'') stls1') =\n        LCons\n         (s2,\n          SOME (s2', tl2, s2'').\n             s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n             s2' -2-tl2\\<rightarrow> s2'' \\<and>\n             \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n             s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2)\n         (tl1_to_tl2\n           (snd (snd (SOME (s2', tl2, s2'').\n                         s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                         s2' -2-tl2\\<rightarrow> s2'' \\<and>\n                         \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n                         s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2)))\n           stls1'))", "by(simp_all add: tl1_to_tl2_def split_beta)"], ["proof (state)\nthis:\n  lnull (tl1_to_tl2 ?s2.0 ?sstls1.0) = lnull ?sstls1.0\n  \\<not> lnull ?sstls1.0 \\<Longrightarrow>\n  lhd (tl1_to_tl2 ?s2.0 ?sstls1.0) =\n  (let (s1, s1', tl1, s1'') = lhd ?sstls1.0;\n       (s2', tl2, s2'') =\n         SOME (s2', tl2, s2'').\n            ?s2.0 -\\<tau>2\\<rightarrow>* s2' \\<and>\n            s2' -2-tl2\\<rightarrow> s2'' \\<and>\n            \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n            s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n   in (?s2.0, s2', tl2, s2''))\n  \\<not> lnull ?sstls1.0 \\<Longrightarrow>\n  ltl (tl1_to_tl2 ?s2.0 ?sstls1.0) =\n  (let (s1, s1', tl1, s1'') = lhd ?sstls1.0;\n       (s2', tl2, s2'') =\n         SOME (s2', tl2, s2'').\n            ?s2.0 -\\<tau>2\\<rightarrow>* s2' \\<and>\n            s2' -2-tl2\\<rightarrow> s2'' \\<and>\n            \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n            s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n   in tl1_to_tl2 s2'' (ltl ?sstls1.0))\n  tl1_to_tl2 ?s2.0 LNil = LNil\n  tl1_to_tl2 ?s2.0 (LCons (?s1.0, ?s1', ?tl1.0, ?s1'') ?stls1') =\n  LCons\n   (?s2.0,\n    SOME (s2', tl2, s2'').\n       ?s2.0 -\\<tau>2\\<rightarrow>* s2' \\<and>\n       s2' -2-tl2\\<rightarrow> s2'' \\<and>\n       \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n       ?s1'' \\<approx> s2'' \\<and> ?tl1.0 \\<sim> tl2)\n   (tl1_to_tl2\n     (snd (snd (SOME (s2', tl2, s2'').\n                   ?s2.0 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                   s2' -2-tl2\\<rightarrow> s2'' \\<and>\n                   \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n                   ?s1'' \\<approx> s2'' \\<and> ?tl1.0 \\<sim> tl2)))\n     ?stls1')\n\ngoal (1 subgoal):\n 1. \\<exists>tls2.\n       s2 -\\<tau>2-tls2\\<rightarrow>* \\<infinity> \\<and> tls1\n       [[\\<sim>]] tls2", "have [simp]: \"llength (tl1_to_tl2 s2 sstls1) = llength sstls1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (tl1_to_tl2 s2 sstls1) = llength sstls1", "by(coinduction arbitrary: s2 sstls1 rule: enat_coinduct)(auto simp add: epred_llength split_beta)"], ["proof (state)\nthis:\n  llength (tl1_to_tl2 s2 sstls1) = llength sstls1\n\ngoal (1 subgoal):\n 1. \\<exists>tls2.\n       s2 -\\<tau>2-tls2\\<rightarrow>* \\<infinity> \\<and> tls1\n       [[\\<sim>]] tls2", "define sstls2 where \"sstls2 = tl1_to_tl2 s2 sstls1\""], ["proof (state)\nthis:\n  sstls2 = tl1_to_tl2 s2 sstls1\n\ngoal (1 subgoal):\n 1. \\<exists>tls2.\n       s2 -\\<tau>2-tls2\\<rightarrow>* \\<infinity> \\<and> tls1\n       [[\\<sim>]] tls2", "with \\<tau>inf1' bisim"], ["proof (chain)\npicking this:\n  s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity>\n  s1 \\<approx> s2\n  sstls2 = tl1_to_tl2 s2 sstls1", "have \"\\<exists>s1 sstls1. s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and> sstls2 = tl1_to_tl2 s2 sstls1 \\<and> s1 \\<approx> s2\""], ["proof (prove)\nusing this:\n  s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity>\n  s1 \\<approx> s2\n  sstls2 = tl1_to_tl2 s2 sstls1\n\ngoal (1 subgoal):\n 1. \\<exists>s1 sstls1.\n       s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and>\n       sstls2 = tl1_to_tl2 s2 sstls1 \\<and> s1 \\<approx> s2", "by blast"], ["proof (state)\nthis:\n  \\<exists>s1 sstls1.\n     s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and>\n     sstls2 = tl1_to_tl2 s2 sstls1 \\<and> s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. \\<exists>tls2.\n       s2 -\\<tau>2-tls2\\<rightarrow>* \\<infinity> \\<and> tls1\n       [[\\<sim>]] tls2", "from \\<tau>inf1' bisim"], ["proof (chain)\npicking this:\n  s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity>\n  s1 \\<approx> s2", "have \"s2 -\\<tau>2-tl1_to_tl2 s2 sstls1\\<rightarrow>*t \\<infinity>\""], ["proof (prove)\nusing this:\n  s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity>\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. s2 -\\<tau>2-tl1_to_tl2 s2 sstls1\\<rightarrow>*t \\<infinity>", "proof(coinduction arbitrary: s2 s1 sstls1)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s2 s1 sstls1.\n       \\<lbrakk>s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity>;\n        s1 \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tl1_to_tl2 s2 sstls1 =\n                             LCons (s, s', tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 sstls1.\n                                  s'' = s2 \\<and>\n                                  tls = tl1_to_tl2 s2 sstls1 \\<and>\n                                  s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and>\n                                  s1 \\<approx> s2) \\<or>\n                              s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tl1_to_tl2 s2 sstls1 = LNil \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>)", "case (\\<tau>inf_step_table s2 s1 sstls1)"], ["proof (state)\nthis:\n  s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity>\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. \\<And>s2 s1 sstls1.\n       \\<lbrakk>s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity>;\n        s1 \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tl1_to_tl2 s2 sstls1 =\n                             LCons (s, s', tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 sstls1.\n                                  s'' = s2 \\<and>\n                                  tls = tl1_to_tl2 s2 sstls1 \\<and>\n                                  s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and>\n                                  s1 \\<approx> s2) \\<or>\n                              s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tl1_to_tl2 s2 sstls1 = LNil \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>)", "note \\<tau>inf' = \\<open>s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity>\\<close> and bisim = \\<open>s1 \\<approx> s2\\<close>"], ["proof (state)\nthis:\n  s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity>\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. \\<And>s2 s1 sstls1.\n       \\<lbrakk>s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity>;\n        s1 \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tl1_to_tl2 s2 sstls1 =\n                             LCons (s, s', tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 sstls1.\n                                  s'' = s2 \\<and>\n                                  tls = tl1_to_tl2 s2 sstls1 \\<and>\n                                  s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and>\n                                  s1 \\<approx> s2) \\<or>\n                              s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tl1_to_tl2 s2 sstls1 = LNil \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>)", "from \\<tau>inf'"], ["proof (chain)\npicking this:\n  s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity>", "show ?case"], ["proof (prove)\nusing this:\n  s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<exists>s s' s'' tls tl.\n        s2 = s \\<and>\n        tl1_to_tl2 s2 sstls1 = LCons (s, s', tl, s'') tls \\<and>\n        s -\\<tau>2\\<rightarrow>* s' \\<and>\n        s' -2-tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move2 s' tl s'' \\<and>\n        ((\\<exists>s2 s1 sstls1.\n             s'' = s2 \\<and>\n             tls = tl1_to_tl2 s2 sstls1 \\<and>\n             s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and> s1\n             \\<approx> s2) \\<or>\n         s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n    (\\<exists>s.\n        s2 = s \\<and>\n        tl1_to_tl2 s2 sstls1 = LNil \\<and>\n        s -\\<tau>2\\<rightarrow> \\<infinity>)", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>sstls1 = LCons (s1, s', tl, s'') tls;\n        s1 -\\<tau>1\\<rightarrow>* s'; s' -1-tl\\<rightarrow> s'';\n        \\<not> \\<tau>move1 s' tl s'';\n        s'' -\\<tau>1-tls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tl1_to_tl2 s2 sstls1 =\n                             LCons (s, s', tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 sstls1.\n                                  s'' = s2 \\<and>\n                                  tls = tl1_to_tl2 s2 sstls1 \\<and>\n                                  s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and>\n                                  s1 \\<approx> s2) \\<or>\n                              s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tl1_to_tl2 s2 sstls1 = LNil \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>)\n 2. \\<lbrakk>sstls1 = LNil; s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                          s2 = s \\<and>\n                          tl1_to_tl2 s2 sstls1 =\n                          LCons (s, s', tl, s'') tls \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          s' -2-tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move2 s' tl s'' \\<and>\n                          ((\\<exists>s2 s1 sstls1.\n                               s'' = s2 \\<and>\n                               tls = tl1_to_tl2 s2 sstls1 \\<and>\n                               s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and>\n                               s1 \\<approx> s2) \\<or>\n                           s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                      (\\<exists>s.\n                          s2 = s \\<and>\n                          tl1_to_tl2 s2 sstls1 = LNil \\<and>\n                          s -\\<tau>2\\<rightarrow> \\<infinity>)", "case (\\<tau>inf_step_table_Cons s1' s1'' sstls1' tl1)"], ["proof (state)\nthis:\n  sstls1 = LCons (s1, s1', tl1, s1'') sstls1'\n  s1 -\\<tau>1\\<rightarrow>* s1'\n  s1' -1-tl1\\<rightarrow> s1''\n  \\<not> \\<tau>move1 s1' tl1 s1''\n  s1'' -\\<tau>1-sstls1'\\<rightarrow>*t \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>sstls1 = LCons (s1, s', tl, s'') tls;\n        s1 -\\<tau>1\\<rightarrow>* s'; s' -1-tl\\<rightarrow> s'';\n        \\<not> \\<tau>move1 s' tl s'';\n        s'' -\\<tau>1-tls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tl1_to_tl2 s2 sstls1 =\n                             LCons (s, s', tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 sstls1.\n                                  s'' = s2 \\<and>\n                                  tls = tl1_to_tl2 s2 sstls1 \\<and>\n                                  s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and>\n                                  s1 \\<approx> s2) \\<or>\n                              s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tl1_to_tl2 s2 sstls1 = LNil \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>)\n 2. \\<lbrakk>sstls1 = LNil; s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                          s2 = s \\<and>\n                          tl1_to_tl2 s2 sstls1 =\n                          LCons (s, s', tl, s'') tls \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          s' -2-tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move2 s' tl s'' \\<and>\n                          ((\\<exists>s2 s1 sstls1.\n                               s'' = s2 \\<and>\n                               tls = tl1_to_tl2 s2 sstls1 \\<and>\n                               s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and>\n                               s1 \\<approx> s2) \\<or>\n                           s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                      (\\<exists>s.\n                          s2 = s \\<and>\n                          tl1_to_tl2 s2 sstls1 = LNil \\<and>\n                          s -\\<tau>2\\<rightarrow> \\<infinity>)", "hence sstls1: \"sstls1 = LCons (s1, s1', tl1, s1'') sstls1'\"\n        and \\<tau>s: \"s1 -\\<tau>1\\<rightarrow>* s1'\" and r: \"s1' -1-tl1\\<rightarrow> s1''\" and n\\<tau>: \"\\<not> \\<tau>move1 s1' tl1 s1''\"\n        and reds1: \"s1'' -\\<tau>1-sstls1'\\<rightarrow>*t \\<infinity>\""], ["proof (prove)\nusing this:\n  sstls1 = LCons (s1, s1', tl1, s1'') sstls1'\n  s1 -\\<tau>1\\<rightarrow>* s1'\n  s1' -1-tl1\\<rightarrow> s1''\n  \\<not> \\<tau>move1 s1' tl1 s1''\n  s1'' -\\<tau>1-sstls1'\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. (sstls1 = LCons (s1, s1', tl1, s1'') sstls1' &&&\n     s1 -\\<tau>1\\<rightarrow>* s1') &&&\n    s1' -1-tl1\\<rightarrow> s1'' &&&\n    \\<not> \\<tau>move1 s1' tl1 s1'' &&&\n    s1'' -\\<tau>1-sstls1'\\<rightarrow>*t \\<infinity>", "by simp_all"], ["proof (state)\nthis:\n  sstls1 = LCons (s1, s1', tl1, s1'') sstls1'\n  s1 -\\<tau>1\\<rightarrow>* s1'\n  s1' -1-tl1\\<rightarrow> s1''\n  \\<not> \\<tau>move1 s1' tl1 s1''\n  s1'' -\\<tau>1-sstls1'\\<rightarrow>*t \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>sstls1 = LCons (s1, s', tl, s'') tls;\n        s1 -\\<tau>1\\<rightarrow>* s'; s' -1-tl\\<rightarrow> s'';\n        \\<not> \\<tau>move1 s' tl s'';\n        s'' -\\<tau>1-tls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tl1_to_tl2 s2 sstls1 =\n                             LCons (s, s', tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 sstls1.\n                                  s'' = s2 \\<and>\n                                  tls = tl1_to_tl2 s2 sstls1 \\<and>\n                                  s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and>\n                                  s1 \\<approx> s2) \\<or>\n                              s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tl1_to_tl2 s2 sstls1 = LNil \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>)\n 2. \\<lbrakk>sstls1 = LNil; s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                          s2 = s \\<and>\n                          tl1_to_tl2 s2 sstls1 =\n                          LCons (s, s', tl, s'') tls \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          s' -2-tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move2 s' tl s'' \\<and>\n                          ((\\<exists>s2 s1 sstls1.\n                               s'' = s2 \\<and>\n                               tls = tl1_to_tl2 s2 sstls1 \\<and>\n                               s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and>\n                               s1 \\<approx> s2) \\<or>\n                           s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                      (\\<exists>s.\n                          s2 = s \\<and>\n                          tl1_to_tl2 s2 sstls1 = LNil \\<and>\n                          s -\\<tau>2\\<rightarrow> \\<infinity>)", "let ?P = \"\\<lambda>(s2', tl2, s2''). s2 -\\<tau>2\\<rightarrow>* s2' \\<and> trsys2 s2' tl2 s2'' \\<and> \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>  s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>sstls1 = LCons (s1, s', tl, s'') tls;\n        s1 -\\<tau>1\\<rightarrow>* s'; s' -1-tl\\<rightarrow> s'';\n        \\<not> \\<tau>move1 s' tl s'';\n        s'' -\\<tau>1-tls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tl1_to_tl2 s2 sstls1 =\n                             LCons (s, s', tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 sstls1.\n                                  s'' = s2 \\<and>\n                                  tls = tl1_to_tl2 s2 sstls1 \\<and>\n                                  s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and>\n                                  s1 \\<approx> s2) \\<or>\n                              s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tl1_to_tl2 s2 sstls1 = LNil \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>)\n 2. \\<lbrakk>sstls1 = LNil; s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                          s2 = s \\<and>\n                          tl1_to_tl2 s2 sstls1 =\n                          LCons (s, s', tl, s'') tls \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          s' -2-tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move2 s' tl s'' \\<and>\n                          ((\\<exists>s2 s1 sstls1.\n                               s'' = s2 \\<and>\n                               tls = tl1_to_tl2 s2 sstls1 \\<and>\n                               s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and>\n                               s1 \\<approx> s2) \\<or>\n                           s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                      (\\<exists>s.\n                          s2 = s \\<and>\n                          tl1_to_tl2 s2 sstls1 = LNil \\<and>\n                          s -\\<tau>2\\<rightarrow> \\<infinity>)", "let ?s2tl2s2' = \"Eps ?P\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>sstls1 = LCons (s1, s', tl, s'') tls;\n        s1 -\\<tau>1\\<rightarrow>* s'; s' -1-tl\\<rightarrow> s'';\n        \\<not> \\<tau>move1 s' tl s'';\n        s'' -\\<tau>1-tls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tl1_to_tl2 s2 sstls1 =\n                             LCons (s, s', tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 sstls1.\n                                  s'' = s2 \\<and>\n                                  tls = tl1_to_tl2 s2 sstls1 \\<and>\n                                  s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and>\n                                  s1 \\<approx> s2) \\<or>\n                              s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tl1_to_tl2 s2 sstls1 = LNil \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>)\n 2. \\<lbrakk>sstls1 = LNil; s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                          s2 = s \\<and>\n                          tl1_to_tl2 s2 sstls1 =\n                          LCons (s, s', tl, s'') tls \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          s' -2-tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move2 s' tl s'' \\<and>\n                          ((\\<exists>s2 s1 sstls1.\n                               s'' = s2 \\<and>\n                               tls = tl1_to_tl2 s2 sstls1 \\<and>\n                               s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and>\n                               s1 \\<approx> s2) \\<or>\n                           s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                      (\\<exists>s.\n                          s2 = s \\<and>\n                          tl1_to_tl2 s2 sstls1 = LNil \\<and>\n                          s -\\<tau>2\\<rightarrow> \\<infinity>)", "let ?s2'' = \"snd (snd ?s2tl2s2')\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>sstls1 = LCons (s1, s', tl, s'') tls;\n        s1 -\\<tau>1\\<rightarrow>* s'; s' -1-tl\\<rightarrow> s'';\n        \\<not> \\<tau>move1 s' tl s'';\n        s'' -\\<tau>1-tls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tl1_to_tl2 s2 sstls1 =\n                             LCons (s, s', tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 sstls1.\n                                  s'' = s2 \\<and>\n                                  tls = tl1_to_tl2 s2 sstls1 \\<and>\n                                  s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and>\n                                  s1 \\<approx> s2) \\<or>\n                              s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tl1_to_tl2 s2 sstls1 = LNil \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>)\n 2. \\<lbrakk>sstls1 = LNil; s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                          s2 = s \\<and>\n                          tl1_to_tl2 s2 sstls1 =\n                          LCons (s, s', tl, s'') tls \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          s' -2-tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move2 s' tl s'' \\<and>\n                          ((\\<exists>s2 s1 sstls1.\n                               s'' = s2 \\<and>\n                               tls = tl1_to_tl2 s2 sstls1 \\<and>\n                               s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and>\n                               s1 \\<approx> s2) \\<or>\n                           s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                      (\\<exists>s.\n                          s2 = s \\<and>\n                          tl1_to_tl2 s2 sstls1 = LNil \\<and>\n                          s -\\<tau>2\\<rightarrow> \\<infinity>)", "from simulation_silents1[OF \\<open>s1 \\<approx> s2\\<close> \\<tau>s]"], ["proof (chain)\npicking this:\n  \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2'", "obtain s2' where \"s2 -\\<tau>2\\<rightarrow>* s2'\" \"s1' \\<approx> s2'\""], ["proof (prove)\nusing this:\n  \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2'\n\ngoal (1 subgoal):\n 1. (\\<And>s2'.\n        \\<lbrakk>s2 -\\<tau>2\\<rightarrow>* s2'; s1' \\<approx> s2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  s1' \\<approx> s2'\n\ngoal (2 subgoals):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>sstls1 = LCons (s1, s', tl, s'') tls;\n        s1 -\\<tau>1\\<rightarrow>* s'; s' -1-tl\\<rightarrow> s'';\n        \\<not> \\<tau>move1 s' tl s'';\n        s'' -\\<tau>1-tls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tl1_to_tl2 s2 sstls1 =\n                             LCons (s, s', tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 sstls1.\n                                  s'' = s2 \\<and>\n                                  tls = tl1_to_tl2 s2 sstls1 \\<and>\n                                  s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and>\n                                  s1 \\<approx> s2) \\<or>\n                              s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tl1_to_tl2 s2 sstls1 = LNil \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>)\n 2. \\<lbrakk>sstls1 = LNil; s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                          s2 = s \\<and>\n                          tl1_to_tl2 s2 sstls1 =\n                          LCons (s, s', tl, s'') tls \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          s' -2-tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move2 s' tl s'' \\<and>\n                          ((\\<exists>s2 s1 sstls1.\n                               s'' = s2 \\<and>\n                               tls = tl1_to_tl2 s2 sstls1 \\<and>\n                               s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and>\n                               s1 \\<approx> s2) \\<or>\n                           s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                      (\\<exists>s.\n                          s2 = s \\<and>\n                          tl1_to_tl2 s2 sstls1 = LNil \\<and>\n                          s -\\<tau>2\\<rightarrow> \\<infinity>)", "from simulation1[OF \\<open>s1' \\<approx> s2'\\<close> r n\\<tau>]"], ["proof (chain)\npicking this:\n  \\<exists>s2'a s2'' tl2.\n     s2' -\\<tau>2\\<rightarrow>* s2'a \\<and>\n     s2'a -2-tl2\\<rightarrow> s2'' \\<and>\n     \\<not> \\<tau>move2 s2'a tl2 s2'' \\<and>\n     s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2", "obtain s2'' s2''' tl2\n        where \"s2' -\\<tau>2\\<rightarrow>* s2''\" \n        and rest: \"s2'' -2-tl2\\<rightarrow> s2'''\" \"\\<not> \\<tau>move2 s2'' tl2 s2'''\" \"s1'' \\<approx> s2'''\" \"tl1 \\<sim> tl2\""], ["proof (prove)\nusing this:\n  \\<exists>s2'a s2'' tl2.\n     s2' -\\<tau>2\\<rightarrow>* s2'a \\<and>\n     s2'a -2-tl2\\<rightarrow> s2'' \\<and>\n     \\<not> \\<tau>move2 s2'a tl2 s2'' \\<and>\n     s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. (\\<And>s2'' tl2 s2'''.\n        \\<lbrakk>s2' -\\<tau>2\\<rightarrow>* s2'';\n         s2'' -2-tl2\\<rightarrow> s2'''; \\<not> \\<tau>move2 s2'' tl2 s2''';\n         s1'' \\<approx> s2'''; tl1 \\<sim> tl2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s2' -\\<tau>2\\<rightarrow>* s2''\n  s2'' -2-tl2\\<rightarrow> s2'''\n  \\<not> \\<tau>move2 s2'' tl2 s2'''\n  s1'' \\<approx> s2'''\n  tl1 \\<sim> tl2\n\ngoal (2 subgoals):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>sstls1 = LCons (s1, s', tl, s'') tls;\n        s1 -\\<tau>1\\<rightarrow>* s'; s' -1-tl\\<rightarrow> s'';\n        \\<not> \\<tau>move1 s' tl s'';\n        s'' -\\<tau>1-tls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tl1_to_tl2 s2 sstls1 =\n                             LCons (s, s', tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 sstls1.\n                                  s'' = s2 \\<and>\n                                  tls = tl1_to_tl2 s2 sstls1 \\<and>\n                                  s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and>\n                                  s1 \\<approx> s2) \\<or>\n                              s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tl1_to_tl2 s2 sstls1 = LNil \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>)\n 2. \\<lbrakk>sstls1 = LNil; s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                          s2 = s \\<and>\n                          tl1_to_tl2 s2 sstls1 =\n                          LCons (s, s', tl, s'') tls \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          s' -2-tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move2 s' tl s'' \\<and>\n                          ((\\<exists>s2 s1 sstls1.\n                               s'' = s2 \\<and>\n                               tls = tl1_to_tl2 s2 sstls1 \\<and>\n                               s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and>\n                               s1 \\<approx> s2) \\<or>\n                           s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                      (\\<exists>s.\n                          s2 = s \\<and>\n                          tl1_to_tl2 s2 sstls1 = LNil \\<and>\n                          s -\\<tau>2\\<rightarrow> \\<infinity>)", "from \\<open>s2 -\\<tau>2\\<rightarrow>* s2'\\<close> \\<open>s2' -\\<tau>2\\<rightarrow>* s2''\\<close>"], ["proof (chain)\npicking this:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  s2' -\\<tau>2\\<rightarrow>* s2''", "have \"s2 -\\<tau>2\\<rightarrow>* s2''\""], ["proof (prove)\nusing this:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  s2' -\\<tau>2\\<rightarrow>* s2''\n\ngoal (1 subgoal):\n 1. s2 -\\<tau>2\\<rightarrow>* s2''", "by(rule rtranclp_trans)"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow>* s2''\n\ngoal (2 subgoals):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>sstls1 = LCons (s1, s', tl, s'') tls;\n        s1 -\\<tau>1\\<rightarrow>* s'; s' -1-tl\\<rightarrow> s'';\n        \\<not> \\<tau>move1 s' tl s'';\n        s'' -\\<tau>1-tls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tl1_to_tl2 s2 sstls1 =\n                             LCons (s, s', tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 sstls1.\n                                  s'' = s2 \\<and>\n                                  tls = tl1_to_tl2 s2 sstls1 \\<and>\n                                  s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and>\n                                  s1 \\<approx> s2) \\<or>\n                              s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tl1_to_tl2 s2 sstls1 = LNil \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>)\n 2. \\<lbrakk>sstls1 = LNil; s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                          s2 = s \\<and>\n                          tl1_to_tl2 s2 sstls1 =\n                          LCons (s, s', tl, s'') tls \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          s' -2-tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move2 s' tl s'' \\<and>\n                          ((\\<exists>s2 s1 sstls1.\n                               s'' = s2 \\<and>\n                               tls = tl1_to_tl2 s2 sstls1 \\<and>\n                               s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and>\n                               s1 \\<approx> s2) \\<or>\n                           s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                      (\\<exists>s.\n                          s2 = s \\<and>\n                          tl1_to_tl2 s2 sstls1 = LNil \\<and>\n                          s -\\<tau>2\\<rightarrow> \\<infinity>)", "with rest"], ["proof (chain)\npicking this:\n  s2'' -2-tl2\\<rightarrow> s2'''\n  \\<not> \\<tau>move2 s2'' tl2 s2'''\n  s1'' \\<approx> s2'''\n  tl1 \\<sim> tl2\n  s2 -\\<tau>2\\<rightarrow>* s2''", "have \"?P (s2'', tl2, s2''')\""], ["proof (prove)\nusing this:\n  s2'' -2-tl2\\<rightarrow> s2'''\n  \\<not> \\<tau>move2 s2'' tl2 s2'''\n  s1'' \\<approx> s2'''\n  tl1 \\<sim> tl2\n  s2 -\\<tau>2\\<rightarrow>* s2''\n\ngoal (1 subgoal):\n 1. case (s2'', tl2, s2''') of\n    (s2', tl2, s2'') \\<Rightarrow>\n      s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n      s2' -2-tl2\\<rightarrow> s2'' \\<and>\n      \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n      s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2", "by simp"], ["proof (state)\nthis:\n  case (s2'', tl2, s2''') of\n  (s2', tl2, s2'') \\<Rightarrow>\n    s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n    s2' -2-tl2\\<rightarrow> s2'' \\<and>\n    \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n    s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n\ngoal (2 subgoals):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>sstls1 = LCons (s1, s', tl, s'') tls;\n        s1 -\\<tau>1\\<rightarrow>* s'; s' -1-tl\\<rightarrow> s'';\n        \\<not> \\<tau>move1 s' tl s'';\n        s'' -\\<tau>1-tls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tl1_to_tl2 s2 sstls1 =\n                             LCons (s, s', tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 sstls1.\n                                  s'' = s2 \\<and>\n                                  tls = tl1_to_tl2 s2 sstls1 \\<and>\n                                  s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and>\n                                  s1 \\<approx> s2) \\<or>\n                              s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tl1_to_tl2 s2 sstls1 = LNil \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>)\n 2. \\<lbrakk>sstls1 = LNil; s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                          s2 = s \\<and>\n                          tl1_to_tl2 s2 sstls1 =\n                          LCons (s, s', tl, s'') tls \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          s' -2-tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move2 s' tl s'' \\<and>\n                          ((\\<exists>s2 s1 sstls1.\n                               s'' = s2 \\<and>\n                               tls = tl1_to_tl2 s2 sstls1 \\<and>\n                               s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and>\n                               s1 \\<approx> s2) \\<or>\n                           s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                      (\\<exists>s.\n                          s2 = s \\<and>\n                          tl1_to_tl2 s2 sstls1 = LNil \\<and>\n                          s -\\<tau>2\\<rightarrow> \\<infinity>)", "hence \"?P ?s2tl2s2'\""], ["proof (prove)\nusing this:\n  case (s2'', tl2, s2''') of\n  (s2', tl2, s2'') \\<Rightarrow>\n    s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n    s2' -2-tl2\\<rightarrow> s2'' \\<and>\n    \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n    s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. case SOME (s2', tl2, s2'').\n            s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n            s2' -2-tl2\\<rightarrow> s2'' \\<and>\n            \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n            s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2 of\n    (s2', tl2, s2'') \\<Rightarrow>\n      s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n      s2' -2-tl2\\<rightarrow> s2'' \\<and>\n      \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n      s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2", "by(rule someI)"], ["proof (state)\nthis:\n  case SOME (s2', tl2, s2'').\n          s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n          s2' -2-tl2\\<rightarrow> s2'' \\<and>\n          \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n          s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2 of\n  (s2', tl2, s2'') \\<Rightarrow>\n    s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n    s2' -2-tl2\\<rightarrow> s2'' \\<and>\n    \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n    s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n\ngoal (2 subgoals):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>sstls1 = LCons (s1, s', tl, s'') tls;\n        s1 -\\<tau>1\\<rightarrow>* s'; s' -1-tl\\<rightarrow> s'';\n        \\<not> \\<tau>move1 s' tl s'';\n        s'' -\\<tau>1-tls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tl1_to_tl2 s2 sstls1 =\n                             LCons (s, s', tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 sstls1.\n                                  s'' = s2 \\<and>\n                                  tls = tl1_to_tl2 s2 sstls1 \\<and>\n                                  s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and>\n                                  s1 \\<approx> s2) \\<or>\n                              s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tl1_to_tl2 s2 sstls1 = LNil \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>)\n 2. \\<lbrakk>sstls1 = LNil; s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                          s2 = s \\<and>\n                          tl1_to_tl2 s2 sstls1 =\n                          LCons (s, s', tl, s'') tls \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          s' -2-tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move2 s' tl s'' \\<and>\n                          ((\\<exists>s2 s1 sstls1.\n                               s'' = s2 \\<and>\n                               tls = tl1_to_tl2 s2 sstls1 \\<and>\n                               s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and>\n                               s1 \\<approx> s2) \\<or>\n                           s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                      (\\<exists>s.\n                          s2 = s \\<and>\n                          tl1_to_tl2 s2 sstls1 = LNil \\<and>\n                          s -\\<tau>2\\<rightarrow> \\<infinity>)", "then"], ["proof (chain)\npicking this:\n  case SOME (s2', tl2, s2'').\n          s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n          s2' -2-tl2\\<rightarrow> s2'' \\<and>\n          \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n          s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2 of\n  (s2', tl2, s2'') \\<Rightarrow>\n    s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n    s2' -2-tl2\\<rightarrow> s2'' \\<and>\n    \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n    s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2", "show ?thesis"], ["proof (prove)\nusing this:\n  case SOME (s2', tl2, s2'').\n          s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n          s2' -2-tl2\\<rightarrow> s2'' \\<and>\n          \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n          s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2 of\n  (s2', tl2, s2'') \\<Rightarrow>\n    s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n    s2' -2-tl2\\<rightarrow> s2'' \\<and>\n    \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n    s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. (\\<exists>s s' s'' tls tl.\n        s2 = s \\<and>\n        tl1_to_tl2 s2 sstls1 = LCons (s, s', tl, s'') tls \\<and>\n        s -\\<tau>2\\<rightarrow>* s' \\<and>\n        s' -2-tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move2 s' tl s'' \\<and>\n        ((\\<exists>s2 s1 sstls1.\n             s'' = s2 \\<and>\n             tls = tl1_to_tl2 s2 sstls1 \\<and>\n             s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and> s1\n             \\<approx> s2) \\<or>\n         s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n    (\\<exists>s.\n        s2 = s \\<and>\n        tl1_to_tl2 s2 sstls1 = LNil \\<and>\n        s -\\<tau>2\\<rightarrow> \\<infinity>)", "using reds1 sstls1"], ["proof (prove)\nusing this:\n  case SOME (s2', tl2, s2'').\n          s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n          s2' -2-tl2\\<rightarrow> s2'' \\<and>\n          \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n          s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2 of\n  (s2', tl2, s2'') \\<Rightarrow>\n    s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n    s2' -2-tl2\\<rightarrow> s2'' \\<and>\n    \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n    s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n  s1'' -\\<tau>1-sstls1'\\<rightarrow>*t \\<infinity>\n  sstls1 = LCons (s1, s1', tl1, s1'') sstls1'\n\ngoal (1 subgoal):\n 1. (\\<exists>s s' s'' tls tl.\n        s2 = s \\<and>\n        tl1_to_tl2 s2 sstls1 = LCons (s, s', tl, s'') tls \\<and>\n        s -\\<tau>2\\<rightarrow>* s' \\<and>\n        s' -2-tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move2 s' tl s'' \\<and>\n        ((\\<exists>s2 s1 sstls1.\n             s'' = s2 \\<and>\n             tls = tl1_to_tl2 s2 sstls1 \\<and>\n             s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and> s1\n             \\<approx> s2) \\<or>\n         s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n    (\\<exists>s.\n        s2 = s \\<and>\n        tl1_to_tl2 s2 sstls1 = LNil \\<and>\n        s -\\<tau>2\\<rightarrow> \\<infinity>)", "by fastforce"], ["proof (state)\nthis:\n  (\\<exists>s s' s'' tls tl.\n      s2 = s \\<and>\n      tl1_to_tl2 s2 sstls1 = LCons (s, s', tl, s'') tls \\<and>\n      s -\\<tau>2\\<rightarrow>* s' \\<and>\n      s' -2-tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move2 s' tl s'' \\<and>\n      ((\\<exists>s2 s1 sstls1.\n           s'' = s2 \\<and>\n           tls = tl1_to_tl2 s2 sstls1 \\<and>\n           s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and> s1\n           \\<approx> s2) \\<or>\n       s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n  (\\<exists>s.\n      s2 = s \\<and>\n      tl1_to_tl2 s2 sstls1 = LNil \\<and>\n      s -\\<tau>2\\<rightarrow> \\<infinity>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sstls1 = LNil; s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                          s2 = s \\<and>\n                          tl1_to_tl2 s2 sstls1 =\n                          LCons (s, s', tl, s'') tls \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          s' -2-tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move2 s' tl s'' \\<and>\n                          ((\\<exists>s2 s1 sstls1.\n                               s'' = s2 \\<and>\n                               tls = tl1_to_tl2 s2 sstls1 \\<and>\n                               s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and>\n                               s1 \\<approx> s2) \\<or>\n                           s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                      (\\<exists>s.\n                          s2 = s \\<and>\n                          tl1_to_tl2 s2 sstls1 = LNil \\<and>\n                          s -\\<tau>2\\<rightarrow> \\<infinity>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>sstls1 = LNil; s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                          s2 = s \\<and>\n                          tl1_to_tl2 s2 sstls1 =\n                          LCons (s, s', tl, s'') tls \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          s' -2-tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move2 s' tl s'' \\<and>\n                          ((\\<exists>s2 s1 sstls1.\n                               s'' = s2 \\<and>\n                               tls = tl1_to_tl2 s2 sstls1 \\<and>\n                               s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and>\n                               s1 \\<approx> s2) \\<or>\n                           s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                      (\\<exists>s.\n                          s2 = s \\<and>\n                          tl1_to_tl2 s2 sstls1 = LNil \\<and>\n                          s -\\<tau>2\\<rightarrow> \\<infinity>)", "case \\<tau>inf_step_table_Nil"], ["proof (state)\nthis:\n  sstls1 = LNil\n  s1 -\\<tau>1\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sstls1 = LNil; s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                          s2 = s \\<and>\n                          tl1_to_tl2 s2 sstls1 =\n                          LCons (s, s', tl, s'') tls \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          s' -2-tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move2 s' tl s'' \\<and>\n                          ((\\<exists>s2 s1 sstls1.\n                               s'' = s2 \\<and>\n                               tls = tl1_to_tl2 s2 sstls1 \\<and>\n                               s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and>\n                               s1 \\<approx> s2) \\<or>\n                           s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                      (\\<exists>s.\n                          s2 = s \\<and>\n                          tl1_to_tl2 s2 sstls1 = LNil \\<and>\n                          s -\\<tau>2\\<rightarrow> \\<infinity>)", "hence [simp]: \"sstls1 = LNil\" and \"s1 -\\<tau>1\\<rightarrow> \\<infinity>\""], ["proof (prove)\nusing this:\n  sstls1 = LNil\n  s1 -\\<tau>1\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. sstls1 = LNil &&& s1 -\\<tau>1\\<rightarrow> \\<infinity>", "by simp_all"], ["proof (state)\nthis:\n  sstls1 = LNil\n  s1 -\\<tau>1\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sstls1 = LNil; s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                          s2 = s \\<and>\n                          tl1_to_tl2 s2 sstls1 =\n                          LCons (s, s', tl, s'') tls \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          s' -2-tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move2 s' tl s'' \\<and>\n                          ((\\<exists>s2 s1 sstls1.\n                               s'' = s2 \\<and>\n                               tls = tl1_to_tl2 s2 sstls1 \\<and>\n                               s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and>\n                               s1 \\<approx> s2) \\<or>\n                           s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                      (\\<exists>s.\n                          s2 = s \\<and>\n                          tl1_to_tl2 s2 sstls1 = LNil \\<and>\n                          s -\\<tau>2\\<rightarrow> \\<infinity>)", "from \\<open>s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<close> \\<open>s1 \\<approx> s2\\<close>"], ["proof (chain)\npicking this:\n  s1 -\\<tau>1\\<rightarrow> \\<infinity>\n  s1 \\<approx> s2", "have \"s2 -\\<tau>2\\<rightarrow> \\<infinity>\""], ["proof (prove)\nusing this:\n  s1 -\\<tau>1\\<rightarrow> \\<infinity>\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. s2 -\\<tau>2\\<rightarrow> \\<infinity>", "by(simp add: \\<tau>diverge_bisim_inv)"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sstls1 = LNil; s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                          s2 = s \\<and>\n                          tl1_to_tl2 s2 sstls1 =\n                          LCons (s, s', tl, s'') tls \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          s' -2-tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move2 s' tl s'' \\<and>\n                          ((\\<exists>s2 s1 sstls1.\n                               s'' = s2 \\<and>\n                               tls = tl1_to_tl2 s2 sstls1 \\<and>\n                               s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and>\n                               s1 \\<approx> s2) \\<or>\n                           s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                      (\\<exists>s.\n                          s2 = s \\<and>\n                          tl1_to_tl2 s2 sstls1 = LNil \\<and>\n                          s -\\<tau>2\\<rightarrow> \\<infinity>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  s2 -\\<tau>2\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<exists>s s' s'' tls tl.\n        s2 = s \\<and>\n        tl1_to_tl2 s2 sstls1 = LCons (s, s', tl, s'') tls \\<and>\n        s -\\<tau>2\\<rightarrow>* s' \\<and>\n        s' -2-tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move2 s' tl s'' \\<and>\n        ((\\<exists>s2 s1 sstls1.\n             s'' = s2 \\<and>\n             tls = tl1_to_tl2 s2 sstls1 \\<and>\n             s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and> s1\n             \\<approx> s2) \\<or>\n         s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n    (\\<exists>s.\n        s2 = s \\<and>\n        tl1_to_tl2 s2 sstls1 = LNil \\<and>\n        s -\\<tau>2\\<rightarrow> \\<infinity>)", "using sstls2_def"], ["proof (prove)\nusing this:\n  s2 -\\<tau>2\\<rightarrow> \\<infinity>\n  sstls2 = tl1_to_tl2 s2 sstls1__\n\ngoal (1 subgoal):\n 1. (\\<exists>s s' s'' tls tl.\n        s2 = s \\<and>\n        tl1_to_tl2 s2 sstls1 = LCons (s, s', tl, s'') tls \\<and>\n        s -\\<tau>2\\<rightarrow>* s' \\<and>\n        s' -2-tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move2 s' tl s'' \\<and>\n        ((\\<exists>s2 s1 sstls1.\n             s'' = s2 \\<and>\n             tls = tl1_to_tl2 s2 sstls1 \\<and>\n             s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and> s1\n             \\<approx> s2) \\<or>\n         s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n    (\\<exists>s.\n        s2 = s \\<and>\n        tl1_to_tl2 s2 sstls1 = LNil \\<and>\n        s -\\<tau>2\\<rightarrow> \\<infinity>)", "by simp"], ["proof (state)\nthis:\n  (\\<exists>s s' s'' tls tl.\n      s2 = s \\<and>\n      tl1_to_tl2 s2 sstls1 = LCons (s, s', tl, s'') tls \\<and>\n      s -\\<tau>2\\<rightarrow>* s' \\<and>\n      s' -2-tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move2 s' tl s'' \\<and>\n      ((\\<exists>s2 s1 sstls1.\n           s'' = s2 \\<and>\n           tls = tl1_to_tl2 s2 sstls1 \\<and>\n           s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and> s1\n           \\<approx> s2) \\<or>\n       s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n  (\\<exists>s.\n      s2 = s \\<and>\n      tl1_to_tl2 s2 sstls1 = LNil \\<and>\n      s -\\<tau>2\\<rightarrow> \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>s s' s'' tls tl.\n      s2 = s \\<and>\n      tl1_to_tl2 s2 sstls1 = LCons (s, s', tl, s'') tls \\<and>\n      s -\\<tau>2\\<rightarrow>* s' \\<and>\n      s' -2-tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move2 s' tl s'' \\<and>\n      ((\\<exists>s2 s1 sstls1.\n           s'' = s2 \\<and>\n           tls = tl1_to_tl2 s2 sstls1 \\<and>\n           s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity> \\<and> s1\n           \\<approx> s2) \\<or>\n       s'' -\\<tau>2-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n  (\\<exists>s.\n      s2 = s \\<and>\n      tl1_to_tl2 s2 sstls1 = LNil \\<and>\n      s -\\<tau>2\\<rightarrow> \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s2 -\\<tau>2-tl1_to_tl2 s2 sstls1\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>tls2.\n       s2 -\\<tau>2-tls2\\<rightarrow>* \\<infinity> \\<and> tls1\n       [[\\<sim>]] tls2", "hence \"s2 -\\<tau>2-lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1)\\<rightarrow>* \\<infinity>\""], ["proof (prove)\nusing this:\n  s2 -\\<tau>2-tl1_to_tl2 s2 sstls1\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. s2 -\\<tau>2-lmap (fst \\<circ> snd \\<circ> snd)\n                 (tl1_to_tl2 s2 sstls1)\\<rightarrow>* \\<infinity>", "by(rule trsys2.\\<tau>inf_step_table_into_\\<tau>inf_step)"], ["proof (state)\nthis:\n  s2 -\\<tau>2-lmap (fst \\<circ> snd \\<circ> snd)\n               (tl1_to_tl2 s2 sstls1)\\<rightarrow>* \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>tls2.\n       s2 -\\<tau>2-tls2\\<rightarrow>* \\<infinity> \\<and> tls1\n       [[\\<sim>]] tls2", "moreover"], ["proof (state)\nthis:\n  s2 -\\<tau>2-lmap (fst \\<circ> snd \\<circ> snd)\n               (tl1_to_tl2 s2 sstls1)\\<rightarrow>* \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>tls2.\n       s2 -\\<tau>2-tls2\\<rightarrow>* \\<infinity> \\<and> tls1\n       [[\\<sim>]] tls2", "have \"tls1 [[\\<sim>]] lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tls1\n    [[\\<sim>]] lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1)", "proof(rule llist_all2_all_lnthI)"], ["proof (state)\ngoal (2 subgoals):\n 1. llength tls1 =\n    llength (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1))\n 2. \\<And>n.\n       enat n < llength tls1 \\<Longrightarrow>\n       lnth tls1 n\n       \\<sim> lnth\n               (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1)) n", "show \"llength tls1 = llength (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength tls1 =\n    llength (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1))", "using tls1"], ["proof (prove)\nusing this:\n  tls1 = lmap (fst \\<circ> snd \\<circ> snd) sstls1\n\ngoal (1 subgoal):\n 1. llength tls1 =\n    llength (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1))", "by simp"], ["proof (state)\nthis:\n  llength tls1 =\n  llength (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       enat n < llength tls1 \\<Longrightarrow>\n       lnth tls1 n\n       \\<sim> lnth\n               (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1)) n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       enat n < llength tls1 \\<Longrightarrow>\n       lnth tls1 n\n       \\<sim> lnth\n               (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1)) n", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       enat n < llength tls1 \\<Longrightarrow>\n       lnth tls1 n\n       \\<sim> lnth\n               (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1)) n", "assume \"enat n < llength tls1\""], ["proof (state)\nthis:\n  enat n < llength tls1\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       enat n < llength tls1 \\<Longrightarrow>\n       lnth tls1 n\n       \\<sim> lnth\n               (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1)) n", "thus \"lnth tls1 n \\<sim> lnth (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1)) n\""], ["proof (prove)\nusing this:\n  enat n < llength tls1\n\ngoal (1 subgoal):\n 1. lnth tls1 n\n    \\<sim> lnth (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1))\n            n", "using \\<tau>inf1' bisim"], ["proof (prove)\nusing this:\n  enat n < llength tls1\n  s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity>\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. lnth tls1 n\n    \\<sim> lnth (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1))\n            n", "unfolding tls1"], ["proof (prove)\nusing this:\n  enat n < llength (lmap (fst \\<circ> snd \\<circ> snd) sstls1)\n  s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity>\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n    \\<sim> lnth (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1))\n            n", "proof(induct n arbitrary: s1 s2 sstls1 rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x s1 s2 sstls1.\n       \\<lbrakk>\\<And>y s1 s2 sstls1.\n                   \\<lbrakk>y < x;\n                    enat y\n                    < llength (lmap (fst \\<circ> snd \\<circ> snd) sstls1);\n                    s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity>;\n                    s1 \\<approx> s2\\<rbrakk>\n                   \\<Longrightarrow> lnth\n(lmap (fst \\<circ> snd \\<circ> snd) sstls1) y\n                                     \\<sim> lnth\n       (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1)) y;\n        enat x < llength (lmap (fst \\<circ> snd \\<circ> snd) sstls1);\n        s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity>;\n        s1 \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) x\n                         \\<sim> lnth\n                                 (lmap (fst \\<circ> snd \\<circ> snd)\n                                   (tl1_to_tl2 s2 sstls1))\n                                 x", "case (less n)"], ["proof (state)\nthis:\n  \\<lbrakk>?y < n;\n   enat ?y < llength (lmap (fst \\<circ> snd \\<circ> snd) ?sstls1.0);\n   ?s1.0 -\\<tau>1-?sstls1.0\\<rightarrow>*t \\<infinity>;\n   ?s1.0 \\<approx> ?s2.0\\<rbrakk>\n  \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) ?sstls1.0) ?y\n                    \\<sim> lnth\n                            (lmap (fst \\<circ> snd \\<circ> snd)\n                              (tl1_to_tl2 ?s2.0 ?sstls1.0))\n                            ?y\n  enat n < llength (lmap (fst \\<circ> snd \\<circ> snd) sstls1)\n  s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity>\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. \\<And>x s1 s2 sstls1.\n       \\<lbrakk>\\<And>y s1 s2 sstls1.\n                   \\<lbrakk>y < x;\n                    enat y\n                    < llength (lmap (fst \\<circ> snd \\<circ> snd) sstls1);\n                    s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity>;\n                    s1 \\<approx> s2\\<rbrakk>\n                   \\<Longrightarrow> lnth\n(lmap (fst \\<circ> snd \\<circ> snd) sstls1) y\n                                     \\<sim> lnth\n       (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1)) y;\n        enat x < llength (lmap (fst \\<circ> snd \\<circ> snd) sstls1);\n        s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity>;\n        s1 \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) x\n                         \\<sim> lnth\n                                 (lmap (fst \\<circ> snd \\<circ> snd)\n                                   (tl1_to_tl2 s2 sstls1))\n                                 x", "note IH = \\<open>\\<And>m s1 s2 sstls1. \\<lbrakk> m < n; enat m < llength (lmap (fst \\<circ> snd \\<circ> snd) sstls1);\n                                   s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity>; s1 \\<approx> s2 \\<rbrakk>\n                 \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) m \\<sim> lnth (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1)) m\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?m < n;\n   enat ?m < llength (lmap (fst \\<circ> snd \\<circ> snd) ?sstls1.0);\n   ?s1.0 -\\<tau>1-?sstls1.0\\<rightarrow>*t \\<infinity>;\n   ?s1.0 \\<approx> ?s2.0\\<rbrakk>\n  \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) ?sstls1.0) ?m\n                    \\<sim> lnth\n                            (lmap (fst \\<circ> snd \\<circ> snd)\n                              (tl1_to_tl2 ?s2.0 ?sstls1.0))\n                            ?m\n\ngoal (1 subgoal):\n 1. \\<And>x s1 s2 sstls1.\n       \\<lbrakk>\\<And>y s1 s2 sstls1.\n                   \\<lbrakk>y < x;\n                    enat y\n                    < llength (lmap (fst \\<circ> snd \\<circ> snd) sstls1);\n                    s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity>;\n                    s1 \\<approx> s2\\<rbrakk>\n                   \\<Longrightarrow> lnth\n(lmap (fst \\<circ> snd \\<circ> snd) sstls1) y\n                                     \\<sim> lnth\n       (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1)) y;\n        enat x < llength (lmap (fst \\<circ> snd \\<circ> snd) sstls1);\n        s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity>;\n        s1 \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) x\n                         \\<sim> lnth\n                                 (lmap (fst \\<circ> snd \\<circ> snd)\n                                   (tl1_to_tl2 s2 sstls1))\n                                 x", "from \\<open>s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity>\\<close>"], ["proof (chain)\npicking this:\n  s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity>", "show ?case"], ["proof (prove)\nusing this:\n  s1 -\\<tau>1-sstls1\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n    \\<sim> lnth (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1))\n            n", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>sstls1 = LCons (s1, s', tl, s'') tls;\n        s1 -\\<tau>1\\<rightarrow>* s'; s' -1-tl\\<rightarrow> s'';\n        \\<not> \\<tau>move1 s' tl s'';\n        s'' -\\<tau>1-tls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n                         \\<sim> lnth\n                                 (lmap (fst \\<circ> snd \\<circ> snd)\n                                   (tl1_to_tl2 s2 sstls1))\n                                 n\n 2. \\<lbrakk>sstls1 = LNil; s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n                      \\<sim> lnth\n                              (lmap (fst \\<circ> snd \\<circ> snd)\n                                (tl1_to_tl2 s2 sstls1))\n                              n", "case (\\<tau>inf_step_table_Cons s1' s1'' sstls1' tl1)"], ["proof (state)\nthis:\n  sstls1 = LCons (s1, s1', tl1, s1'') sstls1'\n  s1 -\\<tau>1\\<rightarrow>* s1'\n  s1' -1-tl1\\<rightarrow> s1''\n  \\<not> \\<tau>move1 s1' tl1 s1''\n  s1'' -\\<tau>1-sstls1'\\<rightarrow>*t \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>sstls1 = LCons (s1, s', tl, s'') tls;\n        s1 -\\<tau>1\\<rightarrow>* s'; s' -1-tl\\<rightarrow> s'';\n        \\<not> \\<tau>move1 s' tl s'';\n        s'' -\\<tau>1-tls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n                         \\<sim> lnth\n                                 (lmap (fst \\<circ> snd \\<circ> snd)\n                                   (tl1_to_tl2 s2 sstls1))\n                                 n\n 2. \\<lbrakk>sstls1 = LNil; s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n                      \\<sim> lnth\n                              (lmap (fst \\<circ> snd \\<circ> snd)\n                                (tl1_to_tl2 s2 sstls1))\n                              n", "hence sstls1: \"sstls1 = LCons (s1, s1', tl1, s1'') sstls1'\"\n          and \\<tau>s: \"s1 -\\<tau>1\\<rightarrow>* s1'\" and r: \"s1' -1-tl1\\<rightarrow> s1''\"\n          and n\\<tau>: \"\\<not> \\<tau>move1 s1' tl1 s1''\" and reds: \"s1'' -\\<tau>1-sstls1'\\<rightarrow>*t \\<infinity>\""], ["proof (prove)\nusing this:\n  sstls1 = LCons (s1, s1', tl1, s1'') sstls1'\n  s1 -\\<tau>1\\<rightarrow>* s1'\n  s1' -1-tl1\\<rightarrow> s1''\n  \\<not> \\<tau>move1 s1' tl1 s1''\n  s1'' -\\<tau>1-sstls1'\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. (sstls1 = LCons (s1, s1', tl1, s1'') sstls1' &&&\n     s1 -\\<tau>1\\<rightarrow>* s1') &&&\n    s1' -1-tl1\\<rightarrow> s1'' &&&\n    \\<not> \\<tau>move1 s1' tl1 s1'' &&&\n    s1'' -\\<tau>1-sstls1'\\<rightarrow>*t \\<infinity>", "by simp_all"], ["proof (state)\nthis:\n  sstls1 = LCons (s1, s1', tl1, s1'') sstls1'\n  s1 -\\<tau>1\\<rightarrow>* s1'\n  s1' -1-tl1\\<rightarrow> s1''\n  \\<not> \\<tau>move1 s1' tl1 s1''\n  s1'' -\\<tau>1-sstls1'\\<rightarrow>*t \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>sstls1 = LCons (s1, s', tl, s'') tls;\n        s1 -\\<tau>1\\<rightarrow>* s'; s' -1-tl\\<rightarrow> s'';\n        \\<not> \\<tau>move1 s' tl s'';\n        s'' -\\<tau>1-tls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n                         \\<sim> lnth\n                                 (lmap (fst \\<circ> snd \\<circ> snd)\n                                   (tl1_to_tl2 s2 sstls1))\n                                 n\n 2. \\<lbrakk>sstls1 = LNil; s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n                      \\<sim> lnth\n                              (lmap (fst \\<circ> snd \\<circ> snd)\n                                (tl1_to_tl2 s2 sstls1))\n                              n", "let ?P = \"\\<lambda>(s2', tl2, s2''). s2 -\\<tau>2\\<rightarrow>* s2' \\<and> trsys2 s2' tl2 s2'' \\<and> \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>  s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>sstls1 = LCons (s1, s', tl, s'') tls;\n        s1 -\\<tau>1\\<rightarrow>* s'; s' -1-tl\\<rightarrow> s'';\n        \\<not> \\<tau>move1 s' tl s'';\n        s'' -\\<tau>1-tls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n                         \\<sim> lnth\n                                 (lmap (fst \\<circ> snd \\<circ> snd)\n                                   (tl1_to_tl2 s2 sstls1))\n                                 n\n 2. \\<lbrakk>sstls1 = LNil; s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n                      \\<sim> lnth\n                              (lmap (fst \\<circ> snd \\<circ> snd)\n                                (tl1_to_tl2 s2 sstls1))\n                              n", "let ?s2tl2s2' = \"Eps ?P\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>sstls1 = LCons (s1, s', tl, s'') tls;\n        s1 -\\<tau>1\\<rightarrow>* s'; s' -1-tl\\<rightarrow> s'';\n        \\<not> \\<tau>move1 s' tl s'';\n        s'' -\\<tau>1-tls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n                         \\<sim> lnth\n                                 (lmap (fst \\<circ> snd \\<circ> snd)\n                                   (tl1_to_tl2 s2 sstls1))\n                                 n\n 2. \\<lbrakk>sstls1 = LNil; s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n                      \\<sim> lnth\n                              (lmap (fst \\<circ> snd \\<circ> snd)\n                                (tl1_to_tl2 s2 sstls1))\n                              n", "let ?tl2 = \"fst (snd ?s2tl2s2')\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>sstls1 = LCons (s1, s', tl, s'') tls;\n        s1 -\\<tau>1\\<rightarrow>* s'; s' -1-tl\\<rightarrow> s'';\n        \\<not> \\<tau>move1 s' tl s'';\n        s'' -\\<tau>1-tls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n                         \\<sim> lnth\n                                 (lmap (fst \\<circ> snd \\<circ> snd)\n                                   (tl1_to_tl2 s2 sstls1))\n                                 n\n 2. \\<lbrakk>sstls1 = LNil; s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n                      \\<sim> lnth\n                              (lmap (fst \\<circ> snd \\<circ> snd)\n                                (tl1_to_tl2 s2 sstls1))\n                              n", "let ?s2'' = \"snd (snd ?s2tl2s2')\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>sstls1 = LCons (s1, s', tl, s'') tls;\n        s1 -\\<tau>1\\<rightarrow>* s'; s' -1-tl\\<rightarrow> s'';\n        \\<not> \\<tau>move1 s' tl s'';\n        s'' -\\<tau>1-tls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n                         \\<sim> lnth\n                                 (lmap (fst \\<circ> snd \\<circ> snd)\n                                   (tl1_to_tl2 s2 sstls1))\n                                 n\n 2. \\<lbrakk>sstls1 = LNil; s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n                      \\<sim> lnth\n                              (lmap (fst \\<circ> snd \\<circ> snd)\n                                (tl1_to_tl2 s2 sstls1))\n                              n", "from simulation_silents1[OF \\<open>s1 \\<approx> s2\\<close> \\<tau>s]"], ["proof (chain)\npicking this:\n  \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2'", "obtain s2'\n          where \"s2 -\\<tau>2\\<rightarrow>* s2'\" \"s1' \\<approx> s2'\""], ["proof (prove)\nusing this:\n  \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2'\n\ngoal (1 subgoal):\n 1. (\\<And>s2'.\n        \\<lbrakk>s2 -\\<tau>2\\<rightarrow>* s2'; s1' \\<approx> s2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  s1' \\<approx> s2'\n\ngoal (2 subgoals):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>sstls1 = LCons (s1, s', tl, s'') tls;\n        s1 -\\<tau>1\\<rightarrow>* s'; s' -1-tl\\<rightarrow> s'';\n        \\<not> \\<tau>move1 s' tl s'';\n        s'' -\\<tau>1-tls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n                         \\<sim> lnth\n                                 (lmap (fst \\<circ> snd \\<circ> snd)\n                                   (tl1_to_tl2 s2 sstls1))\n                                 n\n 2. \\<lbrakk>sstls1 = LNil; s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n                      \\<sim> lnth\n                              (lmap (fst \\<circ> snd \\<circ> snd)\n                                (tl1_to_tl2 s2 sstls1))\n                              n", "from simulation1[OF \\<open>s1' \\<approx> s2'\\<close> r n\\<tau>]"], ["proof (chain)\npicking this:\n  \\<exists>s2'a s2'' tl2.\n     s2' -\\<tau>2\\<rightarrow>* s2'a \\<and>\n     s2'a -2-tl2\\<rightarrow> s2'' \\<and>\n     \\<not> \\<tau>move2 s2'a tl2 s2'' \\<and>\n     s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2", "obtain s2'' s2''' tl2\n          where \"s2' -\\<tau>2\\<rightarrow>* s2''\"\n          and rest: \"s2'' -2-tl2\\<rightarrow> s2'''\" \"\\<not> \\<tau>move2 s2'' tl2 s2'''\" \"s1'' \\<approx> s2'''\" \"tl1 \\<sim> tl2\""], ["proof (prove)\nusing this:\n  \\<exists>s2'a s2'' tl2.\n     s2' -\\<tau>2\\<rightarrow>* s2'a \\<and>\n     s2'a -2-tl2\\<rightarrow> s2'' \\<and>\n     \\<not> \\<tau>move2 s2'a tl2 s2'' \\<and>\n     s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. (\\<And>s2'' tl2 s2'''.\n        \\<lbrakk>s2' -\\<tau>2\\<rightarrow>* s2'';\n         s2'' -2-tl2\\<rightarrow> s2'''; \\<not> \\<tau>move2 s2'' tl2 s2''';\n         s1'' \\<approx> s2'''; tl1 \\<sim> tl2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s2' -\\<tau>2\\<rightarrow>* s2''\n  s2'' -2-tl2\\<rightarrow> s2'''\n  \\<not> \\<tau>move2 s2'' tl2 s2'''\n  s1'' \\<approx> s2'''\n  tl1 \\<sim> tl2\n\ngoal (2 subgoals):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>sstls1 = LCons (s1, s', tl, s'') tls;\n        s1 -\\<tau>1\\<rightarrow>* s'; s' -1-tl\\<rightarrow> s'';\n        \\<not> \\<tau>move1 s' tl s'';\n        s'' -\\<tau>1-tls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n                         \\<sim> lnth\n                                 (lmap (fst \\<circ> snd \\<circ> snd)\n                                   (tl1_to_tl2 s2 sstls1))\n                                 n\n 2. \\<lbrakk>sstls1 = LNil; s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n                      \\<sim> lnth\n                              (lmap (fst \\<circ> snd \\<circ> snd)\n                                (tl1_to_tl2 s2 sstls1))\n                              n", "from \\<open>s2 -\\<tau>2\\<rightarrow>* s2'\\<close> \\<open>s2' -\\<tau>2\\<rightarrow>* s2''\\<close>"], ["proof (chain)\npicking this:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  s2' -\\<tau>2\\<rightarrow>* s2''", "have \"s2 -\\<tau>2\\<rightarrow>* s2''\""], ["proof (prove)\nusing this:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  s2' -\\<tau>2\\<rightarrow>* s2''\n\ngoal (1 subgoal):\n 1. s2 -\\<tau>2\\<rightarrow>* s2''", "by(rule rtranclp_trans)"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow>* s2''\n\ngoal (2 subgoals):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>sstls1 = LCons (s1, s', tl, s'') tls;\n        s1 -\\<tau>1\\<rightarrow>* s'; s' -1-tl\\<rightarrow> s'';\n        \\<not> \\<tau>move1 s' tl s'';\n        s'' -\\<tau>1-tls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n                         \\<sim> lnth\n                                 (lmap (fst \\<circ> snd \\<circ> snd)\n                                   (tl1_to_tl2 s2 sstls1))\n                                 n\n 2. \\<lbrakk>sstls1 = LNil; s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n                      \\<sim> lnth\n                              (lmap (fst \\<circ> snd \\<circ> snd)\n                                (tl1_to_tl2 s2 sstls1))\n                              n", "with rest"], ["proof (chain)\npicking this:\n  s2'' -2-tl2\\<rightarrow> s2'''\n  \\<not> \\<tau>move2 s2'' tl2 s2'''\n  s1'' \\<approx> s2'''\n  tl1 \\<sim> tl2\n  s2 -\\<tau>2\\<rightarrow>* s2''", "have \"?P (s2'', tl2, s2''')\""], ["proof (prove)\nusing this:\n  s2'' -2-tl2\\<rightarrow> s2'''\n  \\<not> \\<tau>move2 s2'' tl2 s2'''\n  s1'' \\<approx> s2'''\n  tl1 \\<sim> tl2\n  s2 -\\<tau>2\\<rightarrow>* s2''\n\ngoal (1 subgoal):\n 1. case (s2'', tl2, s2''') of\n    (s2', tl2, s2'') \\<Rightarrow>\n      s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n      s2' -2-tl2\\<rightarrow> s2'' \\<and>\n      \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n      s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2", "by auto"], ["proof (state)\nthis:\n  case (s2'', tl2, s2''') of\n  (s2', tl2, s2'') \\<Rightarrow>\n    s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n    s2' -2-tl2\\<rightarrow> s2'' \\<and>\n    \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n    s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n\ngoal (2 subgoals):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>sstls1 = LCons (s1, s', tl, s'') tls;\n        s1 -\\<tau>1\\<rightarrow>* s'; s' -1-tl\\<rightarrow> s'';\n        \\<not> \\<tau>move1 s' tl s'';\n        s'' -\\<tau>1-tls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n                         \\<sim> lnth\n                                 (lmap (fst \\<circ> snd \\<circ> snd)\n                                   (tl1_to_tl2 s2 sstls1))\n                                 n\n 2. \\<lbrakk>sstls1 = LNil; s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n                      \\<sim> lnth\n                              (lmap (fst \\<circ> snd \\<circ> snd)\n                                (tl1_to_tl2 s2 sstls1))\n                              n", "hence \"?P ?s2tl2s2'\""], ["proof (prove)\nusing this:\n  case (s2'', tl2, s2''') of\n  (s2', tl2, s2'') \\<Rightarrow>\n    s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n    s2' -2-tl2\\<rightarrow> s2'' \\<and>\n    \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n    s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. case SOME (s2', tl2, s2'').\n            s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n            s2' -2-tl2\\<rightarrow> s2'' \\<and>\n            \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n            s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2 of\n    (s2', tl2, s2'') \\<Rightarrow>\n      s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n      s2' -2-tl2\\<rightarrow> s2'' \\<and>\n      \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n      s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2", "by(rule someI)"], ["proof (state)\nthis:\n  case SOME (s2', tl2, s2'').\n          s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n          s2' -2-tl2\\<rightarrow> s2'' \\<and>\n          \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n          s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2 of\n  (s2', tl2, s2'') \\<Rightarrow>\n    s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n    s2' -2-tl2\\<rightarrow> s2'' \\<and>\n    \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n    s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n\ngoal (2 subgoals):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>sstls1 = LCons (s1, s', tl, s'') tls;\n        s1 -\\<tau>1\\<rightarrow>* s'; s' -1-tl\\<rightarrow> s'';\n        \\<not> \\<tau>move1 s' tl s'';\n        s'' -\\<tau>1-tls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n                         \\<sim> lnth\n                                 (lmap (fst \\<circ> snd \\<circ> snd)\n                                   (tl1_to_tl2 s2 sstls1))\n                                 n\n 2. \\<lbrakk>sstls1 = LNil; s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n                      \\<sim> lnth\n                              (lmap (fst \\<circ> snd \\<circ> snd)\n                                (tl1_to_tl2 s2 sstls1))\n                              n", "hence \"s1'' \\<approx> ?s2''\" \"tl1 \\<sim> ?tl2\""], ["proof (prove)\nusing this:\n  case SOME (s2', tl2, s2'').\n          s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n          s2' -2-tl2\\<rightarrow> s2'' \\<and>\n          \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n          s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2 of\n  (s2', tl2, s2'') \\<Rightarrow>\n    s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n    s2' -2-tl2\\<rightarrow> s2'' \\<and>\n    \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n    s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. s1''\n    \\<approx> snd (snd (SOME (s2', tl2, s2'').\n                           s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                           s2' -2-tl2\\<rightarrow> s2'' \\<and>\n                           \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n                           s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2)) &&&\n    tl1\n    \\<sim> fst (snd (SOME (s2', tl2, s2'').\n                        s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                        s2' -2-tl2\\<rightarrow> s2'' \\<and>\n                        \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n                        s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2))", "by(simp_all add: split_beta)"], ["proof (state)\nthis:\n  s1''\n  \\<approx> snd (snd (SOME (s2', tl2, s2'').\n                         s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                         s2' -2-tl2\\<rightarrow> s2'' \\<and>\n                         \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n                         s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2))\n  tl1\n  \\<sim> fst (snd (SOME (s2', tl2, s2'').\n                      s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                      s2' -2-tl2\\<rightarrow> s2'' \\<and>\n                      \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n                      s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2))\n\ngoal (2 subgoals):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>sstls1 = LCons (s1, s', tl, s'') tls;\n        s1 -\\<tau>1\\<rightarrow>* s'; s' -1-tl\\<rightarrow> s'';\n        \\<not> \\<tau>move1 s' tl s'';\n        s'' -\\<tau>1-tls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n                         \\<sim> lnth\n                                 (lmap (fst \\<circ> snd \\<circ> snd)\n                                   (tl1_to_tl2 s2 sstls1))\n                                 n\n 2. \\<lbrakk>sstls1 = LNil; s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n                      \\<sim> lnth\n                              (lmap (fst \\<circ> snd \\<circ> snd)\n                                (tl1_to_tl2 s2 sstls1))\n                              n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n    \\<sim> lnth (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1))\n            n", "proof(cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n    \\<sim> lnth (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1))\n            n\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n       \\<sim> lnth\n               (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1)) n", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n    \\<sim> lnth (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1))\n            n\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n       \\<sim> lnth\n               (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1)) n", "with sstls1 \\<open>tl1 \\<sim> ?tl2\\<close>"], ["proof (chain)\npicking this:\n  sstls1 = LCons (s1, s1', tl1, s1'') sstls1'\n  tl1\n  \\<sim> fst (snd (SOME (s2', tl2, s2'').\n                      s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                      s2' -2-tl2\\<rightarrow> s2'' \\<and>\n                      \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n                      s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2))\n  n = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  sstls1 = LCons (s1, s1', tl1, s1'') sstls1'\n  tl1\n  \\<sim> fst (snd (SOME (s2', tl2, s2'').\n                      s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                      s2' -2-tl2\\<rightarrow> s2'' \\<and>\n                      \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n                      s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2))\n  n = 0\n\ngoal (1 subgoal):\n 1. lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n    \\<sim> lnth (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1))\n            n", "by simp"], ["proof (state)\nthis:\n  lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n  \\<sim> lnth (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1)) n\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n       \\<sim> lnth\n               (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1)) n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n       \\<sim> lnth\n               (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1)) n", "case (Suc m)"], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n       \\<sim> lnth\n               (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1)) n", "hence \"m < n\""], ["proof (prove)\nusing this:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. m < n", "by simp"], ["proof (state)\nthis:\n  m < n\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n       \\<sim> lnth\n               (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1)) n", "moreover"], ["proof (state)\nthis:\n  m < n\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n       \\<sim> lnth\n               (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1)) n", "have \"enat m < llength (lmap (fst \\<circ> snd \\<circ> snd) sstls1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat m < llength (lmap (fst \\<circ> snd \\<circ> snd) sstls1')", "using sstls1 \\<open>enat n < llength (lmap (fst \\<circ> snd \\<circ> snd) sstls1)\\<close> Suc"], ["proof (prove)\nusing this:\n  sstls1 = LCons (s1, s1', tl1, s1'') sstls1'\n  enat n < llength (lmap (fst \\<circ> snd \\<circ> snd) sstls1)\n  n = Suc m\n\ngoal (1 subgoal):\n 1. enat m < llength (lmap (fst \\<circ> snd \\<circ> snd) sstls1')", "by(simp add: Suc_ile_eq)"], ["proof (state)\nthis:\n  enat m < llength (lmap (fst \\<circ> snd \\<circ> snd) sstls1')\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n       \\<sim> lnth\n               (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1)) n", "ultimately"], ["proof (chain)\npicking this:\n  m < n\n  enat m < llength (lmap (fst \\<circ> snd \\<circ> snd) sstls1')", "have \"lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1') m \\<sim> lnth (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 ?s2'' sstls1')) m\""], ["proof (prove)\nusing this:\n  m < n\n  enat m < llength (lmap (fst \\<circ> snd \\<circ> snd) sstls1')\n\ngoal (1 subgoal):\n 1. lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1') m\n    \\<sim> lnth\n            (lmap (fst \\<circ> snd \\<circ> snd)\n              (tl1_to_tl2\n                (snd (snd (SOME (s2', tl2, s2'').\n                              s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                              s2' -2-tl2\\<rightarrow> s2'' \\<and>\n                              \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n                              s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2)))\n                sstls1'))\n            m", "using reds \\<open>s1'' \\<approx> ?s2''\\<close>"], ["proof (prove)\nusing this:\n  m < n\n  enat m < llength (lmap (fst \\<circ> snd \\<circ> snd) sstls1')\n  s1'' -\\<tau>1-sstls1'\\<rightarrow>*t \\<infinity>\n  s1''\n  \\<approx> snd (snd (SOME (s2', tl2, s2'').\n                         s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                         s2' -2-tl2\\<rightarrow> s2'' \\<and>\n                         \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n                         s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2))\n\ngoal (1 subgoal):\n 1. lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1') m\n    \\<sim> lnth\n            (lmap (fst \\<circ> snd \\<circ> snd)\n              (tl1_to_tl2\n                (snd (snd (SOME (s2', tl2, s2'').\n                              s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                              s2' -2-tl2\\<rightarrow> s2'' \\<and>\n                              \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n                              s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2)))\n                sstls1'))\n            m", "by(rule IH)"], ["proof (state)\nthis:\n  lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1') m\n  \\<sim> lnth\n          (lmap (fst \\<circ> snd \\<circ> snd)\n            (tl1_to_tl2\n              (snd (snd (SOME (s2', tl2, s2'').\n                            s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                            s2' -2-tl2\\<rightarrow> s2'' \\<and>\n                            \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n                            s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2)))\n              sstls1'))\n          m\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n       \\<sim> lnth\n               (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1)) n", "with Suc sstls1"], ["proof (chain)\npicking this:\n  n = Suc m\n  sstls1 = LCons (s1, s1', tl1, s1'') sstls1'\n  lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1') m\n  \\<sim> lnth\n          (lmap (fst \\<circ> snd \\<circ> snd)\n            (tl1_to_tl2\n              (snd (snd (SOME (s2', tl2, s2'').\n                            s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                            s2' -2-tl2\\<rightarrow> s2'' \\<and>\n                            \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n                            s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2)))\n              sstls1'))\n          m", "show ?thesis"], ["proof (prove)\nusing this:\n  n = Suc m\n  sstls1 = LCons (s1, s1', tl1, s1'') sstls1'\n  lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1') m\n  \\<sim> lnth\n          (lmap (fst \\<circ> snd \\<circ> snd)\n            (tl1_to_tl2\n              (snd (snd (SOME (s2', tl2, s2'').\n                            s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                            s2' -2-tl2\\<rightarrow> s2'' \\<and>\n                            \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n                            s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2)))\n              sstls1'))\n          m\n\ngoal (1 subgoal):\n 1. lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n    \\<sim> lnth (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1))\n            n", "by(simp del: o_apply)"], ["proof (state)\nthis:\n  lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n  \\<sim> lnth (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1)) n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n  \\<sim> lnth (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1)) n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sstls1 = LNil; s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n                      \\<sim> lnth\n                              (lmap (fst \\<circ> snd \\<circ> snd)\n                                (tl1_to_tl2 s2 sstls1))\n                              n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>sstls1 = LNil; s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n                      \\<sim> lnth\n                              (lmap (fst \\<circ> snd \\<circ> snd)\n                                (tl1_to_tl2 s2 sstls1))\n                              n", "case \\<tau>inf_step_table_Nil"], ["proof (state)\nthis:\n  sstls1 = LNil\n  s1 -\\<tau>1\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sstls1 = LNil; s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n                      \\<sim> lnth\n                              (lmap (fst \\<circ> snd \\<circ> snd)\n                                (tl1_to_tl2 s2 sstls1))\n                              n", "with \\<open>enat n < llength (lmap (fst \\<circ> snd \\<circ> snd) sstls1)\\<close>"], ["proof (chain)\npicking this:\n  enat n < llength (lmap (fst \\<circ> snd \\<circ> snd) sstls1)\n  sstls1 = LNil\n  s1 -\\<tau>1\\<rightarrow> \\<infinity>", "have False"], ["proof (prove)\nusing this:\n  enat n < llength (lmap (fst \\<circ> snd \\<circ> snd) sstls1)\n  sstls1 = LNil\n  s1 -\\<tau>1\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sstls1 = LNil; s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n                      \\<sim> lnth\n                              (lmap (fst \\<circ> snd \\<circ> snd)\n                                (tl1_to_tl2 s2 sstls1))\n                              n", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n    \\<sim> lnth (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1))\n            n", ".."], ["proof (state)\nthis:\n  lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n  \\<sim> lnth (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1)) n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lnth (lmap (fst \\<circ> snd \\<circ> snd) sstls1) n\n  \\<sim> lnth (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1)) n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lnth tls1 n\n  \\<sim> lnth (lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1)) n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  tls1 [[\\<sim>]] lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1)\n\ngoal (1 subgoal):\n 1. \\<exists>tls2.\n       s2 -\\<tau>2-tls2\\<rightarrow>* \\<infinity> \\<and> tls1\n       [[\\<sim>]] tls2", "ultimately"], ["proof (chain)\npicking this:\n  s2 -\\<tau>2-lmap (fst \\<circ> snd \\<circ> snd)\n               (tl1_to_tl2 s2 sstls1)\\<rightarrow>* \\<infinity>\n  tls1 [[\\<sim>]] lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1)", "show ?thesis"], ["proof (prove)\nusing this:\n  s2 -\\<tau>2-lmap (fst \\<circ> snd \\<circ> snd)\n               (tl1_to_tl2 s2 sstls1)\\<rightarrow>* \\<infinity>\n  tls1 [[\\<sim>]] lmap (fst \\<circ> snd \\<circ> snd) (tl1_to_tl2 s2 sstls1)\n\ngoal (1 subgoal):\n 1. \\<exists>tls2.\n       s2 -\\<tau>2-tls2\\<rightarrow>* \\<infinity> \\<and> tls1\n       [[\\<sim>]] tls2", "by blast"], ["proof (state)\nthis:\n  \\<exists>tls2.\n     s2 -\\<tau>2-tls2\\<rightarrow>* \\<infinity> \\<and> tls1 [[\\<sim>]] tls2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma simulation2_\\<tau>inf_step:\n  \"\\<lbrakk> s2 -\\<tau>2-tls2\\<rightarrow>* \\<infinity>; s1 \\<approx> s2 \\<rbrakk> \\<Longrightarrow> \\<exists>tls1. s1 -\\<tau>1-tls1\\<rightarrow>* \\<infinity> \\<and> tls1 [[\\<sim>]] tls2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s2 -\\<tau>2-tls2\\<rightarrow>* \\<infinity>;\n     s1 \\<approx> s2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tls1.\n                         s1 -\\<tau>1-tls1\\<rightarrow>* \\<infinity> \\<and>\n                         tls1 [[\\<sim>]] tls2", "using delay_bisimulation_diverge.simulation1_\\<tau>inf_step[OF delay_bisimulation_diverge_flip]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s1.0 -\\<tau>2-?tls1.0\\<rightarrow>* \\<infinity>;\n   flip bisim ?s1.0 ?s2.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tls2.\n                       ?s2.0 -\\<tau>1-tls2\\<rightarrow>* \\<infinity> \\<and>\n                       llist_all2 (flip tlsim) ?tls1.0 tls2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s2 -\\<tau>2-tls2\\<rightarrow>* \\<infinity>;\n     s1 \\<approx> s2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tls1.\n                         s1 -\\<tau>1-tls1\\<rightarrow>* \\<infinity> \\<and>\n                         tls1 [[\\<sim>]] tls2", "unfolding flip_simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s1.0 -\\<tau>2-?tls1.0\\<rightarrow>* \\<infinity>;\n   ?s2.0 \\<approx> ?s1.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tls2.\n                       ?s2.0 -\\<tau>1-tls2\\<rightarrow>* \\<infinity> \\<and>\n                       tls2 [[\\<sim>]] ?tls1.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s2 -\\<tau>2-tls2\\<rightarrow>* \\<infinity>;\n     s1 \\<approx> s2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tls1.\n                         s1 -\\<tau>1-tls1\\<rightarrow>* \\<infinity> \\<and>\n                         tls1 [[\\<sim>]] tls2", "."], ["", "lemma no_\\<tau>move1_\\<tau>s_to_no_\\<tau>move2:\n  assumes \"s1 \\<approx> s2\"\n  and no_\\<tau>moves1: \"\\<And>s1'. \\<not> s1 -\\<tau>1\\<rightarrow> s1'\"\n  shows \"\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> (\\<forall>s2''. \\<not> s2' -\\<tau>2\\<rightarrow> s2'') \\<and> s1 \\<approx> s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n       (\\<forall>s2''. \\<not> s2' -\\<tau>2\\<rightarrow> s2'') \\<and> s1\n       \\<approx> s2'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n       (\\<forall>s2''. \\<not> s2' -\\<tau>2\\<rightarrow> s2'') \\<and> s1\n       \\<approx> s2'", "have \"\\<not> s1 -\\<tau>1\\<rightarrow> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> s1 -\\<tau>1\\<rightarrow> \\<infinity>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. s1 -\\<tau>1\\<rightarrow> \\<infinity> \\<Longrightarrow> False", "assume \"s1 -\\<tau>1\\<rightarrow> \\<infinity>\""], ["proof (state)\nthis:\n  s1 -\\<tau>1\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. s1 -\\<tau>1\\<rightarrow> \\<infinity> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  s1 -\\<tau>1\\<rightarrow> \\<infinity>", "obtain s1' where \"s1 -\\<tau>1\\<rightarrow> s1'\""], ["proof (prove)\nusing this:\n  s1 -\\<tau>1\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>s1'.\n        s1 -\\<tau>1\\<rightarrow> s1' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by cases"], ["proof (state)\nthis:\n  s1 -\\<tau>1\\<rightarrow> s1'\n\ngoal (1 subgoal):\n 1. s1 -\\<tau>1\\<rightarrow> \\<infinity> \\<Longrightarrow> False", "with no_\\<tau>moves1[of s1']"], ["proof (chain)\npicking this:\n  \\<not> s1 -\\<tau>1\\<rightarrow> s1'\n  s1 -\\<tau>1\\<rightarrow> s1'", "show False"], ["proof (prove)\nusing this:\n  \\<not> s1 -\\<tau>1\\<rightarrow> s1'\n  s1 -\\<tau>1\\<rightarrow> s1'\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> s1 -\\<tau>1\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n       (\\<forall>s2''. \\<not> s2' -\\<tau>2\\<rightarrow> s2'') \\<and> s1\n       \\<approx> s2'", "with \\<open>s1 \\<approx> s2\\<close>"], ["proof (chain)\npicking this:\n  s1 \\<approx> s2\n  \\<not> s1 -\\<tau>1\\<rightarrow> \\<infinity>", "have \"\\<not> s2 -\\<tau>2\\<rightarrow> \\<infinity>\""], ["proof (prove)\nusing this:\n  s1 \\<approx> s2\n  \\<not> s1 -\\<tau>1\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<not> s2 -\\<tau>2\\<rightarrow> \\<infinity>", "by(simp add: \\<tau>diverge_bisim_inv)"], ["proof (state)\nthis:\n  \\<not> s2 -\\<tau>2\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n       (\\<forall>s2''. \\<not> s2' -\\<tau>2\\<rightarrow> s2'') \\<and> s1\n       \\<approx> s2'", "from trsys2.not_\\<tau>diverge_to_no_\\<tau>move[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>s'.\n     s2 -\\<tau>2\\<rightarrow>* s' \\<and>\n     (\\<forall>s''. \\<not> s' -\\<tau>2\\<rightarrow> s'')", "obtain s2' where \"s2 -\\<tau>2\\<rightarrow>* s2'\" and \"\\<And>s2''. \\<not> s2' -\\<tau>2\\<rightarrow> s2''\""], ["proof (prove)\nusing this:\n  \\<exists>s'.\n     s2 -\\<tau>2\\<rightarrow>* s' \\<and>\n     (\\<forall>s''. \\<not> s' -\\<tau>2\\<rightarrow> s'')\n\ngoal (1 subgoal):\n 1. (\\<And>s2'.\n        \\<lbrakk>s2 -\\<tau>2\\<rightarrow>* s2';\n         \\<And>s2''. \\<not> s2' -\\<tau>2\\<rightarrow> s2''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  \\<not> s2' -\\<tau>2\\<rightarrow> ?s2''\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n       (\\<forall>s2''. \\<not> s2' -\\<tau>2\\<rightarrow> s2'') \\<and> s1\n       \\<approx> s2'", "moreover"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  \\<not> s2' -\\<tau>2\\<rightarrow> ?s2''\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n       (\\<forall>s2''. \\<not> s2' -\\<tau>2\\<rightarrow> s2'') \\<and> s1\n       \\<approx> s2'", "from simulation_silents2[OF \\<open>s1 \\<approx> s2\\<close> \\<open>s2 -\\<tau>2\\<rightarrow>* s2'\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>s1'. s1 -\\<tau>1\\<rightarrow>* s1' \\<and> s1' \\<approx> s2'", "obtain s1' where \"s1 -\\<tau>1\\<rightarrow>* s1'\" and \"s1' \\<approx> s2'\""], ["proof (prove)\nusing this:\n  \\<exists>s1'. s1 -\\<tau>1\\<rightarrow>* s1' \\<and> s1' \\<approx> s2'\n\ngoal (1 subgoal):\n 1. (\\<And>s1'.\n        \\<lbrakk>s1 -\\<tau>1\\<rightarrow>* s1'; s1' \\<approx> s2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s1 -\\<tau>1\\<rightarrow>* s1'\n  s1' \\<approx> s2'\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n       (\\<forall>s2''. \\<not> s2' -\\<tau>2\\<rightarrow> s2'') \\<and> s1\n       \\<approx> s2'", "from \\<open>s1 -\\<tau>1\\<rightarrow>* s1'\\<close> no_\\<tau>moves1"], ["proof (chain)\npicking this:\n  s1 -\\<tau>1\\<rightarrow>* s1'\n  \\<not> s1 -\\<tau>1\\<rightarrow> ?s1'", "have \"s1' = s1\""], ["proof (prove)\nusing this:\n  s1 -\\<tau>1\\<rightarrow>* s1'\n  \\<not> s1 -\\<tau>1\\<rightarrow> ?s1'\n\ngoal (1 subgoal):\n 1. s1' = s1", "by(auto elim: converse_rtranclpE)"], ["proof (state)\nthis:\n  s1' = s1\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n       (\\<forall>s2''. \\<not> s2' -\\<tau>2\\<rightarrow> s2'') \\<and> s1\n       \\<approx> s2'", "ultimately"], ["proof (chain)\npicking this:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  \\<not> s2' -\\<tau>2\\<rightarrow> ?s2''\n  s1' = s1", "show ?thesis"], ["proof (prove)\nusing this:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  \\<not> s2' -\\<tau>2\\<rightarrow> ?s2''\n  s1' = s1\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n       (\\<forall>s2''. \\<not> s2' -\\<tau>2\\<rightarrow> s2'') \\<and> s1\n       \\<approx> s2'", "using \\<open>s1' \\<approx> s2'\\<close>"], ["proof (prove)\nusing this:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  \\<not> s2' -\\<tau>2\\<rightarrow> ?s2''\n  s1' = s1\n  s1' \\<approx> s2'\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n       (\\<forall>s2''. \\<not> s2' -\\<tau>2\\<rightarrow> s2'') \\<and> s1\n       \\<approx> s2'", "by blast"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n     (\\<forall>s2''. \\<not> s2' -\\<tau>2\\<rightarrow> s2'') \\<and> s1\n     \\<approx> s2'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma no_\\<tau>move2_\\<tau>s_to_no_\\<tau>move1:\n  \"\\<lbrakk> s1 \\<approx> s2; \\<And>s2'. \\<not> s2 -\\<tau>2\\<rightarrow> s2' \\<rbrakk> \\<Longrightarrow> \\<exists>s1'. s1 -\\<tau>1\\<rightarrow>* s1' \\<and> (\\<forall>s1''. \\<not> s1' -\\<tau>1\\<rightarrow> s1'') \\<and> s1' \\<approx> s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx> s2;\n     \\<And>s2'. \\<not> s2 -\\<tau>2\\<rightarrow> s2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s1'.\n                         s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                         (\\<forall>s1''. \\<not> s1'\n                             -\\<tau>1\\<rightarrow> s1'') \\<and>\n                         s1' \\<approx> s2", "using delay_bisimulation_diverge.no_\\<tau>move1_\\<tau>s_to_no_\\<tau>move2[OF delay_bisimulation_diverge_flip]"], ["proof (prove)\nusing this:\n  \\<lbrakk>flip bisim ?s1.0 ?s2.0;\n   \\<And>s1'. \\<not> ?s1.0 -\\<tau>2\\<rightarrow> s1'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s2'.\n                       ?s2.0 -\\<tau>1\\<rightarrow>* s2' \\<and>\n                       (\\<forall>s2''. \\<not> s2'\n                           -\\<tau>1\\<rightarrow> s2'') \\<and>\n                       flip bisim ?s1.0 s2'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx> s2;\n     \\<And>s2'. \\<not> s2 -\\<tau>2\\<rightarrow> s2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s1'.\n                         s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                         (\\<forall>s1''. \\<not> s1'\n                             -\\<tau>1\\<rightarrow> s1'') \\<and>\n                         s1' \\<approx> s2", "unfolding flip_simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s2.0 \\<approx> ?s1.0;\n   \\<And>s1'. \\<not> ?s1.0 -\\<tau>2\\<rightarrow> s1'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s2'.\n                       ?s2.0 -\\<tau>1\\<rightarrow>* s2' \\<and>\n                       (\\<forall>s2''. \\<not> s2'\n                           -\\<tau>1\\<rightarrow> s2'') \\<and>\n                       s2' \\<approx> ?s1.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx> s2;\n     \\<And>s2'. \\<not> s2 -\\<tau>2\\<rightarrow> s2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s1'.\n                         s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                         (\\<forall>s1''. \\<not> s1'\n                             -\\<tau>1\\<rightarrow> s1'') \\<and>\n                         s1' \\<approx> s2", "."], ["", "lemma no_move1_to_no_move2:\n  assumes \"s1 \\<approx> s2\"\n  and no_moves1: \"\\<And>tl1 s1'. \\<not> s1 -1-tl1\\<rightarrow> s1'\"\n  shows \"\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> (\\<forall>tl2 s2''. \\<not> s2' -2-tl2\\<rightarrow> s2'') \\<and> s1 \\<approx> s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n       (\\<forall>tl2 s2''. \\<not> s2' -2-tl2\\<rightarrow> s2'') \\<and> s1\n       \\<approx> s2'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n       (\\<forall>tl2 s2''. \\<not> s2' -2-tl2\\<rightarrow> s2'') \\<and> s1\n       \\<approx> s2'", "from no_moves1"], ["proof (chain)\npicking this:\n  \\<not> s1 -1-?tl1.0\\<rightarrow> ?s1'", "have \"\\<And>s1'. \\<not> s1 -\\<tau>1\\<rightarrow> s1'\""], ["proof (prove)\nusing this:\n  \\<not> s1 -1-?tl1.0\\<rightarrow> ?s1'\n\ngoal (1 subgoal):\n 1. \\<And>s1'. \\<not> s1 -\\<tau>1\\<rightarrow> s1'", "by(auto)"], ["proof (state)\nthis:\n  \\<not> s1 -\\<tau>1\\<rightarrow> ?s1'\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n       (\\<forall>tl2 s2''. \\<not> s2' -2-tl2\\<rightarrow> s2'') \\<and> s1\n       \\<approx> s2'", "from no_\\<tau>move1_\\<tau>s_to_no_\\<tau>move2[OF \\<open>s1 \\<approx> s2\\<close> this]"], ["proof (chain)\npicking this:\n  \\<exists>s2'.\n     s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n     (\\<forall>s2''. \\<not> s2' -\\<tau>2\\<rightarrow> s2'') \\<and> s1\n     \\<approx> s2'", "obtain s2' where \"s2 -\\<tau>2\\<rightarrow>* s2'\" and \"s1 \\<approx> s2'\" \n    and no_\\<tau>moves2: \"\\<And>s2''. \\<not> s2' -\\<tau>2\\<rightarrow> s2''\""], ["proof (prove)\nusing this:\n  \\<exists>s2'.\n     s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n     (\\<forall>s2''. \\<not> s2' -\\<tau>2\\<rightarrow> s2'') \\<and> s1\n     \\<approx> s2'\n\ngoal (1 subgoal):\n 1. (\\<And>s2'.\n        \\<lbrakk>s2 -\\<tau>2\\<rightarrow>* s2'; s1 \\<approx> s2';\n         \\<And>s2''. \\<not> s2' -\\<tau>2\\<rightarrow> s2''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  s1 \\<approx> s2'\n  \\<not> s2' -\\<tau>2\\<rightarrow> ?s2''\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n       (\\<forall>tl2 s2''. \\<not> s2' -2-tl2\\<rightarrow> s2'') \\<and> s1\n       \\<approx> s2'", "moreover"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  s1 \\<approx> s2'\n  \\<not> s2' -\\<tau>2\\<rightarrow> ?s2''\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n       (\\<forall>tl2 s2''. \\<not> s2' -2-tl2\\<rightarrow> s2'') \\<and> s1\n       \\<approx> s2'", "have \"\\<And>tl2 s2''. \\<not> s2' -2-tl2\\<rightarrow> s2''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tl2 s2''. \\<not> s2' -2-tl2\\<rightarrow> s2''", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>tl2 s2''. s2' -2-tl2\\<rightarrow> s2'' \\<Longrightarrow> False", "fix tl2 s2''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>tl2 s2''. s2' -2-tl2\\<rightarrow> s2'' \\<Longrightarrow> False", "assume \"s2' -2-tl2\\<rightarrow> s2''\""], ["proof (state)\nthis:\n  s2' -2-tl2\\<rightarrow> s2''\n\ngoal (1 subgoal):\n 1. \\<And>tl2 s2''. s2' -2-tl2\\<rightarrow> s2'' \\<Longrightarrow> False", "with no_\\<tau>moves2[of s2'']"], ["proof (chain)\npicking this:\n  \\<not> s2' -\\<tau>2\\<rightarrow> s2''\n  s2' -2-tl2\\<rightarrow> s2''", "have \"\\<not> \\<tau>move2 s2' tl2 s2''\""], ["proof (prove)\nusing this:\n  \\<not> s2' -\\<tau>2\\<rightarrow> s2''\n  s2' -2-tl2\\<rightarrow> s2''\n\ngoal (1 subgoal):\n 1. \\<not> \\<tau>move2 s2' tl2 s2''", "by(auto)"], ["proof (state)\nthis:\n  \\<not> \\<tau>move2 s2' tl2 s2''\n\ngoal (1 subgoal):\n 1. \\<And>tl2 s2''. s2' -2-tl2\\<rightarrow> s2'' \\<Longrightarrow> False", "from simulation2[OF \\<open>s1 \\<approx> s2'\\<close> \\<open>s2' -2-tl2\\<rightarrow> s2''\\<close> this]"], ["proof (chain)\npicking this:\n  \\<exists>s1' s1'' tl1.\n     s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n     s1' -1-tl1\\<rightarrow> s1'' \\<and>\n     \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n     s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2", "obtain s1' s1'' tl1 where \"s1 -\\<tau>1\\<rightarrow>* s1'\" and \"s1' -1-tl1\\<rightarrow> s1''\""], ["proof (prove)\nusing this:\n  \\<exists>s1' s1'' tl1.\n     s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n     s1' -1-tl1\\<rightarrow> s1'' \\<and>\n     \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n     s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. (\\<And>s1' tl1 s1''.\n        \\<lbrakk>s1 -\\<tau>1\\<rightarrow>* s1';\n         s1' -1-tl1\\<rightarrow> s1''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s1 -\\<tau>1\\<rightarrow>* s1'\n  s1' -1-tl1\\<rightarrow> s1''\n\ngoal (1 subgoal):\n 1. \\<And>tl2 s2''. s2' -2-tl2\\<rightarrow> s2'' \\<Longrightarrow> False", "with no_moves1"], ["proof (chain)\npicking this:\n  \\<not> s1 -1-?tl1.0\\<rightarrow> ?s1'\n  s1 -\\<tau>1\\<rightarrow>* s1'\n  s1' -1-tl1\\<rightarrow> s1''", "show False"], ["proof (prove)\nusing this:\n  \\<not> s1 -1-?tl1.0\\<rightarrow> ?s1'\n  s1 -\\<tau>1\\<rightarrow>* s1'\n  s1' -1-tl1\\<rightarrow> s1''\n\ngoal (1 subgoal):\n 1. False", "by(fastforce elim: converse_rtranclpE)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> s2' -2-?tl2.0\\<rightarrow> ?s2''\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n       (\\<forall>tl2 s2''. \\<not> s2' -2-tl2\\<rightarrow> s2'') \\<and> s1\n       \\<approx> s2'", "ultimately"], ["proof (chain)\npicking this:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  s1 \\<approx> s2'\n  \\<not> s2' -\\<tau>2\\<rightarrow> ?s2''\n  \\<not> s2' -2-?tl2.0\\<rightarrow> ?s2''", "show ?thesis"], ["proof (prove)\nusing this:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  s1 \\<approx> s2'\n  \\<not> s2' -\\<tau>2\\<rightarrow> ?s2''\n  \\<not> s2' -2-?tl2.0\\<rightarrow> ?s2''\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n       (\\<forall>tl2 s2''. \\<not> s2' -2-tl2\\<rightarrow> s2'') \\<and> s1\n       \\<approx> s2'", "by blast"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n     (\\<forall>tl2 s2''. \\<not> s2' -2-tl2\\<rightarrow> s2'') \\<and> s1\n     \\<approx> s2'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma no_move2_to_no_move1:\n  \"\\<lbrakk> s1 \\<approx> s2; \\<And>tl2 s2'. \\<not> s2 -2-tl2\\<rightarrow> s2' \\<rbrakk>\n  \\<Longrightarrow> \\<exists>s1'. s1 -\\<tau>1\\<rightarrow>* s1' \\<and> (\\<forall>tl1 s1''. \\<not> s1' -1-tl1\\<rightarrow> s1'') \\<and> s1' \\<approx> s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx> s2;\n     \\<And>tl2 s2'. \\<not> s2 -2-tl2\\<rightarrow> s2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s1'.\n                         s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                         (\\<forall>tl1 s1''. \\<not> s1' -1-tl1\\<rightarrow>\n                             s1'') \\<and>\n                         s1' \\<approx> s2", "using delay_bisimulation_diverge.no_move1_to_no_move2[OF delay_bisimulation_diverge_flip]"], ["proof (prove)\nusing this:\n  \\<lbrakk>flip bisim ?s1.0 ?s2.0;\n   \\<And>tl1 s1'. \\<not> ?s1.0 -2-tl1\\<rightarrow> s1'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s2'.\n                       ?s2.0 -\\<tau>1\\<rightarrow>* s2' \\<and>\n                       (\\<forall>tl2 s2''. \\<not> s2' -1-tl2\\<rightarrow>\n                           s2'') \\<and>\n                       flip bisim ?s1.0 s2'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx> s2;\n     \\<And>tl2 s2'. \\<not> s2 -2-tl2\\<rightarrow> s2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s1'.\n                         s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                         (\\<forall>tl1 s1''. \\<not> s1' -1-tl1\\<rightarrow>\n                             s1'') \\<and>\n                         s1' \\<approx> s2", "unfolding flip_simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s2.0 \\<approx> ?s1.0;\n   \\<And>tl1 s1'. \\<not> ?s1.0 -2-tl1\\<rightarrow> s1'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s2'.\n                       ?s2.0 -\\<tau>1\\<rightarrow>* s2' \\<and>\n                       (\\<forall>tl2 s2''. \\<not> s2' -1-tl2\\<rightarrow>\n                           s2'') \\<and>\n                       s2' \\<approx> ?s1.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx> s2;\n     \\<And>tl2 s2'. \\<not> s2 -2-tl2\\<rightarrow> s2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s1'.\n                         s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                         (\\<forall>tl1 s1''. \\<not> s1' -1-tl1\\<rightarrow>\n                             s1'') \\<and>\n                         s1' \\<approx> s2", "."], ["", "lemma simulation_\\<tau>Runs_table1:\n  assumes bisim: \"s1 \\<approx> s2\"\n  and run1: \"trsys1.\\<tau>Runs_table s1 stlsss1\"\n  shows \"\\<exists>stlsss2. trsys2.\\<tau>Runs_table s2 stlsss2 \\<and> tllist_all2 (\\<lambda>(tl1, s1'') (tl2, s2''). tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'') (rel_option bisim) stlsss1 stlsss2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stlsss2.\n       trsys2.\\<tau>Runs_table s2 stlsss2 \\<and>\n       tllist_all2\n        (\\<lambda>(tl1, s1'') (tl2, s2'').\n            tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n        (rel_option bisim) stlsss1 stlsss2", "proof(intro exI conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. trsys2.\\<tau>Runs_table s2 ?stlsss2.0\n 2. tllist_all2\n     (\\<lambda>(tl1, s1'') (tl2, s2'').\n         tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n     (rel_option bisim) stlsss1 ?stlsss2.0", "let ?P = \"\\<lambda>(s2 :: 's2) (stlsss1 :: ('tl1 \\<times> 's1, 's1 option) tllist) (tl2, s2'').\n    \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s2' -2-tl2\\<rightarrow> s2'' \\<and> \\<not> \\<tau>move2 s2' tl2 s2'' \\<and> snd (thd stlsss1) \\<approx> s2'' \\<and> fst (thd stlsss1) \\<sim> tl2\""], ["proof (state)\ngoal (2 subgoals):\n 1. trsys2.\\<tau>Runs_table s2 ?stlsss2.0\n 2. tllist_all2\n     (\\<lambda>(tl1, s1'') (tl2, s2'').\n         tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n     (rel_option bisim) stlsss1 ?stlsss2.0", "define tls1_to_tls2 where \"tls1_to_tls2 s2 stlsss1 = unfold_tllist\n      (\\<lambda>(s2, stlsss1). is_TNil stlsss1)\n      (\\<lambda>(s2, stlsss1). map_option (\\<lambda>s1'. SOME s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> (\\<forall>tl s2''. \\<not> s2' -2-tl\\<rightarrow> s2'') \\<and> s1' \\<approx> s2') (terminal stlsss1))\n      (\\<lambda>(s2, stlsss1). let (tl2, s2'') = Eps (?P s2 stlsss1) in (tl2, s2''))\n      (\\<lambda>(s2, stlsss1). let (tl2, s2'') = Eps (?P s2 stlsss1) in (s2'', ttl stlsss1))\n      (s2, stlsss1)\"\n    for s2 stlsss1"], ["proof (state)\nthis:\n  tls1_to_tls2 ?s2.0 ?stlsss1.0 =\n  unfold_tllist (\\<lambda>(s2, stlsss1). is_TNil stlsss1)\n   (\\<lambda>(s2, stlsss1).\n       map_option\n        (\\<lambda>s1'.\n            SOME s2'.\n               s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n               (\\<forall>tl s2''. \\<not> s2' -2-tl\\<rightarrow> s2'') \\<and>\n               s1' \\<approx> s2')\n        (terminal stlsss1))\n   (\\<lambda>(s2, stlsss1).\n       let (tl2, s2'') =\n             SOME (tl2, s2'').\n                \\<exists>s2'.\n                   s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                   s2' -2-tl2\\<rightarrow> s2'' \\<and>\n                   \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n                   snd (thd stlsss1) \\<approx> s2'' \\<and> fst (thd stlsss1)\n                   \\<sim> tl2\n       in (tl2, s2''))\n   (\\<lambda>(s2, stlsss1).\n       let (tl2, s2'') =\n             SOME (tl2, s2'').\n                \\<exists>s2'.\n                   s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                   s2' -2-tl2\\<rightarrow> s2'' \\<and>\n                   \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n                   snd (thd stlsss1) \\<approx> s2'' \\<and> fst (thd stlsss1)\n                   \\<sim> tl2\n       in (s2'', ttl stlsss1))\n   (?s2.0, ?stlsss1.0)\n\ngoal (2 subgoals):\n 1. trsys2.\\<tau>Runs_table s2 ?stlsss2.0\n 2. tllist_all2\n     (\\<lambda>(tl1, s1'') (tl2, s2'').\n         tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n     (rel_option bisim) stlsss1 ?stlsss2.0", "have [simp]:\n    \"\\<And>s2 stlsss1. is_TNil (tls1_to_tls2 s2 stlsss1) \\<longleftrightarrow> is_TNil stlsss1\"\n    \"\\<And>s2 stlsss1. is_TNil stlsss1 \\<Longrightarrow> terminal (tls1_to_tls2 s2 stlsss1) = map_option (\\<lambda>s1'. SOME s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> (\\<forall>tl s2''. \\<not> s2' -2-tl\\<rightarrow> s2'') \\<and> s1' \\<approx> s2') (terminal stlsss1)\"\n    \"\\<And>s2 stlsss1. \\<not> is_TNil stlsss1 \\<Longrightarrow> thd (tls1_to_tls2 s2 stlsss1) = (let (tl2, s2'') = Eps (?P s2 stlsss1) in (tl2, s2''))\"\n    \"\\<And>s2 stlsss1. \\<not> is_TNil stlsss1 \\<Longrightarrow> ttl (tls1_to_tls2 s2 stlsss1) = (let (tl2, s2'') = Eps (?P s2 stlsss1) in tls1_to_tls2 s2'' (ttl stlsss1))\"\n    \"\\<And>s2 os1. tls1_to_tls2 s2 (TNil os1) = \n               TNil (map_option (\\<lambda>s1'. SOME s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> (\\<forall>tl s2''. \\<not> s2' -2-tl\\<rightarrow> s2'') \\<and> s1' \\<approx> s2') os1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>s2 stlsss1.\n         is_TNil (tls1_to_tls2 s2 stlsss1) = is_TNil stlsss1) &&&\n     (\\<And>s2 stlsss1.\n         is_TNil stlsss1 \\<Longrightarrow>\n         terminal (tls1_to_tls2 s2 stlsss1) =\n         map_option\n          (\\<lambda>s1'.\n              SOME s2'.\n                 s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                 (\\<forall>tl s2''. \\<not> s2' -2-tl\\<rightarrow>\n                     s2'') \\<and>\n                 s1' \\<approx> s2')\n          (terminal stlsss1))) &&&\n    (\\<And>s2 stlsss1.\n        \\<not> is_TNil stlsss1 \\<Longrightarrow>\n        thd (tls1_to_tls2 s2 stlsss1) =\n        (let (tl2, s2'') =\n               SOME (tl2, s2'').\n                  \\<exists>s2'.\n                     s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                     s2' -2-tl2\\<rightarrow> s2'' \\<and>\n                     \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n                     snd (thd stlsss1) \\<approx> s2'' \\<and>\n                     fst (thd stlsss1) \\<sim> tl2\n         in (tl2, s2''))) &&&\n    (\\<And>s2 stlsss1.\n        \\<not> is_TNil stlsss1 \\<Longrightarrow>\n        ttl (tls1_to_tls2 s2 stlsss1) =\n        (let (tl2, s2'') =\n               SOME (tl2, s2'').\n                  \\<exists>s2'.\n                     s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                     s2' -2-tl2\\<rightarrow> s2'' \\<and>\n                     \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n                     snd (thd stlsss1) \\<approx> s2'' \\<and>\n                     fst (thd stlsss1) \\<sim> tl2\n         in tls1_to_tls2 s2'' (ttl stlsss1))) &&&\n    (\\<And>s2 os1.\n        tls1_to_tls2 s2 (TNil os1) =\n        TNil\n         (map_option\n           (\\<lambda>s1'.\n               SOME s2'.\n                  s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                  (\\<forall>tl s2''. \\<not> s2' -2-tl\\<rightarrow>\n                      s2'') \\<and>\n                  s1' \\<approx> s2')\n           os1))", "by(simp_all add: tls1_to_tls2_def split_beta)"], ["proof (state)\nthis:\n  is_TNil (tls1_to_tls2 ?s2.0 ?stlsss1.0) = is_TNil ?stlsss1.0\n  is_TNil ?stlsss1.0 \\<Longrightarrow>\n  terminal (tls1_to_tls2 ?s2.0 ?stlsss1.0) =\n  map_option\n   (\\<lambda>s1'.\n       SOME s2'.\n          ?s2.0 -\\<tau>2\\<rightarrow>* s2' \\<and>\n          (\\<forall>tl s2''. \\<not> s2' -2-tl\\<rightarrow> s2'') \\<and> s1'\n          \\<approx> s2')\n   (terminal ?stlsss1.0)\n  \\<not> is_TNil ?stlsss1.0 \\<Longrightarrow>\n  thd (tls1_to_tls2 ?s2.0 ?stlsss1.0) =\n  (let (tl2, s2'') =\n         SOME (tl2, s2'').\n            \\<exists>s2'.\n               ?s2.0 -\\<tau>2\\<rightarrow>* s2' \\<and>\n               s2' -2-tl2\\<rightarrow> s2'' \\<and>\n               \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n               snd (thd ?stlsss1.0) \\<approx> s2'' \\<and>\n               fst (thd ?stlsss1.0) \\<sim> tl2\n   in (tl2, s2''))\n  \\<not> is_TNil ?stlsss1.0 \\<Longrightarrow>\n  ttl (tls1_to_tls2 ?s2.0 ?stlsss1.0) =\n  (let (tl2, s2'') =\n         SOME (tl2, s2'').\n            \\<exists>s2'.\n               ?s2.0 -\\<tau>2\\<rightarrow>* s2' \\<and>\n               s2' -2-tl2\\<rightarrow> s2'' \\<and>\n               \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n               snd (thd ?stlsss1.0) \\<approx> s2'' \\<and>\n               fst (thd ?stlsss1.0) \\<sim> tl2\n   in tls1_to_tls2 s2'' (ttl ?stlsss1.0))\n  tls1_to_tls2 ?s2.0 (TNil ?os1.0) =\n  TNil\n   (map_option\n     (\\<lambda>s1'.\n         SOME s2'.\n            ?s2.0 -\\<tau>2\\<rightarrow>* s2' \\<and>\n            (\\<forall>tl s2''. \\<not> s2' -2-tl\\<rightarrow> s2'') \\<and>\n            s1' \\<approx> s2')\n     ?os1.0)\n\ngoal (2 subgoals):\n 1. trsys2.\\<tau>Runs_table s2 ?stlsss2.0\n 2. tllist_all2\n     (\\<lambda>(tl1, s1'') (tl2, s2'').\n         tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n     (rel_option bisim) stlsss1 ?stlsss2.0", "have [simp]:\n    \"\\<And>s2 s1 s1' tl1 s1'' stlsss1. \n     tls1_to_tls2 s2 (TCons (tl1, s1'') stlsss1) =\n     (let (tl2, s2'') = SOME (tl2, s2''). \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s2' -2-tl2\\<rightarrow> s2'' \\<and> \n                             \\<not> \\<tau>move2 s2' tl2 s2'' \\<and> s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n      in TCons (tl2, s2'') (tls1_to_tls2 s2'' stlsss1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s2 s1 s1' tl1 s1'' stlsss1.\n       tls1_to_tls2 s2 (TCons (tl1, s1'') stlsss1) =\n       (let (tl2, s2'') =\n              SOME (tl2, s2'').\n                 \\<exists>s2'.\n                    s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                    s2' -2-tl2\\<rightarrow> s2'' \\<and>\n                    \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n                    s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n        in TCons (tl2, s2'') (tls1_to_tls2 s2'' stlsss1))", "by(rule tllist.expand)(simp_all add: split_beta)"], ["proof (state)\nthis:\n  tls1_to_tls2 ?s2.0 (TCons (?tl1.0, ?s1'') ?stlsss1.0) =\n  (let (tl2, s2'') =\n         SOME (tl2, s2'').\n            \\<exists>s2'.\n               ?s2.0 -\\<tau>2\\<rightarrow>* s2' \\<and>\n               s2' -2-tl2\\<rightarrow> s2'' \\<and>\n               \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n               ?s1'' \\<approx> s2'' \\<and> ?tl1.0 \\<sim> tl2\n   in TCons (tl2, s2'') (tls1_to_tls2 s2'' ?stlsss1.0))\n\ngoal (2 subgoals):\n 1. trsys2.\\<tau>Runs_table s2 ?stlsss2.0\n 2. tllist_all2\n     (\\<lambda>(tl1, s1'') (tl2, s2'').\n         tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n     (rel_option bisim) stlsss1 ?stlsss2.0", "from bisim run1"], ["proof (chain)\npicking this:\n  s1 \\<approx> s2\n  trsys1.\\<tau>Runs_table s1 stlsss1", "show \"trsys2.\\<tau>Runs_table s2 (tls1_to_tls2 s2 stlsss1)\""], ["proof (prove)\nusing this:\n  s1 \\<approx> s2\n  trsys1.\\<tau>Runs_table s1 stlsss1\n\ngoal (1 subgoal):\n 1. trsys2.\\<tau>Runs_table s2 (tls1_to_tls2 s2 stlsss1)", "proof(coinduction arbitrary: s2 s1 stlsss1)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s2 s1 stlsss1.\n       \\<lbrakk>s1 \\<approx> s2; trsys1.\\<tau>Runs_table s1 stlsss1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))", "case (\\<tau>Runs_table s2 s1 stlsss1)"], ["proof (state)\nthis:\n  s1 \\<approx> s2\n  trsys1.\\<tau>Runs_table s1 stlsss1\n\ngoal (1 subgoal):\n 1. \\<And>s2 s1 stlsss1.\n       \\<lbrakk>s1 \\<approx> s2; trsys1.\\<tau>Runs_table s1 stlsss1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))", "note bisim = \\<open>s1 \\<approx> s2\\<close>\n      and run1 = \\<open>trsys1.\\<tau>Runs_table s1 stlsss1\\<close>"], ["proof (state)\nthis:\n  s1 \\<approx> s2\n  trsys1.\\<tau>Runs_table s1 stlsss1\n\ngoal (1 subgoal):\n 1. \\<And>s2 s1 stlsss1.\n       \\<lbrakk>s1 \\<approx> s2; trsys1.\\<tau>Runs_table s1 stlsss1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))", "from run1"], ["proof (chain)\npicking this:\n  trsys1.\\<tau>Runs_table s1 stlsss1", "show ?case"], ["proof (prove)\nusing this:\n  trsys1.\\<tau>Runs_table s1 stlsss1\n\ngoal (1 subgoal):\n 1. (\\<exists>s s'.\n        s2 = s \\<and>\n        tls1_to_tls2 s2 stlsss1 = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>2\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        s2 = s \\<and>\n        tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n        s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        s2 = s \\<and>\n        tls1_to_tls2 s2 stlsss1 = TCons (tl, s'') tls \\<and>\n        s -\\<tau>2\\<rightarrow>* s' \\<and>\n        s' -2-tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move2 s' tl s'' \\<and>\n        ((\\<exists>s2 s1 stlsss1.\n             s'' = s2 \\<and>\n             tls = tls1_to_tls2 s2 stlsss1 \\<and>\n             s1 \\<approx> s2 \\<and>\n             trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n         trsys2.\\<tau>Runs_table s'' tls))", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>stlsss1 = TNil \\<lfloor>s'\\<rfloor>;\n        s1 -\\<tau>1\\<rightarrow>* s';\n        \\<And>tl s''. \\<not> s' -1-tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))\n 2. \\<lbrakk>stlsss1 = TNil None;\n     s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s'.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 =\n                          TNil \\<lfloor>s'\\<rfloor> \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                          s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                      (\\<exists>s s' s'' tls tl.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 =\n                          TCons (tl, s'') tls \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          s' -2-tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move2 s' tl s'' \\<and>\n                          ((\\<exists>s2 s1 stlsss1.\n                               s'' = s2 \\<and>\n                               tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                               s1 \\<approx> s2 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                           trsys2.\\<tau>Runs_table s'' tls))\n 3. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))", "case (Terminate s1')"], ["proof (state)\nthis:\n  stlsss1 = TNil \\<lfloor>s1'\\<rfloor>\n  s1 -\\<tau>1\\<rightarrow>* s1'\n  \\<not> s1' -1-?tl1\\<rightarrow> ?s''1\n\ngoal (3 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>stlsss1 = TNil \\<lfloor>s'\\<rfloor>;\n        s1 -\\<tau>1\\<rightarrow>* s';\n        \\<And>tl s''. \\<not> s' -1-tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))\n 2. \\<lbrakk>stlsss1 = TNil None;\n     s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s'.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 =\n                          TNil \\<lfloor>s'\\<rfloor> \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                          s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                      (\\<exists>s s' s'' tls tl.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 =\n                          TCons (tl, s'') tls \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          s' -2-tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move2 s' tl s'' \\<and>\n                          ((\\<exists>s2 s1 stlsss1.\n                               s'' = s2 \\<and>\n                               tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                               s1 \\<approx> s2 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                           trsys2.\\<tau>Runs_table s'' tls))\n 3. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))", "let ?P = \"\\<lambda>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> (\\<forall>tl2 s2''. \\<not> s2' -2-tl2\\<rightarrow> s2'') \\<and> s1' \\<approx> s2'\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>stlsss1 = TNil \\<lfloor>s'\\<rfloor>;\n        s1 -\\<tau>1\\<rightarrow>* s';\n        \\<And>tl s''. \\<not> s' -1-tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))\n 2. \\<lbrakk>stlsss1 = TNil None;\n     s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s'.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 =\n                          TNil \\<lfloor>s'\\<rfloor> \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                          s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                      (\\<exists>s s' s'' tls tl.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 =\n                          TCons (tl, s'') tls \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          s' -2-tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move2 s' tl s'' \\<and>\n                          ((\\<exists>s2 s1 stlsss1.\n                               s'' = s2 \\<and>\n                               tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                               s1 \\<approx> s2 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                           trsys2.\\<tau>Runs_table s'' tls))\n 3. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))", "from simulation_silents1[OF bisim \\<open>s1 -\\<tau>1\\<rightarrow>* s1'\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2'", "obtain s2' where \"s2 -\\<tau>2\\<rightarrow>* s2'\" and \"s1' \\<approx> s2'\""], ["proof (prove)\nusing this:\n  \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2'\n\ngoal (1 subgoal):\n 1. (\\<And>s2'.\n        \\<lbrakk>s2 -\\<tau>2\\<rightarrow>* s2'; s1' \\<approx> s2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  s1' \\<approx> s2'\n\ngoal (3 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>stlsss1 = TNil \\<lfloor>s'\\<rfloor>;\n        s1 -\\<tau>1\\<rightarrow>* s';\n        \\<And>tl s''. \\<not> s' -1-tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))\n 2. \\<lbrakk>stlsss1 = TNil None;\n     s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s'.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 =\n                          TNil \\<lfloor>s'\\<rfloor> \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                          s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                      (\\<exists>s s' s'' tls tl.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 =\n                          TCons (tl, s'') tls \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          s' -2-tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move2 s' tl s'' \\<and>\n                          ((\\<exists>s2 s1 stlsss1.\n                               s'' = s2 \\<and>\n                               tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                               s1 \\<approx> s2 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                           trsys2.\\<tau>Runs_table s'' tls))\n 3. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))", "moreover"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  s1' \\<approx> s2'\n\ngoal (3 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>stlsss1 = TNil \\<lfloor>s'\\<rfloor>;\n        s1 -\\<tau>1\\<rightarrow>* s';\n        \\<And>tl s''. \\<not> s' -1-tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))\n 2. \\<lbrakk>stlsss1 = TNil None;\n     s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s'.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 =\n                          TNil \\<lfloor>s'\\<rfloor> \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                          s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                      (\\<exists>s s' s'' tls tl.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 =\n                          TCons (tl, s'') tls \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          s' -2-tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move2 s' tl s'' \\<and>\n                          ((\\<exists>s2 s1 stlsss1.\n                               s'' = s2 \\<and>\n                               tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                               s1 \\<approx> s2 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                           trsys2.\\<tau>Runs_table s'' tls))\n 3. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))", "from no_move1_to_no_move2[OF \\<open>s1' \\<approx> s2'\\<close> \\<open>\\<And>tl1 s1''. \\<not> s1' -1-tl1\\<rightarrow> s1''\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>s2'a.\n     s2' -\\<tau>2\\<rightarrow>* s2'a \\<and>\n     (\\<forall>tl2 s2''. \\<not> s2'a -2-tl2\\<rightarrow> s2'') \\<and> s1'\n     \\<approx> s2'a", "obtain s2'' where \"s2' -\\<tau>2\\<rightarrow>* s2''\" and \"s1' \\<approx> s2''\" \n        and \"\\<And>tl2 s2'''. \\<not> s2'' -2-tl2\\<rightarrow> s2'''\""], ["proof (prove)\nusing this:\n  \\<exists>s2'a.\n     s2' -\\<tau>2\\<rightarrow>* s2'a \\<and>\n     (\\<forall>tl2 s2''. \\<not> s2'a -2-tl2\\<rightarrow> s2'') \\<and> s1'\n     \\<approx> s2'a\n\ngoal (1 subgoal):\n 1. (\\<And>s2''.\n        \\<lbrakk>s2' -\\<tau>2\\<rightarrow>* s2''; s1' \\<approx> s2'';\n         \\<And>tl2 s2'''. \\<not> s2'' -2-tl2\\<rightarrow> s2'''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s2' -\\<tau>2\\<rightarrow>* s2''\n  s1' \\<approx> s2''\n  \\<not> s2'' -2-?tl2.1\\<rightarrow> ?s2'''1\n\ngoal (3 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>stlsss1 = TNil \\<lfloor>s'\\<rfloor>;\n        s1 -\\<tau>1\\<rightarrow>* s';\n        \\<And>tl s''. \\<not> s' -1-tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))\n 2. \\<lbrakk>stlsss1 = TNil None;\n     s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s'.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 =\n                          TNil \\<lfloor>s'\\<rfloor> \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                          s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                      (\\<exists>s s' s'' tls tl.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 =\n                          TCons (tl, s'') tls \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          s' -2-tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move2 s' tl s'' \\<and>\n                          ((\\<exists>s2 s1 stlsss1.\n                               s'' = s2 \\<and>\n                               tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                               s1 \\<approx> s2 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                           trsys2.\\<tau>Runs_table s'' tls))\n 3. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))", "ultimately"], ["proof (chain)\npicking this:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  s1' \\<approx> s2'\n  s2' -\\<tau>2\\<rightarrow>* s2''\n  s1' \\<approx> s2''\n  \\<not> s2'' -2-?tl2.1\\<rightarrow> ?s2'''1", "have \"?P s2''\""], ["proof (prove)\nusing this:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  s1' \\<approx> s2'\n  s2' -\\<tau>2\\<rightarrow>* s2''\n  s1' \\<approx> s2''\n  \\<not> s2'' -2-?tl2.1\\<rightarrow> ?s2'''1\n\ngoal (1 subgoal):\n 1. s2 -\\<tau>2\\<rightarrow>* s2'' \\<and>\n    (\\<forall>tl2 s2''a. \\<not> s2'' -2-tl2\\<rightarrow> s2''a) \\<and> s1'\n    \\<approx> s2''", "by(blast intro: rtranclp_trans)"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow>* s2'' \\<and>\n  (\\<forall>tl2 s2''a. \\<not> s2'' -2-tl2\\<rightarrow> s2''a) \\<and> s1'\n  \\<approx> s2''\n\ngoal (3 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>stlsss1 = TNil \\<lfloor>s'\\<rfloor>;\n        s1 -\\<tau>1\\<rightarrow>* s';\n        \\<And>tl s''. \\<not> s' -1-tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))\n 2. \\<lbrakk>stlsss1 = TNil None;\n     s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s'.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 =\n                          TNil \\<lfloor>s'\\<rfloor> \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                          s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                      (\\<exists>s s' s'' tls tl.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 =\n                          TCons (tl, s'') tls \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          s' -2-tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move2 s' tl s'' \\<and>\n                          ((\\<exists>s2 s1 stlsss1.\n                               s'' = s2 \\<and>\n                               tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                               s1 \\<approx> s2 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                           trsys2.\\<tau>Runs_table s'' tls))\n 3. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))", "hence \"?P (Eps ?P)\""], ["proof (prove)\nusing this:\n  s2 -\\<tau>2\\<rightarrow>* s2'' \\<and>\n  (\\<forall>tl2 s2''a. \\<not> s2'' -2-tl2\\<rightarrow> s2''a) \\<and> s1'\n  \\<approx> s2''\n\ngoal (1 subgoal):\n 1. s2 -\\<tau>2\\<rightarrow>* (SOME s2'.\n                                  s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                                  (\\<forall>tl2 s2''. \\<not> s2'\n-2-tl2\\<rightarrow> s2'') \\<and>\n                                  s1' \\<approx> s2') \\<and>\n    (\\<forall>tl2 s2''.\n        \\<not> (SOME s2'.\n                   s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                   (\\<forall>tl2 s2''. \\<not> s2' -2-tl2\\<rightarrow>\n                       s2'') \\<and>\n                   s1' \\<approx> s2')\n        -2-tl2\\<rightarrow> s2'') \\<and>\n    s1'\n    \\<approx> (SOME s2'.\n                  s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                  (\\<forall>tl2 s2''. \\<not> s2' -2-tl2\\<rightarrow>\n                      s2'') \\<and>\n                  s1' \\<approx> s2')", "by(rule someI)"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow>* (SOME s2'.\n                                s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                                (\\<forall>tl2 s2''. \\<not> s2'\n                                    -2-tl2\\<rightarrow> s2'') \\<and>\n                                s1' \\<approx> s2') \\<and>\n  (\\<forall>tl2 s2''.\n      \\<not> (SOME s2'.\n                 s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                 (\\<forall>tl2 s2''. \\<not> s2' -2-tl2\\<rightarrow>\n                     s2'') \\<and>\n                 s1' \\<approx> s2')\n      -2-tl2\\<rightarrow> s2'') \\<and>\n  s1'\n  \\<approx> (SOME s2'.\n                s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                (\\<forall>tl2 s2''. \\<not> s2' -2-tl2\\<rightarrow>\n                    s2'') \\<and>\n                s1' \\<approx> s2')\n\ngoal (3 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>stlsss1 = TNil \\<lfloor>s'\\<rfloor>;\n        s1 -\\<tau>1\\<rightarrow>* s';\n        \\<And>tl s''. \\<not> s' -1-tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))\n 2. \\<lbrakk>stlsss1 = TNil None;\n     s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s'.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 =\n                          TNil \\<lfloor>s'\\<rfloor> \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                          s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                      (\\<exists>s s' s'' tls tl.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 =\n                          TCons (tl, s'') tls \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          s' -2-tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move2 s' tl s'' \\<and>\n                          ((\\<exists>s2 s1 stlsss1.\n                               s'' = s2 \\<and>\n                               tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                               s1 \\<approx> s2 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                           trsys2.\\<tau>Runs_table s'' tls))\n 3. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))", "hence ?Terminate"], ["proof (prove)\nusing this:\n  s2 -\\<tau>2\\<rightarrow>* (SOME s2'.\n                                s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                                (\\<forall>tl2 s2''. \\<not> s2'\n                                    -2-tl2\\<rightarrow> s2'') \\<and>\n                                s1' \\<approx> s2') \\<and>\n  (\\<forall>tl2 s2''.\n      \\<not> (SOME s2'.\n                 s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                 (\\<forall>tl2 s2''. \\<not> s2' -2-tl2\\<rightarrow>\n                     s2'') \\<and>\n                 s1' \\<approx> s2')\n      -2-tl2\\<rightarrow> s2'') \\<and>\n  s1'\n  \\<approx> (SOME s2'.\n                s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                (\\<forall>tl2 s2''. \\<not> s2' -2-tl2\\<rightarrow>\n                    s2'') \\<and>\n                s1' \\<approx> s2')\n\ngoal (1 subgoal):\n 1. \\<exists>s s'.\n       s2 = s \\<and>\n       tls1_to_tls2 s2 stlsss1 = TNil \\<lfloor>s'\\<rfloor> \\<and>\n       s -\\<tau>2\\<rightarrow>* s' \\<and>\n       (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow> xa)", "using \\<open>stlsss1 = TNil \\<lfloor>s1'\\<rfloor>\\<close>"], ["proof (prove)\nusing this:\n  s2 -\\<tau>2\\<rightarrow>* (SOME s2'.\n                                s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                                (\\<forall>tl2 s2''. \\<not> s2'\n                                    -2-tl2\\<rightarrow> s2'') \\<and>\n                                s1' \\<approx> s2') \\<and>\n  (\\<forall>tl2 s2''.\n      \\<not> (SOME s2'.\n                 s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                 (\\<forall>tl2 s2''. \\<not> s2' -2-tl2\\<rightarrow>\n                     s2'') \\<and>\n                 s1' \\<approx> s2')\n      -2-tl2\\<rightarrow> s2'') \\<and>\n  s1'\n  \\<approx> (SOME s2'.\n                s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                (\\<forall>tl2 s2''. \\<not> s2' -2-tl2\\<rightarrow>\n                    s2'') \\<and>\n                s1' \\<approx> s2')\n  stlsss1 = TNil \\<lfloor>s1'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>s s'.\n       s2 = s \\<and>\n       tls1_to_tls2 s2 stlsss1 = TNil \\<lfloor>s'\\<rfloor> \\<and>\n       s -\\<tau>2\\<rightarrow>* s' \\<and>\n       (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow> xa)", "by simp"], ["proof (state)\nthis:\n  \\<exists>s s'.\n     s2 = s \\<and>\n     tls1_to_tls2 s2 stlsss1 = TNil \\<lfloor>s'\\<rfloor> \\<and>\n     s -\\<tau>2\\<rightarrow>* s' \\<and>\n     (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow> xa)\n\ngoal (3 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>stlsss1 = TNil \\<lfloor>s'\\<rfloor>;\n        s1 -\\<tau>1\\<rightarrow>* s';\n        \\<And>tl s''. \\<not> s' -1-tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))\n 2. \\<lbrakk>stlsss1 = TNil None;\n     s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s'.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 =\n                          TNil \\<lfloor>s'\\<rfloor> \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                          s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                      (\\<exists>s s' s'' tls tl.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 =\n                          TCons (tl, s'') tls \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          s' -2-tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move2 s' tl s'' \\<and>\n                          ((\\<exists>s2 s1 stlsss1.\n                               s'' = s2 \\<and>\n                               tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                               s1 \\<approx> s2 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                           trsys2.\\<tau>Runs_table s'' tls))\n 3. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s s'.\n     s2 = s \\<and>\n     tls1_to_tls2 s2 stlsss1 = TNil \\<lfloor>s'\\<rfloor> \\<and>\n     s -\\<tau>2\\<rightarrow>* s' \\<and>\n     (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow> xa)\n\ngoal (1 subgoal):\n 1. (\\<exists>s s'.\n        s2 = s \\<and>\n        tls1_to_tls2 s2 stlsss1 = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>2\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        s2 = s \\<and>\n        tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n        s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        s2 = s \\<and>\n        tls1_to_tls2 s2 stlsss1 = TCons (tl, s'') tls \\<and>\n        s -\\<tau>2\\<rightarrow>* s' \\<and>\n        s' -2-tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move2 s' tl s'' \\<and>\n        ((\\<exists>s2 s1 stlsss1.\n             s'' = s2 \\<and>\n             tls = tls1_to_tls2 s2 stlsss1 \\<and>\n             s1 \\<approx> s2 \\<and>\n             trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n         trsys2.\\<tau>Runs_table s'' tls))", ".."], ["proof (state)\nthis:\n  (\\<exists>s s'.\n      s2 = s \\<and>\n      tls1_to_tls2 s2 stlsss1 = TNil \\<lfloor>s'\\<rfloor> \\<and>\n      s -\\<tau>2\\<rightarrow>* s' \\<and>\n      (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s.\n      s2 = s \\<and>\n      tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n      s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n  (\\<exists>s s' s'' tls tl.\n      s2 = s \\<and>\n      tls1_to_tls2 s2 stlsss1 = TCons (tl, s'') tls \\<and>\n      s -\\<tau>2\\<rightarrow>* s' \\<and>\n      s' -2-tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move2 s' tl s'' \\<and>\n      ((\\<exists>s2 s1 stlsss1.\n           s'' = s2 \\<and>\n           tls = tls1_to_tls2 s2 stlsss1 \\<and>\n           s1 \\<approx> s2 \\<and> trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n       trsys2.\\<tau>Runs_table s'' tls))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>stlsss1 = TNil None;\n     s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s'.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 =\n                          TNil \\<lfloor>s'\\<rfloor> \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                          s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                      (\\<exists>s s' s'' tls tl.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 =\n                          TCons (tl, s'') tls \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          s' -2-tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move2 s' tl s'' \\<and>\n                          ((\\<exists>s2 s1 stlsss1.\n                               s'' = s2 \\<and>\n                               tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                               s1 \\<approx> s2 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                           trsys2.\\<tau>Runs_table s'' tls))\n 2. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>stlsss1 = TNil None;\n     s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s'.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 =\n                          TNil \\<lfloor>s'\\<rfloor> \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                          s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                      (\\<exists>s s' s'' tls tl.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 =\n                          TCons (tl, s'') tls \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          s' -2-tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move2 s' tl s'' \\<and>\n                          ((\\<exists>s2 s1 stlsss1.\n                               s'' = s2 \\<and>\n                               tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                               s1 \\<approx> s2 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                           trsys2.\\<tau>Runs_table s'' tls))\n 2. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))", "case Diverge"], ["proof (state)\nthis:\n  stlsss1 = TNil None\n  s1 -\\<tau>1\\<rightarrow> \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>stlsss1 = TNil None;\n     s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s'.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 =\n                          TNil \\<lfloor>s'\\<rfloor> \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                          s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                      (\\<exists>s s' s'' tls tl.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 =\n                          TCons (tl, s'') tls \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          s' -2-tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move2 s' tl s'' \\<and>\n                          ((\\<exists>s2 s1 stlsss1.\n                               s'' = s2 \\<and>\n                               tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                               s1 \\<approx> s2 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                           trsys2.\\<tau>Runs_table s'' tls))\n 2. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))", "with \\<tau>diverge_bisim_inv[OF bisim]"], ["proof (chain)\npicking this:\n  s1 -\\<tau>1\\<rightarrow> \\<infinity> =\n  s2 -\\<tau>2\\<rightarrow> \\<infinity>\n  stlsss1 = TNil None\n  s1 -\\<tau>1\\<rightarrow> \\<infinity>", "have ?Diverge"], ["proof (prove)\nusing this:\n  s1 -\\<tau>1\\<rightarrow> \\<infinity> =\n  s2 -\\<tau>2\\<rightarrow> \\<infinity>\n  stlsss1 = TNil None\n  s1 -\\<tau>1\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       s2 = s \\<and>\n       tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n       s -\\<tau>2\\<rightarrow> \\<infinity>", "by simp"], ["proof (state)\nthis:\n  \\<exists>s.\n     s2 = s \\<and>\n     tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n     s -\\<tau>2\\<rightarrow> \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>stlsss1 = TNil None;\n     s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s'.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 =\n                          TNil \\<lfloor>s'\\<rfloor> \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                          s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                      (\\<exists>s s' s'' tls tl.\n                          s2 = s \\<and>\n                          tls1_to_tls2 s2 stlsss1 =\n                          TCons (tl, s'') tls \\<and>\n                          s -\\<tau>2\\<rightarrow>* s' \\<and>\n                          s' -2-tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move2 s' tl s'' \\<and>\n                          ((\\<exists>s2 s1 stlsss1.\n                               s'' = s2 \\<and>\n                               tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                               s1 \\<approx> s2 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                           trsys2.\\<tau>Runs_table s'' tls))\n 2. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s.\n     s2 = s \\<and>\n     tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n     s -\\<tau>2\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<exists>s s'.\n        s2 = s \\<and>\n        tls1_to_tls2 s2 stlsss1 = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>2\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        s2 = s \\<and>\n        tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n        s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        s2 = s \\<and>\n        tls1_to_tls2 s2 stlsss1 = TCons (tl, s'') tls \\<and>\n        s -\\<tau>2\\<rightarrow>* s' \\<and>\n        s' -2-tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move2 s' tl s'' \\<and>\n        ((\\<exists>s2 s1 stlsss1.\n             s'' = s2 \\<and>\n             tls = tls1_to_tls2 s2 stlsss1 \\<and>\n             s1 \\<approx> s2 \\<and>\n             trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n         trsys2.\\<tau>Runs_table s'' tls))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>s s'.\n      s2 = s \\<and>\n      tls1_to_tls2 s2 stlsss1 = TNil \\<lfloor>s'\\<rfloor> \\<and>\n      s -\\<tau>2\\<rightarrow>* s' \\<and>\n      (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s.\n      s2 = s \\<and>\n      tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n      s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n  (\\<exists>s s' s'' tls tl.\n      s2 = s \\<and>\n      tls1_to_tls2 s2 stlsss1 = TCons (tl, s'') tls \\<and>\n      s -\\<tau>2\\<rightarrow>* s' \\<and>\n      s' -2-tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move2 s' tl s'' \\<and>\n      ((\\<exists>s2 s1 stlsss1.\n           s'' = s2 \\<and>\n           tls = tls1_to_tls2 s2 stlsss1 \\<and>\n           s1 \\<approx> s2 \\<and> trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n       trsys2.\\<tau>Runs_table s'' tls))\n\ngoal (1 subgoal):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))", "case (Proceed s1' s1'' stlsss1' tl1)"], ["proof (state)\nthis:\n  stlsss1 = TCons (tl1, s1'') stlsss1'\n  s1 -\\<tau>1\\<rightarrow>* s1'\n  s1' -1-tl1\\<rightarrow> s1''\n  \\<not> \\<tau>move1 s1' tl1 s1''\n  trsys1.\\<tau>Runs_table s1'' stlsss1'\n\ngoal (1 subgoal):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))", "let ?P = \"\\<lambda>(tl2, s2''). \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s2' -2-tl2\\<rightarrow> s2'' \\<and> \\<not> \\<tau>move2 s2' tl2 s2'' \\<and> s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))", "from simulation_silents1[OF bisim \\<open>s1 -\\<tau>1\\<rightarrow>* s1'\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2'", "obtain s2' where \"s2 -\\<tau>2\\<rightarrow>* s2'\" and \"s1' \\<approx> s2'\""], ["proof (prove)\nusing this:\n  \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2'\n\ngoal (1 subgoal):\n 1. (\\<And>s2'.\n        \\<lbrakk>s2 -\\<tau>2\\<rightarrow>* s2'; s1' \\<approx> s2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  s1' \\<approx> s2'\n\ngoal (1 subgoal):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))", "moreover"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  s1' \\<approx> s2'\n\ngoal (1 subgoal):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))", "from simulation1[OF \\<open>s1' \\<approx> s2'\\<close> \\<open>s1' -1-tl1\\<rightarrow> s1''\\<close> \\<open>\\<not> \\<tau>move1 s1' tl1 s1''\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>s2'a s2'' tl2.\n     s2' -\\<tau>2\\<rightarrow>* s2'a \\<and>\n     s2'a -2-tl2\\<rightarrow> s2'' \\<and>\n     \\<not> \\<tau>move2 s2'a tl2 s2'' \\<and>\n     s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2", "obtain s2'' s2''' tl2 where \"s2' -\\<tau>2\\<rightarrow>* s2''\"\n        and \"s2'' -2-tl2\\<rightarrow> s2'''\" and \"\\<not> \\<tau>move2 s2'' tl2 s2'''\"\n        and \"s1'' \\<approx> s2'''\" and \"tl1 \\<sim> tl2\""], ["proof (prove)\nusing this:\n  \\<exists>s2'a s2'' tl2.\n     s2' -\\<tau>2\\<rightarrow>* s2'a \\<and>\n     s2'a -2-tl2\\<rightarrow> s2'' \\<and>\n     \\<not> \\<tau>move2 s2'a tl2 s2'' \\<and>\n     s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. (\\<And>s2'' tl2 s2'''.\n        \\<lbrakk>s2' -\\<tau>2\\<rightarrow>* s2'';\n         s2'' -2-tl2\\<rightarrow> s2'''; \\<not> \\<tau>move2 s2'' tl2 s2''';\n         s1'' \\<approx> s2'''; tl1 \\<sim> tl2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s2' -\\<tau>2\\<rightarrow>* s2''\n  s2'' -2-tl2\\<rightarrow> s2'''\n  \\<not> \\<tau>move2 s2'' tl2 s2'''\n  s1'' \\<approx> s2'''\n  tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))", "ultimately"], ["proof (chain)\npicking this:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  s1' \\<approx> s2'\n  s2' -\\<tau>2\\<rightarrow>* s2''\n  s2'' -2-tl2\\<rightarrow> s2'''\n  \\<not> \\<tau>move2 s2'' tl2 s2'''\n  s1'' \\<approx> s2'''\n  tl1 \\<sim> tl2", "have \"?P (tl2, s2''')\""], ["proof (prove)\nusing this:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  s1' \\<approx> s2'\n  s2' -\\<tau>2\\<rightarrow>* s2''\n  s2'' -2-tl2\\<rightarrow> s2'''\n  \\<not> \\<tau>move2 s2'' tl2 s2'''\n  s1'' \\<approx> s2'''\n  tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. case (tl2, s2''') of\n    (tl2, s2'') \\<Rightarrow>\n      \\<exists>s2'.\n         s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n         s2' -2-tl2\\<rightarrow> s2'' \\<and>\n         \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n         s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2", "by(blast intro: rtranclp_trans)"], ["proof (state)\nthis:\n  case (tl2, s2''') of\n  (tl2, s2'') \\<Rightarrow>\n    \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n       s2' -2-tl2\\<rightarrow> s2'' \\<and>\n       \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n       s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))", "hence \"?P (Eps ?P)\""], ["proof (prove)\nusing this:\n  case (tl2, s2''') of\n  (tl2, s2'') \\<Rightarrow>\n    \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n       s2' -2-tl2\\<rightarrow> s2'' \\<and>\n       \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n       s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. case SOME (tl2, s2'').\n            \\<exists>s2'.\n               s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n               s2' -2-tl2\\<rightarrow> s2'' \\<and>\n               \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n               s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2 of\n    (tl2, s2'') \\<Rightarrow>\n      \\<exists>s2'.\n         s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n         s2' -2-tl2\\<rightarrow> s2'' \\<and>\n         \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n         s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2", "by(rule someI)"], ["proof (state)\nthis:\n  case SOME (tl2, s2'').\n          \\<exists>s2'.\n             s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n             s2' -2-tl2\\<rightarrow> s2'' \\<and>\n             \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n             s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2 of\n  (tl2, s2'') \\<Rightarrow>\n    \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n       s2' -2-tl2\\<rightarrow> s2'' \\<and>\n       \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n       s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))", "hence ?Proceed"], ["proof (prove)\nusing this:\n  case SOME (tl2, s2'').\n          \\<exists>s2'.\n             s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n             s2' -2-tl2\\<rightarrow> s2'' \\<and>\n             \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n             s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2 of\n  (tl2, s2'') \\<Rightarrow>\n    \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n       s2' -2-tl2\\<rightarrow> s2'' \\<and>\n       \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n       s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. \\<exists>s s' s'' tls tl.\n       s2 = s \\<and>\n       tls1_to_tls2 s2 stlsss1 = TCons (tl, s'') tls \\<and>\n       s -\\<tau>2\\<rightarrow>* s' \\<and>\n       s' -2-tl\\<rightarrow> s'' \\<and>\n       \\<not> \\<tau>move2 s' tl s'' \\<and>\n       ((\\<exists>s2 s1 stlsss1.\n            s'' = s2 \\<and>\n            tls = tls1_to_tls2 s2 stlsss1 \\<and>\n            s1 \\<approx> s2 \\<and> trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n        trsys2.\\<tau>Runs_table s'' tls)", "using \\<open>stlsss1 = TCons (tl1, s1'') stlsss1'\\<close> \\<open>trsys1.\\<tau>Runs_table s1'' stlsss1'\\<close>"], ["proof (prove)\nusing this:\n  case SOME (tl2, s2'').\n          \\<exists>s2'.\n             s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n             s2' -2-tl2\\<rightarrow> s2'' \\<and>\n             \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n             s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2 of\n  (tl2, s2'') \\<Rightarrow>\n    \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n       s2' -2-tl2\\<rightarrow> s2'' \\<and>\n       \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n       s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n  stlsss1 = TCons (tl1, s1'') stlsss1'\n  trsys1.\\<tau>Runs_table s1'' stlsss1'\n\ngoal (1 subgoal):\n 1. \\<exists>s s' s'' tls tl.\n       s2 = s \\<and>\n       tls1_to_tls2 s2 stlsss1 = TCons (tl, s'') tls \\<and>\n       s -\\<tau>2\\<rightarrow>* s' \\<and>\n       s' -2-tl\\<rightarrow> s'' \\<and>\n       \\<not> \\<tau>move2 s' tl s'' \\<and>\n       ((\\<exists>s2 s1 stlsss1.\n            s'' = s2 \\<and>\n            tls = tls1_to_tls2 s2 stlsss1 \\<and>\n            s1 \\<approx> s2 \\<and> trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n        trsys2.\\<tau>Runs_table s'' tls)", "by auto blast"], ["proof (state)\nthis:\n  \\<exists>s s' s'' tls tl.\n     s2 = s \\<and>\n     tls1_to_tls2 s2 stlsss1 = TCons (tl, s'') tls \\<and>\n     s -\\<tau>2\\<rightarrow>* s' \\<and>\n     s' -2-tl\\<rightarrow> s'' \\<and>\n     \\<not> \\<tau>move2 s' tl s'' \\<and>\n     ((\\<exists>s2 s1 stlsss1.\n          s'' = s2 \\<and>\n          tls = tls1_to_tls2 s2 stlsss1 \\<and>\n          s1 \\<approx> s2 \\<and> trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n      trsys2.\\<tau>Runs_table s'' tls)\n\ngoal (1 subgoal):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n                             s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s2 = s \\<and>\n                             tls1_to_tls2 s2 stlsss1 =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>2\\<rightarrow>* s' \\<and>\n                             s' -2-tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move2 s' tl s'' \\<and>\n                             ((\\<exists>s2 s1 stlsss1.\n                                  s'' = s2 \\<and>\n                                  tls = tls1_to_tls2 s2 stlsss1 \\<and>\n                                  s1 \\<approx> s2 \\<and>\n                                  trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n                              trsys2.\\<tau>Runs_table s'' tls))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s s' s'' tls tl.\n     s2 = s \\<and>\n     tls1_to_tls2 s2 stlsss1 = TCons (tl, s'') tls \\<and>\n     s -\\<tau>2\\<rightarrow>* s' \\<and>\n     s' -2-tl\\<rightarrow> s'' \\<and>\n     \\<not> \\<tau>move2 s' tl s'' \\<and>\n     ((\\<exists>s2 s1 stlsss1.\n          s'' = s2 \\<and>\n          tls = tls1_to_tls2 s2 stlsss1 \\<and>\n          s1 \\<approx> s2 \\<and> trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n      trsys2.\\<tau>Runs_table s'' tls)\n\ngoal (1 subgoal):\n 1. (\\<exists>s s'.\n        s2 = s \\<and>\n        tls1_to_tls2 s2 stlsss1 = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>2\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        s2 = s \\<and>\n        tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n        s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        s2 = s \\<and>\n        tls1_to_tls2 s2 stlsss1 = TCons (tl, s'') tls \\<and>\n        s -\\<tau>2\\<rightarrow>* s' \\<and>\n        s' -2-tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move2 s' tl s'' \\<and>\n        ((\\<exists>s2 s1 stlsss1.\n             s'' = s2 \\<and>\n             tls = tls1_to_tls2 s2 stlsss1 \\<and>\n             s1 \\<approx> s2 \\<and>\n             trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n         trsys2.\\<tau>Runs_table s'' tls))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>s s'.\n      s2 = s \\<and>\n      tls1_to_tls2 s2 stlsss1 = TNil \\<lfloor>s'\\<rfloor> \\<and>\n      s -\\<tau>2\\<rightarrow>* s' \\<and>\n      (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s.\n      s2 = s \\<and>\n      tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n      s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n  (\\<exists>s s' s'' tls tl.\n      s2 = s \\<and>\n      tls1_to_tls2 s2 stlsss1 = TCons (tl, s'') tls \\<and>\n      s -\\<tau>2\\<rightarrow>* s' \\<and>\n      s' -2-tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move2 s' tl s'' \\<and>\n      ((\\<exists>s2 s1 stlsss1.\n           s'' = s2 \\<and>\n           tls = tls1_to_tls2 s2 stlsss1 \\<and>\n           s1 \\<approx> s2 \\<and> trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n       trsys2.\\<tau>Runs_table s'' tls))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>s s'.\n      s2 = s \\<and>\n      tls1_to_tls2 s2 stlsss1 = TNil \\<lfloor>s'\\<rfloor> \\<and>\n      s -\\<tau>2\\<rightarrow>* s' \\<and>\n      (\\<forall>x xa. \\<not> s' -2-x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s.\n      s2 = s \\<and>\n      tls1_to_tls2 s2 stlsss1 = TNil None \\<and>\n      s -\\<tau>2\\<rightarrow> \\<infinity>) \\<or>\n  (\\<exists>s s' s'' tls tl.\n      s2 = s \\<and>\n      tls1_to_tls2 s2 stlsss1 = TCons (tl, s'') tls \\<and>\n      s -\\<tau>2\\<rightarrow>* s' \\<and>\n      s' -2-tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move2 s' tl s'' \\<and>\n      ((\\<exists>s2 s1 stlsss1.\n           s'' = s2 \\<and>\n           tls = tls1_to_tls2 s2 stlsss1 \\<and>\n           s1 \\<approx> s2 \\<and> trsys1.\\<tau>Runs_table s1 stlsss1) \\<or>\n       trsys2.\\<tau>Runs_table s'' tls))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trsys2.\\<tau>Runs_table s2 (tls1_to_tls2 s2 stlsss1)\n\ngoal (1 subgoal):\n 1. tllist_all2\n     (\\<lambda>(tl1, s1'') (tl2, s2'').\n         tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n     (rel_option bisim) stlsss1\n     (unfold_tllist (\\<lambda>(s2, y). is_TNil y)\n       (\\<lambda>(s2, stlsss1).\n           map_option\n            (\\<lambda>s1'.\n                SOME s2'.\n                   s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                   (\\<forall>tl s2''. \\<not> s2' -2-tl\\<rightarrow>\n                       s2'') \\<and>\n                   s1' \\<approx> s2')\n            (terminal stlsss1))\n       (\\<lambda>(s2, stlsss1).\n           let (x, y) =\n                 SOME (tl2, s2'').\n                    \\<exists>s2'.\n                       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                       s2' -2-tl2\\<rightarrow> s2'' \\<and>\n                       \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n                       snd (thd stlsss1) \\<approx> s2'' \\<and>\n                       fst (thd stlsss1) \\<sim> tl2\n           in (x, y))\n       (\\<lambda>(s2, stlsss1).\n           let (tl2, s2'') =\n                 SOME (tl2, s2'').\n                    \\<exists>s2'.\n                       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                       s2' -2-tl2\\<rightarrow> s2'' \\<and>\n                       \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n                       snd (thd stlsss1) \\<approx> s2'' \\<and>\n                       fst (thd stlsss1) \\<sim> tl2\n           in (s2'', ttl stlsss1))\n       (s2, stlsss1))", "let ?Tlsim = \"\\<lambda>(tl1, s1'') (tl2, s2''). tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2''\""], ["proof (state)\ngoal (1 subgoal):\n 1. tllist_all2\n     (\\<lambda>(tl1, s1'') (tl2, s2'').\n         tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n     (rel_option bisim) stlsss1\n     (unfold_tllist (\\<lambda>(s2, y). is_TNil y)\n       (\\<lambda>(s2, stlsss1).\n           map_option\n            (\\<lambda>s1'.\n                SOME s2'.\n                   s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                   (\\<forall>tl s2''. \\<not> s2' -2-tl\\<rightarrow>\n                       s2'') \\<and>\n                   s1' \\<approx> s2')\n            (terminal stlsss1))\n       (\\<lambda>(s2, stlsss1).\n           let (x, y) =\n                 SOME (tl2, s2'').\n                    \\<exists>s2'.\n                       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                       s2' -2-tl2\\<rightarrow> s2'' \\<and>\n                       \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n                       snd (thd stlsss1) \\<approx> s2'' \\<and>\n                       fst (thd stlsss1) \\<sim> tl2\n           in (x, y))\n       (\\<lambda>(s2, stlsss1).\n           let (tl2, s2'') =\n                 SOME (tl2, s2'').\n                    \\<exists>s2'.\n                       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                       s2' -2-tl2\\<rightarrow> s2'' \\<and>\n                       \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n                       snd (thd stlsss1) \\<approx> s2'' \\<and>\n                       fst (thd stlsss1) \\<sim> tl2\n           in (s2'', ttl stlsss1))\n       (s2, stlsss1))", "let ?Bisim = \"rel_option bisim\""], ["proof (state)\ngoal (1 subgoal):\n 1. tllist_all2\n     (\\<lambda>(tl1, s1'') (tl2, s2'').\n         tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n     (rel_option bisim) stlsss1\n     (unfold_tllist (\\<lambda>(s2, y). is_TNil y)\n       (\\<lambda>(s2, stlsss1).\n           map_option\n            (\\<lambda>s1'.\n                SOME s2'.\n                   s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                   (\\<forall>tl s2''. \\<not> s2' -2-tl\\<rightarrow>\n                       s2'') \\<and>\n                   s1' \\<approx> s2')\n            (terminal stlsss1))\n       (\\<lambda>(s2, stlsss1).\n           let (x, y) =\n                 SOME (tl2, s2'').\n                    \\<exists>s2'.\n                       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                       s2' -2-tl2\\<rightarrow> s2'' \\<and>\n                       \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n                       snd (thd stlsss1) \\<approx> s2'' \\<and>\n                       fst (thd stlsss1) \\<sim> tl2\n           in (x, y))\n       (\\<lambda>(s2, stlsss1).\n           let (tl2, s2'') =\n                 SOME (tl2, s2'').\n                    \\<exists>s2'.\n                       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                       s2' -2-tl2\\<rightarrow> s2'' \\<and>\n                       \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n                       snd (thd stlsss1) \\<approx> s2'' \\<and>\n                       fst (thd stlsss1) \\<sim> tl2\n           in (s2'', ttl stlsss1))\n       (s2, stlsss1))", "from run1 bisim"], ["proof (chain)\npicking this:\n  trsys1.\\<tau>Runs_table s1 stlsss1\n  s1 \\<approx> s2", "show \"tllist_all2 ?Tlsim ?Bisim stlsss1 (tls1_to_tls2 s2 stlsss1)\""], ["proof (prove)\nusing this:\n  trsys1.\\<tau>Runs_table s1 stlsss1\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. tllist_all2\n     (\\<lambda>(tl1, s1'') (tl2, s2'').\n         tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n     (rel_option bisim) stlsss1 (tls1_to_tls2 s2 stlsss1)", "proof(coinduction arbitrary: s1 s2 stlsss1)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s1 s2 stlsss1.\n       \\<lbrakk>trsys1.\\<tau>Runs_table s1 stlsss1; s1 \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> is_TNil stlsss1 =\n                         is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                         (is_TNil stlsss1 \\<longrightarrow>\n                          is_TNil\n                           (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                          rel_option bisim (terminal stlsss1)\n                           (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                         (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tls1_to_tls2 s2\n                                    stlsss1) \\<longrightarrow>\n                          (case thd stlsss1 of\n                           (tl1, s1'') \\<Rightarrow>\n                             \\<lambda>(tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                           (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                          ((\\<exists>s1 s2a stlsss1a.\n                               ttl stlsss1 = stlsss1a \\<and>\n                               ttl (tls1_to_tls2 s2 stlsss1) =\n                               tls1_to_tls2 s2a stlsss1a \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1a \\<and> s1\n                               \\<approx> s2a) \\<or>\n                           tllist_all2\n                            (\\<lambda>(tl1, s1'') (tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                            (rel_option bisim) (ttl stlsss1)\n                            (ttl (tls1_to_tls2 s2 stlsss1))))", "case (tllist_all2 s1 s2 stlsss1)"], ["proof (state)\nthis:\n  trsys1.\\<tau>Runs_table s1 stlsss1\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2 stlsss1.\n       \\<lbrakk>trsys1.\\<tau>Runs_table s1 stlsss1; s1 \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> is_TNil stlsss1 =\n                         is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                         (is_TNil stlsss1 \\<longrightarrow>\n                          is_TNil\n                           (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                          rel_option bisim (terminal stlsss1)\n                           (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                         (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tls1_to_tls2 s2\n                                    stlsss1) \\<longrightarrow>\n                          (case thd stlsss1 of\n                           (tl1, s1'') \\<Rightarrow>\n                             \\<lambda>(tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                           (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                          ((\\<exists>s1 s2a stlsss1a.\n                               ttl stlsss1 = stlsss1a \\<and>\n                               ttl (tls1_to_tls2 s2 stlsss1) =\n                               tls1_to_tls2 s2a stlsss1a \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1a \\<and> s1\n                               \\<approx> s2a) \\<or>\n                           tllist_all2\n                            (\\<lambda>(tl1, s1'') (tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                            (rel_option bisim) (ttl stlsss1)\n                            (ttl (tls1_to_tls2 s2 stlsss1))))", "note Runs = \\<open>trsys1.\\<tau>Runs_table s1 stlsss1\\<close> and bisim = \\<open>s1 \\<approx> s2\\<close>"], ["proof (state)\nthis:\n  trsys1.\\<tau>Runs_table s1 stlsss1\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2 stlsss1.\n       \\<lbrakk>trsys1.\\<tau>Runs_table s1 stlsss1; s1 \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> is_TNil stlsss1 =\n                         is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                         (is_TNil stlsss1 \\<longrightarrow>\n                          is_TNil\n                           (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                          rel_option bisim (terminal stlsss1)\n                           (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                         (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tls1_to_tls2 s2\n                                    stlsss1) \\<longrightarrow>\n                          (case thd stlsss1 of\n                           (tl1, s1'') \\<Rightarrow>\n                             \\<lambda>(tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                           (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                          ((\\<exists>s1 s2a stlsss1a.\n                               ttl stlsss1 = stlsss1a \\<and>\n                               ttl (tls1_to_tls2 s2 stlsss1) =\n                               tls1_to_tls2 s2a stlsss1a \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1a \\<and> s1\n                               \\<approx> s2a) \\<or>\n                           tllist_all2\n                            (\\<lambda>(tl1, s1'') (tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                            (rel_option bisim) (ttl stlsss1)\n                            (ttl (tls1_to_tls2 s2 stlsss1))))", "from Runs"], ["proof (chain)\npicking this:\n  trsys1.\\<tau>Runs_table s1 stlsss1", "show ?case"], ["proof (prove)\nusing this:\n  trsys1.\\<tau>Runs_table s1 stlsss1\n\ngoal (1 subgoal):\n 1. is_TNil stlsss1 = is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n    (is_TNil stlsss1 \\<longrightarrow>\n     is_TNil (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n     rel_option bisim (terminal stlsss1)\n      (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n    (\\<not> is_TNil stlsss1 \\<longrightarrow>\n     \\<not> is_TNil (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n     (case thd stlsss1 of\n      (tl1, s1'') \\<Rightarrow>\n        \\<lambda>(tl2, s2''). tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n      (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n     ((\\<exists>s1 s2 stlsss1.\n          ttl stlsss1 = stlsss1 \\<and>\n          ttl (tls1_to_tls2 s2 stlsss1) = tls1_to_tls2 s2 stlsss1 \\<and>\n          trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1 \\<approx> s2) \\<or>\n      tllist_all2\n       (\\<lambda>(tl1, s1'') (tl2, s2'').\n           tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n       (rel_option bisim) (ttl stlsss1) (ttl (tls1_to_tls2 s2 stlsss1))))", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>stlsss1 = TNil \\<lfloor>s'\\<rfloor>;\n        s1 -\\<tau>1\\<rightarrow>* s';\n        \\<And>tl s''. \\<not> s' -1-tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> is_TNil stlsss1 =\n                         is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                         (is_TNil stlsss1 \\<longrightarrow>\n                          is_TNil\n                           (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                          rel_option bisim (terminal stlsss1)\n                           (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                         (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tls1_to_tls2 s2\n                                    stlsss1) \\<longrightarrow>\n                          (case thd stlsss1 of\n                           (tl1, s1'') \\<Rightarrow>\n                             \\<lambda>(tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                           (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                          ((\\<exists>s1 s2 stlsss1.\n                               ttl stlsss1 = stlsss1 \\<and>\n                               ttl (tls1_to_tls2 s2 stlsss1) =\n                               tls1_to_tls2 s2 stlsss1 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                               \\<approx> s2) \\<or>\n                           tllist_all2\n                            (\\<lambda>(tl1, s1'') (tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                            (rel_option bisim) (ttl stlsss1)\n                            (ttl (tls1_to_tls2 s2 stlsss1))))\n 2. \\<lbrakk>stlsss1 = TNil None;\n     s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> is_TNil stlsss1 =\n                      is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                      (is_TNil stlsss1 \\<longrightarrow>\n                       is_TNil (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       rel_option bisim (terminal stlsss1)\n                        (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                      (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                       \\<not> is_TNil\n                               (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       (case thd stlsss1 of\n                        (tl1, s1'') \\<Rightarrow>\n                          \\<lambda>(tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                        (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                       ((\\<exists>s1 s2 stlsss1.\n                            ttl stlsss1 = stlsss1 \\<and>\n                            ttl (tls1_to_tls2 s2 stlsss1) =\n                            tls1_to_tls2 s2 stlsss1 \\<and>\n                            trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                            \\<approx> s2) \\<or>\n                        tllist_all2\n                         (\\<lambda>(tl1, s1'') (tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                         (rel_option bisim) (ttl stlsss1)\n                         (ttl (tls1_to_tls2 s2 stlsss1))))\n 3. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> is_TNil stlsss1 =\n                         is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                         (is_TNil stlsss1 \\<longrightarrow>\n                          is_TNil\n                           (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                          rel_option bisim (terminal stlsss1)\n                           (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                         (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tls1_to_tls2 s2\n                                    stlsss1) \\<longrightarrow>\n                          (case thd stlsss1 of\n                           (tl1, s1'') \\<Rightarrow>\n                             \\<lambda>(tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                           (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                          ((\\<exists>s1 s2 stlsss1.\n                               ttl stlsss1 = stlsss1 \\<and>\n                               ttl (tls1_to_tls2 s2 stlsss1) =\n                               tls1_to_tls2 s2 stlsss1 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                               \\<approx> s2) \\<or>\n                           tllist_all2\n                            (\\<lambda>(tl1, s1'') (tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                            (rel_option bisim) (ttl stlsss1)\n                            (ttl (tls1_to_tls2 s2 stlsss1))))", "case (Terminate s1')"], ["proof (state)\nthis:\n  stlsss1 = TNil \\<lfloor>s1'\\<rfloor>\n  s1 -\\<tau>1\\<rightarrow>* s1'\n  \\<not> s1' -1-?tl1\\<rightarrow> ?s''1\n\ngoal (3 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>stlsss1 = TNil \\<lfloor>s'\\<rfloor>;\n        s1 -\\<tau>1\\<rightarrow>* s';\n        \\<And>tl s''. \\<not> s' -1-tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> is_TNil stlsss1 =\n                         is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                         (is_TNil stlsss1 \\<longrightarrow>\n                          is_TNil\n                           (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                          rel_option bisim (terminal stlsss1)\n                           (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                         (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tls1_to_tls2 s2\n                                    stlsss1) \\<longrightarrow>\n                          (case thd stlsss1 of\n                           (tl1, s1'') \\<Rightarrow>\n                             \\<lambda>(tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                           (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                          ((\\<exists>s1 s2 stlsss1.\n                               ttl stlsss1 = stlsss1 \\<and>\n                               ttl (tls1_to_tls2 s2 stlsss1) =\n                               tls1_to_tls2 s2 stlsss1 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                               \\<approx> s2) \\<or>\n                           tllist_all2\n                            (\\<lambda>(tl1, s1'') (tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                            (rel_option bisim) (ttl stlsss1)\n                            (ttl (tls1_to_tls2 s2 stlsss1))))\n 2. \\<lbrakk>stlsss1 = TNil None;\n     s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> is_TNil stlsss1 =\n                      is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                      (is_TNil stlsss1 \\<longrightarrow>\n                       is_TNil (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       rel_option bisim (terminal stlsss1)\n                        (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                      (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                       \\<not> is_TNil\n                               (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       (case thd stlsss1 of\n                        (tl1, s1'') \\<Rightarrow>\n                          \\<lambda>(tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                        (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                       ((\\<exists>s1 s2 stlsss1.\n                            ttl stlsss1 = stlsss1 \\<and>\n                            ttl (tls1_to_tls2 s2 stlsss1) =\n                            tls1_to_tls2 s2 stlsss1 \\<and>\n                            trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                            \\<approx> s2) \\<or>\n                        tllist_all2\n                         (\\<lambda>(tl1, s1'') (tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                         (rel_option bisim) (ttl stlsss1)\n                         (ttl (tls1_to_tls2 s2 stlsss1))))\n 3. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> is_TNil stlsss1 =\n                         is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                         (is_TNil stlsss1 \\<longrightarrow>\n                          is_TNil\n                           (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                          rel_option bisim (terminal stlsss1)\n                           (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                         (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tls1_to_tls2 s2\n                                    stlsss1) \\<longrightarrow>\n                          (case thd stlsss1 of\n                           (tl1, s1'') \\<Rightarrow>\n                             \\<lambda>(tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                           (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                          ((\\<exists>s1 s2 stlsss1.\n                               ttl stlsss1 = stlsss1 \\<and>\n                               ttl (tls1_to_tls2 s2 stlsss1) =\n                               tls1_to_tls2 s2 stlsss1 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                               \\<approx> s2) \\<or>\n                           tllist_all2\n                            (\\<lambda>(tl1, s1'') (tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                            (rel_option bisim) (ttl stlsss1)\n                            (ttl (tls1_to_tls2 s2 stlsss1))))", "let ?P = \"\\<lambda>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> (\\<forall>tl2 s2''. \\<not> s2' -2-tl2\\<rightarrow> s2'') \\<and> s1' \\<approx> s2'\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>stlsss1 = TNil \\<lfloor>s'\\<rfloor>;\n        s1 -\\<tau>1\\<rightarrow>* s';\n        \\<And>tl s''. \\<not> s' -1-tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> is_TNil stlsss1 =\n                         is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                         (is_TNil stlsss1 \\<longrightarrow>\n                          is_TNil\n                           (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                          rel_option bisim (terminal stlsss1)\n                           (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                         (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tls1_to_tls2 s2\n                                    stlsss1) \\<longrightarrow>\n                          (case thd stlsss1 of\n                           (tl1, s1'') \\<Rightarrow>\n                             \\<lambda>(tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                           (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                          ((\\<exists>s1 s2 stlsss1.\n                               ttl stlsss1 = stlsss1 \\<and>\n                               ttl (tls1_to_tls2 s2 stlsss1) =\n                               tls1_to_tls2 s2 stlsss1 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                               \\<approx> s2) \\<or>\n                           tllist_all2\n                            (\\<lambda>(tl1, s1'') (tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                            (rel_option bisim) (ttl stlsss1)\n                            (ttl (tls1_to_tls2 s2 stlsss1))))\n 2. \\<lbrakk>stlsss1 = TNil None;\n     s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> is_TNil stlsss1 =\n                      is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                      (is_TNil stlsss1 \\<longrightarrow>\n                       is_TNil (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       rel_option bisim (terminal stlsss1)\n                        (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                      (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                       \\<not> is_TNil\n                               (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       (case thd stlsss1 of\n                        (tl1, s1'') \\<Rightarrow>\n                          \\<lambda>(tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                        (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                       ((\\<exists>s1 s2 stlsss1.\n                            ttl stlsss1 = stlsss1 \\<and>\n                            ttl (tls1_to_tls2 s2 stlsss1) =\n                            tls1_to_tls2 s2 stlsss1 \\<and>\n                            trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                            \\<approx> s2) \\<or>\n                        tllist_all2\n                         (\\<lambda>(tl1, s1'') (tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                         (rel_option bisim) (ttl stlsss1)\n                         (ttl (tls1_to_tls2 s2 stlsss1))))\n 3. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> is_TNil stlsss1 =\n                         is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                         (is_TNil stlsss1 \\<longrightarrow>\n                          is_TNil\n                           (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                          rel_option bisim (terminal stlsss1)\n                           (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                         (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tls1_to_tls2 s2\n                                    stlsss1) \\<longrightarrow>\n                          (case thd stlsss1 of\n                           (tl1, s1'') \\<Rightarrow>\n                             \\<lambda>(tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                           (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                          ((\\<exists>s1 s2 stlsss1.\n                               ttl stlsss1 = stlsss1 \\<and>\n                               ttl (tls1_to_tls2 s2 stlsss1) =\n                               tls1_to_tls2 s2 stlsss1 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                               \\<approx> s2) \\<or>\n                           tllist_all2\n                            (\\<lambda>(tl1, s1'') (tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                            (rel_option bisim) (ttl stlsss1)\n                            (ttl (tls1_to_tls2 s2 stlsss1))))", "from simulation_silents1[OF bisim \\<open>s1 -\\<tau>1\\<rightarrow>* s1'\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2'", "obtain s2' where \"s2 -\\<tau>2\\<rightarrow>* s2'\" and \"s1' \\<approx> s2'\""], ["proof (prove)\nusing this:\n  \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2'\n\ngoal (1 subgoal):\n 1. (\\<And>s2'.\n        \\<lbrakk>s2 -\\<tau>2\\<rightarrow>* s2'; s1' \\<approx> s2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  s1' \\<approx> s2'\n\ngoal (3 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>stlsss1 = TNil \\<lfloor>s'\\<rfloor>;\n        s1 -\\<tau>1\\<rightarrow>* s';\n        \\<And>tl s''. \\<not> s' -1-tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> is_TNil stlsss1 =\n                         is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                         (is_TNil stlsss1 \\<longrightarrow>\n                          is_TNil\n                           (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                          rel_option bisim (terminal stlsss1)\n                           (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                         (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tls1_to_tls2 s2\n                                    stlsss1) \\<longrightarrow>\n                          (case thd stlsss1 of\n                           (tl1, s1'') \\<Rightarrow>\n                             \\<lambda>(tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                           (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                          ((\\<exists>s1 s2 stlsss1.\n                               ttl stlsss1 = stlsss1 \\<and>\n                               ttl (tls1_to_tls2 s2 stlsss1) =\n                               tls1_to_tls2 s2 stlsss1 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                               \\<approx> s2) \\<or>\n                           tllist_all2\n                            (\\<lambda>(tl1, s1'') (tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                            (rel_option bisim) (ttl stlsss1)\n                            (ttl (tls1_to_tls2 s2 stlsss1))))\n 2. \\<lbrakk>stlsss1 = TNil None;\n     s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> is_TNil stlsss1 =\n                      is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                      (is_TNil stlsss1 \\<longrightarrow>\n                       is_TNil (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       rel_option bisim (terminal stlsss1)\n                        (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                      (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                       \\<not> is_TNil\n                               (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       (case thd stlsss1 of\n                        (tl1, s1'') \\<Rightarrow>\n                          \\<lambda>(tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                        (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                       ((\\<exists>s1 s2 stlsss1.\n                            ttl stlsss1 = stlsss1 \\<and>\n                            ttl (tls1_to_tls2 s2 stlsss1) =\n                            tls1_to_tls2 s2 stlsss1 \\<and>\n                            trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                            \\<approx> s2) \\<or>\n                        tllist_all2\n                         (\\<lambda>(tl1, s1'') (tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                         (rel_option bisim) (ttl stlsss1)\n                         (ttl (tls1_to_tls2 s2 stlsss1))))\n 3. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> is_TNil stlsss1 =\n                         is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                         (is_TNil stlsss1 \\<longrightarrow>\n                          is_TNil\n                           (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                          rel_option bisim (terminal stlsss1)\n                           (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                         (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tls1_to_tls2 s2\n                                    stlsss1) \\<longrightarrow>\n                          (case thd stlsss1 of\n                           (tl1, s1'') \\<Rightarrow>\n                             \\<lambda>(tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                           (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                          ((\\<exists>s1 s2 stlsss1.\n                               ttl stlsss1 = stlsss1 \\<and>\n                               ttl (tls1_to_tls2 s2 stlsss1) =\n                               tls1_to_tls2 s2 stlsss1 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                               \\<approx> s2) \\<or>\n                           tllist_all2\n                            (\\<lambda>(tl1, s1'') (tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                            (rel_option bisim) (ttl stlsss1)\n                            (ttl (tls1_to_tls2 s2 stlsss1))))", "moreover"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  s1' \\<approx> s2'\n\ngoal (3 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>stlsss1 = TNil \\<lfloor>s'\\<rfloor>;\n        s1 -\\<tau>1\\<rightarrow>* s';\n        \\<And>tl s''. \\<not> s' -1-tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> is_TNil stlsss1 =\n                         is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                         (is_TNil stlsss1 \\<longrightarrow>\n                          is_TNil\n                           (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                          rel_option bisim (terminal stlsss1)\n                           (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                         (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tls1_to_tls2 s2\n                                    stlsss1) \\<longrightarrow>\n                          (case thd stlsss1 of\n                           (tl1, s1'') \\<Rightarrow>\n                             \\<lambda>(tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                           (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                          ((\\<exists>s1 s2 stlsss1.\n                               ttl stlsss1 = stlsss1 \\<and>\n                               ttl (tls1_to_tls2 s2 stlsss1) =\n                               tls1_to_tls2 s2 stlsss1 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                               \\<approx> s2) \\<or>\n                           tllist_all2\n                            (\\<lambda>(tl1, s1'') (tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                            (rel_option bisim) (ttl stlsss1)\n                            (ttl (tls1_to_tls2 s2 stlsss1))))\n 2. \\<lbrakk>stlsss1 = TNil None;\n     s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> is_TNil stlsss1 =\n                      is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                      (is_TNil stlsss1 \\<longrightarrow>\n                       is_TNil (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       rel_option bisim (terminal stlsss1)\n                        (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                      (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                       \\<not> is_TNil\n                               (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       (case thd stlsss1 of\n                        (tl1, s1'') \\<Rightarrow>\n                          \\<lambda>(tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                        (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                       ((\\<exists>s1 s2 stlsss1.\n                            ttl stlsss1 = stlsss1 \\<and>\n                            ttl (tls1_to_tls2 s2 stlsss1) =\n                            tls1_to_tls2 s2 stlsss1 \\<and>\n                            trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                            \\<approx> s2) \\<or>\n                        tllist_all2\n                         (\\<lambda>(tl1, s1'') (tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                         (rel_option bisim) (ttl stlsss1)\n                         (ttl (tls1_to_tls2 s2 stlsss1))))\n 3. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> is_TNil stlsss1 =\n                         is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                         (is_TNil stlsss1 \\<longrightarrow>\n                          is_TNil\n                           (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                          rel_option bisim (terminal stlsss1)\n                           (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                         (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tls1_to_tls2 s2\n                                    stlsss1) \\<longrightarrow>\n                          (case thd stlsss1 of\n                           (tl1, s1'') \\<Rightarrow>\n                             \\<lambda>(tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                           (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                          ((\\<exists>s1 s2 stlsss1.\n                               ttl stlsss1 = stlsss1 \\<and>\n                               ttl (tls1_to_tls2 s2 stlsss1) =\n                               tls1_to_tls2 s2 stlsss1 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                               \\<approx> s2) \\<or>\n                           tllist_all2\n                            (\\<lambda>(tl1, s1'') (tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                            (rel_option bisim) (ttl stlsss1)\n                            (ttl (tls1_to_tls2 s2 stlsss1))))", "from no_move1_to_no_move2[OF \\<open>s1' \\<approx> s2'\\<close> \\<open>\\<And>tl1 s1''. \\<not> s1' -1-tl1\\<rightarrow> s1''\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>s2'a.\n     s2' -\\<tau>2\\<rightarrow>* s2'a \\<and>\n     (\\<forall>tl2 s2''. \\<not> s2'a -2-tl2\\<rightarrow> s2'') \\<and> s1'\n     \\<approx> s2'a", "obtain s2'' where \"s2' -\\<tau>2\\<rightarrow>* s2''\" and \"s1' \\<approx> s2''\"\n        and \"\\<And>tl2 s2'''. \\<not> s2'' -2-tl2\\<rightarrow> s2'''\""], ["proof (prove)\nusing this:\n  \\<exists>s2'a.\n     s2' -\\<tau>2\\<rightarrow>* s2'a \\<and>\n     (\\<forall>tl2 s2''. \\<not> s2'a -2-tl2\\<rightarrow> s2'') \\<and> s1'\n     \\<approx> s2'a\n\ngoal (1 subgoal):\n 1. (\\<And>s2''.\n        \\<lbrakk>s2' -\\<tau>2\\<rightarrow>* s2''; s1' \\<approx> s2'';\n         \\<And>tl2 s2'''. \\<not> s2'' -2-tl2\\<rightarrow> s2'''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s2' -\\<tau>2\\<rightarrow>* s2''\n  s1' \\<approx> s2''\n  \\<not> s2'' -2-?tl2.1\\<rightarrow> ?s2'''1\n\ngoal (3 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>stlsss1 = TNil \\<lfloor>s'\\<rfloor>;\n        s1 -\\<tau>1\\<rightarrow>* s';\n        \\<And>tl s''. \\<not> s' -1-tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> is_TNil stlsss1 =\n                         is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                         (is_TNil stlsss1 \\<longrightarrow>\n                          is_TNil\n                           (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                          rel_option bisim (terminal stlsss1)\n                           (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                         (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tls1_to_tls2 s2\n                                    stlsss1) \\<longrightarrow>\n                          (case thd stlsss1 of\n                           (tl1, s1'') \\<Rightarrow>\n                             \\<lambda>(tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                           (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                          ((\\<exists>s1 s2 stlsss1.\n                               ttl stlsss1 = stlsss1 \\<and>\n                               ttl (tls1_to_tls2 s2 stlsss1) =\n                               tls1_to_tls2 s2 stlsss1 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                               \\<approx> s2) \\<or>\n                           tllist_all2\n                            (\\<lambda>(tl1, s1'') (tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                            (rel_option bisim) (ttl stlsss1)\n                            (ttl (tls1_to_tls2 s2 stlsss1))))\n 2. \\<lbrakk>stlsss1 = TNil None;\n     s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> is_TNil stlsss1 =\n                      is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                      (is_TNil stlsss1 \\<longrightarrow>\n                       is_TNil (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       rel_option bisim (terminal stlsss1)\n                        (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                      (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                       \\<not> is_TNil\n                               (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       (case thd stlsss1 of\n                        (tl1, s1'') \\<Rightarrow>\n                          \\<lambda>(tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                        (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                       ((\\<exists>s1 s2 stlsss1.\n                            ttl stlsss1 = stlsss1 \\<and>\n                            ttl (tls1_to_tls2 s2 stlsss1) =\n                            tls1_to_tls2 s2 stlsss1 \\<and>\n                            trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                            \\<approx> s2) \\<or>\n                        tllist_all2\n                         (\\<lambda>(tl1, s1'') (tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                         (rel_option bisim) (ttl stlsss1)\n                         (ttl (tls1_to_tls2 s2 stlsss1))))\n 3. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> is_TNil stlsss1 =\n                         is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                         (is_TNil stlsss1 \\<longrightarrow>\n                          is_TNil\n                           (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                          rel_option bisim (terminal stlsss1)\n                           (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                         (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tls1_to_tls2 s2\n                                    stlsss1) \\<longrightarrow>\n                          (case thd stlsss1 of\n                           (tl1, s1'') \\<Rightarrow>\n                             \\<lambda>(tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                           (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                          ((\\<exists>s1 s2 stlsss1.\n                               ttl stlsss1 = stlsss1 \\<and>\n                               ttl (tls1_to_tls2 s2 stlsss1) =\n                               tls1_to_tls2 s2 stlsss1 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                               \\<approx> s2) \\<or>\n                           tllist_all2\n                            (\\<lambda>(tl1, s1'') (tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                            (rel_option bisim) (ttl stlsss1)\n                            (ttl (tls1_to_tls2 s2 stlsss1))))", "ultimately"], ["proof (chain)\npicking this:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  s1' \\<approx> s2'\n  s2' -\\<tau>2\\<rightarrow>* s2''\n  s1' \\<approx> s2''\n  \\<not> s2'' -2-?tl2.1\\<rightarrow> ?s2'''1", "have \"?P s2''\""], ["proof (prove)\nusing this:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  s1' \\<approx> s2'\n  s2' -\\<tau>2\\<rightarrow>* s2''\n  s1' \\<approx> s2''\n  \\<not> s2'' -2-?tl2.1\\<rightarrow> ?s2'''1\n\ngoal (1 subgoal):\n 1. s2 -\\<tau>2\\<rightarrow>* s2'' \\<and>\n    (\\<forall>tl2 s2''a. \\<not> s2'' -2-tl2\\<rightarrow> s2''a) \\<and> s1'\n    \\<approx> s2''", "by(blast intro: rtranclp_trans)"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow>* s2'' \\<and>\n  (\\<forall>tl2 s2''a. \\<not> s2'' -2-tl2\\<rightarrow> s2''a) \\<and> s1'\n  \\<approx> s2''\n\ngoal (3 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>stlsss1 = TNil \\<lfloor>s'\\<rfloor>;\n        s1 -\\<tau>1\\<rightarrow>* s';\n        \\<And>tl s''. \\<not> s' -1-tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> is_TNil stlsss1 =\n                         is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                         (is_TNil stlsss1 \\<longrightarrow>\n                          is_TNil\n                           (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                          rel_option bisim (terminal stlsss1)\n                           (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                         (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tls1_to_tls2 s2\n                                    stlsss1) \\<longrightarrow>\n                          (case thd stlsss1 of\n                           (tl1, s1'') \\<Rightarrow>\n                             \\<lambda>(tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                           (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                          ((\\<exists>s1 s2 stlsss1.\n                               ttl stlsss1 = stlsss1 \\<and>\n                               ttl (tls1_to_tls2 s2 stlsss1) =\n                               tls1_to_tls2 s2 stlsss1 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                               \\<approx> s2) \\<or>\n                           tllist_all2\n                            (\\<lambda>(tl1, s1'') (tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                            (rel_option bisim) (ttl stlsss1)\n                            (ttl (tls1_to_tls2 s2 stlsss1))))\n 2. \\<lbrakk>stlsss1 = TNil None;\n     s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> is_TNil stlsss1 =\n                      is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                      (is_TNil stlsss1 \\<longrightarrow>\n                       is_TNil (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       rel_option bisim (terminal stlsss1)\n                        (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                      (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                       \\<not> is_TNil\n                               (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       (case thd stlsss1 of\n                        (tl1, s1'') \\<Rightarrow>\n                          \\<lambda>(tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                        (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                       ((\\<exists>s1 s2 stlsss1.\n                            ttl stlsss1 = stlsss1 \\<and>\n                            ttl (tls1_to_tls2 s2 stlsss1) =\n                            tls1_to_tls2 s2 stlsss1 \\<and>\n                            trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                            \\<approx> s2) \\<or>\n                        tllist_all2\n                         (\\<lambda>(tl1, s1'') (tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                         (rel_option bisim) (ttl stlsss1)\n                         (ttl (tls1_to_tls2 s2 stlsss1))))\n 3. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> is_TNil stlsss1 =\n                         is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                         (is_TNil stlsss1 \\<longrightarrow>\n                          is_TNil\n                           (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                          rel_option bisim (terminal stlsss1)\n                           (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                         (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tls1_to_tls2 s2\n                                    stlsss1) \\<longrightarrow>\n                          (case thd stlsss1 of\n                           (tl1, s1'') \\<Rightarrow>\n                             \\<lambda>(tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                           (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                          ((\\<exists>s1 s2 stlsss1.\n                               ttl stlsss1 = stlsss1 \\<and>\n                               ttl (tls1_to_tls2 s2 stlsss1) =\n                               tls1_to_tls2 s2 stlsss1 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                               \\<approx> s2) \\<or>\n                           tllist_all2\n                            (\\<lambda>(tl1, s1'') (tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                            (rel_option bisim) (ttl stlsss1)\n                            (ttl (tls1_to_tls2 s2 stlsss1))))", "hence \"?P (Eps ?P)\""], ["proof (prove)\nusing this:\n  s2 -\\<tau>2\\<rightarrow>* s2'' \\<and>\n  (\\<forall>tl2 s2''a. \\<not> s2'' -2-tl2\\<rightarrow> s2''a) \\<and> s1'\n  \\<approx> s2''\n\ngoal (1 subgoal):\n 1. s2 -\\<tau>2\\<rightarrow>* (SOME s2'.\n                                  s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                                  (\\<forall>tl2 s2''. \\<not> s2'\n-2-tl2\\<rightarrow> s2'') \\<and>\n                                  s1' \\<approx> s2') \\<and>\n    (\\<forall>tl2 s2''.\n        \\<not> (SOME s2'.\n                   s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                   (\\<forall>tl2 s2''. \\<not> s2' -2-tl2\\<rightarrow>\n                       s2'') \\<and>\n                   s1' \\<approx> s2')\n        -2-tl2\\<rightarrow> s2'') \\<and>\n    s1'\n    \\<approx> (SOME s2'.\n                  s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                  (\\<forall>tl2 s2''. \\<not> s2' -2-tl2\\<rightarrow>\n                      s2'') \\<and>\n                  s1' \\<approx> s2')", "by(rule someI)"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow>* (SOME s2'.\n                                s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                                (\\<forall>tl2 s2''. \\<not> s2'\n                                    -2-tl2\\<rightarrow> s2'') \\<and>\n                                s1' \\<approx> s2') \\<and>\n  (\\<forall>tl2 s2''.\n      \\<not> (SOME s2'.\n                 s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                 (\\<forall>tl2 s2''. \\<not> s2' -2-tl2\\<rightarrow>\n                     s2'') \\<and>\n                 s1' \\<approx> s2')\n      -2-tl2\\<rightarrow> s2'') \\<and>\n  s1'\n  \\<approx> (SOME s2'.\n                s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                (\\<forall>tl2 s2''. \\<not> s2' -2-tl2\\<rightarrow>\n                    s2'') \\<and>\n                s1' \\<approx> s2')\n\ngoal (3 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>stlsss1 = TNil \\<lfloor>s'\\<rfloor>;\n        s1 -\\<tau>1\\<rightarrow>* s';\n        \\<And>tl s''. \\<not> s' -1-tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> is_TNil stlsss1 =\n                         is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                         (is_TNil stlsss1 \\<longrightarrow>\n                          is_TNil\n                           (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                          rel_option bisim (terminal stlsss1)\n                           (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                         (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tls1_to_tls2 s2\n                                    stlsss1) \\<longrightarrow>\n                          (case thd stlsss1 of\n                           (tl1, s1'') \\<Rightarrow>\n                             \\<lambda>(tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                           (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                          ((\\<exists>s1 s2 stlsss1.\n                               ttl stlsss1 = stlsss1 \\<and>\n                               ttl (tls1_to_tls2 s2 stlsss1) =\n                               tls1_to_tls2 s2 stlsss1 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                               \\<approx> s2) \\<or>\n                           tllist_all2\n                            (\\<lambda>(tl1, s1'') (tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                            (rel_option bisim) (ttl stlsss1)\n                            (ttl (tls1_to_tls2 s2 stlsss1))))\n 2. \\<lbrakk>stlsss1 = TNil None;\n     s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> is_TNil stlsss1 =\n                      is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                      (is_TNil stlsss1 \\<longrightarrow>\n                       is_TNil (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       rel_option bisim (terminal stlsss1)\n                        (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                      (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                       \\<not> is_TNil\n                               (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       (case thd stlsss1 of\n                        (tl1, s1'') \\<Rightarrow>\n                          \\<lambda>(tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                        (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                       ((\\<exists>s1 s2 stlsss1.\n                            ttl stlsss1 = stlsss1 \\<and>\n                            ttl (tls1_to_tls2 s2 stlsss1) =\n                            tls1_to_tls2 s2 stlsss1 \\<and>\n                            trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                            \\<approx> s2) \\<or>\n                        tllist_all2\n                         (\\<lambda>(tl1, s1'') (tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                         (rel_option bisim) (ttl stlsss1)\n                         (ttl (tls1_to_tls2 s2 stlsss1))))\n 3. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> is_TNil stlsss1 =\n                         is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                         (is_TNil stlsss1 \\<longrightarrow>\n                          is_TNil\n                           (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                          rel_option bisim (terminal stlsss1)\n                           (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                         (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tls1_to_tls2 s2\n                                    stlsss1) \\<longrightarrow>\n                          (case thd stlsss1 of\n                           (tl1, s1'') \\<Rightarrow>\n                             \\<lambda>(tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                           (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                          ((\\<exists>s1 s2 stlsss1.\n                               ttl stlsss1 = stlsss1 \\<and>\n                               ttl (tls1_to_tls2 s2 stlsss1) =\n                               tls1_to_tls2 s2 stlsss1 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                               \\<approx> s2) \\<or>\n                           tllist_all2\n                            (\\<lambda>(tl1, s1'') (tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                            (rel_option bisim) (ttl stlsss1)\n                            (ttl (tls1_to_tls2 s2 stlsss1))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  s2 -\\<tau>2\\<rightarrow>* (SOME s2'.\n                                s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                                (\\<forall>tl2 s2''. \\<not> s2'\n                                    -2-tl2\\<rightarrow> s2'') \\<and>\n                                s1' \\<approx> s2') \\<and>\n  (\\<forall>tl2 s2''.\n      \\<not> (SOME s2'.\n                 s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                 (\\<forall>tl2 s2''. \\<not> s2' -2-tl2\\<rightarrow>\n                     s2'') \\<and>\n                 s1' \\<approx> s2')\n      -2-tl2\\<rightarrow> s2'') \\<and>\n  s1'\n  \\<approx> (SOME s2'.\n                s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                (\\<forall>tl2 s2''. \\<not> s2' -2-tl2\\<rightarrow>\n                    s2'') \\<and>\n                s1' \\<approx> s2')\n\ngoal (1 subgoal):\n 1. is_TNil stlsss1 = is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n    (is_TNil stlsss1 \\<longrightarrow>\n     is_TNil (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n     rel_option bisim (terminal stlsss1)\n      (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n    (\\<not> is_TNil stlsss1 \\<longrightarrow>\n     \\<not> is_TNil (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n     (case thd stlsss1 of\n      (tl1, s1'') \\<Rightarrow>\n        \\<lambda>(tl2, s2''). tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n      (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n     ((\\<exists>s1 s2 stlsss1.\n          ttl stlsss1 = stlsss1 \\<and>\n          ttl (tls1_to_tls2 s2 stlsss1) = tls1_to_tls2 s2 stlsss1 \\<and>\n          trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1 \\<approx> s2) \\<or>\n      tllist_all2\n       (\\<lambda>(tl1, s1'') (tl2, s2'').\n           tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n       (rel_option bisim) (ttl stlsss1) (ttl (tls1_to_tls2 s2 stlsss1))))", "using \\<open>stlsss1 = TNil \\<lfloor>s1'\\<rfloor>\\<close> bisim"], ["proof (prove)\nusing this:\n  s2 -\\<tau>2\\<rightarrow>* (SOME s2'.\n                                s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                                (\\<forall>tl2 s2''. \\<not> s2'\n                                    -2-tl2\\<rightarrow> s2'') \\<and>\n                                s1' \\<approx> s2') \\<and>\n  (\\<forall>tl2 s2''.\n      \\<not> (SOME s2'.\n                 s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                 (\\<forall>tl2 s2''. \\<not> s2' -2-tl2\\<rightarrow>\n                     s2'') \\<and>\n                 s1' \\<approx> s2')\n      -2-tl2\\<rightarrow> s2'') \\<and>\n  s1'\n  \\<approx> (SOME s2'.\n                s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                (\\<forall>tl2 s2''. \\<not> s2' -2-tl2\\<rightarrow>\n                    s2'') \\<and>\n                s1' \\<approx> s2')\n  stlsss1 = TNil \\<lfloor>s1'\\<rfloor>\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. is_TNil stlsss1 = is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n    (is_TNil stlsss1 \\<longrightarrow>\n     is_TNil (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n     rel_option bisim (terminal stlsss1)\n      (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n    (\\<not> is_TNil stlsss1 \\<longrightarrow>\n     \\<not> is_TNil (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n     (case thd stlsss1 of\n      (tl1, s1'') \\<Rightarrow>\n        \\<lambda>(tl2, s2''). tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n      (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n     ((\\<exists>s1 s2 stlsss1.\n          ttl stlsss1 = stlsss1 \\<and>\n          ttl (tls1_to_tls2 s2 stlsss1) = tls1_to_tls2 s2 stlsss1 \\<and>\n          trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1 \\<approx> s2) \\<or>\n      tllist_all2\n       (\\<lambda>(tl1, s1'') (tl2, s2'').\n           tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n       (rel_option bisim) (ttl stlsss1) (ttl (tls1_to_tls2 s2 stlsss1))))", "by(simp)"], ["proof (state)\nthis:\n  is_TNil stlsss1 = is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n  (is_TNil stlsss1 \\<longrightarrow>\n   is_TNil (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n   rel_option bisim (terminal stlsss1)\n    (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n  (\\<not> is_TNil stlsss1 \\<longrightarrow>\n   \\<not> is_TNil (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n   (case thd stlsss1 of\n    (tl1, s1'') \\<Rightarrow>\n      \\<lambda>(tl2, s2''). tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n    (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n   ((\\<exists>s1 s2 stlsss1.\n        ttl stlsss1 = stlsss1 \\<and>\n        ttl (tls1_to_tls2 s2 stlsss1) = tls1_to_tls2 s2 stlsss1 \\<and>\n        trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1 \\<approx> s2) \\<or>\n    tllist_all2\n     (\\<lambda>(tl1, s1'') (tl2, s2'').\n         tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n     (rel_option bisim) (ttl stlsss1) (ttl (tls1_to_tls2 s2 stlsss1))))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>stlsss1 = TNil None;\n     s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> is_TNil stlsss1 =\n                      is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                      (is_TNil stlsss1 \\<longrightarrow>\n                       is_TNil (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       rel_option bisim (terminal stlsss1)\n                        (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                      (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                       \\<not> is_TNil\n                               (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       (case thd stlsss1 of\n                        (tl1, s1'') \\<Rightarrow>\n                          \\<lambda>(tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                        (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                       ((\\<exists>s1 s2 stlsss1.\n                            ttl stlsss1 = stlsss1 \\<and>\n                            ttl (tls1_to_tls2 s2 stlsss1) =\n                            tls1_to_tls2 s2 stlsss1 \\<and>\n                            trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                            \\<approx> s2) \\<or>\n                        tllist_all2\n                         (\\<lambda>(tl1, s1'') (tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                         (rel_option bisim) (ttl stlsss1)\n                         (ttl (tls1_to_tls2 s2 stlsss1))))\n 2. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> is_TNil stlsss1 =\n                         is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                         (is_TNil stlsss1 \\<longrightarrow>\n                          is_TNil\n                           (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                          rel_option bisim (terminal stlsss1)\n                           (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                         (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tls1_to_tls2 s2\n                                    stlsss1) \\<longrightarrow>\n                          (case thd stlsss1 of\n                           (tl1, s1'') \\<Rightarrow>\n                             \\<lambda>(tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                           (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                          ((\\<exists>s1 s2 stlsss1.\n                               ttl stlsss1 = stlsss1 \\<and>\n                               ttl (tls1_to_tls2 s2 stlsss1) =\n                               tls1_to_tls2 s2 stlsss1 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                               \\<approx> s2) \\<or>\n                           tllist_all2\n                            (\\<lambda>(tl1, s1'') (tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                            (rel_option bisim) (ttl stlsss1)\n                            (ttl (tls1_to_tls2 s2 stlsss1))))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>stlsss1 = TNil None;\n     s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> is_TNil stlsss1 =\n                      is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                      (is_TNil stlsss1 \\<longrightarrow>\n                       is_TNil (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       rel_option bisim (terminal stlsss1)\n                        (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                      (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                       \\<not> is_TNil\n                               (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       (case thd stlsss1 of\n                        (tl1, s1'') \\<Rightarrow>\n                          \\<lambda>(tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                        (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                       ((\\<exists>s1 s2 stlsss1.\n                            ttl stlsss1 = stlsss1 \\<and>\n                            ttl (tls1_to_tls2 s2 stlsss1) =\n                            tls1_to_tls2 s2 stlsss1 \\<and>\n                            trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                            \\<approx> s2) \\<or>\n                        tllist_all2\n                         (\\<lambda>(tl1, s1'') (tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                         (rel_option bisim) (ttl stlsss1)\n                         (ttl (tls1_to_tls2 s2 stlsss1))))\n 2. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> is_TNil stlsss1 =\n                         is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                         (is_TNil stlsss1 \\<longrightarrow>\n                          is_TNil\n                           (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                          rel_option bisim (terminal stlsss1)\n                           (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                         (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tls1_to_tls2 s2\n                                    stlsss1) \\<longrightarrow>\n                          (case thd stlsss1 of\n                           (tl1, s1'') \\<Rightarrow>\n                             \\<lambda>(tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                           (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                          ((\\<exists>s1 s2 stlsss1.\n                               ttl stlsss1 = stlsss1 \\<and>\n                               ttl (tls1_to_tls2 s2 stlsss1) =\n                               tls1_to_tls2 s2 stlsss1 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                               \\<approx> s2) \\<or>\n                           tllist_all2\n                            (\\<lambda>(tl1, s1'') (tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                            (rel_option bisim) (ttl stlsss1)\n                            (ttl (tls1_to_tls2 s2 stlsss1))))", "case (Proceed s1' s1'' stlsss1' tl1)"], ["proof (state)\nthis:\n  stlsss1 = TCons (tl1, s1'') stlsss1'\n  s1 -\\<tau>1\\<rightarrow>* s1'\n  s1' -1-tl1\\<rightarrow> s1''\n  \\<not> \\<tau>move1 s1' tl1 s1''\n  trsys1.\\<tau>Runs_table s1'' stlsss1'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>stlsss1 = TNil None;\n     s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> is_TNil stlsss1 =\n                      is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                      (is_TNil stlsss1 \\<longrightarrow>\n                       is_TNil (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       rel_option bisim (terminal stlsss1)\n                        (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                      (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                       \\<not> is_TNil\n                               (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       (case thd stlsss1 of\n                        (tl1, s1'') \\<Rightarrow>\n                          \\<lambda>(tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                        (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                       ((\\<exists>s1 s2 stlsss1.\n                            ttl stlsss1 = stlsss1 \\<and>\n                            ttl (tls1_to_tls2 s2 stlsss1) =\n                            tls1_to_tls2 s2 stlsss1 \\<and>\n                            trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                            \\<approx> s2) \\<or>\n                        tllist_all2\n                         (\\<lambda>(tl1, s1'') (tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                         (rel_option bisim) (ttl stlsss1)\n                         (ttl (tls1_to_tls2 s2 stlsss1))))\n 2. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> is_TNil stlsss1 =\n                         is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                         (is_TNil stlsss1 \\<longrightarrow>\n                          is_TNil\n                           (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                          rel_option bisim (terminal stlsss1)\n                           (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                         (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tls1_to_tls2 s2\n                                    stlsss1) \\<longrightarrow>\n                          (case thd stlsss1 of\n                           (tl1, s1'') \\<Rightarrow>\n                             \\<lambda>(tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                           (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                          ((\\<exists>s1 s2 stlsss1.\n                               ttl stlsss1 = stlsss1 \\<and>\n                               ttl (tls1_to_tls2 s2 stlsss1) =\n                               tls1_to_tls2 s2 stlsss1 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                               \\<approx> s2) \\<or>\n                           tllist_all2\n                            (\\<lambda>(tl1, s1'') (tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                            (rel_option bisim) (ttl stlsss1)\n                            (ttl (tls1_to_tls2 s2 stlsss1))))", "from simulation_silents1[OF bisim \\<open>s1 -\\<tau>1\\<rightarrow>* s1'\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2'", "obtain s2' where \"s2 -\\<tau>2\\<rightarrow>* s2'\" and \"s1' \\<approx> s2'\""], ["proof (prove)\nusing this:\n  \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2'\n\ngoal (1 subgoal):\n 1. (\\<And>s2'.\n        \\<lbrakk>s2 -\\<tau>2\\<rightarrow>* s2'; s1' \\<approx> s2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  s1' \\<approx> s2'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>stlsss1 = TNil None;\n     s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> is_TNil stlsss1 =\n                      is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                      (is_TNil stlsss1 \\<longrightarrow>\n                       is_TNil (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       rel_option bisim (terminal stlsss1)\n                        (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                      (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                       \\<not> is_TNil\n                               (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       (case thd stlsss1 of\n                        (tl1, s1'') \\<Rightarrow>\n                          \\<lambda>(tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                        (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                       ((\\<exists>s1 s2 stlsss1.\n                            ttl stlsss1 = stlsss1 \\<and>\n                            ttl (tls1_to_tls2 s2 stlsss1) =\n                            tls1_to_tls2 s2 stlsss1 \\<and>\n                            trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                            \\<approx> s2) \\<or>\n                        tllist_all2\n                         (\\<lambda>(tl1, s1'') (tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                         (rel_option bisim) (ttl stlsss1)\n                         (ttl (tls1_to_tls2 s2 stlsss1))))\n 2. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> is_TNil stlsss1 =\n                         is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                         (is_TNil stlsss1 \\<longrightarrow>\n                          is_TNil\n                           (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                          rel_option bisim (terminal stlsss1)\n                           (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                         (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tls1_to_tls2 s2\n                                    stlsss1) \\<longrightarrow>\n                          (case thd stlsss1 of\n                           (tl1, s1'') \\<Rightarrow>\n                             \\<lambda>(tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                           (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                          ((\\<exists>s1 s2 stlsss1.\n                               ttl stlsss1 = stlsss1 \\<and>\n                               ttl (tls1_to_tls2 s2 stlsss1) =\n                               tls1_to_tls2 s2 stlsss1 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                               \\<approx> s2) \\<or>\n                           tllist_all2\n                            (\\<lambda>(tl1, s1'') (tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                            (rel_option bisim) (ttl stlsss1)\n                            (ttl (tls1_to_tls2 s2 stlsss1))))", "moreover"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  s1' \\<approx> s2'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>stlsss1 = TNil None;\n     s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> is_TNil stlsss1 =\n                      is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                      (is_TNil stlsss1 \\<longrightarrow>\n                       is_TNil (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       rel_option bisim (terminal stlsss1)\n                        (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                      (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                       \\<not> is_TNil\n                               (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       (case thd stlsss1 of\n                        (tl1, s1'') \\<Rightarrow>\n                          \\<lambda>(tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                        (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                       ((\\<exists>s1 s2 stlsss1.\n                            ttl stlsss1 = stlsss1 \\<and>\n                            ttl (tls1_to_tls2 s2 stlsss1) =\n                            tls1_to_tls2 s2 stlsss1 \\<and>\n                            trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                            \\<approx> s2) \\<or>\n                        tllist_all2\n                         (\\<lambda>(tl1, s1'') (tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                         (rel_option bisim) (ttl stlsss1)\n                         (ttl (tls1_to_tls2 s2 stlsss1))))\n 2. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> is_TNil stlsss1 =\n                         is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                         (is_TNil stlsss1 \\<longrightarrow>\n                          is_TNil\n                           (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                          rel_option bisim (terminal stlsss1)\n                           (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                         (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tls1_to_tls2 s2\n                                    stlsss1) \\<longrightarrow>\n                          (case thd stlsss1 of\n                           (tl1, s1'') \\<Rightarrow>\n                             \\<lambda>(tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                           (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                          ((\\<exists>s1 s2 stlsss1.\n                               ttl stlsss1 = stlsss1 \\<and>\n                               ttl (tls1_to_tls2 s2 stlsss1) =\n                               tls1_to_tls2 s2 stlsss1 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                               \\<approx> s2) \\<or>\n                           tllist_all2\n                            (\\<lambda>(tl1, s1'') (tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                            (rel_option bisim) (ttl stlsss1)\n                            (ttl (tls1_to_tls2 s2 stlsss1))))", "from simulation1[OF \\<open>s1' \\<approx> s2'\\<close> \\<open>s1' -1-tl1\\<rightarrow> s1''\\<close> \\<open>\\<not> \\<tau>move1 s1' tl1 s1''\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>s2'a s2'' tl2.\n     s2' -\\<tau>2\\<rightarrow>* s2'a \\<and>\n     s2'a -2-tl2\\<rightarrow> s2'' \\<and>\n     \\<not> \\<tau>move2 s2'a tl2 s2'' \\<and>\n     s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2", "obtain s2'' s2''' tl2 where \"s2' -\\<tau>2\\<rightarrow>* s2''\"\n        and \"s2'' -2-tl2\\<rightarrow> s2'''\" and \"\\<not> \\<tau>move2 s2'' tl2 s2'''\"\n        and \"s1'' \\<approx> s2'''\" and \"tl1 \\<sim> tl2\""], ["proof (prove)\nusing this:\n  \\<exists>s2'a s2'' tl2.\n     s2' -\\<tau>2\\<rightarrow>* s2'a \\<and>\n     s2'a -2-tl2\\<rightarrow> s2'' \\<and>\n     \\<not> \\<tau>move2 s2'a tl2 s2'' \\<and>\n     s1'' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. (\\<And>s2'' tl2 s2'''.\n        \\<lbrakk>s2' -\\<tau>2\\<rightarrow>* s2'';\n         s2'' -2-tl2\\<rightarrow> s2'''; \\<not> \\<tau>move2 s2'' tl2 s2''';\n         s1'' \\<approx> s2'''; tl1 \\<sim> tl2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s2' -\\<tau>2\\<rightarrow>* s2''\n  s2'' -2-tl2\\<rightarrow> s2'''\n  \\<not> \\<tau>move2 s2'' tl2 s2'''\n  s1'' \\<approx> s2'''\n  tl1 \\<sim> tl2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>stlsss1 = TNil None;\n     s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> is_TNil stlsss1 =\n                      is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                      (is_TNil stlsss1 \\<longrightarrow>\n                       is_TNil (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       rel_option bisim (terminal stlsss1)\n                        (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                      (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                       \\<not> is_TNil\n                               (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       (case thd stlsss1 of\n                        (tl1, s1'') \\<Rightarrow>\n                          \\<lambda>(tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                        (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                       ((\\<exists>s1 s2 stlsss1.\n                            ttl stlsss1 = stlsss1 \\<and>\n                            ttl (tls1_to_tls2 s2 stlsss1) =\n                            tls1_to_tls2 s2 stlsss1 \\<and>\n                            trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                            \\<approx> s2) \\<or>\n                        tllist_all2\n                         (\\<lambda>(tl1, s1'') (tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                         (rel_option bisim) (ttl stlsss1)\n                         (ttl (tls1_to_tls2 s2 stlsss1))))\n 2. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> is_TNil stlsss1 =\n                         is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                         (is_TNil stlsss1 \\<longrightarrow>\n                          is_TNil\n                           (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                          rel_option bisim (terminal stlsss1)\n                           (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                         (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tls1_to_tls2 s2\n                                    stlsss1) \\<longrightarrow>\n                          (case thd stlsss1 of\n                           (tl1, s1'') \\<Rightarrow>\n                             \\<lambda>(tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                           (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                          ((\\<exists>s1 s2 stlsss1.\n                               ttl stlsss1 = stlsss1 \\<and>\n                               ttl (tls1_to_tls2 s2 stlsss1) =\n                               tls1_to_tls2 s2 stlsss1 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                               \\<approx> s2) \\<or>\n                           tllist_all2\n                            (\\<lambda>(tl1, s1'') (tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                            (rel_option bisim) (ttl stlsss1)\n                            (ttl (tls1_to_tls2 s2 stlsss1))))", "ultimately"], ["proof (chain)\npicking this:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  s1' \\<approx> s2'\n  s2' -\\<tau>2\\<rightarrow>* s2''\n  s2'' -2-tl2\\<rightarrow> s2'''\n  \\<not> \\<tau>move2 s2'' tl2 s2'''\n  s1'' \\<approx> s2'''\n  tl1 \\<sim> tl2", "have \"?P s2 stlsss1 (tl2, s2''')\""], ["proof (prove)\nusing this:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  s1' \\<approx> s2'\n  s2' -\\<tau>2\\<rightarrow>* s2''\n  s2'' -2-tl2\\<rightarrow> s2'''\n  \\<not> \\<tau>move2 s2'' tl2 s2'''\n  s1'' \\<approx> s2'''\n  tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. case (tl2, s2''') of\n    (tl2, s2'') \\<Rightarrow>\n      \\<exists>s2'.\n         s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n         s2' -2-tl2\\<rightarrow> s2'' \\<and>\n         \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n         snd (thd stlsss1) \\<approx> s2'' \\<and> fst (thd stlsss1)\n         \\<sim> tl2", "using \\<open>stlsss1 = TCons (tl1, s1'') stlsss1'\\<close>"], ["proof (prove)\nusing this:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  s1' \\<approx> s2'\n  s2' -\\<tau>2\\<rightarrow>* s2''\n  s2'' -2-tl2\\<rightarrow> s2'''\n  \\<not> \\<tau>move2 s2'' tl2 s2'''\n  s1'' \\<approx> s2'''\n  tl1 \\<sim> tl2\n  stlsss1 = TCons (tl1, s1'') stlsss1'\n\ngoal (1 subgoal):\n 1. case (tl2, s2''') of\n    (tl2, s2'') \\<Rightarrow>\n      \\<exists>s2'.\n         s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n         s2' -2-tl2\\<rightarrow> s2'' \\<and>\n         \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n         snd (thd stlsss1) \\<approx> s2'' \\<and> fst (thd stlsss1)\n         \\<sim> tl2", "by(auto intro: rtranclp_trans)"], ["proof (state)\nthis:\n  case (tl2, s2''') of\n  (tl2, s2'') \\<Rightarrow>\n    \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n       s2' -2-tl2\\<rightarrow> s2'' \\<and>\n       \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n       snd (thd stlsss1) \\<approx> s2'' \\<and> fst (thd stlsss1) \\<sim> tl2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>stlsss1 = TNil None;\n     s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> is_TNil stlsss1 =\n                      is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                      (is_TNil stlsss1 \\<longrightarrow>\n                       is_TNil (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       rel_option bisim (terminal stlsss1)\n                        (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                      (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                       \\<not> is_TNil\n                               (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       (case thd stlsss1 of\n                        (tl1, s1'') \\<Rightarrow>\n                          \\<lambda>(tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                        (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                       ((\\<exists>s1 s2 stlsss1.\n                            ttl stlsss1 = stlsss1 \\<and>\n                            ttl (tls1_to_tls2 s2 stlsss1) =\n                            tls1_to_tls2 s2 stlsss1 \\<and>\n                            trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                            \\<approx> s2) \\<or>\n                        tllist_all2\n                         (\\<lambda>(tl1, s1'') (tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                         (rel_option bisim) (ttl stlsss1)\n                         (ttl (tls1_to_tls2 s2 stlsss1))))\n 2. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> is_TNil stlsss1 =\n                         is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                         (is_TNil stlsss1 \\<longrightarrow>\n                          is_TNil\n                           (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                          rel_option bisim (terminal stlsss1)\n                           (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                         (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tls1_to_tls2 s2\n                                    stlsss1) \\<longrightarrow>\n                          (case thd stlsss1 of\n                           (tl1, s1'') \\<Rightarrow>\n                             \\<lambda>(tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                           (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                          ((\\<exists>s1 s2 stlsss1.\n                               ttl stlsss1 = stlsss1 \\<and>\n                               ttl (tls1_to_tls2 s2 stlsss1) =\n                               tls1_to_tls2 s2 stlsss1 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                               \\<approx> s2) \\<or>\n                           tllist_all2\n                            (\\<lambda>(tl1, s1'') (tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                            (rel_option bisim) (ttl stlsss1)\n                            (ttl (tls1_to_tls2 s2 stlsss1))))", "hence \"?P s2 stlsss1 (Eps (?P s2 stlsss1))\""], ["proof (prove)\nusing this:\n  case (tl2, s2''') of\n  (tl2, s2'') \\<Rightarrow>\n    \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n       s2' -2-tl2\\<rightarrow> s2'' \\<and>\n       \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n       snd (thd stlsss1) \\<approx> s2'' \\<and> fst (thd stlsss1) \\<sim> tl2\n\ngoal (1 subgoal):\n 1. case SOME (tl2, s2'').\n            \\<exists>s2'.\n               s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n               s2' -2-tl2\\<rightarrow> s2'' \\<and>\n               \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n               snd (thd stlsss1) \\<approx> s2'' \\<and> fst (thd stlsss1)\n               \\<sim> tl2 of\n    (tl2, s2'') \\<Rightarrow>\n      \\<exists>s2'.\n         s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n         s2' -2-tl2\\<rightarrow> s2'' \\<and>\n         \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n         snd (thd stlsss1) \\<approx> s2'' \\<and> fst (thd stlsss1)\n         \\<sim> tl2", "by(rule someI)"], ["proof (state)\nthis:\n  case SOME (tl2, s2'').\n          \\<exists>s2'.\n             s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n             s2' -2-tl2\\<rightarrow> s2'' \\<and>\n             \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n             snd (thd stlsss1) \\<approx> s2'' \\<and> fst (thd stlsss1)\n             \\<sim> tl2 of\n  (tl2, s2'') \\<Rightarrow>\n    \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n       s2' -2-tl2\\<rightarrow> s2'' \\<and>\n       \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n       snd (thd stlsss1) \\<approx> s2'' \\<and> fst (thd stlsss1) \\<sim> tl2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>stlsss1 = TNil None;\n     s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> is_TNil stlsss1 =\n                      is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                      (is_TNil stlsss1 \\<longrightarrow>\n                       is_TNil (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       rel_option bisim (terminal stlsss1)\n                        (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                      (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                       \\<not> is_TNil\n                               (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       (case thd stlsss1 of\n                        (tl1, s1'') \\<Rightarrow>\n                          \\<lambda>(tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                        (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                       ((\\<exists>s1 s2 stlsss1.\n                            ttl stlsss1 = stlsss1 \\<and>\n                            ttl (tls1_to_tls2 s2 stlsss1) =\n                            tls1_to_tls2 s2 stlsss1 \\<and>\n                            trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                            \\<approx> s2) \\<or>\n                        tllist_all2\n                         (\\<lambda>(tl1, s1'') (tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                         (rel_option bisim) (ttl stlsss1)\n                         (ttl (tls1_to_tls2 s2 stlsss1))))\n 2. \\<And>s' s'' tls tl.\n       \\<lbrakk>stlsss1 = TCons (tl, s'') tls; s1 -\\<tau>1\\<rightarrow>* s';\n        s' -1-tl\\<rightarrow> s''; \\<not> \\<tau>move1 s' tl s'';\n        trsys1.\\<tau>Runs_table s'' tls\\<rbrakk>\n       \\<Longrightarrow> is_TNil stlsss1 =\n                         is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                         (is_TNil stlsss1 \\<longrightarrow>\n                          is_TNil\n                           (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                          rel_option bisim (terminal stlsss1)\n                           (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                         (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tls1_to_tls2 s2\n                                    stlsss1) \\<longrightarrow>\n                          (case thd stlsss1 of\n                           (tl1, s1'') \\<Rightarrow>\n                             \\<lambda>(tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                           (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                          ((\\<exists>s1 s2 stlsss1.\n                               ttl stlsss1 = stlsss1 \\<and>\n                               ttl (tls1_to_tls2 s2 stlsss1) =\n                               tls1_to_tls2 s2 stlsss1 \\<and>\n                               trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                               \\<approx> s2) \\<or>\n                           tllist_all2\n                            (\\<lambda>(tl1, s1'') (tl2, s2'').\n                                tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                            (rel_option bisim) (ttl stlsss1)\n                            (ttl (tls1_to_tls2 s2 stlsss1))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  case SOME (tl2, s2'').\n          \\<exists>s2'.\n             s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n             s2' -2-tl2\\<rightarrow> s2'' \\<and>\n             \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n             snd (thd stlsss1) \\<approx> s2'' \\<and> fst (thd stlsss1)\n             \\<sim> tl2 of\n  (tl2, s2'') \\<Rightarrow>\n    \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n       s2' -2-tl2\\<rightarrow> s2'' \\<and>\n       \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n       snd (thd stlsss1) \\<approx> s2'' \\<and> fst (thd stlsss1) \\<sim> tl2\n\ngoal (1 subgoal):\n 1. is_TNil stlsss1 = is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n    (is_TNil stlsss1 \\<longrightarrow>\n     is_TNil (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n     rel_option bisim (terminal stlsss1)\n      (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n    (\\<not> is_TNil stlsss1 \\<longrightarrow>\n     \\<not> is_TNil (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n     (case thd stlsss1 of\n      (tl1, s1'') \\<Rightarrow>\n        \\<lambda>(tl2, s2''). tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n      (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n     ((\\<exists>s1 s2 stlsss1.\n          ttl stlsss1 = stlsss1 \\<and>\n          ttl (tls1_to_tls2 s2 stlsss1) = tls1_to_tls2 s2 stlsss1 \\<and>\n          trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1 \\<approx> s2) \\<or>\n      tllist_all2\n       (\\<lambda>(tl1, s1'') (tl2, s2'').\n           tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n       (rel_option bisim) (ttl stlsss1) (ttl (tls1_to_tls2 s2 stlsss1))))", "using \\<open>stlsss1 = TCons (tl1, s1'') stlsss1'\\<close> \\<open>trsys1.\\<tau>Runs_table s1'' stlsss1'\\<close> bisim"], ["proof (prove)\nusing this:\n  case SOME (tl2, s2'').\n          \\<exists>s2'.\n             s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n             s2' -2-tl2\\<rightarrow> s2'' \\<and>\n             \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n             snd (thd stlsss1) \\<approx> s2'' \\<and> fst (thd stlsss1)\n             \\<sim> tl2 of\n  (tl2, s2'') \\<Rightarrow>\n    \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n       s2' -2-tl2\\<rightarrow> s2'' \\<and>\n       \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n       snd (thd stlsss1) \\<approx> s2'' \\<and> fst (thd stlsss1) \\<sim> tl2\n  stlsss1 = TCons (tl1, s1'') stlsss1'\n  trsys1.\\<tau>Runs_table s1'' stlsss1'\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. is_TNil stlsss1 = is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n    (is_TNil stlsss1 \\<longrightarrow>\n     is_TNil (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n     rel_option bisim (terminal stlsss1)\n      (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n    (\\<not> is_TNil stlsss1 \\<longrightarrow>\n     \\<not> is_TNil (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n     (case thd stlsss1 of\n      (tl1, s1'') \\<Rightarrow>\n        \\<lambda>(tl2, s2''). tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n      (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n     ((\\<exists>s1 s2 stlsss1.\n          ttl stlsss1 = stlsss1 \\<and>\n          ttl (tls1_to_tls2 s2 stlsss1) = tls1_to_tls2 s2 stlsss1 \\<and>\n          trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1 \\<approx> s2) \\<or>\n      tllist_all2\n       (\\<lambda>(tl1, s1'') (tl2, s2'').\n           tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n       (rel_option bisim) (ttl stlsss1) (ttl (tls1_to_tls2 s2 stlsss1))))", "by auto blast"], ["proof (state)\nthis:\n  is_TNil stlsss1 = is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n  (is_TNil stlsss1 \\<longrightarrow>\n   is_TNil (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n   rel_option bisim (terminal stlsss1)\n    (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n  (\\<not> is_TNil stlsss1 \\<longrightarrow>\n   \\<not> is_TNil (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n   (case thd stlsss1 of\n    (tl1, s1'') \\<Rightarrow>\n      \\<lambda>(tl2, s2''). tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n    (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n   ((\\<exists>s1 s2 stlsss1.\n        ttl stlsss1 = stlsss1 \\<and>\n        ttl (tls1_to_tls2 s2 stlsss1) = tls1_to_tls2 s2 stlsss1 \\<and>\n        trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1 \\<approx> s2) \\<or>\n    tllist_all2\n     (\\<lambda>(tl1, s1'') (tl2, s2'').\n         tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n     (rel_option bisim) (ttl stlsss1) (ttl (tls1_to_tls2 s2 stlsss1))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>stlsss1 = TNil None;\n     s1 -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> is_TNil stlsss1 =\n                      is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n                      (is_TNil stlsss1 \\<longrightarrow>\n                       is_TNil (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       rel_option bisim (terminal stlsss1)\n                        (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n                      (\\<not> is_TNil stlsss1 \\<longrightarrow>\n                       \\<not> is_TNil\n                               (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n                       (case thd stlsss1 of\n                        (tl1, s1'') \\<Rightarrow>\n                          \\<lambda>(tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                        (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n                       ((\\<exists>s1 s2 stlsss1.\n                            ttl stlsss1 = stlsss1 \\<and>\n                            ttl (tls1_to_tls2 s2 stlsss1) =\n                            tls1_to_tls2 s2 stlsss1 \\<and>\n                            trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1\n                            \\<approx> s2) \\<or>\n                        tllist_all2\n                         (\\<lambda>(tl1, s1'') (tl2, s2'').\n                             tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                         (rel_option bisim) (ttl stlsss1)\n                         (ttl (tls1_to_tls2 s2 stlsss1))))", "qed simp"], ["proof (state)\nthis:\n  is_TNil stlsss1 = is_TNil (tls1_to_tls2 s2 stlsss1) \\<and>\n  (is_TNil stlsss1 \\<longrightarrow>\n   is_TNil (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n   rel_option bisim (terminal stlsss1)\n    (terminal (tls1_to_tls2 s2 stlsss1))) \\<and>\n  (\\<not> is_TNil stlsss1 \\<longrightarrow>\n   \\<not> is_TNil (tls1_to_tls2 s2 stlsss1) \\<longrightarrow>\n   (case thd stlsss1 of\n    (tl1, s1'') \\<Rightarrow>\n      \\<lambda>(tl2, s2''). tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n    (thd (tls1_to_tls2 s2 stlsss1)) \\<and>\n   ((\\<exists>s1 s2 stlsss1.\n        ttl stlsss1 = stlsss1 \\<and>\n        ttl (tls1_to_tls2 s2 stlsss1) = tls1_to_tls2 s2 stlsss1 \\<and>\n        trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> s1 \\<approx> s2) \\<or>\n    tllist_all2\n     (\\<lambda>(tl1, s1'') (tl2, s2'').\n         tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n     (rel_option bisim) (ttl stlsss1) (ttl (tls1_to_tls2 s2 stlsss1))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  tllist_all2\n   (\\<lambda>(tl1, s1'') (tl2, s2'').\n       tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n   (rel_option bisim) stlsss1 (tls1_to_tls2 s2 stlsss1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma simulation_\\<tau>Runs_table2:\n  assumes \"s1 \\<approx> s2\"\n  and \"trsys2.\\<tau>Runs_table s2 stlsss2\"\n  shows \"\\<exists>stlsss1. trsys1.\\<tau>Runs_table s1 stlsss1 \\<and> tllist_all2 (\\<lambda>(tl1, s1'') (tl2, s2''). tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'') (rel_option bisim) stlsss1 stlsss2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stlsss1.\n       trsys1.\\<tau>Runs_table s1 stlsss1 \\<and>\n       tllist_all2\n        (\\<lambda>(tl1, s1'') (tl2, s2'').\n            tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n        (rel_option bisim) stlsss1 stlsss2", "using delay_bisimulation_diverge.simulation_\\<tau>Runs_table1[OF delay_bisimulation_diverge_flip, unfolded flip_simps, OF assms]"], ["proof (prove)\nusing this:\n  \\<exists>stlsss2a.\n     trsys1.\\<tau>Runs_table s1 stlsss2a \\<and>\n     tllist_all2\n      (\\<lambda>(tl1, s1'') (tl2, s2'').\n          tl2 \\<sim> tl1 \\<and> s2'' \\<approx> s1'')\n      (\\<lambda>b a. rel_option bisim a b) stlsss2 stlsss2a\n\ngoal (1 subgoal):\n 1. \\<exists>stlsss1.\n       trsys1.\\<tau>Runs_table s1 stlsss1 \\<and>\n       tllist_all2\n        (\\<lambda>(tl1, s1'') (tl2, s2'').\n            tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n        (rel_option bisim) stlsss1 stlsss2", "by(subst tllist_all2_flip[symmetric])(simp only: flip_def split_def)"], ["", "lemma simulation_\\<tau>Runs1:\n  assumes bisim: \"s1 \\<approx> s2\"\n  and run1: \"s1 \\<Down>1 tls1\"\n  shows \"\\<exists>tls2. s2 \\<Down>2 tls2 \\<and> tllist_all2 tlsim (rel_option bisim) tls1 tls2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>tls2.\n       s2 \\<Down>2 tls2 \\<and>\n       tllist_all2 tlsim (rel_option bisim) tls1 tls2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>tls2.\n       s2 \\<Down>2 tls2 \\<and>\n       tllist_all2 tlsim (rel_option bisim) tls1 tls2", "from trsys1.\\<tau>Runs_into_\\<tau>Runs_table[OF run1]"], ["proof (chain)\npicking this:\n  \\<exists>stlsss.\n     tls1 = tmap fst id stlsss \\<and> trsys1.\\<tau>Runs_table s1 stlsss", "obtain stlsss1 where tls1: \"tls1 = tmap fst id stlsss1\"\n    and \\<tau>Runs1: \"trsys1.\\<tau>Runs_table s1 stlsss1\""], ["proof (prove)\nusing this:\n  \\<exists>stlsss.\n     tls1 = tmap fst id stlsss \\<and> trsys1.\\<tau>Runs_table s1 stlsss\n\ngoal (1 subgoal):\n 1. (\\<And>stlsss1.\n        \\<lbrakk>tls1 = tmap fst id stlsss1;\n         trsys1.\\<tau>Runs_table s1 stlsss1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  tls1 = tmap fst id stlsss1\n  trsys1.\\<tau>Runs_table s1 stlsss1\n\ngoal (1 subgoal):\n 1. \\<exists>tls2.\n       s2 \\<Down>2 tls2 \\<and>\n       tllist_all2 tlsim (rel_option bisim) tls1 tls2", "from simulation_\\<tau>Runs_table1[OF bisim \\<tau>Runs1]"], ["proof (chain)\npicking this:\n  \\<exists>stlsss2.\n     trsys2.\\<tau>Runs_table s2 stlsss2 \\<and>\n     tllist_all2\n      (\\<lambda>(tl1, s1'') (tl2, s2'').\n          tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n      (rel_option bisim) stlsss1 stlsss2", "obtain stlsss2 where \\<tau>Runs2: \"trsys2.\\<tau>Runs_table s2 stlsss2\"\n    and tlsim: \"tllist_all2 (\\<lambda>(tl1, s1'') (tl2, s2''). tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n                            (rel_option bisim) stlsss1 stlsss2\""], ["proof (prove)\nusing this:\n  \\<exists>stlsss2.\n     trsys2.\\<tau>Runs_table s2 stlsss2 \\<and>\n     tllist_all2\n      (\\<lambda>(tl1, s1'') (tl2, s2'').\n          tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n      (rel_option bisim) stlsss1 stlsss2\n\ngoal (1 subgoal):\n 1. (\\<And>stlsss2.\n        \\<lbrakk>trsys2.\\<tau>Runs_table s2 stlsss2;\n         tllist_all2\n          (\\<lambda>(tl1, s1'') (tl2, s2'').\n              tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n          (rel_option bisim) stlsss1 stlsss2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  trsys2.\\<tau>Runs_table s2 stlsss2\n  tllist_all2\n   (\\<lambda>(tl1, s1'') (tl2, s2'').\n       tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n   (rel_option bisim) stlsss1 stlsss2\n\ngoal (1 subgoal):\n 1. \\<exists>tls2.\n       s2 \\<Down>2 tls2 \\<and>\n       tllist_all2 tlsim (rel_option bisim) tls1 tls2", "from \\<tau>Runs2"], ["proof (chain)\npicking this:\n  trsys2.\\<tau>Runs_table s2 stlsss2", "have \"s2 \\<Down>2 tmap fst id stlsss2\""], ["proof (prove)\nusing this:\n  trsys2.\\<tau>Runs_table s2 stlsss2\n\ngoal (1 subgoal):\n 1. s2 \\<Down>2 tmap fst id stlsss2", "by(rule \\<tau>Runs_table_into_\\<tau>Runs)"], ["proof (state)\nthis:\n  s2 \\<Down>2 tmap fst id stlsss2\n\ngoal (1 subgoal):\n 1. \\<exists>tls2.\n       s2 \\<Down>2 tls2 \\<and>\n       tllist_all2 tlsim (rel_option bisim) tls1 tls2", "moreover"], ["proof (state)\nthis:\n  s2 \\<Down>2 tmap fst id stlsss2\n\ngoal (1 subgoal):\n 1. \\<exists>tls2.\n       s2 \\<Down>2 tls2 \\<and>\n       tllist_all2 tlsim (rel_option bisim) tls1 tls2", "have \"tllist_all2 tlsim (rel_option bisim) tls1 (tmap fst id stlsss2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tllist_all2 tlsim (rel_option bisim) tls1 (tmap fst id stlsss2)", "using tlsim"], ["proof (prove)\nusing this:\n  tllist_all2\n   (\\<lambda>(tl1, s1'') (tl2, s2'').\n       tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n   (rel_option bisim) stlsss1 stlsss2\n\ngoal (1 subgoal):\n 1. tllist_all2 tlsim (rel_option bisim) tls1 (tmap fst id stlsss2)", "unfolding tls1"], ["proof (prove)\nusing this:\n  tllist_all2\n   (\\<lambda>(tl1, s1'') (tl2, s2'').\n       tl1 \\<sim> tl2 \\<and> s1'' \\<approx> s2'')\n   (rel_option bisim) stlsss1 stlsss2\n\ngoal (1 subgoal):\n 1. tllist_all2 tlsim (rel_option bisim) (tmap fst id stlsss1)\n     (tmap fst id stlsss2)", "by(fastforce simp add: tllist_all2_tmap1 tllist_all2_tmap2 elim: tllist_all2_mono rel_option_mono)"], ["proof (state)\nthis:\n  tllist_all2 tlsim (rel_option bisim) tls1 (tmap fst id stlsss2)\n\ngoal (1 subgoal):\n 1. \\<exists>tls2.\n       s2 \\<Down>2 tls2 \\<and>\n       tllist_all2 tlsim (rel_option bisim) tls1 tls2", "ultimately"], ["proof (chain)\npicking this:\n  s2 \\<Down>2 tmap fst id stlsss2\n  tllist_all2 tlsim (rel_option bisim) tls1 (tmap fst id stlsss2)", "show ?thesis"], ["proof (prove)\nusing this:\n  s2 \\<Down>2 tmap fst id stlsss2\n  tllist_all2 tlsim (rel_option bisim) tls1 (tmap fst id stlsss2)\n\ngoal (1 subgoal):\n 1. \\<exists>tls2.\n       s2 \\<Down>2 tls2 \\<and>\n       tllist_all2 tlsim (rel_option bisim) tls1 tls2", "by blast"], ["proof (state)\nthis:\n  \\<exists>tls2.\n     s2 \\<Down>2 tls2 \\<and> tllist_all2 tlsim (rel_option bisim) tls1 tls2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma simulation_\\<tau>Runs2:\n  \"\\<lbrakk> s1 \\<approx> s2; s2 \\<Down>2 tls2 \\<rbrakk>\n  \\<Longrightarrow> \\<exists>tls1. s1 \\<Down>1 tls1 \\<and> tllist_all2 tlsim (rel_option bisim) tls1 tls2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx> s2; s2 \\<Down>2 tls2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tls1.\n                         s1 \\<Down>1 tls1 \\<and>\n                         tllist_all2 tlsim (rel_option bisim) tls1 tls2", "using delay_bisimulation_diverge.simulation_\\<tau>Runs1[OF delay_bisimulation_diverge_flip]"], ["proof (prove)\nusing this:\n  \\<lbrakk>flip bisim ?s1.0 ?s2.0; ?s1.0 \\<Down>2 ?tls1.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tls2.\n                       ?s2.0 \\<Down>1 tls2 \\<and>\n                       tllist_all2 (flip tlsim) (rel_option (flip bisim))\n                        ?tls1.0 tls2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx> s2; s2 \\<Down>2 tls2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tls1.\n                         s1 \\<Down>1 tls1 \\<and>\n                         tllist_all2 tlsim (rel_option bisim) tls1 tls2", "unfolding flip_simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s2.0 \\<approx> ?s1.0; ?s1.0 \\<Down>2 ?tls1.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tls2.\n                       ?s2.0 \\<Down>1 tls2 \\<and>\n                       tllist_all2 tlsim (rel_option bisim) tls2 ?tls1.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx> s2; s2 \\<Down>2 tls2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tls1.\n                         s1 \\<Down>1 tls1 \\<and>\n                         tllist_all2 tlsim (rel_option bisim) tls1 tls2", "."], ["", "end"], ["", "locale delay_bisimulation_final_base =\n  delay_bisimulation_base _ _ _ _ \\<tau>move1 \\<tau>move2 +\n  bisimulation_final_base _ _ _ _ final1 final2 \n  for \\<tau>move1 :: \"('s1, 'tl1) trsys\"\n  and \\<tau>move2 :: \"('s2, 'tl2) trsys\"\n  and final1 :: \"'s1 \\<Rightarrow> bool\"\n  and final2 :: \"'s2 \\<Rightarrow> bool\" +\n  assumes final1_simulation: \"\\<lbrakk> s1 \\<approx> s2; final1 s1 \\<rbrakk> \\<Longrightarrow> \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1 \\<approx> s2' \\<and> final2 s2'\"\n  and final2_simulation: \"\\<lbrakk> s1 \\<approx> s2; final2 s2 \\<rbrakk> \\<Longrightarrow> \\<exists>s1'. s1 -\\<tau>1\\<rightarrow>* s1' \\<and> s1' \\<approx> s2 \\<and> final1 s1'\"\nbegin"], ["", "lemma delay_bisimulation_final_base_flip:\n  \"delay_bisimulation_final_base trsys2 trsys1 (flip bisim) \\<tau>move2 \\<tau>move1 final2 final1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_final_base trsys2 trsys1 (flip bisim) \\<tau>move2\n     \\<tau>move1 final2 final1", "apply(unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>flip bisim s1 s2; final2 s1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            s2 -\\<tau>1\\<rightarrow>* s2' \\<and>\n                            flip bisim s1 s2' \\<and> final1 s2'\n 2. \\<And>s1 s2.\n       \\<lbrakk>flip bisim s1 s2; final1 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>2\\<rightarrow>* s1' \\<and>\n                            flip bisim s1' s2 \\<and> final2 s1'", "apply(unfold flip_simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>s2 \\<approx> s1; final2 s1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            s2 -\\<tau>1\\<rightarrow>* s2' \\<and>\n                            s2' \\<approx> s1 \\<and> final1 s2'\n 2. \\<And>s1 s2.\n       \\<lbrakk>s2 \\<approx> s1; final1 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>2\\<rightarrow>* s1' \\<and>\n                            s2 \\<approx> s1' \\<and> final2 s1'", "by(blast intro: final1_simulation final2_simulation)+"], ["", "end"], ["", "lemma delay_bisimulation_final_base_flip_simps [flip_simps]:\n  \"delay_bisimulation_final_base trsys2 trsys1 (flip bisim) \\<tau>move2 \\<tau>move1 final2 final1 =\n  delay_bisimulation_final_base trsys1 trsys2 bisim \\<tau>move1 \\<tau>move2 final1 final2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_final_base trsys2 trsys1 (flip bisim) \\<tau>move2\n     \\<tau>move1 final2 final1 =\n    delay_bisimulation_final_base trsys1 trsys2 bisim \\<tau>move1\n     \\<tau>move2 final1 final2", "by(auto dest: delay_bisimulation_final_base.delay_bisimulation_final_base_flip simp only: flip_flip)"], ["", "context delay_bisimulation_final_base begin"], ["", "lemma \\<tau>Runs_terminate_final1:\n  assumes \"s1 \\<Down>1 tls1\"\n  and \"s2 \\<Down>2 tls2\"\n  and \"tllist_all2 tlsim (rel_option bisim) tls1 tls2\"\n  and \"tfinite tls1\"\n  and \"terminal tls1 = Some s1'\"\n  and \"final1 s1'\"\n  shows \"\\<exists>s2'. tfinite tls2 \\<and> terminal tls2 = Some s2' \\<and> final2 s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       tfinite tls2 \\<and>\n       terminal tls2 = \\<lfloor>s2'\\<rfloor> \\<and> final2 s2'", "using assms(4) assms(1-3,5-)"], ["proof (prove)\nusing this:\n  tfinite tls1\n  s1 \\<Down>1 tls1\n  s2 \\<Down>2 tls2\n  tllist_all2 tlsim (rel_option bisim) tls1 tls2\n  terminal tls1 = \\<lfloor>s1'\\<rfloor>\n  final1 s1'\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       tfinite tls2 \\<and>\n       terminal tls2 = \\<lfloor>s2'\\<rfloor> \\<and> final2 s2'", "apply(induct arbitrary: tls2 s1 s2 rule: tfinite_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y tls2 s1 s2.\n       \\<lbrakk>s1 \\<Down>1 TNil y; s2 \\<Down>2 tls2;\n        tllist_all2 tlsim (rel_option bisim) (TNil y) tls2;\n        terminal (TNil y) = \\<lfloor>s1'\\<rfloor>; final1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            tfinite tls2 \\<and>\n                            terminal tls2 = \\<lfloor>s2'\\<rfloor> \\<and>\n                            final2 s2'\n 2. \\<And>x xs tls2 s1 s2.\n       \\<lbrakk>tfinite xs;\n        \\<And>tls2 s1 s2.\n           \\<lbrakk>s1 \\<Down>1 xs; s2 \\<Down>2 tls2;\n            tllist_all2 tlsim (rel_option bisim) xs tls2;\n            terminal xs = \\<lfloor>s1'\\<rfloor>; final1 s1'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s2'.\n                                tfinite tls2 \\<and>\n                                terminal tls2 = \\<lfloor>s2'\\<rfloor> \\<and>\n                                final2 s2';\n        s1 \\<Down>1 TCons x xs; s2 \\<Down>2 tls2;\n        tllist_all2 tlsim (rel_option bisim) (TCons x xs) tls2;\n        terminal (TCons x xs) = \\<lfloor>s1'\\<rfloor>; final1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            tfinite tls2 \\<and>\n                            terminal tls2 = \\<lfloor>s2'\\<rfloor> \\<and>\n                            final2 s2'", "apply(auto 4 4 simp add: tllist_all2_TCons1 tllist_all2_TNil1 rel_option_Some1 trsys1.\\<tau>Runs_simps trsys2.\\<tau>Runs_simps dest: final1_simulation elim: converse_rtranclpE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \\<tau>Runs_terminate_final2:\n  \"\\<lbrakk> s1 \\<Down>1 tls1; s2 \\<Down>2 tls2; tllist_all2 tlsim (rel_option bisim) tls1 tls2;\n     tfinite tls2; terminal tls2 = Some s2'; final2 s2' \\<rbrakk>\n  \\<Longrightarrow> \\<exists>s1'. tfinite tls1 \\<and> terminal tls1 = Some s1' \\<and> final1 s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<Down>1 tls1; s2 \\<Down>2 tls2;\n     tllist_all2 tlsim (rel_option bisim) tls1 tls2; tfinite tls2;\n     terminal tls2 = \\<lfloor>s2'\\<rfloor>; final2 s2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s1'.\n                         tfinite tls1 \\<and>\n                         terminal tls1 = \\<lfloor>s1'\\<rfloor> \\<and>\n                         final1 s1'", "using delay_bisimulation_final_base.\\<tau>Runs_terminate_final1[where tlsim = \"flip tlsim\", OF delay_bisimulation_final_base_flip]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s1.0 \\<Down>2 ?tls1.0; ?s2.0 \\<Down>1 ?tls2.0;\n   tllist_all2 (flip tlsim) (rel_option (flip bisim)) ?tls1.0 ?tls2.0;\n   tfinite ?tls1.0; terminal ?tls1.0 = \\<lfloor>?s1'\\<rfloor>;\n   final2 ?s1'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s2'.\n                       tfinite ?tls2.0 \\<and>\n                       terminal ?tls2.0 = \\<lfloor>s2'\\<rfloor> \\<and>\n                       final1 s2'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<Down>1 tls1; s2 \\<Down>2 tls2;\n     tllist_all2 tlsim (rel_option bisim) tls1 tls2; tfinite tls2;\n     terminal tls2 = \\<lfloor>s2'\\<rfloor>; final2 s2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s1'.\n                         tfinite tls1 \\<and>\n                         terminal tls1 = \\<lfloor>s1'\\<rfloor> \\<and>\n                         final1 s1'", "unfolding flip_simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s1.0 \\<Down>2 ?tls1.0; ?s2.0 \\<Down>1 ?tls2.0;\n   tllist_all2 tlsim (rel_option bisim) ?tls2.0 ?tls1.0; tfinite ?tls1.0;\n   terminal ?tls1.0 = \\<lfloor>?s1'\\<rfloor>; final2 ?s1'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s2'.\n                       tfinite ?tls2.0 \\<and>\n                       terminal ?tls2.0 = \\<lfloor>s2'\\<rfloor> \\<and>\n                       final1 s2'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<Down>1 tls1; s2 \\<Down>2 tls2;\n     tllist_all2 tlsim (rel_option bisim) tls1 tls2; tfinite tls2;\n     terminal tls2 = \\<lfloor>s2'\\<rfloor>; final2 s2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s1'.\n                         tfinite tls1 \\<and>\n                         terminal tls1 = \\<lfloor>s1'\\<rfloor> \\<and>\n                         final1 s1'", "by -"], ["", "end"], ["", "locale delay_bisimulation_diverge_final = \n  delay_bisimulation_diverge + \n  delay_bisimulation_final_base +\n  constrains trsys1 :: \"('s1, 'tl1) trsys\"\n  and trsys2 :: \"('s2, 'tl2) trsys\"\n  and bisim :: \"('s1, 's2) bisim\"\n  and tlsim :: \"('tl1, 'tl2) bisim\"\n  and \\<tau>move1 :: \"('s1, 'tl1) trsys\"\n  and \\<tau>move2 :: \"('s2, 'tl2) trsys\"\n  and final1 :: \"'s1 \\<Rightarrow> bool\"\n  and final2 :: \"'s2 \\<Rightarrow> bool\"\nbegin"], ["", "lemma delay_bisimulation_diverge_final_flip:\n  \"delay_bisimulation_diverge_final trsys2 trsys1 (flip bisim) (flip tlsim) \\<tau>move2 \\<tau>move1 final2 final1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge_final trsys2 trsys1 (flip bisim) (flip tlsim)\n     \\<tau>move2 \\<tau>move1 final2 final1", "apply(rule delay_bisimulation_diverge_final.intro)"], ["proof (prove)\ngoal (2 subgoals):\n 1. delay_bisimulation_diverge trsys2 trsys1 (flip bisim) (flip tlsim)\n     \\<tau>move2 \\<tau>move1\n 2. delay_bisimulation_final_base trsys2 trsys1 (flip bisim) \\<tau>move2\n     \\<tau>move1 final2 final1", "apply(rule delay_bisimulation_diverge_flip)"], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_final_base trsys2 trsys1 (flip bisim) \\<tau>move2\n     \\<tau>move1 final2 final1", "apply(unfold_locales, unfold flip_simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>s2 \\<approx> s1; final2 s1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            s2 -\\<tau>1\\<rightarrow>* s2' \\<and>\n                            s2' \\<approx> s1 \\<and> final1 s2'\n 2. \\<And>s1 s2.\n       \\<lbrakk>s2 \\<approx> s1; final1 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>2\\<rightarrow>* s1' \\<and>\n                            s2 \\<approx> s1' \\<and> final2 s1'", "apply(blast intro: final1_simulation final2_simulation)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma delay_bisimulation_diverge_final_flip_simps [flip_simps]:\n  \"delay_bisimulation_diverge_final trsys2 trsys1 (flip bisim) (flip tlsim) \\<tau>move2 \\<tau>move1 final2 final1 =\n   delay_bisimulation_diverge_final trsys1 trsys2 bisim tlsim \\<tau>move1 \\<tau>move2 final1 final2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge_final trsys2 trsys1 (flip bisim) (flip tlsim)\n     \\<tau>move2 \\<tau>move1 final2 final1 =\n    delay_bisimulation_diverge_final trsys1 trsys2 bisim tlsim \\<tau>move1\n     \\<tau>move2 final1 final2", "by(auto dest: delay_bisimulation_diverge_final.delay_bisimulation_diverge_final_flip simp only: flip_flip)"], ["", "context delay_bisimulation_diverge_final begin"], ["", "lemma delay_bisimulation_diverge:\n  \"delay_bisimulation_diverge trsys1 trsys2 bisim tlsim \\<tau>move1 \\<tau>move2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge trsys1 trsys2 bisim tlsim \\<tau>move1\n     \\<tau>move2", "by(unfold_locales)"], ["", "lemma delay_bisimulation_final_base:\n  \"delay_bisimulation_final_base trsys1 trsys2 bisim \\<tau>move1 \\<tau>move2 final1 final2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_final_base trsys1 trsys2 bisim \\<tau>move1\n     \\<tau>move2 final1 final2", "by(unfold_locales)"], ["", "lemma final_simulation1:\n  \"\\<lbrakk> s1 \\<approx> s2; s1 -\\<tau>1-tls1\\<rightarrow>* s1'; final1 s1' \\<rbrakk>\n  \\<Longrightarrow> \\<exists>s2' tls2. s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2' \\<and> final2 s2' \\<and> tls1 [\\<sim>] tls2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx> s2; s1 -\\<tau>1-tls1\\<rightarrow>* s1';\n     final1 s1'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2' tls2.\n                         s2 -\\<tau>2-tls2\\<rightarrow>* s2' \\<and>\n                         s1' \\<approx> s2' \\<and>\n                         final2 s2' \\<and> tls1 [\\<sim>] tls2", "by(blast dest: simulation1_\\<tau>rtrancl3p final1_simulation intro: \\<tau>rtrancl3p_trans[OF _ silent_moves_into_\\<tau>rtrancl3p, simplified])"], ["", "lemma final_simulation2:\n  \"\\<lbrakk> s1 \\<approx> s2; s2 -\\<tau>2-tls2\\<rightarrow>* s2'; final2 s2' \\<rbrakk>\n  \\<Longrightarrow> \\<exists>s1' tls1. s1 -\\<tau>1-tls1\\<rightarrow>* s1' \\<and> s1' \\<approx> s2' \\<and> final1 s1' \\<and> tls1 [\\<sim>] tls2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx> s2; s2 -\\<tau>2-tls2\\<rightarrow>* s2';\n     final2 s2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s1' tls1.\n                         s1 -\\<tau>1-tls1\\<rightarrow>* s1' \\<and>\n                         s1' \\<approx> s2' \\<and>\n                         final1 s1' \\<and> tls1 [\\<sim>] tls2", "by(rule delay_bisimulation_diverge_final.final_simulation1[OF delay_bisimulation_diverge_final_flip, unfolded flip_simps])"], ["", "end"], ["", "locale delay_bisimulation_measure_base = \n  delay_bisimulation_base +\n  constrains trsys1 :: \"'s1 \\<Rightarrow> 'tl1 \\<Rightarrow> 's1 \\<Rightarrow> bool\"\n  and trsys2 :: \"'s2 \\<Rightarrow> 'tl2 \\<Rightarrow> 's2 \\<Rightarrow> bool\"\n  and bisim :: \"'s1 \\<Rightarrow> 's2 \\<Rightarrow> bool\"\n  and tlsim :: \"'tl1 \\<Rightarrow> 'tl2 \\<Rightarrow> bool\"\n  and \\<tau>move1 :: \"'s1 \\<Rightarrow> 'tl1 \\<Rightarrow> 's1 \\<Rightarrow> bool\"\n  and \\<tau>move2 :: \"'s2 \\<Rightarrow> 'tl2 \\<Rightarrow> 's2 \\<Rightarrow> bool\"\n  fixes \\<mu>1 :: \"'s1 \\<Rightarrow> 's1 \\<Rightarrow> bool\"\n  and \\<mu>2 :: \"'s2 \\<Rightarrow> 's2 \\<Rightarrow> bool\""], ["", "locale delay_bisimulation_measure =\n  delay_bisimulation_measure_base _ _ _ _ \\<tau>move1 \\<tau>move2 \\<mu>1 \\<mu>2 +\n  delay_bisimulation_obs trsys1 trsys2 bisim tlsim \\<tau>move1 \\<tau>move2\n  for \\<tau>move1 :: \"'s1 \\<Rightarrow> 'tl1 \\<Rightarrow> 's1 \\<Rightarrow> bool\"\n  and \\<tau>move2 :: \"'s2 \\<Rightarrow> 'tl2 \\<Rightarrow> 's2 \\<Rightarrow> bool\"\n  and \\<mu>1 :: \"'s1 \\<Rightarrow> 's1 \\<Rightarrow> bool\"\n  and \\<mu>2 :: \"'s2 \\<Rightarrow> 's2 \\<Rightarrow> bool\" +\n  assumes simulation_silent1:\n  \"\\<lbrakk> s1 \\<approx> s2; s1 -\\<tau>1\\<rightarrow> s1' \\<rbrakk> \\<Longrightarrow> s1' \\<approx> s2 \\<and> \\<mu>1^++ s1' s1 \\<or> (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')\"\n  and simulation_silent2:\n  \"\\<lbrakk> s1 \\<approx> s2; s2 -\\<tau>2\\<rightarrow> s2' \\<rbrakk> \\<Longrightarrow> s1 \\<approx> s2' \\<and> \\<mu>2^++ s2' s2 \\<or> (\\<exists>s1'. s1 -\\<tau>1\\<rightarrow>+ s1' \\<and> s1' \\<approx> s2')\"\n  and wf_\\<mu>1: \"wfP \\<mu>1\"\n  and wf_\\<mu>2: \"wfP \\<mu>2\"\nbegin"], ["", "lemma delay_bisimulation_measure_flip:\n  \"delay_bisimulation_measure trsys2 trsys1 (flip bisim) (flip tlsim) \\<tau>move2 \\<tau>move1 \\<mu>2 \\<mu>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_measure trsys2 trsys1 (flip bisim) (flip tlsim)\n     \\<tau>move2 \\<tau>move1 \\<mu>2 \\<mu>1", "apply(rule delay_bisimulation_measure.intro)"], ["proof (prove)\ngoal (2 subgoals):\n 1. delay_bisimulation_obs trsys2 trsys1 (flip bisim) (flip tlsim)\n     \\<tau>move2 \\<tau>move1\n 2. delay_bisimulation_measure_axioms trsys2 trsys1 (flip bisim) \\<tau>move2\n     \\<tau>move1 \\<mu>2 \\<mu>1", "apply(rule delay_bisimulation_obs_flip)"], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_measure_axioms trsys2 trsys1 (flip bisim) \\<tau>move2\n     \\<tau>move1 \\<mu>2 \\<mu>1", "apply(unfold_locales)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s1 s2 s1'.\n       \\<lbrakk>flip bisim s1 s2; s1 -\\<tau>2\\<rightarrow> s1'\\<rbrakk>\n       \\<Longrightarrow> flip bisim s1' s2 \\<and>\n                         \\<mu>2\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n                         (\\<exists>s2'.\n                             s2 -\\<tau>1\\<rightarrow>+ s2' \\<and>\n                             flip bisim s1' s2')\n 2. \\<And>s1 s2 s2'.\n       \\<lbrakk>flip bisim s1 s2; s2 -\\<tau>1\\<rightarrow> s2'\\<rbrakk>\n       \\<Longrightarrow> flip bisim s1 s2' \\<and>\n                         \\<mu>1\\<^sup>+\\<^sup>+ s2' s2 \\<or>\n                         (\\<exists>s1'.\n                             s1 -\\<tau>2\\<rightarrow>+ s1' \\<and>\n                             flip bisim s1' s2')\n 3. wfP \\<mu>2\n 4. wfP \\<mu>1", "apply(unfold flip_simps)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s1 s2 s1'.\n       \\<lbrakk>s2 \\<approx> s1; s1 -\\<tau>2\\<rightarrow> s1'\\<rbrakk>\n       \\<Longrightarrow> s2 \\<approx> s1' \\<and>\n                         \\<mu>2\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n                         (\\<exists>s2'.\n                             s2 -\\<tau>1\\<rightarrow>+ s2' \\<and> s2'\n                             \\<approx> s1')\n 2. \\<And>s1 s2 s2'.\n       \\<lbrakk>s2 \\<approx> s1; s2 -\\<tau>1\\<rightarrow> s2'\\<rbrakk>\n       \\<Longrightarrow> s2' \\<approx> s1 \\<and>\n                         \\<mu>1\\<^sup>+\\<^sup>+ s2' s2 \\<or>\n                         (\\<exists>s1'.\n                             s1 -\\<tau>2\\<rightarrow>+ s1' \\<and> s2'\n                             \\<approx> s1')\n 3. wfP \\<mu>2\n 4. wfP \\<mu>1", "apply(rule simulation_silent1 simulation_silent2 wf_\\<mu>1 wf_\\<mu>2|assumption)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma delay_bisimulation_measure_flip_simps [flip_simps]:\n  \"delay_bisimulation_measure trsys2 trsys1 (flip bisim) (flip tlsim) \\<tau>move2 \\<tau>move1 \\<mu>2 \\<mu>1 =\n   delay_bisimulation_measure trsys1 trsys2 bisim tlsim \\<tau>move1 \\<tau>move2 \\<mu>1 \\<mu>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_measure trsys2 trsys1 (flip bisim) (flip tlsim)\n     \\<tau>move2 \\<tau>move1 \\<mu>2 \\<mu>1 =\n    delay_bisimulation_measure trsys1 trsys2 bisim tlsim \\<tau>move1\n     \\<tau>move2 \\<mu>1 \\<mu>2", "by(auto dest: delay_bisimulation_measure.delay_bisimulation_measure_flip simp only: flip_simps)"], ["", "context delay_bisimulation_measure begin"], ["", "lemma simulation_silentst1:\n  assumes bisim: \"s1 \\<approx> s2\" and moves: \"s1 -\\<tau>1\\<rightarrow>+ s1'\"\n  shows \"s1' \\<approx> s2 \\<and> \\<mu>1^++ s1' s1 \\<or> (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')", "using moves bisim"], ["proof (prove)\nusing this:\n  s1 -\\<tau>1\\<rightarrow>+ s1'\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>s1 -\\<tau>1\\<rightarrow> y; s1 \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> y \\<approx> s2 \\<and>\n                         \\<mu>1\\<^sup>+\\<^sup>+ y s1 \\<or>\n                         (\\<exists>s2'.\n                             s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> y\n                             \\<approx> s2')\n 2. \\<And>y z.\n       \\<lbrakk>s1 -\\<tau>1\\<rightarrow>+ y; y -\\<tau>1\\<rightarrow> z;\n        s1 \\<approx> s2 \\<Longrightarrow>\n        y \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ y s1 \\<or>\n        (\\<exists>s2'.\n            s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> y \\<approx> s2');\n        s1 \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> z \\<approx> s2 \\<and>\n                         \\<mu>1\\<^sup>+\\<^sup>+ z s1 \\<or>\n                         (\\<exists>s2'.\n                             s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> z\n                             \\<approx> s2')", "case (base s1')"], ["proof (state)\nthis:\n  s1 -\\<tau>1\\<rightarrow> s1'\n  s1 \\<approx> s2\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>s1 -\\<tau>1\\<rightarrow> y; s1 \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> y \\<approx> s2 \\<and>\n                         \\<mu>1\\<^sup>+\\<^sup>+ y s1 \\<or>\n                         (\\<exists>s2'.\n                             s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> y\n                             \\<approx> s2')\n 2. \\<And>y z.\n       \\<lbrakk>s1 -\\<tau>1\\<rightarrow>+ y; y -\\<tau>1\\<rightarrow> z;\n        s1 \\<approx> s2 \\<Longrightarrow>\n        y \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ y s1 \\<or>\n        (\\<exists>s2'.\n            s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> y \\<approx> s2');\n        s1 \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> z \\<approx> s2 \\<and>\n                         \\<mu>1\\<^sup>+\\<^sup>+ z s1 \\<or>\n                         (\\<exists>s2'.\n                             s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> z\n                             \\<approx> s2')", "thus ?case"], ["proof (prove)\nusing this:\n  s1 -\\<tau>1\\<rightarrow> s1'\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')", "by(auto dest: simulation_silent1)"], ["proof (state)\nthis:\n  s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n  (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>s1 -\\<tau>1\\<rightarrow>+ y; y -\\<tau>1\\<rightarrow> z;\n        s1 \\<approx> s2 \\<Longrightarrow>\n        y \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ y s1 \\<or>\n        (\\<exists>s2'.\n            s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> y \\<approx> s2');\n        s1 \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> z \\<approx> s2 \\<and>\n                         \\<mu>1\\<^sup>+\\<^sup>+ z s1 \\<or>\n                         (\\<exists>s2'.\n                             s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> z\n                             \\<approx> s2')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>s1 -\\<tau>1\\<rightarrow>+ y; y -\\<tau>1\\<rightarrow> z;\n        s1 \\<approx> s2 \\<Longrightarrow>\n        y \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ y s1 \\<or>\n        (\\<exists>s2'.\n            s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> y \\<approx> s2');\n        s1 \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> z \\<approx> s2 \\<and>\n                         \\<mu>1\\<^sup>+\\<^sup>+ z s1 \\<or>\n                         (\\<exists>s2'.\n                             s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> z\n                             \\<approx> s2')", "case (step s1' s1'')"], ["proof (state)\nthis:\n  s1 -\\<tau>1\\<rightarrow>+ s1'\n  s1' -\\<tau>1\\<rightarrow> s1''\n  s1 \\<approx> s2 \\<Longrightarrow>\n  s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n  (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>s1 -\\<tau>1\\<rightarrow>+ y; y -\\<tau>1\\<rightarrow> z;\n        s1 \\<approx> s2 \\<Longrightarrow>\n        y \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ y s1 \\<or>\n        (\\<exists>s2'.\n            s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> y \\<approx> s2');\n        s1 \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> z \\<approx> s2 \\<and>\n                         \\<mu>1\\<^sup>+\\<^sup>+ z s1 \\<or>\n                         (\\<exists>s2'.\n                             s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> z\n                             \\<approx> s2')", "hence \"s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or> (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')\""], ["proof (prove)\nusing this:\n  s1 -\\<tau>1\\<rightarrow>+ s1'\n  s1' -\\<tau>1\\<rightarrow> s1''\n  s1 \\<approx> s2 \\<Longrightarrow>\n  s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n  (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')", "by blast"], ["proof (state)\nthis:\n  s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n  (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>s1 -\\<tau>1\\<rightarrow>+ y; y -\\<tau>1\\<rightarrow> z;\n        s1 \\<approx> s2 \\<Longrightarrow>\n        y \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ y s1 \\<or>\n        (\\<exists>s2'.\n            s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> y \\<approx> s2');\n        s1 \\<approx> s2\\<rbrakk>\n       \\<Longrightarrow> z \\<approx> s2 \\<and>\n                         \\<mu>1\\<^sup>+\\<^sup>+ z s1 \\<or>\n                         (\\<exists>s2'.\n                             s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> z\n                             \\<approx> s2')", "thus ?case"], ["proof (prove)\nusing this:\n  s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n  (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')\n\ngoal (1 subgoal):\n 1. s1'' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1'' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1'' \\<approx> s2')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<Longrightarrow>\n    s1'' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1'' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1'' \\<approx> s2')\n 2. \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1'\n       \\<approx> s2' \\<Longrightarrow>\n    s1'' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1'' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1'' \\<approx> s2')", "assume \"s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1\""], ["proof (state)\nthis:\n  s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1\n\ngoal (2 subgoals):\n 1. s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<Longrightarrow>\n    s1'' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1'' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1'' \\<approx> s2')\n 2. \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1'\n       \\<approx> s2' \\<Longrightarrow>\n    s1'' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1'' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1'' \\<approx> s2')", "hence \"s1' \\<approx> s2\" \"\\<mu>1\\<^sup>+\\<^sup>+ s1' s1\""], ["proof (prove)\nusing this:\n  s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1\n\ngoal (1 subgoal):\n 1. s1' \\<approx> s2 &&& \\<mu>1\\<^sup>+\\<^sup>+ s1' s1", "by simp_all"], ["proof (state)\nthis:\n  s1' \\<approx> s2\n  \\<mu>1\\<^sup>+\\<^sup>+ s1' s1\n\ngoal (2 subgoals):\n 1. s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<Longrightarrow>\n    s1'' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1'' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1'' \\<approx> s2')\n 2. \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1'\n       \\<approx> s2' \\<Longrightarrow>\n    s1'' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1'' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1'' \\<approx> s2')", "with simulation_silent1[OF \\<open>s1' \\<approx> s2\\<close> \\<open>s1' -\\<tau>1\\<rightarrow> s1''\\<close>]"], ["proof (chain)\npicking this:\n  s1'' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1'' s1' \\<or>\n  (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1'' \\<approx> s2')\n  s1' \\<approx> s2\n  \\<mu>1\\<^sup>+\\<^sup>+ s1' s1", "show ?thesis"], ["proof (prove)\nusing this:\n  s1'' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1'' s1' \\<or>\n  (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1'' \\<approx> s2')\n  s1' \\<approx> s2\n  \\<mu>1\\<^sup>+\\<^sup>+ s1' s1\n\ngoal (1 subgoal):\n 1. s1'' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1'' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1'' \\<approx> s2')", "by(auto)"], ["proof (state)\nthis:\n  s1'' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1'' s1 \\<or>\n  (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1'' \\<approx> s2')\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1'\n       \\<approx> s2' \\<Longrightarrow>\n    s1'' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1'' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1'' \\<approx> s2')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1'\n       \\<approx> s2' \\<Longrightarrow>\n    s1'' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1'' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1'' \\<approx> s2')", "assume \"\\<exists>s2'. trsys2.silent_move\\<^sup>+\\<^sup>+ s2 s2' \\<and> s1' \\<approx> s2'\""], ["proof (state)\nthis:\n  \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2'\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1'\n       \\<approx> s2' \\<Longrightarrow>\n    s1'' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1'' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1'' \\<approx> s2')", "then"], ["proof (chain)\npicking this:\n  \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2'", "obtain s2' where \"s2 -\\<tau>2\\<rightarrow>+ s2'\" \"s1' \\<approx> s2'\""], ["proof (prove)\nusing this:\n  \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2'\n\ngoal (1 subgoal):\n 1. (\\<And>s2'.\n        \\<lbrakk>s2 -\\<tau>2\\<rightarrow>+ s2'; s1' \\<approx> s2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow>+ s2'\n  s1' \\<approx> s2'\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1'\n       \\<approx> s2' \\<Longrightarrow>\n    s1'' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1'' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1'' \\<approx> s2')", "with simulation_silent1[OF \\<open>s1' \\<approx> s2'\\<close> \\<open>s1' -\\<tau>1\\<rightarrow> s1''\\<close>]"], ["proof (chain)\npicking this:\n  s1'' \\<approx> s2' \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1'' s1' \\<or>\n  (\\<exists>s2'a.\n      s2' -\\<tau>2\\<rightarrow>+ s2'a \\<and> s1'' \\<approx> s2'a)\n  s2 -\\<tau>2\\<rightarrow>+ s2'\n  s1' \\<approx> s2'", "show ?thesis"], ["proof (prove)\nusing this:\n  s1'' \\<approx> s2' \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1'' s1' \\<or>\n  (\\<exists>s2'a.\n      s2' -\\<tau>2\\<rightarrow>+ s2'a \\<and> s1'' \\<approx> s2'a)\n  s2 -\\<tau>2\\<rightarrow>+ s2'\n  s1' \\<approx> s2'\n\ngoal (1 subgoal):\n 1. s1'' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1'' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1'' \\<approx> s2')", "by(auto intro: tranclp_trans)"], ["proof (state)\nthis:\n  s1'' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1'' s1 \\<or>\n  (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1'' \\<approx> s2')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s1'' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1'' s1 \\<or>\n  (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1'' \\<approx> s2')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma simulation_silentst2:\n  \"\\<lbrakk> s1 \\<approx> s2; s2 -\\<tau>2\\<rightarrow>+ s2' \\<rbrakk> \\<Longrightarrow> s1 \\<approx> s2' \\<and> \\<mu>2^++ s2' s2 \\<or> (\\<exists>s1'. s1 -\\<tau>1\\<rightarrow>+ s1' \\<and> s1' \\<approx> s2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx> s2; s2 -\\<tau>2\\<rightarrow>+ s2'\\<rbrakk>\n    \\<Longrightarrow> s1 \\<approx> s2' \\<and>\n                      \\<mu>2\\<^sup>+\\<^sup>+ s2' s2 \\<or>\n                      (\\<exists>s1'.\n                          s1 -\\<tau>1\\<rightarrow>+ s1' \\<and> s1'\n                          \\<approx> s2')", "using delay_bisimulation_measure.simulation_silentst1[OF delay_bisimulation_measure_flip]"], ["proof (prove)\nusing this:\n  \\<lbrakk>flip bisim ?s1.0 ?s2.0;\n   ?s1.0 -\\<tau>2\\<rightarrow>+ ?s1'\\<rbrakk>\n  \\<Longrightarrow> flip bisim ?s1' ?s2.0 \\<and>\n                    \\<mu>2\\<^sup>+\\<^sup>+ ?s1' ?s1.0 \\<or>\n                    (\\<exists>s2'.\n                        ?s2.0 -\\<tau>1\\<rightarrow>+ s2' \\<and>\n                        flip bisim ?s1' s2')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx> s2; s2 -\\<tau>2\\<rightarrow>+ s2'\\<rbrakk>\n    \\<Longrightarrow> s1 \\<approx> s2' \\<and>\n                      \\<mu>2\\<^sup>+\\<^sup>+ s2' s2 \\<or>\n                      (\\<exists>s1'.\n                          s1 -\\<tau>1\\<rightarrow>+ s1' \\<and> s1'\n                          \\<approx> s2')", "unfolding flip_simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s2.0 \\<approx> ?s1.0; ?s1.0 -\\<tau>2\\<rightarrow>+ ?s1'\\<rbrakk>\n  \\<Longrightarrow> ?s2.0 \\<approx> ?s1' \\<and>\n                    \\<mu>2\\<^sup>+\\<^sup>+ ?s1' ?s1.0 \\<or>\n                    (\\<exists>s2'.\n                        ?s2.0 -\\<tau>1\\<rightarrow>+ s2' \\<and> s2'\n                        \\<approx> ?s1')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx> s2; s2 -\\<tau>2\\<rightarrow>+ s2'\\<rbrakk>\n    \\<Longrightarrow> s1 \\<approx> s2' \\<and>\n                      \\<mu>2\\<^sup>+\\<^sup>+ s2' s2 \\<or>\n                      (\\<exists>s1'.\n                          s1 -\\<tau>1\\<rightarrow>+ s1' \\<and> s1'\n                          \\<approx> s2')", "."], ["", "lemma \\<tau>diverge_simulation1:\n  assumes diverge1: \"s1 -\\<tau>1\\<rightarrow> \\<infinity>\"\n  and bisim: \"s1 \\<approx> s2\"\n  shows \"s2 -\\<tau>2\\<rightarrow> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s2 -\\<tau>2\\<rightarrow> \\<infinity>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s2 -\\<tau>2\\<rightarrow> \\<infinity>", "from assms"], ["proof (chain)\npicking this:\n  s1 -\\<tau>1\\<rightarrow> \\<infinity>\n  s1 \\<approx> s2", "have \"s1 -\\<tau>1\\<rightarrow> \\<infinity> \\<and> s1 \\<approx> s2\""], ["proof (prove)\nusing this:\n  s1 -\\<tau>1\\<rightarrow> \\<infinity>\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. s1 -\\<tau>1\\<rightarrow> \\<infinity> \\<and> s1 \\<approx> s2", "by blast"], ["proof (state)\nthis:\n  s1 -\\<tau>1\\<rightarrow> \\<infinity> \\<and> s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. s2 -\\<tau>2\\<rightarrow> \\<infinity>", "thus ?thesis"], ["proof (prove)\nusing this:\n  s1 -\\<tau>1\\<rightarrow> \\<infinity> \\<and> s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. s2 -\\<tau>2\\<rightarrow> \\<infinity>", "using wfP_trancl[OF wf_\\<mu>1]"], ["proof (prove)\nusing this:\n  s1 -\\<tau>1\\<rightarrow> \\<infinity> \\<and> s1 \\<approx> s2\n  wfP \\<mu>1\\<^sup>+\\<^sup>+\n\ngoal (1 subgoal):\n 1. s2 -\\<tau>2\\<rightarrow> \\<infinity>", "proof(coinduct rule: trsys2.\\<tau>diverge_trancl_measure_coinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       t -\\<tau>1\\<rightarrow> \\<infinity> \\<and> t\n       \\<approx> s \\<Longrightarrow>\n       \\<exists>s' t'.\n          (\\<mu>1\\<^sup>+\\<^sup>+ t' t \\<and> s' = s \\<or> s\n           -\\<tau>2\\<rightarrow>+ s') \\<and>\n          (t' -\\<tau>1\\<rightarrow> \\<infinity> \\<and> t' \\<approx> s' \\<or>\n           s' -\\<tau>2\\<rightarrow> \\<infinity>)", "case (\\<tau>diverge s2 s1)"], ["proof (state)\nthis:\n  s1 -\\<tau>1\\<rightarrow> \\<infinity> \\<and> s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       t -\\<tau>1\\<rightarrow> \\<infinity> \\<and> t\n       \\<approx> s \\<Longrightarrow>\n       \\<exists>s' t'.\n          (\\<mu>1\\<^sup>+\\<^sup>+ t' t \\<and> s' = s \\<or> s\n           -\\<tau>2\\<rightarrow>+ s') \\<and>\n          (t' -\\<tau>1\\<rightarrow> \\<infinity> \\<and> t' \\<approx> s' \\<or>\n           s' -\\<tau>2\\<rightarrow> \\<infinity>)", "hence \"s1 -\\<tau>1\\<rightarrow> \\<infinity>\" \"s1 \\<approx> s2\""], ["proof (prove)\nusing this:\n  s1 -\\<tau>1\\<rightarrow> \\<infinity> \\<and> s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. s1 -\\<tau>1\\<rightarrow> \\<infinity> &&& s1 \\<approx> s2", "by simp_all"], ["proof (state)\nthis:\n  s1 -\\<tau>1\\<rightarrow> \\<infinity>\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       t -\\<tau>1\\<rightarrow> \\<infinity> \\<and> t\n       \\<approx> s \\<Longrightarrow>\n       \\<exists>s' t'.\n          (\\<mu>1\\<^sup>+\\<^sup>+ t' t \\<and> s' = s \\<or> s\n           -\\<tau>2\\<rightarrow>+ s') \\<and>\n          (t' -\\<tau>1\\<rightarrow> \\<infinity> \\<and> t' \\<approx> s' \\<or>\n           s' -\\<tau>2\\<rightarrow> \\<infinity>)", "then"], ["proof (chain)\npicking this:\n  s1 -\\<tau>1\\<rightarrow> \\<infinity>\n  s1 \\<approx> s2", "obtain s1' where \"trsys1.silent_move s1 s1'\" \"s1' -\\<tau>1\\<rightarrow> \\<infinity>\""], ["proof (prove)\nusing this:\n  s1 -\\<tau>1\\<rightarrow> \\<infinity>\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. (\\<And>s1'.\n        \\<lbrakk>s1 -\\<tau>1\\<rightarrow> s1';\n         s1' -\\<tau>1\\<rightarrow> \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim: trsys1.\\<tau>diverge.cases)"], ["proof (state)\nthis:\n  s1 -\\<tau>1\\<rightarrow> s1'\n  s1' -\\<tau>1\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       t -\\<tau>1\\<rightarrow> \\<infinity> \\<and> t\n       \\<approx> s \\<Longrightarrow>\n       \\<exists>s' t'.\n          (\\<mu>1\\<^sup>+\\<^sup>+ t' t \\<and> s' = s \\<or> s\n           -\\<tau>2\\<rightarrow>+ s') \\<and>\n          (t' -\\<tau>1\\<rightarrow> \\<infinity> \\<and> t' \\<approx> s' \\<or>\n           s' -\\<tau>2\\<rightarrow> \\<infinity>)", "from simulation_silent1[OF \\<open>s1 \\<approx> s2\\<close> \\<open>trsys1.silent_move s1 s1'\\<close>] \\<open>s1' -\\<tau>1\\<rightarrow> \\<infinity>\\<close>"], ["proof (chain)\npicking this:\n  s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n  (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')\n  s1' -\\<tau>1\\<rightarrow> \\<infinity>", "show ?case"], ["proof (prove)\nusing this:\n  s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n  (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')\n  s1' -\\<tau>1\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>s' t'.\n       (\\<mu>1\\<^sup>+\\<^sup>+ t' s1 \\<and> s' = s2 \\<or> s2\n        -\\<tau>2\\<rightarrow>+ s') \\<and>\n       (t' -\\<tau>1\\<rightarrow> \\<infinity> \\<and> t' \\<approx> s' \\<or>\n        s' -\\<tau>2\\<rightarrow> \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>s' t'.\n     (\\<mu>1\\<^sup>+\\<^sup>+ t' s1 \\<and> s' = s2 \\<or> s2\n      -\\<tau>2\\<rightarrow>+ s') \\<and>\n     (t' -\\<tau>1\\<rightarrow> \\<infinity> \\<and> t' \\<approx> s' \\<or>\n      s' -\\<tau>2\\<rightarrow> \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow> \\<infinity>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<tau>diverge_simulation2:\n  \"\\<lbrakk> s2 -\\<tau>2\\<rightarrow> \\<infinity>; s1 \\<approx> s2 \\<rbrakk> \\<Longrightarrow> s1 -\\<tau>1\\<rightarrow> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s2 -\\<tau>2\\<rightarrow> \\<infinity>; s1 \\<approx> s2\\<rbrakk>\n    \\<Longrightarrow> s1 -\\<tau>1\\<rightarrow> \\<infinity>", "using delay_bisimulation_measure.\\<tau>diverge_simulation1[OF delay_bisimulation_measure_flip]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s1.0 -\\<tau>2\\<rightarrow> \\<infinity>;\n   flip bisim ?s1.0 ?s2.0\\<rbrakk>\n  \\<Longrightarrow> ?s2.0 -\\<tau>1\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s2 -\\<tau>2\\<rightarrow> \\<infinity>; s1 \\<approx> s2\\<rbrakk>\n    \\<Longrightarrow> s1 -\\<tau>1\\<rightarrow> \\<infinity>", "unfolding flip_simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s1.0 -\\<tau>2\\<rightarrow> \\<infinity>;\n   ?s2.0 \\<approx> ?s1.0\\<rbrakk>\n  \\<Longrightarrow> ?s2.0 -\\<tau>1\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s2 -\\<tau>2\\<rightarrow> \\<infinity>; s1 \\<approx> s2\\<rbrakk>\n    \\<Longrightarrow> s1 -\\<tau>1\\<rightarrow> \\<infinity>", "."], ["", "lemma \\<tau>diverge_bisim_inv:\n  \"s1 \\<approx> s2 \\<Longrightarrow> s1 -\\<tau>1\\<rightarrow> \\<infinity> \\<longleftrightarrow> s2 -\\<tau>2\\<rightarrow> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s1 \\<approx> s2 \\<Longrightarrow>\n    s1 -\\<tau>1\\<rightarrow> \\<infinity> =\n    s2 -\\<tau>2\\<rightarrow> \\<infinity>", "by(blast intro: \\<tau>diverge_simulation1 \\<tau>diverge_simulation2)"], ["", "end"], ["", "sublocale delay_bisimulation_measure < delay_bisimulation_diverge"], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge trsys1 trsys2 bisim tlsim \\<tau>move1\n     \\<tau>move2", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s1 s2 s1'.\n       \\<lbrakk>s1 \\<approx> s2; s1 -\\<tau>1\\<rightarrow> s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1'\n                            \\<approx> s2'\n 2. \\<And>s1 s2 s2'.\n       \\<lbrakk>s1 \\<approx> s2; s2 -\\<tau>2\\<rightarrow> s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and> s1'\n                            \\<approx> s2'\n 3. \\<And>s1 s2.\n       s1 \\<approx> s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> =\n       s2 -\\<tau>2\\<rightarrow> \\<infinity>", "fix s1 s2 s1'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s1 s2 s1'.\n       \\<lbrakk>s1 \\<approx> s2; s1 -\\<tau>1\\<rightarrow> s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1'\n                            \\<approx> s2'\n 2. \\<And>s1 s2 s2'.\n       \\<lbrakk>s1 \\<approx> s2; s2 -\\<tau>2\\<rightarrow> s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and> s1'\n                            \\<approx> s2'\n 3. \\<And>s1 s2.\n       s1 \\<approx> s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> =\n       s2 -\\<tau>2\\<rightarrow> \\<infinity>", "assume \"s1 \\<approx> s2\" \"s1 -\\<tau>1\\<rightarrow> s1'\""], ["proof (state)\nthis:\n  s1 \\<approx> s2\n  s1 -\\<tau>1\\<rightarrow> s1'\n\ngoal (3 subgoals):\n 1. \\<And>s1 s2 s1'.\n       \\<lbrakk>s1 \\<approx> s2; s1 -\\<tau>1\\<rightarrow> s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1'\n                            \\<approx> s2'\n 2. \\<And>s1 s2 s2'.\n       \\<lbrakk>s1 \\<approx> s2; s2 -\\<tau>2\\<rightarrow> s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and> s1'\n                            \\<approx> s2'\n 3. \\<And>s1 s2.\n       s1 \\<approx> s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> =\n       s2 -\\<tau>2\\<rightarrow> \\<infinity>", "from simulation_silent1[OF this]"], ["proof (chain)\npicking this:\n  s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n  (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')", "show \"\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2'\""], ["proof (prove)\nusing this:\n  s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n  (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')\n\ngoal (1 subgoal):\n 1. \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2'", "by(auto intro: tranclp_into_rtranclp)"], ["proof (state)\nthis:\n  \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s1' \\<approx> s2'\n\ngoal (2 subgoals):\n 1. \\<And>s1 s2 s2'.\n       \\<lbrakk>s1 \\<approx> s2; s2 -\\<tau>2\\<rightarrow> s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and> s1'\n                            \\<approx> s2'\n 2. \\<And>s1 s2.\n       s1 \\<approx> s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> =\n       s2 -\\<tau>2\\<rightarrow> \\<infinity>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s1 s2 s2'.\n       \\<lbrakk>s1 \\<approx> s2; s2 -\\<tau>2\\<rightarrow> s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and> s1'\n                            \\<approx> s2'\n 2. \\<And>s1 s2.\n       s1 \\<approx> s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> =\n       s2 -\\<tau>2\\<rightarrow> \\<infinity>", "fix s1 s2 s2'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s1 s2 s2'.\n       \\<lbrakk>s1 \\<approx> s2; s2 -\\<tau>2\\<rightarrow> s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and> s1'\n                            \\<approx> s2'\n 2. \\<And>s1 s2.\n       s1 \\<approx> s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> =\n       s2 -\\<tau>2\\<rightarrow> \\<infinity>", "assume \"s1 \\<approx> s2\" \"s2 -\\<tau>2\\<rightarrow> s2'\""], ["proof (state)\nthis:\n  s1 \\<approx> s2\n  s2 -\\<tau>2\\<rightarrow> s2'\n\ngoal (2 subgoals):\n 1. \\<And>s1 s2 s2'.\n       \\<lbrakk>s1 \\<approx> s2; s2 -\\<tau>2\\<rightarrow> s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and> s1'\n                            \\<approx> s2'\n 2. \\<And>s1 s2.\n       s1 \\<approx> s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> =\n       s2 -\\<tau>2\\<rightarrow> \\<infinity>", "from simulation_silent2[OF this]"], ["proof (chain)\npicking this:\n  s1 \\<approx> s2' \\<and> \\<mu>2\\<^sup>+\\<^sup>+ s2' s2 \\<or>\n  (\\<exists>s1'. s1 -\\<tau>1\\<rightarrow>+ s1' \\<and> s1' \\<approx> s2')", "show \"\\<exists>s1'. s1 -\\<tau>1\\<rightarrow>* s1' \\<and> s1' \\<approx> s2'\""], ["proof (prove)\nusing this:\n  s1 \\<approx> s2' \\<and> \\<mu>2\\<^sup>+\\<^sup>+ s2' s2 \\<or>\n  (\\<exists>s1'. s1 -\\<tau>1\\<rightarrow>+ s1' \\<and> s1' \\<approx> s2')\n\ngoal (1 subgoal):\n 1. \\<exists>s1'. s1 -\\<tau>1\\<rightarrow>* s1' \\<and> s1' \\<approx> s2'", "by(auto intro: tranclp_into_rtranclp)"], ["proof (state)\nthis:\n  \\<exists>s1'. s1 -\\<tau>1\\<rightarrow>* s1' \\<and> s1' \\<approx> s2'\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       s1 \\<approx> s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> =\n       s2 -\\<tau>2\\<rightarrow> \\<infinity>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       s1 \\<approx> s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> =\n       s2 -\\<tau>2\\<rightarrow> \\<infinity>", "fix s1 s2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       s1 \\<approx> s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> =\n       s2 -\\<tau>2\\<rightarrow> \\<infinity>", "assume \"s1 \\<approx> s2\""], ["proof (state)\nthis:\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       s1 \\<approx> s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> =\n       s2 -\\<tau>2\\<rightarrow> \\<infinity>", "thus \"s1 -\\<tau>1\\<rightarrow> \\<infinity> \\<longleftrightarrow> s2 -\\<tau>2\\<rightarrow> \\<infinity>\""], ["proof (prove)\nusing this:\n  s1 \\<approx> s2\n\ngoal (1 subgoal):\n 1. s1 -\\<tau>1\\<rightarrow> \\<infinity> =\n    s2 -\\<tau>2\\<rightarrow> \\<infinity>", "by(rule \\<tau>diverge_bisim_inv)"], ["proof (state)\nthis:\n  s1 -\\<tau>1\\<rightarrow> \\<infinity> =\n  s2 -\\<tau>2\\<rightarrow> \\<infinity>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Counter example for\n  @{prop \"delay_bisimulation_diverge trsys1 trsys2 bisim tlsim \\<tau>move1 \\<tau>move2 \\<Longrightarrow> \\<exists>\\<mu>1 \\<mu>2. delay_bisimulation_measure trsys1 trsys2 bisim tlsim \\<tau>move1 \\<tau>move2 \\<mu>1 \\<mu>2\"}\n\n (only \\<open>\\<tau>\\<close>moves):\n\\begin{verbatim}\n--|\n| v\n--a  ~  x\n  |     |\n  |     |\n  v     v\n--b  ~  y--\n| ^     ^ |\n--|     |--\n\\end{verbatim}\n\\<close>"], ["", "locale delay_bisimulation_measure_final =\n  delay_bisimulation_measure + \n  delay_bisimulation_final_base +\n  constrains trsys1 :: \"('s1, 'tl1) trsys\"\n  and trsys2 :: \"('s2, 'tl2) trsys\"\n  and bisim :: \"('s1, 's2) bisim\"\n  and tlsim :: \"('tl1, 'tl2) bisim\"\n  and \\<tau>move1 :: \"('s1, 'tl1) trsys\"\n  and \\<tau>move2 :: \"('s2, 'tl2) trsys\"\n  and \\<mu>1 :: \"'s1 \\<Rightarrow> 's1 \\<Rightarrow> bool\"\n  and \\<mu>2 :: \"'s2 \\<Rightarrow> 's2 \\<Rightarrow> bool\"\n  and final1 :: \"'s1 \\<Rightarrow> bool\"\n  and final2 :: \"'s2 \\<Rightarrow> bool\""], ["", "sublocale delay_bisimulation_measure_final < delay_bisimulation_diverge_final"], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge_final trsys1 trsys2 bisim tlsim \\<tau>move1\n     \\<tau>move2 final1 final2", "by unfold_locales"], ["", "locale \\<tau>inv = delay_bisimulation_base +\n  constrains trsys1 :: \"('s1, 'tl1) trsys\"\n  and trsys2 :: \"('s2, 'tl2) trsys\"\n  and bisim :: \"('s1, 's2) bisim\"\n  and tlsim :: \"('tl1, 'tl2) bisim\"\n  and \\<tau>move1 :: \"('s1, 'tl1) trsys\"\n  and \\<tau>move2 :: \"('s2, 'tl2) trsys\"\n  and \\<tau>moves1 :: \"'s1 \\<Rightarrow> 's1 \\<Rightarrow> bool\"\n  and \\<tau>moves2 :: \"'s2 \\<Rightarrow> 's2 \\<Rightarrow> bool\"\n  assumes \\<tau>inv: \"\\<lbrakk> s1 \\<approx> s2; s1 -1-tl1\\<rightarrow> s1'; s2 -2-tl2\\<rightarrow> s2'; s1' \\<approx> s2'; tl1 \\<sim> tl2 \\<rbrakk>\n                 \\<Longrightarrow> \\<tau>move1 s1 tl1 s1' \\<longleftrightarrow> \\<tau>move2 s2 tl2 s2'\"\nbegin"], ["", "lemma \\<tau>inv_flip:\n  \"\\<tau>inv trsys2 trsys1 (flip bisim) (flip tlsim) \\<tau>move2 \\<tau>move1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>inv trsys2 trsys1 (flip bisim) (flip tlsim) \\<tau>move2\n     \\<tau>move1", "by(unfold_locales)(unfold flip_simps,rule \\<tau>inv[symmetric])"], ["", "end"], ["", "lemma \\<tau>inv_flip_simps [flip_simps]:\n  \"\\<tau>inv trsys2 trsys1 (flip bisim) (flip tlsim) \\<tau>move2 \\<tau>move1 = \\<tau>inv trsys1 trsys2 bisim tlsim \\<tau>move1 \\<tau>move2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>inv trsys2 trsys1 (flip bisim) (flip tlsim) \\<tau>move2\n     \\<tau>move1 =\n    \\<tau>inv trsys1 trsys2 bisim tlsim \\<tau>move1 \\<tau>move2", "by(auto dest: \\<tau>inv.\\<tau>inv_flip simp only: flip_simps)"], ["", "locale bisimulation_into_delay =\n  bisimulation + \\<tau>inv +\n  constrains trsys1 :: \"('s1, 'tl1) trsys\"\n  and trsys2 :: \"('s2, 'tl2) trsys\"\n  and bisim :: \"('s1, 's2) bisim\"\n  and tlsim :: \"('tl1, 'tl2) bisim\"\n  and \\<tau>move1 :: \"('s1, 'tl1) trsys\"\n  and \\<tau>move2 :: \"('s2, 'tl2) trsys\"\nbegin"], ["", "lemma bisimulation_into_delay_flip:\n  \"bisimulation_into_delay trsys2 trsys1 (flip bisim) (flip tlsim) \\<tau>move2 \\<tau>move1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisimulation_into_delay trsys2 trsys1 (flip bisim) (flip tlsim)\n     \\<tau>move2 \\<tau>move1", "by(intro_locales)(intro bisimulation_flip \\<tau>inv_flip)+"], ["", "end"], ["", "lemma bisimulation_into_delay_flip_simps [flip_simps]:\n  \"bisimulation_into_delay trsys2 trsys1 (flip bisim) (flip tlsim) \\<tau>move2 \\<tau>move1 =\n   bisimulation_into_delay trsys1 trsys2 bisim tlsim \\<tau>move1 \\<tau>move2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisimulation_into_delay trsys2 trsys1 (flip bisim) (flip tlsim)\n     \\<tau>move2 \\<tau>move1 =\n    bisimulation_into_delay trsys1 trsys2 bisim tlsim \\<tau>move1\n     \\<tau>move2", "by(auto dest: bisimulation_into_delay.bisimulation_into_delay_flip simp only: flip_simps)"], ["", "context bisimulation_into_delay begin"], ["", "lemma simulation_silent1_aux:\n  assumes bisim: \"s1 \\<approx> s2\" and \"s1 -\\<tau>1\\<rightarrow> s1'\"\n  shows \"s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or> (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')", "from assms"], ["proof (chain)\npicking this:\n  s1 \\<approx> s2\n  s1 -\\<tau>1\\<rightarrow> s1'", "obtain tl1 where tr1: \"s1 -1-tl1\\<rightarrow> s1'\"\n    and \\<tau>1: \"\\<tau>move1 s1 tl1 s1'\""], ["proof (prove)\nusing this:\n  s1 \\<approx> s2\n  s1 -\\<tau>1\\<rightarrow> s1'\n\ngoal (1 subgoal):\n 1. (\\<And>tl1.\n        \\<lbrakk>s1 -1-tl1\\<rightarrow> s1'; \\<tau>move1 s1 tl1 s1'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto)"], ["proof (state)\nthis:\n  s1 -1-tl1\\<rightarrow> s1'\n  \\<tau>move1 s1 tl1 s1'\n\ngoal (1 subgoal):\n 1. s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')", "from simulation1[OF bisim tr1]"], ["proof (chain)\npicking this:\n  \\<exists>s2' tl2.\n     s2 -2-tl2\\<rightarrow> s2' \\<and>\n     s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2", "obtain s2' tl2 where tr2: \"s2 -2-tl2\\<rightarrow> s2'\"\n    and bisim': \"s1' \\<approx> s2'\" and tlsim: \"tl1 \\<sim> tl2\""], ["proof (prove)\nusing this:\n  \\<exists>s2' tl2.\n     s2 -2-tl2\\<rightarrow> s2' \\<and>\n     s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. (\\<And>tl2 s2'.\n        \\<lbrakk>s2 -2-tl2\\<rightarrow> s2'; s1' \\<approx> s2';\n         tl1 \\<sim> tl2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s2 -2-tl2\\<rightarrow> s2'\n  s1' \\<approx> s2'\n  tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')", "from \\<tau>inv[OF bisim tr1 tr2 bisim' tlsim] \\<tau>1"], ["proof (chain)\npicking this:\n  \\<tau>move1 s1 tl1 s1' = \\<tau>move2 s2 tl2 s2'\n  \\<tau>move1 s1 tl1 s1'", "have \\<tau>2: \"\\<tau>move2 s2 tl2 s2'\""], ["proof (prove)\nusing this:\n  \\<tau>move1 s1 tl1 s1' = \\<tau>move2 s2 tl2 s2'\n  \\<tau>move1 s1 tl1 s1'\n\ngoal (1 subgoal):\n 1. \\<tau>move2 s2 tl2 s2'", "by simp"], ["proof (state)\nthis:\n  \\<tau>move2 s2 tl2 s2'\n\ngoal (1 subgoal):\n 1. s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')", "from tr2 \\<tau>2"], ["proof (chain)\npicking this:\n  s2 -2-tl2\\<rightarrow> s2'\n  \\<tau>move2 s2 tl2 s2'", "have \"s2 -\\<tau>2\\<rightarrow>+ s2'\""], ["proof (prove)\nusing this:\n  s2 -2-tl2\\<rightarrow> s2'\n  \\<tau>move2 s2 tl2 s2'\n\ngoal (1 subgoal):\n 1. s2 -\\<tau>2\\<rightarrow>+ s2'", "by(auto)"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow>+ s2'\n\ngoal (1 subgoal):\n 1. s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')", "with bisim'"], ["proof (chain)\npicking this:\n  s1' \\<approx> s2'\n  s2 -\\<tau>2\\<rightarrow>+ s2'", "show ?thesis"], ["proof (prove)\nusing this:\n  s1' \\<approx> s2'\n  s2 -\\<tau>2\\<rightarrow>+ s2'\n\ngoal (1 subgoal):\n 1. s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n    (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')", "by blast"], ["proof (state)\nthis:\n  s1' \\<approx> s2 \\<and> \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n  (\\<exists>s2'. s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1' \\<approx> s2')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma simulation_silent2_aux:\n  \"\\<lbrakk> s1 \\<approx> s2; s2 -\\<tau>2\\<rightarrow> s2' \\<rbrakk> \\<Longrightarrow> s1 \\<approx> s2' \\<and> \\<mu>2\\<^sup>+\\<^sup>+ s2' s2 \\<or> (\\<exists>s1'. s1 -\\<tau>1\\<rightarrow>+ s1' \\<and> s1' \\<approx> s2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx> s2; s2 -\\<tau>2\\<rightarrow> s2'\\<rbrakk>\n    \\<Longrightarrow> s1 \\<approx> s2' \\<and>\n                      \\<mu>2\\<^sup>+\\<^sup>+ s2' s2 \\<or>\n                      (\\<exists>s1'.\n                          s1 -\\<tau>1\\<rightarrow>+ s1' \\<and> s1'\n                          \\<approx> s2')", "using bisimulation_into_delay.simulation_silent1_aux[OF bisimulation_into_delay_flip]"], ["proof (prove)\nusing this:\n  \\<lbrakk>flip bisim ?s1.0 ?s2.0; ?s1.0 -\\<tau>2\\<rightarrow> ?s1'\\<rbrakk>\n  \\<Longrightarrow> flip bisim ?s1' ?s2.0 \\<and>\n                    ?\\<mu>1.0\\<^sup>+\\<^sup>+ ?s1' ?s1.0 \\<or>\n                    (\\<exists>s2'.\n                        ?s2.0 -\\<tau>1\\<rightarrow>+ s2' \\<and>\n                        flip bisim ?s1' s2')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx> s2; s2 -\\<tau>2\\<rightarrow> s2'\\<rbrakk>\n    \\<Longrightarrow> s1 \\<approx> s2' \\<and>\n                      \\<mu>2\\<^sup>+\\<^sup>+ s2' s2 \\<or>\n                      (\\<exists>s1'.\n                          s1 -\\<tau>1\\<rightarrow>+ s1' \\<and> s1'\n                          \\<approx> s2')", "unfolding flip_simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s2.0 \\<approx> ?s1.0; ?s1.0 -\\<tau>2\\<rightarrow> ?s1'\\<rbrakk>\n  \\<Longrightarrow> ?s2.0 \\<approx> ?s1' \\<and>\n                    ?\\<mu>1.0\\<^sup>+\\<^sup>+ ?s1' ?s1.0 \\<or>\n                    (\\<exists>s2'.\n                        ?s2.0 -\\<tau>1\\<rightarrow>+ s2' \\<and> s2'\n                        \\<approx> ?s1')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx> s2; s2 -\\<tau>2\\<rightarrow> s2'\\<rbrakk>\n    \\<Longrightarrow> s1 \\<approx> s2' \\<and>\n                      \\<mu>2\\<^sup>+\\<^sup>+ s2' s2 \\<or>\n                      (\\<exists>s1'.\n                          s1 -\\<tau>1\\<rightarrow>+ s1' \\<and> s1'\n                          \\<approx> s2')", "."], ["", "lemma simulation1_aux:\n  assumes bisim: \"s1 \\<approx> s2\" and tr1: \"s1 -1-tl1\\<rightarrow> s1'\" and \\<tau>1: \"\\<not> \\<tau>move1 s1 tl1 s1'\"\n  shows \"\\<exists>s2' s2'' tl2. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> s2' -2-tl2\\<rightarrow> s2'' \\<and> \\<not> \\<tau>move2 s2' tl2 s2'' \\<and> s1' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s2' s2'' tl2.\n       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n       s2' -2-tl2\\<rightarrow> s2'' \\<and>\n       \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n       s1' \\<approx> s2'' \\<and> tl1 \\<sim> tl2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s2' s2'' tl2.\n       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n       s2' -2-tl2\\<rightarrow> s2'' \\<and>\n       \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n       s1' \\<approx> s2'' \\<and> tl1 \\<sim> tl2", "from simulation1[OF bisim tr1]"], ["proof (chain)\npicking this:\n  \\<exists>s2' tl2.\n     s2 -2-tl2\\<rightarrow> s2' \\<and>\n     s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2", "obtain s2' tl2 where tr2: \"s2 -2-tl2\\<rightarrow> s2'\"\n    and bisim': \"s1' \\<approx> s2'\" and tlsim: \"tl1 \\<sim> tl2\""], ["proof (prove)\nusing this:\n  \\<exists>s2' tl2.\n     s2 -2-tl2\\<rightarrow> s2' \\<and>\n     s1' \\<approx> s2' \\<and> tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. (\\<And>tl2 s2'.\n        \\<lbrakk>s2 -2-tl2\\<rightarrow> s2'; s1' \\<approx> s2';\n         tl1 \\<sim> tl2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s2 -2-tl2\\<rightarrow> s2'\n  s1' \\<approx> s2'\n  tl1 \\<sim> tl2\n\ngoal (1 subgoal):\n 1. \\<exists>s2' s2'' tl2.\n       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n       s2' -2-tl2\\<rightarrow> s2'' \\<and>\n       \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n       s1' \\<approx> s2'' \\<and> tl1 \\<sim> tl2", "from \\<tau>inv[OF bisim tr1 tr2 bisim' tlsim] \\<tau>1"], ["proof (chain)\npicking this:\n  \\<tau>move1 s1 tl1 s1' = \\<tau>move2 s2 tl2 s2'\n  \\<not> \\<tau>move1 s1 tl1 s1'", "have \\<tau>2: \"\\<not> \\<tau>move2 s2 tl2 s2'\""], ["proof (prove)\nusing this:\n  \\<tau>move1 s1 tl1 s1' = \\<tau>move2 s2 tl2 s2'\n  \\<not> \\<tau>move1 s1 tl1 s1'\n\ngoal (1 subgoal):\n 1. \\<not> \\<tau>move2 s2 tl2 s2'", "by simp"], ["proof (state)\nthis:\n  \\<not> \\<tau>move2 s2 tl2 s2'\n\ngoal (1 subgoal):\n 1. \\<exists>s2' s2'' tl2.\n       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n       s2' -2-tl2\\<rightarrow> s2'' \\<and>\n       \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n       s1' \\<approx> s2'' \\<and> tl1 \\<sim> tl2", "with bisim' tr2 tlsim"], ["proof (chain)\npicking this:\n  s1' \\<approx> s2'\n  s2 -2-tl2\\<rightarrow> s2'\n  tl1 \\<sim> tl2\n  \\<not> \\<tau>move2 s2 tl2 s2'", "show ?thesis"], ["proof (prove)\nusing this:\n  s1' \\<approx> s2'\n  s2 -2-tl2\\<rightarrow> s2'\n  tl1 \\<sim> tl2\n  \\<not> \\<tau>move2 s2 tl2 s2'\n\ngoal (1 subgoal):\n 1. \\<exists>s2' s2'' tl2.\n       s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n       s2' -2-tl2\\<rightarrow> s2'' \\<and>\n       \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n       s1' \\<approx> s2'' \\<and> tl1 \\<sim> tl2", "by blast"], ["proof (state)\nthis:\n  \\<exists>s2' s2'' tl2.\n     s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n     s2' -2-tl2\\<rightarrow> s2'' \\<and>\n     \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n     s1' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma simulation2_aux:\n  \"\\<lbrakk> s1 \\<approx> s2; s2 -2-tl2\\<rightarrow> s2'; \\<not> \\<tau>move2 s2 tl2 s2' \\<rbrakk>\n  \\<Longrightarrow> \\<exists>s1' s1'' tl1. s1 -\\<tau>1\\<rightarrow>* s1' \\<and> s1' -1-tl1\\<rightarrow> s1'' \\<and> \\<not> \\<tau>move1 s1' tl1 s1'' \\<and> s1'' \\<approx> s2' \\<and> tl1 \\<sim> tl2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx> s2; s2 -2-tl2\\<rightarrow> s2';\n     \\<not> \\<tau>move2 s2 tl2 s2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                         s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                         s1' -1-tl1\\<rightarrow> s1'' \\<and>\n                         \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                         s1'' \\<approx> s2' \\<and> tl1 \\<sim> tl2", "using bisimulation_into_delay.simulation1_aux[OF bisimulation_into_delay_flip]"], ["proof (prove)\nusing this:\n  \\<lbrakk>flip bisim ?s1.0 ?s2.0; ?s1.0 -2-?tl1.0\\<rightarrow> ?s1';\n   \\<not> \\<tau>move2 ?s1.0 ?tl1.0 ?s1'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                       ?s2.0 -\\<tau>1\\<rightarrow>* s2' \\<and>\n                       s2' -1-tl2\\<rightarrow> s2'' \\<and>\n                       \\<not> \\<tau>move1 s2' tl2 s2'' \\<and>\n                       flip bisim ?s1' s2'' \\<and> flip tlsim ?tl1.0 tl2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx> s2; s2 -2-tl2\\<rightarrow> s2';\n     \\<not> \\<tau>move2 s2 tl2 s2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                         s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                         s1' -1-tl1\\<rightarrow> s1'' \\<and>\n                         \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                         s1'' \\<approx> s2' \\<and> tl1 \\<sim> tl2", "unfolding flip_simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s2.0 \\<approx> ?s1.0; ?s1.0 -2-?tl1.0\\<rightarrow> ?s1';\n   \\<not> \\<tau>move2 ?s1.0 ?tl1.0 ?s1'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                       ?s2.0 -\\<tau>1\\<rightarrow>* s2' \\<and>\n                       s2' -1-tl2\\<rightarrow> s2'' \\<and>\n                       \\<not> \\<tau>move1 s2' tl2 s2'' \\<and>\n                       s2'' \\<approx> ?s1' \\<and> tl2 \\<sim> ?tl1.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<approx> s2; s2 -2-tl2\\<rightarrow> s2';\n     \\<not> \\<tau>move2 s2 tl2 s2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                         s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                         s1' -1-tl1\\<rightarrow> s1'' \\<and>\n                         \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                         s1'' \\<approx> s2' \\<and> tl1 \\<sim> tl2", "."], ["", "lemma delay_bisimulation_measure:\n  assumes wf_\\<mu>1: \"wfP \\<mu>1\"\n  and wf_\\<mu>2: \"wfP \\<mu>2\"\n  shows \"delay_bisimulation_measure trsys1 trsys2 bisim tlsim \\<tau>move1 \\<tau>move2 \\<mu>1 \\<mu>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_measure trsys1 trsys2 bisim tlsim \\<tau>move1\n     \\<tau>move2 \\<mu>1 \\<mu>2", "apply(unfold_locales)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>s1 \\<approx> s2; s1 -1-tl1\\<rightarrow> s1';\n        \\<not> \\<tau>move1 s1 tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n                            s2' -2-tl2\\<rightarrow> s2'' \\<and>\n                            \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n                            s1' \\<approx> s2'' \\<and> tl1 \\<sim> tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>s1 \\<approx> s2; s2 -2-tl2\\<rightarrow> s2';\n        \\<not> \\<tau>move2 s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            s1' -1-tl1\\<rightarrow> s1'' \\<and>\n                            \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                            s1'' \\<approx> s2' \\<and> tl1 \\<sim> tl2\n 3. \\<And>s1 s2 s1'.\n       \\<lbrakk>s1 \\<approx> s2; s1 -\\<tau>1\\<rightarrow> s1'\\<rbrakk>\n       \\<Longrightarrow> s1' \\<approx> s2 \\<and>\n                         \\<mu>1\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n                         (\\<exists>s2'.\n                             s2 -\\<tau>2\\<rightarrow>+ s2' \\<and> s1'\n                             \\<approx> s2')\n 4. \\<And>s1 s2 s2'.\n       \\<lbrakk>s1 \\<approx> s2; s2 -\\<tau>2\\<rightarrow> s2'\\<rbrakk>\n       \\<Longrightarrow> s1 \\<approx> s2' \\<and>\n                         \\<mu>2\\<^sup>+\\<^sup>+ s2' s2 \\<or>\n                         (\\<exists>s1'.\n                             s1 -\\<tau>1\\<rightarrow>+ s1' \\<and> s1'\n                             \\<approx> s2')\n 5. wfP \\<mu>1\n 6. wfP \\<mu>2", "apply(rule simulation_silent1_aux simulation_silent2_aux simulation1_aux simulation2_aux wf_\\<mu>1 wf_\\<mu>2|assumption)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma delay_bisimulation:\n  \"delay_bisimulation_diverge trsys1 trsys2 bisim tlsim \\<tau>move1 \\<tau>move2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge trsys1 trsys2 bisim tlsim \\<tau>move1\n     \\<tau>move2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge trsys1 trsys2 bisim tlsim \\<tau>move1\n     \\<tau>move2", "interpret delay_bisimulation_measure trsys1 trsys2 bisim tlsim \\<tau>move1 \\<tau>move2 \"\\<lambda>s s'. False\" \"\\<lambda>s s'. False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_measure trsys1 trsys2 bisim tlsim \\<tau>move1\n     \\<tau>move2 (\\<lambda>s s'. False) (\\<lambda>s s'. False)", "by(blast intro: delay_bisimulation_measure wfP_empty)"], ["proof (state)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge trsys1 trsys2 bisim tlsim \\<tau>move1\n     \\<tau>move2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge trsys1 trsys2 bisim tlsim \\<tau>move1\n     \\<tau>move2", ".."], ["proof (state)\nthis:\n  delay_bisimulation_diverge trsys1 trsys2 bisim tlsim \\<tau>move1\n   \\<tau>move2\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "sublocale bisimulation_into_delay < delay_bisimulation_diverge"], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge trsys1 trsys2 bisim tlsim \\<tau>move1\n     \\<tau>move2", "by(rule delay_bisimulation)"], ["", "lemma delay_bisimulation_conv_bisimulation:\n  \"delay_bisimulation_diverge trsys1 trsys2 bisim tlsim (\\<lambda>s tl s'. False) (\\<lambda>s tl s'. False) =\n   bisimulation trsys1 trsys2 bisim tlsim\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge trsys1 trsys2 bisim tlsim\n     (\\<lambda>s tl s'. False) (\\<lambda>s tl s'. False) =\n    bisimulation trsys1 trsys2 bisim tlsim", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. delay_bisimulation_diverge trsys1 trsys2 bisim tlsim\n     (\\<lambda>s tl s'. False) (\\<lambda>s tl s'. False) \\<Longrightarrow>\n    bisimulation trsys1 trsys2 bisim tlsim\n 2. bisimulation trsys1 trsys2 bisim tlsim \\<Longrightarrow>\n    delay_bisimulation_diverge trsys1 trsys2 bisim tlsim\n     (\\<lambda>s tl s'. False) (\\<lambda>s tl s'. False)", "assume ?lhs"], ["proof (state)\nthis:\n  delay_bisimulation_diverge trsys1 trsys2 bisim tlsim\n   (\\<lambda>s tl s'. False) (\\<lambda>s tl s'. False)\n\ngoal (2 subgoals):\n 1. delay_bisimulation_diverge trsys1 trsys2 bisim tlsim\n     (\\<lambda>s tl s'. False) (\\<lambda>s tl s'. False) \\<Longrightarrow>\n    bisimulation trsys1 trsys2 bisim tlsim\n 2. bisimulation trsys1 trsys2 bisim tlsim \\<Longrightarrow>\n    delay_bisimulation_diverge trsys1 trsys2 bisim tlsim\n     (\\<lambda>s tl s'. False) (\\<lambda>s tl s'. False)", "then"], ["proof (chain)\npicking this:\n  delay_bisimulation_diverge trsys1 trsys2 bisim tlsim\n   (\\<lambda>s tl s'. False) (\\<lambda>s tl s'. False)", "interpret delay_bisimulation_diverge trsys1 trsys2 bisim tlsim \"\\<lambda>s tl s'. False\" \"\\<lambda>s tl s'. False\""], ["proof (prove)\nusing this:\n  delay_bisimulation_diverge trsys1 trsys2 bisim tlsim\n   (\\<lambda>s tl s'. False) (\\<lambda>s tl s'. False)\n\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge trsys1 trsys2 bisim tlsim\n     (\\<lambda>s tl s'. False) (\\<lambda>s tl s'. False)", "."], ["proof (state)\ngoal (2 subgoals):\n 1. delay_bisimulation_diverge trsys1 trsys2 bisim tlsim\n     (\\<lambda>s tl s'. False) (\\<lambda>s tl s'. False) \\<Longrightarrow>\n    bisimulation trsys1 trsys2 bisim tlsim\n 2. bisimulation trsys1 trsys2 bisim tlsim \\<Longrightarrow>\n    delay_bisimulation_diverge trsys1 trsys2 bisim tlsim\n     (\\<lambda>s tl s'. False) (\\<lambda>s tl s'. False)", "show ?rhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. bisimulation trsys1 trsys2 bisim tlsim", "by(unfold_locales)(fastforce simp add: \\<tau>moves_False dest: simulation1 simulation2)+"], ["proof (state)\nthis:\n  bisimulation trsys1 trsys2 bisim tlsim\n\ngoal (1 subgoal):\n 1. bisimulation trsys1 trsys2 bisim tlsim \\<Longrightarrow>\n    delay_bisimulation_diverge trsys1 trsys2 bisim tlsim\n     (\\<lambda>s tl s'. False) (\\<lambda>s tl s'. False)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. bisimulation trsys1 trsys2 bisim tlsim \\<Longrightarrow>\n    delay_bisimulation_diverge trsys1 trsys2 bisim tlsim\n     (\\<lambda>s tl s'. False) (\\<lambda>s tl s'. False)", "assume ?rhs"], ["proof (state)\nthis:\n  bisimulation trsys1 trsys2 bisim tlsim\n\ngoal (1 subgoal):\n 1. bisimulation trsys1 trsys2 bisim tlsim \\<Longrightarrow>\n    delay_bisimulation_diverge trsys1 trsys2 bisim tlsim\n     (\\<lambda>s tl s'. False) (\\<lambda>s tl s'. False)", "then"], ["proof (chain)\npicking this:\n  bisimulation trsys1 trsys2 bisim tlsim", "interpret bisimulation trsys1 trsys2 bisim tlsim"], ["proof (prove)\nusing this:\n  bisimulation trsys1 trsys2 bisim tlsim\n\ngoal (1 subgoal):\n 1. bisimulation trsys1 trsys2 bisim tlsim", "."], ["proof (state)\ngoal (1 subgoal):\n 1. bisimulation trsys1 trsys2 bisim tlsim \\<Longrightarrow>\n    delay_bisimulation_diverge trsys1 trsys2 bisim tlsim\n     (\\<lambda>s tl s'. False) (\\<lambda>s tl s'. False)", "interpret bisimulation_into_delay trsys1 trsys2 bisim tlsim \"\\<lambda>s tl s'. False\" \"\\<lambda>s tl s'. False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisimulation_into_delay trsys1 trsys2 bisim tlsim\n     (\\<lambda>s tl s'. False) (\\<lambda>s tl s'. False)", "by(unfold_locales)(rule refl)"], ["proof (state)\ngoal (1 subgoal):\n 1. bisimulation trsys1 trsys2 bisim tlsim \\<Longrightarrow>\n    delay_bisimulation_diverge trsys1 trsys2 bisim tlsim\n     (\\<lambda>s tl s'. False) (\\<lambda>s tl s'. False)", "show ?lhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge trsys1 trsys2 bisim tlsim\n     (\\<lambda>s tl s'. False) (\\<lambda>s tl s'. False)", "by unfold_locales"], ["proof (state)\nthis:\n  delay_bisimulation_diverge trsys1 trsys2 bisim tlsim\n   (\\<lambda>s tl s'. False) (\\<lambda>s tl s'. False)\n\ngoal:\nNo subgoals!", "qed"], ["", "context bisimulation_final begin"], ["", "lemma delay_bisimulation_final_base: \n  \"delay_bisimulation_final_base trsys1 trsys2 bisim \\<tau>move1 \\<tau>move2 final1 final2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_final_base trsys1 trsys2 bisim \\<tau>move1\n     \\<tau>move2 final1 final2", "by(unfold_locales)(auto simp add: bisim_final)"], ["", "end"], ["", "sublocale bisimulation_final < delay_bisimulation_final_base"], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_final_base trsys1 trsys2 bisim \\<tau>move1\n     \\<tau>move2 final1 final2", "by(rule delay_bisimulation_final_base)"], ["", "subsection \\<open>Transitivity for bisimulations\\<close>"], ["", "definition bisim_compose :: \"('s1, 's2) bisim \\<Rightarrow> ('s2, 's3) bisim \\<Rightarrow> ('s1, 's3) bisim\" (infixr \"\\<circ>\\<^sub>B\" 60)\nwhere \"(bisim1 \\<circ>\\<^sub>B bisim2) s1 s3 \\<equiv> \\<exists>s2. bisim1 s1 s2 \\<and> bisim2 s2 s3\""], ["", "lemma bisim_composeI [intro]:\n  \"\\<lbrakk> bisim12 s1 s2; bisim23 s2 s3 \\<rbrakk> \\<Longrightarrow> (bisim12 \\<circ>\\<^sub>B bisim23) s1 s3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bisim12 s1 s2; bisim23 s2 s3\\<rbrakk>\n    \\<Longrightarrow> (bisim12 \\<circ>\\<^sub>B bisim23) s1 s3", "by(auto simp add: bisim_compose_def)"], ["", "lemma bisim_composeE [elim!]:\n  assumes bisim: \"(bisim12 \\<circ>\\<^sub>B bisim23) s1 s3\"\n  obtains s2 where \"bisim12 s1 s2\" \"bisim23 s2 s3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s2.\n        \\<lbrakk>bisim12 s1 s2; bisim23 s2 s3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(atomize_elim)(rule bisim[unfolded bisim_compose_def])"], ["", "lemma bisim_compose_assoc [simp]:\n  \"(bisim12 \\<circ>\\<^sub>B bisim23) \\<circ>\\<^sub>B bisim34 = bisim12 \\<circ>\\<^sub>B bisim23 \\<circ>\\<^sub>B bisim34\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bisim12 \\<circ>\\<^sub>B bisim23) \\<circ>\\<^sub>B bisim34 =\n    bisim12 \\<circ>\\<^sub>B bisim23 \\<circ>\\<^sub>B bisim34", "by(auto simp add: fun_eq_iff)"], ["", "lemma bisim_compose_conv_relcomp:\n  \"case_prod (bisim_compose bisim12 bisim23) = (\\<lambda>x. x \\<in> relcomp (Collect (case_prod bisim12)) (Collect (case_prod bisim23)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). (bisim12 \\<circ>\\<^sub>B bisim23) x y) =\n    (\\<lambda>x. x \\<in> {(x, y). bisim12 x y} O {(x, y). bisim23 x y})", "by(auto simp add: relcomp_unfold)"], ["", "lemma list_all2_bisim_composeI:\n  \"\\<lbrakk> list_all2 A xs ys; list_all2 B ys zs \\<rbrakk>\n  \\<Longrightarrow> list_all2 (A \\<circ>\\<^sub>B B) xs zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all2 A xs ys; list_all2 B ys zs\\<rbrakk>\n    \\<Longrightarrow> list_all2 (A \\<circ>\\<^sub>B B) xs zs", "by(rule list_all2_trans) auto+"], ["", "lemma delay_bisimulation_diverge_compose:\n  assumes wbisim12: \"delay_bisimulation_diverge trsys1 trsys2 bisim12 tlsim12 \\<tau>move1 \\<tau>move2\"\n  and wbisim23: \"delay_bisimulation_diverge trsys2 trsys3 bisim23 tlsim23 \\<tau>move2 \\<tau>move3\"\n  shows \"delay_bisimulation_diverge trsys1 trsys3 (bisim12 \\<circ>\\<^sub>B bisim23) (tlsim12 \\<circ>\\<^sub>B tlsim23) \\<tau>move1 \\<tau>move3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge trsys1 trsys3\n     (bisim12 \\<circ>\\<^sub>B bisim23) (tlsim12 \\<circ>\\<^sub>B tlsim23)\n     \\<tau>move1 \\<tau>move3", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge trsys1 trsys3\n     (bisim12 \\<circ>\\<^sub>B bisim23) (tlsim12 \\<circ>\\<^sub>B tlsim23)\n     \\<tau>move1 \\<tau>move3", "interpret trsys1: \\<tau>trsys trsys1 \\<tau>move1"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge trsys1 trsys3\n     (bisim12 \\<circ>\\<^sub>B bisim23) (tlsim12 \\<circ>\\<^sub>B tlsim23)\n     \\<tau>move1 \\<tau>move3", "interpret trsys2: \\<tau>trsys trsys2 \\<tau>move2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge trsys1 trsys3\n     (bisim12 \\<circ>\\<^sub>B bisim23) (tlsim12 \\<circ>\\<^sub>B tlsim23)\n     \\<tau>move1 \\<tau>move3", "interpret trsys3: \\<tau>trsys trsys3 \\<tau>move3"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge trsys1 trsys3\n     (bisim12 \\<circ>\\<^sub>B bisim23) (tlsim12 \\<circ>\\<^sub>B tlsim23)\n     \\<tau>move1 \\<tau>move3", "interpret wb12: delay_bisimulation_diverge trsys1 trsys2 bisim12 tlsim12 \\<tau>move1 \\<tau>move2"], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge trsys1 trsys2 bisim12 tlsim12 \\<tau>move1\n     \\<tau>move2", "by(auto intro: wbisim12)"], ["proof (state)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge trsys1 trsys3\n     (bisim12 \\<circ>\\<^sub>B bisim23) (tlsim12 \\<circ>\\<^sub>B tlsim23)\n     \\<tau>move1 \\<tau>move3", "interpret wb23: delay_bisimulation_diverge trsys2 trsys3 bisim23 tlsim23 \\<tau>move2 \\<tau>move3"], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge trsys2 trsys3 bisim23 tlsim23 \\<tau>move2\n     \\<tau>move3", "by(auto intro: wbisim23)"], ["proof (state)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge trsys1 trsys3\n     (bisim12 \\<circ>\\<^sub>B bisim23) (tlsim12 \\<circ>\\<^sub>B tlsim23)\n     \\<tau>move1 \\<tau>move3", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge trsys1 trsys3\n     (bisim12 \\<circ>\\<^sub>B bisim23) (tlsim12 \\<circ>\\<^sub>B tlsim23)\n     \\<tau>move1 \\<tau>move3", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys1 s1 tl1 s1';\n        \\<not> \\<tau>move1 s1 tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            trsys3 s2' tl2 s2'' \\<and>\n                            \\<not> \\<tau>move3 s2' tl2 s2'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1'\n                             s2'' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys3 s2 tl2 s2';\n        \\<not> \\<tau>move3 s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            trsys1 s1' tl1 s1'' \\<and>\n                            \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1''\n                             s2' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 3. \\<And>s1 s2 s1'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2;\n        s1 -\\<tau>1\\<rightarrow> s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2'\n 4. \\<And>s1 s2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2;\n        trsys3.silent_move s2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2'\n 5. \\<And>s1 s2.\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "fix s1 s3 s1'"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys1 s1 tl1 s1';\n        \\<not> \\<tau>move1 s1 tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            trsys3 s2' tl2 s2'' \\<and>\n                            \\<not> \\<tau>move3 s2' tl2 s2'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1'\n                             s2'' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys3 s2 tl2 s2';\n        \\<not> \\<tau>move3 s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            trsys1 s1' tl1 s1'' \\<and>\n                            \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1''\n                             s2' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 3. \\<And>s1 s2 s1'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2;\n        s1 -\\<tau>1\\<rightarrow> s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2'\n 4. \\<And>s1 s2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2;\n        trsys3.silent_move s2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2'\n 5. \\<And>s1 s2.\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "assume bisim: \"(bisim12 \\<circ>\\<^sub>B bisim23) s1 s3\" and tr1: \"trsys1.silent_move s1 s1'\""], ["proof (state)\nthis:\n  (bisim12 \\<circ>\\<^sub>B bisim23) s1 s3\n  s1 -\\<tau>1\\<rightarrow> s1'\n\ngoal (5 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys1 s1 tl1 s1';\n        \\<not> \\<tau>move1 s1 tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            trsys3 s2' tl2 s2'' \\<and>\n                            \\<not> \\<tau>move3 s2' tl2 s2'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1'\n                             s2'' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys3 s2 tl2 s2';\n        \\<not> \\<tau>move3 s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            trsys1 s1' tl1 s1'' \\<and>\n                            \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1''\n                             s2' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 3. \\<And>s1 s2 s1'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2;\n        s1 -\\<tau>1\\<rightarrow> s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2'\n 4. \\<And>s1 s2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2;\n        trsys3.silent_move s2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2'\n 5. \\<And>s1 s2.\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "from bisim"], ["proof (chain)\npicking this:\n  (bisim12 \\<circ>\\<^sub>B bisim23) s1 s3", "obtain s2 where bisim1: \"bisim12 s1 s2\" and bisim2: \"bisim23 s2 s3\""], ["proof (prove)\nusing this:\n  (bisim12 \\<circ>\\<^sub>B bisim23) s1 s3\n\ngoal (1 subgoal):\n 1. (\\<And>s2.\n        \\<lbrakk>bisim12 s1 s2; bisim23 s2 s3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  bisim12 s1 s2\n  bisim23 s2 s3\n\ngoal (5 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys1 s1 tl1 s1';\n        \\<not> \\<tau>move1 s1 tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            trsys3 s2' tl2 s2'' \\<and>\n                            \\<not> \\<tau>move3 s2' tl2 s2'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1'\n                             s2'' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys3 s2 tl2 s2';\n        \\<not> \\<tau>move3 s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            trsys1 s1' tl1 s1'' \\<and>\n                            \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1''\n                             s2' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 3. \\<And>s1 s2 s1'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2;\n        s1 -\\<tau>1\\<rightarrow> s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2'\n 4. \\<And>s1 s2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2;\n        trsys3.silent_move s2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2'\n 5. \\<And>s1 s2.\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "from wb12.simulation_silent1[OF bisim1 tr1]"], ["proof (chain)\npicking this:\n  \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> bisim12 s1' s2'", "obtain s2'\n      where tr2: \"trsys2.silent_moves s2 s2'\" and bisim1': \"bisim12 s1' s2'\""], ["proof (prove)\nusing this:\n  \\<exists>s2'. s2 -\\<tau>2\\<rightarrow>* s2' \\<and> bisim12 s1' s2'\n\ngoal (1 subgoal):\n 1. (\\<And>s2'.\n        \\<lbrakk>s2 -\\<tau>2\\<rightarrow>* s2'; bisim12 s1' s2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  bisim12 s1' s2'\n\ngoal (5 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys1 s1 tl1 s1';\n        \\<not> \\<tau>move1 s1 tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            trsys3 s2' tl2 s2'' \\<and>\n                            \\<not> \\<tau>move3 s2' tl2 s2'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1'\n                             s2'' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys3 s2 tl2 s2';\n        \\<not> \\<tau>move3 s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            trsys1 s1' tl1 s1'' \\<and>\n                            \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1''\n                             s2' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 3. \\<And>s1 s2 s1'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2;\n        s1 -\\<tau>1\\<rightarrow> s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2'\n 4. \\<And>s1 s2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2;\n        trsys3.silent_move s2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2'\n 5. \\<And>s1 s2.\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "from wb23.simulation_silents1[OF bisim2 tr2]"], ["proof (chain)\npicking this:\n  \\<exists>s2'a. trsys3.silent_moves s3 s2'a \\<and> bisim23 s2' s2'a", "obtain s3'\n      where \"trsys3.silent_moves s3 s3'\" \"bisim23 s2' s3'\""], ["proof (prove)\nusing this:\n  \\<exists>s2'a. trsys3.silent_moves s3 s2'a \\<and> bisim23 s2' s2'a\n\ngoal (1 subgoal):\n 1. (\\<And>s3'.\n        \\<lbrakk>trsys3.silent_moves s3 s3'; bisim23 s2' s3'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  trsys3.silent_moves s3 s3'\n  bisim23 s2' s3'\n\ngoal (5 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys1 s1 tl1 s1';\n        \\<not> \\<tau>move1 s1 tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            trsys3 s2' tl2 s2'' \\<and>\n                            \\<not> \\<tau>move3 s2' tl2 s2'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1'\n                             s2'' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys3 s2 tl2 s2';\n        \\<not> \\<tau>move3 s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            trsys1 s1' tl1 s1'' \\<and>\n                            \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1''\n                             s2' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 3. \\<And>s1 s2 s1'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2;\n        s1 -\\<tau>1\\<rightarrow> s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2'\n 4. \\<And>s1 s2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2;\n        trsys3.silent_move s2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2'\n 5. \\<And>s1 s2.\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "with bisim1'"], ["proof (chain)\npicking this:\n  bisim12 s1' s2'\n  trsys3.silent_moves s3 s3'\n  bisim23 s2' s3'", "show \"\\<exists>s3'. trsys3.silent_moves s3 s3' \\<and> (bisim12 \\<circ>\\<^sub>B bisim23) s1' s3'\""], ["proof (prove)\nusing this:\n  bisim12 s1' s2'\n  trsys3.silent_moves s3 s3'\n  bisim23 s2' s3'\n\ngoal (1 subgoal):\n 1. \\<exists>s3'.\n       trsys3.silent_moves s3 s3' \\<and>\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1' s3'", "by(blast intro: bisim_composeI)"], ["proof (state)\nthis:\n  \\<exists>s3'.\n     trsys3.silent_moves s3 s3' \\<and>\n     (bisim12 \\<circ>\\<^sub>B bisim23) s1' s3'\n\ngoal (4 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys1 s1 tl1 s1';\n        \\<not> \\<tau>move1 s1 tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            trsys3 s2' tl2 s2'' \\<and>\n                            \\<not> \\<tau>move3 s2' tl2 s2'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1'\n                             s2'' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys3 s2 tl2 s2';\n        \\<not> \\<tau>move3 s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            trsys1 s1' tl1 s1'' \\<and>\n                            \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1''\n                             s2' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 3. \\<And>s1 s2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2;\n        trsys3.silent_move s2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2'\n 4. \\<And>s1 s2.\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys1 s1 tl1 s1';\n        \\<not> \\<tau>move1 s1 tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            trsys3 s2' tl2 s2'' \\<and>\n                            \\<not> \\<tau>move3 s2' tl2 s2'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1'\n                             s2'' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys3 s2 tl2 s2';\n        \\<not> \\<tau>move3 s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            trsys1 s1' tl1 s1'' \\<and>\n                            \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1''\n                             s2' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 3. \\<And>s1 s2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2;\n        trsys3.silent_move s2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2'\n 4. \\<And>s1 s2.\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "fix s1 s3 s3'"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys1 s1 tl1 s1';\n        \\<not> \\<tau>move1 s1 tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            trsys3 s2' tl2 s2'' \\<and>\n                            \\<not> \\<tau>move3 s2' tl2 s2'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1'\n                             s2'' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys3 s2 tl2 s2';\n        \\<not> \\<tau>move3 s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            trsys1 s1' tl1 s1'' \\<and>\n                            \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1''\n                             s2' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 3. \\<And>s1 s2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2;\n        trsys3.silent_move s2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2'\n 4. \\<And>s1 s2.\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "assume bisim: \"(bisim12 \\<circ>\\<^sub>B bisim23) s1 s3\" and tr3: \"trsys3.silent_move s3 s3'\""], ["proof (state)\nthis:\n  (bisim12 \\<circ>\\<^sub>B bisim23) s1 s3\n  trsys3.silent_move s3 s3'\n\ngoal (4 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys1 s1 tl1 s1';\n        \\<not> \\<tau>move1 s1 tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            trsys3 s2' tl2 s2'' \\<and>\n                            \\<not> \\<tau>move3 s2' tl2 s2'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1'\n                             s2'' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys3 s2 tl2 s2';\n        \\<not> \\<tau>move3 s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            trsys1 s1' tl1 s1'' \\<and>\n                            \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1''\n                             s2' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 3. \\<And>s1 s2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2;\n        trsys3.silent_move s2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2'\n 4. \\<And>s1 s2.\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "from bisim"], ["proof (chain)\npicking this:\n  (bisim12 \\<circ>\\<^sub>B bisim23) s1 s3", "obtain s2 where bisim1: \"bisim12 s1 s2\" and bisim2: \"bisim23 s2 s3\""], ["proof (prove)\nusing this:\n  (bisim12 \\<circ>\\<^sub>B bisim23) s1 s3\n\ngoal (1 subgoal):\n 1. (\\<And>s2.\n        \\<lbrakk>bisim12 s1 s2; bisim23 s2 s3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  bisim12 s1 s2\n  bisim23 s2 s3\n\ngoal (4 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys1 s1 tl1 s1';\n        \\<not> \\<tau>move1 s1 tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            trsys3 s2' tl2 s2'' \\<and>\n                            \\<not> \\<tau>move3 s2' tl2 s2'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1'\n                             s2'' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys3 s2 tl2 s2';\n        \\<not> \\<tau>move3 s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            trsys1 s1' tl1 s1'' \\<and>\n                            \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1''\n                             s2' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 3. \\<And>s1 s2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2;\n        trsys3.silent_move s2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2'\n 4. \\<And>s1 s2.\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "from wb23.simulation_silent2[OF bisim2 tr3]"], ["proof (chain)\npicking this:\n  \\<exists>s1'. s2 -\\<tau>2\\<rightarrow>* s1' \\<and> bisim23 s1' s3'", "obtain s2'\n      where tr2: \"trsys2.silent_moves s2 s2'\" and bisim2': \"bisim23 s2' s3'\""], ["proof (prove)\nusing this:\n  \\<exists>s1'. s2 -\\<tau>2\\<rightarrow>* s1' \\<and> bisim23 s1' s3'\n\ngoal (1 subgoal):\n 1. (\\<And>s2'.\n        \\<lbrakk>s2 -\\<tau>2\\<rightarrow>* s2'; bisim23 s2' s3'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  bisim23 s2' s3'\n\ngoal (4 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys1 s1 tl1 s1';\n        \\<not> \\<tau>move1 s1 tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            trsys3 s2' tl2 s2'' \\<and>\n                            \\<not> \\<tau>move3 s2' tl2 s2'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1'\n                             s2'' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys3 s2 tl2 s2';\n        \\<not> \\<tau>move3 s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            trsys1 s1' tl1 s1'' \\<and>\n                            \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1''\n                             s2' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 3. \\<And>s1 s2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2;\n        trsys3.silent_move s2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2'\n 4. \\<And>s1 s2.\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "from wb12.simulation_silents2[OF bisim1 tr2]"], ["proof (chain)\npicking this:\n  \\<exists>s1'. s1 -\\<tau>1\\<rightarrow>* s1' \\<and> bisim12 s1' s2'", "obtain s1'\n      where \"trsys1.silent_moves s1 s1'\" \"bisim12 s1' s2'\""], ["proof (prove)\nusing this:\n  \\<exists>s1'. s1 -\\<tau>1\\<rightarrow>* s1' \\<and> bisim12 s1' s2'\n\ngoal (1 subgoal):\n 1. (\\<And>s1'.\n        \\<lbrakk>s1 -\\<tau>1\\<rightarrow>* s1'; bisim12 s1' s2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s1 -\\<tau>1\\<rightarrow>* s1'\n  bisim12 s1' s2'\n\ngoal (4 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys1 s1 tl1 s1';\n        \\<not> \\<tau>move1 s1 tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            trsys3 s2' tl2 s2'' \\<and>\n                            \\<not> \\<tau>move3 s2' tl2 s2'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1'\n                             s2'' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys3 s2 tl2 s2';\n        \\<not> \\<tau>move3 s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            trsys1 s1' tl1 s1'' \\<and>\n                            \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1''\n                             s2' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 3. \\<And>s1 s2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2;\n        trsys3.silent_move s2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2'\n 4. \\<And>s1 s2.\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "with bisim2'"], ["proof (chain)\npicking this:\n  bisim23 s2' s3'\n  s1 -\\<tau>1\\<rightarrow>* s1'\n  bisim12 s1' s2'", "show \"\\<exists>s1'. trsys1.silent_moves s1 s1' \\<and> (bisim12 \\<circ>\\<^sub>B bisim23) s1' s3'\""], ["proof (prove)\nusing this:\n  bisim23 s2' s3'\n  s1 -\\<tau>1\\<rightarrow>* s1'\n  bisim12 s1' s2'\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1' s3'", "by(blast intro: bisim_composeI)"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n     (bisim12 \\<circ>\\<^sub>B bisim23) s1' s3'\n\ngoal (3 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys1 s1 tl1 s1';\n        \\<not> \\<tau>move1 s1 tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            trsys3 s2' tl2 s2'' \\<and>\n                            \\<not> \\<tau>move3 s2' tl2 s2'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1'\n                             s2'' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys3 s2 tl2 s2';\n        \\<not> \\<tau>move3 s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            trsys1 s1' tl1 s1'' \\<and>\n                            \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1''\n                             s2' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 3. \\<And>s1 s2.\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys1 s1 tl1 s1';\n        \\<not> \\<tau>move1 s1 tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            trsys3 s2' tl2 s2'' \\<and>\n                            \\<not> \\<tau>move3 s2' tl2 s2'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1'\n                             s2'' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys3 s2 tl2 s2';\n        \\<not> \\<tau>move3 s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            trsys1 s1' tl1 s1'' \\<and>\n                            \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1''\n                             s2' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 3. \\<And>s1 s2.\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "fix s1 s3 tl1 s1'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys1 s1 tl1 s1';\n        \\<not> \\<tau>move1 s1 tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            trsys3 s2' tl2 s2'' \\<and>\n                            \\<not> \\<tau>move3 s2' tl2 s2'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1'\n                             s2'' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys3 s2 tl2 s2';\n        \\<not> \\<tau>move3 s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            trsys1 s1' tl1 s1'' \\<and>\n                            \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1''\n                             s2' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 3. \\<And>s1 s2.\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "assume bisim: \"(bisim12 \\<circ>\\<^sub>B bisim23) s1 s3\"\n      and tr1: \"trsys1 s1 tl1 s1'\" and \\<tau>1: \"\\<not> \\<tau>move1 s1 tl1 s1'\""], ["proof (state)\nthis:\n  (bisim12 \\<circ>\\<^sub>B bisim23) s1 s3\n  trsys1 s1 tl1 s1'\n  \\<not> \\<tau>move1 s1 tl1 s1'\n\ngoal (3 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys1 s1 tl1 s1';\n        \\<not> \\<tau>move1 s1 tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            trsys3 s2' tl2 s2'' \\<and>\n                            \\<not> \\<tau>move3 s2' tl2 s2'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1'\n                             s2'' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys3 s2 tl2 s2';\n        \\<not> \\<tau>move3 s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            trsys1 s1' tl1 s1'' \\<and>\n                            \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1''\n                             s2' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 3. \\<And>s1 s2.\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "from bisim"], ["proof (chain)\npicking this:\n  (bisim12 \\<circ>\\<^sub>B bisim23) s1 s3", "obtain s2 where bisim1: \"bisim12 s1 s2\" and bisim2: \"bisim23 s2 s3\""], ["proof (prove)\nusing this:\n  (bisim12 \\<circ>\\<^sub>B bisim23) s1 s3\n\ngoal (1 subgoal):\n 1. (\\<And>s2.\n        \\<lbrakk>bisim12 s1 s2; bisim23 s2 s3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  bisim12 s1 s2\n  bisim23 s2 s3\n\ngoal (3 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys1 s1 tl1 s1';\n        \\<not> \\<tau>move1 s1 tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            trsys3 s2' tl2 s2'' \\<and>\n                            \\<not> \\<tau>move3 s2' tl2 s2'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1'\n                             s2'' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys3 s2 tl2 s2';\n        \\<not> \\<tau>move3 s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            trsys1 s1' tl1 s1'' \\<and>\n                            \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1''\n                             s2' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 3. \\<And>s1 s2.\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "from wb12.simulation1[OF bisim1 tr1 \\<tau>1]"], ["proof (chain)\npicking this:\n  \\<exists>s2' s2'' tl2.\n     s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n     trsys2 s2' tl2 s2'' \\<and>\n     \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n     bisim12 s1' s2'' \\<and> tlsim12 tl1 tl2", "obtain s2' s2'' tl2\n      where tr21: \"trsys2.silent_moves s2 s2'\" and tr22: \"trsys2 s2' tl2 s2''\" and \\<tau>2: \"\\<not> \\<tau>move2 s2' tl2 s2''\"\n      and bisim1': \"bisim12 s1' s2''\" and tlsim1: \"tlsim12 tl1 tl2\""], ["proof (prove)\nusing this:\n  \\<exists>s2' s2'' tl2.\n     s2 -\\<tau>2\\<rightarrow>* s2' \\<and>\n     trsys2 s2' tl2 s2'' \\<and>\n     \\<not> \\<tau>move2 s2' tl2 s2'' \\<and>\n     bisim12 s1' s2'' \\<and> tlsim12 tl1 tl2\n\ngoal (1 subgoal):\n 1. (\\<And>s2' tl2 s2''.\n        \\<lbrakk>s2 -\\<tau>2\\<rightarrow>* s2'; trsys2 s2' tl2 s2'';\n         \\<not> \\<tau>move2 s2' tl2 s2''; bisim12 s1' s2'';\n         tlsim12 tl1 tl2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  trsys2 s2' tl2 s2''\n  \\<not> \\<tau>move2 s2' tl2 s2''\n  bisim12 s1' s2''\n  tlsim12 tl1 tl2\n\ngoal (3 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys1 s1 tl1 s1';\n        \\<not> \\<tau>move1 s1 tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            trsys3 s2' tl2 s2'' \\<and>\n                            \\<not> \\<tau>move3 s2' tl2 s2'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1'\n                             s2'' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys3 s2 tl2 s2';\n        \\<not> \\<tau>move3 s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            trsys1 s1' tl1 s1'' \\<and>\n                            \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1''\n                             s2' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 3. \\<And>s1 s2.\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "from wb23.simulation_silents1[OF bisim2 tr21]"], ["proof (chain)\npicking this:\n  \\<exists>s2'a. trsys3.silent_moves s3 s2'a \\<and> bisim23 s2' s2'a", "obtain s3'\n      where tr31: \"trsys3.silent_moves s3 s3'\" and bisim2': \"bisim23 s2' s3'\""], ["proof (prove)\nusing this:\n  \\<exists>s2'a. trsys3.silent_moves s3 s2'a \\<and> bisim23 s2' s2'a\n\ngoal (1 subgoal):\n 1. (\\<And>s3'.\n        \\<lbrakk>trsys3.silent_moves s3 s3'; bisim23 s2' s3'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  trsys3.silent_moves s3 s3'\n  bisim23 s2' s3'\n\ngoal (3 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys1 s1 tl1 s1';\n        \\<not> \\<tau>move1 s1 tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            trsys3 s2' tl2 s2'' \\<and>\n                            \\<not> \\<tau>move3 s2' tl2 s2'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1'\n                             s2'' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys3 s2 tl2 s2';\n        \\<not> \\<tau>move3 s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            trsys1 s1' tl1 s1'' \\<and>\n                            \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1''\n                             s2' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 3. \\<And>s1 s2.\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "from wb23.simulation1[OF bisim2' tr22 \\<tau>2]"], ["proof (chain)\npicking this:\n  \\<exists>s2' s2''a tl2a.\n     trsys3.silent_moves s3' s2' \\<and>\n     trsys3 s2' tl2a s2''a \\<and>\n     \\<not> \\<tau>move3 s2' tl2a s2''a \\<and>\n     bisim23 s2'' s2''a \\<and> tlsim23 tl2 tl2a", "obtain s3'' s3''' tl3\n      where \"trsys3.silent_moves s3' s3''\" \"trsys3 s3'' tl3 s3'''\"\n      \"\\<not> \\<tau>move3 s3'' tl3 s3'''\" \"bisim23 s2'' s3'''\" \"tlsim23 tl2 tl3\""], ["proof (prove)\nusing this:\n  \\<exists>s2' s2''a tl2a.\n     trsys3.silent_moves s3' s2' \\<and>\n     trsys3 s2' tl2a s2''a \\<and>\n     \\<not> \\<tau>move3 s2' tl2a s2''a \\<and>\n     bisim23 s2'' s2''a \\<and> tlsim23 tl2 tl2a\n\ngoal (1 subgoal):\n 1. (\\<And>s3'' tl3 s3'''.\n        \\<lbrakk>trsys3.silent_moves s3' s3''; trsys3 s3'' tl3 s3''';\n         \\<not> \\<tau>move3 s3'' tl3 s3'''; bisim23 s2'' s3''';\n         tlsim23 tl2 tl3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  trsys3.silent_moves s3' s3''\n  trsys3 s3'' tl3 s3'''\n  \\<not> \\<tau>move3 s3'' tl3 s3'''\n  bisim23 s2'' s3'''\n  tlsim23 tl2 tl3\n\ngoal (3 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys1 s1 tl1 s1';\n        \\<not> \\<tau>move1 s1 tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            trsys3 s2' tl2 s2'' \\<and>\n                            \\<not> \\<tau>move3 s2' tl2 s2'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1'\n                             s2'' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys3 s2 tl2 s2';\n        \\<not> \\<tau>move3 s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            trsys1 s1' tl1 s1'' \\<and>\n                            \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1''\n                             s2' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 3. \\<And>s1 s2.\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "with tr31 bisim1' tlsim1"], ["proof (chain)\npicking this:\n  trsys3.silent_moves s3 s3'\n  bisim12 s1' s2''\n  tlsim12 tl1 tl2\n  trsys3.silent_moves s3' s3''\n  trsys3 s3'' tl3 s3'''\n  \\<not> \\<tau>move3 s3'' tl3 s3'''\n  bisim23 s2'' s3'''\n  tlsim23 tl2 tl3", "show \"\\<exists>s3' s3'' tl3. trsys3.silent_moves s3 s3' \\<and> trsys3 s3' tl3 s3'' \\<and> \\<not> \\<tau>move3 s3' tl3 s3'' \\<and>\n                         (bisim12 \\<circ>\\<^sub>B bisim23) s1' s3'' \\<and> (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl3\""], ["proof (prove)\nusing this:\n  trsys3.silent_moves s3 s3'\n  bisim12 s1' s2''\n  tlsim12 tl1 tl2\n  trsys3.silent_moves s3' s3''\n  trsys3 s3'' tl3 s3'''\n  \\<not> \\<tau>move3 s3'' tl3 s3'''\n  bisim23 s2'' s3'''\n  tlsim23 tl2 tl3\n\ngoal (1 subgoal):\n 1. \\<exists>s3' s3'' tl3.\n       trsys3.silent_moves s3 s3' \\<and>\n       trsys3 s3' tl3 s3'' \\<and>\n       \\<not> \\<tau>move3 s3' tl3 s3'' \\<and>\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1' s3'' \\<and>\n       (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl3", "by(blast intro: rtranclp_trans bisim_composeI)"], ["proof (state)\nthis:\n  \\<exists>s3' s3'' tl3.\n     trsys3.silent_moves s3 s3' \\<and>\n     trsys3 s3' tl3 s3'' \\<and>\n     \\<not> \\<tau>move3 s3' tl3 s3'' \\<and>\n     (bisim12 \\<circ>\\<^sub>B bisim23) s1' s3'' \\<and>\n     (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl3\n\ngoal (2 subgoals):\n 1. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys3 s2 tl2 s2';\n        \\<not> \\<tau>move3 s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            trsys1 s1' tl1 s1'' \\<and>\n                            \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1''\n                             s2' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 2. \\<And>s1 s2.\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys3 s2 tl2 s2';\n        \\<not> \\<tau>move3 s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            trsys1 s1' tl1 s1'' \\<and>\n                            \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1''\n                             s2' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 2. \\<And>s1 s2.\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "fix s1 s3 tl3 s3'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys3 s2 tl2 s2';\n        \\<not> \\<tau>move3 s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            trsys1 s1' tl1 s1'' \\<and>\n                            \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1''\n                             s2' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 2. \\<And>s1 s2.\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "assume bisim: \"(bisim12 \\<circ>\\<^sub>B bisim23) s1 s3\"\n      and tr3: \"trsys3 s3 tl3 s3'\" and \\<tau>3: \"\\<not> \\<tau>move3 s3 tl3 s3'\""], ["proof (state)\nthis:\n  (bisim12 \\<circ>\\<^sub>B bisim23) s1 s3\n  trsys3 s3 tl3 s3'\n  \\<not> \\<tau>move3 s3 tl3 s3'\n\ngoal (2 subgoals):\n 1. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys3 s2 tl2 s2';\n        \\<not> \\<tau>move3 s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            trsys1 s1' tl1 s1'' \\<and>\n                            \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1''\n                             s2' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 2. \\<And>s1 s2.\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "from bisim"], ["proof (chain)\npicking this:\n  (bisim12 \\<circ>\\<^sub>B bisim23) s1 s3", "obtain s2 where bisim1: \"bisim12 s1 s2\" and bisim2: \"bisim23 s2 s3\""], ["proof (prove)\nusing this:\n  (bisim12 \\<circ>\\<^sub>B bisim23) s1 s3\n\ngoal (1 subgoal):\n 1. (\\<And>s2.\n        \\<lbrakk>bisim12 s1 s2; bisim23 s2 s3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  bisim12 s1 s2\n  bisim23 s2 s3\n\ngoal (2 subgoals):\n 1. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys3 s2 tl2 s2';\n        \\<not> \\<tau>move3 s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            trsys1 s1' tl1 s1'' \\<and>\n                            \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1''\n                             s2' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 2. \\<And>s1 s2.\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "from wb23.simulation2[OF bisim2 tr3 \\<tau>3]"], ["proof (chain)\npicking this:\n  \\<exists>s1' s1'' tl1.\n     s2 -\\<tau>2\\<rightarrow>* s1' \\<and>\n     trsys2 s1' tl1 s1'' \\<and>\n     \\<not> \\<tau>move2 s1' tl1 s1'' \\<and>\n     bisim23 s1'' s3' \\<and> tlsim23 tl1 tl3", "obtain s2' s2'' tl2\n      where tr21: \"trsys2.silent_moves s2 s2'\" and tr22: \"trsys2 s2' tl2 s2''\" and \\<tau>2: \"\\<not> \\<tau>move2 s2' tl2 s2''\"\n      and bisim2': \"bisim23 s2'' s3'\" and tlsim2: \"tlsim23 tl2 tl3\""], ["proof (prove)\nusing this:\n  \\<exists>s1' s1'' tl1.\n     s2 -\\<tau>2\\<rightarrow>* s1' \\<and>\n     trsys2 s1' tl1 s1'' \\<and>\n     \\<not> \\<tau>move2 s1' tl1 s1'' \\<and>\n     bisim23 s1'' s3' \\<and> tlsim23 tl1 tl3\n\ngoal (1 subgoal):\n 1. (\\<And>s2' tl2 s2''.\n        \\<lbrakk>s2 -\\<tau>2\\<rightarrow>* s2'; trsys2 s2' tl2 s2'';\n         \\<not> \\<tau>move2 s2' tl2 s2''; bisim23 s2'' s3';\n         tlsim23 tl2 tl3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  trsys2 s2' tl2 s2''\n  \\<not> \\<tau>move2 s2' tl2 s2''\n  bisim23 s2'' s3'\n  tlsim23 tl2 tl3\n\ngoal (2 subgoals):\n 1. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys3 s2 tl2 s2';\n        \\<not> \\<tau>move3 s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            trsys1 s1' tl1 s1'' \\<and>\n                            \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1''\n                             s2' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 2. \\<And>s1 s2.\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "from wb12.simulation_silents2[OF bisim1 tr21]"], ["proof (chain)\npicking this:\n  \\<exists>s1'. s1 -\\<tau>1\\<rightarrow>* s1' \\<and> bisim12 s1' s2'", "obtain s1'\n      where tr11: \"trsys1.silent_moves s1 s1'\" and bisim1': \"bisim12 s1' s2'\""], ["proof (prove)\nusing this:\n  \\<exists>s1'. s1 -\\<tau>1\\<rightarrow>* s1' \\<and> bisim12 s1' s2'\n\ngoal (1 subgoal):\n 1. (\\<And>s1'.\n        \\<lbrakk>s1 -\\<tau>1\\<rightarrow>* s1'; bisim12 s1' s2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s1 -\\<tau>1\\<rightarrow>* s1'\n  bisim12 s1' s2'\n\ngoal (2 subgoals):\n 1. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys3 s2 tl2 s2';\n        \\<not> \\<tau>move3 s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            trsys1 s1' tl1 s1'' \\<and>\n                            \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1''\n                             s2' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 2. \\<And>s1 s2.\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "from wb12.simulation2[OF bisim1' tr22 \\<tau>2]"], ["proof (chain)\npicking this:\n  \\<exists>s1'a s1'' tl1.\n     s1' -\\<tau>1\\<rightarrow>* s1'a \\<and>\n     trsys1 s1'a tl1 s1'' \\<and>\n     \\<not> \\<tau>move1 s1'a tl1 s1'' \\<and>\n     bisim12 s1'' s2'' \\<and> tlsim12 tl1 tl2", "obtain s1'' s1''' tl1\n      where \"trsys1.silent_moves s1' s1''\" \"trsys1 s1'' tl1 s1'''\"\n      \"\\<not> \\<tau>move1 s1'' tl1 s1'''\" \"bisim12 s1''' s2''\" \"tlsim12 tl1 tl2\""], ["proof (prove)\nusing this:\n  \\<exists>s1'a s1'' tl1.\n     s1' -\\<tau>1\\<rightarrow>* s1'a \\<and>\n     trsys1 s1'a tl1 s1'' \\<and>\n     \\<not> \\<tau>move1 s1'a tl1 s1'' \\<and>\n     bisim12 s1'' s2'' \\<and> tlsim12 tl1 tl2\n\ngoal (1 subgoal):\n 1. (\\<And>s1'' tl1 s1'''.\n        \\<lbrakk>s1' -\\<tau>1\\<rightarrow>* s1''; trsys1 s1'' tl1 s1''';\n         \\<not> \\<tau>move1 s1'' tl1 s1'''; bisim12 s1''' s2'';\n         tlsim12 tl1 tl2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s1' -\\<tau>1\\<rightarrow>* s1''\n  trsys1 s1'' tl1 s1'''\n  \\<not> \\<tau>move1 s1'' tl1 s1'''\n  bisim12 s1''' s2''\n  tlsim12 tl1 tl2\n\ngoal (2 subgoals):\n 1. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; trsys3 s2 tl2 s2';\n        \\<not> \\<tau>move3 s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            trsys1 s1' tl1 s1'' \\<and>\n                            \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1''\n                             s2' \\<and>\n                            (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl2\n 2. \\<And>s1 s2.\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "with tr11 bisim2' tlsim2"], ["proof (chain)\npicking this:\n  s1 -\\<tau>1\\<rightarrow>* s1'\n  bisim23 s2'' s3'\n  tlsim23 tl2 tl3\n  s1' -\\<tau>1\\<rightarrow>* s1''\n  trsys1 s1'' tl1 s1'''\n  \\<not> \\<tau>move1 s1'' tl1 s1'''\n  bisim12 s1''' s2''\n  tlsim12 tl1 tl2", "show \"\\<exists>s1' s1'' tl1. trsys1.silent_moves s1 s1' \\<and> trsys1 s1' tl1 s1'' \\<and> \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n                         (bisim12 \\<circ>\\<^sub>B bisim23) s1'' s3' \\<and> (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl3\""], ["proof (prove)\nusing this:\n  s1 -\\<tau>1\\<rightarrow>* s1'\n  bisim23 s2'' s3'\n  tlsim23 tl2 tl3\n  s1' -\\<tau>1\\<rightarrow>* s1''\n  trsys1 s1'' tl1 s1'''\n  \\<not> \\<tau>move1 s1'' tl1 s1'''\n  bisim12 s1''' s2''\n  tlsim12 tl1 tl2\n\ngoal (1 subgoal):\n 1. \\<exists>s1' s1'' tl1.\n       s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n       trsys1 s1' tl1 s1'' \\<and>\n       \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1'' s3' \\<and>\n       (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl3", "by(blast intro: rtranclp_trans bisim_composeI)"], ["proof (state)\nthis:\n  \\<exists>s1' s1'' tl1.\n     s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n     trsys1 s1' tl1 s1'' \\<and>\n     \\<not> \\<tau>move1 s1' tl1 s1'' \\<and>\n     (bisim12 \\<circ>\\<^sub>B bisim23) s1'' s3' \\<and>\n     (tlsim12 \\<circ>\\<^sub>B tlsim23) tl1 tl3\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "fix s1 s2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "assume \"(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2\""], ["proof (state)\nthis:\n  (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2 \\<Longrightarrow>\n       s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "thus \"\\<tau>trsys.\\<tau>diverge trsys1 \\<tau>move1 s1 = \\<tau>trsys.\\<tau>diverge trsys3 \\<tau>move3 s2\""], ["proof (prove)\nusing this:\n  (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2\n\ngoal (1 subgoal):\n 1. s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2", "by(auto simp add: wb12.\\<tau>diverge_bisim_inv wb23.\\<tau>diverge_bisim_inv)"], ["proof (state)\nthis:\n  s1 -\\<tau>1\\<rightarrow> \\<infinity> = trsys3.\\<tau>diverge s2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  delay_bisimulation_diverge trsys1 trsys3 (bisim12 \\<circ>\\<^sub>B bisim23)\n   (tlsim12 \\<circ>\\<^sub>B tlsim23) \\<tau>move1 \\<tau>move3\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bisimulation_bisim_compose:\n  \"\\<lbrakk> bisimulation trsys1 trsys2 bisim12 tlsim12; bisimulation trsys2 trsys3 bisim23 tlsim23 \\<rbrakk>\n  \\<Longrightarrow> bisimulation trsys1 trsys3 (bisim_compose bisim12 bisim23) (bisim_compose tlsim12 tlsim23)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bisimulation trsys1 trsys2 bisim12 tlsim12;\n     bisimulation trsys2 trsys3 bisim23 tlsim23\\<rbrakk>\n    \\<Longrightarrow> bisimulation trsys1 trsys3\n                       (bisim12 \\<circ>\\<^sub>B bisim23)\n                       (tlsim12 \\<circ>\\<^sub>B tlsim23)", "unfolding delay_bisimulation_conv_bisimulation[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>delay_bisimulation_diverge trsys1 trsys2 bisim12 tlsim12\n              (\\<lambda>s tl s'. False) (\\<lambda>s tl s'. False);\n     delay_bisimulation_diverge trsys2 trsys3 bisim23 tlsim23\n      (\\<lambda>s tl s'. False) (\\<lambda>s tl s'. False)\\<rbrakk>\n    \\<Longrightarrow> delay_bisimulation_diverge trsys1 trsys3\n                       (bisim12 \\<circ>\\<^sub>B bisim23)\n                       (tlsim12 \\<circ>\\<^sub>B tlsim23)\n                       (\\<lambda>s tl s'. False) (\\<lambda>s tl s'. False)", "by(rule delay_bisimulation_diverge_compose)"], ["", "lemma delay_bisimulation_diverge_final_compose:\n  fixes \\<tau>move1 \\<tau>move2\n  assumes wbisim12: \"delay_bisimulation_diverge_final trsys1 trsys2 bisim12 tlsim12 \\<tau>move1 \\<tau>move2 final1 final2\"\n  and wbisim23: \"delay_bisimulation_diverge_final trsys2 trsys3 bisim23 tlsim23 \\<tau>move2 \\<tau>move3 final2 final3\"\n  shows \"delay_bisimulation_diverge_final trsys1 trsys3 (bisim12 \\<circ>\\<^sub>B bisim23) (tlsim12 \\<circ>\\<^sub>B tlsim23) \\<tau>move1 \\<tau>move3 final1 final3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge_final trsys1 trsys3\n     (bisim12 \\<circ>\\<^sub>B bisim23) (tlsim12 \\<circ>\\<^sub>B tlsim23)\n     \\<tau>move1 \\<tau>move3 final1 final3", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge_final trsys1 trsys3\n     (bisim12 \\<circ>\\<^sub>B bisim23) (tlsim12 \\<circ>\\<^sub>B tlsim23)\n     \\<tau>move1 \\<tau>move3 final1 final3", "interpret trsys1: \\<tau>trsys trsys1 \\<tau>move1"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge_final trsys1 trsys3\n     (bisim12 \\<circ>\\<^sub>B bisim23) (tlsim12 \\<circ>\\<^sub>B tlsim23)\n     \\<tau>move1 \\<tau>move3 final1 final3", "interpret trsys2: \\<tau>trsys trsys2 \\<tau>move2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge_final trsys1 trsys3\n     (bisim12 \\<circ>\\<^sub>B bisim23) (tlsim12 \\<circ>\\<^sub>B tlsim23)\n     \\<tau>move1 \\<tau>move3 final1 final3", "interpret trsys3: \\<tau>trsys trsys3 \\<tau>move3"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge_final trsys1 trsys3\n     (bisim12 \\<circ>\\<^sub>B bisim23) (tlsim12 \\<circ>\\<^sub>B tlsim23)\n     \\<tau>move1 \\<tau>move3 final1 final3", "interpret wb12: delay_bisimulation_diverge_final trsys1 trsys2 bisim12 tlsim12 \\<tau>move1 \\<tau>move2 final1 final2"], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge_final trsys1 trsys2 bisim12 tlsim12\n     \\<tau>move1 \\<tau>move2 final1 final2", "by(auto intro: wbisim12)"], ["proof (state)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge_final trsys1 trsys3\n     (bisim12 \\<circ>\\<^sub>B bisim23) (tlsim12 \\<circ>\\<^sub>B tlsim23)\n     \\<tau>move1 \\<tau>move3 final1 final3", "interpret wb23: delay_bisimulation_diverge_final trsys2 trsys3 bisim23 tlsim23 \\<tau>move2 \\<tau>move3 final2 final3"], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge_final trsys2 trsys3 bisim23 tlsim23\n     \\<tau>move2 \\<tau>move3 final2 final3", "by(auto intro: wbisim23)"], ["proof (state)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge_final trsys1 trsys3\n     (bisim12 \\<circ>\\<^sub>B bisim23) (tlsim12 \\<circ>\\<^sub>B tlsim23)\n     \\<tau>move1 \\<tau>move3 final1 final3", "interpret delay_bisimulation_diverge trsys1 trsys3 \"bisim12 \\<circ>\\<^sub>B bisim23\" \"tlsim12 \\<circ>\\<^sub>B tlsim23\" \\<tau>move1 \\<tau>move3"], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge trsys1 trsys3\n     (bisim12 \\<circ>\\<^sub>B bisim23) (tlsim12 \\<circ>\\<^sub>B tlsim23)\n     \\<tau>move1 \\<tau>move3", "by(rule delay_bisimulation_diverge_compose)(unfold_locales)"], ["proof (state)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge_final trsys1 trsys3\n     (bisim12 \\<circ>\\<^sub>B bisim23) (tlsim12 \\<circ>\\<^sub>B tlsim23)\n     \\<tau>move1 \\<tau>move3 final1 final3", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge_final trsys1 trsys3\n     (bisim12 \\<circ>\\<^sub>B bisim23) (tlsim12 \\<circ>\\<^sub>B tlsim23)\n     \\<tau>move1 \\<tau>move3 final1 final3", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; final1 s1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2' \\<and>\n                            final3 s2'\n 2. \\<And>s1 s2.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; final3 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2 \\<and>\n                            final1 s1'", "fix s1 s3"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; final1 s1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2' \\<and>\n                            final3 s2'\n 2. \\<And>s1 s2.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; final3 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2 \\<and>\n                            final1 s1'", "assume \"(bisim12 \\<circ>\\<^sub>B bisim23) s1 s3\" \"final1 s1\""], ["proof (state)\nthis:\n  (bisim12 \\<circ>\\<^sub>B bisim23) s1 s3\n  final1 s1\n\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; final1 s1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2' \\<and>\n                            final3 s2'\n 2. \\<And>s1 s2.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; final3 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2 \\<and>\n                            final1 s1'", "from \\<open>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s3\\<close>"], ["proof (chain)\npicking this:\n  (bisim12 \\<circ>\\<^sub>B bisim23) s1 s3", "obtain s2 where \"bisim12 s1 s2\" and \"bisim23 s2 s3\""], ["proof (prove)\nusing this:\n  (bisim12 \\<circ>\\<^sub>B bisim23) s1 s3\n\ngoal (1 subgoal):\n 1. (\\<And>s2.\n        \\<lbrakk>bisim12 s1 s2; bisim23 s2 s3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  bisim12 s1 s2\n  bisim23 s2 s3\n\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; final1 s1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2' \\<and>\n                            final3 s2'\n 2. \\<And>s1 s2.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; final3 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2 \\<and>\n                            final1 s1'", "from wb12.final1_simulation[OF \\<open>bisim12 s1 s2\\<close> \\<open>final1 s1\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>s2'.\n     s2 -\\<tau>2\\<rightarrow>* s2' \\<and> bisim12 s1 s2' \\<and> final2 s2'", "obtain s2' where \"trsys2.silent_moves s2 s2'\" \"bisim12 s1 s2'\" \"final2 s2'\""], ["proof (prove)\nusing this:\n  \\<exists>s2'.\n     s2 -\\<tau>2\\<rightarrow>* s2' \\<and> bisim12 s1 s2' \\<and> final2 s2'\n\ngoal (1 subgoal):\n 1. (\\<And>s2'.\n        \\<lbrakk>s2 -\\<tau>2\\<rightarrow>* s2'; bisim12 s1 s2';\n         final2 s2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  bisim12 s1 s2'\n  final2 s2'\n\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; final1 s1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2' \\<and>\n                            final3 s2'\n 2. \\<And>s1 s2.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; final3 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2 \\<and>\n                            final1 s1'", "from wb23.simulation_silents1[OF \\<open>bisim23 s2 s3\\<close> \\<open>trsys2.silent_moves s2 s2'\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>s2'a. trsys3.silent_moves s3 s2'a \\<and> bisim23 s2' s2'a", "obtain s3' where \"trsys3.silent_moves s3 s3'\" \"bisim23 s2' s3'\""], ["proof (prove)\nusing this:\n  \\<exists>s2'a. trsys3.silent_moves s3 s2'a \\<and> bisim23 s2' s2'a\n\ngoal (1 subgoal):\n 1. (\\<And>s3'.\n        \\<lbrakk>trsys3.silent_moves s3 s3'; bisim23 s2' s3'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  trsys3.silent_moves s3 s3'\n  bisim23 s2' s3'\n\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; final1 s1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2' \\<and>\n                            final3 s2'\n 2. \\<And>s1 s2.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; final3 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2 \\<and>\n                            final1 s1'", "from wb23.final1_simulation[OF \\<open>bisim23 s2' s3'\\<close> \\<open>final2 s2'\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>s2'a.\n     trsys3.silent_moves s3' s2'a \\<and> bisim23 s2' s2'a \\<and> final3 s2'a", "obtain s3'' where \"trsys3.silent_moves s3' s3''\" \"bisim23 s2' s3''\" \"final3 s3''\""], ["proof (prove)\nusing this:\n  \\<exists>s2'a.\n     trsys3.silent_moves s3' s2'a \\<and> bisim23 s2' s2'a \\<and> final3 s2'a\n\ngoal (1 subgoal):\n 1. (\\<And>s3''.\n        \\<lbrakk>trsys3.silent_moves s3' s3''; bisim23 s2' s3'';\n         final3 s3''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  trsys3.silent_moves s3' s3''\n  bisim23 s2' s3''\n  final3 s3''\n\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; final1 s1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2' \\<and>\n                            final3 s2'\n 2. \\<And>s1 s2.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; final3 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2 \\<and>\n                            final1 s1'", "from \\<open>trsys3.silent_moves s3 s3'\\<close> \\<open>trsys3.silent_moves s3' s3''\\<close>"], ["proof (chain)\npicking this:\n  trsys3.silent_moves s3 s3'\n  trsys3.silent_moves s3' s3''", "have \"trsys3.silent_moves s3 s3''\""], ["proof (prove)\nusing this:\n  trsys3.silent_moves s3 s3'\n  trsys3.silent_moves s3' s3''\n\ngoal (1 subgoal):\n 1. trsys3.silent_moves s3 s3''", "by(rule rtranclp_trans)"], ["proof (state)\nthis:\n  trsys3.silent_moves s3 s3''\n\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; final1 s1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2' \\<and>\n                            final3 s2'\n 2. \\<And>s1 s2.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; final3 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2 \\<and>\n                            final1 s1'", "moreover"], ["proof (state)\nthis:\n  trsys3.silent_moves s3 s3''\n\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; final1 s1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2' \\<and>\n                            final3 s2'\n 2. \\<And>s1 s2.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; final3 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2 \\<and>\n                            final1 s1'", "from \\<open>bisim12 s1 s2'\\<close> \\<open>bisim23 s2' s3''\\<close>"], ["proof (chain)\npicking this:\n  bisim12 s1 s2'\n  bisim23 s2' s3''", "have \"(bisim12 \\<circ>\\<^sub>B bisim23) s1 s3''\""], ["proof (prove)\nusing this:\n  bisim12 s1 s2'\n  bisim23 s2' s3''\n\ngoal (1 subgoal):\n 1. (bisim12 \\<circ>\\<^sub>B bisim23) s1 s3''", ".."], ["proof (state)\nthis:\n  (bisim12 \\<circ>\\<^sub>B bisim23) s1 s3''\n\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; final1 s1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            trsys3.silent_moves s2 s2' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1 s2' \\<and>\n                            final3 s2'\n 2. \\<And>s1 s2.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; final3 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2 \\<and>\n                            final1 s1'", "ultimately"], ["proof (chain)\npicking this:\n  trsys3.silent_moves s3 s3''\n  (bisim12 \\<circ>\\<^sub>B bisim23) s1 s3''", "show \"\\<exists>s3'. trsys3.silent_moves s3 s3' \\<and> (bisim12 \\<circ>\\<^sub>B bisim23) s1 s3' \\<and> final3 s3'\""], ["proof (prove)\nusing this:\n  trsys3.silent_moves s3 s3''\n  (bisim12 \\<circ>\\<^sub>B bisim23) s1 s3''\n\ngoal (1 subgoal):\n 1. \\<exists>s3'.\n       trsys3.silent_moves s3 s3' \\<and>\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s3' \\<and> final3 s3'", "using \\<open>final3 s3''\\<close>"], ["proof (prove)\nusing this:\n  trsys3.silent_moves s3 s3''\n  (bisim12 \\<circ>\\<^sub>B bisim23) s1 s3''\n  final3 s3''\n\ngoal (1 subgoal):\n 1. \\<exists>s3'.\n       trsys3.silent_moves s3 s3' \\<and>\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1 s3' \\<and> final3 s3'", "by iprover"], ["proof (state)\nthis:\n  \\<exists>s3'.\n     trsys3.silent_moves s3 s3' \\<and>\n     (bisim12 \\<circ>\\<^sub>B bisim23) s1 s3' \\<and> final3 s3'\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; final3 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2 \\<and>\n                            final1 s1'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; final3 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2 \\<and>\n                            final1 s1'", "fix s1 s3"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; final3 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2 \\<and>\n                            final1 s1'", "assume \"(bisim12 \\<circ>\\<^sub>B bisim23) s1 s3\" \"final3 s3\""], ["proof (state)\nthis:\n  (bisim12 \\<circ>\\<^sub>B bisim23) s1 s3\n  final3 s3\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; final3 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2 \\<and>\n                            final1 s1'", "from \\<open>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s3\\<close>"], ["proof (chain)\npicking this:\n  (bisim12 \\<circ>\\<^sub>B bisim23) s1 s3", "obtain s2 where \"bisim12 s1 s2\" and \"bisim23 s2 s3\""], ["proof (prove)\nusing this:\n  (bisim12 \\<circ>\\<^sub>B bisim23) s1 s3\n\ngoal (1 subgoal):\n 1. (\\<And>s2.\n        \\<lbrakk>bisim12 s1 s2; bisim23 s2 s3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  bisim12 s1 s2\n  bisim23 s2 s3\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; final3 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2 \\<and>\n                            final1 s1'", "from wb23.final2_simulation[OF \\<open>bisim23 s2 s3\\<close> \\<open>final3 s3\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>s1'.\n     s2 -\\<tau>2\\<rightarrow>* s1' \\<and> bisim23 s1' s3 \\<and> final2 s1'", "obtain s2' where \"trsys2.silent_moves s2 s2'\" \"bisim23 s2' s3\" \"final2 s2'\""], ["proof (prove)\nusing this:\n  \\<exists>s1'.\n     s2 -\\<tau>2\\<rightarrow>* s1' \\<and> bisim23 s1' s3 \\<and> final2 s1'\n\ngoal (1 subgoal):\n 1. (\\<And>s2'.\n        \\<lbrakk>s2 -\\<tau>2\\<rightarrow>* s2'; bisim23 s2' s3;\n         final2 s2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s2 -\\<tau>2\\<rightarrow>* s2'\n  bisim23 s2' s3\n  final2 s2'\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; final3 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2 \\<and>\n                            final1 s1'", "from wb12.simulation_silents2[OF \\<open>bisim12 s1 s2\\<close> \\<open>trsys2.silent_moves s2 s2'\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>s1'. s1 -\\<tau>1\\<rightarrow>* s1' \\<and> bisim12 s1' s2'", "obtain s1' where \"trsys1.silent_moves s1 s1'\" \"bisim12 s1' s2'\""], ["proof (prove)\nusing this:\n  \\<exists>s1'. s1 -\\<tau>1\\<rightarrow>* s1' \\<and> bisim12 s1' s2'\n\ngoal (1 subgoal):\n 1. (\\<And>s1'.\n        \\<lbrakk>s1 -\\<tau>1\\<rightarrow>* s1'; bisim12 s1' s2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s1 -\\<tau>1\\<rightarrow>* s1'\n  bisim12 s1' s2'\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; final3 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2 \\<and>\n                            final1 s1'", "from wb12.final2_simulation[OF \\<open>bisim12 s1' s2'\\<close> \\<open>final2 s2'\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>s1'a.\n     s1' -\\<tau>1\\<rightarrow>* s1'a \\<and>\n     bisim12 s1'a s2' \\<and> final1 s1'a", "obtain s1'' where \"trsys1.silent_moves s1' s1''\" \"bisim12 s1'' s2'\" \"final1 s1''\""], ["proof (prove)\nusing this:\n  \\<exists>s1'a.\n     s1' -\\<tau>1\\<rightarrow>* s1'a \\<and>\n     bisim12 s1'a s2' \\<and> final1 s1'a\n\ngoal (1 subgoal):\n 1. (\\<And>s1''.\n        \\<lbrakk>s1' -\\<tau>1\\<rightarrow>* s1''; bisim12 s1'' s2';\n         final1 s1''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s1' -\\<tau>1\\<rightarrow>* s1''\n  bisim12 s1'' s2'\n  final1 s1''\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; final3 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2 \\<and>\n                            final1 s1'", "from \\<open>trsys1.silent_moves s1 s1'\\<close> \\<open>trsys1.silent_moves s1' s1''\\<close>"], ["proof (chain)\npicking this:\n  s1 -\\<tau>1\\<rightarrow>* s1'\n  s1' -\\<tau>1\\<rightarrow>* s1''", "have \"trsys1.silent_moves s1 s1''\""], ["proof (prove)\nusing this:\n  s1 -\\<tau>1\\<rightarrow>* s1'\n  s1' -\\<tau>1\\<rightarrow>* s1''\n\ngoal (1 subgoal):\n 1. s1 -\\<tau>1\\<rightarrow>* s1''", "by(rule rtranclp_trans)"], ["proof (state)\nthis:\n  s1 -\\<tau>1\\<rightarrow>* s1''\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; final3 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2 \\<and>\n                            final1 s1'", "moreover"], ["proof (state)\nthis:\n  s1 -\\<tau>1\\<rightarrow>* s1''\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; final3 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2 \\<and>\n                            final1 s1'", "from \\<open>bisim12 s1'' s2'\\<close> \\<open>bisim23 s2' s3\\<close>"], ["proof (chain)\npicking this:\n  bisim12 s1'' s2'\n  bisim23 s2' s3", "have \"(bisim12 \\<circ>\\<^sub>B bisim23) s1'' s3\""], ["proof (prove)\nusing this:\n  bisim12 s1'' s2'\n  bisim23 s2' s3\n\ngoal (1 subgoal):\n 1. (bisim12 \\<circ>\\<^sub>B bisim23) s1'' s3", ".."], ["proof (state)\nthis:\n  (bisim12 \\<circ>\\<^sub>B bisim23) s1'' s3\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       \\<lbrakk>(bisim12 \\<circ>\\<^sub>B bisim23) s1 s2; final3 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n                            (bisim12 \\<circ>\\<^sub>B bisim23) s1' s2 \\<and>\n                            final1 s1'", "ultimately"], ["proof (chain)\npicking this:\n  s1 -\\<tau>1\\<rightarrow>* s1''\n  (bisim12 \\<circ>\\<^sub>B bisim23) s1'' s3", "show \"\\<exists>s1'. trsys1.silent_moves s1 s1' \\<and> (bisim12 \\<circ>\\<^sub>B bisim23) s1' s3 \\<and> final1 s1'\""], ["proof (prove)\nusing this:\n  s1 -\\<tau>1\\<rightarrow>* s1''\n  (bisim12 \\<circ>\\<^sub>B bisim23) s1'' s3\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1' s3 \\<and> final1 s1'", "using \\<open>final1 s1''\\<close>"], ["proof (prove)\nusing this:\n  s1 -\\<tau>1\\<rightarrow>* s1''\n  (bisim12 \\<circ>\\<^sub>B bisim23) s1'' s3\n  final1 s1''\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n       (bisim12 \\<circ>\\<^sub>B bisim23) s1' s3 \\<and> final1 s1'", "by iprover"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     s1 -\\<tau>1\\<rightarrow>* s1' \\<and>\n     (bisim12 \\<circ>\\<^sub>B bisim23) s1' s3 \\<and> final1 s1'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  delay_bisimulation_diverge_final trsys1 trsys3\n   (bisim12 \\<circ>\\<^sub>B bisim23) (tlsim12 \\<circ>\\<^sub>B tlsim23)\n   \\<tau>move1 \\<tau>move3 final1 final3\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}