{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Execute/Round_Robin.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma set_enqueue_new_thread: \n  \"set (enqueue_new_thread queue nta) = set queue \\<union> {t. \\<exists>x m. nta = NewThread t x m}\"", "lemma set_enqueue_new_threads: \n  \"set (enqueue_new_threads queue ntas) = set queue \\<union> {t. \\<exists>x m. NewThread t x m \\<in> set ntas}\"", "lemma enqueue_new_thread_eq_Nil [simp]:\n  \"enqueue_new_thread queue nta = [] \\<longleftrightarrow> queue = [] \\<and> (\\<exists>t b. nta = ThreadExists t b)\"", "lemma enqueue_new_threads_eq_Nil [simp]:\n  \"enqueue_new_threads queue ntas = [] \\<longleftrightarrow> queue = [] \\<and> set ntas \\<subseteq> {ThreadExists t b|t b. True}\"", "lemma distinct_enqueue_new_threads:\n  fixes ts :: \"('l,'t,'x) thread_info\"\n  and ntas :: \"('t,'x,'m) new_thread_action list\"\n  assumes \"thread_oks ts ntas\" \"set queue = dom ts\" \"distinct queue\"\n  shows \"distinct (enqueue_new_threads queue ntas)\"", "lemma round_robin_reschedule_induct [consumes 1, case_names head rotate]:\n  assumes major: \"t0 \\<in> set queue\"\n  and head: \"\\<And>queue. P (t0 # queue)\"\n  and rotate: \"\\<And>queue t. \\<lbrakk> t \\<noteq> t0; t0 \\<in> set queue; P (queue @ [t]) \\<rbrakk> \\<Longrightarrow> P (t # queue)\"\n  shows \"P queue\"", "lemma round_robin_step_invar_None:\n  \"\\<lbrakk> round_robin_step n0 \\<sigma> s t' = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>; round_robin_invar \\<sigma> (dom (thr s)) \\<rbrakk>\n  \\<Longrightarrow> round_robin_invar \\<sigma>' (dom (thr s))\"", "lemma round_robin_step_invar_Some:\n  \"\\<lbrakk> deterministic I; round_robin_step n0 \\<sigma> s t' = \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>; round_robin_invar \\<sigma> (dom (thr s)); s \\<in> I \\<rbrakk>\n  \\<Longrightarrow> round_robin_invar \\<sigma>' (dom (thr s) \\<union> {t. \\<exists>x m. NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\"", "lemma round_robin_reschedule_Cons:\n  \"round_robin_reschedule t0 (t0 # queue) n0 s = None\"\n  \"t \\<noteq> t0 \\<Longrightarrow> round_robin_reschedule t0 (t # queue) n0 s =\n   (case round_robin_step n0 (t # queue, n0) s t of\n      None \\<Rightarrow> round_robin_reschedule t0 (queue @ [t]) n0 s\n    | Some ttaxm\\<sigma> \\<Rightarrow> Some ttaxm\\<sigma>)\"", "lemma round_robin_reschedule_NoneD:\n  assumes rrr: \"round_robin_reschedule t0 queue n0 s = None\"\n  and t0: \"t0 \\<in> set queue\"\n  shows \"set (takeWhile (\\<lambda>t'. t' \\<noteq> t0) queue) \\<inter> active_threads s = {}\"", "lemma round_robin_reschedule_Some_NoneD:\n  assumes rrr: \"round_robin_reschedule t0 queue n0 s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\"\n  and t0: \"t0 \\<in> set queue\"\n  shows \"\\<exists>x ln n. thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and> ln $ n > 0 \\<and> \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln\"", "lemma round_robin_reschedule_Some_SomeD:\n  assumes \"deterministic I\"\n  and rrr: \"round_robin_reschedule t0 queue n0 s = \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\"\n  and t0: \"t0 \\<in> set queue\"\n  and I: \"s \\<in> I\"\n  shows \"\\<exists>x. thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and> t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and> actions_ok s t ta\"", "lemma round_robin_reschedule_invar_None:\n  assumes rrr: \"round_robin_reschedule t0 queue n0 s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\"\n  and invar: \"round_robin_invar (queue, n0) (dom (thr s))\"\n  and t0: \"t0 \\<in> set queue\"\n  shows \"round_robin_invar \\<sigma>' (dom (thr s))\"", "lemma round_robin_reschedule_invar_Some:\n  assumes \"deterministic I\"\n  and rrr: \"round_robin_reschedule t0 queue n0 s = \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\"\n  and invar: \"round_robin_invar (queue, n0) (dom (thr s))\"\n  and t0: \"t0 \\<in> set queue\"\n  and \"s \\<in> I\"\n  shows \"round_robin_invar \\<sigma>' (dom (thr s) \\<union> {t. \\<exists>x m. NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\"", "lemma round_robin_NoneD: \n  assumes rr: \"round_robin n0 \\<sigma> s = None\"\n  and invar: \"round_robin_invar \\<sigma> (dom (thr s))\"\n  shows \"active_threads s = {}\"", "lemma round_robin_Some_NoneD:\n  assumes rr: \"round_robin n0 \\<sigma> s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\"\n  shows \"\\<exists>x ln n. thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and> ln $ n > 0 \\<and> \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln\"", "lemma round_robin_Some_SomeD:\n  assumes \"deterministic I\"\n  and rr: \"round_robin n0 \\<sigma> s = \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\"\n  and \"s \\<in> I\"\n  shows \"\\<exists>x. thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and> t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and> actions_ok s t ta\"", "lemma round_robin_invar_None:\n  assumes rr: \"round_robin n0 \\<sigma> s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\"\n  and invar: \"round_robin_invar \\<sigma> (dom (thr s))\"\n  shows \"round_robin_invar \\<sigma>' (dom (thr s))\"", "lemma round_robin_invar_Some:\n  assumes \"deterministic I\"\n  and rr: \"round_robin n0 \\<sigma> s = \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\"\n  and invar: \"round_robin_invar \\<sigma> (dom (thr s))\" \"s \\<in> I\"\n  shows \"round_robin_invar \\<sigma>' (dom (thr s) \\<union> {t. \\<exists>x m. NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\"", "lemma round_robin_invar_correct:\n  \"round_robin_invar \\<sigma> T \\<Longrightarrow> Round_Robin.round_robin_invar (round_robin_\\<alpha> \\<sigma>) T\"", "lemma queue_rotate1_correct:\n  assumes \"queue_invar queue\" \"queue_\\<alpha> queue \\<noteq> []\"\n  shows \"queue_\\<alpha> (queue_rotate1 queue) = rotate1 (queue_\\<alpha> queue)\"\n  and \"queue_invar (queue_rotate1 queue)\"", "lemma enqueue_thread_correct:\n  assumes \"queue_invar queue\"\n  shows \"queue_\\<alpha> (enqueue_new_thread queue nta) = Round_Robin.enqueue_new_thread (queue_\\<alpha> queue) nta\"\n  and \"queue_invar (enqueue_new_thread queue nta)\"", "lemma enqueue_threads_correct:\n  assumes \"queue_invar queue\"\n  shows \"queue_\\<alpha> (enqueue_new_threads queue ntas) = Round_Robin.enqueue_new_threads (queue_\\<alpha> queue) ntas\"\n  and \"queue_invar (enqueue_new_threads queue ntas)\"", "lemma round_robin_update_thread_correct:\n  assumes \"round_robin_invar \\<sigma> T\" \"t' \\<in> T\"\n  shows \"round_robin_\\<alpha> (round_robin_update_state n0 \\<sigma> t ta) = Round_Robin.round_robin_update_state n0 (round_robin_\\<alpha> \\<sigma>) t ta\"", "lemma round_robin_step_correct:\n  assumes det: \"\\<alpha>.deterministic I\"\n  and invar: \"round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\" \"state_invar s\" \"state_\\<alpha> s \\<in> I\"\n  shows\n  \"map_option (apsnd (apsnd round_robin_\\<alpha>)) (round_robin_step n0 \\<sigma> s t) = \n   \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>) (state_\\<alpha> s) t\" (is ?thesis1)\n  and \"case_option True (\\<lambda>(t, taxm, \\<sigma>). round_robin_invar \\<sigma> (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s)) | Some (ta, x', m') \\<Rightarrow> dom (thr_\\<alpha> (thr s)) \\<union> {t. \\<exists>x m. NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) (round_robin_step n0 \\<sigma> s t)\"\n  (is ?thesis2)", "lemma round_robin_reschedule_correct:\n  assumes det: \"\\<alpha>.deterministic I\"\n  and invar: \"round_robin_invar (queue, n) (dom (thr_\\<alpha> (thr s)))\" \"state_invar s\" \"state_\\<alpha> s \\<in> I\"\n  and t0: \"t0 \\<in> set (queue_\\<alpha> queue)\"\n  shows \"map_option (apsnd (apsnd round_robin_\\<alpha>)) (round_robin_reschedule t0 queue n0 s) =\n     \\<alpha>.round_robin_reschedule t0 (queue_\\<alpha> queue) n0 (state_\\<alpha> s)\"\n  and \"case_option True (\\<lambda>(t, taxm, \\<sigma>). round_robin_invar \\<sigma> (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s)) | Some (ta, x', m') \\<Rightarrow> dom (thr_\\<alpha> (thr s)) \\<union> {t. \\<exists>x m. NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) (round_robin_reschedule t0 queue n0 s)\"", "lemma round_robin_correct:\n  assumes det: \"\\<alpha>.deterministic I\"\n  and invar: \"round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\" \"state_invar s\" \"state_\\<alpha> s \\<in> I\"\n  shows \"map_option (apsnd (apsnd round_robin_\\<alpha>)) (round_robin n0 \\<sigma> s) =\n         \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>) (state_\\<alpha> s)\"\n    (is ?thesis1)\n  and \"case_option True (\\<lambda>(t, taxm, \\<sigma>). round_robin_invar \\<sigma> (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s)) | Some (ta, x', m') \\<Rightarrow> dom (thr_\\<alpha> (thr s)) \\<union> {t. \\<exists>x m. NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) (round_robin n0 \\<sigma> s)\"\n    (is ?thesis2)", "lemma round_robin_scheduler_spec:\n  assumes det: \"\\<alpha>.deterministic I\"\n  shows \"scheduler_spec final r (round_robin n0) round_robin_invar thr_\\<alpha> thr_invar ws_\\<alpha> ws_invar is_\\<alpha> is_invar I\"", "lemma round_robin_start_invar:\n  \"round_robin_invar (round_robin_start n0 t0) {t0}\"", "lemma round_robin_scheduler:\n  assumes det: \"\\<alpha>.deterministic I\"\n  shows \n  \"scheduler\n     final r convert_RA\n     (round_robin n0) (pick_wakeup_via_sel (\\<lambda>s P. ws_sel s (\\<lambda>(k,v). P k v))) round_robin_invar \n     thr_\\<alpha> thr_invar thr_lookup thr_update \n     ws_\\<alpha> ws_invar ws_lookup ws_update ws_delete ws_iterate\n     is_\\<alpha> is_invar is_memb is_ins is_delete\n     I\"", "lemmas [code] =\n  round_robin_base.queue_rotate1_def\n  round_robin_base.enqueue_new_thread.simps\n  round_robin_base.enqueue_new_threads_def\n  round_robin_base.round_robin_update_state.simps\n  round_robin_base.round_robin_reschedule.simps\n  round_robin_base.round_robin.simps\n  round_robin_base.round_robin_start_def"], "translations": [["", "lemma set_enqueue_new_thread: \n  \"set (enqueue_new_thread queue nta) = set queue \\<union> {t. \\<exists>x m. nta = NewThread t x m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (enqueue_new_thread queue nta) =\n    set queue \\<union> {t. \\<exists>x m. nta = NewThread t x m}", "by(cases nta) auto"], ["", "lemma set_enqueue_new_threads: \n  \"set (enqueue_new_threads queue ntas) = set queue \\<union> {t. \\<exists>x m. NewThread t x m \\<in> set ntas}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (enqueue_new_threads queue ntas) =\n    set queue \\<union> {t. \\<exists>x m. NewThread t x m \\<in> set ntas}", "apply(induct ntas arbitrary: queue)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>queue.\n       set (enqueue_new_threads queue []) =\n       set queue \\<union> {t. \\<exists>x m. NewThread t x m \\<in> set []}\n 2. \\<And>a ntas queue.\n       (\\<And>queue.\n           set (enqueue_new_threads queue ntas) =\n           set queue \\<union>\n           {t. \\<exists>x m.\n                  NewThread t x m \\<in> set ntas}) \\<Longrightarrow>\n       set (enqueue_new_threads queue (a # ntas)) =\n       set queue \\<union>\n       {t. \\<exists>x m. NewThread t x m \\<in> set (a # ntas)}", "apply(auto simp add: enqueue_new_threads_def set_enqueue_new_thread)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma enqueue_new_thread_eq_Nil [simp]:\n  \"enqueue_new_thread queue nta = [] \\<longleftrightarrow> queue = [] \\<and> (\\<exists>t b. nta = ThreadExists t b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (enqueue_new_thread queue nta = []) =\n    (queue = [] \\<and> (\\<exists>t b. nta = ThreadExists t b))", "by(cases nta) simp_all"], ["", "lemma enqueue_new_threads_eq_Nil [simp]:\n  \"enqueue_new_threads queue ntas = [] \\<longleftrightarrow> queue = [] \\<and> set ntas \\<subseteq> {ThreadExists t b|t b. True}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (enqueue_new_threads queue ntas = []) =\n    (queue = [] \\<and> set ntas \\<subseteq> {ThreadExists t b |t b. True})", "apply(induct ntas arbitrary: queue)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>queue.\n       (enqueue_new_threads queue [] = []) =\n       (queue = [] \\<and> set [] \\<subseteq> {ThreadExists t b |t b. True})\n 2. \\<And>a ntas queue.\n       (\\<And>queue.\n           (enqueue_new_threads queue ntas = []) =\n           (queue = [] \\<and>\n            set ntas\n            \\<subseteq> {ThreadExists t b |t b. True})) \\<Longrightarrow>\n       (enqueue_new_threads queue (a # ntas) = []) =\n       (queue = [] \\<and>\n        set (a # ntas) \\<subseteq> {ThreadExists t b |t b. True})", "apply(auto simp add: enqueue_new_threads_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma distinct_enqueue_new_threads:\n  fixes ts :: \"('l,'t,'x) thread_info\"\n  and ntas :: \"('t,'x,'m) new_thread_action list\"\n  assumes \"thread_oks ts ntas\" \"set queue = dom ts\" \"distinct queue\"\n  shows \"distinct (enqueue_new_threads queue ntas)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (enqueue_new_threads queue ntas)", "using assms"], ["proof (prove)\nusing this:\n  thread_oks ts ntas\n  set queue = dom ts\n  distinct queue\n\ngoal (1 subgoal):\n 1. distinct (enqueue_new_threads queue ntas)", "proof(induct ntas arbitrary: ts queue)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ts queue.\n       \\<lbrakk>thread_oks ts []; set queue = dom ts;\n        distinct queue\\<rbrakk>\n       \\<Longrightarrow> distinct (enqueue_new_threads queue [])\n 2. \\<And>a ntas ts queue.\n       \\<lbrakk>\\<And>ts queue.\n                   \\<lbrakk>thread_oks ts ntas; set queue = dom ts;\n                    distinct queue\\<rbrakk>\n                   \\<Longrightarrow> distinct\n(enqueue_new_threads queue ntas);\n        thread_oks ts (a # ntas); set queue = dom ts;\n        distinct queue\\<rbrakk>\n       \\<Longrightarrow> distinct (enqueue_new_threads queue (a # ntas))", "case Nil"], ["proof (state)\nthis:\n  thread_oks ts []\n  set queue = dom ts\n  distinct queue\n\ngoal (2 subgoals):\n 1. \\<And>ts queue.\n       \\<lbrakk>thread_oks ts []; set queue = dom ts;\n        distinct queue\\<rbrakk>\n       \\<Longrightarrow> distinct (enqueue_new_threads queue [])\n 2. \\<And>a ntas ts queue.\n       \\<lbrakk>\\<And>ts queue.\n                   \\<lbrakk>thread_oks ts ntas; set queue = dom ts;\n                    distinct queue\\<rbrakk>\n                   \\<Longrightarrow> distinct\n(enqueue_new_threads queue ntas);\n        thread_oks ts (a # ntas); set queue = dom ts;\n        distinct queue\\<rbrakk>\n       \\<Longrightarrow> distinct (enqueue_new_threads queue (a # ntas))", "thus ?case"], ["proof (prove)\nusing this:\n  thread_oks ts []\n  set queue = dom ts\n  distinct queue\n\ngoal (1 subgoal):\n 1. distinct (enqueue_new_threads queue [])", "by(simp add: enqueue_new_threads_def)"], ["proof (state)\nthis:\n  distinct (enqueue_new_threads queue [])\n\ngoal (1 subgoal):\n 1. \\<And>a ntas ts queue.\n       \\<lbrakk>\\<And>ts queue.\n                   \\<lbrakk>thread_oks ts ntas; set queue = dom ts;\n                    distinct queue\\<rbrakk>\n                   \\<Longrightarrow> distinct\n(enqueue_new_threads queue ntas);\n        thread_oks ts (a # ntas); set queue = dom ts;\n        distinct queue\\<rbrakk>\n       \\<Longrightarrow> distinct (enqueue_new_threads queue (a # ntas))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ntas ts queue.\n       \\<lbrakk>\\<And>ts queue.\n                   \\<lbrakk>thread_oks ts ntas; set queue = dom ts;\n                    distinct queue\\<rbrakk>\n                   \\<Longrightarrow> distinct\n(enqueue_new_threads queue ntas);\n        thread_oks ts (a # ntas); set queue = dom ts;\n        distinct queue\\<rbrakk>\n       \\<Longrightarrow> distinct (enqueue_new_threads queue (a # ntas))", "case (Cons nt ntas)"], ["proof (state)\nthis:\n  \\<lbrakk>thread_oks ?ts ntas; set ?queue = dom ?ts;\n   distinct ?queue\\<rbrakk>\n  \\<Longrightarrow> distinct (enqueue_new_threads ?queue ntas)\n  thread_oks ts (nt # ntas)\n  set queue = dom ts\n  distinct queue\n\ngoal (1 subgoal):\n 1. \\<And>a ntas ts queue.\n       \\<lbrakk>\\<And>ts queue.\n                   \\<lbrakk>thread_oks ts ntas; set queue = dom ts;\n                    distinct queue\\<rbrakk>\n                   \\<Longrightarrow> distinct\n(enqueue_new_threads queue ntas);\n        thread_oks ts (a # ntas); set queue = dom ts;\n        distinct queue\\<rbrakk>\n       \\<Longrightarrow> distinct (enqueue_new_threads queue (a # ntas))", "from \\<open>thread_oks ts (nt # ntas)\\<close>"], ["proof (chain)\npicking this:\n  thread_oks ts (nt # ntas)", "have \"thread_ok ts nt\" and \"thread_oks (redT_updT ts nt) ntas\""], ["proof (prove)\nusing this:\n  thread_oks ts (nt # ntas)\n\ngoal (1 subgoal):\n 1. thread_ok ts nt &&& thread_oks (redT_updT ts nt) ntas", "by simp_all"], ["proof (state)\nthis:\n  thread_ok ts nt\n  thread_oks (redT_updT ts nt) ntas\n\ngoal (1 subgoal):\n 1. \\<And>a ntas ts queue.\n       \\<lbrakk>\\<And>ts queue.\n                   \\<lbrakk>thread_oks ts ntas; set queue = dom ts;\n                    distinct queue\\<rbrakk>\n                   \\<Longrightarrow> distinct\n(enqueue_new_threads queue ntas);\n        thread_oks ts (a # ntas); set queue = dom ts;\n        distinct queue\\<rbrakk>\n       \\<Longrightarrow> distinct (enqueue_new_threads queue (a # ntas))", "from \\<open>thread_ok ts nt\\<close> \\<open>set queue = dom ts\\<close> \\<open>distinct queue\\<close>"], ["proof (chain)\npicking this:\n  thread_ok ts nt\n  set queue = dom ts\n  distinct queue", "have \"set (enqueue_new_thread queue nt) = dom (redT_updT ts nt) \\<and> distinct (enqueue_new_thread queue nt)\""], ["proof (prove)\nusing this:\n  thread_ok ts nt\n  set queue = dom ts\n  distinct queue\n\ngoal (1 subgoal):\n 1. set (enqueue_new_thread queue nt) = dom (redT_updT ts nt) \\<and>\n    distinct (enqueue_new_thread queue nt)", "by(cases nt)(auto)"], ["proof (state)\nthis:\n  set (enqueue_new_thread queue nt) = dom (redT_updT ts nt) \\<and>\n  distinct (enqueue_new_thread queue nt)\n\ngoal (1 subgoal):\n 1. \\<And>a ntas ts queue.\n       \\<lbrakk>\\<And>ts queue.\n                   \\<lbrakk>thread_oks ts ntas; set queue = dom ts;\n                    distinct queue\\<rbrakk>\n                   \\<Longrightarrow> distinct\n(enqueue_new_threads queue ntas);\n        thread_oks ts (a # ntas); set queue = dom ts;\n        distinct queue\\<rbrakk>\n       \\<Longrightarrow> distinct (enqueue_new_threads queue (a # ntas))", "with \\<open>thread_oks (redT_updT ts nt) ntas\\<close>"], ["proof (chain)\npicking this:\n  thread_oks (redT_updT ts nt) ntas\n  set (enqueue_new_thread queue nt) = dom (redT_updT ts nt) \\<and>\n  distinct (enqueue_new_thread queue nt)", "have \"distinct (enqueue_new_threads (enqueue_new_thread queue nt) ntas)\""], ["proof (prove)\nusing this:\n  thread_oks (redT_updT ts nt) ntas\n  set (enqueue_new_thread queue nt) = dom (redT_updT ts nt) \\<and>\n  distinct (enqueue_new_thread queue nt)\n\ngoal (1 subgoal):\n 1. distinct (enqueue_new_threads (enqueue_new_thread queue nt) ntas)", "by(blast intro: Cons.hyps)"], ["proof (state)\nthis:\n  distinct (enqueue_new_threads (enqueue_new_thread queue nt) ntas)\n\ngoal (1 subgoal):\n 1. \\<And>a ntas ts queue.\n       \\<lbrakk>\\<And>ts queue.\n                   \\<lbrakk>thread_oks ts ntas; set queue = dom ts;\n                    distinct queue\\<rbrakk>\n                   \\<Longrightarrow> distinct\n(enqueue_new_threads queue ntas);\n        thread_oks ts (a # ntas); set queue = dom ts;\n        distinct queue\\<rbrakk>\n       \\<Longrightarrow> distinct (enqueue_new_threads queue (a # ntas))", "thus ?case"], ["proof (prove)\nusing this:\n  distinct (enqueue_new_threads (enqueue_new_thread queue nt) ntas)\n\ngoal (1 subgoal):\n 1. distinct (enqueue_new_threads queue (nt # ntas))", "by(simp add: enqueue_new_threads_def)"], ["proof (state)\nthis:\n  distinct (enqueue_new_threads queue (nt # ntas))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma round_robin_reschedule_induct [consumes 1, case_names head rotate]:\n  assumes major: \"t0 \\<in> set queue\"\n  and head: \"\\<And>queue. P (t0 # queue)\"\n  and rotate: \"\\<And>queue t. \\<lbrakk> t \\<noteq> t0; t0 \\<in> set queue; P (queue @ [t]) \\<rbrakk> \\<Longrightarrow> P (t # queue)\"\n  shows \"P queue\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P queue", "using major"], ["proof (prove)\nusing this:\n  t0 \\<in> set queue\n\ngoal (1 subgoal):\n 1. P queue", "proof(induct n\\<equiv>\"length (takeWhile (\\<lambda>x. x\\<noteq>t0) queue)\" arbitrary: queue)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>queue.\n       \\<lbrakk>0 = length (takeWhile (\\<lambda>x. x \\<noteq> t0) queue);\n        t0 \\<in> set queue\\<rbrakk>\n       \\<Longrightarrow> P queue\n 2. \\<And>n queue.\n       \\<lbrakk>\\<And>queue.\n                   \\<lbrakk>n =\n                            length\n                             (takeWhile (\\<lambda>x. x \\<noteq> t0) queue);\n                    t0 \\<in> set queue\\<rbrakk>\n                   \\<Longrightarrow> P queue;\n        Suc n = length (takeWhile (\\<lambda>x. x \\<noteq> t0) queue);\n        t0 \\<in> set queue\\<rbrakk>\n       \\<Longrightarrow> P queue", "case 0"], ["proof (state)\nthis:\n  0 = length (takeWhile (\\<lambda>x. x \\<noteq> t0) queue)\n  t0 \\<in> set queue\n\ngoal (2 subgoals):\n 1. \\<And>queue.\n       \\<lbrakk>0 = length (takeWhile (\\<lambda>x. x \\<noteq> t0) queue);\n        t0 \\<in> set queue\\<rbrakk>\n       \\<Longrightarrow> P queue\n 2. \\<And>n queue.\n       \\<lbrakk>\\<And>queue.\n                   \\<lbrakk>n =\n                            length\n                             (takeWhile (\\<lambda>x. x \\<noteq> t0) queue);\n                    t0 \\<in> set queue\\<rbrakk>\n                   \\<Longrightarrow> P queue;\n        Suc n = length (takeWhile (\\<lambda>x. x \\<noteq> t0) queue);\n        t0 \\<in> set queue\\<rbrakk>\n       \\<Longrightarrow> P queue", "then"], ["proof (chain)\npicking this:\n  0 = length (takeWhile (\\<lambda>x. x \\<noteq> t0) queue)\n  t0 \\<in> set queue", "obtain queue' where \"queue = t0 # queue'\""], ["proof (prove)\nusing this:\n  0 = length (takeWhile (\\<lambda>x. x \\<noteq> t0) queue)\n  t0 \\<in> set queue\n\ngoal (1 subgoal):\n 1. (\\<And>queue'.\n        queue = t0 # queue' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases queue)(auto split: if_split_asm)"], ["proof (state)\nthis:\n  queue = t0 # queue'\n\ngoal (2 subgoals):\n 1. \\<And>queue.\n       \\<lbrakk>0 = length (takeWhile (\\<lambda>x. x \\<noteq> t0) queue);\n        t0 \\<in> set queue\\<rbrakk>\n       \\<Longrightarrow> P queue\n 2. \\<And>n queue.\n       \\<lbrakk>\\<And>queue.\n                   \\<lbrakk>n =\n                            length\n                             (takeWhile (\\<lambda>x. x \\<noteq> t0) queue);\n                    t0 \\<in> set queue\\<rbrakk>\n                   \\<Longrightarrow> P queue;\n        Suc n = length (takeWhile (\\<lambda>x. x \\<noteq> t0) queue);\n        t0 \\<in> set queue\\<rbrakk>\n       \\<Longrightarrow> P queue", "thus ?case"], ["proof (prove)\nusing this:\n  queue = t0 # queue'\n\ngoal (1 subgoal):\n 1. P queue", "by(simp add: head)"], ["proof (state)\nthis:\n  P queue\n\ngoal (1 subgoal):\n 1. \\<And>n queue.\n       \\<lbrakk>\\<And>queue.\n                   \\<lbrakk>n =\n                            length\n                             (takeWhile (\\<lambda>x. x \\<noteq> t0) queue);\n                    t0 \\<in> set queue\\<rbrakk>\n                   \\<Longrightarrow> P queue;\n        Suc n = length (takeWhile (\\<lambda>x. x \\<noteq> t0) queue);\n        t0 \\<in> set queue\\<rbrakk>\n       \\<Longrightarrow> P queue", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n queue.\n       \\<lbrakk>\\<And>queue.\n                   \\<lbrakk>n =\n                            length\n                             (takeWhile (\\<lambda>x. x \\<noteq> t0) queue);\n                    t0 \\<in> set queue\\<rbrakk>\n                   \\<Longrightarrow> P queue;\n        Suc n = length (takeWhile (\\<lambda>x. x \\<noteq> t0) queue);\n        t0 \\<in> set queue\\<rbrakk>\n       \\<Longrightarrow> P queue", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>n = length (takeWhile (\\<lambda>x. x \\<noteq> t0) ?queue);\n   t0 \\<in> set ?queue\\<rbrakk>\n  \\<Longrightarrow> P ?queue\n  Suc n = length (takeWhile (\\<lambda>x. x \\<noteq> t0) queue)\n  t0 \\<in> set queue\n\ngoal (1 subgoal):\n 1. \\<And>n queue.\n       \\<lbrakk>\\<And>queue.\n                   \\<lbrakk>n =\n                            length\n                             (takeWhile (\\<lambda>x. x \\<noteq> t0) queue);\n                    t0 \\<in> set queue\\<rbrakk>\n                   \\<Longrightarrow> P queue;\n        Suc n = length (takeWhile (\\<lambda>x. x \\<noteq> t0) queue);\n        t0 \\<in> set queue\\<rbrakk>\n       \\<Longrightarrow> P queue", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>n = length (takeWhile (\\<lambda>x. x \\<noteq> t0) ?queue);\n   t0 \\<in> set ?queue\\<rbrakk>\n  \\<Longrightarrow> P ?queue\n  Suc n = length (takeWhile (\\<lambda>x. x \\<noteq> t0) queue)\n  t0 \\<in> set queue", "obtain t queue' where [simp]: \"queue = t # queue'\"\n    and t: \"t \\<noteq> t0\" and n: \"n = length (takeWhile (\\<lambda>x. x \\<noteq> t0) queue')\"\n    and t0: \"t0 \\<in> set queue'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>n = length (takeWhile (\\<lambda>x. x \\<noteq> t0) ?queue);\n   t0 \\<in> set ?queue\\<rbrakk>\n  \\<Longrightarrow> P ?queue\n  Suc n = length (takeWhile (\\<lambda>x. x \\<noteq> t0) queue)\n  t0 \\<in> set queue\n\ngoal (1 subgoal):\n 1. (\\<And>t queue'.\n        \\<lbrakk>queue = t # queue'; t \\<noteq> t0;\n         n = length (takeWhile (\\<lambda>x. x \\<noteq> t0) queue');\n         t0 \\<in> set queue'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases queue)(auto split: if_split_asm)"], ["proof (state)\nthis:\n  queue = t # queue'\n  t \\<noteq> t0\n  n = length (takeWhile (\\<lambda>x. x \\<noteq> t0) queue')\n  t0 \\<in> set queue'\n\ngoal (1 subgoal):\n 1. \\<And>n queue.\n       \\<lbrakk>\\<And>queue.\n                   \\<lbrakk>n =\n                            length\n                             (takeWhile (\\<lambda>x. x \\<noteq> t0) queue);\n                    t0 \\<in> set queue\\<rbrakk>\n                   \\<Longrightarrow> P queue;\n        Suc n = length (takeWhile (\\<lambda>x. x \\<noteq> t0) queue);\n        t0 \\<in> set queue\\<rbrakk>\n       \\<Longrightarrow> P queue", "from n t0"], ["proof (chain)\npicking this:\n  n = length (takeWhile (\\<lambda>x. x \\<noteq> t0) queue')\n  t0 \\<in> set queue'", "have \"n = length (takeWhile (\\<lambda>x. x \\<noteq> t0) (queue' @ [t]))\""], ["proof (prove)\nusing this:\n  n = length (takeWhile (\\<lambda>x. x \\<noteq> t0) queue')\n  t0 \\<in> set queue'\n\ngoal (1 subgoal):\n 1. n = length (takeWhile (\\<lambda>x. x \\<noteq> t0) (queue' @ [t]))", "by(simp)"], ["proof (state)\nthis:\n  n = length (takeWhile (\\<lambda>x. x \\<noteq> t0) (queue' @ [t]))\n\ngoal (1 subgoal):\n 1. \\<And>n queue.\n       \\<lbrakk>\\<And>queue.\n                   \\<lbrakk>n =\n                            length\n                             (takeWhile (\\<lambda>x. x \\<noteq> t0) queue);\n                    t0 \\<in> set queue\\<rbrakk>\n                   \\<Longrightarrow> P queue;\n        Suc n = length (takeWhile (\\<lambda>x. x \\<noteq> t0) queue);\n        t0 \\<in> set queue\\<rbrakk>\n       \\<Longrightarrow> P queue", "moreover"], ["proof (state)\nthis:\n  n = length (takeWhile (\\<lambda>x. x \\<noteq> t0) (queue' @ [t]))\n\ngoal (1 subgoal):\n 1. \\<And>n queue.\n       \\<lbrakk>\\<And>queue.\n                   \\<lbrakk>n =\n                            length\n                             (takeWhile (\\<lambda>x. x \\<noteq> t0) queue);\n                    t0 \\<in> set queue\\<rbrakk>\n                   \\<Longrightarrow> P queue;\n        Suc n = length (takeWhile (\\<lambda>x. x \\<noteq> t0) queue);\n        t0 \\<in> set queue\\<rbrakk>\n       \\<Longrightarrow> P queue", "from t0"], ["proof (chain)\npicking this:\n  t0 \\<in> set queue'", "have \"t0 \\<in> set (queue' @ [t])\""], ["proof (prove)\nusing this:\n  t0 \\<in> set queue'\n\ngoal (1 subgoal):\n 1. t0 \\<in> set (queue' @ [t])", "by simp"], ["proof (state)\nthis:\n  t0 \\<in> set (queue' @ [t])\n\ngoal (1 subgoal):\n 1. \\<And>n queue.\n       \\<lbrakk>\\<And>queue.\n                   \\<lbrakk>n =\n                            length\n                             (takeWhile (\\<lambda>x. x \\<noteq> t0) queue);\n                    t0 \\<in> set queue\\<rbrakk>\n                   \\<Longrightarrow> P queue;\n        Suc n = length (takeWhile (\\<lambda>x. x \\<noteq> t0) queue);\n        t0 \\<in> set queue\\<rbrakk>\n       \\<Longrightarrow> P queue", "ultimately"], ["proof (chain)\npicking this:\n  n = length (takeWhile (\\<lambda>x. x \\<noteq> t0) (queue' @ [t]))\n  t0 \\<in> set (queue' @ [t])", "have \"P (queue' @ [t])\""], ["proof (prove)\nusing this:\n  n = length (takeWhile (\\<lambda>x. x \\<noteq> t0) (queue' @ [t]))\n  t0 \\<in> set (queue' @ [t])\n\ngoal (1 subgoal):\n 1. P (queue' @ [t])", "by(rule Suc.hyps)"], ["proof (state)\nthis:\n  P (queue' @ [t])\n\ngoal (1 subgoal):\n 1. \\<And>n queue.\n       \\<lbrakk>\\<And>queue.\n                   \\<lbrakk>n =\n                            length\n                             (takeWhile (\\<lambda>x. x \\<noteq> t0) queue);\n                    t0 \\<in> set queue\\<rbrakk>\n                   \\<Longrightarrow> P queue;\n        Suc n = length (takeWhile (\\<lambda>x. x \\<noteq> t0) queue);\n        t0 \\<in> set queue\\<rbrakk>\n       \\<Longrightarrow> P queue", "with t t0"], ["proof (chain)\npicking this:\n  t \\<noteq> t0\n  t0 \\<in> set queue'\n  P (queue' @ [t])", "show ?case"], ["proof (prove)\nusing this:\n  t \\<noteq> t0\n  t0 \\<in> set queue'\n  P (queue' @ [t])\n\ngoal (1 subgoal):\n 1. P queue", "by(simp add: rotate)"], ["proof (state)\nthis:\n  P queue\n\ngoal:\nNo subgoals!", "qed"], ["", "context multithreaded_base begin"], ["", "declare actions_ok_iff [simp del]"], ["", "declare actions_ok.cases [rule del]"], ["", "lemma round_robin_step_invar_None:\n  \"\\<lbrakk> round_robin_step n0 \\<sigma> s t' = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>; round_robin_invar \\<sigma> (dom (thr s)) \\<rbrakk>\n  \\<Longrightarrow> round_robin_invar \\<sigma>' (dom (thr s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>round_robin_step n0 \\<sigma> s t' =\n             \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n     round_robin_invar \\<sigma> (dom (thr s))\\<rbrakk>\n    \\<Longrightarrow> round_robin_invar \\<sigma>' (dom (thr s))", "by(cases \\<sigma>)(auto dest: step_thread_Some_NoneD simp add: set_enqueue_new_threads distinct_enqueue_new_threads)"], ["", "lemma round_robin_step_invar_Some:\n  \"\\<lbrakk> deterministic I; round_robin_step n0 \\<sigma> s t' = \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>; round_robin_invar \\<sigma> (dom (thr s)); s \\<in> I \\<rbrakk>\n  \\<Longrightarrow> round_robin_invar \\<sigma>' (dom (thr s) \\<union> {t. \\<exists>x m. NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>deterministic I;\n     round_robin_step n0 \\<sigma> s t' =\n     \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>;\n     round_robin_invar \\<sigma> (dom (thr s)); s \\<in> I\\<rbrakk>\n    \\<Longrightarrow> round_robin_invar \\<sigma>'\n                       (dom (thr s) \\<union>\n                        {t. \\<exists>x m.\n                               NewThread t x m\n                               \\<in> set\n\\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "apply(cases \\<sigma>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>deterministic I;\n        round_robin_step n0 \\<sigma> s t' =\n        \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>;\n        round_robin_invar \\<sigma> (dom (thr s)); s \\<in> I;\n        \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> round_robin_invar \\<sigma>'\n                          (dom (thr s) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>deterministic I;\n        round_robin_step n0 (a, b) s t' =\n        \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>;\n        s \\<in> I; \\<sigma> = (a, b); set a = dom (thr s);\n        distinct a\\<rbrakk>\n       \\<Longrightarrow> round_robin_invar \\<sigma>'\n                          (dom (thr s) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "apply(frule (1) step_thread_Some_SomeD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>deterministic I;\n        round_robin_step n0 (a, b) s t' =\n        \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>;\n        s \\<in> I; \\<sigma> = (a, b); set a = dom (thr s);\n        distinct a\\<rbrakk>\n       \\<Longrightarrow> s \\<in> I\n 2. \\<And>a b.\n       \\<lbrakk>deterministic I;\n        round_robin_step n0 (a, b) s t' =\n        \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>;\n        s \\<in> I; \\<sigma> = (a, b); set a = dom (thr s); distinct a;\n        \\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr\n s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n           actions_ok s t ta \\<and>\n           \\<sigma>' = round_robin_update_state n0 (a, b) t' ta\\<rbrakk>\n       \\<Longrightarrow> round_robin_invar \\<sigma>'\n                          (dom (thr s) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "apply(auto split: if_split_asm simp add: split_beta set_enqueue_new_threads deterministic_THE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a x.\n       \\<lbrakk>deterministic I;\n        round_robin_step n0 (a, 0) s t' =\n        \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                  rotate1\n                   (enqueue_new_threads a\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>),\n                  n0)\\<rfloor>;\n        s \\<in> I; \\<sigma> = (a, 0); set a = dom (thr s); distinct a;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        actions_ok s t ta;\n        \\<sigma>' =\n        (rotate1\n          (enqueue_new_threads a \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>),\n         n0)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (enqueue_new_threads a\n                            \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)\n 2. \\<And>a b x.\n       \\<lbrakk>deterministic I;\n        round_robin_step n0 (a, b) s t' =\n        \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                  rotate1\n                   (enqueue_new_threads a\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>),\n                  n0)\\<rfloor>;\n        s \\<in> I; \\<sigma> = (a, b); set a = dom (thr s); distinct a;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        actions_ok s t ta;\n        \\<sigma>' =\n        (rotate1\n          (enqueue_new_threads a \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>),\n         n0);\n        Yield \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (enqueue_new_threads a\n                            \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)\n 3. \\<And>a b x.\n       \\<lbrakk>deterministic I;\n        round_robin_step n0 (a, b) s t' =\n        \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                  enqueue_new_threads a\n                   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>,\n                  b - Suc 0)\\<rfloor>;\n        s \\<in> I; \\<sigma> = (a, b); set a = dom (thr s); distinct a;\n        0 < b; Yield \\<notin> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        actions_ok s t ta;\n        \\<sigma>' =\n        (enqueue_new_threads a \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>,\n         b - Suc 0)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (enqueue_new_threads a\n                            \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)", "apply(auto simp add: actions_ok_iff distinct_enqueue_new_threads)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma round_robin_reschedule_Cons:\n  \"round_robin_reschedule t0 (t0 # queue) n0 s = None\"\n  \"t \\<noteq> t0 \\<Longrightarrow> round_robin_reschedule t0 (t # queue) n0 s =\n   (case round_robin_step n0 (t # queue, n0) s t of\n      None \\<Rightarrow> round_robin_reschedule t0 (queue @ [t]) n0 s\n    | Some ttaxm\\<sigma> \\<Rightarrow> Some ttaxm\\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. round_robin_reschedule t0 (t0 # queue) n0 s = None &&&\n    (t \\<noteq> t0 \\<Longrightarrow>\n     round_robin_reschedule t0 (t # queue) n0 s =\n     (case round_robin_step n0 (t # queue, n0) s t of\n      None \\<Rightarrow> round_robin_reschedule t0 (queue @ [t]) n0 s\n      | \\<lfloor>ttaxm\\<sigma>\\<rfloor> \\<Rightarrow>\n          \\<lfloor>ttaxm\\<sigma>\\<rfloor>))", "by(simp_all add: round_robin_reschedule.simps)"], ["", "lemma round_robin_reschedule_NoneD:\n  assumes rrr: \"round_robin_reschedule t0 queue n0 s = None\"\n  and t0: \"t0 \\<in> set queue\"\n  shows \"set (takeWhile (\\<lambda>t'. t' \\<noteq> t0) queue) \\<inter> active_threads s = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (takeWhile (\\<lambda>t'. t' \\<noteq> t0) queue) \\<inter>\n    active_threads s =\n    {}", "using t0 rrr"], ["proof (prove)\nusing this:\n  t0 \\<in> set queue\n  round_robin_reschedule t0 queue n0 s = None\n\ngoal (1 subgoal):\n 1. set (takeWhile (\\<lambda>t'. t' \\<noteq> t0) queue) \\<inter>\n    active_threads s =\n    {}", "proof(induct queue rule: round_robin_reschedule_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>queue.\n       round_robin_reschedule t0 (t0 # queue) n0 s = None \\<Longrightarrow>\n       set (takeWhile (\\<lambda>t'. t' \\<noteq> t0) (t0 # queue)) \\<inter>\n       active_threads s =\n       {}\n 2. \\<And>queue t.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        round_robin_reschedule t0 (queue @ [t]) n0 s =\n        None \\<Longrightarrow>\n        set (takeWhile (\\<lambda>t'. t' \\<noteq> t0) (queue @ [t])) \\<inter>\n        active_threads s =\n        {};\n        round_robin_reschedule t0 (t # queue) n0 s = None\\<rbrakk>\n       \\<Longrightarrow> set (takeWhile (\\<lambda>t'. t' \\<noteq> t0)\n                               (t # queue)) \\<inter>\n                         active_threads s =\n                         {}", "case (head queue)"], ["proof (state)\nthis:\n  round_robin_reschedule t0 (t0 # queue) n0 s = None\n\ngoal (2 subgoals):\n 1. \\<And>queue.\n       round_robin_reschedule t0 (t0 # queue) n0 s = None \\<Longrightarrow>\n       set (takeWhile (\\<lambda>t'. t' \\<noteq> t0) (t0 # queue)) \\<inter>\n       active_threads s =\n       {}\n 2. \\<And>queue t.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        round_robin_reschedule t0 (queue @ [t]) n0 s =\n        None \\<Longrightarrow>\n        set (takeWhile (\\<lambda>t'. t' \\<noteq> t0) (queue @ [t])) \\<inter>\n        active_threads s =\n        {};\n        round_robin_reschedule t0 (t # queue) n0 s = None\\<rbrakk>\n       \\<Longrightarrow> set (takeWhile (\\<lambda>t'. t' \\<noteq> t0)\n                               (t # queue)) \\<inter>\n                         active_threads s =\n                         {}", "thus ?case"], ["proof (prove)\nusing this:\n  round_robin_reschedule t0 (t0 # queue) n0 s = None\n\ngoal (1 subgoal):\n 1. set (takeWhile (\\<lambda>t'. t' \\<noteq> t0) (t0 # queue)) \\<inter>\n    active_threads s =\n    {}", "by simp"], ["proof (state)\nthis:\n  set (takeWhile (\\<lambda>t'. t' \\<noteq> t0) (t0 # queue)) \\<inter>\n  active_threads s =\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>queue t.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        round_robin_reschedule t0 (queue @ [t]) n0 s =\n        None \\<Longrightarrow>\n        set (takeWhile (\\<lambda>t'. t' \\<noteq> t0) (queue @ [t])) \\<inter>\n        active_threads s =\n        {};\n        round_robin_reschedule t0 (t # queue) n0 s = None\\<rbrakk>\n       \\<Longrightarrow> set (takeWhile (\\<lambda>t'. t' \\<noteq> t0)\n                               (t # queue)) \\<inter>\n                         active_threads s =\n                         {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>queue t.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        round_robin_reschedule t0 (queue @ [t]) n0 s =\n        None \\<Longrightarrow>\n        set (takeWhile (\\<lambda>t'. t' \\<noteq> t0) (queue @ [t])) \\<inter>\n        active_threads s =\n        {};\n        round_robin_reschedule t0 (t # queue) n0 s = None\\<rbrakk>\n       \\<Longrightarrow> set (takeWhile (\\<lambda>t'. t' \\<noteq> t0)\n                               (t # queue)) \\<inter>\n                         active_threads s =\n                         {}", "case (rotate queue t)"], ["proof (state)\nthis:\n  t \\<noteq> t0\n  t0 \\<in> set queue\n  round_robin_reschedule t0 (queue @ [t]) n0 s = None \\<Longrightarrow>\n  set (takeWhile (\\<lambda>t'. t' \\<noteq> t0) (queue @ [t])) \\<inter>\n  active_threads s =\n  {}\n  round_robin_reschedule t0 (t # queue) n0 s = None\n\ngoal (1 subgoal):\n 1. \\<And>queue t.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        round_robin_reschedule t0 (queue @ [t]) n0 s =\n        None \\<Longrightarrow>\n        set (takeWhile (\\<lambda>t'. t' \\<noteq> t0) (queue @ [t])) \\<inter>\n        active_threads s =\n        {};\n        round_robin_reschedule t0 (t # queue) n0 s = None\\<rbrakk>\n       \\<Longrightarrow> set (takeWhile (\\<lambda>t'. t' \\<noteq> t0)\n                               (t # queue)) \\<inter>\n                         active_threads s =\n                         {}", "from \\<open>round_robin_reschedule t0 (t # queue) n0 s = None\\<close> \\<open>t \\<noteq> t0\\<close>"], ["proof (chain)\npicking this:\n  round_robin_reschedule t0 (t # queue) n0 s = None\n  t \\<noteq> t0", "have \"round_robin_step n0 (t # queue, n0) s t = None\" \n    and \"round_robin_reschedule t0 (queue @ [t]) n0 s = None\""], ["proof (prove)\nusing this:\n  round_robin_reschedule t0 (t # queue) n0 s = None\n  t \\<noteq> t0\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (t # queue, n0) s t = None &&&\n    round_robin_reschedule t0 (queue @ [t]) n0 s = None", "by(simp_all add: round_robin_reschedule_Cons)"], ["proof (state)\nthis:\n  round_robin_step n0 (t # queue, n0) s t = None\n  round_robin_reschedule t0 (queue @ [t]) n0 s = None\n\ngoal (1 subgoal):\n 1. \\<And>queue t.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        round_robin_reschedule t0 (queue @ [t]) n0 s =\n        None \\<Longrightarrow>\n        set (takeWhile (\\<lambda>t'. t' \\<noteq> t0) (queue @ [t])) \\<inter>\n        active_threads s =\n        {};\n        round_robin_reschedule t0 (t # queue) n0 s = None\\<rbrakk>\n       \\<Longrightarrow> set (takeWhile (\\<lambda>t'. t' \\<noteq> t0)\n                               (t # queue)) \\<inter>\n                         active_threads s =\n                         {}", "from this(1)"], ["proof (chain)\npicking this:\n  round_robin_step n0 (t # queue, n0) s t = None", "have \"t \\<notin> active_threads s\""], ["proof (prove)\nusing this:\n  round_robin_step n0 (t # queue, n0) s t = None\n\ngoal (1 subgoal):\n 1. t \\<notin> active_threads s", "by(rule step_thread_NoneD)"], ["proof (state)\nthis:\n  t \\<notin> active_threads s\n\ngoal (1 subgoal):\n 1. \\<And>queue t.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        round_robin_reschedule t0 (queue @ [t]) n0 s =\n        None \\<Longrightarrow>\n        set (takeWhile (\\<lambda>t'. t' \\<noteq> t0) (queue @ [t])) \\<inter>\n        active_threads s =\n        {};\n        round_robin_reschedule t0 (t # queue) n0 s = None\\<rbrakk>\n       \\<Longrightarrow> set (takeWhile (\\<lambda>t'. t' \\<noteq> t0)\n                               (t # queue)) \\<inter>\n                         active_threads s =\n                         {}", "moreover"], ["proof (state)\nthis:\n  t \\<notin> active_threads s\n\ngoal (1 subgoal):\n 1. \\<And>queue t.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        round_robin_reschedule t0 (queue @ [t]) n0 s =\n        None \\<Longrightarrow>\n        set (takeWhile (\\<lambda>t'. t' \\<noteq> t0) (queue @ [t])) \\<inter>\n        active_threads s =\n        {};\n        round_robin_reschedule t0 (t # queue) n0 s = None\\<rbrakk>\n       \\<Longrightarrow> set (takeWhile (\\<lambda>t'. t' \\<noteq> t0)\n                               (t # queue)) \\<inter>\n                         active_threads s =\n                         {}", "from \\<open>round_robin_reschedule t0 (queue @ [t]) n0 s = None\\<close>"], ["proof (chain)\npicking this:\n  round_robin_reschedule t0 (queue @ [t]) n0 s = None", "have \"set (takeWhile (\\<lambda>t'. t' \\<noteq> t0) (queue @ [t])) \\<inter> active_threads s = {}\""], ["proof (prove)\nusing this:\n  round_robin_reschedule t0 (queue @ [t]) n0 s = None\n\ngoal (1 subgoal):\n 1. set (takeWhile (\\<lambda>t'. t' \\<noteq> t0) (queue @ [t])) \\<inter>\n    active_threads s =\n    {}", "by(rule rotate.hyps)"], ["proof (state)\nthis:\n  set (takeWhile (\\<lambda>t'. t' \\<noteq> t0) (queue @ [t])) \\<inter>\n  active_threads s =\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>queue t.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        round_robin_reschedule t0 (queue @ [t]) n0 s =\n        None \\<Longrightarrow>\n        set (takeWhile (\\<lambda>t'. t' \\<noteq> t0) (queue @ [t])) \\<inter>\n        active_threads s =\n        {};\n        round_robin_reschedule t0 (t # queue) n0 s = None\\<rbrakk>\n       \\<Longrightarrow> set (takeWhile (\\<lambda>t'. t' \\<noteq> t0)\n                               (t # queue)) \\<inter>\n                         active_threads s =\n                         {}", "moreover"], ["proof (state)\nthis:\n  set (takeWhile (\\<lambda>t'. t' \\<noteq> t0) (queue @ [t])) \\<inter>\n  active_threads s =\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>queue t.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        round_robin_reschedule t0 (queue @ [t]) n0 s =\n        None \\<Longrightarrow>\n        set (takeWhile (\\<lambda>t'. t' \\<noteq> t0) (queue @ [t])) \\<inter>\n        active_threads s =\n        {};\n        round_robin_reschedule t0 (t # queue) n0 s = None\\<rbrakk>\n       \\<Longrightarrow> set (takeWhile (\\<lambda>t'. t' \\<noteq> t0)\n                               (t # queue)) \\<inter>\n                         active_threads s =\n                         {}", "have \"takeWhile (\\<lambda>t'. t' \\<noteq> t0) (queue @ [t]) = takeWhile (\\<lambda>t'. t' \\<noteq> t0) queue\""], ["proof (prove)\ngoal (1 subgoal):\n 1. takeWhile (\\<lambda>t'. t' \\<noteq> t0) (queue @ [t]) =\n    takeWhile (\\<lambda>t'. t' \\<noteq> t0) queue", "using \\<open>t0 \\<in> set queue\\<close>"], ["proof (prove)\nusing this:\n  t0 \\<in> set queue\n\ngoal (1 subgoal):\n 1. takeWhile (\\<lambda>t'. t' \\<noteq> t0) (queue @ [t]) =\n    takeWhile (\\<lambda>t'. t' \\<noteq> t0) queue", "by simp"], ["proof (state)\nthis:\n  takeWhile (\\<lambda>t'. t' \\<noteq> t0) (queue @ [t]) =\n  takeWhile (\\<lambda>t'. t' \\<noteq> t0) queue\n\ngoal (1 subgoal):\n 1. \\<And>queue t.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        round_robin_reschedule t0 (queue @ [t]) n0 s =\n        None \\<Longrightarrow>\n        set (takeWhile (\\<lambda>t'. t' \\<noteq> t0) (queue @ [t])) \\<inter>\n        active_threads s =\n        {};\n        round_robin_reschedule t0 (t # queue) n0 s = None\\<rbrakk>\n       \\<Longrightarrow> set (takeWhile (\\<lambda>t'. t' \\<noteq> t0)\n                               (t # queue)) \\<inter>\n                         active_threads s =\n                         {}", "ultimately"], ["proof (chain)\npicking this:\n  t \\<notin> active_threads s\n  set (takeWhile (\\<lambda>t'. t' \\<noteq> t0) (queue @ [t])) \\<inter>\n  active_threads s =\n  {}\n  takeWhile (\\<lambda>t'. t' \\<noteq> t0) (queue @ [t]) =\n  takeWhile (\\<lambda>t'. t' \\<noteq> t0) queue", "show ?case"], ["proof (prove)\nusing this:\n  t \\<notin> active_threads s\n  set (takeWhile (\\<lambda>t'. t' \\<noteq> t0) (queue @ [t])) \\<inter>\n  active_threads s =\n  {}\n  takeWhile (\\<lambda>t'. t' \\<noteq> t0) (queue @ [t]) =\n  takeWhile (\\<lambda>t'. t' \\<noteq> t0) queue\n\ngoal (1 subgoal):\n 1. set (takeWhile (\\<lambda>t'. t' \\<noteq> t0) (t # queue)) \\<inter>\n    active_threads s =\n    {}", "using \\<open>t \\<noteq> t0\\<close>"], ["proof (prove)\nusing this:\n  t \\<notin> active_threads s\n  set (takeWhile (\\<lambda>t'. t' \\<noteq> t0) (queue @ [t])) \\<inter>\n  active_threads s =\n  {}\n  takeWhile (\\<lambda>t'. t' \\<noteq> t0) (queue @ [t]) =\n  takeWhile (\\<lambda>t'. t' \\<noteq> t0) queue\n  t \\<noteq> t0\n\ngoal (1 subgoal):\n 1. set (takeWhile (\\<lambda>t'. t' \\<noteq> t0) (t # queue)) \\<inter>\n    active_threads s =\n    {}", "by simp"], ["proof (state)\nthis:\n  set (takeWhile (\\<lambda>t'. t' \\<noteq> t0) (t # queue)) \\<inter>\n  active_threads s =\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma round_robin_reschedule_Some_NoneD:\n  assumes rrr: \"round_robin_reschedule t0 queue n0 s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\"\n  and t0: \"t0 \\<in> set queue\"\n  shows \"\\<exists>x ln n. thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and> ln $ n > 0 \\<and> \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x ln n.\n       thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       0 < ln $ n \\<and>\n       \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln", "using t0 rrr"], ["proof (prove)\nusing this:\n  t0 \\<in> set queue\n  round_robin_reschedule t0 queue n0 s =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>x ln n.\n       thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       0 < ln $ n \\<and>\n       \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln", "proof(induct queue rule: round_robin_reschedule_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>queue.\n       round_robin_reschedule t0 (t0 # queue) n0 s =\n       \\<lfloor>(t, None, \\<sigma>')\\<rfloor> \\<Longrightarrow>\n       \\<exists>x ln n.\n          thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n          0 < ln $ n \\<and>\n          \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln\n 2. \\<And>queue ta.\n       \\<lbrakk>ta \\<noteq> t0; t0 \\<in> set queue;\n        round_robin_reschedule t0 (queue @ [ta]) n0 s =\n        \\<lfloor>(t, None, \\<sigma>')\\<rfloor> \\<Longrightarrow>\n        \\<exists>x ln n.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           0 < ln $ n \\<and>\n           \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln;\n        round_robin_reschedule t0 (ta # queue) n0 s =\n        \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x ln n.\n                            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                            0 < ln $ n \\<and>\n                            \\<not> waiting (wset s t) \\<and>\n                            may_acquire_all (locks s) t ln", "case head"], ["proof (state)\nthis:\n  round_robin_reschedule t0 (t0 # queue_) n0 s =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>queue.\n       round_robin_reschedule t0 (t0 # queue) n0 s =\n       \\<lfloor>(t, None, \\<sigma>')\\<rfloor> \\<Longrightarrow>\n       \\<exists>x ln n.\n          thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n          0 < ln $ n \\<and>\n          \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln\n 2. \\<And>queue ta.\n       \\<lbrakk>ta \\<noteq> t0; t0 \\<in> set queue;\n        round_robin_reschedule t0 (queue @ [ta]) n0 s =\n        \\<lfloor>(t, None, \\<sigma>')\\<rfloor> \\<Longrightarrow>\n        \\<exists>x ln n.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           0 < ln $ n \\<and>\n           \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln;\n        round_robin_reschedule t0 (ta # queue) n0 s =\n        \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x ln n.\n                            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                            0 < ln $ n \\<and>\n                            \\<not> waiting (wset s t) \\<and>\n                            may_acquire_all (locks s) t ln", "thus ?case"], ["proof (prove)\nusing this:\n  round_robin_reschedule t0 (t0 # queue_) n0 s =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>x ln n.\n       thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       0 < ln $ n \\<and>\n       \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln", "by(simp add: round_robin_reschedule_Cons)"], ["proof (state)\nthis:\n  \\<exists>x ln n.\n     thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n     0 < ln $ n \\<and>\n     \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln\n\ngoal (1 subgoal):\n 1. \\<And>queue ta.\n       \\<lbrakk>ta \\<noteq> t0; t0 \\<in> set queue;\n        round_robin_reschedule t0 (queue @ [ta]) n0 s =\n        \\<lfloor>(t, None, \\<sigma>')\\<rfloor> \\<Longrightarrow>\n        \\<exists>x ln n.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           0 < ln $ n \\<and>\n           \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln;\n        round_robin_reschedule t0 (ta # queue) n0 s =\n        \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x ln n.\n                            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                            0 < ln $ n \\<and>\n                            \\<not> waiting (wset s t) \\<and>\n                            may_acquire_all (locks s) t ln", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>queue ta.\n       \\<lbrakk>ta \\<noteq> t0; t0 \\<in> set queue;\n        round_robin_reschedule t0 (queue @ [ta]) n0 s =\n        \\<lfloor>(t, None, \\<sigma>')\\<rfloor> \\<Longrightarrow>\n        \\<exists>x ln n.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           0 < ln $ n \\<and>\n           \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln;\n        round_robin_reschedule t0 (ta # queue) n0 s =\n        \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x ln n.\n                            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                            0 < ln $ n \\<and>\n                            \\<not> waiting (wset s t) \\<and>\n                            may_acquire_all (locks s) t ln", "case (rotate queue t')"], ["proof (state)\nthis:\n  t' \\<noteq> t0\n  t0 \\<in> set queue\n  round_robin_reschedule t0 (queue @ [t']) n0 s =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor> \\<Longrightarrow>\n  \\<exists>x ln n.\n     thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n     0 < ln $ n \\<and>\n     \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln\n  round_robin_reschedule t0 (t' # queue) n0 s =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>queue ta.\n       \\<lbrakk>ta \\<noteq> t0; t0 \\<in> set queue;\n        round_robin_reschedule t0 (queue @ [ta]) n0 s =\n        \\<lfloor>(t, None, \\<sigma>')\\<rfloor> \\<Longrightarrow>\n        \\<exists>x ln n.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           0 < ln $ n \\<and>\n           \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln;\n        round_robin_reschedule t0 (ta # queue) n0 s =\n        \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x ln n.\n                            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                            0 < ln $ n \\<and>\n                            \\<not> waiting (wset s t) \\<and>\n                            may_acquire_all (locks s) t ln", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x ln n.\n       thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       0 < ln $ n \\<and>\n       \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln", "proof(cases \"round_robin_step n0 (t' # queue, n0) s t'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. round_robin_step n0 (t' # queue, n0) s t' = None \\<Longrightarrow>\n    \\<exists>x ln n.\n       thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       0 < ln $ n \\<and>\n       \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln\n 2. \\<And>a.\n       round_robin_step n0 (t' # queue, n0) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>x ln n.\n          thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n          0 < ln $ n \\<and>\n          \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln", "case None"], ["proof (state)\nthis:\n  round_robin_step n0 (t' # queue, n0) s t' = None\n\ngoal (2 subgoals):\n 1. round_robin_step n0 (t' # queue, n0) s t' = None \\<Longrightarrow>\n    \\<exists>x ln n.\n       thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       0 < ln $ n \\<and>\n       \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln\n 2. \\<And>a.\n       round_robin_step n0 (t' # queue, n0) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>x ln n.\n          thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n          0 < ln $ n \\<and>\n          \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln", "with \\<open>round_robin_reschedule t0 (t' # queue) n0 s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\\<close> \\<open>t' \\<noteq> t0\\<close>"], ["proof (chain)\npicking this:\n  round_robin_reschedule t0 (t' # queue) n0 s =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  t' \\<noteq> t0\n  round_robin_step n0 (t' # queue, n0) s t' = None", "have \"round_robin_reschedule t0 (queue @ [t']) n0 s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\""], ["proof (prove)\nusing this:\n  round_robin_reschedule t0 (t' # queue) n0 s =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  t' \\<noteq> t0\n  round_robin_step n0 (t' # queue, n0) s t' = None\n\ngoal (1 subgoal):\n 1. round_robin_reschedule t0 (queue @ [t']) n0 s =\n    \\<lfloor>(t, None, \\<sigma>')\\<rfloor>", "by(simp add: round_robin_reschedule_Cons)"], ["proof (state)\nthis:\n  round_robin_reschedule t0 (queue @ [t']) n0 s =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n\ngoal (2 subgoals):\n 1. round_robin_step n0 (t' # queue, n0) s t' = None \\<Longrightarrow>\n    \\<exists>x ln n.\n       thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       0 < ln $ n \\<and>\n       \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln\n 2. \\<And>a.\n       round_robin_step n0 (t' # queue, n0) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>x ln n.\n          thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n          0 < ln $ n \\<and>\n          \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln", "thus ?thesis"], ["proof (prove)\nusing this:\n  round_robin_reschedule t0 (queue @ [t']) n0 s =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>x ln n.\n       thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       0 < ln $ n \\<and>\n       \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln", "by(rule rotate.hyps)"], ["proof (state)\nthis:\n  \\<exists>x ln n.\n     thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n     0 < ln $ n \\<and>\n     \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       round_robin_step n0 (t' # queue, n0) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>x ln n.\n          thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n          0 < ln $ n \\<and>\n          \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       round_robin_step n0 (t' # queue, n0) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>x ln n.\n          thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n          0 < ln $ n \\<and>\n          \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln", "case (Some a)"], ["proof (state)\nthis:\n  round_robin_step n0 (t' # queue, n0) s t' = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       round_robin_step n0 (t' # queue, n0) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>x ln n.\n          thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n          0 < ln $ n \\<and>\n          \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln", "with \\<open>round_robin_reschedule t0 (t' # queue) n0 s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\\<close> \\<open>t' \\<noteq> t0\\<close>"], ["proof (chain)\npicking this:\n  round_robin_reschedule t0 (t' # queue) n0 s =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  t' \\<noteq> t0\n  round_robin_step n0 (t' # queue, n0) s t' = \\<lfloor>a\\<rfloor>", "have \"round_robin_step n0 (t' # queue, n0) s t' = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\""], ["proof (prove)\nusing this:\n  round_robin_reschedule t0 (t' # queue) n0 s =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  t' \\<noteq> t0\n  round_robin_step n0 (t' # queue, n0) s t' = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (t' # queue, n0) s t' =\n    \\<lfloor>(t, None, \\<sigma>')\\<rfloor>", "by(simp add: round_robin_reschedule_Cons)"], ["proof (state)\nthis:\n  round_robin_step n0 (t' # queue, n0) s t' =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       round_robin_step n0 (t' # queue, n0) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>x ln n.\n          thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n          0 < ln $ n \\<and>\n          \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln", "thus ?thesis"], ["proof (prove)\nusing this:\n  round_robin_step n0 (t' # queue, n0) s t' =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>x ln n.\n       thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       0 < ln $ n \\<and>\n       \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln", "by(blast dest: step_thread_Some_NoneD)"], ["proof (state)\nthis:\n  \\<exists>x ln n.\n     thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n     0 < ln $ n \\<and>\n     \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x ln n.\n     thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n     0 < ln $ n \\<and>\n     \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma round_robin_reschedule_Some_SomeD:\n  assumes \"deterministic I\"\n  and rrr: \"round_robin_reschedule t0 queue n0 s = \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\"\n  and t0: \"t0 \\<in> set queue\"\n  and I: \"s \\<in> I\"\n  shows \"\\<exists>x. thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and> t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and> actions_ok s t ta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n       actions_ok s t ta", "using t0 rrr"], ["proof (prove)\nusing this:\n  t0 \\<in> set queue\n  round_robin_reschedule t0 queue n0 s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n       actions_ok s t ta", "proof(induct queue rule: round_robin_reschedule_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>queue.\n       round_robin_reschedule t0 (t0 # queue) n0 s =\n       \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                 \\<sigma>')\\<rfloor> \\<Longrightarrow>\n       \\<exists>x.\n          thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n          t \\<turnstile> \\<langle>x, shr\ns\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n          actions_ok s t ta\n 2. \\<And>queue tb.\n       \\<lbrakk>tb \\<noteq> t0; t0 \\<in> set queue;\n        round_robin_reschedule t0 (queue @ [tb]) n0 s =\n        \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                  \\<sigma>')\\<rfloor> \\<Longrightarrow>\n        \\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr\n s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n           actions_ok s t ta;\n        round_robin_reschedule t0 (tb # queue) n0 s =\n        \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                  \\<sigma>')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            thr s t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            t \\<turnstile> \\<langle>x, shr\n                  s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n                            actions_ok s t ta", "case head"], ["proof (state)\nthis:\n  round_robin_reschedule t0 (t0 # queue_) n0 s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>queue.\n       round_robin_reschedule t0 (t0 # queue) n0 s =\n       \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                 \\<sigma>')\\<rfloor> \\<Longrightarrow>\n       \\<exists>x.\n          thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n          t \\<turnstile> \\<langle>x, shr\ns\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n          actions_ok s t ta\n 2. \\<And>queue tb.\n       \\<lbrakk>tb \\<noteq> t0; t0 \\<in> set queue;\n        round_robin_reschedule t0 (queue @ [tb]) n0 s =\n        \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                  \\<sigma>')\\<rfloor> \\<Longrightarrow>\n        \\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr\n s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n           actions_ok s t ta;\n        round_robin_reschedule t0 (tb # queue) n0 s =\n        \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                  \\<sigma>')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            thr s t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            t \\<turnstile> \\<langle>x, shr\n                  s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n                            actions_ok s t ta", "thus ?case"], ["proof (prove)\nusing this:\n  round_robin_reschedule t0 (t0 # queue_) n0 s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n       actions_ok s t ta", "by(simp add: round_robin_reschedule_Cons)"], ["proof (state)\nthis:\n  \\<exists>x.\n     thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n     t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n     actions_ok s t ta\n\ngoal (1 subgoal):\n 1. \\<And>queue tb.\n       \\<lbrakk>tb \\<noteq> t0; t0 \\<in> set queue;\n        round_robin_reschedule t0 (queue @ [tb]) n0 s =\n        \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                  \\<sigma>')\\<rfloor> \\<Longrightarrow>\n        \\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr\n s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n           actions_ok s t ta;\n        round_robin_reschedule t0 (tb # queue) n0 s =\n        \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                  \\<sigma>')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            thr s t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            t \\<turnstile> \\<langle>x, shr\n                  s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n                            actions_ok s t ta", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>queue tb.\n       \\<lbrakk>tb \\<noteq> t0; t0 \\<in> set queue;\n        round_robin_reschedule t0 (queue @ [tb]) n0 s =\n        \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                  \\<sigma>')\\<rfloor> \\<Longrightarrow>\n        \\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr\n s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n           actions_ok s t ta;\n        round_robin_reschedule t0 (tb # queue) n0 s =\n        \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                  \\<sigma>')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            thr s t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            t \\<turnstile> \\<langle>x, shr\n                  s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n                            actions_ok s t ta", "case (rotate queue t')"], ["proof (state)\nthis:\n  t' \\<noteq> t0\n  t0 \\<in> set queue\n  round_robin_reschedule t0 (queue @ [t']) n0 s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n            \\<sigma>')\\<rfloor> \\<Longrightarrow>\n  \\<exists>x.\n     thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n     t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n     actions_ok s t ta\n  round_robin_reschedule t0 (t' # queue) n0 s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>queue tb.\n       \\<lbrakk>tb \\<noteq> t0; t0 \\<in> set queue;\n        round_robin_reschedule t0 (queue @ [tb]) n0 s =\n        \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                  \\<sigma>')\\<rfloor> \\<Longrightarrow>\n        \\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr\n s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n           actions_ok s t ta;\n        round_robin_reschedule t0 (tb # queue) n0 s =\n        \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                  \\<sigma>')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            thr s t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            t \\<turnstile> \\<langle>x, shr\n                  s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n                            actions_ok s t ta", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n       actions_ok s t ta", "proof(cases \"round_robin_step n0 (t' # queue, n0) s t'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. round_robin_step n0 (t' # queue, n0) s t' = None \\<Longrightarrow>\n    \\<exists>x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n       actions_ok s t ta\n 2. \\<And>a.\n       round_robin_step n0 (t' # queue, n0) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>x.\n          thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n          t \\<turnstile> \\<langle>x, shr\ns\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n          actions_ok s t ta", "case None"], ["proof (state)\nthis:\n  round_robin_step n0 (t' # queue, n0) s t' = None\n\ngoal (2 subgoals):\n 1. round_robin_step n0 (t' # queue, n0) s t' = None \\<Longrightarrow>\n    \\<exists>x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n       actions_ok s t ta\n 2. \\<And>a.\n       round_robin_step n0 (t' # queue, n0) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>x.\n          thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n          t \\<turnstile> \\<langle>x, shr\ns\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n          actions_ok s t ta", "with \\<open>round_robin_reschedule t0 (t' # queue) n0 s = \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\\<close> \\<open>t' \\<noteq> t0\\<close>"], ["proof (chain)\npicking this:\n  round_robin_reschedule t0 (t' # queue) n0 s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  t' \\<noteq> t0\n  round_robin_step n0 (t' # queue, n0) s t' = None", "have \"round_robin_reschedule t0 (queue @ [t']) n0 s = \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\""], ["proof (prove)\nusing this:\n  round_robin_reschedule t0 (t' # queue) n0 s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  t' \\<noteq> t0\n  round_robin_step n0 (t' # queue, n0) s t' = None\n\ngoal (1 subgoal):\n 1. round_robin_reschedule t0 (queue @ [t']) n0 s =\n    \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>", "by(simp add: round_robin_reschedule_Cons)"], ["proof (state)\nthis:\n  round_robin_reschedule t0 (queue @ [t']) n0 s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n\ngoal (2 subgoals):\n 1. round_robin_step n0 (t' # queue, n0) s t' = None \\<Longrightarrow>\n    \\<exists>x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n       actions_ok s t ta\n 2. \\<And>a.\n       round_robin_step n0 (t' # queue, n0) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>x.\n          thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n          t \\<turnstile> \\<langle>x, shr\ns\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n          actions_ok s t ta", "thus ?thesis"], ["proof (prove)\nusing this:\n  round_robin_reschedule t0 (queue @ [t']) n0 s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n       actions_ok s t ta", "by(rule rotate.hyps)"], ["proof (state)\nthis:\n  \\<exists>x.\n     thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n     t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n     actions_ok s t ta\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       round_robin_step n0 (t' # queue, n0) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>x.\n          thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n          t \\<turnstile> \\<langle>x, shr\ns\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n          actions_ok s t ta", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       round_robin_step n0 (t' # queue, n0) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>x.\n          thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n          t \\<turnstile> \\<langle>x, shr\ns\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n          actions_ok s t ta", "case (Some a)"], ["proof (state)\nthis:\n  round_robin_step n0 (t' # queue, n0) s t' = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       round_robin_step n0 (t' # queue, n0) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>x.\n          thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n          t \\<turnstile> \\<langle>x, shr\ns\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n          actions_ok s t ta", "with \\<open>round_robin_reschedule t0 (t' # queue) n0 s = \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\\<close> \\<open>t' \\<noteq> t0\\<close>"], ["proof (chain)\npicking this:\n  round_robin_reschedule t0 (t' # queue) n0 s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  t' \\<noteq> t0\n  round_robin_step n0 (t' # queue, n0) s t' = \\<lfloor>a\\<rfloor>", "have \"round_robin_step n0 (t' # queue, n0) s t' = \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\""], ["proof (prove)\nusing this:\n  round_robin_reschedule t0 (t' # queue) n0 s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  t' \\<noteq> t0\n  round_robin_step n0 (t' # queue, n0) s t' = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (t' # queue, n0) s t' =\n    \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>", "by(simp add: round_robin_reschedule_Cons)"], ["proof (state)\nthis:\n  round_robin_step n0 (t' # queue, n0) s t' =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       round_robin_step n0 (t' # queue, n0) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>x.\n          thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n          t \\<turnstile> \\<langle>x, shr\ns\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n          actions_ok s t ta", "thus ?thesis"], ["proof (prove)\nusing this:\n  round_robin_step n0 (t' # queue, n0) s t' =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n       actions_ok s t ta", "using I"], ["proof (prove)\nusing this:\n  round_robin_step n0 (t' # queue, n0) s t' =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  s \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n       actions_ok s t ta", "by(blast dest: step_thread_Some_SomeD[OF \\<open>deterministic I\\<close>])"], ["proof (state)\nthis:\n  \\<exists>x.\n     thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n     t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n     actions_ok s t ta\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x.\n     thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n     t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n     actions_ok s t ta\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma round_robin_reschedule_invar_None:\n  assumes rrr: \"round_robin_reschedule t0 queue n0 s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\"\n  and invar: \"round_robin_invar (queue, n0) (dom (thr s))\"\n  and t0: \"t0 \\<in> set queue\"\n  shows \"round_robin_invar \\<sigma>' (dom (thr s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>' (dom (thr s))", "using t0 rrr invar"], ["proof (prove)\nusing this:\n  t0 \\<in> set queue\n  round_robin_reschedule t0 queue n0 s =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  round_robin_invar (queue, n0) (dom (thr s))\n\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>' (dom (thr s))", "proof(induct queue rule: round_robin_reschedule_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>queue.\n       \\<lbrakk>round_robin_reschedule t0 (t0 # queue) n0 s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        round_robin_invar (t0 # queue, n0) (dom (thr s))\\<rbrakk>\n       \\<Longrightarrow> round_robin_invar \\<sigma>' (dom (thr s))\n 2. \\<And>queue ta.\n       \\<lbrakk>ta \\<noteq> t0; t0 \\<in> set queue;\n        \\<lbrakk>round_robin_reschedule t0 (queue @ [ta]) n0 s =\n                 \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n         round_robin_invar (queue @ [ta], n0) (dom (thr s))\\<rbrakk>\n        \\<Longrightarrow> round_robin_invar \\<sigma>' (dom (thr s));\n        round_robin_reschedule t0 (ta # queue) n0 s =\n        \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        round_robin_invar (ta # queue, n0) (dom (thr s))\\<rbrakk>\n       \\<Longrightarrow> round_robin_invar \\<sigma>' (dom (thr s))", "case head"], ["proof (state)\nthis:\n  round_robin_reschedule t0 (t0 # queue_) n0 s =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  round_robin_invar (t0 # queue_, n0) (dom (thr s))\n\ngoal (2 subgoals):\n 1. \\<And>queue.\n       \\<lbrakk>round_robin_reschedule t0 (t0 # queue) n0 s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        round_robin_invar (t0 # queue, n0) (dom (thr s))\\<rbrakk>\n       \\<Longrightarrow> round_robin_invar \\<sigma>' (dom (thr s))\n 2. \\<And>queue ta.\n       \\<lbrakk>ta \\<noteq> t0; t0 \\<in> set queue;\n        \\<lbrakk>round_robin_reschedule t0 (queue @ [ta]) n0 s =\n                 \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n         round_robin_invar (queue @ [ta], n0) (dom (thr s))\\<rbrakk>\n        \\<Longrightarrow> round_robin_invar \\<sigma>' (dom (thr s));\n        round_robin_reschedule t0 (ta # queue) n0 s =\n        \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        round_robin_invar (ta # queue, n0) (dom (thr s))\\<rbrakk>\n       \\<Longrightarrow> round_robin_invar \\<sigma>' (dom (thr s))", "thus ?case"], ["proof (prove)\nusing this:\n  round_robin_reschedule t0 (t0 # queue_) n0 s =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  round_robin_invar (t0 # queue_, n0) (dom (thr s))\n\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>' (dom (thr s))", "by(simp add: round_robin_reschedule_Cons)"], ["proof (state)\nthis:\n  round_robin_invar \\<sigma>' (dom (thr s))\n\ngoal (1 subgoal):\n 1. \\<And>queue ta.\n       \\<lbrakk>ta \\<noteq> t0; t0 \\<in> set queue;\n        \\<lbrakk>round_robin_reschedule t0 (queue @ [ta]) n0 s =\n                 \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n         round_robin_invar (queue @ [ta], n0) (dom (thr s))\\<rbrakk>\n        \\<Longrightarrow> round_robin_invar \\<sigma>' (dom (thr s));\n        round_robin_reschedule t0 (ta # queue) n0 s =\n        \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        round_robin_invar (ta # queue, n0) (dom (thr s))\\<rbrakk>\n       \\<Longrightarrow> round_robin_invar \\<sigma>' (dom (thr s))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>queue ta.\n       \\<lbrakk>ta \\<noteq> t0; t0 \\<in> set queue;\n        \\<lbrakk>round_robin_reschedule t0 (queue @ [ta]) n0 s =\n                 \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n         round_robin_invar (queue @ [ta], n0) (dom (thr s))\\<rbrakk>\n        \\<Longrightarrow> round_robin_invar \\<sigma>' (dom (thr s));\n        round_robin_reschedule t0 (ta # queue) n0 s =\n        \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        round_robin_invar (ta # queue, n0) (dom (thr s))\\<rbrakk>\n       \\<Longrightarrow> round_robin_invar \\<sigma>' (dom (thr s))", "case (rotate queue t')"], ["proof (state)\nthis:\n  t' \\<noteq> t0\n  t0 \\<in> set queue\n  \\<lbrakk>round_robin_reschedule t0 (queue @ [t']) n0 s =\n           \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n   round_robin_invar (queue @ [t'], n0) (dom (thr s))\\<rbrakk>\n  \\<Longrightarrow> round_robin_invar \\<sigma>' (dom (thr s))\n  round_robin_reschedule t0 (t' # queue) n0 s =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  round_robin_invar (t' # queue, n0) (dom (thr s))\n\ngoal (1 subgoal):\n 1. \\<And>queue ta.\n       \\<lbrakk>ta \\<noteq> t0; t0 \\<in> set queue;\n        \\<lbrakk>round_robin_reschedule t0 (queue @ [ta]) n0 s =\n                 \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n         round_robin_invar (queue @ [ta], n0) (dom (thr s))\\<rbrakk>\n        \\<Longrightarrow> round_robin_invar \\<sigma>' (dom (thr s));\n        round_robin_reschedule t0 (ta # queue) n0 s =\n        \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        round_robin_invar (ta # queue, n0) (dom (thr s))\\<rbrakk>\n       \\<Longrightarrow> round_robin_invar \\<sigma>' (dom (thr s))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>' (dom (thr s))", "proof(cases \"round_robin_step n0 (t' # queue, n0) s t'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. round_robin_step n0 (t' # queue, n0) s t' = None \\<Longrightarrow>\n    round_robin_invar \\<sigma>' (dom (thr s))\n 2. \\<And>a.\n       round_robin_step n0 (t' # queue, n0) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       round_robin_invar \\<sigma>' (dom (thr s))", "case None"], ["proof (state)\nthis:\n  round_robin_step n0 (t' # queue, n0) s t' = None\n\ngoal (2 subgoals):\n 1. round_robin_step n0 (t' # queue, n0) s t' = None \\<Longrightarrow>\n    round_robin_invar \\<sigma>' (dom (thr s))\n 2. \\<And>a.\n       round_robin_step n0 (t' # queue, n0) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       round_robin_invar \\<sigma>' (dom (thr s))", "with \\<open>round_robin_reschedule t0 (t' # queue) n0 s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\\<close> \\<open>t' \\<noteq> t0\\<close>"], ["proof (chain)\npicking this:\n  round_robin_reschedule t0 (t' # queue) n0 s =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  t' \\<noteq> t0\n  round_robin_step n0 (t' # queue, n0) s t' = None", "have \"round_robin_reschedule t0 (queue @ [t']) n0 s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\""], ["proof (prove)\nusing this:\n  round_robin_reschedule t0 (t' # queue) n0 s =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  t' \\<noteq> t0\n  round_robin_step n0 (t' # queue, n0) s t' = None\n\ngoal (1 subgoal):\n 1. round_robin_reschedule t0 (queue @ [t']) n0 s =\n    \\<lfloor>(t, None, \\<sigma>')\\<rfloor>", "by(simp add: round_robin_reschedule_Cons)"], ["proof (state)\nthis:\n  round_robin_reschedule t0 (queue @ [t']) n0 s =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n\ngoal (2 subgoals):\n 1. round_robin_step n0 (t' # queue, n0) s t' = None \\<Longrightarrow>\n    round_robin_invar \\<sigma>' (dom (thr s))\n 2. \\<And>a.\n       round_robin_step n0 (t' # queue, n0) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       round_robin_invar \\<sigma>' (dom (thr s))", "moreover"], ["proof (state)\nthis:\n  round_robin_reschedule t0 (queue @ [t']) n0 s =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n\ngoal (2 subgoals):\n 1. round_robin_step n0 (t' # queue, n0) s t' = None \\<Longrightarrow>\n    round_robin_invar \\<sigma>' (dom (thr s))\n 2. \\<And>a.\n       round_robin_step n0 (t' # queue, n0) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       round_robin_invar \\<sigma>' (dom (thr s))", "from \\<open>round_robin_invar (t' # queue, n0) (dom (thr s))\\<close>"], ["proof (chain)\npicking this:\n  round_robin_invar (t' # queue, n0) (dom (thr s))", "have \"round_robin_invar (queue @ [t'], n0) (dom (thr s))\""], ["proof (prove)\nusing this:\n  round_robin_invar (t' # queue, n0) (dom (thr s))\n\ngoal (1 subgoal):\n 1. round_robin_invar (queue @ [t'], n0) (dom (thr s))", "by simp"], ["proof (state)\nthis:\n  round_robin_invar (queue @ [t'], n0) (dom (thr s))\n\ngoal (2 subgoals):\n 1. round_robin_step n0 (t' # queue, n0) s t' = None \\<Longrightarrow>\n    round_robin_invar \\<sigma>' (dom (thr s))\n 2. \\<And>a.\n       round_robin_step n0 (t' # queue, n0) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       round_robin_invar \\<sigma>' (dom (thr s))", "ultimately"], ["proof (chain)\npicking this:\n  round_robin_reschedule t0 (queue @ [t']) n0 s =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  round_robin_invar (queue @ [t'], n0) (dom (thr s))", "show ?thesis"], ["proof (prove)\nusing this:\n  round_robin_reschedule t0 (queue @ [t']) n0 s =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  round_robin_invar (queue @ [t'], n0) (dom (thr s))\n\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>' (dom (thr s))", "by(rule rotate.hyps)"], ["proof (state)\nthis:\n  round_robin_invar \\<sigma>' (dom (thr s))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       round_robin_step n0 (t' # queue, n0) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       round_robin_invar \\<sigma>' (dom (thr s))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       round_robin_step n0 (t' # queue, n0) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       round_robin_invar \\<sigma>' (dom (thr s))", "case (Some a)"], ["proof (state)\nthis:\n  round_robin_step n0 (t' # queue, n0) s t' = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       round_robin_step n0 (t' # queue, n0) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       round_robin_invar \\<sigma>' (dom (thr s))", "with \\<open>round_robin_reschedule t0 (t' # queue) n0 s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\\<close> \\<open>t' \\<noteq> t0\\<close>"], ["proof (chain)\npicking this:\n  round_robin_reschedule t0 (t' # queue) n0 s =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  t' \\<noteq> t0\n  round_robin_step n0 (t' # queue, n0) s t' = \\<lfloor>a\\<rfloor>", "have \"round_robin_step n0 (t' # queue, n0) s t' = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\""], ["proof (prove)\nusing this:\n  round_robin_reschedule t0 (t' # queue) n0 s =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  t' \\<noteq> t0\n  round_robin_step n0 (t' # queue, n0) s t' = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (t' # queue, n0) s t' =\n    \\<lfloor>(t, None, \\<sigma>')\\<rfloor>", "by(simp add: round_robin_reschedule_Cons)"], ["proof (state)\nthis:\n  round_robin_step n0 (t' # queue, n0) s t' =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       round_robin_step n0 (t' # queue, n0) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       round_robin_invar \\<sigma>' (dom (thr s))", "thus ?thesis"], ["proof (prove)\nusing this:\n  round_robin_step n0 (t' # queue, n0) s t' =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>' (dom (thr s))", "using \\<open>round_robin_invar (t' # queue, n0) (dom (thr s))\\<close>"], ["proof (prove)\nusing this:\n  round_robin_step n0 (t' # queue, n0) s t' =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  round_robin_invar (t' # queue, n0) (dom (thr s))\n\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>' (dom (thr s))", "by(rule round_robin_step_invar_None)"], ["proof (state)\nthis:\n  round_robin_invar \\<sigma>' (dom (thr s))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  round_robin_invar \\<sigma>' (dom (thr s))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma round_robin_reschedule_invar_Some:\n  assumes \"deterministic I\"\n  and rrr: \"round_robin_reschedule t0 queue n0 s = \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\"\n  and invar: \"round_robin_invar (queue, n0) (dom (thr s))\"\n  and t0: \"t0 \\<in> set queue\"\n  and \"s \\<in> I\"\n  shows \"round_robin_invar \\<sigma>' (dom (thr s) \\<union> {t. \\<exists>x m. NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>'\n     (dom (thr s) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "using t0 rrr invar"], ["proof (prove)\nusing this:\n  t0 \\<in> set queue\n  round_robin_reschedule t0 queue n0 s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  round_robin_invar (queue, n0) (dom (thr s))\n\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>'\n     (dom (thr s) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "proof(induct queue rule: round_robin_reschedule_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>queue.\n       \\<lbrakk>round_robin_reschedule t0 (t0 # queue) n0 s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        round_robin_invar (t0 # queue, n0) (dom (thr s))\\<rbrakk>\n       \\<Longrightarrow> round_robin_invar \\<sigma>'\n                          (dom (thr s) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n 2. \\<And>queue tb.\n       \\<lbrakk>tb \\<noteq> t0; t0 \\<in> set queue;\n        \\<lbrakk>round_robin_reschedule t0 (queue @ [tb]) n0 s =\n                 \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                           \\<sigma>')\\<rfloor>;\n         round_robin_invar (queue @ [tb], n0) (dom (thr s))\\<rbrakk>\n        \\<Longrightarrow> round_robin_invar \\<sigma>'\n                           (dom (thr s) \\<union>\n                            {t. \\<exists>x m.\n                                   NewThread t x m\n                                   \\<in> set\n    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        round_robin_reschedule t0 (tb # queue) n0 s =\n        \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>;\n        round_robin_invar (tb # queue, n0) (dom (thr s))\\<rbrakk>\n       \\<Longrightarrow> round_robin_invar \\<sigma>'\n                          (dom (thr s) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "case head"], ["proof (state)\nthis:\n  round_robin_reschedule t0 (t0 # queue_) n0 s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  round_robin_invar (t0 # queue_, n0) (dom (thr s))\n\ngoal (2 subgoals):\n 1. \\<And>queue.\n       \\<lbrakk>round_robin_reschedule t0 (t0 # queue) n0 s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        round_robin_invar (t0 # queue, n0) (dom (thr s))\\<rbrakk>\n       \\<Longrightarrow> round_robin_invar \\<sigma>'\n                          (dom (thr s) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n 2. \\<And>queue tb.\n       \\<lbrakk>tb \\<noteq> t0; t0 \\<in> set queue;\n        \\<lbrakk>round_robin_reschedule t0 (queue @ [tb]) n0 s =\n                 \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                           \\<sigma>')\\<rfloor>;\n         round_robin_invar (queue @ [tb], n0) (dom (thr s))\\<rbrakk>\n        \\<Longrightarrow> round_robin_invar \\<sigma>'\n                           (dom (thr s) \\<union>\n                            {t. \\<exists>x m.\n                                   NewThread t x m\n                                   \\<in> set\n    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        round_robin_reschedule t0 (tb # queue) n0 s =\n        \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>;\n        round_robin_invar (tb # queue, n0) (dom (thr s))\\<rbrakk>\n       \\<Longrightarrow> round_robin_invar \\<sigma>'\n                          (dom (thr s) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "thus ?case"], ["proof (prove)\nusing this:\n  round_robin_reschedule t0 (t0 # queue_) n0 s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  round_robin_invar (t0 # queue_, n0) (dom (thr s))\n\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>'\n     (dom (thr s) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "by(simp add: round_robin_reschedule_Cons)"], ["proof (state)\nthis:\n  round_robin_invar \\<sigma>'\n   (dom (thr s) \\<union>\n    {t. \\<exists>x m.\n           NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal (1 subgoal):\n 1. \\<And>queue tb.\n       \\<lbrakk>tb \\<noteq> t0; t0 \\<in> set queue;\n        \\<lbrakk>round_robin_reschedule t0 (queue @ [tb]) n0 s =\n                 \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                           \\<sigma>')\\<rfloor>;\n         round_robin_invar (queue @ [tb], n0) (dom (thr s))\\<rbrakk>\n        \\<Longrightarrow> round_robin_invar \\<sigma>'\n                           (dom (thr s) \\<union>\n                            {t. \\<exists>x m.\n                                   NewThread t x m\n                                   \\<in> set\n    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        round_robin_reschedule t0 (tb # queue) n0 s =\n        \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>;\n        round_robin_invar (tb # queue, n0) (dom (thr s))\\<rbrakk>\n       \\<Longrightarrow> round_robin_invar \\<sigma>'\n                          (dom (thr s) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>queue tb.\n       \\<lbrakk>tb \\<noteq> t0; t0 \\<in> set queue;\n        \\<lbrakk>round_robin_reschedule t0 (queue @ [tb]) n0 s =\n                 \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                           \\<sigma>')\\<rfloor>;\n         round_robin_invar (queue @ [tb], n0) (dom (thr s))\\<rbrakk>\n        \\<Longrightarrow> round_robin_invar \\<sigma>'\n                           (dom (thr s) \\<union>\n                            {t. \\<exists>x m.\n                                   NewThread t x m\n                                   \\<in> set\n    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        round_robin_reschedule t0 (tb # queue) n0 s =\n        \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>;\n        round_robin_invar (tb # queue, n0) (dom (thr s))\\<rbrakk>\n       \\<Longrightarrow> round_robin_invar \\<sigma>'\n                          (dom (thr s) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "case (rotate queue t')"], ["proof (state)\nthis:\n  t' \\<noteq> t0\n  t0 \\<in> set queue\n  \\<lbrakk>round_robin_reschedule t0 (queue @ [t']) n0 s =\n           \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>;\n   round_robin_invar (queue @ [t'], n0) (dom (thr s))\\<rbrakk>\n  \\<Longrightarrow> round_robin_invar \\<sigma>'\n                     (dom (thr s) \\<union>\n                      {t. \\<exists>x m.\n                             NewThread t x m\n                             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n  round_robin_reschedule t0 (t' # queue) n0 s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  round_robin_invar (t' # queue, n0) (dom (thr s))\n\ngoal (1 subgoal):\n 1. \\<And>queue tb.\n       \\<lbrakk>tb \\<noteq> t0; t0 \\<in> set queue;\n        \\<lbrakk>round_robin_reschedule t0 (queue @ [tb]) n0 s =\n                 \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                           \\<sigma>')\\<rfloor>;\n         round_robin_invar (queue @ [tb], n0) (dom (thr s))\\<rbrakk>\n        \\<Longrightarrow> round_robin_invar \\<sigma>'\n                           (dom (thr s) \\<union>\n                            {t. \\<exists>x m.\n                                   NewThread t x m\n                                   \\<in> set\n    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        round_robin_reschedule t0 (tb # queue) n0 s =\n        \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>;\n        round_robin_invar (tb # queue, n0) (dom (thr s))\\<rbrakk>\n       \\<Longrightarrow> round_robin_invar \\<sigma>'\n                          (dom (thr s) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>'\n     (dom (thr s) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "proof(cases \"round_robin_step n0 (t' # queue, n0) s t'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. round_robin_step n0 (t' # queue, n0) s t' = None \\<Longrightarrow>\n    round_robin_invar \\<sigma>'\n     (dom (thr s) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n 2. \\<And>a.\n       round_robin_step n0 (t' # queue, n0) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       round_robin_invar \\<sigma>'\n        (dom (thr s) \\<union>\n         {t. \\<exists>x m.\n                NewThread t x m\n                \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "case None"], ["proof (state)\nthis:\n  round_robin_step n0 (t' # queue, n0) s t' = None\n\ngoal (2 subgoals):\n 1. round_robin_step n0 (t' # queue, n0) s t' = None \\<Longrightarrow>\n    round_robin_invar \\<sigma>'\n     (dom (thr s) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n 2. \\<And>a.\n       round_robin_step n0 (t' # queue, n0) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       round_robin_invar \\<sigma>'\n        (dom (thr s) \\<union>\n         {t. \\<exists>x m.\n                NewThread t x m\n                \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "with \\<open>round_robin_reschedule t0 (t' # queue) n0 s = \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\\<close> \\<open>t' \\<noteq> t0\\<close>"], ["proof (chain)\npicking this:\n  round_robin_reschedule t0 (t' # queue) n0 s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  t' \\<noteq> t0\n  round_robin_step n0 (t' # queue, n0) s t' = None", "have \"round_robin_reschedule t0 (queue @ [t']) n0 s = \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\""], ["proof (prove)\nusing this:\n  round_robin_reschedule t0 (t' # queue) n0 s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  t' \\<noteq> t0\n  round_robin_step n0 (t' # queue, n0) s t' = None\n\ngoal (1 subgoal):\n 1. round_robin_reschedule t0 (queue @ [t']) n0 s =\n    \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>", "by(simp add: round_robin_reschedule_Cons)"], ["proof (state)\nthis:\n  round_robin_reschedule t0 (queue @ [t']) n0 s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n\ngoal (2 subgoals):\n 1. round_robin_step n0 (t' # queue, n0) s t' = None \\<Longrightarrow>\n    round_robin_invar \\<sigma>'\n     (dom (thr s) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n 2. \\<And>a.\n       round_robin_step n0 (t' # queue, n0) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       round_robin_invar \\<sigma>'\n        (dom (thr s) \\<union>\n         {t. \\<exists>x m.\n                NewThread t x m\n                \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "moreover"], ["proof (state)\nthis:\n  round_robin_reschedule t0 (queue @ [t']) n0 s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n\ngoal (2 subgoals):\n 1. round_robin_step n0 (t' # queue, n0) s t' = None \\<Longrightarrow>\n    round_robin_invar \\<sigma>'\n     (dom (thr s) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n 2. \\<And>a.\n       round_robin_step n0 (t' # queue, n0) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       round_robin_invar \\<sigma>'\n        (dom (thr s) \\<union>\n         {t. \\<exists>x m.\n                NewThread t x m\n                \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "from \\<open>round_robin_invar (t' # queue, n0) (dom (thr s))\\<close>"], ["proof (chain)\npicking this:\n  round_robin_invar (t' # queue, n0) (dom (thr s))", "have \"round_robin_invar (queue @ [t'], n0) (dom (thr s))\""], ["proof (prove)\nusing this:\n  round_robin_invar (t' # queue, n0) (dom (thr s))\n\ngoal (1 subgoal):\n 1. round_robin_invar (queue @ [t'], n0) (dom (thr s))", "by simp"], ["proof (state)\nthis:\n  round_robin_invar (queue @ [t'], n0) (dom (thr s))\n\ngoal (2 subgoals):\n 1. round_robin_step n0 (t' # queue, n0) s t' = None \\<Longrightarrow>\n    round_robin_invar \\<sigma>'\n     (dom (thr s) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n 2. \\<And>a.\n       round_robin_step n0 (t' # queue, n0) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       round_robin_invar \\<sigma>'\n        (dom (thr s) \\<union>\n         {t. \\<exists>x m.\n                NewThread t x m\n                \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "ultimately"], ["proof (chain)\npicking this:\n  round_robin_reschedule t0 (queue @ [t']) n0 s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  round_robin_invar (queue @ [t'], n0) (dom (thr s))", "show ?thesis"], ["proof (prove)\nusing this:\n  round_robin_reschedule t0 (queue @ [t']) n0 s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  round_robin_invar (queue @ [t'], n0) (dom (thr s))\n\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>'\n     (dom (thr s) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "by(rule rotate.hyps)"], ["proof (state)\nthis:\n  round_robin_invar \\<sigma>'\n   (dom (thr s) \\<union>\n    {t. \\<exists>x m.\n           NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       round_robin_step n0 (t' # queue, n0) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       round_robin_invar \\<sigma>'\n        (dom (thr s) \\<union>\n         {t. \\<exists>x m.\n                NewThread t x m\n                \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       round_robin_step n0 (t' # queue, n0) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       round_robin_invar \\<sigma>'\n        (dom (thr s) \\<union>\n         {t. \\<exists>x m.\n                NewThread t x m\n                \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "case (Some a)"], ["proof (state)\nthis:\n  round_robin_step n0 (t' # queue, n0) s t' = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       round_robin_step n0 (t' # queue, n0) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       round_robin_invar \\<sigma>'\n        (dom (thr s) \\<union>\n         {t. \\<exists>x m.\n                NewThread t x m\n                \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "with \\<open>round_robin_reschedule t0 (t' # queue) n0 s = \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\\<close> \\<open>t' \\<noteq> t0\\<close>"], ["proof (chain)\npicking this:\n  round_robin_reschedule t0 (t' # queue) n0 s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  t' \\<noteq> t0\n  round_robin_step n0 (t' # queue, n0) s t' = \\<lfloor>a\\<rfloor>", "have \"round_robin_step n0 (t' # queue, n0) s t' = \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\""], ["proof (prove)\nusing this:\n  round_robin_reschedule t0 (t' # queue) n0 s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  t' \\<noteq> t0\n  round_robin_step n0 (t' # queue, n0) s t' = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (t' # queue, n0) s t' =\n    \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>", "by(simp add: round_robin_reschedule_Cons)"], ["proof (state)\nthis:\n  round_robin_step n0 (t' # queue, n0) s t' =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       round_robin_step n0 (t' # queue, n0) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       round_robin_invar \\<sigma>'\n        (dom (thr s) \\<union>\n         {t. \\<exists>x m.\n                NewThread t x m\n                \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "thus ?thesis"], ["proof (prove)\nusing this:\n  round_robin_step n0 (t' # queue, n0) s t' =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>'\n     (dom (thr s) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "using \\<open>round_robin_invar (t' # queue, n0) (dom (thr s))\\<close> \\<open>s \\<in> I\\<close>"], ["proof (prove)\nusing this:\n  round_robin_step n0 (t' # queue, n0) s t' =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  round_robin_invar (t' # queue, n0) (dom (thr s))\n  s \\<in> I\n\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>'\n     (dom (thr s) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "by(rule round_robin_step_invar_Some[OF \\<open>deterministic I\\<close>])"], ["proof (state)\nthis:\n  round_robin_invar \\<sigma>'\n   (dom (thr s) \\<union>\n    {t. \\<exists>x m.\n           NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  round_robin_invar \\<sigma>'\n   (dom (thr s) \\<union>\n    {t. \\<exists>x m.\n           NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma round_robin_NoneD: \n  assumes rr: \"round_robin n0 \\<sigma> s = None\"\n  and invar: \"round_robin_invar \\<sigma> (dom (thr s))\"\n  shows \"active_threads s = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. active_threads s = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. active_threads s = {}", "obtain queue n where \\<sigma>: \"\\<sigma> = (queue, n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>queue n.\n        \\<sigma> = (queue, n) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \\<sigma>)"], ["proof (state)\nthis:\n  \\<sigma> = (queue, n)\n\ngoal (1 subgoal):\n 1. active_threads s = {}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. active_threads s = {}", "proof(cases queue)"], ["proof (state)\ngoal (2 subgoals):\n 1. queue = [] \\<Longrightarrow> active_threads s = {}\n 2. \\<And>a list. queue = a # list \\<Longrightarrow> active_threads s = {}", "case Nil"], ["proof (state)\nthis:\n  queue = []\n\ngoal (2 subgoals):\n 1. queue = [] \\<Longrightarrow> active_threads s = {}\n 2. \\<And>a list. queue = a # list \\<Longrightarrow> active_threads s = {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  queue = []\n\ngoal (1 subgoal):\n 1. active_threads s = {}", "using invar \\<sigma>"], ["proof (prove)\nusing this:\n  queue = []\n  round_robin_invar \\<sigma> (dom (thr s))\n  \\<sigma> = (queue, n)\n\ngoal (1 subgoal):\n 1. active_threads s = {}", "by(fastforce elim: active_threads.cases)"], ["proof (state)\nthis:\n  active_threads s = {}\n\ngoal (1 subgoal):\n 1. \\<And>a list. queue = a # list \\<Longrightarrow> active_threads s = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. queue = a # list \\<Longrightarrow> active_threads s = {}", "case (Cons t queue')"], ["proof (state)\nthis:\n  queue = t # queue'\n\ngoal (1 subgoal):\n 1. \\<And>a list. queue = a # list \\<Longrightarrow> active_threads s = {}", "with rr \\<sigma>"], ["proof (chain)\npicking this:\n  round_robin n0 \\<sigma> s = None\n  \\<sigma> = (queue, n)\n  queue = t # queue'", "have \"round_robin_step n0 (t # queue', n) s t = None\"\n      and \"round_robin_reschedule t (queue' @ [t]) n0 s = None\""], ["proof (prove)\nusing this:\n  round_robin n0 \\<sigma> s = None\n  \\<sigma> = (queue, n)\n  queue = t # queue'\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (t # queue', n) s t = None &&&\n    round_robin_reschedule t (queue' @ [t]) n0 s = None", "by simp_all"], ["proof (state)\nthis:\n  round_robin_step n0 (t # queue', n) s t = None\n  round_robin_reschedule t (queue' @ [t]) n0 s = None\n\ngoal (1 subgoal):\n 1. \\<And>a list. queue = a # list \\<Longrightarrow> active_threads s = {}", "from \\<open>round_robin_step n0 (t # queue', n) s t = None\\<close>"], ["proof (chain)\npicking this:\n  round_robin_step n0 (t # queue', n) s t = None", "have \"t \\<notin> active_threads s\""], ["proof (prove)\nusing this:\n  round_robin_step n0 (t # queue', n) s t = None\n\ngoal (1 subgoal):\n 1. t \\<notin> active_threads s", "by(rule step_thread_NoneD)"], ["proof (state)\nthis:\n  t \\<notin> active_threads s\n\ngoal (1 subgoal):\n 1. \\<And>a list. queue = a # list \\<Longrightarrow> active_threads s = {}", "moreover"], ["proof (state)\nthis:\n  t \\<notin> active_threads s\n\ngoal (1 subgoal):\n 1. \\<And>a list. queue = a # list \\<Longrightarrow> active_threads s = {}", "from \\<open>round_robin_reschedule t (queue' @ [t]) n0 s = None\\<close>"], ["proof (chain)\npicking this:\n  round_robin_reschedule t (queue' @ [t]) n0 s = None", "have \"set (takeWhile (\\<lambda>x. x \\<noteq> t) (queue' @ [t])) \\<inter> active_threads s = {}\""], ["proof (prove)\nusing this:\n  round_robin_reschedule t (queue' @ [t]) n0 s = None\n\ngoal (1 subgoal):\n 1. set (takeWhile (\\<lambda>x. x \\<noteq> t) (queue' @ [t])) \\<inter>\n    active_threads s =\n    {}", "by(rule round_robin_reschedule_NoneD) simp"], ["proof (state)\nthis:\n  set (takeWhile (\\<lambda>x. x \\<noteq> t) (queue' @ [t])) \\<inter>\n  active_threads s =\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>a list. queue = a # list \\<Longrightarrow> active_threads s = {}", "moreover"], ["proof (state)\nthis:\n  set (takeWhile (\\<lambda>x. x \\<noteq> t) (queue' @ [t])) \\<inter>\n  active_threads s =\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>a list. queue = a # list \\<Longrightarrow> active_threads s = {}", "from invar \\<sigma> Cons"], ["proof (chain)\npicking this:\n  round_robin_invar \\<sigma> (dom (thr s))\n  \\<sigma> = (queue, n)\n  queue = t # queue'", "have \"takeWhile (\\<lambda>x. x \\<noteq> t) (queue' @ [t]) = queue'\""], ["proof (prove)\nusing this:\n  round_robin_invar \\<sigma> (dom (thr s))\n  \\<sigma> = (queue, n)\n  queue = t # queue'\n\ngoal (1 subgoal):\n 1. takeWhile (\\<lambda>x. x \\<noteq> t) (queue' @ [t]) = queue'", "by(subst takeWhile_append2) auto"], ["proof (state)\nthis:\n  takeWhile (\\<lambda>x. x \\<noteq> t) (queue' @ [t]) = queue'\n\ngoal (1 subgoal):\n 1. \\<And>a list. queue = a # list \\<Longrightarrow> active_threads s = {}", "moreover"], ["proof (state)\nthis:\n  takeWhile (\\<lambda>x. x \\<noteq> t) (queue' @ [t]) = queue'\n\ngoal (1 subgoal):\n 1. \\<And>a list. queue = a # list \\<Longrightarrow> active_threads s = {}", "from invar"], ["proof (chain)\npicking this:\n  round_robin_invar \\<sigma> (dom (thr s))", "have \"active_threads s \\<subseteq> set queue\""], ["proof (prove)\nusing this:\n  round_robin_invar \\<sigma> (dom (thr s))\n\ngoal (1 subgoal):\n 1. active_threads s \\<subseteq> set queue", "using \\<sigma>"], ["proof (prove)\nusing this:\n  round_robin_invar \\<sigma> (dom (thr s))\n  \\<sigma> = (queue, n)\n\ngoal (1 subgoal):\n 1. active_threads s \\<subseteq> set queue", "by(auto elim: active_threads.cases)"], ["proof (state)\nthis:\n  active_threads s \\<subseteq> set queue\n\ngoal (1 subgoal):\n 1. \\<And>a list. queue = a # list \\<Longrightarrow> active_threads s = {}", "ultimately"], ["proof (chain)\npicking this:\n  t \\<notin> active_threads s\n  set (takeWhile (\\<lambda>x. x \\<noteq> t) (queue' @ [t])) \\<inter>\n  active_threads s =\n  {}\n  takeWhile (\\<lambda>x. x \\<noteq> t) (queue' @ [t]) = queue'\n  active_threads s \\<subseteq> set queue", "show ?thesis"], ["proof (prove)\nusing this:\n  t \\<notin> active_threads s\n  set (takeWhile (\\<lambda>x. x \\<noteq> t) (queue' @ [t])) \\<inter>\n  active_threads s =\n  {}\n  takeWhile (\\<lambda>x. x \\<noteq> t) (queue' @ [t]) = queue'\n  active_threads s \\<subseteq> set queue\n\ngoal (1 subgoal):\n 1. active_threads s = {}", "using Cons"], ["proof (prove)\nusing this:\n  t \\<notin> active_threads s\n  set (takeWhile (\\<lambda>x. x \\<noteq> t) (queue' @ [t])) \\<inter>\n  active_threads s =\n  {}\n  takeWhile (\\<lambda>x. x \\<noteq> t) (queue' @ [t]) = queue'\n  active_threads s \\<subseteq> set queue\n  queue = t # queue'\n\ngoal (1 subgoal):\n 1. active_threads s = {}", "by auto"], ["proof (state)\nthis:\n  active_threads s = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  active_threads s = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma round_robin_Some_NoneD:\n  assumes rr: \"round_robin n0 \\<sigma> s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\"\n  shows \"\\<exists>x ln n. thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and> ln $ n > 0 \\<and> \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x ln n.\n       thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       0 < ln $ n \\<and>\n       \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x ln n.\n       thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       0 < ln $ n \\<and>\n       \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln", "obtain queue n where \\<sigma>: \"\\<sigma> = (queue, n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>queue n.\n        \\<sigma> = (queue, n) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \\<sigma>)"], ["proof (state)\nthis:\n  \\<sigma> = (queue, n)\n\ngoal (1 subgoal):\n 1. \\<exists>x ln n.\n       thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       0 < ln $ n \\<and>\n       \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln", "with rr"], ["proof (chain)\npicking this:\n  round_robin n0 \\<sigma> s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  \\<sigma> = (queue, n)", "have \"queue \\<noteq> []\""], ["proof (prove)\nusing this:\n  round_robin n0 \\<sigma> s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  \\<sigma> = (queue, n)\n\ngoal (1 subgoal):\n 1. queue \\<noteq> []", "by clarsimp"], ["proof (state)\nthis:\n  queue \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>x ln n.\n       thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       0 < ln $ n \\<and>\n       \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln", "then"], ["proof (chain)\npicking this:\n  queue \\<noteq> []", "obtain t' queue' where queue: \"queue = t' # queue'\""], ["proof (prove)\nusing this:\n  queue \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>t' queue'.\n        queue = t' # queue' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: neq_Nil_conv)"], ["proof (state)\nthis:\n  queue = t' # queue'\n\ngoal (1 subgoal):\n 1. \\<exists>x ln n.\n       thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       0 < ln $ n \\<and>\n       \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x ln n.\n       thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       0 < ln $ n \\<and>\n       \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln", "proof(cases \"round_robin_step n0 (t' # queue', n) s t'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. round_robin_step n0 (t' # queue', n) s t' = None \\<Longrightarrow>\n    \\<exists>x ln n.\n       thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       0 < ln $ n \\<and>\n       \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln\n 2. \\<And>a.\n       round_robin_step n0 (t' # queue', n) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>x ln n.\n          thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n          0 < ln $ n \\<and>\n          \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln", "case (Some a)"], ["proof (state)\nthis:\n  round_robin_step n0 (t' # queue', n) s t' = \\<lfloor>a\\<rfloor>\n\ngoal (2 subgoals):\n 1. round_robin_step n0 (t' # queue', n) s t' = None \\<Longrightarrow>\n    \\<exists>x ln n.\n       thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       0 < ln $ n \\<and>\n       \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln\n 2. \\<And>a.\n       round_robin_step n0 (t' # queue', n) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>x ln n.\n          thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n          0 < ln $ n \\<and>\n          \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln", "with rr queue \\<sigma>"], ["proof (chain)\npicking this:\n  round_robin n0 \\<sigma> s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  queue = t' # queue'\n  \\<sigma> = (queue, n)\n  round_robin_step n0 (t' # queue', n) s t' = \\<lfloor>a\\<rfloor>", "have \"round_robin_step n0 (t' # queue', n) s t' = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\""], ["proof (prove)\nusing this:\n  round_robin n0 \\<sigma> s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  queue = t' # queue'\n  \\<sigma> = (queue, n)\n  round_robin_step n0 (t' # queue', n) s t' = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (t' # queue', n) s t' =\n    \\<lfloor>(t, None, \\<sigma>')\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  round_robin_step n0 (t' # queue', n) s t' =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n\ngoal (2 subgoals):\n 1. round_robin_step n0 (t' # queue', n) s t' = None \\<Longrightarrow>\n    \\<exists>x ln n.\n       thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       0 < ln $ n \\<and>\n       \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln\n 2. \\<And>a.\n       round_robin_step n0 (t' # queue', n) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>x ln n.\n          thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n          0 < ln $ n \\<and>\n          \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln", "thus ?thesis"], ["proof (prove)\nusing this:\n  round_robin_step n0 (t' # queue', n) s t' =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>x ln n.\n       thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       0 < ln $ n \\<and>\n       \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln", "by(blast dest: step_thread_Some_NoneD)"], ["proof (state)\nthis:\n  \\<exists>x ln n.\n     thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n     0 < ln $ n \\<and>\n     \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (t' # queue', n) s t' = None \\<Longrightarrow>\n    \\<exists>x ln n.\n       thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       0 < ln $ n \\<and>\n       \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. round_robin_step n0 (t' # queue', n) s t' = None \\<Longrightarrow>\n    \\<exists>x ln n.\n       thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       0 < ln $ n \\<and>\n       \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln", "case None"], ["proof (state)\nthis:\n  round_robin_step n0 (t' # queue', n) s t' = None\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (t' # queue', n) s t' = None \\<Longrightarrow>\n    \\<exists>x ln n.\n       thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       0 < ln $ n \\<and>\n       \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln", "with rr queue \\<sigma>"], ["proof (chain)\npicking this:\n  round_robin n0 \\<sigma> s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  queue = t' # queue'\n  \\<sigma> = (queue, n)\n  round_robin_step n0 (t' # queue', n) s t' = None", "have \"round_robin_reschedule t' (queue' @ [t']) n0 s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\""], ["proof (prove)\nusing this:\n  round_robin n0 \\<sigma> s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  queue = t' # queue'\n  \\<sigma> = (queue, n)\n  round_robin_step n0 (t' # queue', n) s t' = None\n\ngoal (1 subgoal):\n 1. round_robin_reschedule t' (queue' @ [t']) n0 s =\n    \\<lfloor>(t, None, \\<sigma>')\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  round_robin_reschedule t' (queue' @ [t']) n0 s =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (t' # queue', n) s t' = None \\<Longrightarrow>\n    \\<exists>x ln n.\n       thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       0 < ln $ n \\<and>\n       \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln", "thus ?thesis"], ["proof (prove)\nusing this:\n  round_robin_reschedule t' (queue' @ [t']) n0 s =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>x ln n.\n       thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       0 < ln $ n \\<and>\n       \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln", "by(rule round_robin_reschedule_Some_NoneD)simp"], ["proof (state)\nthis:\n  \\<exists>x ln n.\n     thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n     0 < ln $ n \\<and>\n     \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x ln n.\n     thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n     0 < ln $ n \\<and>\n     \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma round_robin_Some_SomeD:\n  assumes \"deterministic I\"\n  and rr: \"round_robin n0 \\<sigma> s = \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\"\n  and \"s \\<in> I\"\n  shows \"\\<exists>x. thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and> t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and> actions_ok s t ta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n       actions_ok s t ta", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n       actions_ok s t ta", "obtain queue n where \\<sigma>: \"\\<sigma> = (queue, n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>queue n.\n        \\<sigma> = (queue, n) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \\<sigma>)"], ["proof (state)\nthis:\n  \\<sigma> = (queue, n)\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n       actions_ok s t ta", "with rr"], ["proof (chain)\npicking this:\n  round_robin n0 \\<sigma> s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  \\<sigma> = (queue, n)", "have \"queue \\<noteq> []\""], ["proof (prove)\nusing this:\n  round_robin n0 \\<sigma> s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  \\<sigma> = (queue, n)\n\ngoal (1 subgoal):\n 1. queue \\<noteq> []", "by clarsimp"], ["proof (state)\nthis:\n  queue \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n       actions_ok s t ta", "then"], ["proof (chain)\npicking this:\n  queue \\<noteq> []", "obtain t' queue' where queue: \"queue = t' # queue'\""], ["proof (prove)\nusing this:\n  queue \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>t' queue'.\n        queue = t' # queue' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: neq_Nil_conv)"], ["proof (state)\nthis:\n  queue = t' # queue'\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n       actions_ok s t ta", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n       actions_ok s t ta", "proof(cases \"round_robin_step n0 (t' # queue', n) s t'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. round_robin_step n0 (t' # queue', n) s t' = None \\<Longrightarrow>\n    \\<exists>x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n       actions_ok s t ta\n 2. \\<And>a.\n       round_robin_step n0 (t' # queue', n) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>x.\n          thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n          t \\<turnstile> \\<langle>x, shr\ns\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n          actions_ok s t ta", "case (Some a)"], ["proof (state)\nthis:\n  round_robin_step n0 (t' # queue', n) s t' = \\<lfloor>a\\<rfloor>\n\ngoal (2 subgoals):\n 1. round_robin_step n0 (t' # queue', n) s t' = None \\<Longrightarrow>\n    \\<exists>x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n       actions_ok s t ta\n 2. \\<And>a.\n       round_robin_step n0 (t' # queue', n) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>x.\n          thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n          t \\<turnstile> \\<langle>x, shr\ns\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n          actions_ok s t ta", "with rr queue \\<sigma>"], ["proof (chain)\npicking this:\n  round_robin n0 \\<sigma> s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  queue = t' # queue'\n  \\<sigma> = (queue, n)\n  round_robin_step n0 (t' # queue', n) s t' = \\<lfloor>a\\<rfloor>", "have \"round_robin_step n0 (t' # queue', n) s t' = \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\""], ["proof (prove)\nusing this:\n  round_robin n0 \\<sigma> s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  queue = t' # queue'\n  \\<sigma> = (queue, n)\n  round_robin_step n0 (t' # queue', n) s t' = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (t' # queue', n) s t' =\n    \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  round_robin_step n0 (t' # queue', n) s t' =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n\ngoal (2 subgoals):\n 1. round_robin_step n0 (t' # queue', n) s t' = None \\<Longrightarrow>\n    \\<exists>x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n       actions_ok s t ta\n 2. \\<And>a.\n       round_robin_step n0 (t' # queue', n) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>x.\n          thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n          t \\<turnstile> \\<langle>x, shr\ns\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n          actions_ok s t ta", "thus ?thesis"], ["proof (prove)\nusing this:\n  round_robin_step n0 (t' # queue', n) s t' =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n       actions_ok s t ta", "using \\<open>s \\<in> I\\<close>"], ["proof (prove)\nusing this:\n  round_robin_step n0 (t' # queue', n) s t' =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  s \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n       actions_ok s t ta", "by(blast dest: step_thread_Some_SomeD[OF \\<open>deterministic I\\<close>])"], ["proof (state)\nthis:\n  \\<exists>x.\n     thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n     t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n     actions_ok s t ta\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (t' # queue', n) s t' = None \\<Longrightarrow>\n    \\<exists>x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n       actions_ok s t ta", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. round_robin_step n0 (t' # queue', n) s t' = None \\<Longrightarrow>\n    \\<exists>x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n       actions_ok s t ta", "case None"], ["proof (state)\nthis:\n  round_robin_step n0 (t' # queue', n) s t' = None\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (t' # queue', n) s t' = None \\<Longrightarrow>\n    \\<exists>x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n       actions_ok s t ta", "with rr queue \\<sigma>"], ["proof (chain)\npicking this:\n  round_robin n0 \\<sigma> s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  queue = t' # queue'\n  \\<sigma> = (queue, n)\n  round_robin_step n0 (t' # queue', n) s t' = None", "have \"round_robin_reschedule t' (queue' @ [t']) n0 s = \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\""], ["proof (prove)\nusing this:\n  round_robin n0 \\<sigma> s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  queue = t' # queue'\n  \\<sigma> = (queue, n)\n  round_robin_step n0 (t' # queue', n) s t' = None\n\ngoal (1 subgoal):\n 1. round_robin_reschedule t' (queue' @ [t']) n0 s =\n    \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  round_robin_reschedule t' (queue' @ [t']) n0 s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (t' # queue', n) s t' = None \\<Longrightarrow>\n    \\<exists>x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n       actions_ok s t ta", "thus ?thesis"], ["proof (prove)\nusing this:\n  round_robin_reschedule t' (queue' @ [t']) n0 s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n       actions_ok s t ta", "by(rule round_robin_reschedule_Some_SomeD[OF \\<open>deterministic I\\<close>])(simp_all add: \\<open>s \\<in> I\\<close>)"], ["proof (state)\nthis:\n  \\<exists>x.\n     thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n     t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n     actions_ok s t ta\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x.\n     thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n     t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n     actions_ok s t ta\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma round_robin_invar_None:\n  assumes rr: \"round_robin n0 \\<sigma> s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\"\n  and invar: \"round_robin_invar \\<sigma> (dom (thr s))\"\n  shows \"round_robin_invar \\<sigma>' (dom (thr s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>' (dom (thr s))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>' (dom (thr s))", "obtain queue n where \\<sigma>: \"\\<sigma> = (queue, n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>queue n.\n        \\<sigma> = (queue, n) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \\<sigma>)"], ["proof (state)\nthis:\n  \\<sigma> = (queue, n)\n\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>' (dom (thr s))", "with rr"], ["proof (chain)\npicking this:\n  round_robin n0 \\<sigma> s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  \\<sigma> = (queue, n)", "have \"queue \\<noteq> []\""], ["proof (prove)\nusing this:\n  round_robin n0 \\<sigma> s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  \\<sigma> = (queue, n)\n\ngoal (1 subgoal):\n 1. queue \\<noteq> []", "by clarsimp"], ["proof (state)\nthis:\n  queue \\<noteq> []\n\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>' (dom (thr s))", "then"], ["proof (chain)\npicking this:\n  queue \\<noteq> []", "obtain t' queue' where queue: \"queue = t' # queue'\""], ["proof (prove)\nusing this:\n  queue \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>t' queue'.\n        queue = t' # queue' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: neq_Nil_conv)"], ["proof (state)\nthis:\n  queue = t' # queue'\n\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>' (dom (thr s))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>' (dom (thr s))", "proof(cases \"round_robin_step n0 (t' # queue', n) s t'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. round_robin_step n0 (t' # queue', n) s t' = None \\<Longrightarrow>\n    round_robin_invar \\<sigma>' (dom (thr s))\n 2. \\<And>a.\n       round_robin_step n0 (t' # queue', n) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       round_robin_invar \\<sigma>' (dom (thr s))", "case (Some a)"], ["proof (state)\nthis:\n  round_robin_step n0 (t' # queue', n) s t' = \\<lfloor>a\\<rfloor>\n\ngoal (2 subgoals):\n 1. round_robin_step n0 (t' # queue', n) s t' = None \\<Longrightarrow>\n    round_robin_invar \\<sigma>' (dom (thr s))\n 2. \\<And>a.\n       round_robin_step n0 (t' # queue', n) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       round_robin_invar \\<sigma>' (dom (thr s))", "with rr queue \\<sigma>"], ["proof (chain)\npicking this:\n  round_robin n0 \\<sigma> s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  queue = t' # queue'\n  \\<sigma> = (queue, n)\n  round_robin_step n0 (t' # queue', n) s t' = \\<lfloor>a\\<rfloor>", "have \"round_robin_step n0 (t' # queue', n) s t' = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\""], ["proof (prove)\nusing this:\n  round_robin n0 \\<sigma> s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  queue = t' # queue'\n  \\<sigma> = (queue, n)\n  round_robin_step n0 (t' # queue', n) s t' = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (t' # queue', n) s t' =\n    \\<lfloor>(t, None, \\<sigma>')\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  round_robin_step n0 (t' # queue', n) s t' =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n\ngoal (2 subgoals):\n 1. round_robin_step n0 (t' # queue', n) s t' = None \\<Longrightarrow>\n    round_robin_invar \\<sigma>' (dom (thr s))\n 2. \\<And>a.\n       round_robin_step n0 (t' # queue', n) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       round_robin_invar \\<sigma>' (dom (thr s))", "thus ?thesis"], ["proof (prove)\nusing this:\n  round_robin_step n0 (t' # queue', n) s t' =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>' (dom (thr s))", "using invar"], ["proof (prove)\nusing this:\n  round_robin_step n0 (t' # queue', n) s t' =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  round_robin_invar \\<sigma> (dom (thr s))\n\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>' (dom (thr s))", "unfolding \\<sigma> queue"], ["proof (prove)\nusing this:\n  round_robin_step n0 (t' # queue', n) s t' =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  round_robin_invar (t' # queue', n) (dom (thr s))\n\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>' (dom (thr s))", "by(rule round_robin_step_invar_None)"], ["proof (state)\nthis:\n  round_robin_invar \\<sigma>' (dom (thr s))\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (t' # queue', n) s t' = None \\<Longrightarrow>\n    round_robin_invar \\<sigma>' (dom (thr s))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. round_robin_step n0 (t' # queue', n) s t' = None \\<Longrightarrow>\n    round_robin_invar \\<sigma>' (dom (thr s))", "case None"], ["proof (state)\nthis:\n  round_robin_step n0 (t' # queue', n) s t' = None\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (t' # queue', n) s t' = None \\<Longrightarrow>\n    round_robin_invar \\<sigma>' (dom (thr s))", "with rr queue \\<sigma>"], ["proof (chain)\npicking this:\n  round_robin n0 \\<sigma> s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  queue = t' # queue'\n  \\<sigma> = (queue, n)\n  round_robin_step n0 (t' # queue', n) s t' = None", "have \"round_robin_reschedule t' (queue' @ [t']) n0 s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\""], ["proof (prove)\nusing this:\n  round_robin n0 \\<sigma> s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  queue = t' # queue'\n  \\<sigma> = (queue, n)\n  round_robin_step n0 (t' # queue', n) s t' = None\n\ngoal (1 subgoal):\n 1. round_robin_reschedule t' (queue' @ [t']) n0 s =\n    \\<lfloor>(t, None, \\<sigma>')\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  round_robin_reschedule t' (queue' @ [t']) n0 s =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (t' # queue', n) s t' = None \\<Longrightarrow>\n    round_robin_invar \\<sigma>' (dom (thr s))", "moreover"], ["proof (state)\nthis:\n  round_robin_reschedule t' (queue' @ [t']) n0 s =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (t' # queue', n) s t' = None \\<Longrightarrow>\n    round_robin_invar \\<sigma>' (dom (thr s))", "from invar queue \\<sigma>"], ["proof (chain)\npicking this:\n  round_robin_invar \\<sigma> (dom (thr s))\n  queue = t' # queue'\n  \\<sigma> = (queue, n)", "have \"round_robin_invar (queue' @ [t'], n0) (dom (thr s))\""], ["proof (prove)\nusing this:\n  round_robin_invar \\<sigma> (dom (thr s))\n  queue = t' # queue'\n  \\<sigma> = (queue, n)\n\ngoal (1 subgoal):\n 1. round_robin_invar (queue' @ [t'], n0) (dom (thr s))", "by simp"], ["proof (state)\nthis:\n  round_robin_invar (queue' @ [t'], n0) (dom (thr s))\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (t' # queue', n) s t' = None \\<Longrightarrow>\n    round_robin_invar \\<sigma>' (dom (thr s))", "ultimately"], ["proof (chain)\npicking this:\n  round_robin_reschedule t' (queue' @ [t']) n0 s =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  round_robin_invar (queue' @ [t'], n0) (dom (thr s))", "show ?thesis"], ["proof (prove)\nusing this:\n  round_robin_reschedule t' (queue' @ [t']) n0 s =\n  \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  round_robin_invar (queue' @ [t'], n0) (dom (thr s))\n\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>' (dom (thr s))", "by(rule round_robin_reschedule_invar_None) simp"], ["proof (state)\nthis:\n  round_robin_invar \\<sigma>' (dom (thr s))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  round_robin_invar \\<sigma>' (dom (thr s))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma round_robin_invar_Some:\n  assumes \"deterministic I\"\n  and rr: \"round_robin n0 \\<sigma> s = \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\"\n  and invar: \"round_robin_invar \\<sigma> (dom (thr s))\" \"s \\<in> I\"\n  shows \"round_robin_invar \\<sigma>' (dom (thr s) \\<union> {t. \\<exists>x m. NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>'\n     (dom (thr s) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>'\n     (dom (thr s) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "obtain queue n where \\<sigma>: \"\\<sigma> = (queue, n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>queue n.\n        \\<sigma> = (queue, n) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \\<sigma>)"], ["proof (state)\nthis:\n  \\<sigma> = (queue, n)\n\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>'\n     (dom (thr s) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "with rr"], ["proof (chain)\npicking this:\n  round_robin n0 \\<sigma> s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  \\<sigma> = (queue, n)", "have \"queue \\<noteq> []\""], ["proof (prove)\nusing this:\n  round_robin n0 \\<sigma> s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  \\<sigma> = (queue, n)\n\ngoal (1 subgoal):\n 1. queue \\<noteq> []", "by clarsimp"], ["proof (state)\nthis:\n  queue \\<noteq> []\n\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>'\n     (dom (thr s) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "then"], ["proof (chain)\npicking this:\n  queue \\<noteq> []", "obtain t' queue' where queue: \"queue = t' # queue'\""], ["proof (prove)\nusing this:\n  queue \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>t' queue'.\n        queue = t' # queue' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: neq_Nil_conv)"], ["proof (state)\nthis:\n  queue = t' # queue'\n\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>'\n     (dom (thr s) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>'\n     (dom (thr s) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "proof(cases \"round_robin_step n0 (t' # queue', n) s t'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. round_robin_step n0 (t' # queue', n) s t' = None \\<Longrightarrow>\n    round_robin_invar \\<sigma>'\n     (dom (thr s) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n 2. \\<And>a.\n       round_robin_step n0 (t' # queue', n) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       round_robin_invar \\<sigma>'\n        (dom (thr s) \\<union>\n         {t. \\<exists>x m.\n                NewThread t x m\n                \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "case (Some a)"], ["proof (state)\nthis:\n  round_robin_step n0 (t' # queue', n) s t' = \\<lfloor>a\\<rfloor>\n\ngoal (2 subgoals):\n 1. round_robin_step n0 (t' # queue', n) s t' = None \\<Longrightarrow>\n    round_robin_invar \\<sigma>'\n     (dom (thr s) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n 2. \\<And>a.\n       round_robin_step n0 (t' # queue', n) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       round_robin_invar \\<sigma>'\n        (dom (thr s) \\<union>\n         {t. \\<exists>x m.\n                NewThread t x m\n                \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "with rr queue \\<sigma>"], ["proof (chain)\npicking this:\n  round_robin n0 \\<sigma> s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  queue = t' # queue'\n  \\<sigma> = (queue, n)\n  round_robin_step n0 (t' # queue', n) s t' = \\<lfloor>a\\<rfloor>", "have \"round_robin_step n0 (t' # queue', n) s t' = \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\""], ["proof (prove)\nusing this:\n  round_robin n0 \\<sigma> s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  queue = t' # queue'\n  \\<sigma> = (queue, n)\n  round_robin_step n0 (t' # queue', n) s t' = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (t' # queue', n) s t' =\n    \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  round_robin_step n0 (t' # queue', n) s t' =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n\ngoal (2 subgoals):\n 1. round_robin_step n0 (t' # queue', n) s t' = None \\<Longrightarrow>\n    round_robin_invar \\<sigma>'\n     (dom (thr s) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n 2. \\<And>a.\n       round_robin_step n0 (t' # queue', n) s t' =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       round_robin_invar \\<sigma>'\n        (dom (thr s) \\<union>\n         {t. \\<exists>x m.\n                NewThread t x m\n                \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "thus ?thesis"], ["proof (prove)\nusing this:\n  round_robin_step n0 (t' # queue', n) s t' =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>'\n     (dom (thr s) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "using invar"], ["proof (prove)\nusing this:\n  round_robin_step n0 (t' # queue', n) s t' =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  round_robin_invar \\<sigma> (dom (thr s))\n  s \\<in> I\n\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>'\n     (dom (thr s) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "unfolding \\<sigma> queue"], ["proof (prove)\nusing this:\n  round_robin_step n0 (t' # queue', n) s t' =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  round_robin_invar (t' # queue', n) (dom (thr s))\n  s \\<in> I\n\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>'\n     (dom (thr s) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "by(rule round_robin_step_invar_Some[OF \\<open>deterministic I\\<close>])"], ["proof (state)\nthis:\n  round_robin_invar \\<sigma>'\n   (dom (thr s) \\<union>\n    {t. \\<exists>x m.\n           NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (t' # queue', n) s t' = None \\<Longrightarrow>\n    round_robin_invar \\<sigma>'\n     (dom (thr s) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. round_robin_step n0 (t' # queue', n) s t' = None \\<Longrightarrow>\n    round_robin_invar \\<sigma>'\n     (dom (thr s) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "case None"], ["proof (state)\nthis:\n  round_robin_step n0 (t' # queue', n) s t' = None\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (t' # queue', n) s t' = None \\<Longrightarrow>\n    round_robin_invar \\<sigma>'\n     (dom (thr s) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "with rr queue \\<sigma>"], ["proof (chain)\npicking this:\n  round_robin n0 \\<sigma> s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  queue = t' # queue'\n  \\<sigma> = (queue, n)\n  round_robin_step n0 (t' # queue', n) s t' = None", "have \"round_robin_reschedule t' (queue' @ [t']) n0 s = \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\""], ["proof (prove)\nusing this:\n  round_robin n0 \\<sigma> s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  queue = t' # queue'\n  \\<sigma> = (queue, n)\n  round_robin_step n0 (t' # queue', n) s t' = None\n\ngoal (1 subgoal):\n 1. round_robin_reschedule t' (queue' @ [t']) n0 s =\n    \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  round_robin_reschedule t' (queue' @ [t']) n0 s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (t' # queue', n) s t' = None \\<Longrightarrow>\n    round_robin_invar \\<sigma>'\n     (dom (thr s) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "moreover"], ["proof (state)\nthis:\n  round_robin_reschedule t' (queue' @ [t']) n0 s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (t' # queue', n) s t' = None \\<Longrightarrow>\n    round_robin_invar \\<sigma>'\n     (dom (thr s) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "from invar queue \\<sigma>"], ["proof (chain)\npicking this:\n  round_robin_invar \\<sigma> (dom (thr s))\n  s \\<in> I\n  queue = t' # queue'\n  \\<sigma> = (queue, n)", "have \"round_robin_invar (queue' @ [t'], n0) (dom (thr s))\""], ["proof (prove)\nusing this:\n  round_robin_invar \\<sigma> (dom (thr s))\n  s \\<in> I\n  queue = t' # queue'\n  \\<sigma> = (queue, n)\n\ngoal (1 subgoal):\n 1. round_robin_invar (queue' @ [t'], n0) (dom (thr s))", "by simp"], ["proof (state)\nthis:\n  round_robin_invar (queue' @ [t'], n0) (dom (thr s))\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (t' # queue', n) s t' = None \\<Longrightarrow>\n    round_robin_invar \\<sigma>'\n     (dom (thr s) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "ultimately"], ["proof (chain)\npicking this:\n  round_robin_reschedule t' (queue' @ [t']) n0 s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  round_robin_invar (queue' @ [t'], n0) (dom (thr s))", "show ?thesis"], ["proof (prove)\nusing this:\n  round_robin_reschedule t' (queue' @ [t']) n0 s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  round_robin_invar (queue' @ [t'], n0) (dom (thr s))\n\ngoal (1 subgoal):\n 1. round_robin_invar \\<sigma>'\n     (dom (thr s) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "by(rule round_robin_reschedule_invar_Some[OF \\<open>deterministic I\\<close>])(simp_all add: \\<open>s \\<in> I\\<close>)"], ["proof (state)\nthis:\n  round_robin_invar \\<sigma>'\n   (dom (thr s) \\<union>\n    {t. \\<exists>x m.\n           NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  round_robin_invar \\<sigma>'\n   (dom (thr s) \\<union>\n    {t. \\<exists>x m.\n           NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale round_robin_base =\n  scheduler_base_aux\n    final r convert_RA\n    thr_\\<alpha> thr_invar thr_lookup thr_update\n    ws_\\<alpha> ws_invar ws_lookup\n    is_\\<alpha> is_invar is_memb is_ins is_delete\n  for final :: \"'x \\<Rightarrow> bool\"\n  and r :: \"'t \\<Rightarrow> ('x \\<times> 'm) \\<Rightarrow> (('l,'t,'x,'m,'w,'o) thread_action \\<times> 'x \\<times> 'm) Predicate.pred\"\n  and convert_RA :: \"'l released_locks \\<Rightarrow> 'o list\"\n  and \"output\" :: \"'queue round_robin \\<Rightarrow> 't \\<Rightarrow> ('l,'t,'x,'m,'w,'o) thread_action \\<Rightarrow> 'q option\"\n  and thr_\\<alpha> :: \"'m_t \\<Rightarrow> ('l,'t,'x) thread_info\"\n  and thr_invar :: \"'m_t \\<Rightarrow> bool\"\n  and thr_lookup :: \"'t \\<Rightarrow> 'm_t \\<rightharpoonup> ('x \\<times> 'l released_locks)\"\n  and thr_update :: \"'t \\<Rightarrow> 'x \\<times> 'l released_locks \\<Rightarrow> 'm_t \\<Rightarrow> 'm_t\"\n  and ws_\\<alpha> :: \"'m_w \\<Rightarrow> ('w,'t) wait_sets\"\n  and ws_invar :: \"'m_w \\<Rightarrow> bool\"\n  and ws_lookup :: \"'t \\<Rightarrow> 'm_w \\<rightharpoonup> 'w wait_set_status\"\n  and ws_update :: \"'t \\<Rightarrow> 'w wait_set_status \\<Rightarrow> 'm_w \\<Rightarrow> 'm_w\"\n  and ws_delete :: \"'t \\<Rightarrow> 'm_w \\<Rightarrow> 'm_w\"\n  and ws_iterate :: \"'m_w \\<Rightarrow> ('t \\<times> 'w wait_set_status, 'm_w) set_iterator\"\n  and ws_sel :: \"'m_w \\<Rightarrow> ('t \\<times> 'w wait_set_status \\<Rightarrow> bool) \\<rightharpoonup> ('t \\<times> 'w wait_set_status)\"\n  and is_\\<alpha> :: \"'s_i \\<Rightarrow> 't interrupts\"\n  and is_invar :: \"'s_i \\<Rightarrow> bool\"\n  and is_memb :: \"'t \\<Rightarrow> 's_i \\<Rightarrow> bool\"\n  and is_ins :: \"'t \\<Rightarrow> 's_i \\<Rightarrow> 's_i\"\n  and is_delete :: \"'t \\<Rightarrow> 's_i \\<Rightarrow> 's_i\"\n  +\n  fixes queue_\\<alpha> :: \"'queue \\<Rightarrow> 't list\"\n  and queue_invar :: \"'queue \\<Rightarrow> bool\"\n  and queue_empty :: \"unit \\<Rightarrow> 'queue\"\n  and queue_isEmpty :: \"'queue \\<Rightarrow> bool\"\n  and queue_enqueue :: \"'t \\<Rightarrow> 'queue \\<Rightarrow> 'queue\"\n  and queue_dequeue :: \"'queue \\<Rightarrow> 't \\<times> 'queue\"\n  and queue_push :: \"'t \\<Rightarrow> 'queue \\<Rightarrow> 'queue\"\nbegin"], ["", "definition queue_rotate1 :: \"'queue \\<Rightarrow> 'queue\"\nwhere \"queue_rotate1 = case_prod queue_enqueue \\<circ> queue_dequeue\""], ["", "primrec enqueue_new_thread :: \"'queue \\<Rightarrow> ('t,'x,'m) new_thread_action \\<Rightarrow> 'queue\"\nwhere \n  \"enqueue_new_thread ts (NewThread t x m) = queue_enqueue t ts\"\n| \"enqueue_new_thread ts (ThreadExists t b) = ts\""], ["", "definition enqueue_new_threads :: \"'queue \\<Rightarrow> ('t,'x,'m) new_thread_action list \\<Rightarrow> 'queue\"\nwhere\n  \"enqueue_new_threads = foldl enqueue_new_thread\""], ["", "primrec round_robin_update_state :: \"nat \\<Rightarrow> 'queue round_robin \\<Rightarrow> 't \\<Rightarrow> ('l,'t,'x,'m,'w,'o) thread_action \\<Rightarrow> 'queue round_robin\"\nwhere \n  \"round_robin_update_state n0 (queue, n) t ta =\n   (let queue' = enqueue_new_threads queue \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n    in if n = 0 \\<or> Yield \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> then (queue_rotate1 queue', n0) else (queue', n - 1))\""], ["", "abbreviation round_robin_step ::\n  \"nat \\<Rightarrow> 'queue round_robin \\<Rightarrow> ('l,'t,'m,'m_t,'m_w,'s_i) state_refine \\<Rightarrow> 't \n  \\<Rightarrow> ('t \\<times> (('l,'t,'x,'m,'w,'o) thread_action \\<times> 'x \\<times> 'm) option \\<times> 'queue round_robin) option\"\nwhere\n  \"round_robin_step n0 \\<sigma> s t \\<equiv> step_thread (round_robin_update_state n0 \\<sigma> t) s t\""], ["", "partial_function (option) round_robin_reschedule ::\n  \"'t \\<Rightarrow> 'queue \\<Rightarrow> nat \\<Rightarrow> ('l,'t,'m,'m_t,'m_w,'s_i) state_refine \n  \\<Rightarrow> ('t \\<times> (('l,'t,'x,'m,'w,'o) thread_action \\<times> 'x \\<times> 'm) option \\<times> 'queue round_robin) option\"\nwhere\n  \"round_robin_reschedule t0 queue n0 s =\n   (let\n      (t, queue') = queue_dequeue queue\n    in\n      if t = t0 then\n        None \n      else\n        case round_robin_step n0 (queue_push t queue', n0) s t of\n          None \\<Rightarrow> round_robin_reschedule t0 (queue_enqueue t queue') n0 s\n        | \\<lfloor>ttaxm\\<sigma>\\<rfloor> \\<Rightarrow> \\<lfloor>ttaxm\\<sigma>\\<rfloor>)\""], ["", "primrec round_robin :: \"nat \\<Rightarrow> ('l,'t,'x,'m,'w,'o,'m_t,'m_w,'s_i,'queue round_robin) scheduler\"\nwhere \n  \"round_robin n0 (queue, n) s = \n   (if queue_isEmpty queue then None\n    else\n      let\n        (t, queue') = queue_dequeue queue\n      in\n        (case round_robin_step n0 (queue_push t queue', n) s t of\n           \\<lfloor>ttaxm\\<sigma>\\<rfloor> \\<Rightarrow> \\<lfloor>ttaxm\\<sigma>\\<rfloor>\n         | None \\<Rightarrow> round_robin_reschedule t (queue_enqueue t queue') n0 s))\""], ["", "primrec round_robin_invar :: \"'queue round_robin \\<Rightarrow> 't set \\<Rightarrow> bool\"\nwhere \"round_robin_invar (queue, n) T \\<longleftrightarrow> queue_invar queue \\<and> Round_Robin.round_robin_invar (queue_\\<alpha> queue, n) T\""], ["", "definition round_robin_\\<alpha> :: \"'queue round_robin \\<Rightarrow> 't list round_robin\"\nwhere \"round_robin_\\<alpha> = apfst queue_\\<alpha>\""], ["", "definition round_robin_start :: \"nat \\<Rightarrow> 't \\<Rightarrow> 'queue round_robin\"\nwhere \"round_robin_start n0 t = (queue_enqueue t (queue_empty ()), n0)\""], ["", "lemma round_robin_invar_correct:\n  \"round_robin_invar \\<sigma> T \\<Longrightarrow> Round_Robin.round_robin_invar (round_robin_\\<alpha> \\<sigma>) T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.round_robin_invar \\<sigma> T \\<Longrightarrow>\n    Round_Robin.round_robin_invar (round_robin_\\<alpha> \\<sigma>) T", "by(cases \\<sigma>)(simp add: round_robin_\\<alpha>_def)"], ["", "end"], ["", "locale round_robin =\n  round_robin_base\n    final r convert_RA \"output\"\n    thr_\\<alpha> thr_invar thr_lookup thr_update\n    ws_\\<alpha> ws_invar ws_lookup ws_update ws_delete ws_iterate ws_sel\n    is_\\<alpha> is_invar is_memb is_ins is_delete\n    queue_\\<alpha> queue_invar queue_empty queue_isEmpty queue_enqueue queue_dequeue queue_push\n  +\n  scheduler_aux\n    final r convert_RA\n    thr_\\<alpha> thr_invar thr_lookup thr_update\n    ws_\\<alpha> ws_invar ws_lookup\n    is_\\<alpha> is_invar is_memb is_ins is_delete\n  +\n  ws: map_update ws_\\<alpha> ws_invar ws_update +\n  ws: map_delete ws_\\<alpha> ws_invar ws_delete +\n  ws: map_iteratei ws_\\<alpha> ws_invar ws_iterate +\n  ws: map_sel' ws_\\<alpha> ws_invar ws_sel +\n  queue: list queue_\\<alpha> queue_invar +\n  queue: list_empty queue_\\<alpha> queue_invar queue_empty +\n  queue: list_isEmpty queue_\\<alpha> queue_invar queue_isEmpty +\n  queue: list_enqueue queue_\\<alpha> queue_invar queue_enqueue +\n  queue: list_dequeue queue_\\<alpha> queue_invar queue_dequeue +\n  queue: list_push queue_\\<alpha> queue_invar queue_push\n  for final :: \"'x \\<Rightarrow> bool\"\n  and r :: \"'t \\<Rightarrow> ('x \\<times> 'm) \\<Rightarrow> (('l,'t,'x,'m,'w,'o) thread_action \\<times> 'x \\<times> 'm) Predicate.pred\"\n  and convert_RA :: \"'l released_locks \\<Rightarrow> 'o list\"\n  and \"output\" :: \"'queue round_robin \\<Rightarrow> 't \\<Rightarrow> ('l,'t,'x,'m,'w,'o) thread_action \\<Rightarrow> 'q option\"\n  and thr_\\<alpha> :: \"'m_t \\<Rightarrow> ('l,'t,'x) thread_info\"\n  and thr_invar :: \"'m_t \\<Rightarrow> bool\"\n  and thr_lookup :: \"'t \\<Rightarrow> 'm_t \\<rightharpoonup> ('x \\<times> 'l released_locks)\"\n  and thr_update :: \"'t \\<Rightarrow> 'x \\<times> 'l released_locks \\<Rightarrow> 'm_t \\<Rightarrow> 'm_t\"\n  and ws_\\<alpha> :: \"'m_w \\<Rightarrow> ('w,'t) wait_sets\"\n  and ws_invar :: \"'m_w \\<Rightarrow> bool\"\n  and ws_lookup :: \"'t \\<Rightarrow> 'm_w \\<rightharpoonup> 'w wait_set_status\"\n  and ws_update :: \"'t \\<Rightarrow> 'w wait_set_status \\<Rightarrow> 'm_w \\<Rightarrow> 'm_w\"\n  and ws_delete :: \"'t \\<Rightarrow> 'm_w \\<Rightarrow> 'm_w\"\n  and ws_iterate :: \"'m_w \\<Rightarrow> ('t \\<times> 'w wait_set_status, 'm_w) set_iterator\"\n  and ws_sel :: \"'m_w \\<Rightarrow> ('t \\<times> 'w wait_set_status \\<Rightarrow> bool) \\<rightharpoonup> ('t \\<times> 'w wait_set_status)\"\n  and is_\\<alpha> :: \"'s_i \\<Rightarrow> 't interrupts\"\n  and is_invar :: \"'s_i \\<Rightarrow> bool\"\n  and is_memb :: \"'t \\<Rightarrow> 's_i \\<Rightarrow> bool\"\n  and is_ins :: \"'t \\<Rightarrow> 's_i \\<Rightarrow> 's_i\"\n  and is_delete :: \"'t \\<Rightarrow> 's_i \\<Rightarrow> 's_i\"\n  and queue_\\<alpha> :: \"'queue \\<Rightarrow> 't list\"\n  and queue_invar :: \"'queue \\<Rightarrow> bool\"\n  and queue_empty :: \"unit \\<Rightarrow> 'queue\"\n  and queue_isEmpty :: \"'queue \\<Rightarrow> bool\"\n  and queue_enqueue :: \"'t \\<Rightarrow> 'queue \\<Rightarrow> 'queue\"\n  and queue_dequeue :: \"'queue \\<Rightarrow> 't \\<times> 'queue\"\n  and queue_push :: \"'t \\<Rightarrow> 'queue \\<Rightarrow> 'queue\"\nbegin"], ["", "lemma queue_rotate1_correct:\n  assumes \"queue_invar queue\" \"queue_\\<alpha> queue \\<noteq> []\"\n  shows \"queue_\\<alpha> (queue_rotate1 queue) = rotate1 (queue_\\<alpha> queue)\"\n  and \"queue_invar (queue_rotate1 queue)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_\\<alpha> (queue_rotate1 queue) =\n    rotate1 (queue_\\<alpha> queue) &&&\n    queue_invar (queue_rotate1 queue)", "using assms"], ["proof (prove)\nusing this:\n  queue_invar queue\n  queue_\\<alpha> queue \\<noteq> []\n\ngoal (1 subgoal):\n 1. queue_\\<alpha> (queue_rotate1 queue) =\n    rotate1 (queue_\\<alpha> queue) &&&\n    queue_invar (queue_rotate1 queue)", "apply(auto simp add: queue_rotate1_def split_beta queue.dequeue_correct queue.enqueue_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>queue_invar queue; queue_\\<alpha> queue \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> tl (queue_\\<alpha> queue) @\n                      [hd (queue_\\<alpha> queue)] =\n                      rotate1 (queue_\\<alpha> queue)", "by(cases \"queue_\\<alpha> queue\") simp_all"], ["", "lemma enqueue_thread_correct:\n  assumes \"queue_invar queue\"\n  shows \"queue_\\<alpha> (enqueue_new_thread queue nta) = Round_Robin.enqueue_new_thread (queue_\\<alpha> queue) nta\"\n  and \"queue_invar (enqueue_new_thread queue nta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_\\<alpha> (local.enqueue_new_thread queue nta) =\n    Round_Robin.enqueue_new_thread (queue_\\<alpha> queue) nta &&&\n    queue_invar (local.enqueue_new_thread queue nta)", "using assms"], ["proof (prove)\nusing this:\n  queue_invar queue\n\ngoal (1 subgoal):\n 1. queue_\\<alpha> (local.enqueue_new_thread queue nta) =\n    Round_Robin.enqueue_new_thread (queue_\\<alpha> queue) nta &&&\n    queue_invar (local.enqueue_new_thread queue nta)", "by(case_tac [!] nta)(simp_all add: queue.enqueue_correct)"], ["", "lemma enqueue_threads_correct:\n  assumes \"queue_invar queue\"\n  shows \"queue_\\<alpha> (enqueue_new_threads queue ntas) = Round_Robin.enqueue_new_threads (queue_\\<alpha> queue) ntas\"\n  and \"queue_invar (enqueue_new_threads queue ntas)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. queue_\\<alpha> (local.enqueue_new_threads queue ntas) =\n    Round_Robin.enqueue_new_threads (queue_\\<alpha> queue) ntas &&&\n    queue_invar (local.enqueue_new_threads queue ntas)", "using assms"], ["proof (prove)\nusing this:\n  queue_invar queue\n\ngoal (1 subgoal):\n 1. queue_\\<alpha> (local.enqueue_new_threads queue ntas) =\n    Round_Robin.enqueue_new_threads (queue_\\<alpha> queue) ntas &&&\n    queue_invar (local.enqueue_new_threads queue ntas)", "apply(induct ntas arbitrary: queue)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>queue.\n       queue_invar queue \\<Longrightarrow>\n       queue_\\<alpha> (local.enqueue_new_threads queue []) =\n       Round_Robin.enqueue_new_threads (queue_\\<alpha> queue) []\n 2. \\<And>queue.\n       queue_invar queue \\<Longrightarrow>\n       queue_invar (local.enqueue_new_threads queue [])\n 3. \\<And>a ntas queue.\n       \\<lbrakk>\\<And>queue.\n                   queue_invar queue \\<Longrightarrow>\n                   queue_\\<alpha> (local.enqueue_new_threads queue ntas) =\n                   Round_Robin.enqueue_new_threads (queue_\\<alpha> queue)\n                    ntas;\n        \\<And>queue.\n           queue_invar queue \\<Longrightarrow>\n           queue_invar (local.enqueue_new_threads queue ntas);\n        queue_invar queue\\<rbrakk>\n       \\<Longrightarrow> queue_\\<alpha>\n                          (local.enqueue_new_threads queue (a # ntas)) =\n                         Round_Robin.enqueue_new_threads\n                          (queue_\\<alpha> queue) (a # ntas)\n 4. \\<And>a ntas queue.\n       \\<lbrakk>\\<And>queue.\n                   queue_invar queue \\<Longrightarrow>\n                   queue_\\<alpha> (local.enqueue_new_threads queue ntas) =\n                   Round_Robin.enqueue_new_threads (queue_\\<alpha> queue)\n                    ntas;\n        \\<And>queue.\n           queue_invar queue \\<Longrightarrow>\n           queue_invar (local.enqueue_new_threads queue ntas);\n        queue_invar queue\\<rbrakk>\n       \\<Longrightarrow> queue_invar\n                          (local.enqueue_new_threads queue (a # ntas))", "apply(simp_all add: enqueue_new_threads_def Round_Robin.enqueue_new_threads_def enqueue_thread_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma round_robin_update_thread_correct:\n  assumes \"round_robin_invar \\<sigma> T\" \"t' \\<in> T\"\n  shows \"round_robin_\\<alpha> (round_robin_update_state n0 \\<sigma> t ta) = Round_Robin.round_robin_update_state n0 (round_robin_\\<alpha> \\<sigma>) t ta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. round_robin_\\<alpha> (local.round_robin_update_state n0 \\<sigma> t ta) =\n    Round_Robin.round_robin_update_state n0 (round_robin_\\<alpha> \\<sigma>)\n     t ta", "using assms"], ["proof (prove)\nusing this:\n  local.round_robin_invar \\<sigma> T\n  t' \\<in> T\n\ngoal (1 subgoal):\n 1. round_robin_\\<alpha> (local.round_robin_update_state n0 \\<sigma> t ta) =\n    Round_Robin.round_robin_update_state n0 (round_robin_\\<alpha> \\<sigma>)\n     t ta", "apply(cases \\<sigma>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>local.round_robin_invar \\<sigma> T; t' \\<in> T;\n        \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> round_robin_\\<alpha>\n                          (local.round_robin_update_state n0 \\<sigma> t\n                            ta) =\n                         Round_Robin.round_robin_update_state n0\n                          (round_robin_\\<alpha> \\<sigma>) t ta", "apply(auto simp add: round_robin_\\<alpha>_def queue_rotate1_correct enqueue_threads_correct del: conjI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>t' \\<in> set (queue_\\<alpha> a); \\<sigma> = (a, b);\n        queue_invar a; distinct (queue_\\<alpha> a);\n        T = set (queue_\\<alpha> a)\\<rbrakk>\n       \\<Longrightarrow> (b = 0 \\<longrightarrow>\n                          queue_\\<alpha>\n                           (queue_rotate1\n                             (local.enqueue_new_threads a\n                               \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)) =\n                          rotate1\n                           (Round_Robin.enqueue_new_threads\n                             (queue_\\<alpha> a)\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)) \\<and>\n                         (Yield\n                          \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<longrightarrow>\n                          queue_\\<alpha>\n                           (queue_rotate1\n                             (local.enqueue_new_threads a\n                               \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)) =\n                          rotate1\n                           (Round_Robin.enqueue_new_threads\n                             (queue_\\<alpha> a)\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>))", "apply(subst (1 2) queue_rotate1_correct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>t' \\<in> set (queue_\\<alpha> a); \\<sigma> = (a, b);\n        queue_invar a; distinct (queue_\\<alpha> a);\n        T = set (queue_\\<alpha> a)\\<rbrakk>\n       \\<Longrightarrow> queue_invar\n                          (local.enqueue_new_threads a\n                            \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)\n 2. \\<And>a b.\n       \\<lbrakk>t' \\<in> set (queue_\\<alpha> a); \\<sigma> = (a, b);\n        queue_invar a; distinct (queue_\\<alpha> a);\n        T = set (queue_\\<alpha> a)\\<rbrakk>\n       \\<Longrightarrow> queue_\\<alpha>\n                          (local.enqueue_new_threads a\n                            \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) \\<noteq>\n                         []\n 3. \\<And>a b.\n       \\<lbrakk>t' \\<in> set (queue_\\<alpha> a); \\<sigma> = (a, b);\n        queue_invar a; distinct (queue_\\<alpha> a);\n        T = set (queue_\\<alpha> a)\\<rbrakk>\n       \\<Longrightarrow> (b = 0 \\<longrightarrow>\n                          rotate1\n                           (queue_\\<alpha>\n                             (local.enqueue_new_threads a\n                               \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)) =\n                          rotate1\n                           (Round_Robin.enqueue_new_threads\n                             (queue_\\<alpha> a)\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)) \\<and>\n                         (Yield\n                          \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<longrightarrow>\n                          rotate1\n                           (queue_\\<alpha>\n                             (local.enqueue_new_threads a\n                               \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)) =\n                          rotate1\n                           (Round_Robin.enqueue_new_threads\n                             (queue_\\<alpha> a)\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>))", "apply(auto simp add: enqueue_threads_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma round_robin_step_correct:\n  assumes det: \"\\<alpha>.deterministic I\"\n  and invar: \"round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\" \"state_invar s\" \"state_\\<alpha> s \\<in> I\"\n  shows\n  \"map_option (apsnd (apsnd round_robin_\\<alpha>)) (round_robin_step n0 \\<sigma> s t) = \n   \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>) (state_\\<alpha> s) t\" (is ?thesis1)\n  and \"case_option True (\\<lambda>(t, taxm, \\<sigma>). round_robin_invar \\<sigma> (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s)) | Some (ta, x', m') \\<Rightarrow> dom (thr_\\<alpha> (thr s)) \\<union> {t. \\<exists>x m. NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) (round_robin_step n0 \\<sigma> s t)\"\n  (is ?thesis2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_step n0 \\<sigma> s t) =\n    \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) t &&&\n    case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        local.round_robin_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_step n0 \\<sigma> s t) =\n    \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) t\n 2. case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        local.round_robin_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "have \"?thesis1 \\<and> ?thesis2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_step n0 \\<sigma> s t) =\n    \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) t \\<and>\n    (case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "proof(cases \"dom (thr_\\<alpha> (thr s)) = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. dom (thr_\\<alpha> (thr s)) = {} \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_step n0 \\<sigma> s t) =\n    \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) t \\<and>\n    (case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))\n 2. dom (thr_\\<alpha> (thr s)) \\<noteq> {} \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_step n0 \\<sigma> s t) =\n    \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) t \\<and>\n    (case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "case True"], ["proof (state)\nthis:\n  dom (thr_\\<alpha> (thr s)) = {}\n\ngoal (2 subgoals):\n 1. dom (thr_\\<alpha> (thr s)) = {} \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_step n0 \\<sigma> s t) =\n    \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) t \\<and>\n    (case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))\n 2. dom (thr_\\<alpha> (thr s)) \\<noteq> {} \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_step n0 \\<sigma> s t) =\n    \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) t \\<and>\n    (case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "thus ?thesis"], ["proof (prove)\nusing this:\n  dom (thr_\\<alpha> (thr s)) = {}\n\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_step n0 \\<sigma> s t) =\n    \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) t \\<and>\n    (case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "using invar"], ["proof (prove)\nusing this:\n  dom (thr_\\<alpha> (thr s)) = {}\n  local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_step n0 \\<sigma> s t) =\n    \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) t \\<and>\n    (case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "apply(cases \\<sigma>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>dom (thr_\\<alpha> (thr s)) = {};\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                          (round_robin_step n0 \\<sigma> s t) =\n                         \\<alpha>.round_robin_step n0\n                          (round_robin_\\<alpha> \\<sigma>) (state_\\<alpha> s)\n                          t \\<and>\n                         (case round_robin_step n0 \\<sigma> s t of\n                          None \\<Rightarrow> True\n                          | \\<lfloor>(t, taxm,\n\\<sigma>)\\<rfloor> \\<Rightarrow>\n                              local.round_robin_invar \\<sigma>\n                               (case taxm of\n                                None \\<Rightarrow>\n                                  dom (thr_\\<alpha> (thr s))\n                                | \\<lfloor>(ta, x',\n      m')\\<rfloor> \\<Rightarrow>\n                                    dom (thr_\\<alpha> (thr s)) \\<union>\n                                    {t. \\<exists>x m.\n     NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "apply(auto dest: step_thread_Some_NoneD[OF det] step_thread_Some_SomeD[OF det])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>thr_\\<alpha> (thr s) = Map.empty; state_invar s;\n        state_\\<alpha> s \\<in> I; \\<sigma> = (a, b); queue_invar a;\n        queue_\\<alpha> a = [];\n        round_robin_step n0 (a, b) s t = None\\<rbrakk>\n       \\<Longrightarrow> None =\n                         \\<alpha>.round_robin_step n0\n                          (round_robin_\\<alpha> (a, b)) (state_\\<alpha> s) t", "apply(fastforce simp add: \\<alpha>.step_thread_eq_None_conv elim: \\<alpha>.active_threads.cases intro: sym)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (round_robin_step n0 \\<sigma> s t) =\n  \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n   (state_\\<alpha> s) t \\<and>\n  (case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n   | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n       local.round_robin_invar \\<sigma>\n        (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n         | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n             dom (thr_\\<alpha> (thr s)) \\<union>\n             {t. \\<exists>x m.\n                    NewThread t x m\n                    \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))\n\ngoal (1 subgoal):\n 1. dom (thr_\\<alpha> (thr s)) \\<noteq> {} \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_step n0 \\<sigma> s t) =\n    \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) t \\<and>\n    (case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. dom (thr_\\<alpha> (thr s)) \\<noteq> {} \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_step n0 \\<sigma> s t) =\n    \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) t \\<and>\n    (case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "case False"], ["proof (state)\nthis:\n  dom (thr_\\<alpha> (thr s)) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. dom (thr_\\<alpha> (thr s)) \\<noteq> {} \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_step n0 \\<sigma> s t) =\n    \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) t \\<and>\n    (case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "then"], ["proof (chain)\npicking this:\n  dom (thr_\\<alpha> (thr s)) \\<noteq> {}", "obtain t' where t': \"t' \\<in> dom (thr_\\<alpha> (thr s))\""], ["proof (prove)\nusing this:\n  dom (thr_\\<alpha> (thr s)) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        t' \\<in> dom (thr_\\<alpha> (thr s)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t' \\<in> dom (thr_\\<alpha> (thr s))\n\ngoal (1 subgoal):\n 1. dom (thr_\\<alpha> (thr s)) \\<noteq> {} \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_step n0 \\<sigma> s t) =\n    \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) t \\<and>\n    (case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "hence ?thesis1"], ["proof (prove)\nusing this:\n  t' \\<in> dom (thr_\\<alpha> (thr s))\n\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_step n0 \\<sigma> s t) =\n    \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) t", "using step_thread_correct(1)[of I round_robin_invar \\<sigma> s round_robin_\\<alpha> \"round_robin_update_state n0 \\<sigma> t\" t, OF det invar]"], ["proof (prove)\nusing this:\n  t' \\<in> dom (thr_\\<alpha> (thr s))\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (round_robin_step n0 \\<sigma> s t) =\n  \\<alpha>.step_thread\n   ((round_robin_\\<alpha> \\<circ>\\<circ>\\<circ>\n     local.round_robin_update_state n0)\n     \\<sigma> t)\n   (state_\\<alpha> s) t\n\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_step n0 \\<sigma> s t) =\n    \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) t", "unfolding o_def"], ["proof (prove)\nusing this:\n  t' \\<in> dom (thr_\\<alpha> (thr s))\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (round_robin_step n0 \\<sigma> s t) =\n  \\<alpha>.step_thread\n   (\\<lambda>x.\n       round_robin_\\<alpha>\n        (local.round_robin_update_state n0 \\<sigma> t x))\n   (state_\\<alpha> s) t\n\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_step n0 \\<sigma> s t) =\n    \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) t", "using invar"], ["proof (prove)\nusing this:\n  t' \\<in> dom (thr_\\<alpha> (thr s))\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (round_robin_step n0 \\<sigma> s t) =\n  \\<alpha>.step_thread\n   (\\<lambda>x.\n       round_robin_\\<alpha>\n        (local.round_robin_update_state n0 \\<sigma> t x))\n   (state_\\<alpha> s) t\n  local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_step n0 \\<sigma> s t) =\n    \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) t", "by(subst (asm) round_robin_update_thread_correct) auto"], ["proof (state)\nthis:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (round_robin_step n0 \\<sigma> s t) =\n  \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n   (state_\\<alpha> s) t\n\ngoal (1 subgoal):\n 1. dom (thr_\\<alpha> (thr s)) \\<noteq> {} \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_step n0 \\<sigma> s t) =\n    \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) t \\<and>\n    (case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "moreover"], ["proof (state)\nthis:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (round_robin_step n0 \\<sigma> s t) =\n  \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n   (state_\\<alpha> s) t\n\ngoal (1 subgoal):\n 1. dom (thr_\\<alpha> (thr s)) \\<noteq> {} \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_step n0 \\<sigma> s t) =\n    \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) t \\<and>\n    (case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "{"], ["proof (state)\nthis:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (round_robin_step n0 \\<sigma> s t) =\n  \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n   (state_\\<alpha> s) t\n\ngoal (1 subgoal):\n 1. dom (thr_\\<alpha> (thr s)) \\<noteq> {} \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_step n0 \\<sigma> s t) =\n    \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) t \\<and>\n    (case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "fix ta :: \"('l, 't, 'x, 'm, 'w, 'o) thread_action\""], ["proof (state)\ngoal (1 subgoal):\n 1. dom (thr_\\<alpha> (thr s)) \\<noteq> {} \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_step n0 \\<sigma> s t) =\n    \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) t \\<and>\n    (case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "assume \"FWThread.thread_oks (thr_\\<alpha> (thr s)) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\""], ["proof (state)\nthis:\n  FWThread.thread_oks (thr_\\<alpha> (thr s))\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n\ngoal (1 subgoal):\n 1. dom (thr_\\<alpha> (thr s)) \\<noteq> {} \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_step n0 \\<sigma> s t) =\n    \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) t \\<and>\n    (case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "moreover"], ["proof (state)\nthis:\n  FWThread.thread_oks (thr_\\<alpha> (thr s))\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n\ngoal (1 subgoal):\n 1. dom (thr_\\<alpha> (thr s)) \\<noteq> {} \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_step n0 \\<sigma> s t) =\n    \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) t \\<and>\n    (case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "from t' invar"], ["proof (chain)\npicking this:\n  t' \\<in> dom (thr_\\<alpha> (thr s))\n  local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I", "have \"queue_\\<alpha> (fst \\<sigma>) \\<noteq> []\""], ["proof (prove)\nusing this:\n  t' \\<in> dom (thr_\\<alpha> (thr s))\n  local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n\ngoal (1 subgoal):\n 1. queue_\\<alpha> (fst \\<sigma>) \\<noteq> []", "by(cases \\<sigma>) auto"], ["proof (state)\nthis:\n  queue_\\<alpha> (fst \\<sigma>) \\<noteq> []\n\ngoal (1 subgoal):\n 1. dom (thr_\\<alpha> (thr s)) \\<noteq> {} \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_step n0 \\<sigma> s t) =\n    \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) t \\<and>\n    (case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "ultimately"], ["proof (chain)\npicking this:\n  FWThread.thread_oks (thr_\\<alpha> (thr s))\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n  queue_\\<alpha> (fst \\<sigma>) \\<noteq> []", "have \"round_robin_invar (round_robin_update_state n0 \\<sigma> t ta) (dom (thr_\\<alpha> (thr s)) \\<union> {t. \\<exists>x m. NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\""], ["proof (prove)\nusing this:\n  FWThread.thread_oks (thr_\\<alpha> (thr s))\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n  queue_\\<alpha> (fst \\<sigma>) \\<noteq> []\n\ngoal (1 subgoal):\n 1. local.round_robin_invar\n     (local.round_robin_update_state n0 \\<sigma> t ta)\n     (dom (thr_\\<alpha> (thr s)) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "using invar t'"], ["proof (prove)\nusing this:\n  FWThread.thread_oks (thr_\\<alpha> (thr s))\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n  queue_\\<alpha> (fst \\<sigma>) \\<noteq> []\n  local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n  t' \\<in> dom (thr_\\<alpha> (thr s))\n\ngoal (1 subgoal):\n 1. local.round_robin_invar\n     (local.round_robin_update_state n0 \\<sigma> t ta)\n     (dom (thr_\\<alpha> (thr s)) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "by(cases \\<sigma>)(auto simp add: queue_rotate1_correct enqueue_threads_correct set_enqueue_new_threads iff del: domIff intro: distinct_enqueue_new_threads)"], ["proof (state)\nthis:\n  local.round_robin_invar (local.round_robin_update_state n0 \\<sigma> t ta)\n   (dom (thr_\\<alpha> (thr s)) \\<union>\n    {t. \\<exists>x m.\n           NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal (1 subgoal):\n 1. dom (thr_\\<alpha> (thr s)) \\<noteq> {} \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_step n0 \\<sigma> s t) =\n    \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) t \\<and>\n    (case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "}"], ["proof (state)\nthis:\n  FWThread.thread_oks (thr_\\<alpha> (thr s))\n   \\<lbrace>?ta5\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n  local.round_robin_invar\n   (local.round_robin_update_state n0 \\<sigma> t ?ta5)\n   (dom (thr_\\<alpha> (thr s)) \\<union>\n    {t. \\<exists>x m.\n           NewThread t x m\n           \\<in> set \\<lbrace>?ta5\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal (1 subgoal):\n 1. dom (thr_\\<alpha> (thr s)) \\<noteq> {} \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_step n0 \\<sigma> s t) =\n    \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) t \\<and>\n    (case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "from step_thread_correct(2)[OF det, of round_robin_invar \\<sigma> s \"round_robin_update_state n0 \\<sigma> t\" t, OF invar this]"], ["proof (chain)\npicking this:\n  (\\<And>ta.\n      FWThread.thread_oks (thr_\\<alpha> (thr s))\n       \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n      FWThread.thread_oks (thr_\\<alpha> (thr s))\n       \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) \\<Longrightarrow>\n  case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      local.round_robin_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "have ?thesis2"], ["proof (prove)\nusing this:\n  (\\<And>ta.\n      FWThread.thread_oks (thr_\\<alpha> (thr s))\n       \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n      FWThread.thread_oks (thr_\\<alpha> (thr s))\n       \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) \\<Longrightarrow>\n  case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      local.round_robin_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal (1 subgoal):\n 1. case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        local.round_robin_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "using t' invar"], ["proof (prove)\nusing this:\n  (\\<And>ta.\n      FWThread.thread_oks (thr_\\<alpha> (thr s))\n       \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n      FWThread.thread_oks (thr_\\<alpha> (thr s))\n       \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) \\<Longrightarrow>\n  case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      local.round_robin_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n  t' \\<in> dom (thr_\\<alpha> (thr s))\n  local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n\ngoal (1 subgoal):\n 1. case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        local.round_robin_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "by simp"], ["proof (state)\nthis:\n  case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      local.round_robin_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal (1 subgoal):\n 1. dom (thr_\\<alpha> (thr s)) \\<noteq> {} \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_step n0 \\<sigma> s t) =\n    \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) t \\<and>\n    (case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "ultimately"], ["proof (chain)\npicking this:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (round_robin_step n0 \\<sigma> s t) =\n  \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n   (state_\\<alpha> s) t\n  case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      local.round_robin_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "show ?thesis"], ["proof (prove)\nusing this:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (round_robin_step n0 \\<sigma> s t) =\n  \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n   (state_\\<alpha> s) t\n  case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      local.round_robin_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_step n0 \\<sigma> s t) =\n    \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) t \\<and>\n    (case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "by blast"], ["proof (state)\nthis:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (round_robin_step n0 \\<sigma> s t) =\n  \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n   (state_\\<alpha> s) t \\<and>\n  (case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n   | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n       local.round_robin_invar \\<sigma>\n        (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n         | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n             dom (thr_\\<alpha> (thr s)) \\<union>\n             {t. \\<exists>x m.\n                    NewThread t x m\n                    \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (round_robin_step n0 \\<sigma> s t) =\n  \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n   (state_\\<alpha> s) t \\<and>\n  (case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n   | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n       local.round_robin_invar \\<sigma>\n        (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n         | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n             dom (thr_\\<alpha> (thr s)) \\<union>\n             {t. \\<exists>x m.\n                    NewThread t x m\n                    \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))\n\ngoal (2 subgoals):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_step n0 \\<sigma> s t) =\n    \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) t\n 2. case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        local.round_robin_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "thus ?thesis1 ?thesis2"], ["proof (prove)\nusing this:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (round_robin_step n0 \\<sigma> s t) =\n  \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n   (state_\\<alpha> s) t \\<and>\n  (case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n   | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n       local.round_robin_invar \\<sigma>\n        (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n         | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n             dom (thr_\\<alpha> (thr s)) \\<union>\n             {t. \\<exists>x m.\n                    NewThread t x m\n                    \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))\n\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_step n0 \\<sigma> s t) =\n    \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) t &&&\n    case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        local.round_robin_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "by blast+"], ["proof (state)\nthis:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (round_robin_step n0 \\<sigma> s t) =\n  \\<alpha>.round_robin_step n0 (round_robin_\\<alpha> \\<sigma>)\n   (state_\\<alpha> s) t\n  case round_robin_step n0 \\<sigma> s t of None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      local.round_robin_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma round_robin_reschedule_correct:\n  assumes det: \"\\<alpha>.deterministic I\"\n  and invar: \"round_robin_invar (queue, n) (dom (thr_\\<alpha> (thr s)))\" \"state_invar s\" \"state_\\<alpha> s \\<in> I\"\n  and t0: \"t0 \\<in> set (queue_\\<alpha> queue)\"\n  shows \"map_option (apsnd (apsnd round_robin_\\<alpha>)) (round_robin_reschedule t0 queue n0 s) =\n     \\<alpha>.round_robin_reschedule t0 (queue_\\<alpha> queue) n0 (state_\\<alpha> s)\"\n  and \"case_option True (\\<lambda>(t, taxm, \\<sigma>). round_robin_invar \\<sigma> (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s)) | Some (ta, x', m') \\<Rightarrow> dom (thr_\\<alpha> (thr s)) \\<union> {t. \\<exists>x m. NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) (round_robin_reschedule t0 queue n0 s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_reschedule t0 queue n0 s) =\n    \\<alpha>.round_robin_reschedule t0 (queue_\\<alpha> queue) n0\n     (state_\\<alpha> s) &&&\n    case round_robin_reschedule t0 queue n0 s of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        local.round_robin_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "using t0 invar"], ["proof (prove)\nusing this:\n  t0 \\<in> set (queue_\\<alpha> queue)\n  local.round_robin_invar (queue, n) (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_reschedule t0 queue n0 s) =\n    \\<alpha>.round_robin_reschedule t0 (queue_\\<alpha> queue) n0\n     (state_\\<alpha> s) &&&\n    case round_robin_reschedule t0 queue n0 s of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        local.round_robin_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "proof(induct \"queue_\\<alpha> queue\" arbitrary: queue n rule: round_robin_reschedule_induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>queue queuea n.\n       \\<lbrakk>t0 # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                          (round_robin_reschedule t0 queuea n0 s) =\n                         \\<alpha>.round_robin_reschedule t0\n                          (queue_\\<alpha> queuea) n0 (state_\\<alpha> s)\n 2. \\<And>queue queuea n.\n       \\<lbrakk>t0 # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                         None \\<Rightarrow> True\n                         | \\<lfloor>(t, taxm,\n                                     \\<sigma>)\\<rfloor> \\<Rightarrow>\n                             local.round_robin_invar \\<sigma>\n                              (case taxm of\n                               None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n                               | \\<lfloor>(ta, x',\n     m')\\<rfloor> \\<Rightarrow>\n                                   dom (thr_\\<alpha> (thr s)) \\<union>\n                                   {t. \\<exists>x m.\n    NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n 3. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                          (round_robin_reschedule t0 queuea n0 s) =\n                         \\<alpha>.round_robin_reschedule t0\n                          (queue_\\<alpha> queuea) n0 (state_\\<alpha> s)\n 4. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                         None \\<Rightarrow> True\n                         | \\<lfloor>(t, taxm,\n                                     \\<sigma>)\\<rfloor> \\<Rightarrow>\n                             local.round_robin_invar \\<sigma>\n                              (case taxm of\n                               None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n                               | \\<lfloor>(ta, x',\n     m')\\<rfloor> \\<Rightarrow>\n                                   dom (thr_\\<alpha> (thr s)) \\<union>\n                                   {t. \\<exists>x m.\n    NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "case head"], ["proof (state)\nthis:\n  t0 # queue_ = queue_\\<alpha> queue\n\ngoal (4 subgoals):\n 1. \\<And>queue queuea n.\n       \\<lbrakk>t0 # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                          (round_robin_reschedule t0 queuea n0 s) =\n                         \\<alpha>.round_robin_reschedule t0\n                          (queue_\\<alpha> queuea) n0 (state_\\<alpha> s)\n 2. \\<And>queue queuea n.\n       \\<lbrakk>t0 # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                         None \\<Rightarrow> True\n                         | \\<lfloor>(t, taxm,\n                                     \\<sigma>)\\<rfloor> \\<Rightarrow>\n                             local.round_robin_invar \\<sigma>\n                              (case taxm of\n                               None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n                               | \\<lfloor>(ta, x',\n     m')\\<rfloor> \\<Rightarrow>\n                                   dom (thr_\\<alpha> (thr s)) \\<union>\n                                   {t. \\<exists>x m.\n    NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n 3. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                          (round_robin_reschedule t0 queuea n0 s) =\n                         \\<alpha>.round_robin_reschedule t0\n                          (queue_\\<alpha> queuea) n0 (state_\\<alpha> s)\n 4. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                         None \\<Rightarrow> True\n                         | \\<lfloor>(t, taxm,\n                                     \\<sigma>)\\<rfloor> \\<Rightarrow>\n                             local.round_robin_invar \\<sigma>\n                              (case taxm of\n                               None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n                               | \\<lfloor>(ta, x',\n     m')\\<rfloor> \\<Rightarrow>\n                                   dom (thr_\\<alpha> (thr s)) \\<union>\n                                   {t. \\<exists>x m.\n    NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "{"], ["proof (state)\nthis:\n  t0 # queue_ = queue_\\<alpha> queue\n\ngoal (4 subgoals):\n 1. \\<And>queue queuea n.\n       \\<lbrakk>t0 # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                          (round_robin_reschedule t0 queuea n0 s) =\n                         \\<alpha>.round_robin_reschedule t0\n                          (queue_\\<alpha> queuea) n0 (state_\\<alpha> s)\n 2. \\<And>queue queuea n.\n       \\<lbrakk>t0 # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                         None \\<Rightarrow> True\n                         | \\<lfloor>(t, taxm,\n                                     \\<sigma>)\\<rfloor> \\<Rightarrow>\n                             local.round_robin_invar \\<sigma>\n                              (case taxm of\n                               None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n                               | \\<lfloor>(ta, x',\n     m')\\<rfloor> \\<Rightarrow>\n                                   dom (thr_\\<alpha> (thr s)) \\<union>\n                                   {t. \\<exists>x m.\n    NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n 3. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                          (round_robin_reschedule t0 queuea n0 s) =\n                         \\<alpha>.round_robin_reschedule t0\n                          (queue_\\<alpha> queuea) n0 (state_\\<alpha> s)\n 4. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                         None \\<Rightarrow> True\n                         | \\<lfloor>(t, taxm,\n                                     \\<sigma>)\\<rfloor> \\<Rightarrow>\n                             local.round_robin_invar \\<sigma>\n                              (case taxm of\n                               None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n                               | \\<lfloor>(ta, x',\n     m')\\<rfloor> \\<Rightarrow>\n                                   dom (thr_\\<alpha> (thr s)) \\<union>\n                                   {t. \\<exists>x m.\n    NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "case 1"], ["proof (state)\nthis:\n  local.round_robin_invar (queue, n) (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n\ngoal (4 subgoals):\n 1. \\<And>queue queuea n.\n       \\<lbrakk>t0 # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                          (round_robin_reschedule t0 queuea n0 s) =\n                         \\<alpha>.round_robin_reschedule t0\n                          (queue_\\<alpha> queuea) n0 (state_\\<alpha> s)\n 2. \\<And>queue queuea n.\n       \\<lbrakk>t0 # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                         None \\<Rightarrow> True\n                         | \\<lfloor>(t, taxm,\n                                     \\<sigma>)\\<rfloor> \\<Rightarrow>\n                             local.round_robin_invar \\<sigma>\n                              (case taxm of\n                               None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n                               | \\<lfloor>(ta, x',\n     m')\\<rfloor> \\<Rightarrow>\n                                   dom (thr_\\<alpha> (thr s)) \\<union>\n                                   {t. \\<exists>x m.\n    NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n 3. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                          (round_robin_reschedule t0 queuea n0 s) =\n                         \\<alpha>.round_robin_reschedule t0\n                          (queue_\\<alpha> queuea) n0 (state_\\<alpha> s)\n 4. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                         None \\<Rightarrow> True\n                         | \\<lfloor>(t, taxm,\n                                     \\<sigma>)\\<rfloor> \\<Rightarrow>\n                             local.round_robin_invar \\<sigma>\n                              (case taxm of\n                               None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n                               | \\<lfloor>(ta, x',\n     m')\\<rfloor> \\<Rightarrow>\n                                   dom (thr_\\<alpha> (thr s)) \\<union>\n                                   {t. \\<exists>x m.\n    NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "thus ?case"], ["proof (prove)\nusing this:\n  local.round_robin_invar (queue, n) (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_reschedule t0 queue n0 s) =\n    \\<alpha>.round_robin_reschedule t0 (queue_\\<alpha> queue) n0\n     (state_\\<alpha> s)", "using head[symmetric]"], ["proof (prove)\nusing this:\n  local.round_robin_invar (queue, n) (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n  queue_\\<alpha> queue = t0 # queue_\n\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_reschedule t0 queue n0 s) =\n    \\<alpha>.round_robin_reschedule t0 (queue_\\<alpha> queue) n0\n     (state_\\<alpha> s)", "by(subst round_robin_reschedule.simps)(subst \\<alpha>.round_robin_reschedule.simps, clarsimp simp add: split_beta queue.dequeue_correct)"], ["proof (state)\nthis:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (round_robin_reschedule t0 queue n0 s) =\n  \\<alpha>.round_robin_reschedule t0 (queue_\\<alpha> queue) n0\n   (state_\\<alpha> s)\n\ngoal (3 subgoals):\n 1. \\<And>queue queuea n.\n       \\<lbrakk>t0 # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                         None \\<Rightarrow> True\n                         | \\<lfloor>(t, taxm,\n                                     \\<sigma>)\\<rfloor> \\<Rightarrow>\n                             local.round_robin_invar \\<sigma>\n                              (case taxm of\n                               None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n                               | \\<lfloor>(ta, x',\n     m')\\<rfloor> \\<Rightarrow>\n                                   dom (thr_\\<alpha> (thr s)) \\<union>\n                                   {t. \\<exists>x m.\n    NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n 2. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                          (round_robin_reschedule t0 queuea n0 s) =\n                         \\<alpha>.round_robin_reschedule t0\n                          (queue_\\<alpha> queuea) n0 (state_\\<alpha> s)\n 3. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                         None \\<Rightarrow> True\n                         | \\<lfloor>(t, taxm,\n                                     \\<sigma>)\\<rfloor> \\<Rightarrow>\n                             local.round_robin_invar \\<sigma>\n                              (case taxm of\n                               None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n                               | \\<lfloor>(ta, x',\n     m')\\<rfloor> \\<Rightarrow>\n                                   dom (thr_\\<alpha> (thr s)) \\<union>\n                                   {t. \\<exists>x m.\n    NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>queue queuea n.\n       \\<lbrakk>t0 # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                         None \\<Rightarrow> True\n                         | \\<lfloor>(t, taxm,\n                                     \\<sigma>)\\<rfloor> \\<Rightarrow>\n                             local.round_robin_invar \\<sigma>\n                              (case taxm of\n                               None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n                               | \\<lfloor>(ta, x',\n     m')\\<rfloor> \\<Rightarrow>\n                                   dom (thr_\\<alpha> (thr s)) \\<union>\n                                   {t. \\<exists>x m.\n    NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n 2. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                          (round_robin_reschedule t0 queuea n0 s) =\n                         \\<alpha>.round_robin_reschedule t0\n                          (queue_\\<alpha> queuea) n0 (state_\\<alpha> s)\n 3. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                         None \\<Rightarrow> True\n                         | \\<lfloor>(t, taxm,\n                                     \\<sigma>)\\<rfloor> \\<Rightarrow>\n                             local.round_robin_invar \\<sigma>\n                              (case taxm of\n                               None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n                               | \\<lfloor>(ta, x',\n     m')\\<rfloor> \\<Rightarrow>\n                                   dom (thr_\\<alpha> (thr s)) \\<union>\n                                   {t. \\<exists>x m.\n    NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "case 2"], ["proof (state)\nthis:\n  local.round_robin_invar (queue, n) (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n\ngoal (3 subgoals):\n 1. \\<And>queue queuea n.\n       \\<lbrakk>t0 # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                         None \\<Rightarrow> True\n                         | \\<lfloor>(t, taxm,\n                                     \\<sigma>)\\<rfloor> \\<Rightarrow>\n                             local.round_robin_invar \\<sigma>\n                              (case taxm of\n                               None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n                               | \\<lfloor>(ta, x',\n     m')\\<rfloor> \\<Rightarrow>\n                                   dom (thr_\\<alpha> (thr s)) \\<union>\n                                   {t. \\<exists>x m.\n    NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n 2. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                          (round_robin_reschedule t0 queuea n0 s) =\n                         \\<alpha>.round_robin_reschedule t0\n                          (queue_\\<alpha> queuea) n0 (state_\\<alpha> s)\n 3. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                         None \\<Rightarrow> True\n                         | \\<lfloor>(t, taxm,\n                                     \\<sigma>)\\<rfloor> \\<Rightarrow>\n                             local.round_robin_invar \\<sigma>\n                              (case taxm of\n                               None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n                               | \\<lfloor>(ta, x',\n     m')\\<rfloor> \\<Rightarrow>\n                                   dom (thr_\\<alpha> (thr s)) \\<union>\n                                   {t. \\<exists>x m.\n    NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "thus ?case"], ["proof (prove)\nusing this:\n  local.round_robin_invar (queue, n) (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n\ngoal (1 subgoal):\n 1. case round_robin_reschedule t0 queue n0 s of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        local.round_robin_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "using head[symmetric]"], ["proof (prove)\nusing this:\n  local.round_robin_invar (queue, n) (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n  queue_\\<alpha> queue = t0 # queue_\n\ngoal (1 subgoal):\n 1. case round_robin_reschedule t0 queue n0 s of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        local.round_robin_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "by(subst round_robin_reschedule.simps)(clarsimp simp add: split_beta queue.dequeue_correct)"], ["proof (state)\nthis:\n  case round_robin_reschedule t0 queue n0 s of None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      local.round_robin_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal (2 subgoals):\n 1. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                          (round_robin_reschedule t0 queuea n0 s) =\n                         \\<alpha>.round_robin_reschedule t0\n                          (queue_\\<alpha> queuea) n0 (state_\\<alpha> s)\n 2. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                         None \\<Rightarrow> True\n                         | \\<lfloor>(t, taxm,\n                                     \\<sigma>)\\<rfloor> \\<Rightarrow>\n                             local.round_robin_invar \\<sigma>\n                              (case taxm of\n                               None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n                               | \\<lfloor>(ta, x',\n     m')\\<rfloor> \\<Rightarrow>\n                                   dom (thr_\\<alpha> (thr s)) \\<union>\n                                   {t. \\<exists>x m.\n    NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "}"], ["proof (state)\nthis:\n  \\<lbrakk>local.round_robin_invar (queue, ?na5)\n            (dom (thr_\\<alpha> (thr s)));\n   state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n  \\<Longrightarrow> case round_robin_reschedule t0 queue n0 s of\n                    None \\<Rightarrow> True\n                    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n                        local.round_robin_invar \\<sigma>\n                         (case taxm of\n                          None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n                          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                              dom (thr_\\<alpha> (thr s)) \\<union>\n                              {t. \\<exists>x m.\n                                     NewThread t x m\n                                     \\<in> set\n      \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal (2 subgoals):\n 1. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                          (round_robin_reschedule t0 queuea n0 s) =\n                         \\<alpha>.round_robin_reschedule t0\n                          (queue_\\<alpha> queuea) n0 (state_\\<alpha> s)\n 2. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                         None \\<Rightarrow> True\n                         | \\<lfloor>(t, taxm,\n                                     \\<sigma>)\\<rfloor> \\<Rightarrow>\n                             local.round_robin_invar \\<sigma>\n                              (case taxm of\n                               None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n                               | \\<lfloor>(ta, x',\n     m')\\<rfloor> \\<Rightarrow>\n                                   dom (thr_\\<alpha> (thr s)) \\<union>\n                                   {t. \\<exists>x m.\n    NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                          (round_robin_reschedule t0 queuea n0 s) =\n                         \\<alpha>.round_robin_reschedule t0\n                          (queue_\\<alpha> queuea) n0 (state_\\<alpha> s)\n 2. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                         None \\<Rightarrow> True\n                         | \\<lfloor>(t, taxm,\n                                     \\<sigma>)\\<rfloor> \\<Rightarrow>\n                             local.round_robin_invar \\<sigma>\n                              (case taxm of\n                               None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n                               | \\<lfloor>(ta, x',\n     m')\\<rfloor> \\<Rightarrow>\n                                   dom (thr_\\<alpha> (thr s)) \\<union>\n                                   {t. \\<exists>x m.\n    NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "case (rotate \\<alpha>queue' t)"], ["proof (state)\nthis:\n  t \\<noteq> t0\n  t0 \\<in> set \\<alpha>queue'\n  \\<lbrakk>\\<alpha>queue' @ [t] = queue_\\<alpha> ?queue3;\n   local.round_robin_invar (?queue3, ?n3) (dom (thr_\\<alpha> (thr s)));\n   state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n  \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                     (round_robin_reschedule t0 ?queue3 n0 s) =\n                    \\<alpha>.round_robin_reschedule t0\n                     (queue_\\<alpha> ?queue3) n0 (state_\\<alpha> s)\n  \\<lbrakk>\\<alpha>queue' @ [t] = queue_\\<alpha> ?queue3;\n   local.round_robin_invar (?queue3, ?n3) (dom (thr_\\<alpha> (thr s)));\n   state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n  \\<Longrightarrow> case round_robin_reschedule t0 ?queue3 n0 s of\n                    None \\<Rightarrow> True\n                    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n                        local.round_robin_invar \\<sigma>\n                         (case taxm of\n                          None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n                          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                              dom (thr_\\<alpha> (thr s)) \\<union>\n                              {t. \\<exists>x m.\n                                     NewThread t x m\n                                     \\<in> set\n      \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n  t # \\<alpha>queue' = queue_\\<alpha> queue\n\ngoal (2 subgoals):\n 1. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                          (round_robin_reschedule t0 queuea n0 s) =\n                         \\<alpha>.round_robin_reschedule t0\n                          (queue_\\<alpha> queuea) n0 (state_\\<alpha> s)\n 2. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                         None \\<Rightarrow> True\n                         | \\<lfloor>(t, taxm,\n                                     \\<sigma>)\\<rfloor> \\<Rightarrow>\n                             local.round_robin_invar \\<sigma>\n                              (case taxm of\n                               None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n                               | \\<lfloor>(ta, x',\n     m')\\<rfloor> \\<Rightarrow>\n                                   dom (thr_\\<alpha> (thr s)) \\<union>\n                                   {t. \\<exists>x m.\n    NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "obtain t' queue' where queue': \"queue_dequeue queue = (t', queue')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t' queue'.\n        queue_dequeue queue = (t', queue') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases \"queue_dequeue queue\")"], ["proof (state)\nthis:\n  queue_dequeue queue = (t', queue')\n\ngoal (2 subgoals):\n 1. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                          (round_robin_reschedule t0 queuea n0 s) =\n                         \\<alpha>.round_robin_reschedule t0\n                          (queue_\\<alpha> queuea) n0 (state_\\<alpha> s)\n 2. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                         None \\<Rightarrow> True\n                         | \\<lfloor>(t, taxm,\n                                     \\<sigma>)\\<rfloor> \\<Rightarrow>\n                             local.round_robin_invar \\<sigma>\n                              (case taxm of\n                               None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n                               | \\<lfloor>(ta, x',\n     m')\\<rfloor> \\<Rightarrow>\n                                   dom (thr_\\<alpha> (thr s)) \\<union>\n                                   {t. \\<exists>x m.\n    NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "note [simp] = \\<open>t # \\<alpha>queue' = queue_\\<alpha> queue\\<close>[symmetric]"], ["proof (state)\nthis:\n  queue_\\<alpha> queue = t # \\<alpha>queue'\n\ngoal (2 subgoals):\n 1. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                          (round_robin_reschedule t0 queuea n0 s) =\n                         \\<alpha>.round_robin_reschedule t0\n                          (queue_\\<alpha> queuea) n0 (state_\\<alpha> s)\n 2. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                         None \\<Rightarrow> True\n                         | \\<lfloor>(t, taxm,\n                                     \\<sigma>)\\<rfloor> \\<Rightarrow>\n                             local.round_robin_invar \\<sigma>\n                              (case taxm of\n                               None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n                               | \\<lfloor>(ta, x',\n     m')\\<rfloor> \\<Rightarrow>\n                                   dom (thr_\\<alpha> (thr s)) \\<union>\n                                   {t. \\<exists>x m.\n    NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "{"], ["proof (state)\nthis:\n  queue_\\<alpha> queue = t # \\<alpha>queue'\n\ngoal (2 subgoals):\n 1. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                          (round_robin_reschedule t0 queuea n0 s) =\n                         \\<alpha>.round_robin_reschedule t0\n                          (queue_\\<alpha> queuea) n0 (state_\\<alpha> s)\n 2. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                         None \\<Rightarrow> True\n                         | \\<lfloor>(t, taxm,\n                                     \\<sigma>)\\<rfloor> \\<Rightarrow>\n                             local.round_robin_invar \\<sigma>\n                              (case taxm of\n                               None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n                               | \\<lfloor>(ta, x',\n     m')\\<rfloor> \\<Rightarrow>\n                                   dom (thr_\\<alpha> (thr s)) \\<union>\n                                   {t. \\<exists>x m.\n    NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "case 1"], ["proof (state)\nthis:\n  local.round_robin_invar (queue, n) (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n\ngoal (2 subgoals):\n 1. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                          (round_robin_reschedule t0 queuea n0 s) =\n                         \\<alpha>.round_robin_reschedule t0\n                          (queue_\\<alpha> queuea) n0 (state_\\<alpha> s)\n 2. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                         None \\<Rightarrow> True\n                         | \\<lfloor>(t, taxm,\n                                     \\<sigma>)\\<rfloor> \\<Rightarrow>\n                             local.round_robin_invar \\<sigma>\n                              (case taxm of\n                               None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n                               | \\<lfloor>(ta, x',\n     m')\\<rfloor> \\<Rightarrow>\n                                   dom (thr_\\<alpha> (thr s)) \\<union>\n                                   {t. \\<exists>x m.\n    NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "with queue'"], ["proof (chain)\npicking this:\n  queue_dequeue queue = (t', queue')\n  local.round_robin_invar (queue, n) (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I", "have [simp]: \"t' = t\" \"\\<alpha>queue' = queue_\\<alpha> queue'\" \"queue_invar queue'\""], ["proof (prove)\nusing this:\n  queue_dequeue queue = (t', queue')\n  local.round_robin_invar (queue, n) (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n\ngoal (1 subgoal):\n 1. t' = t &&& \\<alpha>queue' = queue_\\<alpha> queue' &&& queue_invar queue'", "by(auto elim: queue.removelE)"], ["proof (state)\nthis:\n  t' = t\n  \\<alpha>queue' = queue_\\<alpha> queue'\n  queue_invar queue'\n\ngoal (2 subgoals):\n 1. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                          (round_robin_reschedule t0 queuea n0 s) =\n                         \\<alpha>.round_robin_reschedule t0\n                          (queue_\\<alpha> queuea) n0 (state_\\<alpha> s)\n 2. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                         None \\<Rightarrow> True\n                         | \\<lfloor>(t, taxm,\n                                     \\<sigma>)\\<rfloor> \\<Rightarrow>\n                             local.round_robin_invar \\<sigma>\n                              (case taxm of\n                               None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n                               | \\<lfloor>(ta, x',\n     m')\\<rfloor> \\<Rightarrow>\n                                   dom (thr_\\<alpha> (thr s)) \\<union>\n                                   {t. \\<exists>x m.\n    NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "from 1 queue'"], ["proof (chain)\npicking this:\n  local.round_robin_invar (queue, n) (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n  queue_dequeue queue = (t', queue')", "have invar': \"round_robin_invar (queue_push t queue', n0) (dom (thr_\\<alpha> (thr s)))\""], ["proof (prove)\nusing this:\n  local.round_robin_invar (queue, n) (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n  queue_dequeue queue = (t', queue')\n\ngoal (1 subgoal):\n 1. local.round_robin_invar (queue_push t queue', n0)\n     (dom (thr_\\<alpha> (thr s)))", "by(auto simp add: queue.push_correct)"], ["proof (state)\nthis:\n  local.round_robin_invar (queue_push t queue', n0)\n   (dom (thr_\\<alpha> (thr s)))\n\ngoal (2 subgoals):\n 1. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                          (round_robin_reschedule t0 queuea n0 s) =\n                         \\<alpha>.round_robin_reschedule t0\n                          (queue_\\<alpha> queuea) n0 (state_\\<alpha> s)\n 2. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                         None \\<Rightarrow> True\n                         | \\<lfloor>(t, taxm,\n                                     \\<sigma>)\\<rfloor> \\<Rightarrow>\n                             local.round_robin_invar \\<sigma>\n                              (case taxm of\n                               None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n                               | \\<lfloor>(ta, x',\n     m')\\<rfloor> \\<Rightarrow>\n                                   dom (thr_\\<alpha> (thr s)) \\<union>\n                                   {t. \\<exists>x m.\n    NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_reschedule t0 queue n0 s) =\n    \\<alpha>.round_robin_reschedule t0 (queue_\\<alpha> queue) n0\n     (state_\\<alpha> s)", "proof(cases \"round_robin_step n0 (queue_push t queue', n0) s t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. round_robin_step n0 (queue_push t queue', n0) s t =\n    None \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_reschedule t0 queue n0 s) =\n    \\<alpha>.round_robin_reschedule t0 (queue_\\<alpha> queue) n0\n     (state_\\<alpha> s)\n 2. \\<And>a.\n       round_robin_step n0 (queue_push t queue', n0) s t =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       map_option (apsnd (apsnd round_robin_\\<alpha>))\n        (round_robin_reschedule t0 queue n0 s) =\n       \\<alpha>.round_robin_reschedule t0 (queue_\\<alpha> queue) n0\n        (state_\\<alpha> s)", "case Some"], ["proof (state)\nthis:\n  round_robin_step n0 (queue_push t queue', n0) s t = \\<lfloor>a_\\<rfloor>\n\ngoal (2 subgoals):\n 1. round_robin_step n0 (queue_push t queue', n0) s t =\n    None \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_reschedule t0 queue n0 s) =\n    \\<alpha>.round_robin_reschedule t0 (queue_\\<alpha> queue) n0\n     (state_\\<alpha> s)\n 2. \\<And>a.\n       round_robin_step n0 (queue_push t queue', n0) s t =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       map_option (apsnd (apsnd round_robin_\\<alpha>))\n        (round_robin_reschedule t0 queue n0 s) =\n       \\<alpha>.round_robin_reschedule t0 (queue_\\<alpha> queue) n0\n        (state_\\<alpha> s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  round_robin_step n0 (queue_push t queue', n0) s t = \\<lfloor>a_\\<rfloor>\n\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_reschedule t0 queue n0 s) =\n    \\<alpha>.round_robin_reschedule t0 (queue_\\<alpha> queue) n0\n     (state_\\<alpha> s)", "using queue' \\<open>t \\<noteq> t0\\<close> round_robin_step_correct[OF det invar' \\<open>state_invar s\\<close>, of n0 t] invar' \\<open>state_\\<alpha> s \\<in> I\\<close>"], ["proof (prove)\nusing this:\n  round_robin_step n0 (queue_push t queue', n0) s t = \\<lfloor>a_\\<rfloor>\n  queue_dequeue queue = (t', queue')\n  t \\<noteq> t0\n  state_\\<alpha> s \\<in> I \\<Longrightarrow>\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (round_robin_step n0 (queue_push t queue', n0) s t) =\n  \\<alpha>.round_robin_step n0\n   (round_robin_\\<alpha> (queue_push t queue', n0)) (state_\\<alpha> s) t\n  state_\\<alpha> s \\<in> I \\<Longrightarrow>\n  case round_robin_step n0 (queue_push t queue', n0) s t of\n  None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      local.round_robin_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n  local.round_robin_invar (queue_push t queue', n0)\n   (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> I\n\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_reschedule t0 queue n0 s) =\n    \\<alpha>.round_robin_reschedule t0 (queue_\\<alpha> queue) n0\n     (state_\\<alpha> s)", "by(subst round_robin_reschedule.simps)(subst \\<alpha>.round_robin_reschedule.simps, auto simp add: round_robin_\\<alpha>_def queue.push_correct)"], ["proof (state)\nthis:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (round_robin_reschedule t0 queue n0 s) =\n  \\<alpha>.round_robin_reschedule t0 (queue_\\<alpha> queue) n0\n   (state_\\<alpha> s)\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (queue_push t queue', n0) s t =\n    None \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_reschedule t0 queue n0 s) =\n    \\<alpha>.round_robin_reschedule t0 (queue_\\<alpha> queue) n0\n     (state_\\<alpha> s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. round_robin_step n0 (queue_push t queue', n0) s t =\n    None \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_reschedule t0 queue n0 s) =\n    \\<alpha>.round_robin_reschedule t0 (queue_\\<alpha> queue) n0\n     (state_\\<alpha> s)", "case None"], ["proof (state)\nthis:\n  round_robin_step n0 (queue_push t queue', n0) s t = None\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (queue_push t queue', n0) s t =\n    None \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_reschedule t0 queue n0 s) =\n    \\<alpha>.round_robin_reschedule t0 (queue_\\<alpha> queue) n0\n     (state_\\<alpha> s)", "hence \\<alpha>None: \"\\<alpha>.round_robin_step n0 (queue_\\<alpha> (queue_push t queue'), n0) (state_\\<alpha> s) t = None\""], ["proof (prove)\nusing this:\n  round_robin_step n0 (queue_push t queue', n0) s t = None\n\ngoal (1 subgoal):\n 1. \\<alpha>.round_robin_step n0 (queue_\\<alpha> (queue_push t queue'), n0)\n     (state_\\<alpha> s) t =\n    None", "using round_robin_step_correct[OF det invar' \\<open>state_invar s\\<close>, of n0 t] invar' \\<open>state_\\<alpha> s \\<in> I\\<close>"], ["proof (prove)\nusing this:\n  round_robin_step n0 (queue_push t queue', n0) s t = None\n  state_\\<alpha> s \\<in> I \\<Longrightarrow>\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (round_robin_step n0 (queue_push t queue', n0) s t) =\n  \\<alpha>.round_robin_step n0\n   (round_robin_\\<alpha> (queue_push t queue', n0)) (state_\\<alpha> s) t\n  state_\\<alpha> s \\<in> I \\<Longrightarrow>\n  case round_robin_step n0 (queue_push t queue', n0) s t of\n  None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      local.round_robin_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n  local.round_robin_invar (queue_push t queue', n0)\n   (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> I\n\ngoal (1 subgoal):\n 1. \\<alpha>.round_robin_step n0 (queue_\\<alpha> (queue_push t queue'), n0)\n     (state_\\<alpha> s) t =\n    None", "by(auto simp add: queue.push_correct round_robin_\\<alpha>_def)"], ["proof (state)\nthis:\n  \\<alpha>.round_robin_step n0 (queue_\\<alpha> (queue_push t queue'), n0)\n   (state_\\<alpha> s) t =\n  None\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (queue_push t queue', n0) s t =\n    None \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_reschedule t0 queue n0 s) =\n    \\<alpha>.round_robin_reschedule t0 (queue_\\<alpha> queue) n0\n     (state_\\<alpha> s)", "have \"\\<alpha>queue' @ [t] = queue_\\<alpha> (queue_enqueue t queue')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>queue' @ [t] = queue_\\<alpha> (queue_enqueue t queue')", "by(simp add: queue.enqueue_correct)"], ["proof (state)\nthis:\n  \\<alpha>queue' @ [t] = queue_\\<alpha> (queue_enqueue t queue')\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (queue_push t queue', n0) s t =\n    None \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_reschedule t0 queue n0 s) =\n    \\<alpha>.round_robin_reschedule t0 (queue_\\<alpha> queue) n0\n     (state_\\<alpha> s)", "moreover"], ["proof (state)\nthis:\n  \\<alpha>queue' @ [t] = queue_\\<alpha> (queue_enqueue t queue')\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (queue_push t queue', n0) s t =\n    None \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_reschedule t0 queue n0 s) =\n    \\<alpha>.round_robin_reschedule t0 (queue_\\<alpha> queue) n0\n     (state_\\<alpha> s)", "from invar'"], ["proof (chain)\npicking this:\n  local.round_robin_invar (queue_push t queue', n0)\n   (dom (thr_\\<alpha> (thr s)))", "have \"round_robin_invar (queue_enqueue t queue', n0) (dom (thr_\\<alpha> (thr s)))\""], ["proof (prove)\nusing this:\n  local.round_robin_invar (queue_push t queue', n0)\n   (dom (thr_\\<alpha> (thr s)))\n\ngoal (1 subgoal):\n 1. local.round_robin_invar (queue_enqueue t queue', n0)\n     (dom (thr_\\<alpha> (thr s)))", "by(auto simp add: queue.enqueue_correct queue.push_correct)"], ["proof (state)\nthis:\n  local.round_robin_invar (queue_enqueue t queue', n0)\n   (dom (thr_\\<alpha> (thr s)))\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (queue_push t queue', n0) s t =\n    None \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_reschedule t0 queue n0 s) =\n    \\<alpha>.round_robin_reschedule t0 (queue_\\<alpha> queue) n0\n     (state_\\<alpha> s)", "ultimately"], ["proof (chain)\npicking this:\n  \\<alpha>queue' @ [t] = queue_\\<alpha> (queue_enqueue t queue')\n  local.round_robin_invar (queue_enqueue t queue', n0)\n   (dom (thr_\\<alpha> (thr s)))", "have \"map_option (apsnd (apsnd round_robin_\\<alpha>)) (round_robin_reschedule t0 (queue_enqueue t queue') n0 s) =\n            \\<alpha>.round_robin_reschedule t0 (queue_\\<alpha> (queue_enqueue t queue')) n0 (state_\\<alpha> s)\""], ["proof (prove)\nusing this:\n  \\<alpha>queue' @ [t] = queue_\\<alpha> (queue_enqueue t queue')\n  local.round_robin_invar (queue_enqueue t queue', n0)\n   (dom (thr_\\<alpha> (thr s)))\n\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_reschedule t0 (queue_enqueue t queue') n0 s) =\n    \\<alpha>.round_robin_reschedule t0\n     (queue_\\<alpha> (queue_enqueue t queue')) n0 (state_\\<alpha> s)", "using \\<open>state_invar s\\<close> \\<open>state_\\<alpha> s \\<in> I\\<close>"], ["proof (prove)\nusing this:\n  \\<alpha>queue' @ [t] = queue_\\<alpha> (queue_enqueue t queue')\n  local.round_robin_invar (queue_enqueue t queue', n0)\n   (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_reschedule t0 (queue_enqueue t queue') n0 s) =\n    \\<alpha>.round_robin_reschedule t0\n     (queue_\\<alpha> (queue_enqueue t queue')) n0 (state_\\<alpha> s)", "by(rule rotate.hyps)"], ["proof (state)\nthis:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (round_robin_reschedule t0 (queue_enqueue t queue') n0 s) =\n  \\<alpha>.round_robin_reschedule t0\n   (queue_\\<alpha> (queue_enqueue t queue')) n0 (state_\\<alpha> s)\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (queue_push t queue', n0) s t =\n    None \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_reschedule t0 queue n0 s) =\n    \\<alpha>.round_robin_reschedule t0 (queue_\\<alpha> queue) n0\n     (state_\\<alpha> s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (round_robin_reschedule t0 (queue_enqueue t queue') n0 s) =\n  \\<alpha>.round_robin_reschedule t0\n   (queue_\\<alpha> (queue_enqueue t queue')) n0 (state_\\<alpha> s)\n\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_reschedule t0 queue n0 s) =\n    \\<alpha>.round_robin_reschedule t0 (queue_\\<alpha> queue) n0\n     (state_\\<alpha> s)", "using None \\<alpha>None \\<open>t \\<noteq> t0\\<close> invar' queue'"], ["proof (prove)\nusing this:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (round_robin_reschedule t0 (queue_enqueue t queue') n0 s) =\n  \\<alpha>.round_robin_reschedule t0\n   (queue_\\<alpha> (queue_enqueue t queue')) n0 (state_\\<alpha> s)\n  round_robin_step n0 (queue_push t queue', n0) s t = None\n  \\<alpha>.round_robin_step n0 (queue_\\<alpha> (queue_push t queue'), n0)\n   (state_\\<alpha> s) t =\n  None\n  t \\<noteq> t0\n  local.round_robin_invar (queue_push t queue', n0)\n   (dom (thr_\\<alpha> (thr s)))\n  queue_dequeue queue = (t', queue')\n\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (round_robin_reschedule t0 queue n0 s) =\n    \\<alpha>.round_robin_reschedule t0 (queue_\\<alpha> queue) n0\n     (state_\\<alpha> s)", "by(subst round_robin_reschedule.simps)(subst \\<alpha>.round_robin_reschedule.simps, auto simp add: queue.enqueue_correct queue.push_correct)"], ["proof (state)\nthis:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (round_robin_reschedule t0 queue n0 s) =\n  \\<alpha>.round_robin_reschedule t0 (queue_\\<alpha> queue) n0\n   (state_\\<alpha> s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (round_robin_reschedule t0 queue n0 s) =\n  \\<alpha>.round_robin_reschedule t0 (queue_\\<alpha> queue) n0\n   (state_\\<alpha> s)\n\ngoal (1 subgoal):\n 1. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                         None \\<Rightarrow> True\n                         | \\<lfloor>(t, taxm,\n                                     \\<sigma>)\\<rfloor> \\<Rightarrow>\n                             local.round_robin_invar \\<sigma>\n                              (case taxm of\n                               None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n                               | \\<lfloor>(ta, x',\n     m')\\<rfloor> \\<Rightarrow>\n                                   dom (thr_\\<alpha> (thr s)) \\<union>\n                                   {t. \\<exists>x m.\n    NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                         None \\<Rightarrow> True\n                         | \\<lfloor>(t, taxm,\n                                     \\<sigma>)\\<rfloor> \\<Rightarrow>\n                             local.round_robin_invar \\<sigma>\n                              (case taxm of\n                               None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n                               | \\<lfloor>(ta, x',\n     m')\\<rfloor> \\<Rightarrow>\n                                   dom (thr_\\<alpha> (thr s)) \\<union>\n                                   {t. \\<exists>x m.\n    NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "case 2"], ["proof (state)\nthis:\n  local.round_robin_invar (queue, n) (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                         None \\<Rightarrow> True\n                         | \\<lfloor>(t, taxm,\n                                     \\<sigma>)\\<rfloor> \\<Rightarrow>\n                             local.round_robin_invar \\<sigma>\n                              (case taxm of\n                               None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n                               | \\<lfloor>(ta, x',\n     m')\\<rfloor> \\<Rightarrow>\n                                   dom (thr_\\<alpha> (thr s)) \\<union>\n                                   {t. \\<exists>x m.\n    NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "with queue'"], ["proof (chain)\npicking this:\n  queue_dequeue queue = (t', queue')\n  local.round_robin_invar (queue, n) (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I", "have [simp]: \"t' = t\" \"\\<alpha>queue' = queue_\\<alpha> queue'\" \"queue_invar queue'\""], ["proof (prove)\nusing this:\n  queue_dequeue queue = (t', queue')\n  local.round_robin_invar (queue, n) (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n\ngoal (1 subgoal):\n 1. t' = t &&& \\<alpha>queue' = queue_\\<alpha> queue' &&& queue_invar queue'", "by(auto elim: queue.removelE)"], ["proof (state)\nthis:\n  t' = t\n  \\<alpha>queue' = queue_\\<alpha> queue'\n  queue_invar queue'\n\ngoal (1 subgoal):\n 1. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                         None \\<Rightarrow> True\n                         | \\<lfloor>(t, taxm,\n                                     \\<sigma>)\\<rfloor> \\<Rightarrow>\n                             local.round_robin_invar \\<sigma>\n                              (case taxm of\n                               None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n                               | \\<lfloor>(ta, x',\n     m')\\<rfloor> \\<Rightarrow>\n                                   dom (thr_\\<alpha> (thr s)) \\<union>\n                                   {t. \\<exists>x m.\n    NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "from 2 queue'"], ["proof (chain)\npicking this:\n  local.round_robin_invar (queue, n) (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n  queue_dequeue queue = (t', queue')", "have invar': \"round_robin_invar (queue_push t queue', n0) (dom (thr_\\<alpha> (thr s)))\""], ["proof (prove)\nusing this:\n  local.round_robin_invar (queue, n) (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n  queue_dequeue queue = (t', queue')\n\ngoal (1 subgoal):\n 1. local.round_robin_invar (queue_push t queue', n0)\n     (dom (thr_\\<alpha> (thr s)))", "by(auto simp add: queue.push_correct)"], ["proof (state)\nthis:\n  local.round_robin_invar (queue_push t queue', n0)\n   (dom (thr_\\<alpha> (thr s)))\n\ngoal (1 subgoal):\n 1. \\<And>queue t queuea n.\n       \\<lbrakk>t \\<noteq> t0; t0 \\<in> set queue;\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> map_option (apsnd (apsnd round_robin_\\<alpha>))\n                              (round_robin_reschedule t0 queuea n0 s) =\n                             \\<alpha>.round_robin_reschedule t0\n                              (queue_\\<alpha> queuea) n0 (state_\\<alpha> s);\n        \\<And>queuea n.\n           \\<lbrakk>queue @ [t] = queue_\\<alpha> queuea;\n            local.round_robin_invar (queuea, n)\n             (dom (thr_\\<alpha> (thr s)));\n            state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n           \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                             None \\<Rightarrow> True\n                             | \\<lfloor>(t, taxm,\n   \\<sigma>)\\<rfloor> \\<Rightarrow>\n                                 local.round_robin_invar \\<sigma>\n                                  (case taxm of\n                                   None \\<Rightarrow>\n                                     dom (thr_\\<alpha> (thr s))\n                                   | \\<lfloor>(ta, x',\n         m')\\<rfloor> \\<Rightarrow>\n dom (thr_\\<alpha> (thr s)) \\<union>\n {t. \\<exists>x m.\n        NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>});\n        t # queue = queue_\\<alpha> queuea;\n        local.round_robin_invar (queuea, n) (dom (thr_\\<alpha> (thr s)));\n        state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> case round_robin_reschedule t0 queuea n0 s of\n                         None \\<Rightarrow> True\n                         | \\<lfloor>(t, taxm,\n                                     \\<sigma>)\\<rfloor> \\<Rightarrow>\n                             local.round_robin_invar \\<sigma>\n                              (case taxm of\n                               None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n                               | \\<lfloor>(ta, x',\n     m')\\<rfloor> \\<Rightarrow>\n                                   dom (thr_\\<alpha> (thr s)) \\<union>\n                                   {t. \\<exists>x m.\n    NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. case round_robin_reschedule t0 queue n0 s of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        local.round_robin_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "proof(cases \"round_robin_step n0 (queue_push t queue', n0) s t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. round_robin_step n0 (queue_push t queue', n0) s t =\n    None \\<Longrightarrow>\n    case round_robin_reschedule t0 queue n0 s of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        local.round_robin_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n 2. \\<And>a.\n       round_robin_step n0 (queue_push t queue', n0) s t =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       case round_robin_reschedule t0 queue n0 s of None \\<Rightarrow> True\n       | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n           local.round_robin_invar \\<sigma>\n            (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n             | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                 dom (thr_\\<alpha> (thr s)) \\<union>\n                 {t. \\<exists>x m.\n                        NewThread t x m\n                        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "case Some"], ["proof (state)\nthis:\n  round_robin_step n0 (queue_push t queue', n0) s t = \\<lfloor>a_\\<rfloor>\n\ngoal (2 subgoals):\n 1. round_robin_step n0 (queue_push t queue', n0) s t =\n    None \\<Longrightarrow>\n    case round_robin_reschedule t0 queue n0 s of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        local.round_robin_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n 2. \\<And>a.\n       round_robin_step n0 (queue_push t queue', n0) s t =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       case round_robin_reschedule t0 queue n0 s of None \\<Rightarrow> True\n       | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n           local.round_robin_invar \\<sigma>\n            (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n             | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                 dom (thr_\\<alpha> (thr s)) \\<union>\n                 {t. \\<exists>x m.\n                        NewThread t x m\n                        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "thus ?thesis"], ["proof (prove)\nusing this:\n  round_robin_step n0 (queue_push t queue', n0) s t = \\<lfloor>a_\\<rfloor>\n\ngoal (1 subgoal):\n 1. case round_robin_reschedule t0 queue n0 s of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        local.round_robin_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "using queue' \\<open>t \\<noteq> t0\\<close> round_robin_step_correct[OF det invar' \\<open>state_invar s\\<close>, of n0 t] invar' \\<open>state_\\<alpha> s \\<in> I\\<close>"], ["proof (prove)\nusing this:\n  round_robin_step n0 (queue_push t queue', n0) s t = \\<lfloor>a_\\<rfloor>\n  queue_dequeue queue = (t', queue')\n  t \\<noteq> t0\n  state_\\<alpha> s \\<in> I \\<Longrightarrow>\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (round_robin_step n0 (queue_push t queue', n0) s t) =\n  \\<alpha>.round_robin_step n0\n   (round_robin_\\<alpha> (queue_push t queue', n0)) (state_\\<alpha> s) t\n  state_\\<alpha> s \\<in> I \\<Longrightarrow>\n  case round_robin_step n0 (queue_push t queue', n0) s t of\n  None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      local.round_robin_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n  local.round_robin_invar (queue_push t queue', n0)\n   (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> I\n\ngoal (1 subgoal):\n 1. case round_robin_reschedule t0 queue n0 s of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        local.round_robin_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "by(subst round_robin_reschedule.simps)(auto simp add: round_robin_\\<alpha>_def queue.push_correct)"], ["proof (state)\nthis:\n  case round_robin_reschedule t0 queue n0 s of None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      local.round_robin_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (queue_push t queue', n0) s t =\n    None \\<Longrightarrow>\n    case round_robin_reschedule t0 queue n0 s of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        local.round_robin_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. round_robin_step n0 (queue_push t queue', n0) s t =\n    None \\<Longrightarrow>\n    case round_robin_reschedule t0 queue n0 s of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        local.round_robin_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "case None"], ["proof (state)\nthis:\n  round_robin_step n0 (queue_push t queue', n0) s t = None\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (queue_push t queue', n0) s t =\n    None \\<Longrightarrow>\n    case round_robin_reschedule t0 queue n0 s of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        local.round_robin_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "have \"\\<alpha>queue' @ [t] = queue_\\<alpha> (queue_enqueue t queue')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>queue' @ [t] = queue_\\<alpha> (queue_enqueue t queue')", "by(simp add: queue.enqueue_correct)"], ["proof (state)\nthis:\n  \\<alpha>queue' @ [t] = queue_\\<alpha> (queue_enqueue t queue')\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (queue_push t queue', n0) s t =\n    None \\<Longrightarrow>\n    case round_robin_reschedule t0 queue n0 s of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        local.round_robin_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "moreover"], ["proof (state)\nthis:\n  \\<alpha>queue' @ [t] = queue_\\<alpha> (queue_enqueue t queue')\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (queue_push t queue', n0) s t =\n    None \\<Longrightarrow>\n    case round_robin_reschedule t0 queue n0 s of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        local.round_robin_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "from invar'"], ["proof (chain)\npicking this:\n  local.round_robin_invar (queue_push t queue', n0)\n   (dom (thr_\\<alpha> (thr s)))", "have \"round_robin_invar (queue_enqueue t queue', n0) (dom (thr_\\<alpha> (thr s)))\""], ["proof (prove)\nusing this:\n  local.round_robin_invar (queue_push t queue', n0)\n   (dom (thr_\\<alpha> (thr s)))\n\ngoal (1 subgoal):\n 1. local.round_robin_invar (queue_enqueue t queue', n0)\n     (dom (thr_\\<alpha> (thr s)))", "by(auto simp add: queue.enqueue_correct queue.push_correct)"], ["proof (state)\nthis:\n  local.round_robin_invar (queue_enqueue t queue', n0)\n   (dom (thr_\\<alpha> (thr s)))\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (queue_push t queue', n0) s t =\n    None \\<Longrightarrow>\n    case round_robin_reschedule t0 queue n0 s of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        local.round_robin_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "ultimately"], ["proof (chain)\npicking this:\n  \\<alpha>queue' @ [t] = queue_\\<alpha> (queue_enqueue t queue')\n  local.round_robin_invar (queue_enqueue t queue', n0)\n   (dom (thr_\\<alpha> (thr s)))", "have \"case_option True (\\<lambda>(t, taxm, \\<sigma>). round_robin_invar \\<sigma> (case_option (dom (thr_\\<alpha> (thr s))) (\\<lambda>(ta, x', m'). dom (thr_\\<alpha> (thr s)) \\<union> {t. \\<exists>x m. NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}) taxm)) (round_robin_reschedule t0 (queue_enqueue t queue') n0 s)\""], ["proof (prove)\nusing this:\n  \\<alpha>queue' @ [t] = queue_\\<alpha> (queue_enqueue t queue')\n  local.round_robin_invar (queue_enqueue t queue', n0)\n   (dom (thr_\\<alpha> (thr s)))\n\ngoal (1 subgoal):\n 1. case round_robin_reschedule t0 (queue_enqueue t queue') n0 s of\n    None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        local.round_robin_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "using \\<open>state_invar s\\<close> \\<open>state_\\<alpha> s \\<in> I\\<close>"], ["proof (prove)\nusing this:\n  \\<alpha>queue' @ [t] = queue_\\<alpha> (queue_enqueue t queue')\n  local.round_robin_invar (queue_enqueue t queue', n0)\n   (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n\ngoal (1 subgoal):\n 1. case round_robin_reschedule t0 (queue_enqueue t queue') n0 s of\n    None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        local.round_robin_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "by(rule rotate.hyps)"], ["proof (state)\nthis:\n  case round_robin_reschedule t0 (queue_enqueue t queue') n0 s of\n  None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      local.round_robin_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (queue_push t queue', n0) s t =\n    None \\<Longrightarrow>\n    case round_robin_reschedule t0 queue n0 s of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        local.round_robin_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "thus ?thesis"], ["proof (prove)\nusing this:\n  case round_robin_reschedule t0 (queue_enqueue t queue') n0 s of\n  None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      local.round_robin_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal (1 subgoal):\n 1. case round_robin_reschedule t0 queue n0 s of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        local.round_robin_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "using None \\<open>t \\<noteq> t0\\<close> invar' queue'"], ["proof (prove)\nusing this:\n  case round_robin_reschedule t0 (queue_enqueue t queue') n0 s of\n  None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      local.round_robin_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n  round_robin_step n0 (queue_push t queue', n0) s t = None\n  t \\<noteq> t0\n  local.round_robin_invar (queue_push t queue', n0)\n   (dom (thr_\\<alpha> (thr s)))\n  queue_dequeue queue = (t', queue')\n\ngoal (1 subgoal):\n 1. case round_robin_reschedule t0 queue n0 s of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        local.round_robin_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "by(subst round_robin_reschedule.simps)(auto simp add: queue.enqueue_correct queue.push_correct)"], ["proof (state)\nthis:\n  case round_robin_reschedule t0 queue n0 s of None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      local.round_robin_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  case round_robin_reschedule t0 queue n0 s of None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      local.round_robin_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>local.round_robin_invar (queue, ?na5)\n            (dom (thr_\\<alpha> (thr s)));\n   state_invar s; state_\\<alpha> s \\<in> I\\<rbrakk>\n  \\<Longrightarrow> case round_robin_reschedule t0 queue n0 s of\n                    None \\<Rightarrow> True\n                    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n                        local.round_robin_invar \\<sigma>\n                         (case taxm of\n                          None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n                          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                              dom (thr_\\<alpha> (thr s)) \\<union>\n                              {t. \\<exists>x m.\n                                     NewThread t x m\n                                     \\<in> set\n      \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma round_robin_correct:\n  assumes det: \"\\<alpha>.deterministic I\"\n  and invar: \"round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\" \"state_invar s\" \"state_\\<alpha> s \\<in> I\"\n  shows \"map_option (apsnd (apsnd round_robin_\\<alpha>)) (round_robin n0 \\<sigma> s) =\n         \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>) (state_\\<alpha> s)\"\n    (is ?thesis1)\n  and \"case_option True (\\<lambda>(t, taxm, \\<sigma>). round_robin_invar \\<sigma> (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s)) | Some (ta, x', m') \\<Rightarrow> dom (thr_\\<alpha> (thr s)) \\<union> {t. \\<exists>x m. NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) (round_robin n0 \\<sigma> s)\"\n    (is ?thesis2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (local.round_robin n0 \\<sigma> s) =\n    \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) &&&\n    case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        local.round_robin_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (local.round_robin n0 \\<sigma> s) =\n    \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s)\n 2. case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        local.round_robin_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "obtain queue n where \\<sigma>: \"\\<sigma> = (queue, n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>queue n.\n        \\<sigma> = (queue, n) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \\<sigma>)"], ["proof (state)\nthis:\n  \\<sigma> = (queue, n)\n\ngoal (2 subgoals):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (local.round_robin n0 \\<sigma> s) =\n    \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s)\n 2. case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        local.round_robin_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "have \"?thesis1 \\<and> ?thesis2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (local.round_robin n0 \\<sigma> s) =\n    \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) \\<and>\n    (case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "proof(cases \"queue_\\<alpha> queue\")"], ["proof (state)\ngoal (2 subgoals):\n 1. queue_\\<alpha> queue = [] \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (local.round_robin n0 \\<sigma> s) =\n    \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) \\<and>\n    (case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))\n 2. \\<And>a list.\n       queue_\\<alpha> queue = a # list \\<Longrightarrow>\n       map_option (apsnd (apsnd round_robin_\\<alpha>))\n        (local.round_robin n0 \\<sigma> s) =\n       \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n        (state_\\<alpha> s) \\<and>\n       (case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n        | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n            local.round_robin_invar \\<sigma>\n             (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n              | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                  dom (thr_\\<alpha> (thr s)) \\<union>\n                  {t. \\<exists>x m.\n                         NewThread t x m\n                         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "case Nil"], ["proof (state)\nthis:\n  queue_\\<alpha> queue = []\n\ngoal (2 subgoals):\n 1. queue_\\<alpha> queue = [] \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (local.round_robin n0 \\<sigma> s) =\n    \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) \\<and>\n    (case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))\n 2. \\<And>a list.\n       queue_\\<alpha> queue = a # list \\<Longrightarrow>\n       map_option (apsnd (apsnd round_robin_\\<alpha>))\n        (local.round_robin n0 \\<sigma> s) =\n       \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n        (state_\\<alpha> s) \\<and>\n       (case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n        | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n            local.round_robin_invar \\<sigma>\n             (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n              | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                  dom (thr_\\<alpha> (thr s)) \\<union>\n                  {t. \\<exists>x m.\n                         NewThread t x m\n                         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "thus ?thesis"], ["proof (prove)\nusing this:\n  queue_\\<alpha> queue = []\n\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (local.round_robin n0 \\<sigma> s) =\n    \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) \\<and>\n    (case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "using invar \\<sigma>"], ["proof (prove)\nusing this:\n  queue_\\<alpha> queue = []\n  local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n  \\<sigma> = (queue, n)\n\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (local.round_robin n0 \\<sigma> s) =\n    \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) \\<and>\n    (case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "by(auto simp add: split_beta queue.isEmpty_correct round_robin_\\<alpha>_def)"], ["proof (state)\nthis:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (local.round_robin n0 \\<sigma> s) =\n  \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n   (state_\\<alpha> s) \\<and>\n  (case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n   | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n       local.round_robin_invar \\<sigma>\n        (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n         | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n             dom (thr_\\<alpha> (thr s)) \\<union>\n             {t. \\<exists>x m.\n                    NewThread t x m\n                    \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       queue_\\<alpha> queue = a # list \\<Longrightarrow>\n       map_option (apsnd (apsnd round_robin_\\<alpha>))\n        (local.round_robin n0 \\<sigma> s) =\n       \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n        (state_\\<alpha> s) \\<and>\n       (case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n        | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n            local.round_robin_invar \\<sigma>\n             (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n              | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                  dom (thr_\\<alpha> (thr s)) \\<union>\n                  {t. \\<exists>x m.\n                         NewThread t x m\n                         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       queue_\\<alpha> queue = a # list \\<Longrightarrow>\n       map_option (apsnd (apsnd round_robin_\\<alpha>))\n        (local.round_robin n0 \\<sigma> s) =\n       \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n        (state_\\<alpha> s) \\<and>\n       (case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n        | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n            local.round_robin_invar \\<sigma>\n             (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n              | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                  dom (thr_\\<alpha> (thr s)) \\<union>\n                  {t. \\<exists>x m.\n                         NewThread t x m\n                         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "case (Cons t \\<alpha>queue')"], ["proof (state)\nthis:\n  queue_\\<alpha> queue = t # \\<alpha>queue'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       queue_\\<alpha> queue = a # list \\<Longrightarrow>\n       map_option (apsnd (apsnd round_robin_\\<alpha>))\n        (local.round_robin n0 \\<sigma> s) =\n       \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n        (state_\\<alpha> s) \\<and>\n       (case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n        | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n            local.round_robin_invar \\<sigma>\n             (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n              | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                  dom (thr_\\<alpha> (thr s)) \\<union>\n                  {t. \\<exists>x m.\n                         NewThread t x m\n                         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "with invar \\<sigma>"], ["proof (chain)\npicking this:\n  local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n  \\<sigma> = (queue, n)\n  queue_\\<alpha> queue = t # \\<alpha>queue'", "obtain queue'\n      where [simp]: \"queue_dequeue queue = (t, queue')\" \"\\<alpha>queue' = queue_\\<alpha> queue'\" \"queue_invar queue'\""], ["proof (prove)\nusing this:\n  local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n  \\<sigma> = (queue, n)\n  queue_\\<alpha> queue = t # \\<alpha>queue'\n\ngoal (1 subgoal):\n 1. (\\<And>queue'.\n        \\<lbrakk>queue_dequeue queue = (t, queue');\n         \\<alpha>queue' = queue_\\<alpha> queue'; queue_invar queue'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim: queue.removelE)"], ["proof (state)\nthis:\n  queue_dequeue queue = (t, queue')\n  \\<alpha>queue' = queue_\\<alpha> queue'\n  queue_invar queue'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       queue_\\<alpha> queue = a # list \\<Longrightarrow>\n       map_option (apsnd (apsnd round_robin_\\<alpha>))\n        (local.round_robin n0 \\<sigma> s) =\n       \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n        (state_\\<alpha> s) \\<and>\n       (case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n        | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n            local.round_robin_invar \\<sigma>\n             (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n              | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                  dom (thr_\\<alpha> (thr s)) \\<union>\n                  {t. \\<exists>x m.\n                         NewThread t x m\n                         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "from invar \\<sigma> Cons"], ["proof (chain)\npicking this:\n  local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n  \\<sigma> = (queue, n)\n  queue_\\<alpha> queue = t # \\<alpha>queue'", "have invar': \"round_robin_invar (queue_push t queue', n) (dom (thr_\\<alpha> (thr s)))\""], ["proof (prove)\nusing this:\n  local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n  \\<sigma> = (queue, n)\n  queue_\\<alpha> queue = t # \\<alpha>queue'\n\ngoal (1 subgoal):\n 1. local.round_robin_invar (queue_push t queue', n)\n     (dom (thr_\\<alpha> (thr s)))", "by(auto simp add: queue.push_correct)"], ["proof (state)\nthis:\n  local.round_robin_invar (queue_push t queue', n)\n   (dom (thr_\\<alpha> (thr s)))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       queue_\\<alpha> queue = a # list \\<Longrightarrow>\n       map_option (apsnd (apsnd round_robin_\\<alpha>))\n        (local.round_robin n0 \\<sigma> s) =\n       \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n        (state_\\<alpha> s) \\<and>\n       (case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n        | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n            local.round_robin_invar \\<sigma>\n             (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n              | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                  dom (thr_\\<alpha> (thr s)) \\<union>\n                  {t. \\<exists>x m.\n                         NewThread t x m\n                         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "from invar \\<sigma> Cons"], ["proof (chain)\npicking this:\n  local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n  \\<sigma> = (queue, n)\n  queue_\\<alpha> queue = t # \\<alpha>queue'", "have invar'': \"round_robin_invar (queue_enqueue t queue', n0) (dom (thr_\\<alpha> (thr s)))\""], ["proof (prove)\nusing this:\n  local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n  \\<sigma> = (queue, n)\n  queue_\\<alpha> queue = t # \\<alpha>queue'\n\ngoal (1 subgoal):\n 1. local.round_robin_invar (queue_enqueue t queue', n0)\n     (dom (thr_\\<alpha> (thr s)))", "by(auto simp add: queue.enqueue_correct)"], ["proof (state)\nthis:\n  local.round_robin_invar (queue_enqueue t queue', n0)\n   (dom (thr_\\<alpha> (thr s)))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       queue_\\<alpha> queue = a # list \\<Longrightarrow>\n       map_option (apsnd (apsnd round_robin_\\<alpha>))\n        (local.round_robin n0 \\<sigma> s) =\n       \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n        (state_\\<alpha> s) \\<and>\n       (case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n        | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n            local.round_robin_invar \\<sigma>\n             (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n              | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                  dom (thr_\\<alpha> (thr s)) \\<union>\n                  {t. \\<exists>x m.\n                         NewThread t x m\n                         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (local.round_robin n0 \\<sigma> s) =\n    \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) \\<and>\n    (case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "proof(cases \"round_robin_step n0 (queue_push t queue', n) s t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. round_robin_step n0 (queue_push t queue', n) s t =\n    None \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (local.round_robin n0 \\<sigma> s) =\n    \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) \\<and>\n    (case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))\n 2. \\<And>a.\n       round_robin_step n0 (queue_push t queue', n) s t =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       map_option (apsnd (apsnd round_robin_\\<alpha>))\n        (local.round_robin n0 \\<sigma> s) =\n       \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n        (state_\\<alpha> s) \\<and>\n       (case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n        | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n            local.round_robin_invar \\<sigma>\n             (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n              | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                  dom (thr_\\<alpha> (thr s)) \\<union>\n                  {t. \\<exists>x m.\n                         NewThread t x m\n                         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "case Some"], ["proof (state)\nthis:\n  round_robin_step n0 (queue_push t queue', n) s t = \\<lfloor>a_\\<rfloor>\n\ngoal (2 subgoals):\n 1. round_robin_step n0 (queue_push t queue', n) s t =\n    None \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (local.round_robin n0 \\<sigma> s) =\n    \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) \\<and>\n    (case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))\n 2. \\<And>a.\n       round_robin_step n0 (queue_push t queue', n) s t =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       map_option (apsnd (apsnd round_robin_\\<alpha>))\n        (local.round_robin n0 \\<sigma> s) =\n       \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n        (state_\\<alpha> s) \\<and>\n       (case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n        | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n            local.round_robin_invar \\<sigma>\n             (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n              | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                  dom (thr_\\<alpha> (thr s)) \\<union>\n                  {t. \\<exists>x m.\n                         NewThread t x m\n                         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "with \\<sigma> Cons invar"], ["proof (chain)\npicking this:\n  \\<sigma> = (queue, n)\n  queue_\\<alpha> queue = t # \\<alpha>queue'\n  local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n  round_robin_step n0 (queue_push t queue', n) s t = \\<lfloor>a_\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<sigma> = (queue, n)\n  queue_\\<alpha> queue = t # \\<alpha>queue'\n  local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n  round_robin_step n0 (queue_push t queue', n) s t = \\<lfloor>a_\\<rfloor>\n\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (local.round_robin n0 \\<sigma> s) =\n    \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) \\<and>\n    (case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "using round_robin_step_correct[OF det invar' \\<open>state_invar s\\<close>, of n0 t]"], ["proof (prove)\nusing this:\n  \\<sigma> = (queue, n)\n  queue_\\<alpha> queue = t # \\<alpha>queue'\n  local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n  round_robin_step n0 (queue_push t queue', n) s t = \\<lfloor>a_\\<rfloor>\n  state_\\<alpha> s \\<in> I \\<Longrightarrow>\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (round_robin_step n0 (queue_push t queue', n) s t) =\n  \\<alpha>.round_robin_step n0\n   (round_robin_\\<alpha> (queue_push t queue', n)) (state_\\<alpha> s) t\n  state_\\<alpha> s \\<in> I \\<Longrightarrow>\n  case round_robin_step n0 (queue_push t queue', n) s t of\n  None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      local.round_robin_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (local.round_robin n0 \\<sigma> s) =\n    \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) \\<and>\n    (case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "by(auto simp add: queue.isEmpty_correct queue.push_correct round_robin_\\<alpha>_def)"], ["proof (state)\nthis:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (local.round_robin n0 \\<sigma> s) =\n  \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n   (state_\\<alpha> s) \\<and>\n  (case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n   | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n       local.round_robin_invar \\<sigma>\n        (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n         | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n             dom (thr_\\<alpha> (thr s)) \\<union>\n             {t. \\<exists>x m.\n                    NewThread t x m\n                    \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (queue_push t queue', n) s t =\n    None \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (local.round_robin n0 \\<sigma> s) =\n    \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) \\<and>\n    (case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. round_robin_step n0 (queue_push t queue', n) s t =\n    None \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (local.round_robin n0 \\<sigma> s) =\n    \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) \\<and>\n    (case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "case None"], ["proof (state)\nthis:\n  round_robin_step n0 (queue_push t queue', n) s t = None\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (queue_push t queue', n) s t =\n    None \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (local.round_robin n0 \\<sigma> s) =\n    \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) \\<and>\n    (case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "from invar \\<sigma> Cons"], ["proof (chain)\npicking this:\n  local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n  \\<sigma> = (queue, n)\n  queue_\\<alpha> queue = t # \\<alpha>queue'", "have \"t \\<in> set (queue_\\<alpha> (queue_enqueue t queue'))\""], ["proof (prove)\nusing this:\n  local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n  \\<sigma> = (queue, n)\n  queue_\\<alpha> queue = t # \\<alpha>queue'\n\ngoal (1 subgoal):\n 1. t \\<in> set (queue_\\<alpha> (queue_enqueue t queue'))", "by(auto simp add: queue.enqueue_correct)"], ["proof (state)\nthis:\n  t \\<in> set (queue_\\<alpha> (queue_enqueue t queue'))\n\ngoal (1 subgoal):\n 1. round_robin_step n0 (queue_push t queue', n) s t =\n    None \\<Longrightarrow>\n    map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (local.round_robin n0 \\<sigma> s) =\n    \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) \\<and>\n    (case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "from round_robin_reschedule_correct[OF det invar'' \\<open>state_invar s\\<close>, OF \\<open>state_\\<alpha> s \\<in> I\\<close> this, of n0] None \\<sigma> Cons invar\n        round_robin_step_correct[OF det invar' \\<open>state_invar s\\<close>, of n0 t]"], ["proof (chain)\npicking this:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (round_robin_reschedule t (queue_enqueue t queue') n0 s) =\n  \\<alpha>.round_robin_reschedule t\n   (queue_\\<alpha> (queue_enqueue t queue')) n0 (state_\\<alpha> s)\n  case round_robin_reschedule t (queue_enqueue t queue') n0 s of\n  None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      local.round_robin_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n  round_robin_step n0 (queue_push t queue', n) s t = None\n  \\<sigma> = (queue, n)\n  queue_\\<alpha> queue = t # \\<alpha>queue'\n  local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n  state_\\<alpha> s \\<in> I \\<Longrightarrow>\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (round_robin_step n0 (queue_push t queue', n) s t) =\n  \\<alpha>.round_robin_step n0\n   (round_robin_\\<alpha> (queue_push t queue', n)) (state_\\<alpha> s) t\n  state_\\<alpha> s \\<in> I \\<Longrightarrow>\n  case round_robin_step n0 (queue_push t queue', n) s t of\n  None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      local.round_robin_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "show ?thesis"], ["proof (prove)\nusing this:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (round_robin_reschedule t (queue_enqueue t queue') n0 s) =\n  \\<alpha>.round_robin_reschedule t\n   (queue_\\<alpha> (queue_enqueue t queue')) n0 (state_\\<alpha> s)\n  case round_robin_reschedule t (queue_enqueue t queue') n0 s of\n  None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      local.round_robin_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n  round_robin_step n0 (queue_push t queue', n) s t = None\n  \\<sigma> = (queue, n)\n  queue_\\<alpha> queue = t # \\<alpha>queue'\n  local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n  state_\\<alpha> s \\<in> I \\<Longrightarrow>\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (round_robin_step n0 (queue_push t queue', n) s t) =\n  \\<alpha>.round_robin_step n0\n   (round_robin_\\<alpha> (queue_push t queue', n)) (state_\\<alpha> s) t\n  state_\\<alpha> s \\<in> I \\<Longrightarrow>\n  case round_robin_step n0 (queue_push t queue', n) s t of\n  None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      local.round_robin_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (local.round_robin n0 \\<sigma> s) =\n    \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) \\<and>\n    (case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         local.round_robin_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "by(auto simp add: queue.isEmpty_correct queue.push_correct round_robin_\\<alpha>_def queue.enqueue_correct)"], ["proof (state)\nthis:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (local.round_robin n0 \\<sigma> s) =\n  \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n   (state_\\<alpha> s) \\<and>\n  (case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n   | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n       local.round_robin_invar \\<sigma>\n        (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n         | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n             dom (thr_\\<alpha> (thr s)) \\<union>\n             {t. \\<exists>x m.\n                    NewThread t x m\n                    \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (local.round_robin n0 \\<sigma> s) =\n  \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n   (state_\\<alpha> s) \\<and>\n  (case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n   | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n       local.round_robin_invar \\<sigma>\n        (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n         | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n             dom (thr_\\<alpha> (thr s)) \\<union>\n             {t. \\<exists>x m.\n                    NewThread t x m\n                    \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (local.round_robin n0 \\<sigma> s) =\n  \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n   (state_\\<alpha> s) \\<and>\n  (case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n   | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n       local.round_robin_invar \\<sigma>\n        (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n         | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n             dom (thr_\\<alpha> (thr s)) \\<union>\n             {t. \\<exists>x m.\n                    NewThread t x m\n                    \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))\n\ngoal (2 subgoals):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (local.round_robin n0 \\<sigma> s) =\n    \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s)\n 2. case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        local.round_robin_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "thus ?thesis1 ?thesis2"], ["proof (prove)\nusing this:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (local.round_robin n0 \\<sigma> s) =\n  \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n   (state_\\<alpha> s) \\<and>\n  (case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n   | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n       local.round_robin_invar \\<sigma>\n        (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n         | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n             dom (thr_\\<alpha> (thr s)) \\<union>\n             {t. \\<exists>x m.\n                    NewThread t x m\n                    \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))\n\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd round_robin_\\<alpha>))\n     (local.round_robin n0 \\<sigma> s) =\n    \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) &&&\n    case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        local.round_robin_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "by simp_all"], ["proof (state)\nthis:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (local.round_robin n0 \\<sigma> s) =\n  \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>) (state_\\<alpha> s)\n  case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      local.round_robin_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma round_robin_scheduler_spec:\n  assumes det: \"\\<alpha>.deterministic I\"\n  shows \"scheduler_spec final r (round_robin n0) round_robin_invar thr_\\<alpha> thr_invar ws_\\<alpha> ws_invar is_\\<alpha> is_invar I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scheduler_spec final r (local.round_robin n0) local.round_robin_invar\n     thr_\\<alpha> thr_invar ws_\\<alpha> ws_invar is_\\<alpha> is_invar I", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<sigma> s.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s = None; state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>.active_threads (state_\\<alpha> s) = {}\n 2. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x ln n.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                            0 < ln $ n \\<and>\n                            \\<not> waiting (ws_\\<alpha> (wset s) t) \\<and>\n                            may_acquire_all (locks s) t ln\n 3. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n                            \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n 4. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)))\n 5. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "fix \\<sigma> s"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<sigma> s.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s = None; state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>.active_threads (state_\\<alpha> s) = {}\n 2. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x ln n.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                            0 < ln $ n \\<and>\n                            \\<not> waiting (ws_\\<alpha> (wset s) t) \\<and>\n                            may_acquire_all (locks s) t ln\n 3. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n                            \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n 4. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)))\n 5. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "assume rr: \"round_robin n0 \\<sigma> s = None\"\n    and invar: \"round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\" \"state_invar s\" \"state_\\<alpha> s \\<in> I\""], ["proof (state)\nthis:\n  local.round_robin n0 \\<sigma> s = None\n  local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n\ngoal (5 subgoals):\n 1. \\<And>\\<sigma> s.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s = None; state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>.active_threads (state_\\<alpha> s) = {}\n 2. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x ln n.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                            0 < ln $ n \\<and>\n                            \\<not> waiting (ws_\\<alpha> (wset s) t) \\<and>\n                            may_acquire_all (locks s) t ln\n 3. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n                            \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n 4. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)))\n 5. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "from round_robin_correct[OF det, OF invar, of n0] rr"], ["proof (chain)\npicking this:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (local.round_robin n0 \\<sigma> s) =\n  \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>) (state_\\<alpha> s)\n  case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      local.round_robin_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n  local.round_robin n0 \\<sigma> s = None", "have \"\\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>) (state_\\<alpha> s) = None\""], ["proof (prove)\nusing this:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (local.round_robin n0 \\<sigma> s) =\n  \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>) (state_\\<alpha> s)\n  case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      local.round_robin_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n  local.round_robin n0 \\<sigma> s = None\n\ngoal (1 subgoal):\n 1. \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) =\n    None", "by simp"], ["proof (state)\nthis:\n  \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n   (state_\\<alpha> s) =\n  None\n\ngoal (5 subgoals):\n 1. \\<And>\\<sigma> s.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s = None; state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>.active_threads (state_\\<alpha> s) = {}\n 2. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x ln n.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                            0 < ln $ n \\<and>\n                            \\<not> waiting (ws_\\<alpha> (wset s) t) \\<and>\n                            may_acquire_all (locks s) t ln\n 3. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n                            \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n 4. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)))\n 5. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "moreover"], ["proof (state)\nthis:\n  \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n   (state_\\<alpha> s) =\n  None\n\ngoal (5 subgoals):\n 1. \\<And>\\<sigma> s.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s = None; state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>.active_threads (state_\\<alpha> s) = {}\n 2. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x ln n.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                            0 < ln $ n \\<and>\n                            \\<not> waiting (ws_\\<alpha> (wset s) t) \\<and>\n                            may_acquire_all (locks s) t ln\n 3. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n                            \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n 4. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)))\n 5. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "from invar"], ["proof (chain)\npicking this:\n  local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I", "have \"Round_Robin.round_robin_invar (round_robin_\\<alpha> \\<sigma>) (dom (thr (state_\\<alpha> s)))\""], ["proof (prove)\nusing this:\n  local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n\ngoal (1 subgoal):\n 1. Round_Robin.round_robin_invar (round_robin_\\<alpha> \\<sigma>)\n     (dom (thr (state_\\<alpha> s)))", "by(simp add: round_robin_invar_correct)"], ["proof (state)\nthis:\n  Round_Robin.round_robin_invar (round_robin_\\<alpha> \\<sigma>)\n   (dom (thr (state_\\<alpha> s)))\n\ngoal (5 subgoals):\n 1. \\<And>\\<sigma> s.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s = None; state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>.active_threads (state_\\<alpha> s) = {}\n 2. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x ln n.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                            0 < ln $ n \\<and>\n                            \\<not> waiting (ws_\\<alpha> (wset s) t) \\<and>\n                            may_acquire_all (locks s) t ln\n 3. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n                            \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n 4. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)))\n 5. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "ultimately"], ["proof (chain)\npicking this:\n  \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n   (state_\\<alpha> s) =\n  None\n  Round_Robin.round_robin_invar (round_robin_\\<alpha> \\<sigma>)\n   (dom (thr (state_\\<alpha> s)))", "show \"\\<alpha>.active_threads (state_\\<alpha> s) = {}\""], ["proof (prove)\nusing this:\n  \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n   (state_\\<alpha> s) =\n  None\n  Round_Robin.round_robin_invar (round_robin_\\<alpha> \\<sigma>)\n   (dom (thr (state_\\<alpha> s)))\n\ngoal (1 subgoal):\n 1. \\<alpha>.active_threads (state_\\<alpha> s) = {}", "by(rule \\<alpha>.round_robin_NoneD)"], ["proof (state)\nthis:\n  \\<alpha>.active_threads (state_\\<alpha> s) = {}\n\ngoal (4 subgoals):\n 1. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x ln n.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                            0 < ln $ n \\<and>\n                            \\<not> waiting (ws_\\<alpha> (wset s) t) \\<and>\n                            may_acquire_all (locks s) t ln\n 2. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n                            \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n 3. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)))\n 4. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x ln n.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                            0 < ln $ n \\<and>\n                            \\<not> waiting (ws_\\<alpha> (wset s) t) \\<and>\n                            may_acquire_all (locks s) t ln\n 2. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n                            \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n 3. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)))\n 4. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "fix \\<sigma> s t \\<sigma>'"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x ln n.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                            0 < ln $ n \\<and>\n                            \\<not> waiting (ws_\\<alpha> (wset s) t) \\<and>\n                            may_acquire_all (locks s) t ln\n 2. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n                            \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n 3. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)))\n 4. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "assume rr: \"round_robin n0 \\<sigma> s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\"\n    and invar: \"round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\" \"state_invar s\" \"state_\\<alpha> s \\<in> I\""], ["proof (state)\nthis:\n  local.round_robin n0 \\<sigma> s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n\ngoal (4 subgoals):\n 1. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x ln n.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                            0 < ln $ n \\<and>\n                            \\<not> waiting (ws_\\<alpha> (wset s) t) \\<and>\n                            may_acquire_all (locks s) t ln\n 2. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n                            \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n 3. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)))\n 4. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "from round_robin_correct[OF det, OF invar, of n0] rr"], ["proof (chain)\npicking this:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (local.round_robin n0 \\<sigma> s) =\n  \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>) (state_\\<alpha> s)\n  case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      local.round_robin_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n  local.round_robin n0 \\<sigma> s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>", "have rr': \"\\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>) (state_\\<alpha> s) = \\<lfloor>(t, None, round_robin_\\<alpha> \\<sigma>')\\<rfloor>\""], ["proof (prove)\nusing this:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (local.round_robin n0 \\<sigma> s) =\n  \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>) (state_\\<alpha> s)\n  case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      local.round_robin_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n  local.round_robin n0 \\<sigma> s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) =\n    \\<lfloor>(t, None, round_robin_\\<alpha> \\<sigma>')\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n   (state_\\<alpha> s) =\n  \\<lfloor>(t, None, round_robin_\\<alpha> \\<sigma>')\\<rfloor>\n\ngoal (4 subgoals):\n 1. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x ln n.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                            0 < ln $ n \\<and>\n                            \\<not> waiting (ws_\\<alpha> (wset s) t) \\<and>\n                            may_acquire_all (locks s) t ln\n 2. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n                            \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n 3. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)))\n 4. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "then"], ["proof (chain)\npicking this:\n  \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n   (state_\\<alpha> s) =\n  \\<lfloor>(t, None, round_robin_\\<alpha> \\<sigma>')\\<rfloor>", "show \"\\<exists>x ln n. thr_\\<alpha> (thr s) t = \\<lfloor>(x, ln)\\<rfloor> \\<and> 0 < ln $ n \\<and> \\<not> waiting (ws_\\<alpha> (wset s) t) \\<and> may_acquire_all (locks s) t ln\""], ["proof (prove)\nusing this:\n  \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n   (state_\\<alpha> s) =\n  \\<lfloor>(t, None, round_robin_\\<alpha> \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>x ln n.\n       thr_\\<alpha> (thr s) t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       0 < ln $ n \\<and>\n       \\<not> waiting (ws_\\<alpha> (wset s) t) \\<and>\n       may_acquire_all (locks s) t ln", "by(rule \\<alpha>.round_robin_Some_NoneD[where s=\"state_\\<alpha> s\", unfolded state_\\<alpha>_conv])"], ["proof (state)\nthis:\n  \\<exists>x ln n.\n     thr_\\<alpha> (thr s) t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n     0 < ln $ n \\<and>\n     \\<not> waiting (ws_\\<alpha> (wset s) t) \\<and>\n     may_acquire_all (locks s) t ln\n\ngoal (3 subgoals):\n 1. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n                            \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n 2. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)))\n 3. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n                            \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n 2. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)))\n 3. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "fix \\<sigma> s t ta x' m' \\<sigma>'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n                            \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n 2. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)))\n 3. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "assume rr: \"round_robin n0 \\<sigma> s = \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\"\n    and invar: \"round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\" \"state_invar s\" \"state_\\<alpha> s \\<in> I\""], ["proof (state)\nthis:\n  local.round_robin n0 \\<sigma> s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n\ngoal (3 subgoals):\n 1. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n                            \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n 2. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)))\n 3. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "from round_robin_correct[OF det, OF invar, of n0] rr"], ["proof (chain)\npicking this:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (local.round_robin n0 \\<sigma> s) =\n  \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>) (state_\\<alpha> s)\n  case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      local.round_robin_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n  local.round_robin n0 \\<sigma> s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>", "have rr': \"\\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>) (state_\\<alpha> s) = \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, round_robin_\\<alpha> \\<sigma>')\\<rfloor>\""], ["proof (prove)\nusing this:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (local.round_robin n0 \\<sigma> s) =\n  \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>) (state_\\<alpha> s)\n  case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      local.round_robin_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n  local.round_robin n0 \\<sigma> s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n     (state_\\<alpha> s) =\n    \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n              round_robin_\\<alpha> \\<sigma>')\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n   (state_\\<alpha> s) =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n            round_robin_\\<alpha> \\<sigma>')\\<rfloor>\n\ngoal (3 subgoals):\n 1. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n                            \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n 2. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)))\n 3. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "thus \"\\<exists>x. thr_\\<alpha> (thr s) t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and> Predicate.eval (r t (x, shr s)) (ta, x', m') \\<and> \\<alpha>.actions_ok (state_\\<alpha> s) t ta\""], ["proof (prove)\nusing this:\n  \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n   (state_\\<alpha> s) =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n            round_robin_\\<alpha> \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       thr_\\<alpha> (thr s) t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n       \\<alpha>.actions_ok (state_\\<alpha> s) t ta", "using \\<open>state_\\<alpha> s \\<in> I\\<close>"], ["proof (prove)\nusing this:\n  \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>)\n   (state_\\<alpha> s) =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n            round_robin_\\<alpha> \\<sigma>')\\<rfloor>\n  state_\\<alpha> s \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       thr_\\<alpha> (thr s) t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n       \\<alpha>.actions_ok (state_\\<alpha> s) t ta", "by(rule \\<alpha>.round_robin_Some_SomeD[OF det, where s=\"state_\\<alpha> s\", unfolded state_\\<alpha>_conv])"], ["proof (state)\nthis:\n  \\<exists>x.\n     thr_\\<alpha> (thr s) t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n     \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n     \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n\ngoal (2 subgoals):\n 1. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)))\n 2. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)))\n 2. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "fix \\<sigma> s t \\<sigma>'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)))\n 2. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "assume rr: \"round_robin n0 \\<sigma> s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\"\n    and invar: \"round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\" \"state_invar s\" \"state_\\<alpha> s \\<in> I\""], ["proof (state)\nthis:\n  local.round_robin n0 \\<sigma> s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n\ngoal (2 subgoals):\n 1. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)))\n 2. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "from round_robin_correct[OF det, OF invar, of n0] rr"], ["proof (chain)\npicking this:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (local.round_robin n0 \\<sigma> s) =\n  \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>) (state_\\<alpha> s)\n  case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      local.round_robin_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n  local.round_robin n0 \\<sigma> s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>", "show \"round_robin_invar \\<sigma>' (dom (thr_\\<alpha> (thr s)))\""], ["proof (prove)\nusing this:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (local.round_robin n0 \\<sigma> s) =\n  \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>) (state_\\<alpha> s)\n  case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      local.round_robin_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n  local.round_robin n0 \\<sigma> s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. local.round_robin_invar \\<sigma>' (dom (thr_\\<alpha> (thr s)))", "by simp"], ["proof (state)\nthis:\n  local.round_robin_invar \\<sigma>' (dom (thr_\\<alpha> (thr s)))\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "fix \\<sigma> s t ta x' m' \\<sigma>'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "assume rr: \"round_robin n0 \\<sigma> s = \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\"\n    and invar: \"round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\" \"state_invar s\" \"state_\\<alpha> s \\<in> I\""], ["proof (state)\nthis:\n  local.round_robin n0 \\<sigma> s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.round_robin n0 \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s;\n        local.round_robin_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> local.round_robin_invar \\<sigma>'\n                          (dom (thr_\\<alpha> (thr s)) \\<union>\n                           {t. \\<exists>x m.\n                                  NewThread t x m\n                                  \\<in> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "from round_robin_correct[OF det, OF invar, of n0] rr"], ["proof (chain)\npicking this:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (local.round_robin n0 \\<sigma> s) =\n  \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>) (state_\\<alpha> s)\n  case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      local.round_robin_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n  local.round_robin n0 \\<sigma> s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>", "show \"round_robin_invar \\<sigma>' (dom (thr_\\<alpha> (thr s)) \\<union> {t. \\<exists>x m. NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\""], ["proof (prove)\nusing this:\n  map_option (apsnd (apsnd round_robin_\\<alpha>))\n   (local.round_robin n0 \\<sigma> s) =\n  \\<alpha>.round_robin n0 (round_robin_\\<alpha> \\<sigma>) (state_\\<alpha> s)\n  case local.round_robin n0 \\<sigma> s of None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      local.round_robin_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n  local.round_robin n0 \\<sigma> s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. local.round_robin_invar \\<sigma>'\n     (dom (thr_\\<alpha> (thr s)) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "by simp"], ["proof (state)\nthis:\n  local.round_robin_invar \\<sigma>'\n   (dom (thr_\\<alpha> (thr s)) \\<union>\n    {t. \\<exists>x m.\n           NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma round_robin_start_invar:\n  \"round_robin_invar (round_robin_start n0 t0) {t0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.round_robin_invar (round_robin_start n0 t0) {t0}", "by(simp add: round_robin_start_def queue.empty_correct queue.enqueue_correct)"], ["", "end"], ["", "sublocale round_robin_base <\n  scheduler_base\n    final r convert_RA\n    \"round_robin n0\" \"output\" \"pick_wakeup_via_sel (\\<lambda>s P. ws_sel s (\\<lambda>(k,v). P k v))\" round_robin_invar\n    thr_\\<alpha> thr_invar thr_lookup thr_update\n    ws_\\<alpha> ws_invar ws_lookup ws_update ws_delete ws_iterate\n    is_\\<alpha> is_invar is_memb is_ins is_delete\n  for n0"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sublocale round_robin <\n  pick_wakeup_spec\n    final r convert_RA\n    \"pick_wakeup_via_sel (\\<lambda>s P. ws_sel s (\\<lambda>(k,v). P k v))\" round_robin_invar\n    thr_\\<alpha> thr_invar\n    ws_\\<alpha> ws_invar\n    is_\\<alpha> is_invar"], ["proof (prove)\ngoal (1 subgoal):\n 1. pick_wakeup_spec\n     (pick_wakeup_via_sel (\\<lambda>s P. ws_sel s (\\<lambda>(k, v). P k v)))\n     local.round_robin_invar ws_\\<alpha> ws_invar", "by(rule pick_wakeup_spec_via_sel)(unfold_locales)"], ["", "context round_robin begin"], ["", "lemma round_robin_scheduler:\n  assumes det: \"\\<alpha>.deterministic I\"\n  shows \n  \"scheduler\n     final r convert_RA\n     (round_robin n0) (pick_wakeup_via_sel (\\<lambda>s P. ws_sel s (\\<lambda>(k,v). P k v))) round_robin_invar \n     thr_\\<alpha> thr_invar thr_lookup thr_update \n     ws_\\<alpha> ws_invar ws_lookup ws_update ws_delete ws_iterate\n     is_\\<alpha> is_invar is_memb is_ins is_delete\n     I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scheduler final r convert_RA (local.round_robin n0)\n     (pick_wakeup_via_sel (\\<lambda>s P. ws_sel s (\\<lambda>(k, v). P k v)))\n     local.round_robin_invar thr_\\<alpha> thr_invar thr_lookup thr_update\n     ws_\\<alpha> ws_invar ws_lookup ws_update ws_delete ws_iterate\n     is_\\<alpha> is_invar is_memb is_ins is_delete I", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. scheduler final r convert_RA (local.round_robin n0)\n     (pick_wakeup_via_sel (\\<lambda>s P. ws_sel s (\\<lambda>(k, v). P k v)))\n     local.round_robin_invar thr_\\<alpha> thr_invar thr_lookup thr_update\n     ws_\\<alpha> ws_invar ws_lookup ws_update ws_delete ws_iterate\n     is_\\<alpha> is_invar is_memb is_ins is_delete I", "interpret scheduler_spec\n      final r convert_RA\n      \"round_robin n0\" round_robin_invar\n      thr_\\<alpha> thr_invar\n      ws_\\<alpha> ws_invar\n      is_\\<alpha> is_invar\n      I"], ["proof (prove)\ngoal (1 subgoal):\n 1. scheduler_spec final r (local.round_robin n0) local.round_robin_invar\n     thr_\\<alpha> thr_invar ws_\\<alpha> ws_invar is_\\<alpha> is_invar I", "using det"], ["proof (prove)\nusing this:\n  \\<alpha>.deterministic I\n\ngoal (1 subgoal):\n 1. scheduler_spec final r (local.round_robin n0) local.round_robin_invar\n     thr_\\<alpha> thr_invar ws_\\<alpha> ws_invar is_\\<alpha> is_invar I", "by(rule round_robin_scheduler_spec)"], ["proof (state)\ngoal (1 subgoal):\n 1. scheduler final r convert_RA (local.round_robin n0)\n     (pick_wakeup_via_sel (\\<lambda>s P. ws_sel s (\\<lambda>(k, v). P k v)))\n     local.round_robin_invar thr_\\<alpha> thr_invar thr_lookup thr_update\n     ws_\\<alpha> ws_invar ws_lookup ws_update ws_delete ws_iterate\n     is_\\<alpha> is_invar is_memb is_ins is_delete I", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. scheduler final r convert_RA (local.round_robin n0)\n     (pick_wakeup_via_sel (\\<lambda>s P. ws_sel s (\\<lambda>(k, v). P k v)))\n     local.round_robin_invar thr_\\<alpha> thr_invar thr_lookup thr_update\n     ws_\\<alpha> ws_invar ws_lookup ws_update ws_delete ws_iterate\n     is_\\<alpha> is_invar is_memb is_ins is_delete I", "by(unfold_locales)(rule \\<alpha>.deterministic_invariant3p[OF det])"], ["proof (state)\nthis:\n  scheduler final r convert_RA (local.round_robin n0)\n   (pick_wakeup_via_sel (\\<lambda>s P. ws_sel s (\\<lambda>(k, v). P k v)))\n   local.round_robin_invar thr_\\<alpha> thr_invar thr_lookup thr_update\n   ws_\\<alpha> ws_invar ws_lookup ws_update ws_delete ws_iterate is_\\<alpha>\n   is_invar is_memb is_ins is_delete I\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemmas [code] =\n  round_robin_base.queue_rotate1_def\n  round_robin_base.enqueue_new_thread.simps\n  round_robin_base.enqueue_new_threads_def\n  round_robin_base.round_robin_update_state.simps\n  round_robin_base.round_robin_reschedule.simps\n  round_robin_base.round_robin.simps\n  round_robin_base.round_robin_start_def"], ["", "end"]]}