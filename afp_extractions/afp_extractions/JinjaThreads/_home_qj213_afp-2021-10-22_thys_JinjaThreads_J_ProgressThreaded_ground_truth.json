{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/J/ProgressThreaded.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma lock_ok_ls_Some_ex_ts_not_final:\n  assumes lock: \"lock_ok ls ts\"\n  and hl: \"has_lock (ls $ l) t\"\n  shows \"\\<exists>e x ln. ts t = \\<lfloor>((e, x), ln)\\<rfloor> \\<and> \\<not> final e\"", "lemma assumes wf: \"wf_J_prog P\"\n  shows red_def_ass_new_thread:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; NewThread t'' (e'', x'') c'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk> \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\"\n  \n  and reds_def_ass_new_thread:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; NewThread t'' (e'', x'') c'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk> \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\"", "lemma lifting_wf_def_ass: \"wf_J_prog P \\<Longrightarrow> lifting_wf final_expr (mred P) (\\<lambda>t (e, x) m. \\<D> e \\<lfloor>dom x\\<rfloor>)\"", "lemma def_ass_ts_ok_J_start_state:\n  \"\\<lbrakk> wf_J_prog P; P \\<turnstile> C sees M:Ts\\<rightarrow>T = \\<lfloor>(pns, body)\\<rfloor> in D; length vs = length Ts \\<rbrakk> \\<Longrightarrow>\n  def_ass_ts_ok (thr (J_start_state P C M vs)) h\"", "lemma fixes E :: env\n  assumes wf: \"wf_J_prog P\"\n  shows red_type_newthread:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; P,E,hp s \\<turnstile> e : T; NewThread t'' (e'', x'') (hp s') \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> \\<exists>E T. P,E,hp s' \\<turnstile> e'' : T \\<and> P,hp s' \\<turnstile> x'' (:\\<le>) E\"\n  and reds_type_newthread:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; NewThread t'' (e'', x'') (hp s') \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>; P,E,hp s \\<turnstile> es [:] Ts \\<rbrakk>\n  \\<Longrightarrow> \\<exists>E T. P,E,hp s' \\<turnstile> e'' : T \\<and> P,hp s' \\<turnstile> x'' (:\\<le>) E\"", "lemma ts_inv_ok_J_sconf_type_ET_start:\n  \"ts_inv_ok (thr (J_start_state P C M vs)) (J_sconf_type_ET_start P C M)\"", "lemma (in J_heap) red_preserve_welltype:\n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>e, (h, x)\\<rangle> -ta\\<rightarrow> \\<langle>e', (h', x')\\<rangle>; P,E,h \\<turnstile> e'' : T \\<rbrakk> \\<Longrightarrow> P,E,h' \\<turnstile> e'' : T\"", "lemma sconf_type_ts_ok_J_start_state:\n  \"\\<lbrakk> wf_J_prog P; wf_start_state P C M vs \\<rbrakk>\n  \\<Longrightarrow> sconf_type_ts_ok (J_sconf_type_ET_start P C M) (thr (J_start_state P C M vs)) (shr (J_start_state P C M vs))\"", "lemma J_start_state_sconf_type_ok:\n  assumes wf: \"wf_J_prog P\"\n  and ok: \"wf_start_state P C M vs\"\n  shows \"ts_ok (\\<lambda>t x h. \\<exists>ET. sconf_type_ok ET t x h) (thr (J_start_state P C M vs)) start_heap\"", "lemma red_preserves_type_ok: \n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow> \\<langle>e',s'\\<rangle>; wf_J_prog P; E \\<turnstile> s \\<surd>; type_ok P (E, T) e (hp s); P,hp s \\<turnstile> t \\<surd>t \\<rbrakk> \\<Longrightarrow> type_ok P (E, T) e' (hp s')\"", "lemma lifting_inv_sconf_subject_ok:\n  assumes wf: \"wf_J_prog P\"\n  shows \"lifting_inv final_expr (mred P) sconf_type_ok\"", "lemma assumes wf: \"wf_prog wf_md P\"\n  shows red_wf_red_aux:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e',s'\\<rangle>; \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta; \n    sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n     \\<forall>l. has_locks (ls $ l) t \\<ge> expr_locks e l;\n     ws t = None \\<or> \n     (\\<exists>a vs w T Ts Tr D. call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and> typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and> P \\<turnstile> class_type_of T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and> ws t = \\<lfloor>PostWS w\\<rfloor>) \\<rbrakk>\n    \\<Longrightarrow> \\<exists>e'' s'' ta'. P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta'\\<rightarrow> \\<langle>e'',s''\\<rangle> \\<and> \n        (red_mthr.actions_ok (ls, (ts, m), ws, is) t ta' \\<or> \n         red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta' \\<and> red_mthr.actions_subset ta' ta)\"\n  (is \"\\<lbrakk> _; _; _; _; _; _; ?wakeup e s \\<rbrakk> \\<Longrightarrow> ?concl e s ta\")\n    and reds_wf_red_aux:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es',s'\\<rangle>; \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n     sync_oks es; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n     \\<forall>l. has_locks (ls $ l) t \\<ge> expr_lockss es l;\n     ws t = None \\<or> \n     (\\<exists>a vs w T Ts T Tr D. calls es = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and> typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and> P \\<turnstile> class_type_of T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and> ws t = \\<lfloor>PostWS w\\<rfloor>) \\<rbrakk>\n    \\<Longrightarrow> \\<exists>es'' s'' ta'. P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta'\\<rightarrow>] \\<langle>es'',s''\\<rangle> \\<and> \n        (red_mthr.actions_ok (ls, (ts, m), ws, is) t ta' \\<or> \n         red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta' \\<and> red_mthr.actions_subset ta' ta)\"", "lemma shows red_ta_satisfiable:\n  \"P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle> \\<Longrightarrow> \\<exists>s. red_mthr.actions_ok s t ta\"\n  and reds_ta_satisfiable:\n  \"P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle> \\<Longrightarrow> \\<exists>s. red_mthr.actions_ok s t ta\"", "lemma wf_progress: \n  assumes wf: \"wf_J_prog P\"\n  shows \"progress final_expr (mred P)\n            (red_mthr.wset_Suspend_ok P ({s. sync_es_ok (thr s) (shr s) \\<and> lock_ok (locks s) (thr s)} \\<inter> {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter> {s. def_ass_ts_ok (thr s) (shr s)}))\"\n  (is \"progress _ _ ?wf_state\")", "lemma redT_progress_deadlock:\n  assumes wf: \"wf_J_prog P\"\n  and wf_start: \"wf_start_state P C M vs\"\n  and Red: \"P \\<turnstile> J_start_state P C M vs -\\<triangleright>ttas\\<rightarrow>* s\"\n  and ndead: \"\\<not> red_mthr.deadlock P s\"\n  shows \"\\<exists>t' ta' s'. P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow> s'\"", "lemma redT_progress_deadlocked:\n  assumes wf: \"wf_J_prog P\" \n  and wf_start: \"wf_start_state P C M vs\"\n  and Red: \"P \\<turnstile> J_start_state P C M vs -\\<triangleright>ttas\\<rightarrow>* s\"\n  and ndead:  \"red_mthr.not_final_thread s t\" \"\\<not> t \\<in> red_mthr.deadlocked P s\"\n  shows \"\\<exists>t' ta' s'. P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow> s'\"", "theorem TypeSafetyT:\n  fixes C and M and ttas and Es\n  defines \"Es  == J_sconf_type_ET_start P C M\"\n  and     \"Es' == upd_invs Es sconf_type_ok (concat (map (thr_a \\<circ> snd) ttas))\"\n  assumes wf: \"wf_J_prog P\"\n  and start_wf: \"wf_start_state P C M vs\"\n  and RedT: \"P \\<turnstile> J_start_state P C M vs -\\<triangleright>ttas\\<rightarrow>* s'\"\n  and nored: \"\\<not> (\\<exists>t ta s''. P \\<turnstile> s' -t\\<triangleright>ta\\<rightarrow> s'')\"\n  shows \"thread_conf P (thr s') (shr s')\"\n  and \"thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n       (\\<exists>v. e' = Val v \\<and> (\\<exists>E T. Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and> P,shr s' \\<turnstile> v :\\<le> T) \\<and> ln' = no_wait_locks)\n       \\<or> (\\<exists>a C. e' = Throw a \\<and> typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and> ln' = no_wait_locks)\n       \\<or> (t \\<in> red_mthr.deadlocked P s' \\<and> (\\<exists>E T. Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and> (\\<exists>T'. P,E,shr s' \\<turnstile> e' : T' \\<and> P \\<turnstile> T' \\<le> T)))\"\n     (is \"_ \\<Longrightarrow> ?thesis2\")\n  and \"Es \\<subseteq>\\<^sub>m Es'\""], "translations": [["", "lemma lock_ok_ls_Some_ex_ts_not_final:\n  assumes lock: \"lock_ok ls ts\"\n  and hl: \"has_lock (ls $ l) t\"\n  shows \"\\<exists>e x ln. ts t = \\<lfloor>((e, x), ln)\\<rfloor> \\<and> \\<not> final e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e x ln.\n       ts t = \\<lfloor>((e, x), ln)\\<rfloor> \\<and> \\<not> final e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>e x ln.\n       ts t = \\<lfloor>((e, x), ln)\\<rfloor> \\<and> \\<not> final e", "from lock"], ["proof (chain)\npicking this:\n  lock_ok ls ts", "have \"lock_thread_ok ls ts\""], ["proof (prove)\nusing this:\n  lock_ok ls ts\n\ngoal (1 subgoal):\n 1. lock_thread_ok ls ts", "by(rule lock_ok_lock_thread_ok)"], ["proof (state)\nthis:\n  lock_thread_ok ls ts\n\ngoal (1 subgoal):\n 1. \\<exists>e x ln.\n       ts t = \\<lfloor>((e, x), ln)\\<rfloor> \\<and> \\<not> final e", "with hl"], ["proof (chain)\npicking this:\n  has_lock (ls $ l) t\n  lock_thread_ok ls ts", "obtain e x ln\n    where tst: \"ts t = \\<lfloor>((e, x), ln)\\<rfloor>\""], ["proof (prove)\nusing this:\n  has_lock (ls $ l) t\n  lock_thread_ok ls ts\n\ngoal (1 subgoal):\n 1. (\\<And>e x ln.\n        ts t = \\<lfloor>((e, x), ln)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto dest!: lock_thread_okD)"], ["proof (state)\nthis:\n  ts t = \\<lfloor>((e, x), ln)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>e x ln.\n       ts t = \\<lfloor>((e, x), ln)\\<rfloor> \\<and> \\<not> final e", "{"], ["proof (state)\nthis:\n  ts t = \\<lfloor>((e, x), ln)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>e x ln.\n       ts t = \\<lfloor>((e, x), ln)\\<rfloor> \\<and> \\<not> final e", "assume \"final e\""], ["proof (state)\nthis:\n  final e\n\ngoal (1 subgoal):\n 1. \\<exists>e x ln.\n       ts t = \\<lfloor>((e, x), ln)\\<rfloor> \\<and> \\<not> final e", "hence \"expr_locks e l = 0\""], ["proof (prove)\nusing this:\n  final e\n\ngoal (1 subgoal):\n 1. expr_locks e l = 0", "by(rule final_locks)"], ["proof (state)\nthis:\n  expr_locks e l = 0\n\ngoal (1 subgoal):\n 1. \\<exists>e x ln.\n       ts t = \\<lfloor>((e, x), ln)\\<rfloor> \\<and> \\<not> final e", "with lock tst"], ["proof (chain)\npicking this:\n  lock_ok ls ts\n  ts t = \\<lfloor>((e, x), ln)\\<rfloor>\n  expr_locks e l = 0", "have \"has_locks (ls $ l) t = 0\""], ["proof (prove)\nusing this:\n  lock_ok ls ts\n  ts t = \\<lfloor>((e, x), ln)\\<rfloor>\n  expr_locks e l = 0\n\ngoal (1 subgoal):\n 1. has_locks (ls $ l) t = 0", "by(auto dest: lock_okD2[rule_format, where l=l])"], ["proof (state)\nthis:\n  has_locks (ls $ l) t = 0\n\ngoal (1 subgoal):\n 1. \\<exists>e x ln.\n       ts t = \\<lfloor>((e, x), ln)\\<rfloor> \\<and> \\<not> final e", "with hl"], ["proof (chain)\npicking this:\n  has_lock (ls $ l) t\n  has_locks (ls $ l) t = 0", "have False"], ["proof (prove)\nusing this:\n  has_lock (ls $ l) t\n  has_locks (ls $ l) t = 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>e x ln.\n       ts t = \\<lfloor>((e, x), ln)\\<rfloor> \\<and> \\<not> final e", "}"], ["proof (state)\nthis:\n  final e \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<exists>e x ln.\n       ts t = \\<lfloor>((e, x), ln)\\<rfloor> \\<and> \\<not> final e", "with tst"], ["proof (chain)\npicking this:\n  ts t = \\<lfloor>((e, x), ln)\\<rfloor>\n  final e \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  ts t = \\<lfloor>((e, x), ln)\\<rfloor>\n  final e \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<exists>e x ln.\n       ts t = \\<lfloor>((e, x), ln)\\<rfloor> \\<and> \\<not> final e", "by auto"], ["proof (state)\nthis:\n  \\<exists>e x ln.\n     ts t = \\<lfloor>((e, x), ln)\\<rfloor> \\<and> \\<not> final e\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Preservation lemmata\\<close>"], ["", "subsection \\<open>Definite assignment\\<close>"], ["", "abbreviation\n  def_ass_ts_ok :: \"('addr,'thread_id,'addr expr \\<times> 'addr locals) thread_info \\<Rightarrow> 'heap \\<Rightarrow> bool\"\nwhere\n  \"def_ass_ts_ok \\<equiv> ts_ok (\\<lambda>t (e, x) h. \\<D> e \\<lfloor>dom x\\<rfloor>)\""], ["", "context J_heap_base begin"], ["", "lemma assumes wf: \"wf_J_prog P\"\n  shows red_def_ass_new_thread:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; NewThread t'' (e'', x'') c'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk> \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\"\n  \n  and reds_def_ass_new_thread:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; NewThread t'' (e'', x'') c'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk> \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>extTA2J\n               P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle>;\n      NewThread t'' (e'', x'') c''\n      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n     \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>) &&&\n    (\\<lbrakk>extTA2J\n               P,P,t \\<turnstile> \\<langle>es,s\\<rangle> [-ta\\<rightarrow>]\n                                  \\<langle>es',s'\\<rangle>;\n      NewThread t'' (e'', x'') c''\n      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n     \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>)", "proof(induct rule: red_reds.inducts)"], ["proof (state)\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Class_type\n C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        \\<D> e'' \\<lfloor>dom x''\\<rfloor>;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Array_type T\n (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        \\<D> e'' \\<lfloor>dom x''\\<rfloor>;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         NewThread t'' (e'', x'') c''\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n         \\<D> e'' \\<lfloor>dom x''\\<rfloor>;\n         NewThread t'' (e'', x'') c''\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\nA total of 98 subgoals...", "case (RedCallExternal s a T M vs ta va h' ta' e' s')"], ["proof (state)\nthis:\n  typeof_addr (hp s) a = \\<lfloor>T\\<rfloor>\n  P \\<turnstile> class_type_of T sees M: vs\\<rightarrow>ta = Native in va\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(h'),\n                   hp s\\<rangle> -ta'\\<rightarrow>ext \\<langle>e',\n                s'\\<rangle>\n  ta'_ = extTA2J P ta'\n  e'_ = extRet2J (addr a\\<bullet>M(map Val h')) e'\n  s'_ = (s', lcl s)\n  NewThread t'' (e'', x'') c''\n  \\<in> set \\<lbrace>ta'_\\<rbrace>\\<^bsub>t\\<^esub>\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Class_type\n C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        \\<D> e'' \\<lfloor>dom x''\\<rfloor>;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Array_type T\n (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        \\<D> e'' \\<lfloor>dom x''\\<rfloor>;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         NewThread t'' (e'', x'') c''\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n         \\<D> e'' \\<lfloor>dom x''\\<rfloor>;\n         NewThread t'' (e'', x'') c''\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\nA total of 98 subgoals...", "then"], ["proof (chain)\npicking this:\n  typeof_addr (hp s) a = \\<lfloor>T\\<rfloor>\n  P \\<turnstile> class_type_of T sees M: vs\\<rightarrow>ta = Native in va\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(h'),\n                   hp s\\<rangle> -ta'\\<rightarrow>ext \\<langle>e',\n                s'\\<rangle>\n  ta'_ = extTA2J P ta'\n  e'_ = extRet2J (addr a\\<bullet>M(map Val h')) e'\n  s'_ = (s', lcl s)\n  NewThread t'' (e'', x'') c''\n  \\<in> set \\<lbrace>ta'_\\<rbrace>\\<^bsub>t\\<^esub>", "obtain C fs a where subThread: \"P \\<turnstile> C \\<preceq>\\<^sup>* Thread\" and ext: \"extNTA2J P (C, run, a) = (e'', x'')\""], ["proof (prove)\nusing this:\n  typeof_addr (hp s) a = \\<lfloor>T\\<rfloor>\n  P \\<turnstile> class_type_of T sees M: vs\\<rightarrow>ta = Native in va\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(h'),\n                   hp s\\<rangle> -ta'\\<rightarrow>ext \\<langle>e',\n                s'\\<rangle>\n  ta'_ = extTA2J P ta'\n  e'_ = extRet2J (addr a\\<bullet>M(map Val h')) e'\n  s'_ = (s', lcl s)\n  NewThread t'' (e'', x'') c''\n  \\<in> set \\<lbrace>ta'_\\<rbrace>\\<^bsub>t\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>C a.\n        \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* Thread;\n         extNTA2J P (C, run, a) = (e'', x'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest: red_external_new_thread_sub_thread)"], ["proof (state)\nthis:\n  P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n  extNTA2J P (C, run, a) = (e'', x'')\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Class_type\n C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        \\<D> e'' \\<lfloor>dom x''\\<rfloor>;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Array_type T\n (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        \\<D> e'' \\<lfloor>dom x''\\<rfloor>;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         NewThread t'' (e'', x'') c''\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n         \\<D> e'' \\<lfloor>dom x''\\<rfloor>;\n         NewThread t'' (e'', x'') c''\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\nA total of 98 subgoals...", "from sub_Thread_sees_run[OF wf subThread]"], ["proof (chain)\npicking this:\n  \\<exists>D mthd.\n     P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>mthd\\<rfloor> in D", "obtain D pns body\n    where sees: \"P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>(pns, body)\\<rfloor> in D\""], ["proof (prove)\nusing this:\n  \\<exists>D mthd.\n     P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>mthd\\<rfloor> in D\n\ngoal (1 subgoal):\n 1. (\\<And>pns body D.\n        P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>(pns,\n                             body)\\<rfloor> in D \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>(pns,\n                       body)\\<rfloor> in D\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Class_type\n C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        \\<D> e'' \\<lfloor>dom x''\\<rfloor>;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Array_type T\n (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        \\<D> e'' \\<lfloor>dom x''\\<rfloor>;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         NewThread t'' (e'', x'') c''\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n         \\<D> e'' \\<lfloor>dom x''\\<rfloor>;\n         NewThread t'' (e'', x'') c''\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\nA total of 98 subgoals...", "from sees_wf_mdecl[OF wf this]"], ["proof (chain)\npicking this:\n  wf_mdecl wf_J_mdecl P D (run, [], Void, \\<lfloor>(pns, body)\\<rfloor>)", "have \"\\<D> body \\<lfloor>{this}\\<rfloor>\""], ["proof (prove)\nusing this:\n  wf_mdecl wf_J_mdecl P D (run, [], Void, \\<lfloor>(pns, body)\\<rfloor>)\n\ngoal (1 subgoal):\n 1. \\<D> body \\<lfloor>{this}\\<rfloor>", "by(auto simp add: wf_mdecl_def)"], ["proof (state)\nthis:\n  \\<D> body \\<lfloor>{this}\\<rfloor>\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Class_type\n C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        \\<D> e'' \\<lfloor>dom x''\\<rfloor>;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Array_type T\n (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        \\<D> e'' \\<lfloor>dom x''\\<rfloor>;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         NewThread t'' (e'', x'') c''\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n         \\<D> e'' \\<lfloor>dom x''\\<rfloor>;\n         NewThread t'' (e'', x'') c''\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\nA total of 98 subgoals...", "with sees ext"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>(pns,\n                       body)\\<rfloor> in D\n  extNTA2J P (C, run, a) = (e'', x'')\n  \\<D> body \\<lfloor>{this}\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>(pns,\n                       body)\\<rfloor> in D\n  extNTA2J P (C, run, a) = (e'', x'')\n  \\<D> body \\<lfloor>{this}\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<D> e'' \\<lfloor>dom x''\\<rfloor>", "by(clarsimp simp del: fun_upd_apply)"], ["proof (state)\nthis:\n  \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n\ngoal (97 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Class_type\n C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        \\<D> e'' \\<lfloor>dom x''\\<rfloor>;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Array_type T\n (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        \\<D> e'' \\<lfloor>dom x''\\<rfloor>;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        NewThread t'' (e'', x'') c''\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         NewThread t'' (e'', x'') c''\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n         \\<D> e'' \\<lfloor>dom x''\\<rfloor>;\n         NewThread t'' (e'', x'') c''\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> \\<D> e'' \\<lfloor>dom x''\\<rfloor>\nA total of 97 subgoals...", "qed(auto simp add: ta_upd_simps)"], ["", "lemma lifting_wf_def_ass: \"wf_J_prog P \\<Longrightarrow> lifting_wf final_expr (mred P) (\\<lambda>t (e, x) m. \\<D> e \\<lfloor>dom x\\<rfloor>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_J_prog P \\<Longrightarrow>\n    lifting_wf final_expr\n     (\\<lambda>t ((e, l), h) ta ((e', l'), h').\n         extTA2J\n          P,P,t \\<turnstile> \\<langle>e,(h, l)\\<rangle> -ta\\<rightarrow>\n                             \\<langle>e',(h', l')\\<rangle>)\n     (\\<lambda>t (e, x) m. \\<D> e \\<lfloor>dom x\\<rfloor>)", "apply(unfold_locales)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>t x m ta x' m'.\n       \\<lbrakk>wf_J_prog P; red_mthr.r_syntax P t x m ta x' m';\n        (case x of\n         (e, x) \\<Rightarrow> \\<lambda>m. \\<D> e \\<lfloor>dom x\\<rfloor>)\n         m\\<rbrakk>\n       \\<Longrightarrow> (case x' of\n                          (e, x) \\<Rightarrow>\n                            \\<lambda>m. \\<D> e \\<lfloor>dom x\\<rfloor>)\n                          m'\n 2. \\<And>t x m ta x' m' t'' x''.\n       \\<lbrakk>wf_J_prog P; red_mthr.r_syntax P t x m ta x' m';\n        (case x of\n         (e, x) \\<Rightarrow> \\<lambda>m. \\<D> e \\<lfloor>dom x\\<rfloor>)\n         m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> (case x'' of\n                          (e, x) \\<Rightarrow>\n                            \\<lambda>m. \\<D> e \\<lfloor>dom x\\<rfloor>)\n                          m'\n 3. \\<And>t x m ta x' m' t'' x''.\n       \\<lbrakk>wf_J_prog P; red_mthr.r_syntax P t x m ta x' m';\n        (case x of\n         (e, x) \\<Rightarrow> \\<lambda>m. \\<D> e \\<lfloor>dom x\\<rfloor>)\n         m;\n        (case x'' of\n         (e, x) \\<Rightarrow> \\<lambda>m. \\<D> e \\<lfloor>dom x\\<rfloor>)\n         m\\<rbrakk>\n       \\<Longrightarrow> (case x'' of\n                          (e, x) \\<Rightarrow>\n                            \\<lambda>m. \\<D> e \\<lfloor>dom x\\<rfloor>)\n                          m'", "apply(auto dest: red_preserves_defass red_def_ass_new_thread)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma def_ass_ts_ok_J_start_state:\n  \"\\<lbrakk> wf_J_prog P; P \\<turnstile> C sees M:Ts\\<rightarrow>T = \\<lfloor>(pns, body)\\<rfloor> in D; length vs = length Ts \\<rbrakk> \\<Longrightarrow>\n  def_ass_ts_ok (thr (J_start_state P C M vs)) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_J_prog P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                     body)\\<rfloor> in D;\n     length vs = length Ts\\<rbrakk>\n    \\<Longrightarrow> def_ass_ts_ok\n                       (thr (start_state J_local_start P C M vs)) h", "apply(rule ts_okI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t x ln.\n       \\<lbrakk>wf_J_prog P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                        body)\\<rfloor> in D;\n        length vs = length Ts;\n        thr (start_state J_local_start P C M vs) t =\n        \\<lfloor>(x, ln)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (e, x) \\<Rightarrow>\n                            \\<lambda>h. \\<D> e \\<lfloor>dom x\\<rfloor>)\n                          h", "apply(drule (1) sees_wf_mdecl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t x ln.\n       \\<lbrakk>P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                                body)\\<rfloor> in D;\n        length vs = length Ts;\n        thr (start_state J_local_start P C M vs) t =\n        \\<lfloor>(x, ln)\\<rfloor>;\n        wf_mdecl wf_J_mdecl P D\n         (M, Ts, T, \\<lfloor>(pns, body)\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (e, x) \\<Rightarrow>\n                            \\<lambda>h. \\<D> e \\<lfloor>dom x\\<rfloor>)\n                          h", "apply(clarsimp simp add: wf_mdecl_def start_state_def split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsection \\<open>typeability\\<close>"], ["", "context J_heap_base begin"], ["", "definition type_ok :: \"'addr J_prog \\<Rightarrow> env \\<times> ty \\<Rightarrow> 'addr expr \\<Rightarrow> 'heap \\<Rightarrow> bool\"\nwhere \"type_ok P \\<equiv> (\\<lambda>(E, T) e c. (\\<exists>T'. (P,E,c \\<turnstile> e : T' \\<and> P \\<turnstile> T' \\<le> T)))\""], ["", "definition J_sconf_type_ET_start :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> mname \\<Rightarrow> ('thread_id \\<rightharpoonup> (env \\<times> ty))\"\nwhere\n  \"J_sconf_type_ET_start P C M \\<equiv>\n   let (_, _, T, _) = method P C M\n   in ([start_tid \\<mapsto> (Map.empty, T)])\""], ["", "lemma fixes E :: env\n  assumes wf: \"wf_J_prog P\"\n  shows red_type_newthread:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; P,E,hp s \\<turnstile> e : T; NewThread t'' (e'', x'') (hp s') \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> \\<exists>E T. P,E,hp s' \\<turnstile> e'' : T \\<and> P,hp s' \\<turnstile> x'' (:\\<le>) E\"\n  and reds_type_newthread:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; NewThread t'' (e'', x'') (hp s') \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>; P,E,hp s \\<turnstile> es [:] Ts \\<rbrakk>\n  \\<Longrightarrow> \\<exists>E T. P,E,hp s' \\<turnstile> e'' : T \\<and> P,hp s' \\<turnstile> x'' (:\\<le>) E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>extTA2J\n               P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle>;\n      P,E,hp s \\<turnstile> e : T;\n      NewThread t'' (e'', x'') (hp s')\n      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n     \\<Longrightarrow> \\<exists>E T.\n                          P,E,hp s' \\<turnstile> e'' : T \\<and>\n                          P,hp s' \\<turnstile> x'' (:\\<le>) E) &&&\n    (\\<lbrakk>extTA2J\n               P,P,t \\<turnstile> \\<langle>es,s\\<rangle> [-ta\\<rightarrow>]\n                                  \\<langle>es',s'\\<rangle>;\n      NewThread t'' (e'', x'') (hp s')\n      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n      P,E,hp s \\<turnstile> es [:] Ts\\<rbrakk>\n     \\<Longrightarrow> \\<exists>E T.\n                          P,E,hp s' \\<turnstile> e'' : T \\<and>\n                          P,hp s' \\<turnstile> x'' (:\\<le>) E)", "proof(induct arbitrary: E T and E Ts rule: red_reds.inducts)"], ["proof (state)\ngoal (98 subgoals):\n 1. \\<And>h' a h C l E T.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        P,E,hp (h, l) \\<turnstile> new C : T;\n        NewThread t'' (e'', x'') (hp (h', l))\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Class_type\n C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h', l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h', l) \\<turnstile> x'' (:\\<le>) E\n 2. \\<And>h C l E T.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        P,E,hp (h, l) \\<turnstile> new C : T;\n        NewThread t'' (e'', x'') (hp (h, l))\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h, l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h, l) \\<turnstile> x'' (:\\<le>) E\n 3. \\<And>e s ta e' s' T E Ta.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<And>E T.\n           \\<lbrakk>P,E,hp s \\<turnstile> e : T;\n            NewThread t'' (e'', x'') (hp s')\n            \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>E T.\n                                P,E,hp s' \\<turnstile> e'' : T \\<and>\n                                P,hp s' \\<turnstile> x'' (:\\<le>) E;\n        P,E,hp s \\<turnstile> newA T\\<lfloor>e\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp s')\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s' \\<turnstile> e'' : T \\<and>\n                            P,hp s' \\<turnstile> x'' (:\\<le>) E\n 4. \\<And>i h' a h T l E Ta.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        P,E,hp (h, l) \\<turnstile> newA T\\<lfloor>Val (Intg i)\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp (h', l))\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Array_type T\n (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h', l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h', l) \\<turnstile> x'' (:\\<le>) E\n 5. \\<And>i T s E Ta.\n       \\<lbrakk>i <s 0;\n        P,E,hp s \\<turnstile> newA T\\<lfloor>Val (Intg i)\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp s)\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s \\<turnstile> e'' : T \\<and>\n                            P,hp s \\<turnstile> x'' (:\\<le>) E\n 6. \\<And>i h T l E Ta.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        P,E,hp (h, l) \\<turnstile> newA T\\<lfloor>Val (Intg i)\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp (h, l))\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h, l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h, l) \\<turnstile> x'' (:\\<le>) E\n 7. \\<And>e s ta e' s' C E T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<And>E T.\n           \\<lbrakk>P,E,hp s \\<turnstile> e : T;\n            NewThread t'' (e'', x'') (hp s')\n            \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>E T.\n                                P,E,hp s' \\<turnstile> e'' : T \\<and>\n                                P,hp s' \\<turnstile> x'' (:\\<le>) E;\n        P,E,hp s \\<turnstile> Cast C e : T;\n        NewThread t'' (e'', x'') (hp s')\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s' \\<turnstile> e'' : T \\<and>\n                            P,hp s' \\<turnstile> x'' (:\\<le>) E\n 8. \\<And>s v U T E Ta.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; P,E,hp s \\<turnstile> Cast T (Val v) : Ta;\n        NewThread t'' (e'', x'') (hp s)\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s \\<turnstile> e'' : T \\<and>\n                            P,hp s \\<turnstile> x'' (:\\<le>) E\n 9. \\<And>s v U T E Ta.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        P,E,hp s \\<turnstile> Cast T (Val v) : Ta;\n        NewThread t'' (e'', x'') (hp s)\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s \\<turnstile> e'' : T \\<and>\n                            P,hp s \\<turnstile> x'' (:\\<le>) E\n 10. \\<And>e s ta e' s' T E Ta.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<And>E T.\n            \\<lbrakk>P,E,hp s \\<turnstile> e : T;\n             NewThread t'' (e'', x'') (hp s')\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n            \\<Longrightarrow> \\<exists>E T.\n                                 P,E,hp s' \\<turnstile> e'' : T \\<and>\n                                 P,hp s' \\<turnstile> x'' (:\\<le>) E;\n         P,E,hp s \\<turnstile> e instanceof T : Ta;\n         NewThread t'' (e'', x'') (hp s')\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E T.\n                             P,E,hp s' \\<turnstile> e'' : T \\<and>\n                             P,hp s' \\<turnstile> x'' (:\\<le>) E\nA total of 98 subgoals...", "case (RedCallExternal s a U M Ts T' D vs ta va h' ta' e' s')"], ["proof (state)\nthis:\n  typeof_addr (hp s) a = \\<lfloor>U\\<rfloor>\n  P \\<turnstile> class_type_of U sees M: Ts\\<rightarrow>T' = Native in D\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   hp s\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n  ta' = extTA2J P ta\n  e' = extRet2J (addr a\\<bullet>M(map Val vs)) va\n  s' = (h', lcl s)\n  P,E,hp s \\<turnstile> addr a\\<bullet>M(map Val vs) : T\n  NewThread t'' (e'', x'') (hp s')\n  \\<in> set \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l E T.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        P,E,hp (h, l) \\<turnstile> new C : T;\n        NewThread t'' (e'', x'') (hp (h', l))\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Class_type\n C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h', l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h', l) \\<turnstile> x'' (:\\<le>) E\n 2. \\<And>h C l E T.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        P,E,hp (h, l) \\<turnstile> new C : T;\n        NewThread t'' (e'', x'') (hp (h, l))\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h, l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h, l) \\<turnstile> x'' (:\\<le>) E\n 3. \\<And>e s ta e' s' T E Ta.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<And>E T.\n           \\<lbrakk>P,E,hp s \\<turnstile> e : T;\n            NewThread t'' (e'', x'') (hp s')\n            \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>E T.\n                                P,E,hp s' \\<turnstile> e'' : T \\<and>\n                                P,hp s' \\<turnstile> x'' (:\\<le>) E;\n        P,E,hp s \\<turnstile> newA T\\<lfloor>e\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp s')\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s' \\<turnstile> e'' : T \\<and>\n                            P,hp s' \\<turnstile> x'' (:\\<le>) E\n 4. \\<And>i h' a h T l E Ta.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        P,E,hp (h, l) \\<turnstile> newA T\\<lfloor>Val (Intg i)\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp (h', l))\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Array_type T\n (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h', l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h', l) \\<turnstile> x'' (:\\<le>) E\n 5. \\<And>i T s E Ta.\n       \\<lbrakk>i <s 0;\n        P,E,hp s \\<turnstile> newA T\\<lfloor>Val (Intg i)\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp s)\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s \\<turnstile> e'' : T \\<and>\n                            P,hp s \\<turnstile> x'' (:\\<le>) E\n 6. \\<And>i h T l E Ta.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        P,E,hp (h, l) \\<turnstile> newA T\\<lfloor>Val (Intg i)\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp (h, l))\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h, l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h, l) \\<turnstile> x'' (:\\<le>) E\n 7. \\<And>e s ta e' s' C E T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<And>E T.\n           \\<lbrakk>P,E,hp s \\<turnstile> e : T;\n            NewThread t'' (e'', x'') (hp s')\n            \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>E T.\n                                P,E,hp s' \\<turnstile> e'' : T \\<and>\n                                P,hp s' \\<turnstile> x'' (:\\<le>) E;\n        P,E,hp s \\<turnstile> Cast C e : T;\n        NewThread t'' (e'', x'') (hp s')\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s' \\<turnstile> e'' : T \\<and>\n                            P,hp s' \\<turnstile> x'' (:\\<le>) E\n 8. \\<And>s v U T E Ta.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; P,E,hp s \\<turnstile> Cast T (Val v) : Ta;\n        NewThread t'' (e'', x'') (hp s)\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s \\<turnstile> e'' : T \\<and>\n                            P,hp s \\<turnstile> x'' (:\\<le>) E\n 9. \\<And>s v U T E Ta.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        P,E,hp s \\<turnstile> Cast T (Val v) : Ta;\n        NewThread t'' (e'', x'') (hp s)\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s \\<turnstile> e'' : T \\<and>\n                            P,hp s \\<turnstile> x'' (:\\<le>) E\n 10. \\<And>e s ta e' s' T E Ta.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<And>E T.\n            \\<lbrakk>P,E,hp s \\<turnstile> e : T;\n             NewThread t'' (e'', x'') (hp s')\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n            \\<Longrightarrow> \\<exists>E T.\n                                 P,E,hp s' \\<turnstile> e'' : T \\<and>\n                                 P,hp s' \\<turnstile> x'' (:\\<le>) E;\n         P,E,hp s \\<turnstile> e instanceof T : Ta;\n         NewThread t'' (e'', x'') (hp s')\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E T.\n                             P,E,hp s' \\<turnstile> e'' : T \\<and>\n                             P,hp s' \\<turnstile> x'' (:\\<le>) E\nA total of 98 subgoals...", "from \\<open>NewThread t'' (e'', x'') (hp s') \\<in> set \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>\\<close> \\<open>ta' = extTA2J P ta\\<close>"], ["proof (chain)\npicking this:\n  NewThread t'' (e'', x'') (hp s')\n  \\<in> set \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>\n  ta' = extTA2J P ta", "obtain C' M' a' where nt: \"NewThread t'' (C', M', a') (hp s') \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\"\n    and \"extNTA2J P (C', M', a') = (e'', x'')\""], ["proof (prove)\nusing this:\n  NewThread t'' (e'', x'') (hp s')\n  \\<in> set \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>\n  ta' = extTA2J P ta\n\ngoal (1 subgoal):\n 1. (\\<And>C' M' a'.\n        \\<lbrakk>NewThread t'' (C', M', a') (hp s')\n                 \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n         extNTA2J P (C', M', a') = (e'', x'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  NewThread t'' (C', M', a') (hp s')\n  \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n  extNTA2J P (C', M', a') = (e'', x'')\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l E T.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        P,E,hp (h, l) \\<turnstile> new C : T;\n        NewThread t'' (e'', x'') (hp (h', l))\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Class_type\n C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h', l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h', l) \\<turnstile> x'' (:\\<le>) E\n 2. \\<And>h C l E T.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        P,E,hp (h, l) \\<turnstile> new C : T;\n        NewThread t'' (e'', x'') (hp (h, l))\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h, l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h, l) \\<turnstile> x'' (:\\<le>) E\n 3. \\<And>e s ta e' s' T E Ta.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<And>E T.\n           \\<lbrakk>P,E,hp s \\<turnstile> e : T;\n            NewThread t'' (e'', x'') (hp s')\n            \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>E T.\n                                P,E,hp s' \\<turnstile> e'' : T \\<and>\n                                P,hp s' \\<turnstile> x'' (:\\<le>) E;\n        P,E,hp s \\<turnstile> newA T\\<lfloor>e\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp s')\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s' \\<turnstile> e'' : T \\<and>\n                            P,hp s' \\<turnstile> x'' (:\\<le>) E\n 4. \\<And>i h' a h T l E Ta.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        P,E,hp (h, l) \\<turnstile> newA T\\<lfloor>Val (Intg i)\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp (h', l))\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Array_type T\n (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h', l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h', l) \\<turnstile> x'' (:\\<le>) E\n 5. \\<And>i T s E Ta.\n       \\<lbrakk>i <s 0;\n        P,E,hp s \\<turnstile> newA T\\<lfloor>Val (Intg i)\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp s)\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s \\<turnstile> e'' : T \\<and>\n                            P,hp s \\<turnstile> x'' (:\\<le>) E\n 6. \\<And>i h T l E Ta.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        P,E,hp (h, l) \\<turnstile> newA T\\<lfloor>Val (Intg i)\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp (h, l))\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h, l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h, l) \\<turnstile> x'' (:\\<le>) E\n 7. \\<And>e s ta e' s' C E T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<And>E T.\n           \\<lbrakk>P,E,hp s \\<turnstile> e : T;\n            NewThread t'' (e'', x'') (hp s')\n            \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>E T.\n                                P,E,hp s' \\<turnstile> e'' : T \\<and>\n                                P,hp s' \\<turnstile> x'' (:\\<le>) E;\n        P,E,hp s \\<turnstile> Cast C e : T;\n        NewThread t'' (e'', x'') (hp s')\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s' \\<turnstile> e'' : T \\<and>\n                            P,hp s' \\<turnstile> x'' (:\\<le>) E\n 8. \\<And>s v U T E Ta.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; P,E,hp s \\<turnstile> Cast T (Val v) : Ta;\n        NewThread t'' (e'', x'') (hp s)\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s \\<turnstile> e'' : T \\<and>\n                            P,hp s \\<turnstile> x'' (:\\<le>) E\n 9. \\<And>s v U T E Ta.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        P,E,hp s \\<turnstile> Cast T (Val v) : Ta;\n        NewThread t'' (e'', x'') (hp s)\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s \\<turnstile> e'' : T \\<and>\n                            P,hp s \\<turnstile> x'' (:\\<le>) E\n 10. \\<And>e s ta e' s' T E Ta.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<And>E T.\n            \\<lbrakk>P,E,hp s \\<turnstile> e : T;\n             NewThread t'' (e'', x'') (hp s')\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n            \\<Longrightarrow> \\<exists>E T.\n                                 P,E,hp s' \\<turnstile> e'' : T \\<and>\n                                 P,hp s' \\<turnstile> x'' (:\\<le>) E;\n         P,E,hp s \\<turnstile> e instanceof T : Ta;\n         NewThread t'' (e'', x'') (hp s')\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E T.\n                             P,E,hp s' \\<turnstile> e'' : T \\<and>\n                             P,hp s' \\<turnstile> x'' (:\\<le>) E\nA total of 98 subgoals...", "from red_external_new_thread_sees[OF wf \\<open>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),hp s\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\\<close> nt] \\<open>typeof_addr (hp s) a = \\<lfloor>U\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  typeof_addr h' a' = \\<lfloor>Class_type C'\\<rfloor> \\<and>\n  (\\<exists>T meth D.\n      P \\<turnstile> C' sees M': []\\<rightarrow>T = \\<lfloor>meth\\<rfloor> in D)\n  typeof_addr (hp s) a = \\<lfloor>U\\<rfloor>", "obtain T pns body D where h'a': \"typeof_addr h' a' = \\<lfloor>Class_type C'\\<rfloor>\"\n    and sees: \" P \\<turnstile> C' sees M': []\\<rightarrow>T = \\<lfloor>(pns, body)\\<rfloor> in D\""], ["proof (prove)\nusing this:\n  typeof_addr h' a' = \\<lfloor>Class_type C'\\<rfloor> \\<and>\n  (\\<exists>T meth D.\n      P \\<turnstile> C' sees M': []\\<rightarrow>T = \\<lfloor>meth\\<rfloor> in D)\n  typeof_addr (hp s) a = \\<lfloor>U\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>T pns body D.\n        \\<lbrakk>typeof_addr h' a' = \\<lfloor>Class_type C'\\<rfloor>;\n         P \\<turnstile> C' sees M': []\\<rightarrow>T = \\<lfloor>(pns,\n                           body)\\<rfloor> in D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  typeof_addr h' a' = \\<lfloor>Class_type C'\\<rfloor>\n  P \\<turnstile> C' sees M': []\\<rightarrow>T = \\<lfloor>(pns,\n                    body)\\<rfloor> in D\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l E T.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        P,E,hp (h, l) \\<turnstile> new C : T;\n        NewThread t'' (e'', x'') (hp (h', l))\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Class_type\n C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h', l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h', l) \\<turnstile> x'' (:\\<le>) E\n 2. \\<And>h C l E T.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        P,E,hp (h, l) \\<turnstile> new C : T;\n        NewThread t'' (e'', x'') (hp (h, l))\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h, l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h, l) \\<turnstile> x'' (:\\<le>) E\n 3. \\<And>e s ta e' s' T E Ta.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<And>E T.\n           \\<lbrakk>P,E,hp s \\<turnstile> e : T;\n            NewThread t'' (e'', x'') (hp s')\n            \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>E T.\n                                P,E,hp s' \\<turnstile> e'' : T \\<and>\n                                P,hp s' \\<turnstile> x'' (:\\<le>) E;\n        P,E,hp s \\<turnstile> newA T\\<lfloor>e\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp s')\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s' \\<turnstile> e'' : T \\<and>\n                            P,hp s' \\<turnstile> x'' (:\\<le>) E\n 4. \\<And>i h' a h T l E Ta.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        P,E,hp (h, l) \\<turnstile> newA T\\<lfloor>Val (Intg i)\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp (h', l))\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Array_type T\n (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h', l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h', l) \\<turnstile> x'' (:\\<le>) E\n 5. \\<And>i T s E Ta.\n       \\<lbrakk>i <s 0;\n        P,E,hp s \\<turnstile> newA T\\<lfloor>Val (Intg i)\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp s)\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s \\<turnstile> e'' : T \\<and>\n                            P,hp s \\<turnstile> x'' (:\\<le>) E\n 6. \\<And>i h T l E Ta.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        P,E,hp (h, l) \\<turnstile> newA T\\<lfloor>Val (Intg i)\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp (h, l))\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h, l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h, l) \\<turnstile> x'' (:\\<le>) E\n 7. \\<And>e s ta e' s' C E T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<And>E T.\n           \\<lbrakk>P,E,hp s \\<turnstile> e : T;\n            NewThread t'' (e'', x'') (hp s')\n            \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>E T.\n                                P,E,hp s' \\<turnstile> e'' : T \\<and>\n                                P,hp s' \\<turnstile> x'' (:\\<le>) E;\n        P,E,hp s \\<turnstile> Cast C e : T;\n        NewThread t'' (e'', x'') (hp s')\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s' \\<turnstile> e'' : T \\<and>\n                            P,hp s' \\<turnstile> x'' (:\\<le>) E\n 8. \\<And>s v U T E Ta.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; P,E,hp s \\<turnstile> Cast T (Val v) : Ta;\n        NewThread t'' (e'', x'') (hp s)\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s \\<turnstile> e'' : T \\<and>\n                            P,hp s \\<turnstile> x'' (:\\<le>) E\n 9. \\<And>s v U T E Ta.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        P,E,hp s \\<turnstile> Cast T (Val v) : Ta;\n        NewThread t'' (e'', x'') (hp s)\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s \\<turnstile> e'' : T \\<and>\n                            P,hp s \\<turnstile> x'' (:\\<le>) E\n 10. \\<And>e s ta e' s' T E Ta.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<And>E T.\n            \\<lbrakk>P,E,hp s \\<turnstile> e : T;\n             NewThread t'' (e'', x'') (hp s')\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n            \\<Longrightarrow> \\<exists>E T.\n                                 P,E,hp s' \\<turnstile> e'' : T \\<and>\n                                 P,hp s' \\<turnstile> x'' (:\\<le>) E;\n         P,E,hp s \\<turnstile> e instanceof T : Ta;\n         NewThread t'' (e'', x'') (hp s')\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E T.\n                             P,E,hp s' \\<turnstile> e'' : T \\<and>\n                             P,hp s' \\<turnstile> x'' (:\\<le>) E\nA total of 98 subgoals...", "from sees_wf_mdecl[OF wf sees]"], ["proof (chain)\npicking this:\n  wf_mdecl wf_J_mdecl P D (M', [], T, \\<lfloor>(pns, body)\\<rfloor>)", "obtain T where \"P,[this \\<mapsto> Class D] \\<turnstile> body :: T\""], ["proof (prove)\nusing this:\n  wf_mdecl wf_J_mdecl P D (M', [], T, \\<lfloor>(pns, body)\\<rfloor>)\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        P,[this \\<mapsto> Class D] \\<turnstile> body :: T \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: wf_mdecl_def)"], ["proof (state)\nthis:\n  P,[this \\<mapsto> Class D] \\<turnstile> body :: T\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l E T.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        P,E,hp (h, l) \\<turnstile> new C : T;\n        NewThread t'' (e'', x'') (hp (h', l))\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Class_type\n C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h', l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h', l) \\<turnstile> x'' (:\\<le>) E\n 2. \\<And>h C l E T.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        P,E,hp (h, l) \\<turnstile> new C : T;\n        NewThread t'' (e'', x'') (hp (h, l))\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h, l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h, l) \\<turnstile> x'' (:\\<le>) E\n 3. \\<And>e s ta e' s' T E Ta.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<And>E T.\n           \\<lbrakk>P,E,hp s \\<turnstile> e : T;\n            NewThread t'' (e'', x'') (hp s')\n            \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>E T.\n                                P,E,hp s' \\<turnstile> e'' : T \\<and>\n                                P,hp s' \\<turnstile> x'' (:\\<le>) E;\n        P,E,hp s \\<turnstile> newA T\\<lfloor>e\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp s')\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s' \\<turnstile> e'' : T \\<and>\n                            P,hp s' \\<turnstile> x'' (:\\<le>) E\n 4. \\<And>i h' a h T l E Ta.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        P,E,hp (h, l) \\<turnstile> newA T\\<lfloor>Val (Intg i)\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp (h', l))\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Array_type T\n (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h', l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h', l) \\<turnstile> x'' (:\\<le>) E\n 5. \\<And>i T s E Ta.\n       \\<lbrakk>i <s 0;\n        P,E,hp s \\<turnstile> newA T\\<lfloor>Val (Intg i)\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp s)\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s \\<turnstile> e'' : T \\<and>\n                            P,hp s \\<turnstile> x'' (:\\<le>) E\n 6. \\<And>i h T l E Ta.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        P,E,hp (h, l) \\<turnstile> newA T\\<lfloor>Val (Intg i)\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp (h, l))\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h, l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h, l) \\<turnstile> x'' (:\\<le>) E\n 7. \\<And>e s ta e' s' C E T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<And>E T.\n           \\<lbrakk>P,E,hp s \\<turnstile> e : T;\n            NewThread t'' (e'', x'') (hp s')\n            \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>E T.\n                                P,E,hp s' \\<turnstile> e'' : T \\<and>\n                                P,hp s' \\<turnstile> x'' (:\\<le>) E;\n        P,E,hp s \\<turnstile> Cast C e : T;\n        NewThread t'' (e'', x'') (hp s')\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s' \\<turnstile> e'' : T \\<and>\n                            P,hp s' \\<turnstile> x'' (:\\<le>) E\n 8. \\<And>s v U T E Ta.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; P,E,hp s \\<turnstile> Cast T (Val v) : Ta;\n        NewThread t'' (e'', x'') (hp s)\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s \\<turnstile> e'' : T \\<and>\n                            P,hp s \\<turnstile> x'' (:\\<le>) E\n 9. \\<And>s v U T E Ta.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        P,E,hp s \\<turnstile> Cast T (Val v) : Ta;\n        NewThread t'' (e'', x'') (hp s)\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s \\<turnstile> e'' : T \\<and>\n                            P,hp s \\<turnstile> x'' (:\\<le>) E\n 10. \\<And>e s ta e' s' T E Ta.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<And>E T.\n            \\<lbrakk>P,E,hp s \\<turnstile> e : T;\n             NewThread t'' (e'', x'') (hp s')\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n            \\<Longrightarrow> \\<exists>E T.\n                                 P,E,hp s' \\<turnstile> e'' : T \\<and>\n                                 P,hp s' \\<turnstile> x'' (:\\<le>) E;\n         P,E,hp s \\<turnstile> e instanceof T : Ta;\n         NewThread t'' (e'', x'') (hp s')\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E T.\n                             P,E,hp s' \\<turnstile> e'' : T \\<and>\n                             P,hp s' \\<turnstile> x'' (:\\<le>) E\nA total of 98 subgoals...", "hence \"WTrt P (hp s') [this \\<mapsto> Class D] body T\""], ["proof (prove)\nusing this:\n  P,[this \\<mapsto> Class D] \\<turnstile> body :: T\n\ngoal (1 subgoal):\n 1. P,[this \\<mapsto> Class D],hp s' \\<turnstile> body : T", "by(rule WT_implies_WTrt)"], ["proof (state)\nthis:\n  P,[this \\<mapsto> Class D],hp s' \\<turnstile> body : T\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l E T.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        P,E,hp (h, l) \\<turnstile> new C : T;\n        NewThread t'' (e'', x'') (hp (h', l))\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Class_type\n C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h', l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h', l) \\<turnstile> x'' (:\\<le>) E\n 2. \\<And>h C l E T.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        P,E,hp (h, l) \\<turnstile> new C : T;\n        NewThread t'' (e'', x'') (hp (h, l))\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h, l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h, l) \\<turnstile> x'' (:\\<le>) E\n 3. \\<And>e s ta e' s' T E Ta.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<And>E T.\n           \\<lbrakk>P,E,hp s \\<turnstile> e : T;\n            NewThread t'' (e'', x'') (hp s')\n            \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>E T.\n                                P,E,hp s' \\<turnstile> e'' : T \\<and>\n                                P,hp s' \\<turnstile> x'' (:\\<le>) E;\n        P,E,hp s \\<turnstile> newA T\\<lfloor>e\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp s')\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s' \\<turnstile> e'' : T \\<and>\n                            P,hp s' \\<turnstile> x'' (:\\<le>) E\n 4. \\<And>i h' a h T l E Ta.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        P,E,hp (h, l) \\<turnstile> newA T\\<lfloor>Val (Intg i)\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp (h', l))\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Array_type T\n (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h', l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h', l) \\<turnstile> x'' (:\\<le>) E\n 5. \\<And>i T s E Ta.\n       \\<lbrakk>i <s 0;\n        P,E,hp s \\<turnstile> newA T\\<lfloor>Val (Intg i)\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp s)\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s \\<turnstile> e'' : T \\<and>\n                            P,hp s \\<turnstile> x'' (:\\<le>) E\n 6. \\<And>i h T l E Ta.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        P,E,hp (h, l) \\<turnstile> newA T\\<lfloor>Val (Intg i)\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp (h, l))\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h, l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h, l) \\<turnstile> x'' (:\\<le>) E\n 7. \\<And>e s ta e' s' C E T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<And>E T.\n           \\<lbrakk>P,E,hp s \\<turnstile> e : T;\n            NewThread t'' (e'', x'') (hp s')\n            \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>E T.\n                                P,E,hp s' \\<turnstile> e'' : T \\<and>\n                                P,hp s' \\<turnstile> x'' (:\\<le>) E;\n        P,E,hp s \\<turnstile> Cast C e : T;\n        NewThread t'' (e'', x'') (hp s')\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s' \\<turnstile> e'' : T \\<and>\n                            P,hp s' \\<turnstile> x'' (:\\<le>) E\n 8. \\<And>s v U T E Ta.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; P,E,hp s \\<turnstile> Cast T (Val v) : Ta;\n        NewThread t'' (e'', x'') (hp s)\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s \\<turnstile> e'' : T \\<and>\n                            P,hp s \\<turnstile> x'' (:\\<le>) E\n 9. \\<And>s v U T E Ta.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        P,E,hp s \\<turnstile> Cast T (Val v) : Ta;\n        NewThread t'' (e'', x'') (hp s)\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s \\<turnstile> e'' : T \\<and>\n                            P,hp s \\<turnstile> x'' (:\\<le>) E\n 10. \\<And>e s ta e' s' T E Ta.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<And>E T.\n            \\<lbrakk>P,E,hp s \\<turnstile> e : T;\n             NewThread t'' (e'', x'') (hp s')\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n            \\<Longrightarrow> \\<exists>E T.\n                                 P,E,hp s' \\<turnstile> e'' : T \\<and>\n                                 P,hp s' \\<turnstile> x'' (:\\<le>) E;\n         P,E,hp s \\<turnstile> e instanceof T : Ta;\n         NewThread t'' (e'', x'') (hp s')\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E T.\n                             P,E,hp s' \\<turnstile> e'' : T \\<and>\n                             P,hp s' \\<turnstile> x'' (:\\<le>) E\nA total of 98 subgoals...", "moreover"], ["proof (state)\nthis:\n  P,[this \\<mapsto> Class D],hp s' \\<turnstile> body : T\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l E T.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        P,E,hp (h, l) \\<turnstile> new C : T;\n        NewThread t'' (e'', x'') (hp (h', l))\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Class_type\n C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h', l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h', l) \\<turnstile> x'' (:\\<le>) E\n 2. \\<And>h C l E T.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        P,E,hp (h, l) \\<turnstile> new C : T;\n        NewThread t'' (e'', x'') (hp (h, l))\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h, l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h, l) \\<turnstile> x'' (:\\<le>) E\n 3. \\<And>e s ta e' s' T E Ta.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<And>E T.\n           \\<lbrakk>P,E,hp s \\<turnstile> e : T;\n            NewThread t'' (e'', x'') (hp s')\n            \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>E T.\n                                P,E,hp s' \\<turnstile> e'' : T \\<and>\n                                P,hp s' \\<turnstile> x'' (:\\<le>) E;\n        P,E,hp s \\<turnstile> newA T\\<lfloor>e\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp s')\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s' \\<turnstile> e'' : T \\<and>\n                            P,hp s' \\<turnstile> x'' (:\\<le>) E\n 4. \\<And>i h' a h T l E Ta.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        P,E,hp (h, l) \\<turnstile> newA T\\<lfloor>Val (Intg i)\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp (h', l))\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Array_type T\n (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h', l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h', l) \\<turnstile> x'' (:\\<le>) E\n 5. \\<And>i T s E Ta.\n       \\<lbrakk>i <s 0;\n        P,E,hp s \\<turnstile> newA T\\<lfloor>Val (Intg i)\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp s)\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s \\<turnstile> e'' : T \\<and>\n                            P,hp s \\<turnstile> x'' (:\\<le>) E\n 6. \\<And>i h T l E Ta.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        P,E,hp (h, l) \\<turnstile> newA T\\<lfloor>Val (Intg i)\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp (h, l))\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h, l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h, l) \\<turnstile> x'' (:\\<le>) E\n 7. \\<And>e s ta e' s' C E T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<And>E T.\n           \\<lbrakk>P,E,hp s \\<turnstile> e : T;\n            NewThread t'' (e'', x'') (hp s')\n            \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>E T.\n                                P,E,hp s' \\<turnstile> e'' : T \\<and>\n                                P,hp s' \\<turnstile> x'' (:\\<le>) E;\n        P,E,hp s \\<turnstile> Cast C e : T;\n        NewThread t'' (e'', x'') (hp s')\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s' \\<turnstile> e'' : T \\<and>\n                            P,hp s' \\<turnstile> x'' (:\\<le>) E\n 8. \\<And>s v U T E Ta.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; P,E,hp s \\<turnstile> Cast T (Val v) : Ta;\n        NewThread t'' (e'', x'') (hp s)\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s \\<turnstile> e'' : T \\<and>\n                            P,hp s \\<turnstile> x'' (:\\<le>) E\n 9. \\<And>s v U T E Ta.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        P,E,hp s \\<turnstile> Cast T (Val v) : Ta;\n        NewThread t'' (e'', x'') (hp s)\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s \\<turnstile> e'' : T \\<and>\n                            P,hp s \\<turnstile> x'' (:\\<le>) E\n 10. \\<And>e s ta e' s' T E Ta.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<And>E T.\n            \\<lbrakk>P,E,hp s \\<turnstile> e : T;\n             NewThread t'' (e'', x'') (hp s')\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n            \\<Longrightarrow> \\<exists>E T.\n                                 P,E,hp s' \\<turnstile> e'' : T \\<and>\n                                 P,hp s' \\<turnstile> x'' (:\\<le>) E;\n         P,E,hp s \\<turnstile> e instanceof T : Ta;\n         NewThread t'' (e'', x'') (hp s')\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E T.\n                             P,E,hp s' \\<turnstile> e'' : T \\<and>\n                             P,hp s' \\<turnstile> x'' (:\\<le>) E\nA total of 98 subgoals...", "from sees"], ["proof (chain)\npicking this:\n  P \\<turnstile> C' sees M': []\\<rightarrow>Tb__ = \\<lfloor>(pns,\n                       body)\\<rfloor> in D", "have \"P \\<turnstile> C' \\<preceq>\\<^sup>* D\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C' sees M': []\\<rightarrow>Tb__ = \\<lfloor>(pns,\n                       body)\\<rfloor> in D\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C' \\<preceq>\\<^sup>* D", "by(rule sees_method_decl_above)"], ["proof (state)\nthis:\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l E T.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        P,E,hp (h, l) \\<turnstile> new C : T;\n        NewThread t'' (e'', x'') (hp (h', l))\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Class_type\n C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h', l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h', l) \\<turnstile> x'' (:\\<le>) E\n 2. \\<And>h C l E T.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        P,E,hp (h, l) \\<turnstile> new C : T;\n        NewThread t'' (e'', x'') (hp (h, l))\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h, l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h, l) \\<turnstile> x'' (:\\<le>) E\n 3. \\<And>e s ta e' s' T E Ta.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<And>E T.\n           \\<lbrakk>P,E,hp s \\<turnstile> e : T;\n            NewThread t'' (e'', x'') (hp s')\n            \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>E T.\n                                P,E,hp s' \\<turnstile> e'' : T \\<and>\n                                P,hp s' \\<turnstile> x'' (:\\<le>) E;\n        P,E,hp s \\<turnstile> newA T\\<lfloor>e\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp s')\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s' \\<turnstile> e'' : T \\<and>\n                            P,hp s' \\<turnstile> x'' (:\\<le>) E\n 4. \\<And>i h' a h T l E Ta.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        P,E,hp (h, l) \\<turnstile> newA T\\<lfloor>Val (Intg i)\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp (h', l))\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Array_type T\n (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h', l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h', l) \\<turnstile> x'' (:\\<le>) E\n 5. \\<And>i T s E Ta.\n       \\<lbrakk>i <s 0;\n        P,E,hp s \\<turnstile> newA T\\<lfloor>Val (Intg i)\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp s)\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s \\<turnstile> e'' : T \\<and>\n                            P,hp s \\<turnstile> x'' (:\\<le>) E\n 6. \\<And>i h T l E Ta.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        P,E,hp (h, l) \\<turnstile> newA T\\<lfloor>Val (Intg i)\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp (h, l))\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h, l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h, l) \\<turnstile> x'' (:\\<le>) E\n 7. \\<And>e s ta e' s' C E T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<And>E T.\n           \\<lbrakk>P,E,hp s \\<turnstile> e : T;\n            NewThread t'' (e'', x'') (hp s')\n            \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>E T.\n                                P,E,hp s' \\<turnstile> e'' : T \\<and>\n                                P,hp s' \\<turnstile> x'' (:\\<le>) E;\n        P,E,hp s \\<turnstile> Cast C e : T;\n        NewThread t'' (e'', x'') (hp s')\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s' \\<turnstile> e'' : T \\<and>\n                            P,hp s' \\<turnstile> x'' (:\\<le>) E\n 8. \\<And>s v U T E Ta.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; P,E,hp s \\<turnstile> Cast T (Val v) : Ta;\n        NewThread t'' (e'', x'') (hp s)\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s \\<turnstile> e'' : T \\<and>\n                            P,hp s \\<turnstile> x'' (:\\<le>) E\n 9. \\<And>s v U T E Ta.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        P,E,hp s \\<turnstile> Cast T (Val v) : Ta;\n        NewThread t'' (e'', x'') (hp s)\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s \\<turnstile> e'' : T \\<and>\n                            P,hp s \\<turnstile> x'' (:\\<le>) E\n 10. \\<And>e s ta e' s' T E Ta.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<And>E T.\n            \\<lbrakk>P,E,hp s \\<turnstile> e : T;\n             NewThread t'' (e'', x'') (hp s')\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n            \\<Longrightarrow> \\<exists>E T.\n                                 P,E,hp s' \\<turnstile> e'' : T \\<and>\n                                 P,hp s' \\<turnstile> x'' (:\\<le>) E;\n         P,E,hp s \\<turnstile> e instanceof T : Ta;\n         NewThread t'' (e'', x'') (hp s')\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E T.\n                             P,E,hp s' \\<turnstile> e'' : T \\<and>\n                             P,hp s' \\<turnstile> x'' (:\\<le>) E\nA total of 98 subgoals...", "with h'a'"], ["proof (chain)\npicking this:\n  typeof_addr h' a' = \\<lfloor>Class_type C'\\<rfloor>\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D", "have \"P,h' \\<turnstile> [this \\<mapsto> Addr a'] (:\\<le>) [this \\<mapsto> Class D]\""], ["proof (prove)\nusing this:\n  typeof_addr h' a' = \\<lfloor>Class_type C'\\<rfloor>\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. P,h' \\<turnstile> [this \\<mapsto>\n                       Addr a'] (:\\<le>) [this \\<mapsto> Class D]", "by(auto simp add: lconf_def conf_def)"], ["proof (state)\nthis:\n  P,h' \\<turnstile> [this \\<mapsto>\n                     Addr a'] (:\\<le>) [this \\<mapsto> Class D]\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l E T.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        P,E,hp (h, l) \\<turnstile> new C : T;\n        NewThread t'' (e'', x'') (hp (h', l))\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Class_type\n C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h', l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h', l) \\<turnstile> x'' (:\\<le>) E\n 2. \\<And>h C l E T.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        P,E,hp (h, l) \\<turnstile> new C : T;\n        NewThread t'' (e'', x'') (hp (h, l))\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h, l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h, l) \\<turnstile> x'' (:\\<le>) E\n 3. \\<And>e s ta e' s' T E Ta.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<And>E T.\n           \\<lbrakk>P,E,hp s \\<turnstile> e : T;\n            NewThread t'' (e'', x'') (hp s')\n            \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>E T.\n                                P,E,hp s' \\<turnstile> e'' : T \\<and>\n                                P,hp s' \\<turnstile> x'' (:\\<le>) E;\n        P,E,hp s \\<turnstile> newA T\\<lfloor>e\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp s')\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s' \\<turnstile> e'' : T \\<and>\n                            P,hp s' \\<turnstile> x'' (:\\<le>) E\n 4. \\<And>i h' a h T l E Ta.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        P,E,hp (h, l) \\<turnstile> newA T\\<lfloor>Val (Intg i)\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp (h', l))\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Array_type T\n (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h', l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h', l) \\<turnstile> x'' (:\\<le>) E\n 5. \\<And>i T s E Ta.\n       \\<lbrakk>i <s 0;\n        P,E,hp s \\<turnstile> newA T\\<lfloor>Val (Intg i)\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp s)\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s \\<turnstile> e'' : T \\<and>\n                            P,hp s \\<turnstile> x'' (:\\<le>) E\n 6. \\<And>i h T l E Ta.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        P,E,hp (h, l) \\<turnstile> newA T\\<lfloor>Val (Intg i)\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp (h, l))\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h, l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h, l) \\<turnstile> x'' (:\\<le>) E\n 7. \\<And>e s ta e' s' C E T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<And>E T.\n           \\<lbrakk>P,E,hp s \\<turnstile> e : T;\n            NewThread t'' (e'', x'') (hp s')\n            \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>E T.\n                                P,E,hp s' \\<turnstile> e'' : T \\<and>\n                                P,hp s' \\<turnstile> x'' (:\\<le>) E;\n        P,E,hp s \\<turnstile> Cast C e : T;\n        NewThread t'' (e'', x'') (hp s')\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s' \\<turnstile> e'' : T \\<and>\n                            P,hp s' \\<turnstile> x'' (:\\<le>) E\n 8. \\<And>s v U T E Ta.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; P,E,hp s \\<turnstile> Cast T (Val v) : Ta;\n        NewThread t'' (e'', x'') (hp s)\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s \\<turnstile> e'' : T \\<and>\n                            P,hp s \\<turnstile> x'' (:\\<le>) E\n 9. \\<And>s v U T E Ta.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        P,E,hp s \\<turnstile> Cast T (Val v) : Ta;\n        NewThread t'' (e'', x'') (hp s)\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s \\<turnstile> e'' : T \\<and>\n                            P,hp s \\<turnstile> x'' (:\\<le>) E\n 10. \\<And>e s ta e' s' T E Ta.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<And>E T.\n            \\<lbrakk>P,E,hp s \\<turnstile> e : T;\n             NewThread t'' (e'', x'') (hp s')\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n            \\<Longrightarrow> \\<exists>E T.\n                                 P,E,hp s' \\<turnstile> e'' : T \\<and>\n                                 P,hp s' \\<turnstile> x'' (:\\<le>) E;\n         P,E,hp s \\<turnstile> e instanceof T : Ta;\n         NewThread t'' (e'', x'') (hp s')\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E T.\n                             P,E,hp s' \\<turnstile> e'' : T \\<and>\n                             P,hp s' \\<turnstile> x'' (:\\<le>) E\nA total of 98 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  P,[this \\<mapsto> Class D],hp s' \\<turnstile> body : T\n  P,h' \\<turnstile> [this \\<mapsto>\n                     Addr a'] (:\\<le>) [this \\<mapsto> Class D]", "show ?case"], ["proof (prove)\nusing this:\n  P,[this \\<mapsto> Class D],hp s' \\<turnstile> body : T\n  P,h' \\<turnstile> [this \\<mapsto>\n                     Addr a'] (:\\<le>) [this \\<mapsto> Class D]\n\ngoal (1 subgoal):\n 1. \\<exists>E T.\n       P,E,hp s' \\<turnstile> e'' : T \\<and>\n       P,hp s' \\<turnstile> x'' (:\\<le>) E", "using h'a' sees \\<open>s' = (h', lcl s)\\<close>\n    \\<open>extNTA2J P (C', M', a') = (e'', x'')\\<close>"], ["proof (prove)\nusing this:\n  P,[this \\<mapsto> Class D],hp s' \\<turnstile> body : T\n  P,h' \\<turnstile> [this \\<mapsto>\n                     Addr a'] (:\\<le>) [this \\<mapsto> Class D]\n  typeof_addr h' a' = \\<lfloor>Class_type C'\\<rfloor>\n  P \\<turnstile> C' sees M': []\\<rightarrow>Tb__ = \\<lfloor>(pns,\n                       body)\\<rfloor> in D\n  s' = (h', lcl s)\n  extNTA2J P (C', M', a') = (e'', x'')\n\ngoal (1 subgoal):\n 1. \\<exists>E T.\n       P,E,hp s' \\<turnstile> e'' : T \\<and>\n       P,hp s' \\<turnstile> x'' (:\\<le>) E", "by(fastforce intro: sees_method_decl_above)"], ["proof (state)\nthis:\n  \\<exists>E T.\n     P,E,hp s' \\<turnstile> e'' : T \\<and>\n     P,hp s' \\<turnstile> x'' (:\\<le>) E\n\ngoal (97 subgoals):\n 1. \\<And>h' a h C l E T.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        P,E,hp (h, l) \\<turnstile> new C : T;\n        NewThread t'' (e'', x'') (hp (h', l))\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Class_type\n C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h', l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h', l) \\<turnstile> x'' (:\\<le>) E\n 2. \\<And>h C l E T.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        P,E,hp (h, l) \\<turnstile> new C : T;\n        NewThread t'' (e'', x'') (hp (h, l))\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h, l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h, l) \\<turnstile> x'' (:\\<le>) E\n 3. \\<And>e s ta e' s' T E Ta.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<And>E T.\n           \\<lbrakk>P,E,hp s \\<turnstile> e : T;\n            NewThread t'' (e'', x'') (hp s')\n            \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>E T.\n                                P,E,hp s' \\<turnstile> e'' : T \\<and>\n                                P,hp s' \\<turnstile> x'' (:\\<le>) E;\n        P,E,hp s \\<turnstile> newA T\\<lfloor>e\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp s')\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s' \\<turnstile> e'' : T \\<and>\n                            P,hp s' \\<turnstile> x'' (:\\<le>) E\n 4. \\<And>i h' a h T l E Ta.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        P,E,hp (h, l) \\<turnstile> newA T\\<lfloor>Val (Intg i)\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp (h', l))\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Array_type T\n (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h', l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h', l) \\<turnstile> x'' (:\\<le>) E\n 5. \\<And>i T s E Ta.\n       \\<lbrakk>i <s 0;\n        P,E,hp s \\<turnstile> newA T\\<lfloor>Val (Intg i)\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp s)\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s \\<turnstile> e'' : T \\<and>\n                            P,hp s \\<turnstile> x'' (:\\<le>) E\n 6. \\<And>i h T l E Ta.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        P,E,hp (h, l) \\<turnstile> newA T\\<lfloor>Val (Intg i)\\<rceil> : Ta;\n        NewThread t'' (e'', x'') (hp (h, l))\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp (h, l) \\<turnstile> e'' : T \\<and>\n                            P,hp (h, l) \\<turnstile> x'' (:\\<le>) E\n 7. \\<And>e s ta e' s' C E T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<And>E T.\n           \\<lbrakk>P,E,hp s \\<turnstile> e : T;\n            NewThread t'' (e'', x'') (hp s')\n            \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>E T.\n                                P,E,hp s' \\<turnstile> e'' : T \\<and>\n                                P,hp s' \\<turnstile> x'' (:\\<le>) E;\n        P,E,hp s \\<turnstile> Cast C e : T;\n        NewThread t'' (e'', x'') (hp s')\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s' \\<turnstile> e'' : T \\<and>\n                            P,hp s' \\<turnstile> x'' (:\\<le>) E\n 8. \\<And>s v U T E Ta.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; P,E,hp s \\<turnstile> Cast T (Val v) : Ta;\n        NewThread t'' (e'', x'') (hp s)\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s \\<turnstile> e'' : T \\<and>\n                            P,hp s \\<turnstile> x'' (:\\<le>) E\n 9. \\<And>s v U T E Ta.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        P,E,hp s \\<turnstile> Cast T (Val v) : Ta;\n        NewThread t'' (e'', x'') (hp s)\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E T.\n                            P,E,hp s \\<turnstile> e'' : T \\<and>\n                            P,hp s \\<turnstile> x'' (:\\<le>) E\n 10. \\<And>e s ta e' s' T E Ta.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<And>E T.\n            \\<lbrakk>P,E,hp s \\<turnstile> e : T;\n             NewThread t'' (e'', x'') (hp s')\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n            \\<Longrightarrow> \\<exists>E T.\n                                 P,E,hp s' \\<turnstile> e'' : T \\<and>\n                                 P,hp s' \\<turnstile> x'' (:\\<le>) E;\n         P,E,hp s \\<turnstile> e instanceof T : Ta;\n         NewThread t'' (e'', x'') (hp s')\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E T.\n                             P,E,hp s' \\<turnstile> e'' : T \\<and>\n                             P,hp s' \\<turnstile> x'' (:\\<le>) E\nA total of 97 subgoals...", "qed(fastforce simp add: ta_upd_simps)+"], ["", "end"], ["", "context J_heap_conf_base begin"], ["", "definition sconf_type_ok :: \"(env \\<times> ty) \\<Rightarrow> 'thread_id \\<Rightarrow> 'addr expr \\<times> 'addr locals \\<Rightarrow> 'heap \\<Rightarrow> bool\" \nwhere\n  \"sconf_type_ok ET t ex h \\<equiv> fst ET \\<turnstile> (h, snd ex) \\<surd> \\<and> type_ok P ET (fst ex) h \\<and> P,h \\<turnstile> t \\<surd>t\""], ["", "abbreviation sconf_type_ts_ok ::\n  \"('thread_id \\<rightharpoonup> (env \\<times> ty)) \\<Rightarrow> ('addr,'thread_id,'addr expr \\<times> 'addr locals) thread_info \\<Rightarrow> 'heap \\<Rightarrow> bool\"\nwhere\n  \"sconf_type_ts_ok \\<equiv> ts_inv sconf_type_ok\""], ["", "lemma ts_inv_ok_J_sconf_type_ET_start:\n  \"ts_inv_ok (thr (J_start_state P C M vs)) (J_sconf_type_ET_start P C M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts_inv_ok (thr (start_state J_local_start P C M vs))\n     (J_sconf_type_ET_start P C M)", "by(rule ts_inv_okI)(simp add: start_state_def J_sconf_type_ET_start_def split_beta)"], ["", "end"], ["", "lemma (in J_heap) red_preserve_welltype:\n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>e, (h, x)\\<rangle> -ta\\<rightarrow> \\<langle>e', (h', x')\\<rangle>; P,E,h \\<turnstile> e'' : T \\<rbrakk> \\<Longrightarrow> P,E,h' \\<turnstile> e'' : T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n                                     (h, x)\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',(h', x')\\<rangle>;\n     P,E,h \\<turnstile> e'' : T\\<rbrakk>\n    \\<Longrightarrow> P,E,h' \\<turnstile> e'' : T", "by(auto elim: WTrt_hext_mono dest!: red_hext_incr)"], ["", "context J_heap_conf begin"], ["", "lemma sconf_type_ts_ok_J_start_state:\n  \"\\<lbrakk> wf_J_prog P; wf_start_state P C M vs \\<rbrakk>\n  \\<Longrightarrow> sconf_type_ts_ok (J_sconf_type_ET_start P C M) (thr (J_start_state P C M vs)) (shr (J_start_state P C M vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_J_prog P; wf_start_state P C M vs\\<rbrakk>\n    \\<Longrightarrow> sconf_type_ts_ok (J_sconf_type_ET_start P C M)\n                       (thr (start_state J_local_start P C M vs))\n                       (shr (start_state J_local_start P C M vs))", "apply(erule wf_start_state.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ts T meth D.\n       \\<lbrakk>wf_J_prog P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>meth\\<rfloor> in D;\n        start_heap_ok; P,start_heap \\<turnstile> vs [:\\<le>] Ts\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ts_ok (J_sconf_type_ET_start P C M)\n                          (thr (start_state J_local_start P C M vs))\n                          (shr (start_state J_local_start P C M vs))", "apply(rule ts_invI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ts T meth D t x ln.\n       \\<lbrakk>wf_J_prog P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>meth\\<rfloor> in D;\n        start_heap_ok; P,start_heap \\<turnstile> vs [:\\<le>] Ts;\n        thr (start_state J_local_start P C M vs) t =\n        \\<lfloor>(x, ln)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            J_sconf_type_ET_start P C M t =\n                            \\<lfloor>i\\<rfloor> \\<and>\n                            sconf_type_ok i t x\n                             (shr (start_state J_local_start P C M vs))", "apply(simp add: start_state_def split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ts T meth D t x.\n       \\<lbrakk>wf_J_prog P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>meth\\<rfloor> in D;\n        start_heap_ok; P,start_heap \\<turnstile> vs [:\\<le>] Ts;\n        t = start_tid;\n        (case meth of\n         (pns, body) \\<Rightarrow>\n           \\<lambda>vs.\n              ({this:Class D=\\<lfloor>Null\\<rfloor>; blocks pns Ts vs body},\n               Map.empty))\n         vs =\n        x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b.\n                            J_sconf_type_ET_start P C M start_tid =\n                            \\<lfloor>(a, b)\\<rfloor> \\<and>\n                            sconf_type_ok (a, b) start_tid x start_heap", "apply(frule (1) sees_wf_mdecl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ts T meth D t x.\n       \\<lbrakk>wf_J_prog P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>meth\\<rfloor> in D;\n        start_heap_ok; P,start_heap \\<turnstile> vs [:\\<le>] Ts;\n        t = start_tid;\n        (case meth of\n         (pns, body) \\<Rightarrow>\n           \\<lambda>vs.\n              ({this:Class D=\\<lfloor>Null\\<rfloor>; blocks pns Ts vs body},\n               Map.empty))\n         vs =\n        x;\n        wf_mdecl wf_J_mdecl P D (M, Ts, T, \\<lfloor>meth\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b.\n                            J_sconf_type_ET_start P C M start_tid =\n                            \\<lfloor>(a, b)\\<rfloor> \\<and>\n                            sconf_type_ok (a, b) start_tid x start_heap", "apply(auto simp add: wf_mdecl_def J_sconf_type_ET_start_def sconf_type_ok_def sconf_def type_ok_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Ts T a b D T'.\n       \\<lbrakk>wf_J_prog P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a,\n                        b)\\<rfloor> in D;\n        start_heap_ok; P,start_heap \\<turnstile> vs [:\\<le>] Ts;\n        \\<forall>x\\<in>set Ts. is_type P x; is_type P T;\n        length Ts = length a; distinct a; this \\<notin> set a;\n        \\<D> b \\<lfloor>insert this (set a)\\<rfloor>;\n        P,[a [\\<mapsto>] Ts, this \\<mapsto> Class D] \\<turnstile> b :: T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> hconf start_heap\n 2. \\<And>Ts T a b D T'.\n       \\<lbrakk>wf_J_prog P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a,\n                        b)\\<rfloor> in D;\n        start_heap_ok; P,start_heap \\<turnstile> vs [:\\<le>] Ts;\n        \\<forall>x\\<in>set Ts. is_type P x; is_type P T;\n        length Ts = length a; distinct a; this \\<notin> set a;\n        \\<D> b \\<lfloor>insert this (set a)\\<rfloor>;\n        P,[a [\\<mapsto>] Ts, this \\<mapsto> Class D] \\<turnstile> b :: T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> preallocated start_heap\n 3. \\<And>Ts T a b D T'.\n       \\<lbrakk>wf_J_prog P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a,\n                        b)\\<rfloor> in D;\n        start_heap_ok; P,start_heap \\<turnstile> vs [:\\<le>] Ts;\n        \\<forall>x\\<in>set Ts. is_type P x; is_type P T;\n        length Ts = length a; distinct a; this \\<notin> set a;\n        \\<D> b \\<lfloor>insert this (set a)\\<rfloor>;\n        P,[a [\\<mapsto>] Ts, this \\<mapsto> Class D] \\<turnstile> b :: T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T'.\n                            P,[this \\<mapsto>\n                               Class\n                                D],start_heap \\<turnstile> blocks a Ts vs\n                      b : T' \\<and>\n                            P \\<turnstile> T' \\<le> T\n 4. \\<And>Ts T a b D T'.\n       \\<lbrakk>wf_J_prog P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a,\n                        b)\\<rfloor> in D;\n        start_heap_ok; P,start_heap \\<turnstile> vs [:\\<le>] Ts;\n        \\<forall>x\\<in>set Ts. is_type P x; is_type P T;\n        length Ts = length a; distinct a; this \\<notin> set a;\n        \\<D> b \\<lfloor>insert this (set a)\\<rfloor>;\n        P,[a [\\<mapsto>] Ts, this \\<mapsto> Class D] \\<turnstile> b :: T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,start_heap \\<turnstile> start_tid \\<surd>t", "apply(erule hconf_start_heap)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Ts T a b D T'.\n       \\<lbrakk>wf_J_prog P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a,\n                        b)\\<rfloor> in D;\n        start_heap_ok; P,start_heap \\<turnstile> vs [:\\<le>] Ts;\n        \\<forall>x\\<in>set Ts. is_type P x; is_type P T;\n        length Ts = length a; distinct a; this \\<notin> set a;\n        \\<D> b \\<lfloor>insert this (set a)\\<rfloor>;\n        P,[a [\\<mapsto>] Ts, this \\<mapsto> Class D] \\<turnstile> b :: T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> preallocated start_heap\n 2. \\<And>Ts T a b D T'.\n       \\<lbrakk>wf_J_prog P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a,\n                        b)\\<rfloor> in D;\n        start_heap_ok; P,start_heap \\<turnstile> vs [:\\<le>] Ts;\n        \\<forall>x\\<in>set Ts. is_type P x; is_type P T;\n        length Ts = length a; distinct a; this \\<notin> set a;\n        \\<D> b \\<lfloor>insert this (set a)\\<rfloor>;\n        P,[a [\\<mapsto>] Ts, this \\<mapsto> Class D] \\<turnstile> b :: T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T'.\n                            P,[this \\<mapsto>\n                               Class\n                                D],start_heap \\<turnstile> blocks a Ts vs\n                      b : T' \\<and>\n                            P \\<turnstile> T' \\<le> T\n 3. \\<And>Ts T a b D T'.\n       \\<lbrakk>wf_J_prog P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a,\n                        b)\\<rfloor> in D;\n        start_heap_ok; P,start_heap \\<turnstile> vs [:\\<le>] Ts;\n        \\<forall>x\\<in>set Ts. is_type P x; is_type P T;\n        length Ts = length a; distinct a; this \\<notin> set a;\n        \\<D> b \\<lfloor>insert this (set a)\\<rfloor>;\n        P,[a [\\<mapsto>] Ts, this \\<mapsto> Class D] \\<turnstile> b :: T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,start_heap \\<turnstile> start_tid \\<surd>t", "apply(erule preallocated_start_heap)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Ts T a b D T'.\n       \\<lbrakk>wf_J_prog P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a,\n                        b)\\<rfloor> in D;\n        P,start_heap \\<turnstile> vs [:\\<le>] Ts;\n        \\<forall>x\\<in>set Ts. is_type P x; is_type P T;\n        length Ts = length a; distinct a; this \\<notin> set a;\n        \\<D> b \\<lfloor>insert this (set a)\\<rfloor>;\n        P,[a [\\<mapsto>] Ts, this \\<mapsto> Class D] \\<turnstile> b :: T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> wf_syscls P\n 2. \\<And>Ts T a b D T'.\n       \\<lbrakk>wf_J_prog P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a,\n                        b)\\<rfloor> in D;\n        start_heap_ok; P,start_heap \\<turnstile> vs [:\\<le>] Ts;\n        \\<forall>x\\<in>set Ts. is_type P x; is_type P T;\n        length Ts = length a; distinct a; this \\<notin> set a;\n        \\<D> b \\<lfloor>insert this (set a)\\<rfloor>;\n        P,[a [\\<mapsto>] Ts, this \\<mapsto> Class D] \\<turnstile> b :: T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T'.\n                            P,[this \\<mapsto>\n                               Class\n                                D],start_heap \\<turnstile> blocks a Ts vs\n                      b : T' \\<and>\n                            P \\<turnstile> T' \\<le> T\n 3. \\<And>Ts T a b D T'.\n       \\<lbrakk>wf_J_prog P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a,\n                        b)\\<rfloor> in D;\n        start_heap_ok; P,start_heap \\<turnstile> vs [:\\<le>] Ts;\n        \\<forall>x\\<in>set Ts. is_type P x; is_type P T;\n        length Ts = length a; distinct a; this \\<notin> set a;\n        \\<D> b \\<lfloor>insert this (set a)\\<rfloor>;\n        P,[a [\\<mapsto>] Ts, this \\<mapsto> Class D] \\<turnstile> b :: T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,start_heap \\<turnstile> start_tid \\<surd>t", "apply(erule wf_prog_wf_syscls)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Ts T a b D T'.\n       \\<lbrakk>wf_J_prog P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a,\n                        b)\\<rfloor> in D;\n        start_heap_ok; P,start_heap \\<turnstile> vs [:\\<le>] Ts;\n        \\<forall>x\\<in>set Ts. is_type P x; is_type P T;\n        length Ts = length a; distinct a; this \\<notin> set a;\n        \\<D> b \\<lfloor>insert this (set a)\\<rfloor>;\n        P,[a [\\<mapsto>] Ts, this \\<mapsto> Class D] \\<turnstile> b :: T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T'.\n                            P,[this \\<mapsto>\n                               Class\n                                D],start_heap \\<turnstile> blocks a Ts vs\n                      b : T' \\<and>\n                            P \\<turnstile> T' \\<le> T\n 2. \\<And>Ts T a b D T'.\n       \\<lbrakk>wf_J_prog P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a,\n                        b)\\<rfloor> in D;\n        start_heap_ok; P,start_heap \\<turnstile> vs [:\\<le>] Ts;\n        \\<forall>x\\<in>set Ts. is_type P x; is_type P T;\n        length Ts = length a; distinct a; this \\<notin> set a;\n        \\<D> b \\<lfloor>insert this (set a)\\<rfloor>;\n        P,[a [\\<mapsto>] Ts, this \\<mapsto> Class D] \\<turnstile> b :: T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,start_heap \\<turnstile> start_tid \\<surd>t", "apply(frule list_all2_lengthD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Ts T a b D T'.\n       \\<lbrakk>wf_J_prog P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a,\n                        b)\\<rfloor> in D;\n        start_heap_ok; P,start_heap \\<turnstile> vs [:\\<le>] Ts;\n        \\<forall>x\\<in>set Ts. is_type P x; is_type P T;\n        length Ts = length a; distinct a; this \\<notin> set a;\n        \\<D> b \\<lfloor>insert this (set a)\\<rfloor>;\n        P,[a [\\<mapsto>] Ts, this \\<mapsto> Class D] \\<turnstile> b :: T';\n        P \\<turnstile> T' \\<le> T; length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T'.\n                            P,[this \\<mapsto>\n                               Class\n                                D],start_heap \\<turnstile> blocks a Ts vs\n                      b : T' \\<and>\n                            P \\<turnstile> T' \\<le> T\n 2. \\<And>Ts T a b D T'.\n       \\<lbrakk>wf_J_prog P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a,\n                        b)\\<rfloor> in D;\n        start_heap_ok; P,start_heap \\<turnstile> vs [:\\<le>] Ts;\n        \\<forall>x\\<in>set Ts. is_type P x; is_type P T;\n        length Ts = length a; distinct a; this \\<notin> set a;\n        \\<D> b \\<lfloor>insert this (set a)\\<rfloor>;\n        P,[a [\\<mapsto>] Ts, this \\<mapsto> Class D] \\<turnstile> b :: T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,start_heap \\<turnstile> start_tid \\<surd>t", "apply(auto simp add: wt_blocks confs_conv_map intro: WT_implies_WTrt)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ts T a b D T'.\n       \\<lbrakk>wf_J_prog P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a,\n                        b)\\<rfloor> in D;\n        start_heap_ok; P,start_heap \\<turnstile> vs [:\\<le>] Ts;\n        \\<forall>x\\<in>set Ts. is_type P x; is_type P T;\n        length Ts = length a; distinct a; this \\<notin> set a;\n        \\<D> b \\<lfloor>insert this (set a)\\<rfloor>;\n        P,[a [\\<mapsto>] Ts, this \\<mapsto> Class D] \\<turnstile> b :: T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,start_heap \\<turnstile> start_tid \\<surd>t", "apply(erule tconf_start_heap_start_tid)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ts T a b D T'.\n       \\<lbrakk>wf_J_prog P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a,\n                        b)\\<rfloor> in D;\n        P,start_heap \\<turnstile> vs [:\\<le>] Ts;\n        \\<forall>x\\<in>set Ts. is_type P x; is_type P T;\n        length Ts = length a; distinct a; this \\<notin> set a;\n        \\<D> b \\<lfloor>insert this (set a)\\<rfloor>;\n        P,[a [\\<mapsto>] Ts, this \\<mapsto> Class D] \\<turnstile> b :: T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> wf_syscls P", "apply(erule wf_prog_wf_syscls)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma J_start_state_sconf_type_ok:\n  assumes wf: \"wf_J_prog P\"\n  and ok: \"wf_start_state P C M vs\"\n  shows \"ts_ok (\\<lambda>t x h. \\<exists>ET. sconf_type_ok ET t x h) (thr (J_start_state P C M vs)) start_heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts_ok (\\<lambda>t x h. \\<exists>ET. sconf_type_ok ET t x h)\n     (thr (start_state J_local_start P C M vs)) start_heap", "using sconf_type_ts_ok_J_start_state[OF assms]"], ["proof (prove)\nusing this:\n  sconf_type_ts_ok (J_sconf_type_ET_start P C M)\n   (thr (start_state J_local_start P C M vs))\n   (shr (start_state J_local_start P C M vs))\n\ngoal (1 subgoal):\n 1. ts_ok (\\<lambda>t x h. \\<exists>ET. sconf_type_ok ET t x h)\n     (thr (start_state J_local_start P C M vs)) start_heap", "unfolding shr_start_state"], ["proof (prove)\nusing this:\n  sconf_type_ts_ok (J_sconf_type_ET_start P C M)\n   (thr (start_state J_local_start P C M vs)) start_heap\n\ngoal (1 subgoal):\n 1. ts_ok (\\<lambda>t x h. \\<exists>ET. sconf_type_ok ET t x h)\n     (thr (start_state J_local_start P C M vs)) start_heap", "by(rule ts_inv_into_ts_ok_Ex)"], ["", "end"], ["", "context J_conf_read begin"], ["", "lemma red_preserves_type_ok: \n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow> \\<langle>e',s'\\<rangle>; wf_J_prog P; E \\<turnstile> s \\<surd>; type_ok P (E, T) e (hp s); P,hp s \\<turnstile> t \\<surd>t \\<rbrakk> \\<Longrightarrow> type_ok P (E, T) e' (hp s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n     wf_J_prog P; E \\<turnstile> s \\<surd>; type_ok P (E, T) e (hp s);\n     P,hp s \\<turnstile> t \\<surd>t\\<rbrakk>\n    \\<Longrightarrow> type_ok P (E, T) e' (hp s')", "apply(clarsimp simp add: type_ok_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>T'.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        wf_J_prog P; E \\<turnstile> s \\<surd>;\n        P,hp s \\<turnstile> t \\<surd>t; P,E,hp s \\<turnstile> e : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T'.\n                            P,E,hp s' \\<turnstile> e' : T' \\<and>\n                            P \\<turnstile> T' \\<le> T", "apply(subgoal_tac \"\\<exists>T''. P,E,hp s' \\<turnstile> e' : T'' \\<and> P \\<turnstile> T'' \\<le> T'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>T'.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        wf_J_prog P; E \\<turnstile> s \\<surd>;\n        P,hp s \\<turnstile> t \\<surd>t; P,E,hp s \\<turnstile> e : T';\n        P \\<turnstile> T' \\<le> T;\n        \\<exists>T''.\n           P,E,hp s' \\<turnstile> e' : T'' \\<and>\n           P \\<turnstile> T'' \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T'.\n                            P,E,hp s' \\<turnstile> e' : T' \\<and>\n                            P \\<turnstile> T' \\<le> T\n 2. \\<And>T'.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        wf_J_prog P; E \\<turnstile> s \\<surd>;\n        P,hp s \\<turnstile> t \\<surd>t; P,E,hp s \\<turnstile> e : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T''.\n                            P,E,hp s' \\<turnstile> e' : T'' \\<and>\n                            P \\<turnstile> T'' \\<le> T'", "apply(fast elim: widen_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>T'.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        wf_J_prog P; E \\<turnstile> s \\<surd>;\n        P,hp s \\<turnstile> t \\<surd>t; P,E,hp s \\<turnstile> e : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T''.\n                            P,E,hp s' \\<turnstile> e' : T'' \\<and>\n                            P \\<turnstile> T'' \\<le> T'", "by(rule subject_reduction)"], ["", "lemma lifting_inv_sconf_subject_ok:\n  assumes wf: \"wf_J_prog P\"\n  shows \"lifting_inv final_expr (mred P) sconf_type_ok\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lifting_inv final_expr\n     (\\<lambda>t ((e, l), h) ta ((e', l'), h').\n         extTA2J\n          P,P,t \\<turnstile> \\<langle>e,(h, l)\\<rangle> -ta\\<rightarrow>\n                             \\<langle>e',(h', l')\\<rangle>)\n     sconf_type_ok", "proof(unfold_locales)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t x m ta x' m' i.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m';\n        sconf_type_ok i t x m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i t x' m'\n 2. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 3. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "fix t x m ta x' m' i"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t x m ta x' m' i.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m';\n        sconf_type_ok i t x m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i t x' m'\n 2. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 3. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "assume mred: \"mred P t (x, m) ta (x', m')\"\n    and \"sconf_type_ok i t x m\""], ["proof (state)\nthis:\n  red_mthr.r_syntax P t x m ta x' m'\n  sconf_type_ok i t x m\n\ngoal (3 subgoals):\n 1. \\<And>t x m ta x' m' i.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m';\n        sconf_type_ok i t x m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i t x' m'\n 2. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 3. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "moreover"], ["proof (state)\nthis:\n  red_mthr.r_syntax P t x m ta x' m'\n  sconf_type_ok i t x m\n\ngoal (3 subgoals):\n 1. \\<And>t x m ta x' m' i.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m';\n        sconf_type_ok i t x m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i t x' m'\n 2. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 3. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "obtain e l where x [simp]: \"x = (e, l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e l. x = (e, l) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases x, auto)"], ["proof (state)\nthis:\n  x = (e, l)\n\ngoal (3 subgoals):\n 1. \\<And>t x m ta x' m' i.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m';\n        sconf_type_ok i t x m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i t x' m'\n 2. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 3. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "moreover"], ["proof (state)\nthis:\n  x = (e, l)\n\ngoal (3 subgoals):\n 1. \\<And>t x m ta x' m' i.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m';\n        sconf_type_ok i t x m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i t x' m'\n 2. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 3. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "obtain e' l' where x' [simp]: \"x' = (e', l')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e' l'. x' = (e', l') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases x', auto)"], ["proof (state)\nthis:\n  x' = (e', l')\n\ngoal (3 subgoals):\n 1. \\<And>t x m ta x' m' i.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m';\n        sconf_type_ok i t x m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i t x' m'\n 2. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 3. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "moreover"], ["proof (state)\nthis:\n  x' = (e', l')\n\ngoal (3 subgoals):\n 1. \\<And>t x m ta x' m' i.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m';\n        sconf_type_ok i t x m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i t x' m'\n 2. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 3. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "obtain E T where i [simp]: \"i = (E, T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>E T. i = (E, T) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases i, auto)"], ["proof (state)\nthis:\n  i = (E, T)\n\ngoal (3 subgoals):\n 1. \\<And>t x m ta x' m' i.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m';\n        sconf_type_ok i t x m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i t x' m'\n 2. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 3. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "ultimately"], ["proof (chain)\npicking this:\n  red_mthr.r_syntax P t x m ta x' m'\n  sconf_type_ok i t x m\n  x = (e, l)\n  x' = (e', l')\n  i = (E, T)", "have sconf_type: \"sconf_type_ok (E, T) t (e, l) m\"\n    and red: \"P,t \\<turnstile> \\<langle>e, (m, l)\\<rangle> -ta\\<rightarrow> \\<langle>e', (m', l')\\<rangle>\""], ["proof (prove)\nusing this:\n  red_mthr.r_syntax P t x m ta x' m'\n  sconf_type_ok i t x m\n  x = (e, l)\n  x' = (e', l')\n  i = (E, T)\n\ngoal (1 subgoal):\n 1. sconf_type_ok (E, T) t (e, l) m &&&\n    extTA2J\n     P,P,t \\<turnstile> \\<langle>e,(m, l)\\<rangle> -ta\\<rightarrow>\n                        \\<langle>e',(m', l')\\<rangle>", "by auto"], ["proof (state)\nthis:\n  sconf_type_ok (E, T) t (e, l) m\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e,(m, l)\\<rangle> -ta\\<rightarrow>\n                      \\<langle>e',(m', l')\\<rangle>\n\ngoal (3 subgoals):\n 1. \\<And>t x m ta x' m' i.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m';\n        sconf_type_ok i t x m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i t x' m'\n 2. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 3. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "from sconf_type"], ["proof (chain)\npicking this:\n  sconf_type_ok (E, T) t (e, l) m", "have sconf: \"E \\<turnstile> (m, l) \\<surd>\" and \"type_ok P (E, T) e m\" and tconf: \"P,m \\<turnstile> t \\<surd>t\""], ["proof (prove)\nusing this:\n  sconf_type_ok (E, T) t (e, l) m\n\ngoal (1 subgoal):\n 1. E \\<turnstile> (m, l) \\<surd> &&&\n    type_ok P (E, T) e m &&& P,m \\<turnstile> t \\<surd>t", "by(auto simp add: sconf_type_ok_def)"], ["proof (state)\nthis:\n  E \\<turnstile> (m, l) \\<surd>\n  type_ok P (E, T) e m\n  P,m \\<turnstile> t \\<surd>t\n\ngoal (3 subgoals):\n 1. \\<And>t x m ta x' m' i.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m';\n        sconf_type_ok i t x m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i t x' m'\n 2. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 3. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "then"], ["proof (chain)\npicking this:\n  E \\<turnstile> (m, l) \\<surd>\n  type_ok P (E, T) e m\n  P,m \\<turnstile> t \\<surd>t", "obtain T' where \"P,E,m \\<turnstile> e : T'\" \"P \\<turnstile> T' \\<le> T\""], ["proof (prove)\nusing this:\n  E \\<turnstile> (m, l) \\<surd>\n  type_ok P (E, T) e m\n  P,m \\<turnstile> t \\<surd>t\n\ngoal (1 subgoal):\n 1. (\\<And>T'.\n        \\<lbrakk>P,E,m \\<turnstile> e : T';\n         P \\<turnstile> T' \\<le> T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: type_ok_def)"], ["proof (state)\nthis:\n  P,E,m \\<turnstile> e : T'\n  P \\<turnstile> T' \\<le> T\n\ngoal (3 subgoals):\n 1. \\<And>t x m ta x' m' i.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m';\n        sconf_type_ok i t x m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i t x' m'\n 2. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 3. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "from \\<open>E \\<turnstile> (m, l) \\<surd>\\<close> \\<open>P,E,m \\<turnstile> e : T'\\<close> red tconf"], ["proof (chain)\npicking this:\n  E \\<turnstile> (m, l) \\<surd>\n  P,E,m \\<turnstile> e : T'\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e,(m, l)\\<rangle> -ta\\<rightarrow>\n                      \\<langle>e',(m', l')\\<rangle>\n  P,m \\<turnstile> t \\<surd>t", "have \"E \\<turnstile> (m', l') \\<surd>\""], ["proof (prove)\nusing this:\n  E \\<turnstile> (m, l) \\<surd>\n  P,E,m \\<turnstile> e : T'\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e,(m, l)\\<rangle> -ta\\<rightarrow>\n                      \\<langle>e',(m', l')\\<rangle>\n  P,m \\<turnstile> t \\<surd>t\n\ngoal (1 subgoal):\n 1. E \\<turnstile> (m', l') \\<surd>", "by(auto elim: red_preserves_sconf)"], ["proof (state)\nthis:\n  E \\<turnstile> (m', l') \\<surd>\n\ngoal (3 subgoals):\n 1. \\<And>t x m ta x' m' i.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m';\n        sconf_type_ok i t x m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i t x' m'\n 2. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 3. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "moreover"], ["proof (state)\nthis:\n  E \\<turnstile> (m', l') \\<surd>\n\ngoal (3 subgoals):\n 1. \\<And>t x m ta x' m' i.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m';\n        sconf_type_ok i t x m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i t x' m'\n 2. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 3. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "from red \\<open>P,E,m \\<turnstile> e : T'\\<close> wf \\<open>E \\<turnstile> (m, l) \\<surd>\\<close> tconf"], ["proof (chain)\npicking this:\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e,(m, l)\\<rangle> -ta\\<rightarrow>\n                      \\<langle>e',(m', l')\\<rangle>\n  P,E,m \\<turnstile> e : T'\n  wf_J_prog P\n  E \\<turnstile> (m, l) \\<surd>\n  P,m \\<turnstile> t \\<surd>t", "obtain T'' where \"P,E,m' \\<turnstile> e' : T''\" \"P \\<turnstile> T'' \\<le> T'\""], ["proof (prove)\nusing this:\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e,(m, l)\\<rangle> -ta\\<rightarrow>\n                      \\<langle>e',(m', l')\\<rangle>\n  P,E,m \\<turnstile> e : T'\n  wf_J_prog P\n  E \\<turnstile> (m, l) \\<surd>\n  P,m \\<turnstile> t \\<surd>t\n\ngoal (1 subgoal):\n 1. (\\<And>T''.\n        \\<lbrakk>P,E,m' \\<turnstile> e' : T'';\n         P \\<turnstile> T'' \\<le> T'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: subject_reduction)"], ["proof (state)\nthis:\n  P,E,m' \\<turnstile> e' : T''\n  P \\<turnstile> T'' \\<le> T'\n\ngoal (3 subgoals):\n 1. \\<And>t x m ta x' m' i.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m';\n        sconf_type_ok i t x m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i t x' m'\n 2. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 3. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "note \\<open>P,E,m' \\<turnstile> e' : T''\\<close>"], ["proof (state)\nthis:\n  P,E,m' \\<turnstile> e' : T''\n\ngoal (3 subgoals):\n 1. \\<And>t x m ta x' m' i.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m';\n        sconf_type_ok i t x m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i t x' m'\n 2. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 3. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "moreover"], ["proof (state)\nthis:\n  P,E,m' \\<turnstile> e' : T''\n\ngoal (3 subgoals):\n 1. \\<And>t x m ta x' m' i.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m';\n        sconf_type_ok i t x m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i t x' m'\n 2. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 3. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "from \\<open>P \\<turnstile> T'' \\<le> T'\\<close> \\<open>P \\<turnstile> T' \\<le> T\\<close>"], ["proof (chain)\npicking this:\n  P \\<turnstile> T'' \\<le> T'\n  P \\<turnstile> T' \\<le> T", "have \"P \\<turnstile> T'' \\<le> T\""], ["proof (prove)\nusing this:\n  P \\<turnstile> T'' \\<le> T'\n  P \\<turnstile> T' \\<le> T\n\ngoal (1 subgoal):\n 1. P \\<turnstile> T'' \\<le> T", "by(rule widen_trans)"], ["proof (state)\nthis:\n  P \\<turnstile> T'' \\<le> T\n\ngoal (3 subgoals):\n 1. \\<And>t x m ta x' m' i.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m';\n        sconf_type_ok i t x m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i t x' m'\n 2. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 3. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "moreover"], ["proof (state)\nthis:\n  P \\<turnstile> T'' \\<le> T\n\ngoal (3 subgoals):\n 1. \\<And>t x m ta x' m' i.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m';\n        sconf_type_ok i t x m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i t x' m'\n 2. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 3. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "from mred tconf"], ["proof (chain)\npicking this:\n  red_mthr.r_syntax P t x m ta x' m'\n  P,m \\<turnstile> t \\<surd>t", "have \"P,m' \\<turnstile> t \\<surd>t\""], ["proof (prove)\nusing this:\n  red_mthr.r_syntax P t x m ta x' m'\n  P,m \\<turnstile> t \\<surd>t\n\ngoal (1 subgoal):\n 1. P,m' \\<turnstile> t \\<surd>t", "by(rule red_tconf.preserves_red)"], ["proof (state)\nthis:\n  P,m' \\<turnstile> t \\<surd>t\n\ngoal (3 subgoals):\n 1. \\<And>t x m ta x' m' i.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m';\n        sconf_type_ok i t x m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i t x' m'\n 2. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 3. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "ultimately"], ["proof (chain)\npicking this:\n  E \\<turnstile> (m', l') \\<surd>\n  P,E,m' \\<turnstile> e' : T''\n  P \\<turnstile> T'' \\<le> T\n  P,m' \\<turnstile> t \\<surd>t", "have \"sconf_type_ok (E, T) t (e', l') m'\""], ["proof (prove)\nusing this:\n  E \\<turnstile> (m', l') \\<surd>\n  P,E,m' \\<turnstile> e' : T''\n  P \\<turnstile> T'' \\<le> T\n  P,m' \\<turnstile> t \\<surd>t\n\ngoal (1 subgoal):\n 1. sconf_type_ok (E, T) t (e', l') m'", "by(auto simp add: sconf_type_ok_def type_ok_def)"], ["proof (state)\nthis:\n  sconf_type_ok (E, T) t (e', l') m'\n\ngoal (3 subgoals):\n 1. \\<And>t x m ta x' m' i.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m';\n        sconf_type_ok i t x m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i t x' m'\n 2. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 3. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "thus \"sconf_type_ok i t x' m'\""], ["proof (prove)\nusing this:\n  sconf_type_ok (E, T) t (e', l') m'\n\ngoal (1 subgoal):\n 1. sconf_type_ok i t x' m'", "by simp"], ["proof (state)\nthis:\n  sconf_type_ok i t x' m'\n\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 2. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 2. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "fix t x m ta x' m' i t'' x''"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 2. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "assume mred: \"mred P t (x, m) ta (x', m')\"\n    and \"sconf_type_ok i t x m\"\n    and \"NewThread t'' x'' m' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\""], ["proof (state)\nthis:\n  red_mthr.r_syntax P t x m ta x' m'\n  sconf_type_ok i t x m\n  NewThread t'' x'' m' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 2. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "moreover"], ["proof (state)\nthis:\n  red_mthr.r_syntax P t x m ta x' m'\n  sconf_type_ok i t x m\n  NewThread t'' x'' m' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 2. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "obtain e l where x [simp]: \"x = (e, l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e l. x = (e, l) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases x, auto)"], ["proof (state)\nthis:\n  x = (e, l)\n\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 2. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "moreover"], ["proof (state)\nthis:\n  x = (e, l)\n\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 2. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "obtain e' l' where x' [simp]: \"x' = (e', l')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e' l'. x' = (e', l') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases x', auto)"], ["proof (state)\nthis:\n  x' = (e', l')\n\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 2. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "moreover"], ["proof (state)\nthis:\n  x' = (e', l')\n\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 2. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "obtain E T where i [simp]: \"i = (E, T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>E T. i = (E, T) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases i, auto)"], ["proof (state)\nthis:\n  i = (E, T)\n\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 2. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "moreover"], ["proof (state)\nthis:\n  i = (E, T)\n\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 2. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "obtain e'' l'' where x'' [simp]: \"x'' = (e'', l'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e'' l''.\n        x'' = (e'', l'') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases x'', auto)"], ["proof (state)\nthis:\n  x'' = (e'', l'')\n\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 2. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "ultimately"], ["proof (chain)\npicking this:\n  red_mthr.r_syntax P t x m ta x' m'\n  sconf_type_ok i t x m\n  NewThread t'' x'' m' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n  x = (e, l)\n  x' = (e', l')\n  i = (E, T)\n  x'' = (e'', l'')", "have sconf_type: \"sconf_type_ok (E, T) t (e, l) m\"\n    and red: \"P,t \\<turnstile> \\<langle>e, (m, l)\\<rangle> -ta\\<rightarrow> \\<langle>e', (m', l')\\<rangle>\"\n    and nt: \"NewThread t'' (e'', l'') m' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\""], ["proof (prove)\nusing this:\n  red_mthr.r_syntax P t x m ta x' m'\n  sconf_type_ok i t x m\n  NewThread t'' x'' m' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n  x = (e, l)\n  x' = (e', l')\n  i = (E, T)\n  x'' = (e'', l'')\n\ngoal (1 subgoal):\n 1. sconf_type_ok (E, T) t (e, l) m &&&\n    extTA2J\n     P,P,t \\<turnstile> \\<langle>e,(m, l)\\<rangle> -ta\\<rightarrow>\n                        \\<langle>e',(m', l')\\<rangle> &&&\n    NewThread t'' (e'', l'') m'\n    \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>", "by auto"], ["proof (state)\nthis:\n  sconf_type_ok (E, T) t (e, l) m\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e,(m, l)\\<rangle> -ta\\<rightarrow>\n                      \\<langle>e',(m', l')\\<rangle>\n  NewThread t'' (e'', l'') m'\n  \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 2. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "from sconf_type"], ["proof (chain)\npicking this:\n  sconf_type_ok (E, T) t (e, l) m", "have sconf: \"E \\<turnstile> (m, l) \\<surd>\" and \"type_ok P (E, T) e m\" and tconf: \"P,m \\<turnstile> t \\<surd>t\""], ["proof (prove)\nusing this:\n  sconf_type_ok (E, T) t (e, l) m\n\ngoal (1 subgoal):\n 1. E \\<turnstile> (m, l) \\<surd> &&&\n    type_ok P (E, T) e m &&& P,m \\<turnstile> t \\<surd>t", "by(auto simp add: sconf_type_ok_def)"], ["proof (state)\nthis:\n  E \\<turnstile> (m, l) \\<surd>\n  type_ok P (E, T) e m\n  P,m \\<turnstile> t \\<surd>t\n\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 2. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "then"], ["proof (chain)\npicking this:\n  E \\<turnstile> (m, l) \\<surd>\n  type_ok P (E, T) e m\n  P,m \\<turnstile> t \\<surd>t", "obtain T' where \"P,E,m \\<turnstile> e : T'\" \"P \\<turnstile> T' \\<le> T\""], ["proof (prove)\nusing this:\n  E \\<turnstile> (m, l) \\<surd>\n  type_ok P (E, T) e m\n  P,m \\<turnstile> t \\<surd>t\n\ngoal (1 subgoal):\n 1. (\\<And>T'.\n        \\<lbrakk>P,E,m \\<turnstile> e : T';\n         P \\<turnstile> T' \\<le> T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: type_ok_def)"], ["proof (state)\nthis:\n  P,E,m \\<turnstile> e : T'\n  P \\<turnstile> T' \\<le> T\n\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 2. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "from nt \\<open>P,E,m \\<turnstile> e : T'\\<close> red"], ["proof (chain)\npicking this:\n  NewThread t'' (e'', l'') m'\n  \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n  P,E,m \\<turnstile> e : T'\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e,(m, l)\\<rangle> -ta\\<rightarrow>\n                      \\<langle>e',(m', l')\\<rangle>", "have \"\\<exists>E T. P,E,m' \\<turnstile> e'' : T \\<and> P,m' \\<turnstile> l'' (:\\<le>) E\""], ["proof (prove)\nusing this:\n  NewThread t'' (e'', l'') m'\n  \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n  P,E,m \\<turnstile> e : T'\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e,(m, l)\\<rangle> -ta\\<rightarrow>\n                      \\<langle>e',(m', l')\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>E T.\n       P,E,m' \\<turnstile> e'' : T \\<and> P,m' \\<turnstile> l'' (:\\<le>) E", "by(fastforce dest: red_type_newthread[OF wf])"], ["proof (state)\nthis:\n  \\<exists>E T.\n     P,E,m' \\<turnstile> e'' : T \\<and> P,m' \\<turnstile> l'' (:\\<le>) E\n\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 2. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "then"], ["proof (chain)\npicking this:\n  \\<exists>E T.\n     P,E,m' \\<turnstile> e'' : T \\<and> P,m' \\<turnstile> l'' (:\\<le>) E", "obtain E'' T'' where \"P,E'',m' \\<turnstile> e'' : T''\" \"P,m' \\<turnstile> l'' (:\\<le>) E''\""], ["proof (prove)\nusing this:\n  \\<exists>E T.\n     P,E,m' \\<turnstile> e'' : T \\<and> P,m' \\<turnstile> l'' (:\\<le>) E\n\ngoal (1 subgoal):\n 1. (\\<And>E'' T''.\n        \\<lbrakk>P,E'',m' \\<turnstile> e'' : T'';\n         P,m' \\<turnstile> l'' (:\\<le>) E''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  P,E'',m' \\<turnstile> e'' : T''\n  P,m' \\<turnstile> l'' (:\\<le>) E''\n\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 2. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "moreover"], ["proof (state)\nthis:\n  P,E'',m' \\<turnstile> e'' : T''\n  P,m' \\<turnstile> l'' (:\\<le>) E''\n\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 2. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "from sconf red \\<open>P,E,m \\<turnstile> e : T'\\<close> tconf"], ["proof (chain)\npicking this:\n  E \\<turnstile> (m, l) \\<surd>\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e,(m, l)\\<rangle> -ta\\<rightarrow>\n                      \\<langle>e',(m', l')\\<rangle>\n  P,E,m \\<turnstile> e : T'\n  P,m \\<turnstile> t \\<surd>t", "have \"E \\<turnstile> (m', l') \\<surd>\""], ["proof (prove)\nusing this:\n  E \\<turnstile> (m, l) \\<surd>\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e,(m, l)\\<rangle> -ta\\<rightarrow>\n                      \\<langle>e',(m', l')\\<rangle>\n  P,E,m \\<turnstile> e : T'\n  P,m \\<turnstile> t \\<surd>t\n\ngoal (1 subgoal):\n 1. E \\<turnstile> (m', l') \\<surd>", "by(auto intro: red_preserves_sconf)"], ["proof (state)\nthis:\n  E \\<turnstile> (m', l') \\<surd>\n\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 2. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "moreover"], ["proof (state)\nthis:\n  E \\<turnstile> (m', l') \\<surd>\n\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 2. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "from mred tconf \\<open>NewThread t'' x'' m' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  red_mthr.r_syntax P t x m ta x' m'\n  P,m \\<turnstile> t \\<surd>t\n  NewThread t'' x'' m' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>", "have \"P,m' \\<turnstile> t'' \\<surd>t\""], ["proof (prove)\nusing this:\n  red_mthr.r_syntax P t x m ta x' m'\n  P,m \\<turnstile> t \\<surd>t\n  NewThread t'' x'' m' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n\ngoal (1 subgoal):\n 1. P,m' \\<turnstile> t'' \\<surd>t", "by(rule red_tconf.preserves_NewThread)"], ["proof (state)\nthis:\n  P,m' \\<turnstile> t'' \\<surd>t\n\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m' i t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        NewThread t'' x'' m'\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n 2. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "ultimately"], ["proof (chain)\npicking this:\n  P,E'',m' \\<turnstile> e'' : T''\n  P,m' \\<turnstile> l'' (:\\<le>) E''\n  E \\<turnstile> (m', l') \\<surd>\n  P,m' \\<turnstile> t'' \\<surd>t", "show \"\\<exists>i''. sconf_type_ok i'' t'' x'' m'\""], ["proof (prove)\nusing this:\n  P,E'',m' \\<turnstile> e'' : T''\n  P,m' \\<turnstile> l'' (:\\<le>) E''\n  E \\<turnstile> (m', l') \\<surd>\n  P,m' \\<turnstile> t'' \\<surd>t\n\ngoal (1 subgoal):\n 1. \\<exists>i''. sconf_type_ok i'' t'' x'' m'", "by(auto simp add: sconf_type_ok_def type_ok_def sconf_def)"], ["proof (state)\nthis:\n  \\<exists>i''. sconf_type_ok i'' t'' x'' m'\n\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "fix t x m ta x' m' i i'' t'' x''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "assume mred: \"mred P t (x, m) ta (x', m')\" \n    and \"sconf_type_ok i t x m\" \n    and \"sconf_type_ok i'' t'' x'' m\""], ["proof (state)\nthis:\n  red_mthr.r_syntax P t x m ta x' m'\n  sconf_type_ok i t x m\n  sconf_type_ok i'' t'' x'' m\n\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "moreover"], ["proof (state)\nthis:\n  red_mthr.r_syntax P t x m ta x' m'\n  sconf_type_ok i t x m\n  sconf_type_ok i'' t'' x'' m\n\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "obtain e l where x [simp]: \"x = (e, l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e l. x = (e, l) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases x, auto)"], ["proof (state)\nthis:\n  x = (e, l)\n\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "moreover"], ["proof (state)\nthis:\n  x = (e, l)\n\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "obtain e' l' where x' [simp]: \"x' = (e', l')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e' l'. x' = (e', l') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases x', auto)"], ["proof (state)\nthis:\n  x' = (e', l')\n\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "moreover"], ["proof (state)\nthis:\n  x' = (e', l')\n\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "obtain E T where i [simp]: \"i = (E, T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>E T. i = (E, T) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases i, auto)"], ["proof (state)\nthis:\n  i = (E, T)\n\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "moreover"], ["proof (state)\nthis:\n  i = (E, T)\n\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "obtain e'' l'' where x'' [simp]: \"x'' = (e'', l'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e'' l''.\n        x'' = (e'', l'') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases x'', auto)"], ["proof (state)\nthis:\n  x'' = (e'', l'')\n\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "moreover"], ["proof (state)\nthis:\n  x'' = (e'', l'')\n\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "obtain E'' T'' where i'' [simp]: \"i'' = (E'', T'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>E'' T''.\n        i'' = (E'', T'') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases i'', auto)"], ["proof (state)\nthis:\n  i'' = (E'', T'')\n\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "ultimately"], ["proof (chain)\npicking this:\n  red_mthr.r_syntax P t x m ta x' m'\n  sconf_type_ok i t x m\n  sconf_type_ok i'' t'' x'' m\n  x = (e, l)\n  x' = (e', l')\n  i = (E, T)\n  x'' = (e'', l'')\n  i'' = (E'', T'')", "have sconf_type: \"sconf_type_ok (E, T) t (e, l) m\"\n    and red: \"P,t \\<turnstile> \\<langle>e, (m, l)\\<rangle> -ta\\<rightarrow> \\<langle>e', (m', l')\\<rangle>\"\n    and sc: \"sconf_type_ok (E'', T'') t'' (e'', l'') m\""], ["proof (prove)\nusing this:\n  red_mthr.r_syntax P t x m ta x' m'\n  sconf_type_ok i t x m\n  sconf_type_ok i'' t'' x'' m\n  x = (e, l)\n  x' = (e', l')\n  i = (E, T)\n  x'' = (e'', l'')\n  i'' = (E'', T'')\n\ngoal (1 subgoal):\n 1. sconf_type_ok (E, T) t (e, l) m &&&\n    extTA2J\n     P,P,t \\<turnstile> \\<langle>e,(m, l)\\<rangle> -ta\\<rightarrow>\n                        \\<langle>e',(m', l')\\<rangle> &&&\n    sconf_type_ok (E'', T'') t'' (e'', l'') m", "by auto"], ["proof (state)\nthis:\n  sconf_type_ok (E, T) t (e, l) m\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e,(m, l)\\<rangle> -ta\\<rightarrow>\n                      \\<langle>e',(m', l')\\<rangle>\n  sconf_type_ok (E'', T'') t'' (e'', l'') m\n\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "from sconf_type"], ["proof (chain)\npicking this:\n  sconf_type_ok (E, T) t (e, l) m", "obtain T' where \"P,E,m \\<turnstile> e : T'\" and \"P,m \\<turnstile> t \\<surd>t\""], ["proof (prove)\nusing this:\n  sconf_type_ok (E, T) t (e, l) m\n\ngoal (1 subgoal):\n 1. (\\<And>T'.\n        \\<lbrakk>P,E,m \\<turnstile> e : T';\n         P,m \\<turnstile> t \\<surd>t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: sconf_type_ok_def type_ok_def)"], ["proof (state)\nthis:\n  P,E,m \\<turnstile> e : T'\n  P,m \\<turnstile> t \\<surd>t\n\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "from sc"], ["proof (chain)\npicking this:\n  sconf_type_ok (E'', T'') t'' (e'', l'') m", "have sconf: \"E'' \\<turnstile> (m, l'') \\<surd>\" and \"type_ok P (E'', T'') e'' m\" and \"P,m \\<turnstile> t'' \\<surd>t\""], ["proof (prove)\nusing this:\n  sconf_type_ok (E'', T'') t'' (e'', l'') m\n\ngoal (1 subgoal):\n 1. E'' \\<turnstile> (m, l'') \\<surd> &&&\n    type_ok P (E'', T'') e'' m &&& P,m \\<turnstile> t'' \\<surd>t", "by(auto simp add: sconf_type_ok_def)"], ["proof (state)\nthis:\n  E'' \\<turnstile> (m, l'') \\<surd>\n  type_ok P (E'', T'') e'' m\n  P,m \\<turnstile> t'' \\<surd>t\n\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "then"], ["proof (chain)\npicking this:\n  E'' \\<turnstile> (m, l'') \\<surd>\n  type_ok P (E'', T'') e'' m\n  P,m \\<turnstile> t'' \\<surd>t", "obtain T''' where \"P,E'',m \\<turnstile> e'' : T'''\" \"P \\<turnstile> T''' \\<le> T''\""], ["proof (prove)\nusing this:\n  E'' \\<turnstile> (m, l'') \\<surd>\n  type_ok P (E'', T'') e'' m\n  P,m \\<turnstile> t'' \\<surd>t\n\ngoal (1 subgoal):\n 1. (\\<And>T'''.\n        \\<lbrakk>P,E'',m \\<turnstile> e'' : T''';\n         P \\<turnstile> T''' \\<le> T''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: type_ok_def)"], ["proof (state)\nthis:\n  P,E'',m \\<turnstile> e'' : T'''\n  P \\<turnstile> T''' \\<le> T''\n\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "moreover"], ["proof (state)\nthis:\n  P,E'',m \\<turnstile> e'' : T'''\n  P \\<turnstile> T''' \\<le> T''\n\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "from red \\<open>P,E'',m \\<turnstile> e'' : T'''\\<close>"], ["proof (chain)\npicking this:\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e,(m, l)\\<rangle> -ta\\<rightarrow>\n                      \\<langle>e',(m', l')\\<rangle>\n  P,E'',m \\<turnstile> e'' : T'''", "have \"P,E'',m' \\<turnstile> e'' : T'''\""], ["proof (prove)\nusing this:\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e,(m, l)\\<rangle> -ta\\<rightarrow>\n                      \\<langle>e',(m', l')\\<rangle>\n  P,E'',m \\<turnstile> e'' : T'''\n\ngoal (1 subgoal):\n 1. P,E'',m' \\<turnstile> e'' : T'''", "by(rule red_preserve_welltype)"], ["proof (state)\nthis:\n  P,E'',m' \\<turnstile> e'' : T'''\n\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "moreover"], ["proof (state)\nthis:\n  P,E'',m' \\<turnstile> e'' : T'''\n\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "from sconf red \\<open>P,E,m \\<turnstile> e : T'\\<close>"], ["proof (chain)\npicking this:\n  E'' \\<turnstile> (m, l'') \\<surd>\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e,(m, l)\\<rangle> -ta\\<rightarrow>\n                      \\<langle>e',(m', l')\\<rangle>\n  P,E,m \\<turnstile> e : T'", "have \"hconf m'\""], ["proof (prove)\nusing this:\n  E'' \\<turnstile> (m, l'') \\<surd>\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e,(m, l)\\<rangle> -ta\\<rightarrow>\n                      \\<langle>e',(m', l')\\<rangle>\n  P,E,m \\<turnstile> e : T'\n\ngoal (1 subgoal):\n 1. hconf m'", "unfolding sconf_def"], ["proof (prove)\nusing this:\n  let (h, l) = (m, l'')\n  in hconf h \\<and> P,h \\<turnstile> l (:\\<le>) E'' \\<and> preallocated h\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e,(m, l)\\<rangle> -ta\\<rightarrow>\n                      \\<langle>e',(m', l')\\<rangle>\n  P,E,m \\<turnstile> e : T'\n\ngoal (1 subgoal):\n 1. hconf m'", "by(auto dest: red_preserves_hconf)"], ["proof (state)\nthis:\n  hconf m'\n\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "moreover"], ["proof (state)\nthis:\n  hconf m'\n\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "{"], ["proof (state)\nthis:\n  hconf m'\n\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "from red"], ["proof (chain)\npicking this:\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e,(m, l)\\<rangle> -ta\\<rightarrow>\n                      \\<langle>e',(m', l')\\<rangle>", "have \"hext m m'\""], ["proof (prove)\nusing this:\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e,(m, l)\\<rangle> -ta\\<rightarrow>\n                      \\<langle>e',(m', l')\\<rangle>\n\ngoal (1 subgoal):\n 1. m \\<unlhd> m'", "by(auto dest: red_hext_incr)"], ["proof (state)\nthis:\n  m \\<unlhd> m'\n\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "moreover"], ["proof (state)\nthis:\n  m \\<unlhd> m'\n\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "from sconf"], ["proof (chain)\npicking this:\n  E'' \\<turnstile> (m, l'') \\<surd>", "have \"P,m \\<turnstile> l'' (:\\<le>) E''\" \"preallocated m\""], ["proof (prove)\nusing this:\n  E'' \\<turnstile> (m, l'') \\<surd>\n\ngoal (1 subgoal):\n 1. P,m \\<turnstile> l'' (:\\<le>) E'' &&& preallocated m", "by(simp_all add: sconf_def)"], ["proof (state)\nthis:\n  P,m \\<turnstile> l'' (:\\<le>) E''\n  preallocated m\n\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "ultimately"], ["proof (chain)\npicking this:\n  m \\<unlhd> m'\n  P,m \\<turnstile> l'' (:\\<le>) E''\n  preallocated m", "have \"P,m' \\<turnstile> l'' (:\\<le>) E''\" \"preallocated m'\""], ["proof (prove)\nusing this:\n  m \\<unlhd> m'\n  P,m \\<turnstile> l'' (:\\<le>) E''\n  preallocated m\n\ngoal (1 subgoal):\n 1. P,m' \\<turnstile> l'' (:\\<le>) E'' &&& preallocated m'", "by(blast intro: lconf_hext preallocated_hext)+"], ["proof (state)\nthis:\n  P,m' \\<turnstile> l'' (:\\<le>) E''\n  preallocated m'\n\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "}"], ["proof (state)\nthis:\n  P,m' \\<turnstile> l'' (:\\<le>) E''\n  preallocated m'\n\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "moreover"], ["proof (state)\nthis:\n  P,m' \\<turnstile> l'' (:\\<le>) E''\n  preallocated m'\n\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "from mred \\<open>P,m \\<turnstile> t \\<surd>t\\<close> \\<open>P,m \\<turnstile> t'' \\<surd>t\\<close>"], ["proof (chain)\npicking this:\n  red_mthr.r_syntax P t x m ta x' m'\n  P,m \\<turnstile> t \\<surd>t\n  P,m \\<turnstile> t'' \\<surd>t", "have \"P,m' \\<turnstile> t'' \\<surd>t\""], ["proof (prove)\nusing this:\n  red_mthr.r_syntax P t x m ta x' m'\n  P,m \\<turnstile> t \\<surd>t\n  P,m \\<turnstile> t'' \\<surd>t\n\ngoal (1 subgoal):\n 1. P,m' \\<turnstile> t'' \\<surd>t", "by(rule red_tconf.preserves_other)"], ["proof (state)\nthis:\n  P,m' \\<turnstile> t'' \\<surd>t\n\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "ultimately"], ["proof (chain)\npicking this:\n  P,E'',m \\<turnstile> e'' : T'''\n  P \\<turnstile> T''' \\<le> T''\n  P,E'',m' \\<turnstile> e'' : T'''\n  hconf m'\n  P,m' \\<turnstile> l'' (:\\<le>) E''\n  preallocated m'\n  P,m' \\<turnstile> t'' \\<surd>t", "have \"sconf_type_ok (E'', T'') t'' (e'', l'') m'\""], ["proof (prove)\nusing this:\n  P,E'',m \\<turnstile> e'' : T'''\n  P \\<turnstile> T''' \\<le> T''\n  P,E'',m' \\<turnstile> e'' : T'''\n  hconf m'\n  P,m' \\<turnstile> l'' (:\\<le>) E''\n  preallocated m'\n  P,m' \\<turnstile> t'' \\<surd>t\n\ngoal (1 subgoal):\n 1. sconf_type_ok (E'', T'') t'' (e'', l'') m'", "by(auto simp add: sconf_type_ok_def sconf_def type_ok_def)"], ["proof (state)\nthis:\n  sconf_type_ok (E'', T'') t'' (e'', l'') m'\n\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m' i i'' t'' x''.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m'; sconf_type_ok i t x m;\n        sconf_type_ok i'' t'' x'' m\\<rbrakk>\n       \\<Longrightarrow> sconf_type_ok i'' t'' x'' m'", "thus \"sconf_type_ok i'' t'' x'' m'\""], ["proof (prove)\nusing this:\n  sconf_type_ok (E'', T'') t'' (e'', l'') m'\n\ngoal (1 subgoal):\n 1. sconf_type_ok i'' t'' x'' m'", "by simp"], ["proof (state)\nthis:\n  sconf_type_ok i'' t'' x'' m'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>@{term \"wf_red\"}\\<close>"], ["", "context J_progress begin"], ["", "context begin"], ["", "declare red_mthr.actions_ok_iff [simp del]"], ["", "declare red_mthr.actions_ok.cases [rule del]"], ["", "declare red_mthr.actions_ok.intros [rule del]"], ["", "lemma assumes wf: \"wf_prog wf_md P\"\n  shows red_wf_red_aux:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e',s'\\<rangle>; \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta; \n    sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n     \\<forall>l. has_locks (ls $ l) t \\<ge> expr_locks e l;\n     ws t = None \\<or> \n     (\\<exists>a vs w T Ts Tr D. call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and> typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and> P \\<turnstile> class_type_of T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and> ws t = \\<lfloor>PostWS w\\<rfloor>) \\<rbrakk>\n    \\<Longrightarrow> \\<exists>e'' s'' ta'. P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta'\\<rightarrow> \\<langle>e'',s''\\<rangle> \\<and> \n        (red_mthr.actions_ok (ls, (ts, m), ws, is) t ta' \\<or> \n         red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta' \\<and> red_mthr.actions_subset ta' ta)\"\n  (is \"\\<lbrakk> _; _; _; _; _; _; ?wakeup e s \\<rbrakk> \\<Longrightarrow> ?concl e s ta\")\n    and reds_wf_red_aux:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es',s'\\<rangle>; \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n     sync_oks es; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n     \\<forall>l. has_locks (ls $ l) t \\<ge> expr_lockss es l;\n     ws t = None \\<or> \n     (\\<exists>a vs w T Ts T Tr D. calls es = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and> typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and> P \\<turnstile> class_type_of T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and> ws t = \\<lfloor>PostWS w\\<rfloor>) \\<rbrakk>\n    \\<Longrightarrow> \\<exists>es'' s'' ta'. P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta'\\<rightarrow>] \\<langle>es'',s''\\<rangle> \\<and> \n        (red_mthr.actions_ok (ls, (ts, m), ws, is) t ta' \\<or> \n         red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta' \\<and> red_mthr.actions_subset ta' ta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>extTA2J\n               P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle>;\n      \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta; sync_ok e;\n      hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n      \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n      ws t = None \\<or>\n      (\\<exists>a vs w T Ts Tr D.\n          call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n          typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n          P \\<turnstile> class_type_of\n                          T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n          ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n     \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                          extTA2J\n                           P,P,t \\<turnstile> \\<langle>e,\n         s\\<rangle> -ta'\\<rightarrow>\n        \\<langle>e'',s''\\<rangle> \\<and>\n                          (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                            ta' \\<or>\n                           red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                            ta' \\<and>\n                           red_mthr.actions_subset ta' ta)) &&&\n    (\\<lbrakk>extTA2J\n               P,P,t \\<turnstile> \\<langle>es,s\\<rangle> [-ta\\<rightarrow>]\n                                  \\<langle>es',s'\\<rangle>;\n      \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta; sync_oks es;\n      hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n      \\<forall>l. expr_lockss es l \\<le> has_locks (ls $ l) t;\n      ws t = None \\<or>\n      (\\<exists>a vs w T Ts Ta Tr D.\n          calls es = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n          typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n          P \\<turnstile> class_type_of\n                          Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n          ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n     \\<Longrightarrow> \\<exists>es'' s'' ta'.\n                          extTA2J\n                           P,P,t \\<turnstile> \\<langle>es,\n         s\\<rangle> [-ta'\\<rightarrow>]\n        \\<langle>es'',s''\\<rangle> \\<and>\n                          (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                            ta' \\<or>\n                           red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                            ta' \\<and>\n                           red_mthr.actions_subset ta' ta))", "proof(induct rule: red_reds.inducts)"], ["proof (state)\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 98 subgoals...", "case (SynchronizedRed2 e s ta e' s' a)"], ["proof (state)\nthis:\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                      \\<langle>e',s'\\<rangle>\n  \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n   sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n   \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n   ws t = None \\<or>\n   (\\<exists>a vs w T Ts Tr D.\n       call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n       typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n       P \\<turnstile> class_type_of\n                       T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n       ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                       extTA2J\n                        P,P,t \\<turnstile> \\<langle>e,\n      s\\<rangle> -ta'\\<rightarrow>\n     \\<langle>e'',s''\\<rangle> \\<and>\n                       (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                         ta' \\<or>\n                        red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                         ta' \\<and>\n                        red_mthr.actions_subset ta' ta)\n  \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta\n  sync_ok (insync(a) e)\n  hconf (hp s)\n  P,hp s \\<turnstile> t \\<surd>t\n  \\<forall>l. expr_locks (insync(a) e) l \\<le> has_locks (ls $ l) t\n  ws t = None \\<or>\n  (\\<exists>aa vs w T Ts Tr D.\n      call (insync(a) e) = \\<lfloor>(aa, wait, vs)\\<rfloor> \\<and>\n      typeof_addr (hp s) aa = \\<lfloor>T\\<rfloor> \\<and>\n      P \\<turnstile> class_type_of\n                      T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n      ws t = \\<lfloor>PostWS w\\<rfloor>)\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 98 subgoals...", "note IH = \\<open>\\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta; sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n            \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t; ?wakeup e s\\<rbrakk>\n            \\<Longrightarrow> ?concl e s ta\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n   sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n   \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n   ws t = None \\<or>\n   (\\<exists>a vs w T Ts Tr D.\n       call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n       typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n       P \\<turnstile> class_type_of\n                       T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n       ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                       extTA2J\n                        P,P,t \\<turnstile> \\<langle>e,\n      s\\<rangle> -ta'\\<rightarrow>\n     \\<langle>e'',s''\\<rangle> \\<and>\n                       (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                         ta' \\<or>\n                        red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                         ta' \\<and>\n                        red_mthr.actions_subset ta' ta)\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 98 subgoals...", "note \\<open>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta\\<close>"], ["proof (state)\nthis:\n  \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 98 subgoals...", "moreover"], ["proof (state)\nthis:\n  \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 98 subgoals...", "from \\<open>sync_ok (insync(a) e)\\<close>"], ["proof (chain)\npicking this:\n  sync_ok (insync(a) e)", "have \"sync_ok e\""], ["proof (prove)\nusing this:\n  sync_ok (insync(a) e)\n\ngoal (1 subgoal):\n 1. sync_ok e", "by simp"], ["proof (state)\nthis:\n  sync_ok e\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 98 subgoals...", "moreover"], ["proof (state)\nthis:\n  sync_ok e\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 98 subgoals...", "note \\<open>hconf (hp s)\\<close> \\<open>P,hp s \\<turnstile> t \\<surd>t\\<close>"], ["proof (state)\nthis:\n  hconf (hp s)\n  P,hp s \\<turnstile> t \\<surd>t\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 98 subgoals...", "moreover"], ["proof (state)\nthis:\n  hconf (hp s)\n  P,hp s \\<turnstile> t \\<surd>t\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 98 subgoals...", "from \\<open>\\<forall>l. expr_locks (insync(a) e) l \\<le> has_locks (ls $ l) t\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>l. expr_locks (insync(a) e) l \\<le> has_locks (ls $ l) t", "have \"\\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t\""], ["proof (prove)\nusing this:\n  \\<forall>l. expr_locks (insync(a) e) l \\<le> has_locks (ls $ l) t\n\ngoal (1 subgoal):\n 1. \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t", "by(force split: if_split_asm)"], ["proof (state)\nthis:\n  \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 98 subgoals...", "moreover"], ["proof (state)\nthis:\n  \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 98 subgoals...", "from \\<open>?wakeup (insync(a) e) s\\<close>"], ["proof (chain)\npicking this:\n  ws t = None \\<or>\n  (\\<exists>aa vs w T Ts Tr D.\n      call (insync(a) e) = \\<lfloor>(aa, wait, vs)\\<rfloor> \\<and>\n      typeof_addr (hp s) aa = \\<lfloor>T\\<rfloor> \\<and>\n      P \\<turnstile> class_type_of\n                      T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n      ws t = \\<lfloor>PostWS w\\<rfloor>)", "have \"?wakeup e s\""], ["proof (prove)\nusing this:\n  ws t = None \\<or>\n  (\\<exists>aa vs w T Ts Tr D.\n      call (insync(a) e) = \\<lfloor>(aa, wait, vs)\\<rfloor> \\<and>\n      typeof_addr (hp s) aa = \\<lfloor>T\\<rfloor> \\<and>\n      P \\<turnstile> class_type_of\n                      T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n      ws t = \\<lfloor>PostWS w\\<rfloor>)\n\ngoal (1 subgoal):\n 1. ws t = None \\<or>\n    (\\<exists>a vs w T Ts Tr D.\n        call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n        typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n        P \\<turnstile> class_type_of\n                        T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n        ws t = \\<lfloor>PostWS w\\<rfloor>)", "by auto"], ["proof (state)\nthis:\n  ws t = None \\<or>\n  (\\<exists>a vs w T Ts Tr D.\n      call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n      typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n      P \\<turnstile> class_type_of\n                      T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n      ws t = \\<lfloor>PostWS w\\<rfloor>)\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 98 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta\n  sync_ok e\n  hconf (hp s)\n  P,hp s \\<turnstile> t \\<surd>t\n  \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t\n  ws t = None \\<or>\n  (\\<exists>a vs w T Ts Tr D.\n      call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n      typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n      P \\<turnstile> class_type_of\n                      T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n      ws t = \\<lfloor>PostWS w\\<rfloor>)", "have \"?concl e s ta\""], ["proof (prove)\nusing this:\n  \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta\n  sync_ok e\n  hconf (hp s)\n  P,hp s \\<turnstile> t \\<surd>t\n  \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t\n  ws t = None \\<or>\n  (\\<exists>a vs w T Ts Tr D.\n      call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n      typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n      P \\<turnstile> class_type_of\n                      T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n      ws t = \\<lfloor>PostWS w\\<rfloor>)\n\ngoal (1 subgoal):\n 1. \\<exists>e'' s'' ta'.\n       extTA2J\n        P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                           \\<langle>e'',s''\\<rangle> \\<and>\n       (red_mthr.actions_ok (ls, (ts, m), ws, is) t ta' \\<or>\n        red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta' \\<and>\n        red_mthr.actions_subset ta' ta)", "by(rule IH)"], ["proof (state)\nthis:\n  \\<exists>e'' s'' ta'.\n     extTA2J\n      P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                         \\<langle>e'',s''\\<rangle> \\<and>\n     (red_mthr.actions_ok (ls, (ts, m), ws, is) t ta' \\<or>\n      red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta' \\<and>\n      red_mthr.actions_subset ta' ta)\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 98 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<exists>e'' s'' ta'.\n     extTA2J\n      P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                         \\<langle>e'',s''\\<rangle> \\<and>\n     (red_mthr.actions_ok (ls, (ts, m), ws, is) t ta' \\<or>\n      red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta' \\<and>\n      red_mthr.actions_subset ta' ta)\n\ngoal (1 subgoal):\n 1. \\<exists>e'' s'' ta'.\n       extTA2J\n        P,P,t \\<turnstile> \\<langle>insync(a) e,s\\<rangle> -ta'\\<rightarrow>\n                           \\<langle>e'',s''\\<rangle> \\<and>\n       (red_mthr.actions_ok (ls, (ts, m), ws, is) t ta' \\<or>\n        red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta' \\<and>\n        red_mthr.actions_subset ta' ta)", "by(fastforce intro: red_reds.SynchronizedRed2)"], ["proof (state)\nthis:\n  \\<exists>e'' s'' ta'.\n     extTA2J\n      P,P,t \\<turnstile> \\<langle>insync(a) e,s\\<rangle> -ta'\\<rightarrow>\n                         \\<langle>e'',s''\\<rangle> \\<and>\n     (red_mthr.actions_ok (ls, (ts, m), ws, is) t ta' \\<or>\n      red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta' \\<and>\n      red_mthr.actions_subset ta' ta)\n\ngoal (97 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 97 subgoals...", "next"], ["proof (state)\ngoal (97 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 97 subgoals...", "case RedCall"], ["proof (state)\nthis:\n  typeof_addr (hp s_) a_ = \\<lfloor>hU_\\<rfloor>\n  P \\<turnstile> class_type_of\n                  hU_ sees M_: Ts_\\<rightarrow>T_ = \\<lfloor>(pns_,\n                        body_)\\<rfloor> in D_\n  length vs_ = length pns_\n  length Ts_ = length pns_\n  \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t \\<lbrace>\\<rbrace>\n  sync_ok (addr a_\\<bullet>M_(map Val vs_))\n  hconf (hp s_)\n  P,hp s_ \\<turnstile> t \\<surd>t\n  \\<forall>l.\n     expr_locks (addr a_\\<bullet>M_(map Val vs_)) l\n     \\<le> has_locks (ls $ l) t\n  ws t = None \\<or>\n  (\\<exists>aa vsa w T Ts Tr D.\n      call (addr a_\\<bullet>M_(map Val vs_)) =\n      \\<lfloor>(aa, wait, vsa)\\<rfloor> \\<and>\n      typeof_addr (hp s_) aa = \\<lfloor>T\\<rfloor> \\<and>\n      P \\<turnstile> class_type_of\n                      T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n      ws t = \\<lfloor>PostWS w\\<rfloor>)\n\ngoal (97 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 97 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  typeof_addr (hp s_) a_ = \\<lfloor>hU_\\<rfloor>\n  P \\<turnstile> class_type_of\n                  hU_ sees M_: Ts_\\<rightarrow>T_ = \\<lfloor>(pns_,\n                        body_)\\<rfloor> in D_\n  length vs_ = length pns_\n  length Ts_ = length pns_\n  \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t \\<lbrace>\\<rbrace>\n  sync_ok (addr a_\\<bullet>M_(map Val vs_))\n  hconf (hp s_)\n  P,hp s_ \\<turnstile> t \\<surd>t\n  \\<forall>l.\n     expr_locks (addr a_\\<bullet>M_(map Val vs_)) l\n     \\<le> has_locks (ls $ l) t\n  ws t = None \\<or>\n  (\\<exists>aa vsa w T Ts Tr D.\n      call (addr a_\\<bullet>M_(map Val vs_)) =\n      \\<lfloor>(aa, wait, vsa)\\<rfloor> \\<and>\n      typeof_addr (hp s_) aa = \\<lfloor>T\\<rfloor> \\<and>\n      P \\<turnstile> class_type_of\n                      T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n      ws t = \\<lfloor>PostWS w\\<rfloor>)\n\ngoal (1 subgoal):\n 1. \\<exists>e'' s'' ta'.\n       extTA2J\n        P,P,t \\<turnstile> \\<langle>addr a_\\<bullet>M_(map Val vs_),\n                            s_\\<rangle> -ta'\\<rightarrow>\n                           \\<langle>e'',s''\\<rangle> \\<and>\n       (red_mthr.actions_ok (ls, (ts, m), ws, is) t ta' \\<or>\n        red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta' \\<and>\n        red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)", "by(auto simp add: is_val_iff contains_insync_conv contains_insyncs_conv red_mthr.actions_ok'_empty red_mthr.actions_ok'_ta_upd_obs dest: sees_method_fun)"], ["proof (state)\nthis:\n  \\<exists>e'' s'' ta'.\n     extTA2J\n      P,P,t \\<turnstile> \\<langle>addr a_\\<bullet>M_(map Val vs_),\n                          s_\\<rangle> -ta'\\<rightarrow>\n                         \\<langle>e'',s''\\<rangle> \\<and>\n     (red_mthr.actions_ok (ls, (ts, m), ws, is) t ta' \\<or>\n      red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta' \\<and>\n      red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n\ngoal (96 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 96 subgoals...", "next"], ["proof (state)\ngoal (96 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 96 subgoals...", "case (RedCallExternal s a U M Ts T D vs ta va h' ta' e' s')"], ["proof (state)\nthis:\n  typeof_addr (hp s) a = \\<lfloor>U\\<rfloor>\n  P \\<turnstile> class_type_of U sees M: Ts\\<rightarrow>T = Native in D\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   hp s\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n  ta' = extTA2J P ta\n  e' = extRet2J (addr a\\<bullet>M(map Val vs)) va\n  s' = (h', lcl s)\n  \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta'\n  sync_ok (addr a\\<bullet>M(map Val vs))\n  hconf (hp s)\n  P,hp s \\<turnstile> t \\<surd>t\n  \\<forall>l.\n     expr_locks (addr a\\<bullet>M(map Val vs)) l \\<le> has_locks (ls $ l) t\n  ws t = None \\<or>\n  (\\<exists>aa vsa w T Ts Tr D.\n      call (addr a\\<bullet>M(map Val vs)) =\n      \\<lfloor>(aa, wait, vsa)\\<rfloor> \\<and>\n      typeof_addr (hp s) aa = \\<lfloor>T\\<rfloor> \\<and>\n      P \\<turnstile> class_type_of\n                      T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n      ws t = \\<lfloor>PostWS w\\<rfloor>)\n\ngoal (96 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 96 subgoals...", "from \\<open>?wakeup (addr a\\<bullet>M(map Val vs)) s\\<close>"], ["proof (chain)\npicking this:\n  ws t = None \\<or>\n  (\\<exists>aa vsa w T Ts Tr D.\n      call (addr a\\<bullet>M(map Val vs)) =\n      \\<lfloor>(aa, wait, vsa)\\<rfloor> \\<and>\n      typeof_addr (hp s) aa = \\<lfloor>T\\<rfloor> \\<and>\n      P \\<turnstile> class_type_of\n                      T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n      ws t = \\<lfloor>PostWS w\\<rfloor>)", "have \"wset (ls, (ts, m), ws, is) t = None \\<or> (M = wait \\<and> (\\<exists>w. wset (ls, (ts, m), ws, is) t = \\<lfloor>PostWS w\\<rfloor>))\""], ["proof (prove)\nusing this:\n  ws t = None \\<or>\n  (\\<exists>aa vsa w T Ts Tr D.\n      call (addr a\\<bullet>M(map Val vs)) =\n      \\<lfloor>(aa, wait, vsa)\\<rfloor> \\<and>\n      typeof_addr (hp s) aa = \\<lfloor>T\\<rfloor> \\<and>\n      P \\<turnstile> class_type_of\n                      T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n      ws t = \\<lfloor>PostWS w\\<rfloor>)\n\ngoal (1 subgoal):\n 1. wset (ls, (ts, m), ws, is) t = None \\<or>\n    M = wait \\<and>\n    (\\<exists>w. wset (ls, (ts, m), ws, is) t = \\<lfloor>PostWS w\\<rfloor>)", "by auto"], ["proof (state)\nthis:\n  wset (ls, (ts, m), ws, is) t = None \\<or>\n  M = wait \\<and>\n  (\\<exists>w. wset (ls, (ts, m), ws, is) t = \\<lfloor>PostWS w\\<rfloor>)\n\ngoal (96 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 96 subgoals...", "with wf  \\<open>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),hp s\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>\\<close> \\<open>P,hp s \\<turnstile> t \\<surd>t\\<close> \\<open>hconf (hp s)\\<close>"], ["proof (chain)\npicking this:\n  wf_prog wf_md P\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   hp s\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n  P,hp s \\<turnstile> t \\<surd>t\n  hconf (hp s)\n  wset (ls, (ts, m), ws, is) t = None \\<or>\n  M = wait \\<and>\n  (\\<exists>w. wset (ls, (ts, m), ws, is) t = \\<lfloor>PostWS w\\<rfloor>)", "obtain ta'' va' h'' where red': \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),hp s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va',h''\\<rangle>\"\n    and aok: \"red_mthr.actions_ok (ls, (ts, m), ws, is) t ta'' \\<or>\n              red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta'' \\<and> final_thread.actions_subset ta'' ta\""], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   hp s\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n  P,hp s \\<turnstile> t \\<surd>t\n  hconf (hp s)\n  wset (ls, (ts, m), ws, is) t = None \\<or>\n  M = wait \\<and>\n  (\\<exists>w. wset (ls, (ts, m), ws, is) t = \\<lfloor>PostWS w\\<rfloor>)\n\ngoal (1 subgoal):\n 1. (\\<And>ta'' va' h''.\n        \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                                  hp s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va',\n                                h''\\<rangle>;\n         red_mthr.actions_ok (ls, (ts, m), ws, is) t ta'' \\<or>\n         red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta'' \\<and>\n         final_thread.actions_subset ta'' ta\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule red_external_wf_red)"], ["proof (state)\nthis:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   hp s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va',\n                 h''\\<rangle>\n  red_mthr.actions_ok (ls, (ts, m), ws, is) t ta'' \\<or>\n  red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta'' \\<and>\n  final_thread.actions_subset ta'' ta\n\ngoal (96 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 96 subgoals...", "from aok \\<open>ta' = extTA2J P ta\\<close>"], ["proof (chain)\npicking this:\n  red_mthr.actions_ok (ls, (ts, m), ws, is) t ta'' \\<or>\n  red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta'' \\<and>\n  final_thread.actions_subset ta'' ta\n  ta' = extTA2J P ta", "have \"red_mthr.actions_ok (ls, (ts, m), ws, is) t (extTA2J P ta'') \\<or>\n        red_mthr.actions_ok' (ls, (ts, m), ws, is) t (extTA2J P ta'') \\<and> red_mthr.actions_subset (extTA2J P ta'') ta'\""], ["proof (prove)\nusing this:\n  red_mthr.actions_ok (ls, (ts, m), ws, is) t ta'' \\<or>\n  red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta'' \\<and>\n  final_thread.actions_subset ta'' ta\n  ta' = extTA2J P ta\n\ngoal (1 subgoal):\n 1. red_mthr.actions_ok (ls, (ts, m), ws, is) t (extTA2J P ta'') \\<or>\n    red_mthr.actions_ok' (ls, (ts, m), ws, is) t (extTA2J P ta'') \\<and>\n    red_mthr.actions_subset (extTA2J P ta'') ta'", "by(auto simp add: red_mthr.actions_ok'_convert_extTA red_mthr.actions_ok_iff elim: final_thread.actions_subset.cases del: subsetI)"], ["proof (state)\nthis:\n  red_mthr.actions_ok (ls, (ts, m), ws, is) t (extTA2J P ta'') \\<or>\n  red_mthr.actions_ok' (ls, (ts, m), ws, is) t (extTA2J P ta'') \\<and>\n  red_mthr.actions_subset (extTA2J P ta'') ta'\n\ngoal (96 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 96 subgoals...", "moreover"], ["proof (state)\nthis:\n  red_mthr.actions_ok (ls, (ts, m), ws, is) t (extTA2J P ta'') \\<or>\n  red_mthr.actions_ok' (ls, (ts, m), ws, is) t (extTA2J P ta'') \\<and>\n  red_mthr.actions_subset (extTA2J P ta'') ta'\n\ngoal (96 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 96 subgoals...", "from red' \\<open>typeof_addr (hp s) a = \\<lfloor>U\\<rfloor>\\<close> \\<open>P \\<turnstile> class_type_of U sees M: Ts\\<rightarrow>T = Native in D\\<close>"], ["proof (chain)\npicking this:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   hp s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va',\n                 h''\\<rangle>\n  typeof_addr (hp s) a = \\<lfloor>U\\<rfloor>\n  P \\<turnstile> class_type_of U sees M: Ts\\<rightarrow>T = Native in D", "obtain s'' e'' where \"P,t \\<turnstile> \\<langle>addr a\\<bullet>M(map Val vs),s\\<rangle> -extTA2J P ta''\\<rightarrow> \\<langle>e'',s''\\<rangle>\""], ["proof (prove)\nusing this:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   hp s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va',\n                 h''\\<rangle>\n  typeof_addr (hp s) a = \\<lfloor>U\\<rfloor>\n  P \\<turnstile> class_type_of U sees M: Ts\\<rightarrow>T = Native in D\n\ngoal (1 subgoal):\n 1. (\\<And>e'' s''.\n        extTA2J\n         P,P,t \\<turnstile> \\<langle>addr a\\<bullet>M(map Val vs),\n                             s\\<rangle> -extTA2J P ta''\\<rightarrow>\n                            \\<langle>e'',s''\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce intro: red_reds.RedCallExternal)"], ["proof (state)\nthis:\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>addr a\\<bullet>M(map Val vs),\n                       s\\<rangle> -extTA2J P ta''\\<rightarrow>\n                      \\<langle>e'',s''\\<rangle>\n\ngoal (96 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 96 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  red_mthr.actions_ok (ls, (ts, m), ws, is) t (extTA2J P ta'') \\<or>\n  red_mthr.actions_ok' (ls, (ts, m), ws, is) t (extTA2J P ta'') \\<and>\n  red_mthr.actions_subset (extTA2J P ta'') ta'\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>addr a\\<bullet>M(map Val vs),\n                       s\\<rangle> -extTA2J P ta''\\<rightarrow>\n                      \\<langle>e'',s''\\<rangle>", "show ?case"], ["proof (prove)\nusing this:\n  red_mthr.actions_ok (ls, (ts, m), ws, is) t (extTA2J P ta'') \\<or>\n  red_mthr.actions_ok' (ls, (ts, m), ws, is) t (extTA2J P ta'') \\<and>\n  red_mthr.actions_subset (extTA2J P ta'') ta'\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>addr a\\<bullet>M(map Val vs),\n                       s\\<rangle> -extTA2J P ta''\\<rightarrow>\n                      \\<langle>e'',s''\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>e'' s'' ta'a.\n       extTA2J\n        P,P,t \\<turnstile> \\<langle>addr a\\<bullet>M(map Val vs),\n                            s\\<rangle> -ta'a\\<rightarrow>\n                           \\<langle>e'',s''\\<rangle> \\<and>\n       (red_mthr.actions_ok (ls, (ts, m), ws, is) t ta'a \\<or>\n        red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta'a \\<and>\n        red_mthr.actions_subset ta'a ta')", "by blast"], ["proof (state)\nthis:\n  \\<exists>e'' s'' ta'a.\n     extTA2J\n      P,P,t \\<turnstile> \\<langle>addr a\\<bullet>M(map Val vs),\n                          s\\<rangle> -ta'a\\<rightarrow>\n                         \\<langle>e'',s''\\<rangle> \\<and>\n     (red_mthr.actions_ok (ls, (ts, m), ws, is) t ta'a \\<or>\n      red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta'a \\<and>\n      red_mthr.actions_subset ta'a ta')\n\ngoal (95 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 95 subgoals...", "next"], ["proof (state)\ngoal (95 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 95 subgoals...", "case LockSynchronized"], ["proof (state)\nthis:\n  \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t \\<lbrace>(Lock, a_),\n          SyncLock a_\\<rbrace>\n  sync_ok (sync(addr a_) e_)\n  hconf (hp s_)\n  P,hp s_ \\<turnstile> t \\<surd>t\n  \\<forall>l. expr_locks (sync(addr a_) e_) l \\<le> has_locks (ls $ l) t\n  ws t = None \\<or>\n  (\\<exists>aa vs w T Ts Tr D.\n      call (sync(addr a_) e_) = \\<lfloor>(aa, wait, vs)\\<rfloor> \\<and>\n      typeof_addr (hp s_) aa = \\<lfloor>T\\<rfloor> \\<and>\n      P \\<turnstile> class_type_of\n                      T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n      ws t = \\<lfloor>PostWS w\\<rfloor>)\n\ngoal (95 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 95 subgoals...", "hence False"], ["proof (prove)\nusing this:\n  \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t \\<lbrace>(Lock, a_),\n          SyncLock a_\\<rbrace>\n  sync_ok (sync(addr a_) e_)\n  hconf (hp s_)\n  P,hp s_ \\<turnstile> t \\<surd>t\n  \\<forall>l. expr_locks (sync(addr a_) e_) l \\<le> has_locks (ls $ l) t\n  ws t = None \\<or>\n  (\\<exists>aa vs w T Ts Tr D.\n      call (sync(addr a_) e_) = \\<lfloor>(aa, wait, vs)\\<rfloor> \\<and>\n      typeof_addr (hp s_) aa = \\<lfloor>T\\<rfloor> \\<and>\n      P \\<turnstile> class_type_of\n                      T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n      ws t = \\<lfloor>PostWS w\\<rfloor>)\n\ngoal (1 subgoal):\n 1. False", "by(auto simp add: lock_ok_las'_def finfun_upd_apply ta_upd_simps)"], ["proof (state)\nthis:\n  False\n\ngoal (95 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 95 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>e'' s'' ta'.\n       extTA2J\n        P,P,t \\<turnstile> \\<langle>sync(addr a_) e_,\n                            s_\\<rangle> -ta'\\<rightarrow>\n                           \\<langle>e'',s''\\<rangle> \\<and>\n       (red_mthr.actions_ok (ls, (ts, m), ws, is) t ta' \\<or>\n        red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta' \\<and>\n        red_mthr.actions_subset ta' \\<lbrace>(Lock, a_),\n         SyncLock a_\\<rbrace>)", ".."], ["proof (state)\nthis:\n  \\<exists>e'' s'' ta'.\n     extTA2J\n      P,P,t \\<turnstile> \\<langle>sync(addr a_) e_,\n                          s_\\<rangle> -ta'\\<rightarrow>\n                         \\<langle>e'',s''\\<rangle> \\<and>\n     (red_mthr.actions_ok (ls, (ts, m), ws, is) t ta' \\<or>\n      red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta' \\<and>\n      red_mthr.actions_subset ta' \\<lbrace>(Lock, a_), SyncLock a_\\<rbrace>)\n\ngoal (94 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 94 subgoals...", "next"], ["proof (state)\ngoal (94 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 94 subgoals...", "case (UnlockSynchronized a v s)"], ["proof (state)\nthis:\n  \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t \\<lbrace>(Unlock, a),\n          SyncUnlock a\\<rbrace>\n  sync_ok (insync(a) Val v)\n  hconf (hp s)\n  P,hp s \\<turnstile> t \\<surd>t\n  \\<forall>l. expr_locks (insync(a) Val v) l \\<le> has_locks (ls $ l) t\n  ws t = None \\<or>\n  (\\<exists>aa vs w T Ts Tr D.\n      call (insync(a) Val v) = \\<lfloor>(aa, wait, vs)\\<rfloor> \\<and>\n      typeof_addr (hp s) aa = \\<lfloor>T\\<rfloor> \\<and>\n      P \\<turnstile> class_type_of\n                      T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n      ws t = \\<lfloor>PostWS w\\<rfloor>)\n\ngoal (94 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 94 subgoals...", "from \\<open>\\<forall>l. expr_locks (insync(a) Val v) l \\<le> has_locks (ls $ l) t\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>l. expr_locks (insync(a) Val v) l \\<le> has_locks (ls $ l) t", "have \"has_lock (ls $ a) t\""], ["proof (prove)\nusing this:\n  \\<forall>l. expr_locks (insync(a) Val v) l \\<le> has_locks (ls $ l) t\n\ngoal (1 subgoal):\n 1. has_lock (ls $ a) t", "by(force split: if_split_asm)"], ["proof (state)\nthis:\n  has_lock (ls $ a) t\n\ngoal (94 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 94 subgoals...", "with UnlockSynchronized"], ["proof (chain)\npicking this:\n  \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t \\<lbrace>(Unlock, a),\n          SyncUnlock a\\<rbrace>\n  sync_ok (insync(a) Val v)\n  hconf (hp s)\n  P,hp s \\<turnstile> t \\<surd>t\n  \\<forall>l. expr_locks (insync(a) Val v) l \\<le> has_locks (ls $ l) t\n  ws t = None \\<or>\n  (\\<exists>aa vs w T Ts Tr D.\n      call (insync(a) Val v) = \\<lfloor>(aa, wait, vs)\\<rfloor> \\<and>\n      typeof_addr (hp s) aa = \\<lfloor>T\\<rfloor> \\<and>\n      P \\<turnstile> class_type_of\n                      T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n      ws t = \\<lfloor>PostWS w\\<rfloor>)\n  has_lock (ls $ a) t", "have False"], ["proof (prove)\nusing this:\n  \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t \\<lbrace>(Unlock, a),\n          SyncUnlock a\\<rbrace>\n  sync_ok (insync(a) Val v)\n  hconf (hp s)\n  P,hp s \\<turnstile> t \\<surd>t\n  \\<forall>l. expr_locks (insync(a) Val v) l \\<le> has_locks (ls $ l) t\n  ws t = None \\<or>\n  (\\<exists>aa vs w T Ts Tr D.\n      call (insync(a) Val v) = \\<lfloor>(aa, wait, vs)\\<rfloor> \\<and>\n      typeof_addr (hp s) aa = \\<lfloor>T\\<rfloor> \\<and>\n      P \\<turnstile> class_type_of\n                      T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n      ws t = \\<lfloor>PostWS w\\<rfloor>)\n  has_lock (ls $ a) t\n\ngoal (1 subgoal):\n 1. False", "by(auto simp add: lock_ok_las'_def finfun_upd_apply ta_upd_simps)"], ["proof (state)\nthis:\n  False\n\ngoal (94 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 94 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>e'' s'' ta'.\n       extTA2J\n        P,P,t \\<turnstile> \\<langle>insync(a) Val v,\n                            s\\<rangle> -ta'\\<rightarrow>\n                           \\<langle>e'',s''\\<rangle> \\<and>\n       (red_mthr.actions_ok (ls, (ts, m), ws, is) t ta' \\<or>\n        red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta' \\<and>\n        red_mthr.actions_subset ta' \\<lbrace>(Unlock, a),\n         SyncUnlock a\\<rbrace>)", ".."], ["proof (state)\nthis:\n  \\<exists>e'' s'' ta'.\n     extTA2J\n      P,P,t \\<turnstile> \\<langle>insync(a) Val v,\n                          s\\<rangle> -ta'\\<rightarrow>\n                         \\<langle>e'',s''\\<rangle> \\<and>\n     (red_mthr.actions_ok (ls, (ts, m), ws, is) t ta' \\<or>\n      red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta' \\<and>\n      red_mthr.actions_subset ta' \\<lbrace>(Unlock, a),\n       SyncUnlock a\\<rbrace>)\n\ngoal (93 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 93 subgoals...", "next"], ["proof (state)\ngoal (93 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 93 subgoals...", "case (SynchronizedThrow2 a ad s)"], ["proof (state)\nthis:\n  \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t \\<lbrace>(Unlock, a),\n          SyncUnlock a\\<rbrace>\n  sync_ok (insync(a) Throw ad)\n  hconf (hp s)\n  P,hp s \\<turnstile> t \\<surd>t\n  \\<forall>l. expr_locks (insync(a) Throw ad) l \\<le> has_locks (ls $ l) t\n  ws t = None \\<or>\n  (\\<exists>aa vs w T Ts Tr D.\n      call (insync(a) Throw ad) = \\<lfloor>(aa, wait, vs)\\<rfloor> \\<and>\n      typeof_addr (hp s) aa = \\<lfloor>T\\<rfloor> \\<and>\n      P \\<turnstile> class_type_of\n                      T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n      ws t = \\<lfloor>PostWS w\\<rfloor>)\n\ngoal (93 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 93 subgoals...", "from \\<open>\\<forall>l. expr_locks (insync(a) Throw ad) l \\<le> has_locks (ls $ l) t\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>l. expr_locks (insync(a) Throw ad) l \\<le> has_locks (ls $ l) t", "have \"has_lock (ls $ a) t\""], ["proof (prove)\nusing this:\n  \\<forall>l. expr_locks (insync(a) Throw ad) l \\<le> has_locks (ls $ l) t\n\ngoal (1 subgoal):\n 1. has_lock (ls $ a) t", "by(force split: if_split_asm)"], ["proof (state)\nthis:\n  has_lock (ls $ a) t\n\ngoal (93 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 93 subgoals...", "with SynchronizedThrow2"], ["proof (chain)\npicking this:\n  \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t \\<lbrace>(Unlock, a),\n          SyncUnlock a\\<rbrace>\n  sync_ok (insync(a) Throw ad)\n  hconf (hp s)\n  P,hp s \\<turnstile> t \\<surd>t\n  \\<forall>l. expr_locks (insync(a) Throw ad) l \\<le> has_locks (ls $ l) t\n  ws t = None \\<or>\n  (\\<exists>aa vs w T Ts Tr D.\n      call (insync(a) Throw ad) = \\<lfloor>(aa, wait, vs)\\<rfloor> \\<and>\n      typeof_addr (hp s) aa = \\<lfloor>T\\<rfloor> \\<and>\n      P \\<turnstile> class_type_of\n                      T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n      ws t = \\<lfloor>PostWS w\\<rfloor>)\n  has_lock (ls $ a) t", "have False"], ["proof (prove)\nusing this:\n  \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t \\<lbrace>(Unlock, a),\n          SyncUnlock a\\<rbrace>\n  sync_ok (insync(a) Throw ad)\n  hconf (hp s)\n  P,hp s \\<turnstile> t \\<surd>t\n  \\<forall>l. expr_locks (insync(a) Throw ad) l \\<le> has_locks (ls $ l) t\n  ws t = None \\<or>\n  (\\<exists>aa vs w T Ts Tr D.\n      call (insync(a) Throw ad) = \\<lfloor>(aa, wait, vs)\\<rfloor> \\<and>\n      typeof_addr (hp s) aa = \\<lfloor>T\\<rfloor> \\<and>\n      P \\<turnstile> class_type_of\n                      T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n      ws t = \\<lfloor>PostWS w\\<rfloor>)\n  has_lock (ls $ a) t\n\ngoal (1 subgoal):\n 1. False", "by(auto simp add: lock_ok_las'_def finfun_upd_apply ta_upd_simps)"], ["proof (state)\nthis:\n  False\n\ngoal (93 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 93 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>e'' s'' ta'.\n       extTA2J\n        P,P,t \\<turnstile> \\<langle>insync(a) Throw ad,\n                            s\\<rangle> -ta'\\<rightarrow>\n                           \\<langle>e'',s''\\<rangle> \\<and>\n       (red_mthr.actions_ok (ls, (ts, m), ws, is) t ta' \\<or>\n        red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta' \\<and>\n        red_mthr.actions_subset ta' \\<lbrace>(Unlock, a),\n         SyncUnlock a\\<rbrace>)", ".."], ["proof (state)\nthis:\n  \\<exists>e'' s'' ta'.\n     extTA2J\n      P,P,t \\<turnstile> \\<langle>insync(a) Throw ad,\n                          s\\<rangle> -ta'\\<rightarrow>\n                         \\<langle>e'',s''\\<rangle> \\<and>\n     (red_mthr.actions_ok (ls, (ts, m), ws, is) t ta' \\<or>\n      red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta' \\<and>\n      red_mthr.actions_subset ta' \\<lbrace>(Unlock, a),\n       SyncUnlock a\\<rbrace>)\n\ngoal (92 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 92 subgoals...", "next"], ["proof (state)\ngoal (92 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 92 subgoals...", "case BlockRed"], ["proof (state)\nthis:\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e_,\n                       (h_, l_(V_ := vo_))\\<rangle> -ta_\\<rightarrow>\n                      \\<langle>e'_,(h'_, l'_)\\<rangle>\n  \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta_;\n   sync_ok e_; hconf (hp (h_, l_(V_ := vo_)));\n   P,hp (h_, l_(V_ := vo_)) \\<turnstile> t \\<surd>t;\n   \\<forall>l. expr_locks e_ l \\<le> has_locks (ls $ l) t;\n   ws t = None \\<or>\n   (\\<exists>a vs w T Ts Tr D.\n       call e_ = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n       typeof_addr (hp (h_, l_(V_ := vo_))) a = \\<lfloor>T\\<rfloor> \\<and>\n       P \\<turnstile> class_type_of\n                       T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n       ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                       extTA2J\n                        P,P,t \\<turnstile> \\<langle>e_,\n      (h_, l_(V_ := vo_))\\<rangle> -ta'\\<rightarrow>\n     \\<langle>e'',s''\\<rangle> \\<and>\n                       (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                         ta' \\<or>\n                        red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                         ta' \\<and>\n                        red_mthr.actions_subset ta' ta_)\n  \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta_\n  sync_ok {V_:T_=vo_; e_}\n  hconf (hp (h_, l_))\n  P,hp (h_, l_) \\<turnstile> t \\<surd>t\n  \\<forall>l. expr_locks {V_:T_=vo_; e_} l \\<le> has_locks (ls $ l) t\n  ws t = None \\<or>\n  (\\<exists>a vs w Ta Ts Tr D.\n      call {V_:T_=vo_; e_} = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n      typeof_addr (hp (h_, l_)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n      P \\<turnstile> class_type_of\n                      Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n      ws t = \\<lfloor>PostWS w\\<rfloor>)\n\ngoal (92 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 92 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e_,\n                       (h_, l_(V_ := vo_))\\<rangle> -ta_\\<rightarrow>\n                      \\<langle>e'_,(h'_, l'_)\\<rangle>\n  \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta_;\n   sync_ok e_; hconf (hp (h_, l_(V_ := vo_)));\n   P,hp (h_, l_(V_ := vo_)) \\<turnstile> t \\<surd>t;\n   \\<forall>l. expr_locks e_ l \\<le> has_locks (ls $ l) t;\n   ws t = None \\<or>\n   (\\<exists>a vs w T Ts Tr D.\n       call e_ = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n       typeof_addr (hp (h_, l_(V_ := vo_))) a = \\<lfloor>T\\<rfloor> \\<and>\n       P \\<turnstile> class_type_of\n                       T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n       ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                       extTA2J\n                        P,P,t \\<turnstile> \\<langle>e_,\n      (h_, l_(V_ := vo_))\\<rangle> -ta'\\<rightarrow>\n     \\<langle>e'',s''\\<rangle> \\<and>\n                       (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                         ta' \\<or>\n                        red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                         ta' \\<and>\n                        red_mthr.actions_subset ta' ta_)\n  \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta_\n  sync_ok {V_:T_=vo_; e_}\n  hconf (hp (h_, l_))\n  P,hp (h_, l_) \\<turnstile> t \\<surd>t\n  \\<forall>l. expr_locks {V_:T_=vo_; e_} l \\<le> has_locks (ls $ l) t\n  ws t = None \\<or>\n  (\\<exists>a vs w Ta Ts Tr D.\n      call {V_:T_=vo_; e_} = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n      typeof_addr (hp (h_, l_)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n      P \\<turnstile> class_type_of\n                      Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n      ws t = \\<lfloor>PostWS w\\<rfloor>)\n\ngoal (1 subgoal):\n 1. \\<exists>e'' s'' ta'.\n       extTA2J\n        P,P,t \\<turnstile> \\<langle>{V_:T_=vo_; e_},\n                            (h_, l_)\\<rangle> -ta'\\<rightarrow>\n                           \\<langle>e'',s''\\<rangle> \\<and>\n       (red_mthr.actions_ok (ls, (ts, m), ws, is) t ta' \\<or>\n        red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta' \\<and>\n        red_mthr.actions_subset ta' ta_)", "by(simp)(blast intro: red_reds.intros)"], ["proof (state)\nthis:\n  \\<exists>e'' s'' ta'.\n     extTA2J\n      P,P,t \\<turnstile> \\<langle>{V_:T_=vo_; e_},\n                          (h_, l_)\\<rangle> -ta'\\<rightarrow>\n                         \\<langle>e'',s''\\<rangle> \\<and>\n     (red_mthr.actions_ok (ls, (ts, m), ws, is) t ta' \\<or>\n      red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta' \\<and>\n      red_mthr.actions_subset ta' ta_)\n\ngoal (91 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Class_type C)\\<rbrace>)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (new C); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (new C) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (new C) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>new C,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (newA T\\<lfloor>e\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>e\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>e\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>e\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>NewHeapElem a\n                          (Array_type T (nat (sint i)))\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta'\n                              \\<lbrace>NewHeapElem a\n  (Array_type T (nat (sint i)))\\<rbrace>)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>); hconf (hp (h, l));\n        P,hp (h, l) \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (newA T\\<lfloor>Val (Intg i)\\<rceil>) l\n           \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n            \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp (h, l)) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>newA T\\<lfloor>Val\n                                   (Intg i)\\<rceil>,\n           (h, l)\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w T Ts Tr D.\n             call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta);\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n        sync_ok (Cast C e); hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l. expr_locks (Cast C e) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w T Ts Tr D.\n            call (Cast C e) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast C e,\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                \\<lbrace>\\<rbrace>;\n        sync_ok (Cast T (Val v)); hconf (hp s);\n        P,hp s \\<turnstile> t \\<surd>t;\n        \\<forall>l.\n           expr_locks (Cast T (Val v)) l \\<le> has_locks (ls $ l) t;\n        ws t = None \\<or>\n        (\\<exists>a vs w Ta Ts Tr D.\n            call (Cast T (Val v)) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n            typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n            P \\<turnstile> class_type_of\n                            Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n            ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                            extTA2J\n                             P,P,t \\<turnstile> \\<langle>Cast T (Val v),\n           s\\<rangle> -ta'\\<rightarrow>\n          \\<langle>e'',s''\\<rangle> \\<and>\n                            (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                              ta' \\<or>\n                             red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                              ta' \\<and>\n                             red_mthr.actions_subset ta' \\<lbrace>\\<rbrace>)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>\\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n          sync_ok e; hconf (hp s); P,hp s \\<turnstile> t \\<surd>t;\n          \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t;\n          ws t = None \\<or>\n          (\\<exists>a vs w T Ts Tr D.\n              call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n              typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n              P \\<turnstile> class_type_of\n                              T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n              ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                              extTA2J\n                               P,P,t \\<turnstile> \\<langle>e,\n             s\\<rangle> -ta'\\<rightarrow>\n            \\<langle>e'',s''\\<rangle> \\<and>\n                              (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                                ta' \\<or>\n                               red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                                ta' \\<and>\n                               red_mthr.actions_subset ta' ta);\n         \\<not> red_mthr.actions_ok' (ls, (ts, m), ws, is) t ta;\n         sync_ok (e instanceof T); hconf (hp s);\n         P,hp s \\<turnstile> t \\<surd>t;\n         \\<forall>l.\n            expr_locks (e instanceof T) l \\<le> has_locks (ls $ l) t;\n         ws t = None \\<or>\n         (\\<exists>a vs w Ta Ts Tr D.\n             call (e instanceof T) = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n             typeof_addr (hp s) a = \\<lfloor>Ta\\<rfloor> \\<and>\n             P \\<turnstile> class_type_of\n                             Ta sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n             ws t = \\<lfloor>PostWS w\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                             extTA2J\n                              P,P,t \\<turnstile> \\<langle>e instanceof T,\n            s\\<rangle> -ta'\\<rightarrow>\n           \\<langle>e'',s''\\<rangle> \\<and>\n                             (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                               ta' \\<or>\n                              red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                               ta' \\<and>\n                              red_mthr.actions_subset ta' ta)\nA total of 91 subgoals...", "qed\n (simp_all add: is_val_iff contains_insync_conv contains_insyncs_conv red_mthr.actions_ok'_empty\n   red_mthr.actions_ok'_ta_upd_obs thread_action'_to_thread_action.simps red_mthr.actions_ok_iff\n  split: if_split_asm del: split_paired_Ex,\n  (blast intro: red_reds.intros elim: add_leE)+)"], ["", "end"], ["", "end"], ["", "context J_heap_base begin"], ["", "lemma shows red_ta_satisfiable:\n  \"P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle> \\<Longrightarrow> \\<exists>s. red_mthr.actions_ok s t ta\"\n  and reds_ta_satisfiable:\n  \"P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle> \\<Longrightarrow> \\<exists>s. red_mthr.actions_ok s t ta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (extTA2J\n      P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                         \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n     \\<exists>s. red_mthr.actions_ok s t ta) &&&\n    (extTA2J\n      P,P,t \\<turnstile> \\<langle>es,s\\<rangle> [-ta\\<rightarrow>]\n                         \\<langle>es',s'\\<rangle> \\<Longrightarrow>\n     \\<exists>s. red_mthr.actions_ok s t ta)", "apply(induct rule: red_reds.inducts)"], ["proof (prove)\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       \\<exists>s.\n          red_mthr.actions_ok s t\n           \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       \\<exists>s. red_mthr.actions_ok s t \\<lbrace>\\<rbrace>\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<exists>s. red_mthr.actions_ok s t ta\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s. red_mthr.actions_ok s t ta\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            red_mthr.actions_ok s t\n                             \\<lbrace>NewHeapElem a\n (Array_type T (nat (sint i)))\\<rbrace>\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       \\<exists>s. red_mthr.actions_ok s t \\<lbrace>\\<rbrace>\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            red_mthr.actions_ok s t \\<lbrace>\\<rbrace>\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA2J\n                 P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle>;\n        \\<exists>s. red_mthr.actions_ok s t ta\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s. red_mthr.actions_ok s t ta\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            red_mthr.actions_ok s t \\<lbrace>\\<rbrace>\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            red_mthr.actions_ok s t \\<lbrace>\\<rbrace>\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n         \\<exists>s. red_mthr.actions_ok s t ta\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s. red_mthr.actions_ok s t ta\nA total of 98 subgoals...", "apply(fastforce simp add: lock_ok_las_def finfun_upd_apply intro: exI[where x=\"K$ None\"] exI[where x=\"K$ \\<lfloor>(t, 0)\\<rfloor>\"] may_lock.intros dest: red_external_ta_satisfiable[where final=\"final_expr :: ('addr expr \\<times> 'addr locals) \\<Rightarrow> bool\"])+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "context J_typesafe begin"], ["", "lemma wf_progress: \n  assumes wf: \"wf_J_prog P\"\n  shows \"progress final_expr (mred P)\n            (red_mthr.wset_Suspend_ok P ({s. sync_es_ok (thr s) (shr s) \\<and> lock_ok (locks s) (thr s)} \\<inter> {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter> {s. def_ass_ts_ok (thr s) (shr s)}))\"\n  (is \"progress _ _ ?wf_state\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. progress final_expr\n     (\\<lambda>t ((e, l), h) ta ((e', l'), h').\n         extTA2J\n          P,P,t \\<turnstile> \\<langle>e,(h, l)\\<rangle> -ta\\<rightarrow>\n                             \\<langle>e',(h', l')\\<rangle>)\n     (red_mthr.wset_Suspend_ok P\n       ({s. sync_es_ok (thr s) (shr s) \\<and>\n            lock_ok (locks s) (thr s)} \\<inter>\n        {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n        {s. def_ass_ts_ok (thr s) (shr s)}))", "proof"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>s.\n       s \\<in> red_mthr.wset_Suspend_ok P\n                ({s. sync_es_ok (thr s) (shr s) \\<and>\n                     lock_ok (locks s) (thr s)} \\<inter>\n                 {s. \\<exists>Es.\n                        sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n                 {s. def_ass_ts_ok (thr s) (shr s)}) \\<Longrightarrow>\n       lock_thread_ok (locks s) (thr s) \\<and>\n       red_mthr.wset_final_ok (wset s) (thr s)\n 2. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 3. \\<And>s t x ta x' m' w.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'; \\<not> waiting (wset s t);\n        Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<not> final_expr x'\n 4. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 5. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 6. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "{"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>s.\n       s \\<in> red_mthr.wset_Suspend_ok P\n                ({s. sync_es_ok (thr s) (shr s) \\<and>\n                     lock_ok (locks s) (thr s)} \\<inter>\n                 {s. \\<exists>Es.\n                        sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n                 {s. def_ass_ts_ok (thr s) (shr s)}) \\<Longrightarrow>\n       lock_thread_ok (locks s) (thr s) \\<and>\n       red_mthr.wset_final_ok (wset s) (thr s)\n 2. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 3. \\<And>s t x ta x' m' w.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'; \\<not> waiting (wset s t);\n        Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<not> final_expr x'\n 4. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 5. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 6. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "fix s t x ta x' m' w"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>s.\n       s \\<in> red_mthr.wset_Suspend_ok P\n                ({s. sync_es_ok (thr s) (shr s) \\<and>\n                     lock_ok (locks s) (thr s)} \\<inter>\n                 {s. \\<exists>Es.\n                        sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n                 {s. def_ass_ts_ok (thr s) (shr s)}) \\<Longrightarrow>\n       lock_thread_ok (locks s) (thr s) \\<and>\n       red_mthr.wset_final_ok (wset s) (thr s)\n 2. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 3. \\<And>s t x ta x' m' w.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'; \\<not> waiting (wset s t);\n        Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<not> final_expr x'\n 4. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 5. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 6. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "assume \"mred P t (x, shr s) ta (x', m')\"\n      and Suspend: \"Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\""], ["proof (state)\nthis:\n  red_mthr.r_syntax P t x (shr s) ta x' m'\n  Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\n\ngoal (6 subgoals):\n 1. \\<And>s.\n       s \\<in> red_mthr.wset_Suspend_ok P\n                ({s. sync_es_ok (thr s) (shr s) \\<and>\n                     lock_ok (locks s) (thr s)} \\<inter>\n                 {s. \\<exists>Es.\n                        sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n                 {s. def_ass_ts_ok (thr s) (shr s)}) \\<Longrightarrow>\n       lock_thread_ok (locks s) (thr s) \\<and>\n       red_mthr.wset_final_ok (wset s) (thr s)\n 2. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 3. \\<And>s t x ta x' m' w.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'; \\<not> waiting (wset s t);\n        Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<not> final_expr x'\n 4. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 5. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 6. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "moreover"], ["proof (state)\nthis:\n  red_mthr.r_syntax P t x (shr s) ta x' m'\n  Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\n\ngoal (6 subgoals):\n 1. \\<And>s.\n       s \\<in> red_mthr.wset_Suspend_ok P\n                ({s. sync_es_ok (thr s) (shr s) \\<and>\n                     lock_ok (locks s) (thr s)} \\<inter>\n                 {s. \\<exists>Es.\n                        sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n                 {s. def_ass_ts_ok (thr s) (shr s)}) \\<Longrightarrow>\n       lock_thread_ok (locks s) (thr s) \\<and>\n       red_mthr.wset_final_ok (wset s) (thr s)\n 2. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 3. \\<And>s t x ta x' m' w.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'; \\<not> waiting (wset s t);\n        Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<not> final_expr x'\n 4. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 5. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 6. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "obtain e xs where x: \"x = (e, xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e xs. x = (e, xs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases x)"], ["proof (state)\nthis:\n  x = (e, xs)\n\ngoal (6 subgoals):\n 1. \\<And>s.\n       s \\<in> red_mthr.wset_Suspend_ok P\n                ({s. sync_es_ok (thr s) (shr s) \\<and>\n                     lock_ok (locks s) (thr s)} \\<inter>\n                 {s. \\<exists>Es.\n                        sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n                 {s. def_ass_ts_ok (thr s) (shr s)}) \\<Longrightarrow>\n       lock_thread_ok (locks s) (thr s) \\<and>\n       red_mthr.wset_final_ok (wset s) (thr s)\n 2. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 3. \\<And>s t x ta x' m' w.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'; \\<not> waiting (wset s t);\n        Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<not> final_expr x'\n 4. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 5. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 6. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "moreover"], ["proof (state)\nthis:\n  x = (e, xs)\n\ngoal (6 subgoals):\n 1. \\<And>s.\n       s \\<in> red_mthr.wset_Suspend_ok P\n                ({s. sync_es_ok (thr s) (shr s) \\<and>\n                     lock_ok (locks s) (thr s)} \\<inter>\n                 {s. \\<exists>Es.\n                        sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n                 {s. def_ass_ts_ok (thr s) (shr s)}) \\<Longrightarrow>\n       lock_thread_ok (locks s) (thr s) \\<and>\n       red_mthr.wset_final_ok (wset s) (thr s)\n 2. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 3. \\<And>s t x ta x' m' w.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'; \\<not> waiting (wset s t);\n        Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<not> final_expr x'\n 4. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 5. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 6. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "obtain e' xs' where x': \"x' = (e', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e' xs'.\n        x' = (e', xs') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases x')"], ["proof (state)\nthis:\n  x' = (e', xs')\n\ngoal (6 subgoals):\n 1. \\<And>s.\n       s \\<in> red_mthr.wset_Suspend_ok P\n                ({s. sync_es_ok (thr s) (shr s) \\<and>\n                     lock_ok (locks s) (thr s)} \\<inter>\n                 {s. \\<exists>Es.\n                        sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n                 {s. def_ass_ts_ok (thr s) (shr s)}) \\<Longrightarrow>\n       lock_thread_ok (locks s) (thr s) \\<and>\n       red_mthr.wset_final_ok (wset s) (thr s)\n 2. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 3. \\<And>s t x ta x' m' w.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'; \\<not> waiting (wset s t);\n        Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<not> final_expr x'\n 4. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 5. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 6. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "ultimately"], ["proof (chain)\npicking this:\n  red_mthr.r_syntax P t x (shr s) ta x' m'\n  Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\n  x = (e, xs)\n  x' = (e', xs')", "have red: \"P,t \\<turnstile> \\<langle>e, (shr s, xs)\\<rangle> -ta\\<rightarrow> \\<langle>e', (m', xs')\\<rangle>\""], ["proof (prove)\nusing this:\n  red_mthr.r_syntax P t x (shr s) ta x' m'\n  Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\n  x = (e, xs)\n  x' = (e', xs')\n\ngoal (1 subgoal):\n 1. extTA2J\n     P,P,t \\<turnstile> \\<langle>e,(shr s, xs)\\<rangle> -ta\\<rightarrow>\n                        \\<langle>e',(m', xs')\\<rangle>", "by simp"], ["proof (state)\nthis:\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e,(shr s, xs)\\<rangle> -ta\\<rightarrow>\n                      \\<langle>e',(m', xs')\\<rangle>\n\ngoal (6 subgoals):\n 1. \\<And>s.\n       s \\<in> red_mthr.wset_Suspend_ok P\n                ({s. sync_es_ok (thr s) (shr s) \\<and>\n                     lock_ok (locks s) (thr s)} \\<inter>\n                 {s. \\<exists>Es.\n                        sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n                 {s. def_ass_ts_ok (thr s) (shr s)}) \\<Longrightarrow>\n       lock_thread_ok (locks s) (thr s) \\<and>\n       red_mthr.wset_final_ok (wset s) (thr s)\n 2. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 3. \\<And>s t x ta x' m' w.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'; \\<not> waiting (wset s t);\n        Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<not> final_expr x'\n 4. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 5. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 6. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "from red_Suspend_is_call[OF red Suspend]"], ["proof (chain)\npicking this:\n  \\<exists>a vs hT Ts Tr D.\n     call e' = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n     typeof_addr (hp (shr s, xs)) a = \\<lfloor>hT\\<rfloor> \\<and>\n     P \\<turnstile> class_type_of\n                     hT sees wait: Ts\\<rightarrow>Tr = Native in D", "show \"\\<not> final_expr x'\""], ["proof (prove)\nusing this:\n  \\<exists>a vs hT Ts Tr D.\n     call e' = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n     typeof_addr (hp (shr s, xs)) a = \\<lfloor>hT\\<rfloor> \\<and>\n     P \\<turnstile> class_type_of\n                     hT sees wait: Ts\\<rightarrow>Tr = Native in D\n\ngoal (1 subgoal):\n 1. \\<not> final_expr x'", "by(auto simp add: x')"], ["proof (state)\nthis:\n  \\<not> final_expr x'\n\ngoal (5 subgoals):\n 1. \\<And>s.\n       s \\<in> red_mthr.wset_Suspend_ok P\n                ({s. sync_es_ok (thr s) (shr s) \\<and>\n                     lock_ok (locks s) (thr s)} \\<inter>\n                 {s. \\<exists>Es.\n                        sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n                 {s. def_ass_ts_ok (thr s) (shr s)}) \\<Longrightarrow>\n       lock_thread_ok (locks s) (thr s) \\<and>\n       red_mthr.wset_final_ok (wset s) (thr s)\n 2. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 3. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 4. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 5. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "}"], ["proof (state)\nthis:\n  \\<lbrakk>red_mthr.r_syntax P ?t17 ?x17 (shr ?s17) ?ta17 ?x'17 ?m'17;\n   Suspend ?w17 \\<in> set \\<lbrace>?ta17\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> \\<not> final_expr ?x'17\n\ngoal (5 subgoals):\n 1. \\<And>s.\n       s \\<in> red_mthr.wset_Suspend_ok P\n                ({s. sync_es_ok (thr s) (shr s) \\<and>\n                     lock_ok (locks s) (thr s)} \\<inter>\n                 {s. \\<exists>Es.\n                        sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n                 {s. def_ass_ts_ok (thr s) (shr s)}) \\<Longrightarrow>\n       lock_thread_ok (locks s) (thr s) \\<and>\n       red_mthr.wset_final_ok (wset s) (thr s)\n 2. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 3. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 4. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 5. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "note Suspend_final = this"], ["proof (state)\nthis:\n  \\<lbrakk>red_mthr.r_syntax P ?t17 ?x17 (shr ?s17) ?ta17 ?x'17 ?m'17;\n   Suspend ?w17 \\<in> set \\<lbrace>?ta17\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> \\<not> final_expr ?x'17\n\ngoal (5 subgoals):\n 1. \\<And>s.\n       s \\<in> red_mthr.wset_Suspend_ok P\n                ({s. sync_es_ok (thr s) (shr s) \\<and>\n                     lock_ok (locks s) (thr s)} \\<inter>\n                 {s. \\<exists>Es.\n                        sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n                 {s. def_ass_ts_ok (thr s) (shr s)}) \\<Longrightarrow>\n       lock_thread_ok (locks s) (thr s) \\<and>\n       red_mthr.wset_final_ok (wset s) (thr s)\n 2. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 3. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 4. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 5. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "{"], ["proof (state)\nthis:\n  \\<lbrakk>red_mthr.r_syntax P ?t17 ?x17 (shr ?s17) ?ta17 ?x'17 ?m'17;\n   Suspend ?w17 \\<in> set \\<lbrace>?ta17\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> \\<not> final_expr ?x'17\n\ngoal (5 subgoals):\n 1. \\<And>s.\n       s \\<in> red_mthr.wset_Suspend_ok P\n                ({s. sync_es_ok (thr s) (shr s) \\<and>\n                     lock_ok (locks s) (thr s)} \\<inter>\n                 {s. \\<exists>Es.\n                        sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n                 {s. def_ass_ts_ok (thr s) (shr s)}) \\<Longrightarrow>\n       lock_thread_ok (locks s) (thr s) \\<and>\n       red_mthr.wset_final_ok (wset s) (thr s)\n 2. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 3. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 4. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 5. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "fix s"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>s.\n       s \\<in> red_mthr.wset_Suspend_ok P\n                ({s. sync_es_ok (thr s) (shr s) \\<and>\n                     lock_ok (locks s) (thr s)} \\<inter>\n                 {s. \\<exists>Es.\n                        sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n                 {s. def_ass_ts_ok (thr s) (shr s)}) \\<Longrightarrow>\n       lock_thread_ok (locks s) (thr s) \\<and>\n       red_mthr.wset_final_ok (wset s) (thr s)\n 2. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 3. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 4. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 5. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "assume s: \"s \\<in> ?wf_state\""], ["proof (state)\nthis:\n  s \\<in> red_mthr.wset_Suspend_ok P\n           ({s. sync_es_ok (thr s) (shr s) \\<and>\n                lock_ok (locks s) (thr s)} \\<inter>\n            {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n            {s. def_ass_ts_ok (thr s) (shr s)})\n\ngoal (5 subgoals):\n 1. \\<And>s.\n       s \\<in> red_mthr.wset_Suspend_ok P\n                ({s. sync_es_ok (thr s) (shr s) \\<and>\n                     lock_ok (locks s) (thr s)} \\<inter>\n                 {s. \\<exists>Es.\n                        sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n                 {s. def_ass_ts_ok (thr s) (shr s)}) \\<Longrightarrow>\n       lock_thread_ok (locks s) (thr s) \\<and>\n       red_mthr.wset_final_ok (wset s) (thr s)\n 2. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 3. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 4. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 5. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "hence \"lock_thread_ok (locks s) (thr s)\""], ["proof (prove)\nusing this:\n  s \\<in> red_mthr.wset_Suspend_ok P\n           ({s. sync_es_ok (thr s) (shr s) \\<and>\n                lock_ok (locks s) (thr s)} \\<inter>\n            {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n            {s. def_ass_ts_ok (thr s) (shr s)})\n\ngoal (1 subgoal):\n 1. lock_thread_ok (locks s) (thr s)", "by(auto dest: red_mthr.wset_Suspend_okD1 intro: lock_ok_lock_thread_ok)"], ["proof (state)\nthis:\n  lock_thread_ok (locks s) (thr s)\n\ngoal (5 subgoals):\n 1. \\<And>s.\n       s \\<in> red_mthr.wset_Suspend_ok P\n                ({s. sync_es_ok (thr s) (shr s) \\<and>\n                     lock_ok (locks s) (thr s)} \\<inter>\n                 {s. \\<exists>Es.\n                        sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n                 {s. def_ass_ts_ok (thr s) (shr s)}) \\<Longrightarrow>\n       lock_thread_ok (locks s) (thr s) \\<and>\n       red_mthr.wset_final_ok (wset s) (thr s)\n 2. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 3. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 4. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 5. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "moreover"], ["proof (state)\nthis:\n  lock_thread_ok (locks s) (thr s)\n\ngoal (5 subgoals):\n 1. \\<And>s.\n       s \\<in> red_mthr.wset_Suspend_ok P\n                ({s. sync_es_ok (thr s) (shr s) \\<and>\n                     lock_ok (locks s) (thr s)} \\<inter>\n                 {s. \\<exists>Es.\n                        sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n                 {s. def_ass_ts_ok (thr s) (shr s)}) \\<Longrightarrow>\n       lock_thread_ok (locks s) (thr s) \\<and>\n       red_mthr.wset_final_ok (wset s) (thr s)\n 2. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 3. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 4. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 5. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "have \"red_mthr.wset_final_ok (wset s) (thr s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. red_mthr.wset_final_ok (wset s) (thr s)", "proof(rule red_mthr.wset_final_okI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t w.\n       wset s t = \\<lfloor>w\\<rfloor> \\<Longrightarrow>\n       \\<exists>x ln.\n          thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and> \\<not> final_expr x", "fix t w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t w.\n       wset s t = \\<lfloor>w\\<rfloor> \\<Longrightarrow>\n       \\<exists>x ln.\n          thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and> \\<not> final_expr x", "assume \"wset s t = \\<lfloor>w\\<rfloor>\""], ["proof (state)\nthis:\n  wset s t = \\<lfloor>w\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>t w.\n       wset s t = \\<lfloor>w\\<rfloor> \\<Longrightarrow>\n       \\<exists>x ln.\n          thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and> \\<not> final_expr x", "from red_mthr.wset_Suspend_okD2[OF s this]"], ["proof (chain)\npicking this:\n  \\<exists>s0\\<in>{s. sync_es_ok (thr s) (shr s) \\<and>\n                      lock_ok (locks s) (thr s)} \\<inter>\n                  {s. \\<exists>Es.\n                         sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n                  {s. def_ass_ts_ok (thr s) (shr s)}.\n     \\<exists>s1\\<in>{s. sync_es_ok (thr s) (shr s) \\<and>\n                         lock_ok (locks s) (thr s)} \\<inter>\n                     {s. \\<exists>Es.\n                            sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n                     {s. def_ass_ts_ok (thr s) (shr s)}.\n        \\<exists>ttas x x0 ta w' ln' ln''.\n           P \\<turnstile> s0 -t\\<triangleright>ta\\<rightarrow> s1 \\<and>\n           P \\<turnstile> s1 -\\<triangleright>ttas\\<rightarrow>* s \\<and>\n           thr s0 t = \\<lfloor>(x0, no_wait_locks)\\<rfloor> \\<and>\n           red_mthr.r_syntax P t x0 (shr s0) ta x (shr s1) \\<and>\n           Suspend w' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n           red_mthr.actions_ok s0 t ta \\<and>\n           thr s1 t = \\<lfloor>(x, ln')\\<rfloor> \\<and>\n           thr s t = \\<lfloor>(x, ln'')\\<rfloor>", "obtain x0 ta x m1 w' ln'' and s0 :: \"('addr, 'thread_id, 'heap) J_state\"\n        where mred: \"mred P t (x0, shr s0) ta (x, m1)\"\n        and Suspend: \"Suspend w' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\" \n        and tst: \"thr s t = \\<lfloor>(x, ln'')\\<rfloor>\""], ["proof (prove)\nusing this:\n  \\<exists>s0\\<in>{s. sync_es_ok (thr s) (shr s) \\<and>\n                      lock_ok (locks s) (thr s)} \\<inter>\n                  {s. \\<exists>Es.\n                         sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n                  {s. def_ass_ts_ok (thr s) (shr s)}.\n     \\<exists>s1\\<in>{s. sync_es_ok (thr s) (shr s) \\<and>\n                         lock_ok (locks s) (thr s)} \\<inter>\n                     {s. \\<exists>Es.\n                            sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n                     {s. def_ass_ts_ok (thr s) (shr s)}.\n        \\<exists>ttas x x0 ta w' ln' ln''.\n           P \\<turnstile> s0 -t\\<triangleright>ta\\<rightarrow> s1 \\<and>\n           P \\<turnstile> s1 -\\<triangleright>ttas\\<rightarrow>* s \\<and>\n           thr s0 t = \\<lfloor>(x0, no_wait_locks)\\<rfloor> \\<and>\n           red_mthr.r_syntax P t x0 (shr s0) ta x (shr s1) \\<and>\n           Suspend w' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n           red_mthr.actions_ok s0 t ta \\<and>\n           thr s1 t = \\<lfloor>(x, ln')\\<rfloor> \\<and>\n           thr s t = \\<lfloor>(x, ln'')\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>x0 s0 ta x m1 w' ln''.\n        \\<lbrakk>red_mthr.r_syntax P t x0 (shr s0) ta x m1;\n         Suspend w' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n         thr s t = \\<lfloor>(x, ln'')\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  red_mthr.r_syntax P t x0 (shr s0) ta x m1\n  Suspend w' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\n  thr s t = \\<lfloor>(x, ln'')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>t w.\n       wset s t = \\<lfloor>w\\<rfloor> \\<Longrightarrow>\n       \\<exists>x ln.\n          thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and> \\<not> final_expr x", "from Suspend_final[OF mred Suspend] tst"], ["proof (chain)\npicking this:\n  \\<not> final_expr x\n  thr s t = \\<lfloor>(x, ln'')\\<rfloor>", "show \" \\<exists>x ln. thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and> \\<not> final_expr x\""], ["proof (prove)\nusing this:\n  \\<not> final_expr x\n  thr s t = \\<lfloor>(x, ln'')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>x ln.\n       thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and> \\<not> final_expr x", "by blast"], ["proof (state)\nthis:\n  \\<exists>x ln.\n     thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and> \\<not> final_expr x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  red_mthr.wset_final_ok (wset s) (thr s)\n\ngoal (5 subgoals):\n 1. \\<And>s.\n       s \\<in> red_mthr.wset_Suspend_ok P\n                ({s. sync_es_ok (thr s) (shr s) \\<and>\n                     lock_ok (locks s) (thr s)} \\<inter>\n                 {s. \\<exists>Es.\n                        sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n                 {s. def_ass_ts_ok (thr s) (shr s)}) \\<Longrightarrow>\n       lock_thread_ok (locks s) (thr s) \\<and>\n       red_mthr.wset_final_ok (wset s) (thr s)\n 2. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 3. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 4. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 5. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "ultimately"], ["proof (chain)\npicking this:\n  lock_thread_ok (locks s) (thr s)\n  red_mthr.wset_final_ok (wset s) (thr s)", "show \"lock_thread_ok (locks s) (thr s) \\<and> red_mthr.wset_final_ok (wset s) (thr s)\""], ["proof (prove)\nusing this:\n  lock_thread_ok (locks s) (thr s)\n  red_mthr.wset_final_ok (wset s) (thr s)\n\ngoal (1 subgoal):\n 1. lock_thread_ok (locks s) (thr s) \\<and>\n    red_mthr.wset_final_ok (wset s) (thr s)", ".."], ["proof (state)\nthis:\n  lock_thread_ok (locks s) (thr s) \\<and>\n  red_mthr.wset_final_ok (wset s) (thr s)\n\ngoal (4 subgoals):\n 1. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 2. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 3. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 4. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "}"], ["proof (state)\nthis:\n  ?s17\n  \\<in> red_mthr.wset_Suspend_ok P\n         ({s. sync_es_ok (thr s) (shr s) \\<and>\n              lock_ok (locks s) (thr s)} \\<inter>\n          {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n          {s. def_ass_ts_ok (thr s) (shr s)}) \\<Longrightarrow>\n  lock_thread_ok (locks ?s17) (thr ?s17) \\<and>\n  red_mthr.wset_final_ok (wset ?s17) (thr ?s17)\n\ngoal (4 subgoals):\n 1. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 2. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 3. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 4. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 2. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 3. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 4. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "fix s t ex ta e'x' m'"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 2. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 3. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 4. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "assume wfs: \"s \\<in> ?wf_state\"\n    and \"thr s t = \\<lfloor>(ex, no_wait_locks)\\<rfloor>\"\n    and \"mred P t (ex, shr s) ta (e'x', m')\"\n    and wait: \"\\<not> waiting (wset s t)\""], ["proof (state)\nthis:\n  s \\<in> red_mthr.wset_Suspend_ok P\n           ({s. sync_es_ok (thr s) (shr s) \\<and>\n                lock_ok (locks s) (thr s)} \\<inter>\n            {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n            {s. def_ass_ts_ok (thr s) (shr s)})\n  thr s t = \\<lfloor>(ex, no_wait_locks)\\<rfloor>\n  red_mthr.r_syntax P t ex (shr s) ta e'x' m'\n  \\<not> waiting (wset s t)\n\ngoal (4 subgoals):\n 1. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 2. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 3. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 4. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "moreover"], ["proof (state)\nthis:\n  s \\<in> red_mthr.wset_Suspend_ok P\n           ({s. sync_es_ok (thr s) (shr s) \\<and>\n                lock_ok (locks s) (thr s)} \\<inter>\n            {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n            {s. def_ass_ts_ok (thr s) (shr s)})\n  thr s t = \\<lfloor>(ex, no_wait_locks)\\<rfloor>\n  red_mthr.r_syntax P t ex (shr s) ta e'x' m'\n  \\<not> waiting (wset s t)\n\ngoal (4 subgoals):\n 1. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 2. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 3. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 4. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "obtain ls ts m ws \"is\" where s: \"s = (ls, (ts, m), ws, is)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ls ts m ws is.\n        s = (ls, (ts, m), ws, is) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases s) fastforce"], ["proof (state)\nthis:\n  s = (ls, (ts, m), ws, is)\n\ngoal (4 subgoals):\n 1. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 2. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 3. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 4. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "moreover"], ["proof (state)\nthis:\n  s = (ls, (ts, m), ws, is)\n\ngoal (4 subgoals):\n 1. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 2. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 3. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 4. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "obtain e x where ex: \"ex = (e, x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e x. ex = (e, x) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases ex)"], ["proof (state)\nthis:\n  ex = (e, x)\n\ngoal (4 subgoals):\n 1. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 2. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 3. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 4. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "moreover"], ["proof (state)\nthis:\n  ex = (e, x)\n\ngoal (4 subgoals):\n 1. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 2. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 3. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 4. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "obtain e' x' where e'x': \"e'x' = (e', x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e' x'.\n        e'x' = (e', x') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases e'x')"], ["proof (state)\nthis:\n  e'x' = (e', x')\n\ngoal (4 subgoals):\n 1. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 2. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 3. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 4. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "ultimately"], ["proof (chain)\npicking this:\n  s \\<in> red_mthr.wset_Suspend_ok P\n           ({s. sync_es_ok (thr s) (shr s) \\<and>\n                lock_ok (locks s) (thr s)} \\<inter>\n            {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n            {s. def_ass_ts_ok (thr s) (shr s)})\n  thr s t = \\<lfloor>(ex, no_wait_locks)\\<rfloor>\n  red_mthr.r_syntax P t ex (shr s) ta e'x' m'\n  \\<not> waiting (wset s t)\n  s = (ls, (ts, m), ws, is)\n  ex = (e, x)\n  e'x' = (e', x')", "have tst: \"ts t = \\<lfloor>(ex, no_wait_locks)\\<rfloor>\" \n    and red: \"P,t \\<turnstile> \\<langle>e, (m, x)\\<rangle> -ta\\<rightarrow> \\<langle>e', (m', x')\\<rangle>\""], ["proof (prove)\nusing this:\n  s \\<in> red_mthr.wset_Suspend_ok P\n           ({s. sync_es_ok (thr s) (shr s) \\<and>\n                lock_ok (locks s) (thr s)} \\<inter>\n            {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n            {s. def_ass_ts_ok (thr s) (shr s)})\n  thr s t = \\<lfloor>(ex, no_wait_locks)\\<rfloor>\n  red_mthr.r_syntax P t ex (shr s) ta e'x' m'\n  \\<not> waiting (wset s t)\n  s = (ls, (ts, m), ws, is)\n  ex = (e, x)\n  e'x' = (e', x')\n\ngoal (1 subgoal):\n 1. ts t = \\<lfloor>(ex, no_wait_locks)\\<rfloor> &&&\n    extTA2J\n     P,P,t \\<turnstile> \\<langle>e,(m, x)\\<rangle> -ta\\<rightarrow>\n                        \\<langle>e',(m', x')\\<rangle>", "by auto"], ["proof (state)\nthis:\n  ts t = \\<lfloor>(ex, no_wait_locks)\\<rfloor>\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e,(m, x)\\<rangle> -ta\\<rightarrow>\n                      \\<langle>e',(m', x')\\<rangle>\n\ngoal (4 subgoals):\n 1. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 2. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 3. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 4. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "from wf"], ["proof (chain)\npicking this:\n  wf_J_prog P", "have wwf: \"wwf_J_prog P\""], ["proof (prove)\nusing this:\n  wf_J_prog P\n\ngoal (1 subgoal):\n 1. wwf_J_prog P", "by(rule wf_prog_wwf_prog)"], ["proof (state)\nthis:\n  wwf_J_prog P\n\ngoal (4 subgoals):\n 1. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 2. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 3. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 4. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "from wfs s"], ["proof (chain)\npicking this:\n  s \\<in> red_mthr.wset_Suspend_ok P\n           ({s. sync_es_ok (thr s) (shr s) \\<and>\n                lock_ok (locks s) (thr s)} \\<inter>\n            {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n            {s. def_ass_ts_ok (thr s) (shr s)})\n  s = (ls, (ts, m), ws, is)", "obtain Es where aeos: \"sync_es_ok ts m\"\n    and lockok: \"lock_ok ls ts\"\n    and \"sconf_type_ts_ok Es ts m\""], ["proof (prove)\nusing this:\n  s \\<in> red_mthr.wset_Suspend_ok P\n           ({s. sync_es_ok (thr s) (shr s) \\<and>\n                lock_ok (locks s) (thr s)} \\<inter>\n            {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n            {s. def_ass_ts_ok (thr s) (shr s)})\n  s = (ls, (ts, m), ws, is)\n\ngoal (1 subgoal):\n 1. (\\<And>Es.\n        \\<lbrakk>sync_es_ok ts m; lock_ok ls ts;\n         sconf_type_ts_ok Es ts m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: red_mthr.wset_Suspend_okD1)"], ["proof (state)\nthis:\n  sync_es_ok ts m\n  lock_ok ls ts\n  sconf_type_ts_ok Es ts m\n\ngoal (4 subgoals):\n 1. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 2. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 3. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 4. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "with tst ex"], ["proof (chain)\npicking this:\n  ts t = \\<lfloor>(ex, no_wait_locks)\\<rfloor>\n  ex = (e, x)\n  sync_es_ok ts m\n  lock_ok ls ts\n  sconf_type_ts_ok Es ts m", "obtain E T where sconf: \"sconf_type_ok (E, T) t (e, x) m\"\n    and aoe: \"sync_ok e\""], ["proof (prove)\nusing this:\n  ts t = \\<lfloor>(ex, no_wait_locks)\\<rfloor>\n  ex = (e, x)\n  sync_es_ok ts m\n  lock_ok ls ts\n  sconf_type_ts_ok Es ts m\n\ngoal (1 subgoal):\n 1. (\\<And>E T.\n        \\<lbrakk>sconf_type_ok (E, T) t (e, x) m; sync_ok e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest: ts_okD ts_invD)"], ["proof (state)\nthis:\n  sconf_type_ok (E, T) t (e, x) m\n  sync_ok e\n\ngoal (4 subgoals):\n 1. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 2. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 3. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 4. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "then"], ["proof (chain)\npicking this:\n  sconf_type_ok (E, T) t (e, x) m\n  sync_ok e", "obtain T' where \"hconf m\" \"P,E,m \\<turnstile> e : T'\" \"preallocated m\""], ["proof (prove)\nusing this:\n  sconf_type_ok (E, T) t (e, x) m\n  sync_ok e\n\ngoal (1 subgoal):\n 1. (\\<And>T'.\n        \\<lbrakk>hconf m; P,E,m \\<turnstile> e : T'; preallocated m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: sconf_type_ok_def sconf_def type_ok_def)"], ["proof (state)\nthis:\n  hconf m\n  P,E,m \\<turnstile> e : T'\n  preallocated m\n\ngoal (4 subgoals):\n 1. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 2. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 3. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 4. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "from \\<open>sconf_type_ts_ok Es ts m\\<close> s"], ["proof (chain)\npicking this:\n  sconf_type_ts_ok Es ts m\n  s = (ls, (ts, m), ws, is)", "have \"thread_conf P (thr s) (shr s)\""], ["proof (prove)\nusing this:\n  sconf_type_ts_ok Es ts m\n  s = (ls, (ts, m), ws, is)\n\ngoal (1 subgoal):\n 1. thread_conf P (thr s) (shr s)", "by(auto dest: ts_invD intro!: ts_okI simp add: sconf_type_ok_def)"], ["proof (state)\nthis:\n  thread_conf P (thr s) (shr s)\n\ngoal (4 subgoals):\n 1. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 2. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 3. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 4. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "with \\<open>thr s t = \\<lfloor>(ex, no_wait_locks)\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  thr s t = \\<lfloor>(ex, no_wait_locks)\\<rfloor>\n  thread_conf P (thr s) (shr s)", "have \"P,shr s \\<turnstile> t \\<surd>t\""], ["proof (prove)\nusing this:\n  thr s t = \\<lfloor>(ex, no_wait_locks)\\<rfloor>\n  thread_conf P (thr s) (shr s)\n\ngoal (1 subgoal):\n 1. P,shr s \\<turnstile> t \\<surd>t", "by(auto dest: ts_okD)"], ["proof (state)\nthis:\n  P,shr s \\<turnstile> t \\<surd>t\n\ngoal (4 subgoals):\n 1. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m';\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta' x' m' \\<and>\n                            (red_mthr.actions_ok s t ta' \\<or>\n                             red_mthr.actions_ok' s t ta' \\<and>\n                             red_mthr.actions_subset ta' ta)\n 2. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 3. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 4. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "show \"\\<exists>ta' x' m'. mred P t (ex, shr s) ta' (x', m') \\<and> \n        (red_mthr.actions_ok s t ta' \\<or> red_mthr.actions_ok' s t ta' \\<and> red_mthr.actions_subset ta' ta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ta' x' m'.\n       red_mthr.r_syntax P t ex (shr s) ta' x' m' \\<and>\n       (red_mthr.actions_ok s t ta' \\<or>\n        red_mthr.actions_ok' s t ta' \\<and> red_mthr.actions_subset ta' ta)", "proof(cases \"red_mthr.actions_ok' s t ta\")"], ["proof (state)\ngoal (2 subgoals):\n 1. red_mthr.actions_ok' s t ta \\<Longrightarrow>\n    \\<exists>ta' x' m'.\n       red_mthr.r_syntax P t ex (shr s) ta' x' m' \\<and>\n       (red_mthr.actions_ok s t ta' \\<or>\n        red_mthr.actions_ok' s t ta' \\<and> red_mthr.actions_subset ta' ta)\n 2. \\<not> red_mthr.actions_ok' s t ta \\<Longrightarrow>\n    \\<exists>ta' x' m'.\n       red_mthr.r_syntax P t ex (shr s) ta' x' m' \\<and>\n       (red_mthr.actions_ok s t ta' \\<or>\n        red_mthr.actions_ok' s t ta' \\<and> red_mthr.actions_subset ta' ta)", "case True"], ["proof (state)\nthis:\n  red_mthr.actions_ok' s t ta\n\ngoal (2 subgoals):\n 1. red_mthr.actions_ok' s t ta \\<Longrightarrow>\n    \\<exists>ta' x' m'.\n       red_mthr.r_syntax P t ex (shr s) ta' x' m' \\<and>\n       (red_mthr.actions_ok s t ta' \\<or>\n        red_mthr.actions_ok' s t ta' \\<and> red_mthr.actions_subset ta' ta)\n 2. \\<not> red_mthr.actions_ok' s t ta \\<Longrightarrow>\n    \\<exists>ta' x' m'.\n       red_mthr.r_syntax P t ex (shr s) ta' x' m' \\<and>\n       (red_mthr.actions_ok s t ta' \\<or>\n        red_mthr.actions_ok' s t ta' \\<and> red_mthr.actions_subset ta' ta)", "have \"red_mthr.actions_subset ta ta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. red_mthr.actions_subset ta ta", ".."], ["proof (state)\nthis:\n  red_mthr.actions_subset ta ta\n\ngoal (2 subgoals):\n 1. red_mthr.actions_ok' s t ta \\<Longrightarrow>\n    \\<exists>ta' x' m'.\n       red_mthr.r_syntax P t ex (shr s) ta' x' m' \\<and>\n       (red_mthr.actions_ok s t ta' \\<or>\n        red_mthr.actions_ok' s t ta' \\<and> red_mthr.actions_subset ta' ta)\n 2. \\<not> red_mthr.actions_ok' s t ta \\<Longrightarrow>\n    \\<exists>ta' x' m'.\n       red_mthr.r_syntax P t ex (shr s) ta' x' m' \\<and>\n       (red_mthr.actions_ok s t ta' \\<or>\n        red_mthr.actions_ok' s t ta' \\<and> red_mthr.actions_subset ta' ta)", "with True \\<open>mred P t (ex, shr s) ta (e'x', m')\\<close>"], ["proof (chain)\npicking this:\n  red_mthr.actions_ok' s t ta\n  red_mthr.r_syntax P t ex (shr s) ta e'x' m'\n  red_mthr.actions_subset ta ta", "show ?thesis"], ["proof (prove)\nusing this:\n  red_mthr.actions_ok' s t ta\n  red_mthr.r_syntax P t ex (shr s) ta e'x' m'\n  red_mthr.actions_subset ta ta\n\ngoal (1 subgoal):\n 1. \\<exists>ta' x' m'.\n       red_mthr.r_syntax P t ex (shr s) ta' x' m' \\<and>\n       (red_mthr.actions_ok s t ta' \\<or>\n        red_mthr.actions_ok' s t ta' \\<and> red_mthr.actions_subset ta' ta)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ta' x' m'.\n     red_mthr.r_syntax P t ex (shr s) ta' x' m' \\<and>\n     (red_mthr.actions_ok s t ta' \\<or>\n      red_mthr.actions_ok' s t ta' \\<and> red_mthr.actions_subset ta' ta)\n\ngoal (1 subgoal):\n 1. \\<not> red_mthr.actions_ok' s t ta \\<Longrightarrow>\n    \\<exists>ta' x' m'.\n       red_mthr.r_syntax P t ex (shr s) ta' x' m' \\<and>\n       (red_mthr.actions_ok s t ta' \\<or>\n        red_mthr.actions_ok' s t ta' \\<and> red_mthr.actions_subset ta' ta)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> red_mthr.actions_ok' s t ta \\<Longrightarrow>\n    \\<exists>ta' x' m'.\n       red_mthr.r_syntax P t ex (shr s) ta' x' m' \\<and>\n       (red_mthr.actions_ok s t ta' \\<or>\n        red_mthr.actions_ok' s t ta' \\<and> red_mthr.actions_subset ta' ta)", "case False"], ["proof (state)\nthis:\n  \\<not> red_mthr.actions_ok' s t ta\n\ngoal (1 subgoal):\n 1. \\<not> red_mthr.actions_ok' s t ta \\<Longrightarrow>\n    \\<exists>ta' x' m'.\n       red_mthr.r_syntax P t ex (shr s) ta' x' m' \\<and>\n       (red_mthr.actions_ok s t ta' \\<or>\n        red_mthr.actions_ok' s t ta' \\<and> red_mthr.actions_subset ta' ta)", "from lock_okD2[OF lockok, OF tst[unfolded ex]]"], ["proof (chain)\npicking this:\n  \\<forall>l. has_locks (ls $ l) t + no_wait_locks $ l = expr_locks e l", "have locks: \"\\<forall>l. has_locks (ls $ l) t \\<ge> expr_locks e l\""], ["proof (prove)\nusing this:\n  \\<forall>l. has_locks (ls $ l) t + no_wait_locks $ l = expr_locks e l\n\ngoal (1 subgoal):\n 1. \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t", "by simp"], ["proof (state)\nthis:\n  \\<forall>l. expr_locks e l \\<le> has_locks (ls $ l) t\n\ngoal (1 subgoal):\n 1. \\<not> red_mthr.actions_ok' s t ta \\<Longrightarrow>\n    \\<exists>ta' x' m'.\n       red_mthr.r_syntax P t ex (shr s) ta' x' m' \\<and>\n       (red_mthr.actions_ok s t ta' \\<or>\n        red_mthr.actions_ok' s t ta' \\<and> red_mthr.actions_subset ta' ta)", "have \"ws t = None \\<or> (\\<exists>a vs w T Ts Tr D. call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and> typeof_addr (hp (m, x)) a = \\<lfloor>T\\<rfloor> \\<and> P \\<turnstile> class_type_of T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and> ws t = \\<lfloor>PostWS w\\<rfloor>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ws t = None \\<or>\n    (\\<exists>a vs w T Ts Tr D.\n        call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n        typeof_addr (hp (m, x)) a = \\<lfloor>T\\<rfloor> \\<and>\n        P \\<turnstile> class_type_of\n                        T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n        ws t = \\<lfloor>PostWS w\\<rfloor>)", "proof(cases \"ws t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ws t = None \\<Longrightarrow>\n    ws t = None \\<or>\n    (\\<exists>a vs w T Ts Tr D.\n        call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n        typeof_addr (hp (m, x)) a = \\<lfloor>T\\<rfloor> \\<and>\n        P \\<turnstile> class_type_of\n                        T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n        ws t = \\<lfloor>PostWS w\\<rfloor>)\n 2. \\<And>a.\n       ws t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       ws t = None \\<or>\n       (\\<exists>a vs w T Ts Tr D.\n           call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n           typeof_addr (hp (m, x)) a = \\<lfloor>T\\<rfloor> \\<and>\n           P \\<turnstile> class_type_of\n                           T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n           ws t = \\<lfloor>PostWS w\\<rfloor>)", "case None"], ["proof (state)\nthis:\n  ws t = None\n\ngoal (2 subgoals):\n 1. ws t = None \\<Longrightarrow>\n    ws t = None \\<or>\n    (\\<exists>a vs w T Ts Tr D.\n        call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n        typeof_addr (hp (m, x)) a = \\<lfloor>T\\<rfloor> \\<and>\n        P \\<turnstile> class_type_of\n                        T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n        ws t = \\<lfloor>PostWS w\\<rfloor>)\n 2. \\<And>a.\n       ws t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       ws t = None \\<or>\n       (\\<exists>a vs w T Ts Tr D.\n           call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n           typeof_addr (hp (m, x)) a = \\<lfloor>T\\<rfloor> \\<and>\n           P \\<turnstile> class_type_of\n                           T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n           ws t = \\<lfloor>PostWS w\\<rfloor>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ws t = None\n\ngoal (1 subgoal):\n 1. ws t = None \\<or>\n    (\\<exists>a vs w T Ts Tr D.\n        call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n        typeof_addr (hp (m, x)) a = \\<lfloor>T\\<rfloor> \\<and>\n        P \\<turnstile> class_type_of\n                        T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n        ws t = \\<lfloor>PostWS w\\<rfloor>)", ".."], ["proof (state)\nthis:\n  ws t = None \\<or>\n  (\\<exists>a vs w T Ts Tr D.\n      call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n      typeof_addr (hp (m, x)) a = \\<lfloor>T\\<rfloor> \\<and>\n      P \\<turnstile> class_type_of\n                      T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n      ws t = \\<lfloor>PostWS w\\<rfloor>)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ws t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       ws t = None \\<or>\n       (\\<exists>a vs w T Ts Tr D.\n           call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n           typeof_addr (hp (m, x)) a = \\<lfloor>T\\<rfloor> \\<and>\n           P \\<turnstile> class_type_of\n                           T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n           ws t = \\<lfloor>PostWS w\\<rfloor>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       ws t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       ws t = None \\<or>\n       (\\<exists>a vs w T Ts Tr D.\n           call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n           typeof_addr (hp (m, x)) a = \\<lfloor>T\\<rfloor> \\<and>\n           P \\<turnstile> class_type_of\n                           T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n           ws t = \\<lfloor>PostWS w\\<rfloor>)", "case (Some w)"], ["proof (state)\nthis:\n  ws t = \\<lfloor>w\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ws t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       ws t = None \\<or>\n       (\\<exists>a vs w T Ts Tr D.\n           call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n           typeof_addr (hp (m, x)) a = \\<lfloor>T\\<rfloor> \\<and>\n           P \\<turnstile> class_type_of\n                           T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n           ws t = \\<lfloor>PostWS w\\<rfloor>)", "with red_mthr.wset_Suspend_okD2[OF wfs, of t w] tst ex s"], ["proof (chain)\npicking this:\n  wset s t = \\<lfloor>w\\<rfloor> \\<Longrightarrow>\n  \\<exists>s0\\<in>{s. sync_es_ok (thr s) (shr s) \\<and>\n                      lock_ok (locks s) (thr s)} \\<inter>\n                  {s. \\<exists>Es.\n                         sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n                  {s. def_ass_ts_ok (thr s) (shr s)}.\n     \\<exists>s1\\<in>{s. sync_es_ok (thr s) (shr s) \\<and>\n                         lock_ok (locks s) (thr s)} \\<inter>\n                     {s. \\<exists>Es.\n                            sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n                     {s. def_ass_ts_ok (thr s) (shr s)}.\n        \\<exists>ttas x x0 ta w' ln' ln''.\n           P \\<turnstile> s0 -t\\<triangleright>ta\\<rightarrow> s1 \\<and>\n           P \\<turnstile> s1 -\\<triangleright>ttas\\<rightarrow>* s \\<and>\n           thr s0 t = \\<lfloor>(x0, no_wait_locks)\\<rfloor> \\<and>\n           red_mthr.r_syntax P t x0 (shr s0) ta x (shr s1) \\<and>\n           Suspend w' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n           red_mthr.actions_ok s0 t ta \\<and>\n           thr s1 t = \\<lfloor>(x, ln')\\<rfloor> \\<and>\n           thr s t = \\<lfloor>(x, ln'')\\<rfloor>\n  ts t = \\<lfloor>(ex, no_wait_locks)\\<rfloor>\n  ex = (e, x)\n  s = (ls, (ts, m), ws, is)\n  ws t = \\<lfloor>w\\<rfloor>", "obtain e0 x0 m0 ta0 w' s1 tta1 \n        where red0: \"P,t \\<turnstile> \\<langle>e0, (m0, x0)\\<rangle> -ta0\\<rightarrow> \\<langle>e, (shr s1, x)\\<rangle>\"\n        and Suspend: \"Suspend w' \\<in> set \\<lbrace>ta0\\<rbrace>\\<^bsub>w\\<^esub>\"\n        and s1: \"P \\<turnstile> s1 -\\<triangleright>tta1\\<rightarrow>* s\""], ["proof (prove)\nusing this:\n  wset s t = \\<lfloor>w\\<rfloor> \\<Longrightarrow>\n  \\<exists>s0\\<in>{s. sync_es_ok (thr s) (shr s) \\<and>\n                      lock_ok (locks s) (thr s)} \\<inter>\n                  {s. \\<exists>Es.\n                         sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n                  {s. def_ass_ts_ok (thr s) (shr s)}.\n     \\<exists>s1\\<in>{s. sync_es_ok (thr s) (shr s) \\<and>\n                         lock_ok (locks s) (thr s)} \\<inter>\n                     {s. \\<exists>Es.\n                            sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n                     {s. def_ass_ts_ok (thr s) (shr s)}.\n        \\<exists>ttas x x0 ta w' ln' ln''.\n           P \\<turnstile> s0 -t\\<triangleright>ta\\<rightarrow> s1 \\<and>\n           P \\<turnstile> s1 -\\<triangleright>ttas\\<rightarrow>* s \\<and>\n           thr s0 t = \\<lfloor>(x0, no_wait_locks)\\<rfloor> \\<and>\n           red_mthr.r_syntax P t x0 (shr s0) ta x (shr s1) \\<and>\n           Suspend w' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n           red_mthr.actions_ok s0 t ta \\<and>\n           thr s1 t = \\<lfloor>(x, ln')\\<rfloor> \\<and>\n           thr s t = \\<lfloor>(x, ln'')\\<rfloor>\n  ts t = \\<lfloor>(ex, no_wait_locks)\\<rfloor>\n  ex = (e, x)\n  s = (ls, (ts, m), ws, is)\n  ws t = \\<lfloor>w\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>e0 m0 x0 ta0 s1 w' tta1.\n        \\<lbrakk>extTA2J\n                  P,P,t \\<turnstile> \\<langle>e0,\n(m0, x0)\\<rangle> -ta0\\<rightarrow>\n                                     \\<langle>e,(shr s1, x)\\<rangle>;\n         Suspend w' \\<in> set \\<lbrace>ta0\\<rbrace>\\<^bsub>w\\<^esub>;\n         P \\<turnstile> s1 -\\<triangleright>tta1\\<rightarrow>* s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e0,(m0, x0)\\<rangle> -ta0\\<rightarrow>\n                      \\<langle>e,(shr s1, x)\\<rangle>\n  Suspend w' \\<in> set \\<lbrace>ta0\\<rbrace>\\<^bsub>w\\<^esub>\n  P \\<turnstile> s1 -\\<triangleright>tta1\\<rightarrow>* s\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ws t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       ws t = None \\<or>\n       (\\<exists>a vs w T Ts Tr D.\n           call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n           typeof_addr (hp (m, x)) a = \\<lfloor>T\\<rfloor> \\<and>\n           P \\<turnstile> class_type_of\n                           T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n           ws t = \\<lfloor>PostWS w\\<rfloor>)", "from red_Suspend_is_call[OF red0 Suspend]"], ["proof (chain)\npicking this:\n  \\<exists>a vs hT Ts Tr D.\n     call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n     typeof_addr (hp (m0, x0)) a = \\<lfloor>hT\\<rfloor> \\<and>\n     P \\<turnstile> class_type_of\n                     hT sees wait: Ts\\<rightarrow>Tr = Native in D", "obtain a vs T Ts Tr D\n        where call: \"call e = \\<lfloor>(a, wait, vs)\\<rfloor>\"\n        and type: \"typeof_addr m0 a = \\<lfloor>T\\<rfloor>\" \n        and iec: \"P \\<turnstile> class_type_of T sees wait: Ts\\<rightarrow>Tr = Native in D\""], ["proof (prove)\nusing this:\n  \\<exists>a vs hT Ts Tr D.\n     call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n     typeof_addr (hp (m0, x0)) a = \\<lfloor>hT\\<rfloor> \\<and>\n     P \\<turnstile> class_type_of\n                     hT sees wait: Ts\\<rightarrow>Tr = Native in D\n\ngoal (1 subgoal):\n 1. (\\<And>a vs T Ts Tr D.\n        \\<lbrakk>call e = \\<lfloor>(a, wait, vs)\\<rfloor>;\n         typeof_addr m0 a = \\<lfloor>T\\<rfloor>;\n         P \\<turnstile> class_type_of\n                         T sees wait: Ts\\<rightarrow>Tr = Native in D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  call e = \\<lfloor>(a, wait, vs)\\<rfloor>\n  typeof_addr m0 a = \\<lfloor>T\\<rfloor>\n  P \\<turnstile> class_type_of T sees wait: Ts\\<rightarrow>Tr = Native in D\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ws t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       ws t = None \\<or>\n       (\\<exists>a vs w T Ts Tr D.\n           call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n           typeof_addr (hp (m, x)) a = \\<lfloor>T\\<rfloor> \\<and>\n           P \\<turnstile> class_type_of\n                           T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n           ws t = \\<lfloor>PostWS w\\<rfloor>)", "from red0"], ["proof (chain)\npicking this:\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e0,(m0, x0)\\<rangle> -ta0\\<rightarrow>\n                      \\<langle>e,(shr s1, x)\\<rangle>", "have \"m0 \\<unlhd> shr s1\""], ["proof (prove)\nusing this:\n  extTA2J\n   P,P,t \\<turnstile> \\<langle>e0,(m0, x0)\\<rangle> -ta0\\<rightarrow>\n                      \\<langle>e,(shr s1, x)\\<rangle>\n\ngoal (1 subgoal):\n 1. m0 \\<unlhd> shr s1", "by(auto dest: red_hext_incr)"], ["proof (state)\nthis:\n  m0 \\<unlhd> shr s1\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ws t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       ws t = None \\<or>\n       (\\<exists>a vs w T Ts Tr D.\n           call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n           typeof_addr (hp (m, x)) a = \\<lfloor>T\\<rfloor> \\<and>\n           P \\<turnstile> class_type_of\n                           T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n           ws t = \\<lfloor>PostWS w\\<rfloor>)", "also"], ["proof (state)\nthis:\n  m0 \\<unlhd> shr s1\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ws t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       ws t = None \\<or>\n       (\\<exists>a vs w T Ts Tr D.\n           call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n           typeof_addr (hp (m, x)) a = \\<lfloor>T\\<rfloor> \\<and>\n           P \\<turnstile> class_type_of\n                           T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n           ws t = \\<lfloor>PostWS w\\<rfloor>)", "from s1"], ["proof (chain)\npicking this:\n  P \\<turnstile> s1 -\\<triangleright>tta1\\<rightarrow>* s", "have \"shr s1 \\<unlhd> shr s\""], ["proof (prove)\nusing this:\n  P \\<turnstile> s1 -\\<triangleright>tta1\\<rightarrow>* s\n\ngoal (1 subgoal):\n 1. shr s1 \\<unlhd> shr s", "by(rule RedT_hext_incr)"], ["proof (state)\nthis:\n  shr s1 \\<unlhd> shr s\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ws t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       ws t = None \\<or>\n       (\\<exists>a vs w T Ts Tr D.\n           call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n           typeof_addr (hp (m, x)) a = \\<lfloor>T\\<rfloor> \\<and>\n           P \\<turnstile> class_type_of\n                           T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n           ws t = \\<lfloor>PostWS w\\<rfloor>)", "finally"], ["proof (chain)\npicking this:\n  m0 \\<unlhd> shr s", "have \"typeof_addr (shr s) a = \\<lfloor>T\\<rfloor>\""], ["proof (prove)\nusing this:\n  m0 \\<unlhd> shr s\n\ngoal (1 subgoal):\n 1. typeof_addr (shr s) a = \\<lfloor>T\\<rfloor>", "using type"], ["proof (prove)\nusing this:\n  m0 \\<unlhd> shr s\n  typeof_addr m0 a = \\<lfloor>T\\<rfloor>\n\ngoal (1 subgoal):\n 1. typeof_addr (shr s) a = \\<lfloor>T\\<rfloor>", "by(rule typeof_addr_hext_mono)"], ["proof (state)\nthis:\n  typeof_addr (shr s) a = \\<lfloor>T\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ws t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       ws t = None \\<or>\n       (\\<exists>a vs w T Ts Tr D.\n           call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n           typeof_addr (hp (m, x)) a = \\<lfloor>T\\<rfloor> \\<and>\n           P \\<turnstile> class_type_of\n                           T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n           ws t = \\<lfloor>PostWS w\\<rfloor>)", "moreover"], ["proof (state)\nthis:\n  typeof_addr (shr s) a = \\<lfloor>T\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ws t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       ws t = None \\<or>\n       (\\<exists>a vs w T Ts Tr D.\n           call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n           typeof_addr (hp (m, x)) a = \\<lfloor>T\\<rfloor> \\<and>\n           P \\<turnstile> class_type_of\n                           T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n           ws t = \\<lfloor>PostWS w\\<rfloor>)", "from Some wait s"], ["proof (chain)\npicking this:\n  ws t = \\<lfloor>w\\<rfloor>\n  \\<not> waiting (wset s t)\n  s = (ls, (ts, m), ws, is)", "obtain w' where \"ws t = \\<lfloor>PostWS w'\\<rfloor>\""], ["proof (prove)\nusing this:\n  ws t = \\<lfloor>w\\<rfloor>\n  \\<not> waiting (wset s t)\n  s = (ls, (ts, m), ws, is)\n\ngoal (1 subgoal):\n 1. (\\<And>w'.\n        ws t = \\<lfloor>PostWS w'\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: not_waiting_iff)"], ["proof (state)\nthis:\n  ws t = \\<lfloor>PostWS w'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ws t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       ws t = None \\<or>\n       (\\<exists>a vs w T Ts Tr D.\n           call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n           typeof_addr (hp (m, x)) a = \\<lfloor>T\\<rfloor> \\<and>\n           P \\<turnstile> class_type_of\n                           T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n           ws t = \\<lfloor>PostWS w\\<rfloor>)", "ultimately"], ["proof (chain)\npicking this:\n  typeof_addr (shr s) a = \\<lfloor>T\\<rfloor>\n  ws t = \\<lfloor>PostWS w'\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  typeof_addr (shr s) a = \\<lfloor>T\\<rfloor>\n  ws t = \\<lfloor>PostWS w'\\<rfloor>\n\ngoal (1 subgoal):\n 1. ws t = None \\<or>\n    (\\<exists>a vs w T Ts Tr D.\n        call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n        typeof_addr (hp (m, x)) a = \\<lfloor>T\\<rfloor> \\<and>\n        P \\<turnstile> class_type_of\n                        T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n        ws t = \\<lfloor>PostWS w\\<rfloor>)", "using call iec s"], ["proof (prove)\nusing this:\n  typeof_addr (shr s) a = \\<lfloor>T\\<rfloor>\n  ws t = \\<lfloor>PostWS w'\\<rfloor>\n  call e = \\<lfloor>(a, wait, vs)\\<rfloor>\n  P \\<turnstile> class_type_of T sees wait: Ts\\<rightarrow>Tr = Native in D\n  s = (ls, (ts, m), ws, is)\n\ngoal (1 subgoal):\n 1. ws t = None \\<or>\n    (\\<exists>a vs w T Ts Tr D.\n        call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n        typeof_addr (hp (m, x)) a = \\<lfloor>T\\<rfloor> \\<and>\n        P \\<turnstile> class_type_of\n                        T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n        ws t = \\<lfloor>PostWS w\\<rfloor>)", "by auto"], ["proof (state)\nthis:\n  ws t = None \\<or>\n  (\\<exists>a vs w T Ts Tr D.\n      call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n      typeof_addr (hp (m, x)) a = \\<lfloor>T\\<rfloor> \\<and>\n      P \\<turnstile> class_type_of\n                      T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n      ws t = \\<lfloor>PostWS w\\<rfloor>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ws t = None \\<or>\n  (\\<exists>a vs w T Ts Tr D.\n      call e = \\<lfloor>(a, wait, vs)\\<rfloor> \\<and>\n      typeof_addr (hp (m, x)) a = \\<lfloor>T\\<rfloor> \\<and>\n      P \\<turnstile> class_type_of\n                      T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n      ws t = \\<lfloor>PostWS w\\<rfloor>)\n\ngoal (1 subgoal):\n 1. \\<not> red_mthr.actions_ok' s t ta \\<Longrightarrow>\n    \\<exists>ta' x' m'.\n       red_mthr.r_syntax P t ex (shr s) ta' x' m' \\<and>\n       (red_mthr.actions_ok s t ta' \\<or>\n        red_mthr.actions_ok' s t ta' \\<and> red_mthr.actions_subset ta' ta)", "from red_wf_red_aux[OF wf red False[unfolded s] aoe _ _ locks, OF _ _ this] \\<open>hconf m\\<close> \\<open>P,shr s \\<turnstile> t \\<surd>t\\<close> ex s"], ["proof (chain)\npicking this:\n  \\<lbrakk>hconf (hp (m, x)); P,hp (m, x) \\<turnstile> t \\<surd>t\\<rbrakk>\n  \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                       extTA2J\n                        P,P,t \\<turnstile> \\<langle>e,\n      (m, x)\\<rangle> -ta'\\<rightarrow>\n     \\<langle>e'',s''\\<rangle> \\<and>\n                       (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                         ta' \\<or>\n                        red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                         ta' \\<and>\n                        red_mthr.actions_subset ta' ta)\n  hconf m\n  P,shr s \\<turnstile> t \\<surd>t\n  ex = (e, x)\n  s = (ls, (ts, m), ws, is)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>hconf (hp (m, x)); P,hp (m, x) \\<turnstile> t \\<surd>t\\<rbrakk>\n  \\<Longrightarrow> \\<exists>e'' s'' ta'.\n                       extTA2J\n                        P,P,t \\<turnstile> \\<langle>e,\n      (m, x)\\<rangle> -ta'\\<rightarrow>\n     \\<langle>e'',s''\\<rangle> \\<and>\n                       (red_mthr.actions_ok (ls, (ts, m), ws, is) t\n                         ta' \\<or>\n                        red_mthr.actions_ok' (ls, (ts, m), ws, is) t\n                         ta' \\<and>\n                        red_mthr.actions_subset ta' ta)\n  hconf m\n  P,shr s \\<turnstile> t \\<surd>t\n  ex = (e, x)\n  s = (ls, (ts, m), ws, is)\n\ngoal (1 subgoal):\n 1. \\<exists>ta' x' m'.\n       red_mthr.r_syntax P t ex (shr s) ta' x' m' \\<and>\n       (red_mthr.actions_ok s t ta' \\<or>\n        red_mthr.actions_ok' s t ta' \\<and> red_mthr.actions_subset ta' ta)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ta' x' m'.\n     red_mthr.r_syntax P t ex (shr s) ta' x' m' \\<and>\n     (red_mthr.actions_ok s t ta' \\<or>\n      red_mthr.actions_ok' s t ta' \\<and> red_mthr.actions_subset ta' ta)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ta' x' m'.\n     red_mthr.r_syntax P t ex (shr s) ta' x' m' \\<and>\n     (red_mthr.actions_ok s t ta' \\<or>\n      red_mthr.actions_ok' s t ta' \\<and> red_mthr.actions_subset ta' ta)\n\ngoal (3 subgoals):\n 1. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 2. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 3. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 2. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 3. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "fix s t x"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 2. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 3. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "assume wfs: \"s \\<in> ?wf_state\"\n    and tst: \"thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\" \n    and nfin: \"\\<not> final_expr x\""], ["proof (state)\nthis:\n  s \\<in> red_mthr.wset_Suspend_ok P\n           ({s. sync_es_ok (thr s) (shr s) \\<and>\n                lock_ok (locks s) (thr s)} \\<inter>\n            {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n            {s. def_ass_ts_ok (thr s) (shr s)})\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  \\<not> final_expr x\n\ngoal (3 subgoals):\n 1. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 2. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 3. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "obtain e xs where x: \"x = (e, xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e xs. x = (e, xs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases x)"], ["proof (state)\nthis:\n  x = (e, xs)\n\ngoal (3 subgoals):\n 1. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 2. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 3. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "from wfs"], ["proof (chain)\npicking this:\n  s \\<in> red_mthr.wset_Suspend_ok P\n           ({s. sync_es_ok (thr s) (shr s) \\<and>\n                lock_ok (locks s) (thr s)} \\<inter>\n            {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n            {s. def_ass_ts_ok (thr s) (shr s)})", "have \"def_ass_ts_ok (thr s) (shr s)\""], ["proof (prove)\nusing this:\n  s \\<in> red_mthr.wset_Suspend_ok P\n           ({s. sync_es_ok (thr s) (shr s) \\<and>\n                lock_ok (locks s) (thr s)} \\<inter>\n            {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n            {s. def_ass_ts_ok (thr s) (shr s)})\n\ngoal (1 subgoal):\n 1. def_ass_ts_ok (thr s) (shr s)", "by(auto dest: red_mthr.wset_Suspend_okD1)"], ["proof (state)\nthis:\n  def_ass_ts_ok (thr s) (shr s)\n\ngoal (3 subgoals):\n 1. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 2. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 3. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "with tst x"], ["proof (chain)\npicking this:\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  x = (e, xs)\n  def_ass_ts_ok (thr s) (shr s)", "have DA: \"\\<D> e \\<lfloor>dom xs\\<rfloor>\""], ["proof (prove)\nusing this:\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  x = (e, xs)\n  def_ass_ts_ok (thr s) (shr s)\n\ngoal (1 subgoal):\n 1. \\<D> e \\<lfloor>dom xs\\<rfloor>", "by(auto dest: ts_okD)"], ["proof (state)\nthis:\n  \\<D> e \\<lfloor>dom xs\\<rfloor>\n\ngoal (3 subgoals):\n 1. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 2. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 3. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "from wfs"], ["proof (chain)\npicking this:\n  s \\<in> red_mthr.wset_Suspend_ok P\n           ({s. sync_es_ok (thr s) (shr s) \\<and>\n                lock_ok (locks s) (thr s)} \\<inter>\n            {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n            {s. def_ass_ts_ok (thr s) (shr s)})", "obtain Es where \"sconf_type_ts_ok Es (thr s) (shr s)\""], ["proof (prove)\nusing this:\n  s \\<in> red_mthr.wset_Suspend_ok P\n           ({s. sync_es_ok (thr s) (shr s) \\<and>\n                lock_ok (locks s) (thr s)} \\<inter>\n            {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n            {s. def_ass_ts_ok (thr s) (shr s)})\n\ngoal (1 subgoal):\n 1. (\\<And>Es.\n        sconf_type_ts_ok Es (thr s) (shr s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: red_mthr.wset_Suspend_okD1)"], ["proof (state)\nthis:\n  sconf_type_ts_ok Es (thr s) (shr s)\n\ngoal (3 subgoals):\n 1. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 2. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 3. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "with tst x"], ["proof (chain)\npicking this:\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  x = (e, xs)\n  sconf_type_ts_ok Es (thr s) (shr s)", "obtain E T where \"sconf_type_ok (E, T) t (e, xs) (shr s)\""], ["proof (prove)\nusing this:\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  x = (e, xs)\n  sconf_type_ts_ok Es (thr s) (shr s)\n\ngoal (1 subgoal):\n 1. (\\<And>E T.\n        sconf_type_ok (E, T) t (e, xs) (shr s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: ts_invD)"], ["proof (state)\nthis:\n  sconf_type_ok (E, T) t (e, xs) (shr s)\n\ngoal (3 subgoals):\n 1. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 2. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 3. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "then"], ["proof (chain)\npicking this:\n  sconf_type_ok (E, T) t (e, xs) (shr s)", "obtain T' where \"hconf (shr s)\" \"P,E,shr s \\<turnstile> e : T'\""], ["proof (prove)\nusing this:\n  sconf_type_ok (E, T) t (e, xs) (shr s)\n\ngoal (1 subgoal):\n 1. (\\<And>T'.\n        \\<lbrakk>hconf (shr s); P,E,shr s \\<turnstile> e : T'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: sconf_type_ok_def sconf_def type_ok_def)"], ["proof (state)\nthis:\n  hconf (shr s)\n  P,E,shr s \\<turnstile> e : T'\n\ngoal (3 subgoals):\n 1. \\<And>s t x.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m'.\n                            red_mthr.r_syntax P t x (shr s) ta x' m'\n 2. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 3. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "from red_progress(1)[OF wf_prog_wwf_prog[OF wf] this DA, where extTA=\"extTA2J P\" and t=t] nfin x"], ["proof (chain)\npicking this:\n  \\<not> final e \\<Longrightarrow>\n  \\<exists>e' s' ta.\n     extTA2J\n      P,P,t \\<turnstile> \\<langle>e,(shr s, xs)\\<rangle> -ta\\<rightarrow>\n                         \\<langle>e',s'\\<rangle>\n  \\<not> final_expr x\n  x = (e, xs)", "show \"\\<exists>ta x' m'. mred P t (x, shr s) ta (x', m')\""], ["proof (prove)\nusing this:\n  \\<not> final e \\<Longrightarrow>\n  \\<exists>e' s' ta.\n     extTA2J\n      P,P,t \\<turnstile> \\<langle>e,(shr s, xs)\\<rangle> -ta\\<rightarrow>\n                         \\<langle>e',s'\\<rangle>\n  \\<not> final_expr x\n  x = (e, xs)\n\ngoal (1 subgoal):\n 1. \\<exists>ta x' m'. red_mthr.r_syntax P t x (shr s) ta x' m'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ta x' m'. red_mthr.r_syntax P t x (shr s) ta x' m'\n\ngoal (2 subgoals):\n 1. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 2. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 2. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "fix s t x xm ta xm'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 2. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "assume \"s \\<in> ?wf_state\"\n    and \"thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\"\n    and \"mred P t xm ta xm'\"\n    and \"Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or> WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\""], ["proof (state)\nthis:\n  s \\<in> red_mthr.wset_Suspend_ok P\n           ({s. sync_es_ok (thr s) (shr s) \\<and>\n                lock_ok (locks s) (thr s)} \\<inter>\n            {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n            {s. def_ass_ts_ok (thr s) (shr s)})\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  (case xm of\n   (x, xa) \\<Rightarrow>\n     (case x of\n      (e, l) \\<Rightarrow>\n        \\<lambda>h ta ((e', l'), h').\n           extTA2J\n            P,P,t \\<turnstile> \\<langle>e,(h, l)\\<rangle> -ta\\<rightarrow>\n                               \\<langle>e',(h', l')\\<rangle>)\n      xa)\n   ta xm'\n  Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n  WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>s t x xm ta xm'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        (case xm of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, l) \\<Rightarrow>\n              \\<lambda>h ta ((e', l'), h').\n                 extTA2J\n                  P,P,t \\<turnstile> \\<langle>e,\n(h, l)\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',(h', l')\\<rangle>)\n            xa)\n         ta xm';\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_waits ta = {}\n 2. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "thus \"collect_waits ta = {}\""], ["proof (prove)\nusing this:\n  s \\<in> red_mthr.wset_Suspend_ok P\n           ({s. sync_es_ok (thr s) (shr s) \\<and>\n                lock_ok (locks s) (thr s)} \\<inter>\n            {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n            {s. def_ass_ts_ok (thr s) (shr s)})\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  (case xm of\n   (x, xa) \\<Rightarrow>\n     (case x of\n      (e, l) \\<Rightarrow>\n        \\<lambda>h ta ((e', l'), h').\n           extTA2J\n            P,P,t \\<turnstile> \\<langle>e,(h, l)\\<rangle> -ta\\<rightarrow>\n                               \\<langle>e',(h', l')\\<rangle>)\n      xa)\n   ta xm'\n  Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n  WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\n\ngoal (1 subgoal):\n 1. collect_waits ta = {}", "by(auto dest: red_ta_Wakeup_no_Join_no_Lock_no_Interrupt simp: split_beta)"], ["proof (state)\nthis:\n  collect_waits ta = {}\n\ngoal (1 subgoal):\n 1. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "fix s t x ta x' m'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "assume \"s \\<in> ?wf_state\"\n    and \"thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\"\n    and \"mred P t (x, shr s) ta (x', m')\""], ["proof (state)\nthis:\n  s \\<in> red_mthr.wset_Suspend_ok P\n           ({s. sync_es_ok (thr s) (shr s) \\<and>\n                lock_ok (locks s) (thr s)} \\<inter>\n            {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n            {s. def_ass_ts_ok (thr s) (shr s)})\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  red_mthr.r_syntax P t x (shr s) ta x' m'\n\ngoal (1 subgoal):\n 1. \\<And>s t x ta x' m'.\n       \\<lbrakk>s \\<in> red_mthr.wset_Suspend_ok P\n                         ({s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)});\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        red_mthr.r_syntax P t x (shr s) ta x' m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. red_mthr.actions_ok s' t ta", "thus \"\\<exists>s'. red_mthr.actions_ok s' t ta\""], ["proof (prove)\nusing this:\n  s \\<in> red_mthr.wset_Suspend_ok P\n           ({s. sync_es_ok (thr s) (shr s) \\<and>\n                lock_ok (locks s) (thr s)} \\<inter>\n            {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n            {s. def_ass_ts_ok (thr s) (shr s)})\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  red_mthr.r_syntax P t x (shr s) ta x' m'\n\ngoal (1 subgoal):\n 1. \\<exists>s'. red_mthr.actions_ok s' t ta", "by(fastforce simp add: split_beta dest!: red_ta_satisfiable)"], ["proof (state)\nthis:\n  \\<exists>s'. red_mthr.actions_ok s' t ta\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma redT_progress_deadlock:\n  assumes wf: \"wf_J_prog P\"\n  and wf_start: \"wf_start_state P C M vs\"\n  and Red: \"P \\<turnstile> J_start_state P C M vs -\\<triangleright>ttas\\<rightarrow>* s\"\n  and ndead: \"\\<not> red_mthr.deadlock P s\"\n  shows \"\\<exists>t' ta' s'. P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow> s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (mredT_syntax1 P s t' ta')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (mredT_syntax1 P s t' ta')", "let ?wf_state = \"red_mthr.wset_Suspend_ok P ({s. sync_es_ok (thr s) (shr s) \\<and> lock_ok (locks s) (thr s)} \\<inter> {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter> {s. def_ass_ts_ok (thr s) (shr s)})\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (mredT_syntax1 P s t' ta')", "interpret red_mthr: progress\n    final_expr \"mred P\" convert_RA ?wf_state"], ["proof (prove)\ngoal (1 subgoal):\n 1. progress final_expr\n     (\\<lambda>t ((e, l), h) ta ((e', l'), h').\n         extTA2J\n          P,P,t \\<turnstile> \\<langle>e,(h, l)\\<rangle> -ta\\<rightarrow>\n                             \\<langle>e',(h', l')\\<rangle>)\n     (red_mthr.wset_Suspend_ok P\n       ({s. sync_es_ok (thr s) (shr s) \\<and>\n            lock_ok (locks s) (thr s)} \\<inter>\n        {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n        {s. def_ass_ts_ok (thr s) (shr s)}))", "using wf"], ["proof (prove)\nusing this:\n  wf_J_prog P\n\ngoal (1 subgoal):\n 1. progress final_expr\n     (\\<lambda>t ((e, l), h) ta ((e', l'), h').\n         extTA2J\n          P,P,t \\<turnstile> \\<langle>e,(h, l)\\<rangle> -ta\\<rightarrow>\n                             \\<langle>e',(h', l')\\<rangle>)\n     (red_mthr.wset_Suspend_ok P\n       ({s. sync_es_ok (thr s) (shr s) \\<and>\n            lock_ok (locks s) (thr s)} \\<inter>\n        {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n        {s. def_ass_ts_ok (thr s) (shr s)}))", "by(rule wf_progress)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (mredT_syntax1 P s t' ta')", "from wf_start"], ["proof (chain)\npicking this:\n  wf_start_state P C M vs", "obtain Ts T pns body D \n    where start: \"start_heap_ok\" \"P \\<turnstile> C sees M:Ts\\<rightarrow>T = \\<lfloor>(pns, body)\\<rfloor> in D\" \"P,start_heap \\<turnstile> vs [:\\<le>] Ts\""], ["proof (prove)\nusing this:\n  wf_start_state P C M vs\n\ngoal (1 subgoal):\n 1. (\\<And>Ts T pns body D.\n        \\<lbrakk>start_heap_ok;\n         P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                         body)\\<rfloor> in D;\n         P,start_heap \\<turnstile> vs [:\\<le>] Ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases) auto"], ["proof (state)\nthis:\n  start_heap_ok\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                  body)\\<rfloor> in D\n  P,start_heap \\<turnstile> vs [:\\<le>] Ts\n\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (mredT_syntax1 P s t' ta')", "from start"], ["proof (chain)\npicking this:\n  start_heap_ok\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                  body)\\<rfloor> in D\n  P,start_heap \\<turnstile> vs [:\\<le>] Ts", "have len: \"length Ts = length vs\""], ["proof (prove)\nusing this:\n  start_heap_ok\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                  body)\\<rfloor> in D\n  P,start_heap \\<turnstile> vs [:\\<le>] Ts\n\ngoal (1 subgoal):\n 1. length Ts = length vs", "by(auto dest: list_all2_lengthD)"], ["proof (state)\nthis:\n  length Ts = length vs\n\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (mredT_syntax1 P s t' ta')", "have \"invariant3p (mredT P) ?wf_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant3p (mredT P)\n     (red_mthr.wset_Suspend_ok P\n       ({s. sync_es_ok (thr s) (shr s) \\<and>\n            lock_ok (locks s) (thr s)} \\<inter>\n        {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n        {s. def_ass_ts_ok (thr s) (shr s)}))", "by(rule red_mthr.invariant3p_wset_Suspend_ok) (intro invariant3p_IntI invariant3p_sync_es_ok_lock_ok[OF wf] lifting_inv.invariant3p_ts_inv[OF lifting_inv_sconf_subject_ok[OF wf]] lifting_wf.invariant3p_ts_ok[OF lifting_wf_def_ass[OF wf]])"], ["proof (state)\nthis:\n  invariant3p (mredT P)\n   (red_mthr.wset_Suspend_ok P\n     ({s. sync_es_ok (thr s) (shr s) \\<and>\n          lock_ok (locks s) (thr s)} \\<inter>\n      {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n      {s. def_ass_ts_ok (thr s) (shr s)}))\n\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (mredT_syntax1 P s t' ta')", "moreover"], ["proof (state)\nthis:\n  invariant3p (mredT P)\n   (red_mthr.wset_Suspend_ok P\n     ({s. sync_es_ok (thr s) (shr s) \\<and>\n          lock_ok (locks s) (thr s)} \\<inter>\n      {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n      {s. def_ass_ts_ok (thr s) (shr s)}))\n\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (mredT_syntax1 P s t' ta')", "note Red"], ["proof (state)\nthis:\n  P \\<turnstile> start_state J_local_start P C M\n                  vs -\\<triangleright>ttas\\<rightarrow>* s\n\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (mredT_syntax1 P s t' ta')", "moreover"], ["proof (state)\nthis:\n  P \\<turnstile> start_state J_local_start P C M\n                  vs -\\<triangleright>ttas\\<rightarrow>* s\n\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (mredT_syntax1 P s t' ta')", "have start': \"J_start_state P C M vs \\<in> ?wf_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. start_state J_local_start P C M vs\n    \\<in> red_mthr.wset_Suspend_ok P\n           ({s. sync_es_ok (thr s) (shr s) \\<and>\n                lock_ok (locks s) (thr s)} \\<inter>\n            {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n            {s. def_ass_ts_ok (thr s) (shr s)})", "apply(rule red_mthr.wset_Suspend_okI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. start_state J_local_start P C M vs\n    \\<in> {s. sync_es_ok (thr s) (shr s) \\<and>\n              lock_ok (locks s) (thr s)} \\<inter>\n          {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n          {s. def_ass_ts_ok (thr s) (shr s)}\n 2. \\<And>t w.\n       wset (start_state J_local_start P C M vs) t =\n       \\<lfloor>w\\<rfloor> \\<Longrightarrow>\n       \\<exists>s0\\<in>{s. sync_es_ok (thr s) (shr s) \\<and>\n                           lock_ok (locks s) (thr s)} \\<inter>\n                       {s. \\<exists>Es.\n                              sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n                       {s. def_ass_ts_ok (thr s) (shr s)}.\n          \\<exists>s1\\<in>{s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)}.\n             \\<exists>ttas x x0 ta w' ln' ln''.\n                P \\<turnstile> s0 -t\\<triangleright>ta\\<rightarrow> s1 \\<and>\n                P \\<turnstile> s1 -\\<triangleright>ttas\\<rightarrow>* start_state\n                                 J_local_start P C M vs \\<and>\n                thr s0 t = \\<lfloor>(x0, no_wait_locks)\\<rfloor> \\<and>\n                red_mthr.r_syntax P t x0 (shr s0) ta x (shr s1) \\<and>\n                Suspend w'\n                \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n                red_mthr.actions_ok s0 t ta \\<and>\n                thr s1 t = \\<lfloor>(x, ln')\\<rfloor> \\<and>\n                thr (start_state J_local_start P C M vs) t =\n                \\<lfloor>(x, ln'')\\<rfloor>", "apply(blast intro: sconf_type_ts_ok_J_start_state sync_es_ok_J_start_state lock_ok_J_start_state def_ass_ts_ok_J_start_state start wf len len[symmetric] wf_start)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t w.\n       wset (start_state J_local_start P C M vs) t =\n       \\<lfloor>w\\<rfloor> \\<Longrightarrow>\n       \\<exists>s0\\<in>{s. sync_es_ok (thr s) (shr s) \\<and>\n                           lock_ok (locks s) (thr s)} \\<inter>\n                       {s. \\<exists>Es.\n                              sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n                       {s. def_ass_ts_ok (thr s) (shr s)}.\n          \\<exists>s1\\<in>{s. sync_es_ok (thr s) (shr s) \\<and>\n                              lock_ok (locks s) (thr s)} \\<inter>\n                          {s. \\<exists>Es.\n                                 sconf_type_ts_ok Es (thr s)\n                                  (shr s)} \\<inter>\n                          {s. def_ass_ts_ok (thr s) (shr s)}.\n             \\<exists>ttas x x0 ta w' ln' ln''.\n                P \\<turnstile> s0 -t\\<triangleright>ta\\<rightarrow> s1 \\<and>\n                P \\<turnstile> s1 -\\<triangleright>ttas\\<rightarrow>* start_state\n                                 J_local_start P C M vs \\<and>\n                thr s0 t = \\<lfloor>(x0, no_wait_locks)\\<rfloor> \\<and>\n                red_mthr.r_syntax P t x0 (shr s0) ta x (shr s1) \\<and>\n                Suspend w'\n                \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n                red_mthr.actions_ok s0 t ta \\<and>\n                thr s1 t = \\<lfloor>(x, ln')\\<rfloor> \\<and>\n                thr (start_state J_local_start P C M vs) t =\n                \\<lfloor>(x, ln'')\\<rfloor>", "apply(simp add: start_state_def split_beta)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  start_state J_local_start P C M vs\n  \\<in> red_mthr.wset_Suspend_ok P\n         ({s. sync_es_ok (thr s) (shr s) \\<and>\n              lock_ok (locks s) (thr s)} \\<inter>\n          {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n          {s. def_ass_ts_ok (thr s) (shr s)})\n\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (mredT_syntax1 P s t' ta')", "ultimately"], ["proof (chain)\npicking this:\n  invariant3p (mredT P)\n   (red_mthr.wset_Suspend_ok P\n     ({s. sync_es_ok (thr s) (shr s) \\<and>\n          lock_ok (locks s) (thr s)} \\<inter>\n      {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n      {s. def_ass_ts_ok (thr s) (shr s)}))\n  P \\<turnstile> start_state J_local_start P C M\n                  vs -\\<triangleright>ttas\\<rightarrow>* s\n  start_state J_local_start P C M vs\n  \\<in> red_mthr.wset_Suspend_ok P\n         ({s. sync_es_ok (thr s) (shr s) \\<and>\n              lock_ok (locks s) (thr s)} \\<inter>\n          {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n          {s. def_ass_ts_ok (thr s) (shr s)})", "have \"s \\<in> ?wf_state\""], ["proof (prove)\nusing this:\n  invariant3p (mredT P)\n   (red_mthr.wset_Suspend_ok P\n     ({s. sync_es_ok (thr s) (shr s) \\<and>\n          lock_ok (locks s) (thr s)} \\<inter>\n      {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n      {s. def_ass_ts_ok (thr s) (shr s)}))\n  P \\<turnstile> start_state J_local_start P C M\n                  vs -\\<triangleright>ttas\\<rightarrow>* s\n  start_state J_local_start P C M vs\n  \\<in> red_mthr.wset_Suspend_ok P\n         ({s. sync_es_ok (thr s) (shr s) \\<and>\n              lock_ok (locks s) (thr s)} \\<inter>\n          {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n          {s. def_ass_ts_ok (thr s) (shr s)})\n\ngoal (1 subgoal):\n 1. s \\<in> red_mthr.wset_Suspend_ok P\n             ({s. sync_es_ok (thr s) (shr s) \\<and>\n                  lock_ok (locks s) (thr s)} \\<inter>\n              {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n              {s. def_ass_ts_ok (thr s) (shr s)})", "unfolding red_mthr.RedT_def"], ["proof (prove)\nusing this:\n  invariant3p (mredT P)\n   (red_mthr.wset_Suspend_ok P\n     ({s. sync_es_ok (thr s) (shr s) \\<and>\n          lock_ok (locks s) (thr s)} \\<inter>\n      {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n      {s. def_ass_ts_ok (thr s) (shr s)}))\n  rtrancl3p (mredT P) (start_state J_local_start P C M vs) ttas s\n  start_state J_local_start P C M vs\n  \\<in> red_mthr.wset_Suspend_ok P\n         ({s. sync_es_ok (thr s) (shr s) \\<and>\n              lock_ok (locks s) (thr s)} \\<inter>\n          {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n          {s. def_ass_ts_ok (thr s) (shr s)})\n\ngoal (1 subgoal):\n 1. s \\<in> red_mthr.wset_Suspend_ok P\n             ({s. sync_es_ok (thr s) (shr s) \\<and>\n                  lock_ok (locks s) (thr s)} \\<inter>\n              {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n              {s. def_ass_ts_ok (thr s) (shr s)})", "by(rule invariant3p_rtrancl3p)"], ["proof (state)\nthis:\n  s \\<in> red_mthr.wset_Suspend_ok P\n           ({s. sync_es_ok (thr s) (shr s) \\<and>\n                lock_ok (locks s) (thr s)} \\<inter>\n            {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n            {s. def_ass_ts_ok (thr s) (shr s)})\n\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (mredT_syntax1 P s t' ta')", "thus ?thesis"], ["proof (prove)\nusing this:\n  s \\<in> red_mthr.wset_Suspend_ok P\n           ({s. sync_es_ok (thr s) (shr s) \\<and>\n                lock_ok (locks s) (thr s)} \\<inter>\n            {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n            {s. def_ass_ts_ok (thr s) (shr s)})\n\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (mredT_syntax1 P s t' ta')", "using ndead"], ["proof (prove)\nusing this:\n  s \\<in> red_mthr.wset_Suspend_ok P\n           ({s. sync_es_ok (thr s) (shr s) \\<and>\n                lock_ok (locks s) (thr s)} \\<inter>\n            {s. \\<exists>Es. sconf_type_ts_ok Es (thr s) (shr s)} \\<inter>\n            {s. def_ass_ts_ok (thr s) (shr s)})\n  \\<not> red_mthr.deadlock P s\n\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (mredT_syntax1 P s t' ta')", "by(rule red_mthr.redT_progress)"], ["proof (state)\nthis:\n  \\<exists>t' ta'. Ex (mredT_syntax1 P s t' ta')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma redT_progress_deadlocked:\n  assumes wf: \"wf_J_prog P\" \n  and wf_start: \"wf_start_state P C M vs\"\n  and Red: \"P \\<turnstile> J_start_state P C M vs -\\<triangleright>ttas\\<rightarrow>* s\"\n  and ndead:  \"red_mthr.not_final_thread s t\" \"\\<not> t \\<in> red_mthr.deadlocked P s\"\n  shows \"\\<exists>t' ta' s'. P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow> s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (mredT_syntax1 P s t' ta')", "using wf wf_start Red"], ["proof (prove)\nusing this:\n  wf_J_prog P\n  wf_start_state P C M vs\n  P \\<turnstile> start_state J_local_start P C M\n                  vs -\\<triangleright>ttas\\<rightarrow>* s\n\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (mredT_syntax1 P s t' ta')", "proof(rule redT_progress_deadlock)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> red_mthr.deadlock P s", "from ndead"], ["proof (chain)\npicking this:\n  red_mthr.not_final_thread s t\n  t \\<notin> red_mthr.deadlocked P s", "show \"\\<not> red_mthr.deadlock P s\""], ["proof (prove)\nusing this:\n  red_mthr.not_final_thread s t\n  t \\<notin> red_mthr.deadlocked P s\n\ngoal (1 subgoal):\n 1. \\<not> red_mthr.deadlock P s", "unfolding red_mthr.deadlock_eq_deadlocked'"], ["proof (prove)\nusing this:\n  red_mthr.not_final_thread s t\n  t \\<notin> red_mthr.deadlocked P s\n\ngoal (1 subgoal):\n 1. \\<not> red_mthr.deadlocked' P s", "by(auto simp add: red_mthr.deadlocked'_def)"], ["proof (state)\nthis:\n  \\<not> red_mthr.deadlock P s\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Type safety proof\\<close>"], ["", "theorem TypeSafetyT:\n  fixes C and M and ttas and Es\n  defines \"Es  == J_sconf_type_ET_start P C M\"\n  and     \"Es' == upd_invs Es sconf_type_ok (concat (map (thr_a \\<circ> snd) ttas))\"\n  assumes wf: \"wf_J_prog P\"\n  and start_wf: \"wf_start_state P C M vs\"\n  and RedT: \"P \\<turnstile> J_start_state P C M vs -\\<triangleright>ttas\\<rightarrow>* s'\"\n  and nored: \"\\<not> (\\<exists>t ta s''. P \\<turnstile> s' -t\\<triangleright>ta\\<rightarrow> s'')\"\n  shows \"thread_conf P (thr s') (shr s')\"\n  and \"thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n       (\\<exists>v. e' = Val v \\<and> (\\<exists>E T. Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and> P,shr s' \\<turnstile> v :\\<le> T) \\<and> ln' = no_wait_locks)\n       \\<or> (\\<exists>a C. e' = Throw a \\<and> typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and> ln' = no_wait_locks)\n       \\<or> (t \\<in> red_mthr.deadlocked P s' \\<and> (\\<exists>E T. Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and> (\\<exists>T'. P,E,shr s' \\<turnstile> e' : T' \\<and> P \\<turnstile> T' \\<le> T)))\"\n     (is \"_ \\<Longrightarrow> ?thesis2\")\n  and \"Es \\<subseteq>\\<^sub>m Es'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thread_conf P (thr s') (shr s') &&&\n    (thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n     (\\<exists>v.\n         e' = Val v \\<and>\n         (\\<exists>E T.\n             Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n             P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n         ln' = no_wait_locks) \\<or>\n     (\\<exists>a C.\n         e' = Throw a \\<and>\n         typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n         P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n         ln' = no_wait_locks) \\<or>\n     t \\<in> red_mthr.deadlocked P s' \\<and>\n     (\\<exists>E T.\n         Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n         (\\<exists>T'.\n             P,E,shr s' \\<turnstile> e' : T' \\<and>\n             P \\<turnstile> T' \\<le> T))) &&&\n    Es \\<subseteq>\\<^sub>m Es'", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. thread_conf P (thr s') (shr s')\n 2. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))\n 3. Es \\<subseteq>\\<^sub>m Es'", "from start_wf"], ["proof (chain)\npicking this:\n  wf_start_state P C M vs", "obtain Ts T pns body D\n    where start_heap: \"start_heap_ok\"\n    and sees: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T = \\<lfloor>(pns, body)\\<rfloor> in D\"\n    and conf: \"P,start_heap \\<turnstile> vs [:\\<le>] Ts\""], ["proof (prove)\nusing this:\n  wf_start_state P C M vs\n\ngoal (1 subgoal):\n 1. (\\<And>Ts T pns body D.\n        \\<lbrakk>start_heap_ok;\n         P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                         body)\\<rfloor> in D;\n         P,start_heap \\<turnstile> vs [:\\<le>] Ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  start_heap_ok\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                  body)\\<rfloor> in D\n  P,start_heap \\<turnstile> vs [:\\<le>] Ts\n\ngoal (3 subgoals):\n 1. thread_conf P (thr s') (shr s')\n 2. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))\n 3. Es \\<subseteq>\\<^sub>m Es'", "from RedT"], ["proof (chain)\npicking this:\n  P \\<turnstile> start_state J_local_start P C M\n                  vs -\\<triangleright>ttas\\<rightarrow>* s'", "show \"thread_conf P (thr s') (shr s')\""], ["proof (prove)\nusing this:\n  P \\<turnstile> start_state J_local_start P C M\n                  vs -\\<triangleright>ttas\\<rightarrow>* s'\n\ngoal (1 subgoal):\n 1. thread_conf P (thr s') (shr s')", "by(rule red_tconf.RedT_preserves)(rule thread_conf_start_state[OF start_heap wf_prog_wf_syscls[OF wf]])"], ["proof (state)\nthis:\n  thread_conf P (thr s') (shr s')\n\ngoal (2 subgoals):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))\n 2. Es \\<subseteq>\\<^sub>m Es'", "show \"Es \\<subseteq>\\<^sub>m Es'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Es \\<subseteq>\\<^sub>m Es'", "using RedT ts_inv_ok_J_sconf_type_ET_start"], ["proof (prove)\nusing this:\n  P \\<turnstile> start_state J_local_start P C M\n                  vs -\\<triangleright>ttas\\<rightarrow>* s'\n  ts_inv_ok (thr (start_state J_local_start P ?C ?M ?vs))\n   (J_sconf_type_ET_start P ?C ?M)\n\ngoal (1 subgoal):\n 1. Es \\<subseteq>\\<^sub>m Es'", "unfolding Es'_def Es_def"], ["proof (prove)\nusing this:\n  P \\<turnstile> start_state J_local_start P C M\n                  vs -\\<triangleright>ttas\\<rightarrow>* s'\n  ts_inv_ok (thr (start_state J_local_start P ?C ?M ?vs))\n   (J_sconf_type_ET_start P ?C ?M)\n\ngoal (1 subgoal):\n 1. J_sconf_type_ET_start P C M \\<subseteq>\\<^sub>m\n    upd_invs (J_sconf_type_ET_start P C M) sconf_type_ok\n     (concat (map (thr_a \\<circ> snd) ttas))", "by(rule red_mthr.RedT_upd_inv_ext)"], ["proof (state)\nthis:\n  Es \\<subseteq>\\<^sub>m Es'\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "assume \"thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor>\""], ["proof (state)\nthis:\n  thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor>\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "moreover"], ["proof (state)\nthis:\n  thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor>\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "obtain ls' ts' m' ws' is' where s' [simp]: \"s' = (ls', (ts', m'), ws', is')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ls' ts' m' ws' is'.\n        s' = (ls', (ts', m'), ws', is') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases s') fastforce"], ["proof (state)\nthis:\n  s' = (ls', (ts', m'), ws', is')\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "ultimately"], ["proof (chain)\npicking this:\n  thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor>\n  s' = (ls', (ts', m'), ws', is')", "have es't: \"ts' t = \\<lfloor>((e', x'), ln')\\<rfloor>\""], ["proof (prove)\nusing this:\n  thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor>\n  s' = (ls', (ts', m'), ws', is')\n\ngoal (1 subgoal):\n 1. ts' t = \\<lfloor>((e', x'), ln')\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  ts' t = \\<lfloor>((e', x'), ln')\\<rfloor>\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "from wf"], ["proof (chain)\npicking this:\n  wf_J_prog P", "have wwf: \"wwf_J_prog P\""], ["proof (prove)\nusing this:\n  wf_J_prog P\n\ngoal (1 subgoal):\n 1. wwf_J_prog P", "by(rule wf_prog_wwf_prog)"], ["proof (state)\nthis:\n  wwf_J_prog P\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "from conf"], ["proof (chain)\npicking this:\n  P,start_heap \\<turnstile> vs [:\\<le>] Ts", "have len: \"length vs = length Ts\""], ["proof (prove)\nusing this:\n  P,start_heap \\<turnstile> vs [:\\<le>] Ts\n\ngoal (1 subgoal):\n 1. length vs = length Ts", "by(rule list_all2_lengthD)"], ["proof (state)\nthis:\n  length vs = length Ts\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "from RedT def_ass_ts_ok_J_start_state[OF wf sees len]"], ["proof (chain)\npicking this:\n  P \\<turnstile> start_state J_local_start P C M\n                  vs -\\<triangleright>ttas\\<rightarrow>* s'\n  def_ass_ts_ok (thr (start_state J_local_start P C M vs)) ?h", "have defass': \"def_ass_ts_ok ts' m'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> start_state J_local_start P C M\n                  vs -\\<triangleright>ttas\\<rightarrow>* s'\n  def_ass_ts_ok (thr (start_state J_local_start P C M vs)) ?h\n\ngoal (1 subgoal):\n 1. def_ass_ts_ok ts' m'", "by(fastforce dest: lifting_wf.RedT_preserves[OF lifting_wf_def_ass, OF wf])"], ["proof (state)\nthis:\n  def_ass_ts_ok ts' m'\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "from RedT sync_es_ok_J_start_state[OF wf sees len[symmetric]] lock_ok_J_start_state[OF wf sees len[symmetric]]"], ["proof (chain)\npicking this:\n  P \\<turnstile> start_state J_local_start P C M\n                  vs -\\<triangleright>ttas\\<rightarrow>* s'\n  sync_es_ok (thr (start_state J_local_start P C M vs)) ?m\n  lock_ok (locks (start_state J_local_start P C M vs))\n   (thr (start_state J_local_start P C M vs))", "have lock': \"lock_ok ls' ts'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> start_state J_local_start P C M\n                  vs -\\<triangleright>ttas\\<rightarrow>* s'\n  sync_es_ok (thr (start_state J_local_start P C M vs)) ?m\n  lock_ok (locks (start_state J_local_start P C M vs))\n   (thr (start_state J_local_start P C M vs))\n\ngoal (1 subgoal):\n 1. lock_ok ls' ts'", "by (fastforce dest: RedT_preserves_lock_ok[OF wf])"], ["proof (state)\nthis:\n  lock_ok ls' ts'\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "from RedT sync_es_ok_J_start_state[OF wf sees len[symmetric]]"], ["proof (chain)\npicking this:\n  P \\<turnstile> start_state J_local_start P C M\n                  vs -\\<triangleright>ttas\\<rightarrow>* s'\n  sync_es_ok (thr (start_state J_local_start P C M vs)) ?m", "have addr': \"sync_es_ok ts' m'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> start_state J_local_start P C M\n                  vs -\\<triangleright>ttas\\<rightarrow>* s'\n  sync_es_ok (thr (start_state J_local_start P C M vs)) ?m\n\ngoal (1 subgoal):\n 1. sync_es_ok ts' m'", "by(fastforce dest: RedT_preserves_sync_ok[OF wf])"], ["proof (state)\nthis:\n  sync_es_ok ts' m'\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "from RedT sconf_type_ts_ok_J_start_state[OF wf start_wf]"], ["proof (chain)\npicking this:\n  P \\<turnstile> start_state J_local_start P C M\n                  vs -\\<triangleright>ttas\\<rightarrow>* s'\n  sconf_type_ts_ok (J_sconf_type_ET_start P C M)\n   (thr (start_state J_local_start P C M vs))\n   (shr (start_state J_local_start P C M vs))", "have sconf_subject': \"sconf_type_ts_ok Es' ts' m'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> start_state J_local_start P C M\n                  vs -\\<triangleright>ttas\\<rightarrow>* s'\n  sconf_type_ts_ok (J_sconf_type_ET_start P C M)\n   (thr (start_state J_local_start P C M vs))\n   (shr (start_state J_local_start P C M vs))\n\ngoal (1 subgoal):\n 1. sconf_type_ts_ok Es' ts' m'", "unfolding Es'_def Es_def"], ["proof (prove)\nusing this:\n  P \\<turnstile> start_state J_local_start P C M\n                  vs -\\<triangleright>ttas\\<rightarrow>* s'\n  sconf_type_ts_ok (J_sconf_type_ET_start P C M)\n   (thr (start_state J_local_start P C M vs))\n   (shr (start_state J_local_start P C M vs))\n\ngoal (1 subgoal):\n 1. sconf_type_ts_ok\n     (upd_invs (J_sconf_type_ET_start P C M) sconf_type_ok\n       (concat (map (thr_a \\<circ> snd) ttas)))\n     ts' m'", "by(fastforce dest: lifting_inv.RedT_invariant[OF lifting_inv_sconf_subject_ok, OF wf] intro: thread_conf_start_state[OF _ wf_prog_wf_syscls[OF wf]])"], ["proof (state)\nthis:\n  sconf_type_ts_ok Es' ts' m'\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "with es't"], ["proof (chain)\npicking this:\n  ts' t = \\<lfloor>((e', x'), ln')\\<rfloor>\n  sconf_type_ts_ok Es' ts' m'", "obtain E T where ET: \"Es' t = \\<lfloor>(E, T)\\<rfloor>\" \n    and \"sconf_type_ok (E, T) t (e', x') m'\""], ["proof (prove)\nusing this:\n  ts' t = \\<lfloor>((e', x'), ln')\\<rfloor>\n  sconf_type_ts_ok Es' ts' m'\n\ngoal (1 subgoal):\n 1. (\\<And>E T.\n        \\<lbrakk>Es' t = \\<lfloor>(E, T)\\<rfloor>;\n         sconf_type_ok (E, T) t (e', x') m'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest!: ts_invD)"], ["proof (state)\nthis:\n  Es' t = \\<lfloor>(E, T)\\<rfloor>\n  sconf_type_ok (E, T) t (e', x') m'\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "{"], ["proof (state)\nthis:\n  Es' t = \\<lfloor>(E, T)\\<rfloor>\n  sconf_type_ok (E, T) t (e', x') m'\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "assume \"final e'\""], ["proof (state)\nthis:\n  final e'\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "have \"ln' = no_wait_locks\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ln' = no_wait_locks", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. ln' \\<noteq> no_wait_locks \\<Longrightarrow> False", "assume \"ln' \\<noteq> no_wait_locks\""], ["proof (state)\nthis:\n  ln' \\<noteq> no_wait_locks\n\ngoal (1 subgoal):\n 1. ln' \\<noteq> no_wait_locks \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  ln' \\<noteq> no_wait_locks", "obtain l where \"ln' $ l > 0\""], ["proof (prove)\nusing this:\n  ln' \\<noteq> no_wait_locks\n\ngoal (1 subgoal):\n 1. (\\<And>l. 0 < ln' $ l \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by(auto simp add: neq_no_wait_locks_conv)"], ["proof (state)\nthis:\n  0 < ln' $ l\n\ngoal (1 subgoal):\n 1. ln' \\<noteq> no_wait_locks \\<Longrightarrow> False", "from lock' es't"], ["proof (chain)\npicking this:\n  lock_ok ls' ts'\n  ts' t = \\<lfloor>((e', x'), ln')\\<rfloor>", "have \"has_locks (ls' $ l) t + ln' $ l = expr_locks e' l\""], ["proof (prove)\nusing this:\n  lock_ok ls' ts'\n  ts' t = \\<lfloor>((e', x'), ln')\\<rfloor>\n\ngoal (1 subgoal):\n 1. has_locks (ls' $ l) t + ln' $ l = expr_locks e' l", "by(auto dest: lock_okD2)"], ["proof (state)\nthis:\n  has_locks (ls' $ l) t + ln' $ l = expr_locks e' l\n\ngoal (1 subgoal):\n 1. ln' \\<noteq> no_wait_locks \\<Longrightarrow> False", "with \\<open>ln' $ l > 0\\<close>"], ["proof (chain)\npicking this:\n  0 < ln' $ l\n  has_locks (ls' $ l) t + ln' $ l = expr_locks e' l", "have \"expr_locks e' l > 0\""], ["proof (prove)\nusing this:\n  0 < ln' $ l\n  has_locks (ls' $ l) t + ln' $ l = expr_locks e' l\n\ngoal (1 subgoal):\n 1. 0 < expr_locks e' l", "by simp"], ["proof (state)\nthis:\n  0 < expr_locks e' l\n\ngoal (1 subgoal):\n 1. ln' \\<noteq> no_wait_locks \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  0 < expr_locks e' l\n\ngoal (1 subgoal):\n 1. ln' \\<noteq> no_wait_locks \\<Longrightarrow> False", "from \\<open>final e'\\<close>"], ["proof (chain)\npicking this:\n  final e'", "have \"expr_locks e' l = 0\""], ["proof (prove)\nusing this:\n  final e'\n\ngoal (1 subgoal):\n 1. expr_locks e' l = 0", "by(rule final_locks)"], ["proof (state)\nthis:\n  expr_locks e' l = 0\n\ngoal (1 subgoal):\n 1. ln' \\<noteq> no_wait_locks \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  0 < expr_locks e' l\n  expr_locks e' l = 0", "show False"], ["proof (prove)\nusing this:\n  0 < expr_locks e' l\n  expr_locks e' l = 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ln' = no_wait_locks\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "}"], ["proof (state)\nthis:\n  final e' \\<Longrightarrow> ln' = no_wait_locks\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "note ln' = this"], ["proof (state)\nthis:\n  final e' \\<Longrightarrow> ln' = no_wait_locks\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "{"], ["proof (state)\nthis:\n  final e' \\<Longrightarrow> ln' = no_wait_locks\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "assume \"\\<exists>v. e' = Val v\""], ["proof (state)\nthis:\n  \\<exists>v. e' = Val v\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "then"], ["proof (chain)\npicking this:\n  \\<exists>v. e' = Val v", "obtain v where v: \"e' = Val v\""], ["proof (prove)\nusing this:\n  \\<exists>v. e' = Val v\n\ngoal (1 subgoal):\n 1. (\\<And>v. e' = Val v \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  e' = Val v\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "with sconf_subject' ET es't"], ["proof (chain)\npicking this:\n  sconf_type_ts_ok Es' ts' m'\n  Es' t = \\<lfloor>(E, T)\\<rfloor>\n  ts' t = \\<lfloor>((e', x'), ln')\\<rfloor>\n  e' = Val v", "have \"P,m' \\<turnstile> v :\\<le> T\""], ["proof (prove)\nusing this:\n  sconf_type_ts_ok Es' ts' m'\n  Es' t = \\<lfloor>(E, T)\\<rfloor>\n  ts' t = \\<lfloor>((e', x'), ln')\\<rfloor>\n  e' = Val v\n\ngoal (1 subgoal):\n 1. P,m' \\<turnstile> v :\\<le> T", "by(auto dest: ts_invD simp add: type_ok_def sconf_type_ok_def conf_def)"], ["proof (state)\nthis:\n  P,m' \\<turnstile> v :\\<le> T\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "moreover"], ["proof (state)\nthis:\n  P,m' \\<turnstile> v :\\<le> T\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "from v ln'"], ["proof (chain)\npicking this:\n  e' = Val v\n  final e' \\<Longrightarrow> ln' = no_wait_locks", "have \"ln' = no_wait_locks\""], ["proof (prove)\nusing this:\n  e' = Val v\n  final e' \\<Longrightarrow> ln' = no_wait_locks\n\ngoal (1 subgoal):\n 1. ln' = no_wait_locks", "by(auto)"], ["proof (state)\nthis:\n  ln' = no_wait_locks\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "ultimately"], ["proof (chain)\npicking this:\n  P,m' \\<turnstile> v :\\<le> T\n  ln' = no_wait_locks", "have \"\\<exists>v. e' = Val v \\<and> (\\<exists>E T. Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and> P,m' \\<turnstile> v :\\<le> T \\<and> ln' = no_wait_locks)\""], ["proof (prove)\nusing this:\n  P,m' \\<turnstile> v :\\<le> T\n  ln' = no_wait_locks\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       e' = Val v \\<and>\n       (\\<exists>E T.\n           Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n           P,m' \\<turnstile> v :\\<le> T \\<and> ln' = no_wait_locks)", "using ET v"], ["proof (prove)\nusing this:\n  P,m' \\<turnstile> v :\\<le> T\n  ln' = no_wait_locks\n  Es' t = \\<lfloor>(E, T)\\<rfloor>\n  e' = Val v\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       e' = Val v \\<and>\n       (\\<exists>E T.\n           Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n           P,m' \\<turnstile> v :\\<le> T \\<and> ln' = no_wait_locks)", "by blast"], ["proof (state)\nthis:\n  \\<exists>v.\n     e' = Val v \\<and>\n     (\\<exists>E T.\n         Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n         P,m' \\<turnstile> v :\\<le> T \\<and> ln' = no_wait_locks)\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "}"], ["proof (state)\nthis:\n  \\<exists>v. e' = Val v \\<Longrightarrow>\n  \\<exists>v.\n     e' = Val v \\<and>\n     (\\<exists>E T.\n         Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n         P,m' \\<turnstile> v :\\<le> T \\<and> ln' = no_wait_locks)\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "moreover"], ["proof (state)\nthis:\n  \\<exists>v. e' = Val v \\<Longrightarrow>\n  \\<exists>v.\n     e' = Val v \\<and>\n     (\\<exists>E T.\n         Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n         P,m' \\<turnstile> v :\\<le> T \\<and> ln' = no_wait_locks)\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "{"], ["proof (state)\nthis:\n  \\<exists>v. e' = Val v \\<Longrightarrow>\n  \\<exists>v.\n     e' = Val v \\<and>\n     (\\<exists>E T.\n         Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n         P,m' \\<turnstile> v :\\<le> T \\<and> ln' = no_wait_locks)\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "assume \"\\<exists>a. e' = Throw a\""], ["proof (state)\nthis:\n  \\<exists>a. e' = Throw a\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "then"], ["proof (chain)\npicking this:\n  \\<exists>a. e' = Throw a", "obtain a where a: \"e' = Throw a\""], ["proof (prove)\nusing this:\n  \\<exists>a. e' = Throw a\n\ngoal (1 subgoal):\n 1. (\\<And>a. e' = Throw a \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  e' = Throw a\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "with sconf_subject' ET es't"], ["proof (chain)\npicking this:\n  sconf_type_ts_ok Es' ts' m'\n  Es' t = \\<lfloor>(E, T)\\<rfloor>\n  ts' t = \\<lfloor>((e', x'), ln')\\<rfloor>\n  e' = Throw a", "have \"\\<exists>T'. P,E,m' \\<turnstile> e' : T' \\<and> P \\<turnstile> T' \\<le> T\""], ["proof (prove)\nusing this:\n  sconf_type_ts_ok Es' ts' m'\n  Es' t = \\<lfloor>(E, T)\\<rfloor>\n  ts' t = \\<lfloor>((e', x'), ln')\\<rfloor>\n  e' = Throw a\n\ngoal (1 subgoal):\n 1. \\<exists>T'.\n       P,E,m' \\<turnstile> e' : T' \\<and> P \\<turnstile> T' \\<le> T", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sconf_type_ts_ok Es' ts' m'; Es' t = \\<lfloor>(E, T)\\<rfloor>;\n     ts' t = \\<lfloor>((e', x'), ln')\\<rfloor>; e' = Throw a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T'.\n                         P,E,m' \\<turnstile> e' : T' \\<and>\n                         P \\<turnstile> T' \\<le> T", "apply(drule ts_invD, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Es' t = \\<lfloor>(E, T)\\<rfloor>;\n     ts' t = \\<lfloor>((e', x'), ln')\\<rfloor>; e' = Throw a;\n     \\<exists>i.\n        Es' t = \\<lfloor>i\\<rfloor> \\<and>\n        sconf_type_ok i t (e', x') m'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T'.\n                         P,E,m' \\<turnstile> e' : T' \\<and>\n                         P \\<turnstile> T' \\<le> T", "by(clarsimp simp add: type_ok_def sconf_type_ok_def)"], ["proof (state)\nthis:\n  \\<exists>T'. P,E,m' \\<turnstile> e' : T' \\<and> P \\<turnstile> T' \\<le> T\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "then"], ["proof (chain)\npicking this:\n  \\<exists>T'. P,E,m' \\<turnstile> e' : T' \\<and> P \\<turnstile> T' \\<le> T", "obtain T' where \"P,E,m' \\<turnstile> e' : T'\" and \"P \\<turnstile> T' \\<le> T\""], ["proof (prove)\nusing this:\n  \\<exists>T'. P,E,m' \\<turnstile> e' : T' \\<and> P \\<turnstile> T' \\<le> T\n\ngoal (1 subgoal):\n 1. (\\<And>T'.\n        \\<lbrakk>P,E,m' \\<turnstile> e' : T';\n         P \\<turnstile> T' \\<le> T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  P,E,m' \\<turnstile> e' : T'\n  P \\<turnstile> T' \\<le> T\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "with a"], ["proof (chain)\npicking this:\n  e' = Throw a\n  P,E,m' \\<turnstile> e' : T'\n  P \\<turnstile> T' \\<le> T", "have \"\\<exists>C. typeof_addr m' a = \\<lfloor>Class_type C\\<rfloor> \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* Throwable\""], ["proof (prove)\nusing this:\n  e' = Throw a\n  P,E,m' \\<turnstile> e' : T'\n  P \\<turnstile> T' \\<le> T\n\ngoal (1 subgoal):\n 1. \\<exists>C.\n       typeof_addr m' a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n       P \\<turnstile> C \\<preceq>\\<^sup>* Throwable", "by(auto simp add: widen_Class)"], ["proof (state)\nthis:\n  \\<exists>C.\n     typeof_addr m' a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n     P \\<turnstile> C \\<preceq>\\<^sup>* Throwable\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "moreover"], ["proof (state)\nthis:\n  \\<exists>C.\n     typeof_addr m' a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n     P \\<turnstile> C \\<preceq>\\<^sup>* Throwable\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "from a ln'"], ["proof (chain)\npicking this:\n  e' = Throw a\n  final e' \\<Longrightarrow> ln' = no_wait_locks", "have \"ln' = no_wait_locks\""], ["proof (prove)\nusing this:\n  e' = Throw a\n  final e' \\<Longrightarrow> ln' = no_wait_locks\n\ngoal (1 subgoal):\n 1. ln' = no_wait_locks", "by(auto)"], ["proof (state)\nthis:\n  ln' = no_wait_locks\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>C.\n     typeof_addr m' a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n     P \\<turnstile> C \\<preceq>\\<^sup>* Throwable\n  ln' = no_wait_locks", "have \"\\<exists>a C. e' = Throw a \\<and> typeof_addr m' a = \\<lfloor>Class_type C\\<rfloor> \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and> ln' = no_wait_locks\""], ["proof (prove)\nusing this:\n  \\<exists>C.\n     typeof_addr m' a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n     P \\<turnstile> C \\<preceq>\\<^sup>* Throwable\n  ln' = no_wait_locks\n\ngoal (1 subgoal):\n 1. \\<exists>a C.\n       e' = Throw a \\<and>\n       typeof_addr m' a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n       P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n       ln' = no_wait_locks", "using a"], ["proof (prove)\nusing this:\n  \\<exists>C.\n     typeof_addr m' a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n     P \\<turnstile> C \\<preceq>\\<^sup>* Throwable\n  ln' = no_wait_locks\n  e' = Throw a\n\ngoal (1 subgoal):\n 1. \\<exists>a C.\n       e' = Throw a \\<and>\n       typeof_addr m' a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n       P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n       ln' = no_wait_locks", "by blast"], ["proof (state)\nthis:\n  \\<exists>a C.\n     e' = Throw a \\<and>\n     typeof_addr m' a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n     P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and> ln' = no_wait_locks\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "}"], ["proof (state)\nthis:\n  \\<exists>a. e' = Throw a \\<Longrightarrow>\n  \\<exists>a C.\n     e' = Throw a \\<and>\n     typeof_addr m' a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n     P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and> ln' = no_wait_locks\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "moreover"], ["proof (state)\nthis:\n  \\<exists>a. e' = Throw a \\<Longrightarrow>\n  \\<exists>a C.\n     e' = Throw a \\<and>\n     typeof_addr m' a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n     P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and> ln' = no_wait_locks\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "{"], ["proof (state)\nthis:\n  \\<exists>a. e' = Throw a \\<Longrightarrow>\n  \\<exists>a C.\n     e' = Throw a \\<and>\n     typeof_addr m' a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n     P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and> ln' = no_wait_locks\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "assume nfine': \"\\<not> final e'\""], ["proof (state)\nthis:\n  \\<not> final e'\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "with es't"], ["proof (chain)\npicking this:\n  ts' t = \\<lfloor>((e', x'), ln')\\<rfloor>\n  \\<not> final e'", "have \"red_mthr.not_final_thread s' t\""], ["proof (prove)\nusing this:\n  ts' t = \\<lfloor>((e', x'), ln')\\<rfloor>\n  \\<not> final e'\n\ngoal (1 subgoal):\n 1. red_mthr.not_final_thread s' t", "by(auto intro: red_mthr.not_final_thread.intros)"], ["proof (state)\nthis:\n  red_mthr.not_final_thread s' t\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "with nored"], ["proof (chain)\npicking this:\n  \\<nexists>t ta. Ex (mredT_syntax1 P s' t ta)\n  red_mthr.not_final_thread s' t", "have \"t \\<in> red_mthr.deadlocked P s'\""], ["proof (prove)\nusing this:\n  \\<nexists>t ta. Ex (mredT_syntax1 P s' t ta)\n  red_mthr.not_final_thread s' t\n\ngoal (1 subgoal):\n 1. t \\<in> red_mthr.deadlocked P s'", "by -(erule contrapos_np, rule redT_progress_deadlocked[OF wf start_wf RedT])"], ["proof (state)\nthis:\n  t \\<in> red_mthr.deadlocked P s'\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "moreover"], ["proof (state)\nthis:\n  t \\<in> red_mthr.deadlocked P s'\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "from \\<open>sconf_type_ok (E, T) t (e', x') m'\\<close>"], ["proof (chain)\npicking this:\n  sconf_type_ok (E, T) t (e', x') m'", "obtain T'' where \"P,E,m' \\<turnstile> e' : T''\" \"P \\<turnstile> T'' \\<le> T\""], ["proof (prove)\nusing this:\n  sconf_type_ok (E, T) t (e', x') m'\n\ngoal (1 subgoal):\n 1. (\\<And>T''.\n        \\<lbrakk>P,E,m' \\<turnstile> e' : T'';\n         P \\<turnstile> T'' \\<le> T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: sconf_type_ok_def type_ok_def)"], ["proof (state)\nthis:\n  P,E,m' \\<turnstile> e' : T''\n  P \\<turnstile> T'' \\<le> T\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "with ET"], ["proof (chain)\npicking this:\n  Es' t = \\<lfloor>(E, T)\\<rfloor>\n  P,E,m' \\<turnstile> e' : T''\n  P \\<turnstile> T'' \\<le> T", "have \"\\<exists>E T. Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and> (\\<exists>T'. P,E,m' \\<turnstile> e' : T' \\<and> P \\<turnstile> T' \\<le> T)\""], ["proof (prove)\nusing this:\n  Es' t = \\<lfloor>(E, T)\\<rfloor>\n  P,E,m' \\<turnstile> e' : T''\n  P \\<turnstile> T'' \\<le> T\n\ngoal (1 subgoal):\n 1. \\<exists>E T.\n       Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n       (\\<exists>T'.\n           P,E,m' \\<turnstile> e' : T' \\<and> P \\<turnstile> T' \\<le> T)", "by blast"], ["proof (state)\nthis:\n  \\<exists>E T.\n     Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n     (\\<exists>T'.\n         P,E,m' \\<turnstile> e' : T' \\<and> P \\<turnstile> T' \\<le> T)\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "ultimately"], ["proof (chain)\npicking this:\n  t \\<in> red_mthr.deadlocked P s'\n  \\<exists>E T.\n     Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n     (\\<exists>T'.\n         P,E,m' \\<turnstile> e' : T' \\<and> P \\<turnstile> T' \\<le> T)", "have \"t \\<in> red_mthr.deadlocked P s' \\<and> (\\<exists>E T. Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and> (\\<exists>T'. P,E,m' \\<turnstile> e' : T' \\<and> P \\<turnstile> T' \\<le> T))\""], ["proof (prove)\nusing this:\n  t \\<in> red_mthr.deadlocked P s'\n  \\<exists>E T.\n     Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n     (\\<exists>T'.\n         P,E,m' \\<turnstile> e' : T' \\<and> P \\<turnstile> T' \\<le> T)\n\ngoal (1 subgoal):\n 1. t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,m' \\<turnstile> e' : T' \\<and> P \\<turnstile> T' \\<le> T))", ".."], ["proof (state)\nthis:\n  t \\<in> red_mthr.deadlocked P s' \\<and>\n  (\\<exists>E T.\n      Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n      (\\<exists>T'.\n          P,E,m' \\<turnstile> e' : T' \\<and> P \\<turnstile> T' \\<le> T))\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "}"], ["proof (state)\nthis:\n  \\<not> final e' \\<Longrightarrow>\n  t \\<in> red_mthr.deadlocked P s' \\<and>\n  (\\<exists>E T.\n      Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n      (\\<exists>T'.\n          P,E,m' \\<turnstile> e' : T' \\<and> P \\<turnstile> T' \\<le> T))\n\ngoal (1 subgoal):\n 1. thr s' t = \\<lfloor>((e', x'), ln')\\<rfloor> \\<Longrightarrow>\n    (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>v. e' = Val v \\<Longrightarrow>\n  \\<exists>v.\n     e' = Val v \\<and>\n     (\\<exists>E T.\n         Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n         P,m' \\<turnstile> v :\\<le> T \\<and> ln' = no_wait_locks)\n  \\<exists>a. e' = Throw a \\<Longrightarrow>\n  \\<exists>a C.\n     e' = Throw a \\<and>\n     typeof_addr m' a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n     P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and> ln' = no_wait_locks\n  \\<not> final e' \\<Longrightarrow>\n  t \\<in> red_mthr.deadlocked P s' \\<and>\n  (\\<exists>E T.\n      Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n      (\\<exists>T'.\n          P,E,m' \\<turnstile> e' : T' \\<and> P \\<turnstile> T' \\<le> T))", "show ?thesis2"], ["proof (prove)\nusing this:\n  \\<exists>v. e' = Val v \\<Longrightarrow>\n  \\<exists>v.\n     e' = Val v \\<and>\n     (\\<exists>E T.\n         Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n         P,m' \\<turnstile> v :\\<le> T \\<and> ln' = no_wait_locks)\n  \\<exists>a. e' = Throw a \\<Longrightarrow>\n  \\<exists>a C.\n     e' = Throw a \\<and>\n     typeof_addr m' a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n     P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and> ln' = no_wait_locks\n  \\<not> final e' \\<Longrightarrow>\n  t \\<in> red_mthr.deadlocked P s' \\<and>\n  (\\<exists>E T.\n      Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n      (\\<exists>T'.\n          P,E,m' \\<turnstile> e' : T' \\<and> P \\<turnstile> T' \\<le> T))\n\ngoal (1 subgoal):\n 1. (\\<exists>v.\n        e' = Val v \\<and>\n        (\\<exists>E T.\n            Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n            P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n        ln' = no_wait_locks) \\<or>\n    (\\<exists>a C.\n        e' = Throw a \\<and>\n        typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n        ln' = no_wait_locks) \\<or>\n    t \\<in> red_mthr.deadlocked P s' \\<and>\n    (\\<exists>E T.\n        Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n        (\\<exists>T'.\n            P,E,shr s' \\<turnstile> e' : T' \\<and>\n            P \\<turnstile> T' \\<le> T))", "by simp(blast)"], ["proof (state)\nthis:\n  (\\<exists>v.\n      e' = Val v \\<and>\n      (\\<exists>E T.\n          Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n          P,shr s' \\<turnstile> v :\\<le> T) \\<and>\n      ln' = no_wait_locks) \\<or>\n  (\\<exists>a C.\n      e' = Throw a \\<and>\n      typeof_addr (shr s') a = \\<lfloor>Class_type C\\<rfloor> \\<and>\n      P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<and>\n      ln' = no_wait_locks) \\<or>\n  t \\<in> red_mthr.deadlocked P s' \\<and>\n  (\\<exists>E T.\n      Es' t = \\<lfloor>(E, T)\\<rfloor> \\<and>\n      (\\<exists>T'.\n          P,E,shr s' \\<turnstile> e' : T' \\<and> P \\<turnstile> T' \\<le> T))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}