{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Common/BinOp.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma sdiv_smod_id: \"(a sdiv b) * b + (a smod b) = a\"", "lemma [simp]:\n  \"(binop_LessThan v1 v2 = Some va) \\<longleftrightarrow> \n   (\\<exists>i1 i2. v1 = Intg i1 \\<and> v2 = Intg i2 \\<and> va = Inl (Bool (i1 <s i2)))\"", "lemma [simp]:\n  \"(binop_LessOrEqual v1 v2 = Some va) \\<longleftrightarrow> \n   (\\<exists>i1 i2. v1 = Intg i1 \\<and> v2 = Intg i2 \\<and> va = Inl (Bool (i1 <=s i2)))\"", "lemma [simp]:\n  \"(binop_GreaterThan v1 v2 = Some va) \\<longleftrightarrow> \n   (\\<exists>i1 i2. v1 = Intg i1 \\<and> v2 = Intg i2 \\<and> va = Inl (Bool (i2 <s i1)))\"", "lemma [simp]:\n  \"(binop_GreaterOrEqual v1 v2 = Some va) \\<longleftrightarrow> \n   (\\<exists>i1 i2. v1 = Intg i1 \\<and> v2 = Intg i2 \\<and> va = Inl (Bool (i2 <=s i1)))\"", "lemma [simp]:\n  \"(binop_Add v\\<^sub>1 v\\<^sub>2  = Some va) \\<longleftrightarrow>\n   (\\<exists>i\\<^sub>1 i\\<^sub>2. v\\<^sub>1 = Intg i\\<^sub>1 \\<and> v\\<^sub>2 = Intg i\\<^sub>2 \\<and> va = Inl (Intg (i\\<^sub>1+i\\<^sub>2)))\"", "lemma [simp]:\n  \"(binop_Subtract v1 v2 = Some va) \\<longleftrightarrow> \n   (\\<exists>i1 i2. v1 = Intg i1 \\<and> v2 = Intg i2 \\<and> va = Inl (Intg (i1 - i2)))\"", "lemma [simp]: \n  \"(binop_Mult v1 v2 = Some va) \\<longleftrightarrow> \n   (\\<exists>i1 i2. v1 = Intg i1 \\<and> v2 = Intg i2 \\<and> va = Inl (Intg (i1 * i2)))\"", "lemma [simp]:\n  \"(binop_BinAnd v1 v2 = Some va) \\<longleftrightarrow> \n   (\\<exists>b1 b2. v1 = Bool b1 \\<and> v2 = Bool b2 \\<and> va = Inl (Bool (b1 \\<and> b2))) \\<or> \n   (\\<exists>i1 i2. v1 = Intg i1 \\<and> v2 = Intg i2 \\<and> va = Inl (Intg (i1 AND i2)))\"", "lemma [simp]:\n  \"(binop_BinOr v1 v2 = Some va) \\<longleftrightarrow> \n   (\\<exists>b1 b2. v1 = Bool b1 \\<and> v2 = Bool b2 \\<and> va = Inl (Bool (b1 \\<or> b2))) \\<or>\n   (\\<exists>i1 i2. v1 = Intg i1 \\<and> v2 = Intg i2 \\<and> va = Inl (Intg (i1 OR i2)))\"", "lemma [simp]:\n  \"(binop_BinXor v1 v2 = Some va) \\<longleftrightarrow>\n   (\\<exists>b1 b2. v1 = Bool b1 \\<and> v2 = Bool b2 \\<and> va = Inl (Bool (b1 \\<noteq> b2))) \\<or>\n   (\\<exists>i1 i2. v1 = Intg i1 \\<and> v2 = Intg i2 \\<and> va = Inl (Intg (i1 XOR i2)))\"", "lemma [simp]:\n  \"(binop_ShiftLeft v1 v2 = Some va) \\<longleftrightarrow> \n   (\\<exists>i1 i2. v1 = Intg i1 \\<and> v2 = Intg i2 \\<and> va = Inl (Intg (i1 << unat (i2 AND 0x1f))))\"", "lemma [simp]:\n  \"(binop_ShiftRightZeros v1 v2 = Some va) \\<longleftrightarrow> \n   (\\<exists>i1 i2. v1 = Intg i1 \\<and> v2 = Intg i2 \\<and> va = Inl (Intg (i1 >> unat (i2 AND 0x1f))))\"", "lemma [simp]:\n  \"(binop_ShiftRightSigned v1 v2 = Some va) \\<longleftrightarrow> \n   (\\<exists>i1 i2. v1 = Intg i1 \\<and> v2 = Intg i2 \\<and> va = Inl (Intg (i1 >>> unat (i2 AND 0x1f))))\"", "lemma [simp]:\n  \"(binop_Mod v1 v2 = Some va) \\<longleftrightarrow> \n   (\\<exists>i1 i2. v1 = Intg i1 \\<and> v2 = Intg i2 \\<and> \n      va = (if i2 = 0 then Inr (addr_of_sys_xcpt ArithmeticException) else Inl (Intg(i1 smod i2))))\"", "lemma [simp]:\n  \"(binop_Div v1 v2 = Some va) \\<longleftrightarrow> \n   (\\<exists>i1 i2. v1 = Intg i1 \\<and> v2 = Intg i2 \\<and> \n      va = (if i2 = 0 then Inr (addr_of_sys_xcpt ArithmeticException) else Inl (Intg(i1 sdiv i2))))\"", "lemma WT_binopI [intro]:\n  \"P \\<turnstile> T1 \\<le> T2 \\<or> P \\<turnstile> T2 \\<le> T1 \\<Longrightarrow> P \\<turnstile> T1\\<guillemotleft>Eq\\<guillemotright>T2 :: Boolean\"\n  \"P \\<turnstile> T1 \\<le> T2 \\<or> P \\<turnstile> T2 \\<le> T1 \\<Longrightarrow> P \\<turnstile> T1\\<guillemotleft>NotEq\\<guillemotright>T2 :: Boolean\"\n  \"bop = Add \\<or> bop = Subtract \\<or> bop = Mult \\<or> bop = Mod \\<or> bop = Div \\<or> bop = BinAnd \\<or> bop = BinOr \\<or> bop = BinXor \\<or> \n   bop = ShiftLeft \\<or> bop = ShiftRightZeros \\<or> bop = ShiftRightSigned\n   \\<Longrightarrow> P \\<turnstile> Integer\\<guillemotleft>bop\\<guillemotright>Integer :: Integer\"\n  \"bop = LessThan \\<or> bop = LessOrEqual \\<or> bop = GreaterThan \\<or> bop = GreaterOrEqual \\<Longrightarrow> P \\<turnstile> Integer\\<guillemotleft>bop\\<guillemotright>Integer :: Boolean\"\n  \"bop = BinAnd \\<or> bop = BinOr \\<or> bop = BinXor \\<Longrightarrow> P \\<turnstile> Boolean\\<guillemotleft>bop\\<guillemotright>Boolean :: Boolean\"", "lemma WT_binop_fun: \"\\<lbrakk> P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 :: T; P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 :: T' \\<rbrakk> \\<Longrightarrow> T = T'\"", "lemma WT_binop_is_type:\n  \"\\<lbrakk> P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 :: T; is_type P T1; is_type P T2 \\<rbrakk> \\<Longrightarrow> is_type P T\"", "lemma WTrt_binopI [intro]:\n  \"P \\<turnstile> T1\\<guillemotleft>Eq\\<guillemotright>T2 : Boolean\"\n  \"P \\<turnstile> T1\\<guillemotleft>NotEq\\<guillemotright>T2 : Boolean\"\n  \"bop = Add \\<or> bop = Subtract \\<or> bop = Mult \\<or> bop = Div \\<or> bop = Mod \\<or> bop = BinAnd \\<or> bop = BinOr \\<or> bop = BinXor \\<or>\n   bop = ShiftLeft \\<or> bop = ShiftRightZeros \\<or> bop = ShiftRightSigned\n   \\<Longrightarrow> P \\<turnstile> Integer\\<guillemotleft>bop\\<guillemotright>Integer : Integer\"\n  \"bop = LessThan \\<or> bop = LessOrEqual \\<or> bop = GreaterThan \\<or> bop = GreaterOrEqual \\<Longrightarrow> P \\<turnstile> Integer\\<guillemotleft>bop\\<guillemotright>Integer : Boolean\"\n  \"bop = BinAnd \\<or> bop = BinOr \\<or> bop = BinXor \\<Longrightarrow> P \\<turnstile> Boolean\\<guillemotleft>bop\\<guillemotright>Boolean : Boolean\"", "lemma WT_binop_WTrt_binop:\n  \"P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 :: T \\<Longrightarrow> P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T\"", "lemma binop_progress:\n  \"\\<lbrakk> typeof\\<^bsub>h\\<^esub> v1 = \\<lfloor>T1\\<rfloor>; typeof\\<^bsub>h\\<^esub> v2 = \\<lfloor>T2\\<rfloor>; P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T \\<rbrakk>\n  \\<Longrightarrow> \\<exists>va. binop bop v1 v2 = \\<lfloor>va\\<rfloor>\"", "lemma binop_type:\n  assumes wf: \"wf_prog wf_md P\"\n  and pre: \"preallocated h\"\n  and type: \"typeof\\<^bsub>h\\<^esub> v1 = \\<lfloor>T1\\<rfloor>\" \"typeof\\<^bsub>h\\<^esub> v2 = \\<lfloor>T2\\<rfloor>\" \"P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T\"\n  shows \"binop bop v1 v2 = \\<lfloor>Inl v\\<rfloor> \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T\"\n  and \"binop bop v1 v2 = \\<lfloor>Inr a\\<rfloor> \\<Longrightarrow> P,h \\<turnstile> Addr a :\\<le> Class Throwable\"", "lemma binop_relevant_class:\n  assumes wf: \"wf_prog wf_md P\"\n  and pre: \"preallocated h\"\n  and bop: \"binop bop v1 v2 = \\<lfloor>Inr a\\<rfloor>\"\n  and sup: \"P \\<turnstile> cname_of h a \\<preceq>\\<^sup>* C\"\n  shows \"binop_relevant_class bop P C\"", "lemma WTrt_binop_fun: \"\\<lbrakk> P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T; P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T' \\<rbrakk> \\<Longrightarrow> T = T'\"", "lemma WTrt_binop_THE [simp]: \"P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T \\<Longrightarrow> The (WTrt_binop P T1 bop T2) = T\"", "lemma WTrt_binop_widen_mono:\n  \"\\<lbrakk> P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T; P \\<turnstile> T1' \\<le> T1; P \\<turnstile> T2' \\<le> T2 \\<rbrakk> \\<Longrightarrow> \\<exists>T'. P \\<turnstile> T1'\\<guillemotleft>bop\\<guillemotright>T2' : T' \\<and> P \\<turnstile> T' \\<le> T\"", "lemma WTrt_binop_is_type:\n  \"\\<lbrakk> P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T; is_type P T1; is_type P T2 \\<rbrakk> \\<Longrightarrow> is_type P T\"", "lemmas [code] =\n  heap_base.binop_Div.simps\n  heap_base.binop_Mod.simps\n  heap_base.binop.simps", "lemma eval_WTrt_binop_i_i_i_i_o:\n  \"Predicate.eval (WTrt_binop_i_i_i_i_o P T1 bop T2) T \\<longleftrightarrow> P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T\"", "lemma the_WTrt_binop_code:\n  \"(THE T. P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T) = Predicate.the (WTrt_binop_i_i_i_i_o P T1 bop T2)\""], "translations": [["", "lemma sdiv_smod_id: \"(a sdiv b) * b + (a smod b) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a sdiv b * b + a smod b = a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a sdiv b * b + a smod b = a", "have F5: \"\\<forall>u::'a word. - (- u) = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u. - (- u) = u", "by simp"], ["proof (state)\nthis:\n  \\<forall>u. - (- u) = u\n\ngoal (1 subgoal):\n 1. a sdiv b * b + a smod b = a", "have F7: \"\\<forall>v u::'a word. u + v = v + u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v u. u + v = v + u", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  \\<forall>v u. u + v = v + u\n\ngoal (1 subgoal):\n 1. a sdiv b * b + a smod b = a", "have F8: \"\\<forall>(w::'a word) (v::int) u::int. word_of_int u + word_of_int v * w = word_of_int (u + v * sint w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>w v u.\n       word_of_int u + word_of_int v * w = word_of_int (u + v * sint w)", "by simp"], ["proof (state)\nthis:\n  \\<forall>w v u.\n     word_of_int u + word_of_int v * w = word_of_int (u + v * sint w)\n\ngoal (1 subgoal):\n 1. a sdiv b * b + a smod b = a", "have \"\\<exists>u. u = - sint b \\<and> word_of_int (sint a mod u + - (- u * (sint a div u))) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u.\n       u = - sint b \\<and>\n       word_of_int (sint a mod u + - (- u * (sint a div u))) = a", "using F5"], ["proof (prove)\nusing this:\n  \\<forall>u. - (- u) = u\n\ngoal (1 subgoal):\n 1. \\<exists>u.\n       u = - sint b \\<and>\n       word_of_int (sint a mod u + - (- u * (sint a div u))) = a", "by simp"], ["proof (state)\nthis:\n  \\<exists>u.\n     u = - sint b \\<and>\n     word_of_int (sint a mod u + - (- u * (sint a div u))) = a\n\ngoal (1 subgoal):\n 1. a sdiv b * b + a smod b = a", "hence \"word_of_int (sint a mod - sint b + - (sint b * (sint a div - sint b))) = a\""], ["proof (prove)\nusing this:\n  \\<exists>u.\n     u = - sint b \\<and>\n     word_of_int (sint a mod u + - (- u * (sint a div u))) = a\n\ngoal (1 subgoal):\n 1. word_of_int (sint a mod - sint b + - (sint b * (sint a div - sint b))) =\n    a", "by (metis equation_minus_iff)"], ["proof (state)\nthis:\n  word_of_int (sint a mod - sint b + - (sint b * (sint a div - sint b))) = a\n\ngoal (1 subgoal):\n 1. a sdiv b * b + a smod b = a", "hence \"word_of_int (sint a mod - sint b) + word_of_int (- (sint a div - sint b)) * b = a\""], ["proof (prove)\nusing this:\n  word_of_int (sint a mod - sint b + - (sint b * (sint a div - sint b))) = a\n\ngoal (1 subgoal):\n 1. word_of_int (sint a mod - sint b) +\n    word_of_int (- (sint a div - sint b)) * b =\n    a", "using F8"], ["proof (prove)\nusing this:\n  word_of_int (sint a mod - sint b + - (sint b * (sint a div - sint b))) = a\n  \\<forall>w v u.\n     word_of_int u + word_of_int v * w = word_of_int (u + v * sint w)\n\ngoal (1 subgoal):\n 1. word_of_int (sint a mod - sint b) +\n    word_of_int (- (sint a div - sint b)) * b =\n    a", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  word_of_int (sint a mod - sint b) +\n  word_of_int (- (sint a div - sint b)) * b =\n  a\n\ngoal (1 subgoal):\n 1. a sdiv b * b + a smod b = a", "hence eq: \"word_of_int (- (sint a div - sint b)) * b + word_of_int (sint a mod - sint b) = a\""], ["proof (prove)\nusing this:\n  word_of_int (sint a mod - sint b) +\n  word_of_int (- (sint a div - sint b)) * b =\n  a\n\ngoal (1 subgoal):\n 1. word_of_int (- (sint a div - sint b)) * b +\n    word_of_int (sint a mod - sint b) =\n    a", "using F7"], ["proof (prove)\nusing this:\n  word_of_int (sint a mod - sint b) +\n  word_of_int (- (sint a div - sint b)) * b =\n  a\n  \\<forall>v u. u + v = v + u\n\ngoal (1 subgoal):\n 1. word_of_int (- (sint a div - sint b)) * b +\n    word_of_int (sint a mod - sint b) =\n    a", "by simp"], ["proof (state)\nthis:\n  word_of_int (- (sint a div - sint b)) * b +\n  word_of_int (sint a mod - sint b) =\n  a\n\ngoal (1 subgoal):\n 1. a sdiv b * b + a smod b = a", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. a sdiv b * b + a smod b = a", "proof(cases \"sint a < 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sint a < 0 \\<Longrightarrow> a sdiv b * b + a smod b = a\n 2. \\<not> sint a < 0 \\<Longrightarrow> a sdiv b * b + a smod b = a", "case True"], ["proof (state)\nthis:\n  sint a < 0\n\ngoal (2 subgoals):\n 1. sint a < 0 \\<Longrightarrow> a sdiv b * b + a smod b = a\n 2. \\<not> sint a < 0 \\<Longrightarrow> a sdiv b * b + a smod b = a", "note a = this"], ["proof (state)\nthis:\n  sint a < 0\n\ngoal (2 subgoals):\n 1. sint a < 0 \\<Longrightarrow> a sdiv b * b + a smod b = a\n 2. \\<not> sint a < 0 \\<Longrightarrow> a sdiv b * b + a smod b = a", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. a sdiv b * b + a smod b = a", "proof(cases \"sint b < 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sint b < 0 \\<Longrightarrow> a sdiv b * b + a smod b = a\n 2. \\<not> sint b < 0 \\<Longrightarrow> a sdiv b * b + a smod b = a", "case True"], ["proof (state)\nthis:\n  sint b < 0\n\ngoal (2 subgoals):\n 1. sint b < 0 \\<Longrightarrow> a sdiv b * b + a smod b = a\n 2. \\<not> sint b < 0 \\<Longrightarrow> a sdiv b * b + a smod b = a", "with a"], ["proof (chain)\npicking this:\n  sint a < 0\n  sint b < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  sint a < 0\n  sint b < 0\n\ngoal (1 subgoal):\n 1. a sdiv b * b + a smod b = a", "by simp (metis F7 F8 eq minus_equation_iff minus_mult_minus mod_div_mult_eq)"], ["proof (state)\nthis:\n  a sdiv b * b + a smod b = a\n\ngoal (1 subgoal):\n 1. \\<not> sint b < 0 \\<Longrightarrow> a sdiv b * b + a smod b = a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> sint b < 0 \\<Longrightarrow> a sdiv b * b + a smod b = a", "case False"], ["proof (state)\nthis:\n  \\<not> sint b < 0\n\ngoal (1 subgoal):\n 1. \\<not> sint b < 0 \\<Longrightarrow> a sdiv b * b + a smod b = a", "from eq"], ["proof (chain)\npicking this:\n  word_of_int (- (sint a div - sint b)) * b +\n  word_of_int (sint a mod - sint b) =\n  a", "have \"word_of_int (- (- sint a div sint b)) * b + word_of_int (- (- sint a mod sint b)) = a\""], ["proof (prove)\nusing this:\n  word_of_int (- (sint a div - sint b)) * b +\n  word_of_int (sint a mod - sint b) =\n  a\n\ngoal (1 subgoal):\n 1. word_of_int (- (- sint a div sint b)) * b +\n    word_of_int (- (- sint a mod sint b)) =\n    a", "by (metis div_minus_right mod_minus_right)"], ["proof (state)\nthis:\n  word_of_int (- (- sint a div sint b)) * b +\n  word_of_int (- (- sint a mod sint b)) =\n  a\n\ngoal (1 subgoal):\n 1. \\<not> sint b < 0 \\<Longrightarrow> a sdiv b * b + a smod b = a", "with a False"], ["proof (chain)\npicking this:\n  sint a < 0\n  \\<not> sint b < 0\n  word_of_int (- (- sint a div sint b)) * b +\n  word_of_int (- (- sint a mod sint b)) =\n  a", "show ?thesis"], ["proof (prove)\nusing this:\n  sint a < 0\n  \\<not> sint b < 0\n  word_of_int (- (- sint a div sint b)) * b +\n  word_of_int (- (- sint a mod sint b)) =\n  a\n\ngoal (1 subgoal):\n 1. a sdiv b * b + a smod b = a", "by simp"], ["proof (state)\nthis:\n  a sdiv b * b + a smod b = a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a sdiv b * b + a smod b = a\n\ngoal (1 subgoal):\n 1. \\<not> sint a < 0 \\<Longrightarrow> a sdiv b * b + a smod b = a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> sint a < 0 \\<Longrightarrow> a sdiv b * b + a smod b = a", "case False"], ["proof (state)\nthis:\n  \\<not> sint a < 0\n\ngoal (1 subgoal):\n 1. \\<not> sint a < 0 \\<Longrightarrow> a sdiv b * b + a smod b = a", "note a = this"], ["proof (state)\nthis:\n  \\<not> sint a < 0\n\ngoal (1 subgoal):\n 1. \\<not> sint a < 0 \\<Longrightarrow> a sdiv b * b + a smod b = a", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. a sdiv b * b + a smod b = a", "proof(cases \"sint b < 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sint b < 0 \\<Longrightarrow> a sdiv b * b + a smod b = a\n 2. \\<not> sint b < 0 \\<Longrightarrow> a sdiv b * b + a smod b = a", "case True"], ["proof (state)\nthis:\n  sint b < 0\n\ngoal (2 subgoals):\n 1. sint b < 0 \\<Longrightarrow> a sdiv b * b + a smod b = a\n 2. \\<not> sint b < 0 \\<Longrightarrow> a sdiv b * b + a smod b = a", "with a eq"], ["proof (chain)\npicking this:\n  \\<not> sint a < 0\n  word_of_int (- (sint a div - sint b)) * b +\n  word_of_int (sint a mod - sint b) =\n  a\n  sint b < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> sint a < 0\n  word_of_int (- (sint a div - sint b)) * b +\n  word_of_int (sint a mod - sint b) =\n  a\n  sint b < 0\n\ngoal (1 subgoal):\n 1. a sdiv b * b + a smod b = a", "by simp"], ["proof (state)\nthis:\n  a sdiv b * b + a smod b = a\n\ngoal (1 subgoal):\n 1. \\<not> sint b < 0 \\<Longrightarrow> a sdiv b * b + a smod b = a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> sint b < 0 \\<Longrightarrow> a sdiv b * b + a smod b = a", "case False"], ["proof (state)\nthis:\n  \\<not> sint b < 0\n\ngoal (1 subgoal):\n 1. \\<not> sint b < 0 \\<Longrightarrow> a sdiv b * b + a smod b = a", "with a"], ["proof (chain)\npicking this:\n  \\<not> sint a < 0\n  \\<not> sint b < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> sint a < 0\n  \\<not> sint b < 0\n\ngoal (1 subgoal):\n 1. a sdiv b * b + a smod b = a", "by (simp add: F7 F8)"], ["proof (state)\nthis:\n  a sdiv b * b + a smod b = a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a sdiv b * b + a smod b = a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a sdiv b * b + a smod b = a\n\ngoal:\nNo subgoals!", "qed"], ["", "notepad begin"], ["proof (state)", "have  \"  5  sdiv ( 3 :: word32) =  1\"\n  and \"  5  smod ( 3 :: word32) =  2\"\n  and \"  5  sdiv (-3 :: word32) = -1\"\n  and \"  5  smod (-3 :: word32) =  2\"\n  and \"(-5) sdiv ( 3 :: word32) = -1\"\n  and \"(-5) smod ( 3 :: word32) = -2\"\n  and \"(-5) sdiv (-3 :: word32) =  1\"\n  and \"(-5) smod (-3 :: word32) = -2\"\n  and \"-2147483648 sdiv 1 = (-2147483648 :: word32)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((5 sdiv 3 = 1 &&& 5 smod 3 = 2) &&&\n     5 sdiv - 3 = - 1 &&& 5 smod - 3 = 2) &&&\n    (- 5 sdiv 3 = - 1 &&& - 5 smod 3 = - 2) &&&\n    - 5 sdiv - 3 = 1 &&&\n    - 5 smod - 3 = - 2 &&& - 2147483648 sdiv 1 = - 2147483648", "by eval+"], ["proof (state)\nthis:\n  5 sdiv 3 = 1\n  5 smod 3 = 2\n  5 sdiv - 3 = - 1\n  5 smod - 3 = 2\n  - 5 sdiv 3 = - 1\n  - 5 smod 3 = - 2\n  - 5 sdiv - 3 = 1\n  - 5 smod - 3 = - 2\n  - 2147483648 sdiv 1 = - 2147483648", "end"], ["", "context heap_base begin"], ["", "fun binop_Mod :: \"'addr val \\<Rightarrow> 'addr val \\<Rightarrow> 'addr binop_ret option\"\nwhere\n  \"binop_Mod (Intg i1) (Intg i2) = \n   Some (if i2 = 0 then Inr (addr_of_sys_xcpt ArithmeticException) else Inl (Intg (i1 smod i2)))\"\n| \"binop_Mod v1 v2 = None\""], ["", "fun binop_Div :: \"'addr val \\<Rightarrow> 'addr val \\<Rightarrow> 'addr binop_ret option\"\nwhere\n  \"binop_Div (Intg i1) (Intg i2) = \n   Some (if i2 = 0 then Inr (addr_of_sys_xcpt ArithmeticException) else Inl (Intg (i1 sdiv i2)))\"\n| \"binop_Div v1 v2 = None\""], ["", "primrec binop :: \"bop \\<Rightarrow> 'addr val \\<Rightarrow> 'addr val \\<Rightarrow> 'addr binop_ret option\"\nwhere\n  \"binop Eq v1 v2 =  Some (Inl (Bool (v1 = v2)))\"\n| \"binop NotEq v1 v2 = Some (Inl (Bool (v1 \\<noteq> v2)))\"\n| \"binop LessThan = binop_LessThan\"\n| \"binop LessOrEqual = binop_LessOrEqual\"\n| \"binop GreaterThan = binop_GreaterThan\"\n| \"binop GreaterOrEqual = binop_GreaterOrEqual\"\n| \"binop Add = binop_Add\"\n| \"binop Subtract = binop_Subtract\"\n| \"binop Mult = binop_Mult\"\n| \"binop Mod = binop_Mod\"\n| \"binop Div = binop_Div\"\n| \"binop BinAnd = binop_BinAnd\"\n| \"binop BinOr = binop_BinOr\"\n| \"binop BinXor = binop_BinXor\"\n| \"binop ShiftLeft = binop_ShiftLeft\"\n| \"binop ShiftRightZeros = binop_ShiftRightZeros\"\n| \"binop ShiftRightSigned = binop_ShiftRightSigned\""], ["", "end"], ["", "lemma [simp]:\n  \"(binop_LessThan v1 v2 = Some va) \\<longleftrightarrow> \n   (\\<exists>i1 i2. v1 = Intg i1 \\<and> v2 = Intg i2 \\<and> va = Inl (Bool (i1 <s i2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (binop_LessThan v1 v2 = \\<lfloor>va\\<rfloor>) =\n    (\\<exists>i1 i2.\n        v1 = Intg i1 \\<and> v2 = Intg i2 \\<and> va = Inl (Bool (i1 <s i2)))", "by(cases \"(v1, v2)\" rule: binop_LessThan.cases) auto"], ["", "lemma [simp]:\n  \"(binop_LessOrEqual v1 v2 = Some va) \\<longleftrightarrow> \n   (\\<exists>i1 i2. v1 = Intg i1 \\<and> v2 = Intg i2 \\<and> va = Inl (Bool (i1 <=s i2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (binop_LessOrEqual v1 v2 = \\<lfloor>va\\<rfloor>) =\n    (\\<exists>i1 i2.\n        v1 = Intg i1 \\<and>\n        v2 = Intg i2 \\<and> va = Inl (Bool (i1 \\<le>s i2)))", "by(cases \"(v1, v2)\" rule: binop_LessOrEqual.cases) auto"], ["", "lemma [simp]:\n  \"(binop_GreaterThan v1 v2 = Some va) \\<longleftrightarrow> \n   (\\<exists>i1 i2. v1 = Intg i1 \\<and> v2 = Intg i2 \\<and> va = Inl (Bool (i2 <s i1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (binop_GreaterThan v1 v2 = \\<lfloor>va\\<rfloor>) =\n    (\\<exists>i1 i2.\n        v1 = Intg i1 \\<and> v2 = Intg i2 \\<and> va = Inl (Bool (i2 <s i1)))", "by(cases \"(v1, v2)\" rule: binop_GreaterThan.cases) auto"], ["", "lemma [simp]:\n  \"(binop_GreaterOrEqual v1 v2 = Some va) \\<longleftrightarrow> \n   (\\<exists>i1 i2. v1 = Intg i1 \\<and> v2 = Intg i2 \\<and> va = Inl (Bool (i2 <=s i1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (binop_GreaterOrEqual v1 v2 = \\<lfloor>va\\<rfloor>) =\n    (\\<exists>i1 i2.\n        v1 = Intg i1 \\<and>\n        v2 = Intg i2 \\<and> va = Inl (Bool (i2 \\<le>s i1)))", "by(cases \"(v1, v2)\" rule: binop_GreaterOrEqual.cases) auto"], ["", "lemma [simp]:\n  \"(binop_Add v\\<^sub>1 v\\<^sub>2  = Some va) \\<longleftrightarrow>\n   (\\<exists>i\\<^sub>1 i\\<^sub>2. v\\<^sub>1 = Intg i\\<^sub>1 \\<and> v\\<^sub>2 = Intg i\\<^sub>2 \\<and> va = Inl (Intg (i\\<^sub>1+i\\<^sub>2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (binop_Add v\\<^sub>1 v\\<^sub>2 = \\<lfloor>va\\<rfloor>) =\n    (\\<exists>i\\<^sub>1 i\\<^sub>2.\n        v\\<^sub>1 = Intg i\\<^sub>1 \\<and>\n        v\\<^sub>2 = Intg i\\<^sub>2 \\<and>\n        va = Inl (Intg (i\\<^sub>1 + i\\<^sub>2)))", "by(cases \"(v\\<^sub>1, v\\<^sub>2)\" rule: binop_Add.cases) auto"], ["", "lemma [simp]:\n  \"(binop_Subtract v1 v2 = Some va) \\<longleftrightarrow> \n   (\\<exists>i1 i2. v1 = Intg i1 \\<and> v2 = Intg i2 \\<and> va = Inl (Intg (i1 - i2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (binop_Subtract v1 v2 = \\<lfloor>va\\<rfloor>) =\n    (\\<exists>i1 i2.\n        v1 = Intg i1 \\<and> v2 = Intg i2 \\<and> va = Inl (Intg (i1 - i2)))", "by(cases \"(v1, v2)\" rule: binop_Subtract.cases) auto"], ["", "lemma [simp]: \n  \"(binop_Mult v1 v2 = Some va) \\<longleftrightarrow> \n   (\\<exists>i1 i2. v1 = Intg i1 \\<and> v2 = Intg i2 \\<and> va = Inl (Intg (i1 * i2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (binop_Mult v1 v2 = \\<lfloor>va\\<rfloor>) =\n    (\\<exists>i1 i2.\n        v1 = Intg i1 \\<and> v2 = Intg i2 \\<and> va = Inl (Intg (i1 * i2)))", "by(cases \"(v1, v2)\" rule: binop_Mult.cases) auto"], ["", "lemma [simp]:\n  \"(binop_BinAnd v1 v2 = Some va) \\<longleftrightarrow> \n   (\\<exists>b1 b2. v1 = Bool b1 \\<and> v2 = Bool b2 \\<and> va = Inl (Bool (b1 \\<and> b2))) \\<or> \n   (\\<exists>i1 i2. v1 = Intg i1 \\<and> v2 = Intg i2 \\<and> va = Inl (Intg (i1 AND i2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (binop_BinAnd v1 v2 = \\<lfloor>va\\<rfloor>) =\n    ((\\<exists>b1 b2.\n         v1 = Bool b1 \\<and>\n         v2 = Bool b2 \\<and> va = Inl (Bool (b1 \\<and> b2))) \\<or>\n     (\\<exists>i1 i2.\n         v1 = Intg i1 \\<and>\n         v2 = Intg i2 \\<and> va = Inl (Intg (i1 AND i2))))", "by(cases \"(v1, v2)\" rule: binop_BinAnd.cases) auto"], ["", "lemma [simp]:\n  \"(binop_BinOr v1 v2 = Some va) \\<longleftrightarrow> \n   (\\<exists>b1 b2. v1 = Bool b1 \\<and> v2 = Bool b2 \\<and> va = Inl (Bool (b1 \\<or> b2))) \\<or>\n   (\\<exists>i1 i2. v1 = Intg i1 \\<and> v2 = Intg i2 \\<and> va = Inl (Intg (i1 OR i2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (binop_BinOr v1 v2 = \\<lfloor>va\\<rfloor>) =\n    ((\\<exists>b1 b2.\n         v1 = Bool b1 \\<and>\n         v2 = Bool b2 \\<and> va = Inl (Bool (b1 \\<or> b2))) \\<or>\n     (\\<exists>i1 i2.\n         v1 = Intg i1 \\<and>\n         v2 = Intg i2 \\<and> va = Inl (Intg (i1 OR i2))))", "by(cases \"(v1, v2)\" rule: binop_BinOr.cases) auto"], ["", "lemma [simp]:\n  \"(binop_BinXor v1 v2 = Some va) \\<longleftrightarrow>\n   (\\<exists>b1 b2. v1 = Bool b1 \\<and> v2 = Bool b2 \\<and> va = Inl (Bool (b1 \\<noteq> b2))) \\<or>\n   (\\<exists>i1 i2. v1 = Intg i1 \\<and> v2 = Intg i2 \\<and> va = Inl (Intg (i1 XOR i2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (binop_BinXor v1 v2 = \\<lfloor>va\\<rfloor>) =\n    ((\\<exists>b1 b2.\n         v1 = Bool b1 \\<and>\n         v2 = Bool b2 \\<and> va = Inl (Bool (b1 \\<noteq> b2))) \\<or>\n     (\\<exists>i1 i2.\n         v1 = Intg i1 \\<and>\n         v2 = Intg i2 \\<and> va = Inl (Intg (i1 XOR i2))))", "by(cases \"(v1, v2)\" rule: binop_BinXor.cases) auto"], ["", "lemma [simp]:\n  \"(binop_ShiftLeft v1 v2 = Some va) \\<longleftrightarrow> \n   (\\<exists>i1 i2. v1 = Intg i1 \\<and> v2 = Intg i2 \\<and> va = Inl (Intg (i1 << unat (i2 AND 0x1f))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (binop_ShiftLeft v1 v2 = \\<lfloor>va\\<rfloor>) =\n    (\\<exists>i1 i2.\n        v1 = Intg i1 \\<and>\n        v2 = Intg i2 \\<and> va = Inl (Intg (i1 << unat (i2 AND 31))))", "by(cases \"(v1, v2)\" rule: binop_ShiftLeft.cases) auto"], ["", "lemma [simp]:\n  \"(binop_ShiftRightZeros v1 v2 = Some va) \\<longleftrightarrow> \n   (\\<exists>i1 i2. v1 = Intg i1 \\<and> v2 = Intg i2 \\<and> va = Inl (Intg (i1 >> unat (i2 AND 0x1f))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (binop_ShiftRightZeros v1 v2 = \\<lfloor>va\\<rfloor>) =\n    (\\<exists>i1 i2.\n        v1 = Intg i1 \\<and>\n        v2 = Intg i2 \\<and> va = Inl (Intg (i1 >> unat (i2 AND 31))))", "by(cases \"(v1, v2)\" rule: binop_ShiftRightZeros.cases) auto"], ["", "lemma [simp]:\n  \"(binop_ShiftRightSigned v1 v2 = Some va) \\<longleftrightarrow> \n   (\\<exists>i1 i2. v1 = Intg i1 \\<and> v2 = Intg i2 \\<and> va = Inl (Intg (i1 >>> unat (i2 AND 0x1f))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (binop_ShiftRightSigned v1 v2 = \\<lfloor>va\\<rfloor>) =\n    (\\<exists>i1 i2.\n        v1 = Intg i1 \\<and>\n        v2 = Intg i2 \\<and> va = Inl (Intg (i1 >>> unat (i2 AND 31))))", "by(cases \"(v1, v2)\" rule: binop_ShiftRightSigned.cases) auto"], ["", "context heap_base begin"], ["", "lemma [simp]:\n  \"(binop_Mod v1 v2 = Some va) \\<longleftrightarrow> \n   (\\<exists>i1 i2. v1 = Intg i1 \\<and> v2 = Intg i2 \\<and> \n      va = (if i2 = 0 then Inr (addr_of_sys_xcpt ArithmeticException) else Inl (Intg(i1 smod i2))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (binop_Mod v1 v2 = \\<lfloor>va\\<rfloor>) =\n    (\\<exists>i1 i2.\n        v1 = Intg i1 \\<and>\n        v2 = Intg i2 \\<and>\n        va =\n        (if i2 = 0 then Inr (addr_of_sys_xcpt ArithmeticException)\n         else Inl (Intg (i1 smod i2))))", "by(cases \"(v1, v2)\" rule: binop_Mod.cases) auto"], ["", "lemma [simp]:\n  \"(binop_Div v1 v2 = Some va) \\<longleftrightarrow> \n   (\\<exists>i1 i2. v1 = Intg i1 \\<and> v2 = Intg i2 \\<and> \n      va = (if i2 = 0 then Inr (addr_of_sys_xcpt ArithmeticException) else Inl (Intg(i1 sdiv i2))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (binop_Div v1 v2 = \\<lfloor>va\\<rfloor>) =\n    (\\<exists>i1 i2.\n        v1 = Intg i1 \\<and>\n        v2 = Intg i2 \\<and>\n        va =\n        (if i2 = 0 then Inr (addr_of_sys_xcpt ArithmeticException)\n         else Inl (Intg (i1 sdiv i2))))", "by(cases \"(v1, v2)\" rule: binop_Div.cases) auto"], ["", "end"], ["", "subsection \\<open>Typing for binary operators\\<close>"], ["", "inductive WT_binop :: \"'m prog \\<Rightarrow> ty \\<Rightarrow> bop \\<Rightarrow> ty \\<Rightarrow> ty \\<Rightarrow> bool\" (\"_ \\<turnstile> _\\<guillemotleft>_\\<guillemotright>_ :: _\" [51,0,0,0,51] 50)\nwhere\n  WT_binop_Eq:\n  \"P \\<turnstile> T1 \\<le> T2 \\<or> P \\<turnstile> T2 \\<le> T1 \\<Longrightarrow> P \\<turnstile> T1\\<guillemotleft>Eq\\<guillemotright>T2 :: Boolean\"\n\n| WT_binop_NotEq:\n  \"P \\<turnstile> T1 \\<le> T2 \\<or> P \\<turnstile> T2 \\<le> T1 \\<Longrightarrow> P \\<turnstile> T1\\<guillemotleft>NotEq\\<guillemotright>T2 :: Boolean\"\n\n| WT_binop_LessThan:\n  \"P \\<turnstile> Integer\\<guillemotleft>LessThan\\<guillemotright>Integer :: Boolean\"\n\n| WT_binop_LessOrEqual:\n  \"P \\<turnstile> Integer\\<guillemotleft>LessOrEqual\\<guillemotright>Integer :: Boolean\"\n\n| WT_binop_GreaterThan:\n  \"P \\<turnstile> Integer\\<guillemotleft>GreaterThan\\<guillemotright>Integer :: Boolean\"\n\n| WT_binop_GreaterOrEqual:\n  \"P \\<turnstile> Integer\\<guillemotleft>GreaterOrEqual\\<guillemotright>Integer :: Boolean\"\n\n| WT_binop_Add:\n  \"P \\<turnstile> Integer\\<guillemotleft>Add\\<guillemotright>Integer :: Integer\"\n\n| WT_binop_Subtract:\n  \"P \\<turnstile> Integer\\<guillemotleft>Subtract\\<guillemotright>Integer :: Integer\"\n\n| WT_binop_Mult:\n  \"P \\<turnstile> Integer\\<guillemotleft>Mult\\<guillemotright>Integer :: Integer\"\n\n| WT_binop_Div:\n  \"P \\<turnstile> Integer\\<guillemotleft>Div\\<guillemotright>Integer :: Integer\"\n\n| WT_binop_Mod:\n  \"P \\<turnstile> Integer\\<guillemotleft>Mod\\<guillemotright>Integer :: Integer\"\n\n| WT_binop_BinAnd_Bool:\n  \"P \\<turnstile> Boolean\\<guillemotleft>BinAnd\\<guillemotright>Boolean :: Boolean\"\n\n| WT_binop_BinAnd_Int:\n  \"P \\<turnstile> Integer\\<guillemotleft>BinAnd\\<guillemotright>Integer :: Integer\"\n\n| WT_binop_BinOr_Bool:\n  \"P \\<turnstile> Boolean\\<guillemotleft>BinOr\\<guillemotright>Boolean :: Boolean\"\n\n| WT_binop_BinOr_Int:\n  \"P \\<turnstile> Integer\\<guillemotleft>BinOr\\<guillemotright>Integer :: Integer\"\n\n| WT_binop_BinXor_Bool:\n  \"P \\<turnstile> Boolean\\<guillemotleft>BinXor\\<guillemotright>Boolean :: Boolean\"\n\n| WT_binop_BinXor_Int:\n  \"P \\<turnstile> Integer\\<guillemotleft>BinXor\\<guillemotright>Integer :: Integer\"\n\n| WT_binop_ShiftLeft:\n  \"P \\<turnstile> Integer\\<guillemotleft>ShiftLeft\\<guillemotright>Integer :: Integer\"\n\n| WT_binop_ShiftRightZeros:\n  \"P \\<turnstile> Integer\\<guillemotleft>ShiftRightZeros\\<guillemotright>Integer :: Integer\"\n\n| WT_binop_ShiftRightSigned:\n  \"P \\<turnstile> Integer\\<guillemotleft>ShiftRightSigned\\<guillemotright>Integer :: Integer\""], ["", "lemma WT_binopI [intro]:\n  \"P \\<turnstile> T1 \\<le> T2 \\<or> P \\<turnstile> T2 \\<le> T1 \\<Longrightarrow> P \\<turnstile> T1\\<guillemotleft>Eq\\<guillemotright>T2 :: Boolean\"\n  \"P \\<turnstile> T1 \\<le> T2 \\<or> P \\<turnstile> T2 \\<le> T1 \\<Longrightarrow> P \\<turnstile> T1\\<guillemotleft>NotEq\\<guillemotright>T2 :: Boolean\"\n  \"bop = Add \\<or> bop = Subtract \\<or> bop = Mult \\<or> bop = Mod \\<or> bop = Div \\<or> bop = BinAnd \\<or> bop = BinOr \\<or> bop = BinXor \\<or> \n   bop = ShiftLeft \\<or> bop = ShiftRightZeros \\<or> bop = ShiftRightSigned\n   \\<Longrightarrow> P \\<turnstile> Integer\\<guillemotleft>bop\\<guillemotright>Integer :: Integer\"\n  \"bop = LessThan \\<or> bop = LessOrEqual \\<or> bop = GreaterThan \\<or> bop = GreaterOrEqual \\<Longrightarrow> P \\<turnstile> Integer\\<guillemotleft>bop\\<guillemotright>Integer :: Boolean\"\n  \"bop = BinAnd \\<or> bop = BinOr \\<or> bop = BinXor \\<Longrightarrow> P \\<turnstile> Boolean\\<guillemotleft>bop\\<guillemotright>Boolean :: Boolean\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((P \\<turnstile> T1 \\<le> T2 \\<or>\n      P \\<turnstile> T2 \\<le> T1 \\<Longrightarrow>\n      P \\<turnstile> T1\\<guillemotleft>Eq\\<guillemotright>T2 :: Boolean) &&&\n     (P \\<turnstile> T1 \\<le> T2 \\<or>\n      P \\<turnstile> T2 \\<le> T1 \\<Longrightarrow>\n      P \\<turnstile> T1\\<guillemotleft>NotEq\\<guillemotright>T2 :: Boolean)) &&&\n    (bop = Add \\<or>\n     bop = Subtract \\<or>\n     bop = Mult \\<or>\n     bop = Mod \\<or>\n     bop = Div \\<or>\n     bop = BinAnd \\<or>\n     bop = BinOr \\<or>\n     bop = BinXor \\<or>\n     bop = ShiftLeft \\<or>\n     bop = ShiftRightZeros \\<or> bop = ShiftRightSigned \\<Longrightarrow>\n     P \\<turnstile> Integer\\<guillemotleft>bop\\<guillemotright>Integer :: Integer) &&&\n    (bop = LessThan \\<or>\n     bop = LessOrEqual \\<or>\n     bop = GreaterThan \\<or> bop = GreaterOrEqual \\<Longrightarrow>\n     P \\<turnstile> Integer\\<guillemotleft>bop\\<guillemotright>Integer :: Boolean) &&&\n    (bop = BinAnd \\<or> bop = BinOr \\<or> bop = BinXor \\<Longrightarrow>\n     P \\<turnstile> Boolean\\<guillemotleft>bop\\<guillemotright>Boolean :: Boolean)", "by(auto intro: WT_binop.intros)"], ["", "inductive_cases [elim]:\n  \"P \\<turnstile> T1\\<guillemotleft>Eq\\<guillemotright>T2 :: T\"\n  \"P \\<turnstile> T1\\<guillemotleft>NotEq\\<guillemotright>T2 :: T\"\n  \"P \\<turnstile> T1\\<guillemotleft>LessThan\\<guillemotright>T2 :: T\"\n  \"P \\<turnstile> T1\\<guillemotleft>LessOrEqual\\<guillemotright>T2 :: T\"\n  \"P \\<turnstile> T1\\<guillemotleft>GreaterThan\\<guillemotright>T2 :: T\"\n  \"P \\<turnstile> T1\\<guillemotleft>GreaterOrEqual\\<guillemotright>T2 :: T\"\n  \"P \\<turnstile> T1\\<guillemotleft>Add\\<guillemotright>T2 :: T\"\n  \"P \\<turnstile> T1\\<guillemotleft>Subtract\\<guillemotright>T2 :: T\"\n  \"P \\<turnstile> T1\\<guillemotleft>Mult\\<guillemotright>T2 :: T\"\n  \"P \\<turnstile> T1\\<guillemotleft>Div\\<guillemotright>T2 :: T\"\n  \"P \\<turnstile> T1\\<guillemotleft>Mod\\<guillemotright>T2 :: T\"\n  \"P \\<turnstile> T1\\<guillemotleft>BinAnd\\<guillemotright>T2 :: T\"\n  \"P \\<turnstile> T1\\<guillemotleft>BinOr\\<guillemotright>T2 :: T\"\n  \"P \\<turnstile> T1\\<guillemotleft>BinXor\\<guillemotright>T2 :: T\"\n  \"P \\<turnstile> T1\\<guillemotleft>ShiftLeft\\<guillemotright>T2 :: T\"\n  \"P \\<turnstile> T1\\<guillemotleft>ShiftRightZeros\\<guillemotright>T2 :: T\"\n  \"P \\<turnstile> T1\\<guillemotleft>ShiftRightSigned\\<guillemotright>T2 :: T\""], ["", "lemma WT_binop_fun: \"\\<lbrakk> P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 :: T; P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 :: T' \\<rbrakk> \\<Longrightarrow> T = T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 :: T;\n     P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 :: T'\\<rbrakk>\n    \\<Longrightarrow> T = T'", "by(cases bop)(auto)"], ["", "lemma WT_binop_is_type:\n  \"\\<lbrakk> P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 :: T; is_type P T1; is_type P T2 \\<rbrakk> \\<Longrightarrow> is_type P T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 :: T;\n     is_type P T1; is_type P T2\\<rbrakk>\n    \\<Longrightarrow> is_type P T", "by(cases bop) auto"], ["", "inductive WTrt_binop :: \"'m prog \\<Rightarrow> ty \\<Rightarrow> bop \\<Rightarrow> ty \\<Rightarrow> ty \\<Rightarrow> bool\" (\"_ \\<turnstile> _\\<guillemotleft>_\\<guillemotright>_ : _\" [51,0,0,0,51] 50)\nwhere\n  WTrt_binop_Eq:\n  \"P \\<turnstile> T1\\<guillemotleft>Eq\\<guillemotright>T2 : Boolean\"\n\n| WTrt_binop_NotEq:\n  \"P \\<turnstile> T1\\<guillemotleft>NotEq\\<guillemotright>T2 : Boolean\"\n\n| WTrt_binop_LessThan:\n  \"P \\<turnstile> Integer\\<guillemotleft>LessThan\\<guillemotright>Integer : Boolean\"\n\n| WTrt_binop_LessOrEqual:\n  \"P \\<turnstile> Integer\\<guillemotleft>LessOrEqual\\<guillemotright>Integer : Boolean\"\n\n| WTrt_binop_GreaterThan:\n  \"P \\<turnstile> Integer\\<guillemotleft>GreaterThan\\<guillemotright>Integer : Boolean\"\n\n| WTrt_binop_GreaterOrEqual:\n  \"P \\<turnstile> Integer\\<guillemotleft>GreaterOrEqual\\<guillemotright>Integer : Boolean\"\n\n| WTrt_binop_Add:\n  \"P \\<turnstile> Integer\\<guillemotleft>Add\\<guillemotright>Integer : Integer\"\n\n| WTrt_binop_Subtract:\n  \"P \\<turnstile> Integer\\<guillemotleft>Subtract\\<guillemotright>Integer : Integer\"\n\n| WTrt_binop_Mult:\n  \"P \\<turnstile> Integer\\<guillemotleft>Mult\\<guillemotright>Integer : Integer\"\n\n| WTrt_binop_Div:\n  \"P \\<turnstile> Integer\\<guillemotleft>Div\\<guillemotright>Integer : Integer\"\n\n| WTrt_binop_Mod:\n  \"P \\<turnstile> Integer\\<guillemotleft>Mod\\<guillemotright>Integer : Integer\"\n\n| WTrt_binop_BinAnd_Bool:\n  \"P \\<turnstile> Boolean\\<guillemotleft>BinAnd\\<guillemotright>Boolean : Boolean\"\n\n| WTrt_binop_BinAnd_Int:\n  \"P \\<turnstile> Integer\\<guillemotleft>BinAnd\\<guillemotright>Integer : Integer\"\n\n| WTrt_binop_BinOr_Bool:\n  \"P \\<turnstile> Boolean\\<guillemotleft>BinOr\\<guillemotright>Boolean : Boolean\"\n\n| WTrt_binop_BinOr_Int:\n  \"P \\<turnstile> Integer\\<guillemotleft>BinOr\\<guillemotright>Integer : Integer\"\n\n| WTrt_binop_BinXor_Bool:\n  \"P \\<turnstile> Boolean\\<guillemotleft>BinXor\\<guillemotright>Boolean : Boolean\"\n\n| WTrt_binop_BinXor_Int:\n  \"P \\<turnstile> Integer\\<guillemotleft>BinXor\\<guillemotright>Integer : Integer\"\n\n| WTrt_binop_ShiftLeft:\n  \"P \\<turnstile> Integer\\<guillemotleft>ShiftLeft\\<guillemotright>Integer : Integer\"\n\n| WTrt_binop_ShiftRightZeros:\n  \"P \\<turnstile> Integer\\<guillemotleft>ShiftRightZeros\\<guillemotright>Integer : Integer\"\n\n| WTrt_binop_ShiftRightSigned:\n  \"P \\<turnstile> Integer\\<guillemotleft>ShiftRightSigned\\<guillemotright>Integer : Integer\""], ["", "lemma WTrt_binopI [intro]:\n  \"P \\<turnstile> T1\\<guillemotleft>Eq\\<guillemotright>T2 : Boolean\"\n  \"P \\<turnstile> T1\\<guillemotleft>NotEq\\<guillemotright>T2 : Boolean\"\n  \"bop = Add \\<or> bop = Subtract \\<or> bop = Mult \\<or> bop = Div \\<or> bop = Mod \\<or> bop = BinAnd \\<or> bop = BinOr \\<or> bop = BinXor \\<or>\n   bop = ShiftLeft \\<or> bop = ShiftRightZeros \\<or> bop = ShiftRightSigned\n   \\<Longrightarrow> P \\<turnstile> Integer\\<guillemotleft>bop\\<guillemotright>Integer : Integer\"\n  \"bop = LessThan \\<or> bop = LessOrEqual \\<or> bop = GreaterThan \\<or> bop = GreaterOrEqual \\<Longrightarrow> P \\<turnstile> Integer\\<guillemotleft>bop\\<guillemotright>Integer : Boolean\"\n  \"bop = BinAnd \\<or> bop = BinOr \\<or> bop = BinXor \\<Longrightarrow> P \\<turnstile> Boolean\\<guillemotleft>bop\\<guillemotright>Boolean : Boolean\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<turnstile> T1\\<guillemotleft>Eq\\<guillemotright>T2 : Boolean &&&\n     P \\<turnstile> T1\\<guillemotleft>NotEq\\<guillemotright>T2 : Boolean) &&&\n    (bop = Add \\<or>\n     bop = Subtract \\<or>\n     bop = Mult \\<or>\n     bop = Div \\<or>\n     bop = Mod \\<or>\n     bop = BinAnd \\<or>\n     bop = BinOr \\<or>\n     bop = BinXor \\<or>\n     bop = ShiftLeft \\<or>\n     bop = ShiftRightZeros \\<or> bop = ShiftRightSigned \\<Longrightarrow>\n     P \\<turnstile> Integer\\<guillemotleft>bop\\<guillemotright>Integer : Integer) &&&\n    (bop = LessThan \\<or>\n     bop = LessOrEqual \\<or>\n     bop = GreaterThan \\<or> bop = GreaterOrEqual \\<Longrightarrow>\n     P \\<turnstile> Integer\\<guillemotleft>bop\\<guillemotright>Integer : Boolean) &&&\n    (bop = BinAnd \\<or> bop = BinOr \\<or> bop = BinXor \\<Longrightarrow>\n     P \\<turnstile> Boolean\\<guillemotleft>bop\\<guillemotright>Boolean : Boolean)", "by(auto intro: WTrt_binop.intros)"], ["", "inductive_cases WTrt_binop_cases [elim]:\n  \"P \\<turnstile> T1\\<guillemotleft>Eq\\<guillemotright>T2 : T\"\n  \"P \\<turnstile> T1\\<guillemotleft>NotEq\\<guillemotright>T2 : T\"\n  \"P \\<turnstile> T1\\<guillemotleft>LessThan\\<guillemotright>T2 : T\"\n  \"P \\<turnstile> T1\\<guillemotleft>LessOrEqual\\<guillemotright>T2 : T\"\n  \"P \\<turnstile> T1\\<guillemotleft>GreaterThan\\<guillemotright>T2 : T\"\n  \"P \\<turnstile> T1\\<guillemotleft>GreaterOrEqual\\<guillemotright>T2 : T\"\n  \"P \\<turnstile> T1\\<guillemotleft>Add\\<guillemotright>T2 : T\"\n  \"P \\<turnstile> T1\\<guillemotleft>Subtract\\<guillemotright>T2 : T\"\n  \"P \\<turnstile> T1\\<guillemotleft>Mult\\<guillemotright>T2 : T\"\n  \"P \\<turnstile> T1\\<guillemotleft>Div\\<guillemotright>T2 : T\"\n  \"P \\<turnstile> T1\\<guillemotleft>Mod\\<guillemotright>T2 : T\"\n  \"P \\<turnstile> T1\\<guillemotleft>BinAnd\\<guillemotright>T2 : T\"\n  \"P \\<turnstile> T1\\<guillemotleft>BinOr\\<guillemotright>T2 : T\"\n  \"P \\<turnstile> T1\\<guillemotleft>BinXor\\<guillemotright>T2 : T\"\n  \"P \\<turnstile> T1\\<guillemotleft>ShiftLeft\\<guillemotright>T2 : T\"\n  \"P \\<turnstile> T1\\<guillemotleft>ShiftRightZeros\\<guillemotright>T2 : T\"\n  \"P \\<turnstile> T1\\<guillemotleft>ShiftRightSigned\\<guillemotright>T2 : T\""], ["", "inductive_simps WTrt_binop_simps [simp]:\n  \"P \\<turnstile> T1\\<guillemotleft>Eq\\<guillemotright>T2 : T\"\n  \"P \\<turnstile> T1\\<guillemotleft>NotEq\\<guillemotright>T2 : T\"\n  \"P \\<turnstile> T1\\<guillemotleft>LessThan\\<guillemotright>T2 : T\"\n  \"P \\<turnstile> T1\\<guillemotleft>LessOrEqual\\<guillemotright>T2 : T\"\n  \"P \\<turnstile> T1\\<guillemotleft>GreaterThan\\<guillemotright>T2 : T\"\n  \"P \\<turnstile> T1\\<guillemotleft>GreaterOrEqual\\<guillemotright>T2 : T\"\n  \"P \\<turnstile> T1\\<guillemotleft>Add\\<guillemotright>T2 : T\"\n  \"P \\<turnstile> T1\\<guillemotleft>Subtract\\<guillemotright>T2 : T\"\n  \"P \\<turnstile> T1\\<guillemotleft>Mult\\<guillemotright>T2 : T\"\n  \"P \\<turnstile> T1\\<guillemotleft>Div\\<guillemotright>T2 : T\"\n  \"P \\<turnstile> T1\\<guillemotleft>Mod\\<guillemotright>T2 : T\"\n  \"P \\<turnstile> T1\\<guillemotleft>BinAnd\\<guillemotright>T2 : T\"\n  \"P \\<turnstile> T1\\<guillemotleft>BinOr\\<guillemotright>T2 : T\"\n  \"P \\<turnstile> T1\\<guillemotleft>BinXor\\<guillemotright>T2 : T\"\n  \"P \\<turnstile> T1\\<guillemotleft>ShiftLeft\\<guillemotright>T2 : T\"\n  \"P \\<turnstile> T1\\<guillemotleft>ShiftRightZeros\\<guillemotright>T2 : T\"\n  \"P \\<turnstile> T1\\<guillemotleft>ShiftRightSigned\\<guillemotright>T2 : T\""], ["", "fun binop_relevant_class :: \"bop \\<Rightarrow> 'm prog \\<Rightarrow> cname \\<Rightarrow> bool\"\nwhere\n  \"binop_relevant_class Div = (\\<lambda>P C. P \\<turnstile> ArithmeticException \\<preceq>\\<^sup>* C )\"\n| \"binop_relevant_class Mod = (\\<lambda>P C. P \\<turnstile> ArithmeticException \\<preceq>\\<^sup>* C )\"\n| \"binop_relevant_class _ = (\\<lambda>P C. False)\""], ["", "lemma WT_binop_WTrt_binop:\n  \"P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 :: T \\<Longrightarrow> P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 :: T \\<Longrightarrow>\n    P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T", "by(auto elim: WT_binop.cases)"], ["", "context heap begin"], ["", "lemma binop_progress:\n  \"\\<lbrakk> typeof\\<^bsub>h\\<^esub> v1 = \\<lfloor>T1\\<rfloor>; typeof\\<^bsub>h\\<^esub> v2 = \\<lfloor>T2\\<rfloor>; P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T \\<rbrakk>\n  \\<Longrightarrow> \\<exists>va. binop bop v1 v2 = \\<lfloor>va\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>typeof\\<^bsub>h\\<^esub> v1 = \\<lfloor>T1\\<rfloor>;\n     typeof\\<^bsub>h\\<^esub> v2 = \\<lfloor>T2\\<rfloor>;\n     P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T\\<rbrakk>\n    \\<Longrightarrow> \\<exists>va. binop bop v1 v2 = \\<lfloor>va\\<rfloor>", "by(cases bop)(auto del: disjCI split del: if_split)"], ["", "lemma binop_type:\n  assumes wf: \"wf_prog wf_md P\"\n  and pre: \"preallocated h\"\n  and type: \"typeof\\<^bsub>h\\<^esub> v1 = \\<lfloor>T1\\<rfloor>\" \"typeof\\<^bsub>h\\<^esub> v2 = \\<lfloor>T2\\<rfloor>\" \"P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T\"\n  shows \"binop bop v1 v2 = \\<lfloor>Inl v\\<rfloor> \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T\"\n  and \"binop bop v1 v2 = \\<lfloor>Inr a\\<rfloor> \\<Longrightarrow> P,h \\<turnstile> Addr a :\\<le> Class Throwable\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (binop bop v1 v2 = \\<lfloor>Inl v\\<rfloor> \\<Longrightarrow>\n     P,h \\<turnstile> v :\\<le> T) &&&\n    (binop bop v1 v2 = \\<lfloor>Inr a\\<rfloor> \\<Longrightarrow>\n     P,h \\<turnstile> Addr a :\\<le> Class Throwable)", "using type"], ["proof (prove)\nusing this:\n  typeof\\<^bsub>h\\<^esub> v1 = \\<lfloor>T1\\<rfloor>\n  typeof\\<^bsub>h\\<^esub> v2 = \\<lfloor>T2\\<rfloor>\n  P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T\n\ngoal (1 subgoal):\n 1. (binop bop v1 v2 = \\<lfloor>Inl v\\<rfloor> \\<Longrightarrow>\n     P,h \\<turnstile> v :\\<le> T) &&&\n    (binop bop v1 v2 = \\<lfloor>Inr a\\<rfloor> \\<Longrightarrow>\n     P,h \\<turnstile> Addr a :\\<le> Class Throwable)", "apply(case_tac [!] bop)"], ["proof (prove)\ngoal (34 subgoals):\n 1. \\<lbrakk>binop bop v1 v2 = \\<lfloor>Inl v\\<rfloor>;\n     typeof\\<^bsub>h\\<^esub> v1 = \\<lfloor>T1\\<rfloor>;\n     typeof\\<^bsub>h\\<^esub> v2 = \\<lfloor>T2\\<rfloor>;\n     P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T;\n     bop = Eq\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T\n 2. \\<lbrakk>binop bop v1 v2 = \\<lfloor>Inl v\\<rfloor>;\n     typeof\\<^bsub>h\\<^esub> v1 = \\<lfloor>T1\\<rfloor>;\n     typeof\\<^bsub>h\\<^esub> v2 = \\<lfloor>T2\\<rfloor>;\n     P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T;\n     bop = NotEq\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T\n 3. \\<lbrakk>binop bop v1 v2 = \\<lfloor>Inl v\\<rfloor>;\n     typeof\\<^bsub>h\\<^esub> v1 = \\<lfloor>T1\\<rfloor>;\n     typeof\\<^bsub>h\\<^esub> v2 = \\<lfloor>T2\\<rfloor>;\n     P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T;\n     bop = LessThan\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T\n 4. \\<lbrakk>binop bop v1 v2 = \\<lfloor>Inl v\\<rfloor>;\n     typeof\\<^bsub>h\\<^esub> v1 = \\<lfloor>T1\\<rfloor>;\n     typeof\\<^bsub>h\\<^esub> v2 = \\<lfloor>T2\\<rfloor>;\n     P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T;\n     bop = LessOrEqual\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T\n 5. \\<lbrakk>binop bop v1 v2 = \\<lfloor>Inl v\\<rfloor>;\n     typeof\\<^bsub>h\\<^esub> v1 = \\<lfloor>T1\\<rfloor>;\n     typeof\\<^bsub>h\\<^esub> v2 = \\<lfloor>T2\\<rfloor>;\n     P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T;\n     bop = GreaterThan\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T\n 6. \\<lbrakk>binop bop v1 v2 = \\<lfloor>Inl v\\<rfloor>;\n     typeof\\<^bsub>h\\<^esub> v1 = \\<lfloor>T1\\<rfloor>;\n     typeof\\<^bsub>h\\<^esub> v2 = \\<lfloor>T2\\<rfloor>;\n     P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T;\n     bop = GreaterOrEqual\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T\n 7. \\<lbrakk>binop bop v1 v2 = \\<lfloor>Inl v\\<rfloor>;\n     typeof\\<^bsub>h\\<^esub> v1 = \\<lfloor>T1\\<rfloor>;\n     typeof\\<^bsub>h\\<^esub> v2 = \\<lfloor>T2\\<rfloor>;\n     P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T;\n     bop = Add\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T\n 8. \\<lbrakk>binop bop v1 v2 = \\<lfloor>Inl v\\<rfloor>;\n     typeof\\<^bsub>h\\<^esub> v1 = \\<lfloor>T1\\<rfloor>;\n     typeof\\<^bsub>h\\<^esub> v2 = \\<lfloor>T2\\<rfloor>;\n     P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T;\n     bop = Subtract\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T\n 9. \\<lbrakk>binop bop v1 v2 = \\<lfloor>Inl v\\<rfloor>;\n     typeof\\<^bsub>h\\<^esub> v1 = \\<lfloor>T1\\<rfloor>;\n     typeof\\<^bsub>h\\<^esub> v2 = \\<lfloor>T2\\<rfloor>;\n     P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T;\n     bop = Mult\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T\n 10. \\<lbrakk>binop bop v1 v2 = \\<lfloor>Inl v\\<rfloor>;\n      typeof\\<^bsub>h\\<^esub> v1 = \\<lfloor>T1\\<rfloor>;\n      typeof\\<^bsub>h\\<^esub> v2 = \\<lfloor>T2\\<rfloor>;\n      P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T;\n      bop = Div\\<rbrakk>\n     \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T\nA total of 34 subgoals...", "apply(auto split: if_split_asm simp add: conf_def wf_preallocatedD[OF wf pre])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma binop_relevant_class:\n  assumes wf: \"wf_prog wf_md P\"\n  and pre: \"preallocated h\"\n  and bop: \"binop bop v1 v2 = \\<lfloor>Inr a\\<rfloor>\"\n  and sup: \"P \\<turnstile> cname_of h a \\<preceq>\\<^sup>* C\"\n  shows \"binop_relevant_class bop P C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. binop_relevant_class bop P C", "using assms"], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  preallocated h\n  binop bop v1 v2 = \\<lfloor>Inr a\\<rfloor>\n  P \\<turnstile> cname_of h a \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. binop_relevant_class bop P C", "by(cases bop)(auto split: if_split_asm)"], ["", "end"], ["", "lemma WTrt_binop_fun: \"\\<lbrakk> P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T; P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T' \\<rbrakk> \\<Longrightarrow> T = T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T;\n     P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T'\\<rbrakk>\n    \\<Longrightarrow> T = T'", "by(cases bop)(auto)"], ["", "lemma WTrt_binop_THE [simp]: \"P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T \\<Longrightarrow> The (WTrt_binop P T1 bop T2) = T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T \\<Longrightarrow>\n    The (WTrt_binop P T1 bop T2) = T", "by(auto dest: WTrt_binop_fun)"], ["", "lemma WTrt_binop_widen_mono:\n  \"\\<lbrakk> P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T; P \\<turnstile> T1' \\<le> T1; P \\<turnstile> T2' \\<le> T2 \\<rbrakk> \\<Longrightarrow> \\<exists>T'. P \\<turnstile> T1'\\<guillemotleft>bop\\<guillemotright>T2' : T' \\<and> P \\<turnstile> T' \\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T;\n     P \\<turnstile> T1' \\<le> T1; P \\<turnstile> T2' \\<le> T2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T'.\n                         P \\<turnstile> T1'\\<guillemotleft>bop\\<guillemotright>T2' : T' \\<and>\n                         P \\<turnstile> T' \\<le> T", "by(cases bop)(auto elim!: WTrt_binop_cases)"], ["", "lemma WTrt_binop_is_type:\n  \"\\<lbrakk> P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T; is_type P T1; is_type P T2 \\<rbrakk> \\<Longrightarrow> is_type P T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T;\n     is_type P T1; is_type P T2\\<rbrakk>\n    \\<Longrightarrow> is_type P T", "by(cases bop) auto"], ["", "subsection \\<open>Code generator setup\\<close>"], ["", "lemmas [code] =\n  heap_base.binop_Div.simps\n  heap_base.binop_Mod.simps\n  heap_base.binop.simps"], ["", "code_pred \n  (modes: i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> bool, i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> bool)\n  WT_binop"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "code_pred\n  (modes: i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> bool, i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> bool)\n  WTrt_binop"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma eval_WTrt_binop_i_i_i_i_o:\n  \"Predicate.eval (WTrt_binop_i_i_i_i_o P T1 bop T2) T \\<longleftrightarrow> P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred.eval (WTrt_binop_i_i_i_i_o P T1 bop T2) T =\n    (P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)", "by(auto elim: WTrt_binop_i_i_i_i_oE intro: WTrt_binop_i_i_i_i_oI)"], ["", "lemma the_WTrt_binop_code:\n  \"(THE T. P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T) = Predicate.the (WTrt_binop_i_i_i_i_o P T1 bop T2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE T. P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T) =\n    Predicate.the (WTrt_binop_i_i_i_i_o P T1 bop T2)", "by(simp add: Predicate.the_def eval_WTrt_binop_i_i_i_i_o)"], ["", "end"]]}