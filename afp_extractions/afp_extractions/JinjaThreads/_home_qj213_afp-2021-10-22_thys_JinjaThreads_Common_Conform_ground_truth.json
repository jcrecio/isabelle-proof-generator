{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Common/Conform.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemmas hconf_heap_ops_mono = \n  hconf_allocate_mono\n  hconf_heap_write_mono", "lemma conf_Null [simp]: \"P,h \\<turnstile> Null :\\<le> T  =  P \\<turnstile> NT \\<le> T\"", "lemma typeof_conf[simp]: \"typeof\\<^bsub>h\\<^esub> v = Some T \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T\"", "lemma typeof_lit_conf[simp]: \"typeof v = Some T \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T\"", "lemma defval_conf[simp]: \"P,h \\<turnstile> default_val T :\\<le> T\"", "lemma conf_widen: \"P,h \\<turnstile> v :\\<le> T \\<Longrightarrow> P \\<turnstile> T \\<le> T' \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'\"", "lemma conf_sys_xcpt:\n  \"\\<lbrakk>preallocated h; C \\<in> sys_xcpts\\<rbrakk> \\<Longrightarrow> P,h \\<turnstile> Addr (addr_of_sys_xcpt C) :\\<le> Class C\"", "lemma conf_NT [iff]: \"P,h \\<turnstile> v :\\<le> NT = (v = Null)\"", "lemma is_IntgI: \"P,h \\<turnstile> v :\\<le> Integer \\<Longrightarrow> is_Intg v\"", "lemma is_BoolI: \"P,h \\<turnstile> v :\\<le> Boolean \\<Longrightarrow> is_Bool v\"", "lemma is_RefI: \"P,h \\<turnstile> v :\\<le> T \\<Longrightarrow> is_refT T \\<Longrightarrow> is_Ref v\"", "lemma non_npD:\n  \"\\<lbrakk> v \\<noteq> Null; P,h \\<turnstile> v :\\<le> Class C; C \\<noteq> Object \\<rbrakk> \n  \\<Longrightarrow> \\<exists>a C'. v = Addr a \\<and> typeof_addr h a = \\<lfloor>Class_type C'\\<rfloor> \\<and> P \\<turnstile> C' \\<preceq>\\<^sup>* C\"", "lemma non_npD2:\n  \"\\<lbrakk>v \\<noteq> Null; P,h \\<turnstile> v :\\<le> Class C \\<rbrakk>\n  \\<Longrightarrow> \\<exists>a hT. v = Addr a \\<and> typeof_addr h a = \\<lfloor>hT\\<rfloor> \\<and> P \\<turnstile> class_type_of hT \\<preceq>\\<^sup>* C\"", "lemma conf_hext: \"\\<lbrakk> h \\<unlhd> h'; P,h \\<turnstile> v :\\<le> T \\<rbrakk> \\<Longrightarrow> P,h' \\<turnstile> v :\\<le> T\"", "lemma conf_heap_ops_mono:\n  assumes \"P,h \\<turnstile> v :\\<le> T\"\n  shows conf_allocate_mono: \"(h', a) \\<in> allocate h hT \\<Longrightarrow> P,h' \\<turnstile> v :\\<le> T\"\n  and conf_heap_write_mono: \"heap_write h a al v' h' \\<Longrightarrow> P,h' \\<turnstile> v :\\<le> T\"", "lemma confs_widens [trans]: \"\\<lbrakk>P,h \\<turnstile> vs [:\\<le>] Ts; P \\<turnstile> Ts [\\<le>] Ts'\\<rbrakk> \\<Longrightarrow> P,h \\<turnstile> vs [:\\<le>] Ts'\"", "lemma confs_rev: \"P,h \\<turnstile> rev s [:\\<le>] t = (P,h \\<turnstile> s [:\\<le>] rev t)\"", "lemma confs_conv_map:\n  \"P,h \\<turnstile> vs [:\\<le>] Ts' = (\\<exists>Ts. map typeof\\<^bsub>h\\<^esub> vs = map Some Ts \\<and> P \\<turnstile> Ts [\\<le>] Ts')\"", "lemma confs_Cons2: \"P,h \\<turnstile> xs [:\\<le>] y#ys = (\\<exists>z zs. xs = z#zs \\<and> P,h \\<turnstile> z :\\<le> y \\<and> P,h \\<turnstile> zs [:\\<le>] ys)\"", "lemma confs_hext: \"P,h \\<turnstile> vs [:\\<le>] Ts \\<Longrightarrow> h \\<unlhd> h' \\<Longrightarrow> P,h' \\<turnstile> vs [:\\<le>] Ts\"", "lemma lconf_upd:\n  \"\\<lbrakk> P,h \\<turnstile> l (:\\<le>) E; P,h \\<turnstile> v :\\<le> T; E V = Some T \\<rbrakk> \\<Longrightarrow> P,h \\<turnstile> l(V\\<mapsto>v) (:\\<le>) E\"", "lemma lconf_empty [iff]: \"P,h \\<turnstile> Map.empty (:\\<le>) E\"", "lemma lconf_upd2: \"\\<lbrakk>P,h \\<turnstile> l (:\\<le>) E; P,h \\<turnstile> v :\\<le> T\\<rbrakk> \\<Longrightarrow> P,h \\<turnstile> l(V\\<mapsto>v) (:\\<le>) E(V\\<mapsto>T)\"", "lemma lconf_hext: \"\\<lbrakk> P,h \\<turnstile> l (:\\<le>) E; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow> P,h' \\<turnstile> l (:\\<le>) E\"", "lemma tconfI: \"\\<lbrakk> typeof_addr h (thread_id2addr t) = \\<lfloor>Class_type C\\<rfloor>; P \\<turnstile> C \\<preceq>\\<^sup>* Thread \\<rbrakk> \\<Longrightarrow> P,h \\<turnstile> t \\<surd>t\"", "lemma tconfD: \"P,h \\<turnstile> t \\<surd>t \\<Longrightarrow> \\<exists>C. typeof_addr h (thread_id2addr t) = \\<lfloor>Class_type C\\<rfloor> \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* Thread\"", "lemma tconf_hext_mono: \"\\<lbrakk> P,h \\<turnstile> t \\<surd>t; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow> P,h' \\<turnstile> t \\<surd>t\"", "lemma tconf_heap_ops_mono:\n  assumes \"P,h \\<turnstile> t \\<surd>t\"\n  shows tconf_allocate_mono: \"(h', a) \\<in> allocate h hT \\<Longrightarrow> P,h' \\<turnstile> t \\<surd>t\"\n  and tconf_heap_write_mono: \"heap_write h a al v h' \\<Longrightarrow> P,h' \\<turnstile> t \\<surd>t\"", "lemma tconf_start_heap_start_tid:\n  \"\\<lbrakk> start_heap_ok; wf_syscls P \\<rbrakk> \\<Longrightarrow> P,start_heap \\<turnstile> start_tid \\<surd>t\"", "lemma start_heap_write_typeable:\n  assumes \"WriteMem ad al v \\<in> set start_heap_obs\"\n  shows \"\\<exists>T. P,start_heap \\<turnstile> ad@al : T \\<and> P,start_heap \\<turnstile> v :\\<le> T\""], "translations": [["", "lemmas hconf_heap_ops_mono = \n  hconf_allocate_mono\n  hconf_heap_write_mono"], ["", "end"], ["", "subsection\\<open>Value conformance \\<open>:\\<le>\\<close>\\<close>"], ["", "context heap_base begin"], ["", "lemma conf_Null [simp]: \"P,h \\<turnstile> Null :\\<le> T  =  P \\<turnstile> NT \\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,h \\<turnstile> Null :\\<le> T) = P \\<turnstile> NT \\<le> T", "unfolding conf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>T'.\n        typeof\\<^bsub>h\\<^esub> Null = \\<lfloor>T'\\<rfloor> \\<and>\n        P \\<turnstile> T' \\<le> T) =\n    P \\<turnstile> NT \\<le> T", "by(simp (no_asm))"], ["", "lemma typeof_conf[simp]: \"typeof\\<^bsub>h\\<^esub> v = Some T \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor> \\<Longrightarrow>\n    P,h \\<turnstile> v :\\<le> T", "unfolding conf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor> \\<Longrightarrow>\n    \\<exists>T'.\n       typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T'\\<rfloor> \\<and>\n       P \\<turnstile> T' \\<le> T", "by (cases v) auto"], ["", "lemma typeof_lit_conf[simp]: \"typeof v = Some T \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof v = \\<lfloor>T\\<rfloor> \\<Longrightarrow>\n    P,h \\<turnstile> v :\\<le> T", "by (rule typeof_conf[OF typeof_lit_typeof])"], ["", "lemma defval_conf[simp]: \"P,h \\<turnstile> default_val T :\\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h \\<turnstile> default_val T :\\<le> T", "unfolding conf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T'.\n       typeof\\<^bsub>h\\<^esub> (default_val T) = \\<lfloor>T'\\<rfloor> \\<and>\n       P \\<turnstile> T' \\<le> T", "by (cases T) auto"], ["", "lemma conf_widen: \"P,h \\<turnstile> v :\\<le> T \\<Longrightarrow> P \\<turnstile> T \\<le> T' \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> v :\\<le> T; P \\<turnstile> T \\<le> T'\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'", "unfolding conf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>T'.\n                typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T'\\<rfloor> \\<and>\n                P \\<turnstile> T' \\<le> T;\n     P \\<turnstile> T \\<le> T'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T'a.\n                         typeof\\<^bsub>h\\<^esub> v =\n                         \\<lfloor>T'a\\<rfloor> \\<and>\n                         P \\<turnstile> T'a \\<le> T'", "by (cases v) (auto intro: widen_trans)"], ["", "lemma conf_sys_xcpt:\n  \"\\<lbrakk>preallocated h; C \\<in> sys_xcpts\\<rbrakk> \\<Longrightarrow> P,h \\<turnstile> Addr (addr_of_sys_xcpt C) :\\<le> Class C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>preallocated h; C \\<in> sys_xcpts\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> Addr\n  (addr_of_sys_xcpt C) :\\<le> Class C", "by(simp add: conf_def typeof_addr_sys_xcp)"], ["", "lemma conf_NT [iff]: \"P,h \\<turnstile> v :\\<le> NT = (v = Null)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,h \\<turnstile> v :\\<le> NT) = (v = Null)", "by (auto simp add: conf_def)"], ["", "lemma is_IntgI: \"P,h \\<turnstile> v :\\<le> Integer \\<Longrightarrow> is_Intg v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h \\<turnstile> v :\\<le> Integer \\<Longrightarrow> is_Intg v", "by (unfold conf_def) auto"], ["", "lemma is_BoolI: \"P,h \\<turnstile> v :\\<le> Boolean \\<Longrightarrow> is_Bool v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h \\<turnstile> v :\\<le> Boolean \\<Longrightarrow> is_Bool v", "by (unfold conf_def) auto"], ["", "lemma is_RefI: \"P,h \\<turnstile> v :\\<le> T \\<Longrightarrow> is_refT T \\<Longrightarrow> is_Ref v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> v :\\<le> T; is_refT T\\<rbrakk>\n    \\<Longrightarrow> is_Ref v", "by(cases v)(auto elim: is_refT.cases simp add: conf_def is_Ref_def)"], ["", "lemma non_npD:\n  \"\\<lbrakk> v \\<noteq> Null; P,h \\<turnstile> v :\\<le> Class C; C \\<noteq> Object \\<rbrakk> \n  \\<Longrightarrow> \\<exists>a C'. v = Addr a \\<and> typeof_addr h a = \\<lfloor>Class_type C'\\<rfloor> \\<and> P \\<turnstile> C' \\<preceq>\\<^sup>* C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<noteq> Null; P,h \\<turnstile> v :\\<le> Class C;\n     C \\<noteq> Object\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a C'.\n                         v = Addr a \\<and>\n                         typeof_addr h a =\n                         \\<lfloor>Class_type C'\\<rfloor> \\<and>\n                         P \\<turnstile> C' \\<preceq>\\<^sup>* C", "by(cases v)(auto simp add: conf_def widen_Class)"], ["", "lemma non_npD2:\n  \"\\<lbrakk>v \\<noteq> Null; P,h \\<turnstile> v :\\<le> Class C \\<rbrakk>\n  \\<Longrightarrow> \\<exists>a hT. v = Addr a \\<and> typeof_addr h a = \\<lfloor>hT\\<rfloor> \\<and> P \\<turnstile> class_type_of hT \\<preceq>\\<^sup>* C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<noteq> Null; P,h \\<turnstile> v :\\<le> Class C\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a hT.\n                         v = Addr a \\<and>\n                         typeof_addr h a = \\<lfloor>hT\\<rfloor> \\<and>\n                         P \\<turnstile> class_type_of hT \\<preceq>\\<^sup>* C", "by(cases v)(auto simp add: conf_def widen_Class)"], ["", "end"], ["", "context heap begin"], ["", "lemma conf_hext: \"\\<lbrakk> h \\<unlhd> h'; P,h \\<turnstile> v :\\<le> T \\<rbrakk> \\<Longrightarrow> P,h' \\<turnstile> v :\\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<unlhd> h'; P,h \\<turnstile> v :\\<le> T\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile> v :\\<le> T", "unfolding conf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<unlhd> h';\n     \\<exists>T'.\n        typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T'\\<rfloor> \\<and>\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T'.\n                         typeof\\<^bsub>h'\\<^esub> v =\n                         \\<lfloor>T'\\<rfloor> \\<and>\n                         P \\<turnstile> T' \\<le> T", "by(cases v)(auto dest: typeof_addr_hext_mono)"], ["", "lemma conf_heap_ops_mono:\n  assumes \"P,h \\<turnstile> v :\\<le> T\"\n  shows conf_allocate_mono: \"(h', a) \\<in> allocate h hT \\<Longrightarrow> P,h' \\<turnstile> v :\\<le> T\"\n  and conf_heap_write_mono: \"heap_write h a al v' h' \\<Longrightarrow> P,h' \\<turnstile> v :\\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((h', a) \\<in> allocate h hT \\<Longrightarrow>\n     P,h' \\<turnstile> v :\\<le> T) &&&\n    (heap_write h a al v' h' \\<Longrightarrow> P,h' \\<turnstile> v :\\<le> T)", "using assms"], ["proof (prove)\nusing this:\n  P,h \\<turnstile> v :\\<le> T\n\ngoal (1 subgoal):\n 1. ((h', a) \\<in> allocate h hT \\<Longrightarrow>\n     P,h' \\<turnstile> v :\\<le> T) &&&\n    (heap_write h a al v' h' \\<Longrightarrow> P,h' \\<turnstile> v :\\<le> T)", "by(auto intro: conf_hext dest: hext_heap_ops)"], ["", "end"], ["", "subsection\\<open>Value list conformance \\<open>[:\\<le>]\\<close>\\<close>"], ["", "context heap_base begin"], ["", "lemma confs_widens [trans]: \"\\<lbrakk>P,h \\<turnstile> vs [:\\<le>] Ts; P \\<turnstile> Ts [\\<le>] Ts'\\<rbrakk> \\<Longrightarrow> P,h \\<turnstile> vs [:\\<le>] Ts'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> vs [:\\<le>] Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> vs [:\\<le>] Ts'", "by (rule list_all2_trans)(rule conf_widen)"], ["", "lemma confs_rev: \"P,h \\<turnstile> rev s [:\\<le>] t = (P,h \\<turnstile> s [:\\<le>] rev t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,h \\<turnstile> rev s [:\\<le>] t) =\n    (P,h \\<turnstile> s [:\\<le>] rev t)", "by(rule list_all2_rev1)"], ["", "lemma confs_conv_map:\n  \"P,h \\<turnstile> vs [:\\<le>] Ts' = (\\<exists>Ts. map typeof\\<^bsub>h\\<^esub> vs = map Some Ts \\<and> P \\<turnstile> Ts [\\<le>] Ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,h \\<turnstile> vs [:\\<le>] Ts') =\n    (\\<exists>Ts.\n        map typeof\\<^bsub>h\\<^esub> vs = map Some Ts \\<and>\n        P \\<turnstile> Ts [\\<le>] Ts')", "apply(induct vs arbitrary: Ts')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Ts'.\n       (P,h \\<turnstile> [] [:\\<le>] Ts') =\n       (\\<exists>Ts.\n           map typeof\\<^bsub>h\\<^esub> [] = map Some Ts \\<and>\n           P \\<turnstile> Ts [\\<le>] Ts')\n 2. \\<And>a vs Ts'.\n       (\\<And>Ts'.\n           (P,h \\<turnstile> vs [:\\<le>] Ts') =\n           (\\<exists>Ts.\n               map typeof\\<^bsub>h\\<^esub> vs = map Some Ts \\<and>\n               P \\<turnstile> Ts [\\<le>] Ts')) \\<Longrightarrow>\n       (P,h \\<turnstile> a # vs [:\\<le>] Ts') =\n       (\\<exists>Ts.\n           map typeof\\<^bsub>h\\<^esub> (a # vs) = map Some Ts \\<and>\n           P \\<turnstile> Ts [\\<le>] Ts')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a vs Ts'.\n       (\\<And>Ts'.\n           (P,h \\<turnstile> vs [:\\<le>] Ts') =\n           (\\<exists>Ts.\n               map typeof\\<^bsub>h\\<^esub> vs = map Some Ts \\<and>\n               P \\<turnstile> Ts [\\<le>] Ts')) \\<Longrightarrow>\n       (P,h \\<turnstile> a # vs [:\\<le>] Ts') =\n       (\\<exists>Ts.\n           map typeof\\<^bsub>h\\<^esub> (a # vs) = map Some Ts \\<and>\n           P \\<turnstile> Ts [\\<le>] Ts')", "apply(case_tac Ts')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a vs Ts'.\n       \\<lbrakk>\\<And>Ts'.\n                   (P,h \\<turnstile> vs [:\\<le>] Ts') =\n                   (\\<exists>Ts.\n                       map typeof\\<^bsub>h\\<^esub> vs = map Some Ts \\<and>\n                       P \\<turnstile> Ts [\\<le>] Ts');\n        Ts' = []\\<rbrakk>\n       \\<Longrightarrow> (P,h \\<turnstile> a # vs [:\\<le>] Ts') =\n                         (\\<exists>Ts.\n                             map typeof\\<^bsub>h\\<^esub> (a # vs) =\n                             map Some Ts \\<and>\n                             P \\<turnstile> Ts [\\<le>] Ts')\n 2. \\<And>a vs Ts' aa list.\n       \\<lbrakk>\\<And>Ts'.\n                   (P,h \\<turnstile> vs [:\\<le>] Ts') =\n                   (\\<exists>Ts.\n                       map typeof\\<^bsub>h\\<^esub> vs = map Some Ts \\<and>\n                       P \\<turnstile> Ts [\\<le>] Ts');\n        Ts' = aa # list\\<rbrakk>\n       \\<Longrightarrow> (P,h \\<turnstile> a # vs [:\\<le>] Ts') =\n                         (\\<exists>Ts.\n                             map typeof\\<^bsub>h\\<^esub> (a # vs) =\n                             map Some Ts \\<and>\n                             P \\<turnstile> Ts [\\<le>] Ts')", "apply(auto simp add:conf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a vs aa list T' Ts.\n       \\<lbrakk>\\<And>Ts'.\n                   (P,h \\<turnstile> vs [:\\<le>] Ts') =\n                   P \\<turnstile> Ts [\\<le>] Ts';\n        typeof\\<^bsub>h\\<^esub> a = \\<lfloor>T'\\<rfloor>;\n        P \\<turnstile> T' \\<le> aa;\n        map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n        P \\<turnstile> Ts [\\<le>] list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Tsa.\n                            \\<lfloor>T'\\<rfloor> # map Some Ts =\n                            map Some Tsa \\<and>\n                            P \\<turnstile> Tsa [\\<le>] (aa # list)", "apply(rule_tac x=\"T' # Ts\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a vs aa list T' Ts.\n       \\<lbrakk>\\<And>Ts'.\n                   (P,h \\<turnstile> vs [:\\<le>] Ts') =\n                   P \\<turnstile> Ts [\\<le>] Ts';\n        typeof\\<^bsub>h\\<^esub> a = \\<lfloor>T'\\<rfloor>;\n        P \\<turnstile> T' \\<le> aa;\n        map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n        P \\<turnstile> Ts [\\<le>] list\\<rbrakk>\n       \\<Longrightarrow> \\<lfloor>T'\\<rfloor> # map Some Ts =\n                         map Some (T' # Ts) \\<and>\n                         P \\<turnstile> (T' # Ts) [\\<le>] (aa # list)", "apply(simp add: fun_of_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma confs_Cons2: \"P,h \\<turnstile> xs [:\\<le>] y#ys = (\\<exists>z zs. xs = z#zs \\<and> P,h \\<turnstile> z :\\<le> y \\<and> P,h \\<turnstile> zs [:\\<le>] ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,h \\<turnstile> xs [:\\<le>] y # ys) =\n    (\\<exists>z zs.\n        xs = z # zs \\<and>\n        P,h \\<turnstile> z :\\<le> y \\<and> P,h \\<turnstile> zs [:\\<le>] ys)", "by (rule list_all2_Cons2)"], ["", "end"], ["", "context heap begin"], ["", "lemma confs_hext: \"P,h \\<turnstile> vs [:\\<le>] Ts \\<Longrightarrow> h \\<unlhd> h' \\<Longrightarrow> P,h' \\<turnstile> vs [:\\<le>] Ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> vs [:\\<le>] Ts; h \\<unlhd> h'\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile> vs [:\\<le>] Ts", "by (erule list_all2_mono, erule conf_hext, assumption)"], ["", "end"], ["", "subsection \\<open>Local variable conformance\\<close>"], ["", "context heap_base begin"], ["", "lemma lconf_upd:\n  \"\\<lbrakk> P,h \\<turnstile> l (:\\<le>) E; P,h \\<turnstile> v :\\<le> T; E V = Some T \\<rbrakk> \\<Longrightarrow> P,h \\<turnstile> l(V\\<mapsto>v) (:\\<le>) E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> l (:\\<le>) E; P,h \\<turnstile> v :\\<le> T;\n     E V = \\<lfloor>T\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> l(V \\<mapsto> v) (:\\<le>) E", "unfolding lconf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>V v.\n                l V = \\<lfloor>v\\<rfloor> \\<longrightarrow>\n                (\\<exists>T.\n                    E V = \\<lfloor>T\\<rfloor> \\<and>\n                    P,h \\<turnstile> v :\\<le> T);\n     P,h \\<turnstile> v :\\<le> T; E V = \\<lfloor>T\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>Va va.\n                         (l(V \\<mapsto> v)) Va =\n                         \\<lfloor>va\\<rfloor> \\<longrightarrow>\n                         (\\<exists>T.\n                             E Va = \\<lfloor>T\\<rfloor> \\<and>\n                             P,h \\<turnstile> va :\\<le> T)", "by auto"], ["", "lemma lconf_empty [iff]: \"P,h \\<turnstile> Map.empty (:\\<le>) E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h \\<turnstile> Map.empty (:\\<le>) E", "by(simp add:lconf_def)"], ["", "lemma lconf_upd2: \"\\<lbrakk>P,h \\<turnstile> l (:\\<le>) E; P,h \\<turnstile> v :\\<le> T\\<rbrakk> \\<Longrightarrow> P,h \\<turnstile> l(V\\<mapsto>v) (:\\<le>) E(V\\<mapsto>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> l (:\\<le>) E;\n     P,h \\<turnstile> v :\\<le> T\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> l(V \\<mapsto> v) (:\\<le>) E(V \n                      \\<mapsto> T)", "by(simp add:lconf_def)"], ["", "end"], ["", "context heap begin"], ["", "lemma lconf_hext: \"\\<lbrakk> P,h \\<turnstile> l (:\\<le>) E; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow> P,h' \\<turnstile> l (:\\<le>) E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> l (:\\<le>) E; h \\<unlhd> h'\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile> l (:\\<le>) E", "unfolding lconf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>V v.\n                l V = \\<lfloor>v\\<rfloor> \\<longrightarrow>\n                (\\<exists>T.\n                    E V = \\<lfloor>T\\<rfloor> \\<and>\n                    P,h \\<turnstile> v :\\<le> T);\n     h \\<unlhd> h'\\<rbrakk>\n    \\<Longrightarrow> \\<forall>V v.\n                         l V = \\<lfloor>v\\<rfloor> \\<longrightarrow>\n                         (\\<exists>T.\n                             E V = \\<lfloor>T\\<rfloor> \\<and>\n                             P,h' \\<turnstile> v :\\<le> T)", "by(fast elim: conf_hext)"], ["", "end"], ["", "subsection \\<open>Thread object conformance\\<close>"], ["", "context heap_base begin"], ["", "lemma tconfI: \"\\<lbrakk> typeof_addr h (thread_id2addr t) = \\<lfloor>Class_type C\\<rfloor>; P \\<turnstile> C \\<preceq>\\<^sup>* Thread \\<rbrakk> \\<Longrightarrow> P,h \\<turnstile> t \\<surd>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>typeof_addr h (thread_id2addr t) =\n             \\<lfloor>Class_type C\\<rfloor>;\n     P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> t \\<surd>t", "by(simp add: tconf_def)"], ["", "lemma tconfD: \"P,h \\<turnstile> t \\<surd>t \\<Longrightarrow> \\<exists>C. typeof_addr h (thread_id2addr t) = \\<lfloor>Class_type C\\<rfloor> \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* Thread\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h \\<turnstile> t \\<surd>t \\<Longrightarrow>\n    \\<exists>C.\n       typeof_addr h (thread_id2addr t) =\n       \\<lfloor>Class_type C\\<rfloor> \\<and>\n       P \\<turnstile> C \\<preceq>\\<^sup>* Thread", "by(auto simp add: tconf_def)"], ["", "end"], ["", "context heap begin"], ["", "lemma tconf_hext_mono: \"\\<lbrakk> P,h \\<turnstile> t \\<surd>t; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow> P,h' \\<turnstile> t \\<surd>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> t \\<surd>t; h \\<unlhd> h'\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile> t \\<surd>t", "by(auto simp add: tconf_def dest: typeof_addr_hext_mono)"], ["", "lemma tconf_heap_ops_mono:\n  assumes \"P,h \\<turnstile> t \\<surd>t\"\n  shows tconf_allocate_mono: \"(h', a) \\<in> allocate h hT \\<Longrightarrow> P,h' \\<turnstile> t \\<surd>t\"\n  and tconf_heap_write_mono: \"heap_write h a al v h' \\<Longrightarrow> P,h' \\<turnstile> t \\<surd>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((h', a) \\<in> allocate h hT \\<Longrightarrow>\n     P,h' \\<turnstile> t \\<surd>t) &&&\n    (heap_write h a al v h' \\<Longrightarrow> P,h' \\<turnstile> t \\<surd>t)", "using tconf_hext_mono[OF assms, of h']"], ["proof (prove)\nusing this:\n  h \\<unlhd> h' \\<Longrightarrow> P,h' \\<turnstile> t \\<surd>t\n\ngoal (1 subgoal):\n 1. ((h', a) \\<in> allocate h hT \\<Longrightarrow>\n     P,h' \\<turnstile> t \\<surd>t) &&&\n    (heap_write h a al v h' \\<Longrightarrow> P,h' \\<turnstile> t \\<surd>t)", "by(blast intro: hext_heap_ops)+"], ["", "lemma tconf_start_heap_start_tid:\n  \"\\<lbrakk> start_heap_ok; wf_syscls P \\<rbrakk> \\<Longrightarrow> P,start_heap \\<turnstile> start_tid \\<surd>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>start_heap_ok; wf_syscls P\\<rbrakk>\n    \\<Longrightarrow> P,start_heap \\<turnstile> start_tid \\<surd>t", "unfolding start_tid_def start_heap_def start_heap_ok_def start_heap_data_def initialization_list_def addr_of_sys_xcpt_def start_addrs_def sys_xcpts_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>snd (snd (foldl create_initial_object (empty_heap, [], True)\n                        [Thread, NullPointer, ClassCast, OutOfMemory,\n                         ArrayIndexOutOfBounds, ArrayStore,\n                         NegativeArraySize, ArithmeticException,\n                         IllegalMonitorState, IllegalThreadState,\n                         InterruptedException]));\n     wf_syscls P\\<rbrakk>\n    \\<Longrightarrow> P,fst (foldl create_initial_object\n                              (empty_heap, [], True)\n                              [Thread, NullPointer, ClassCast, OutOfMemory,\n                               ArrayIndexOutOfBounds, ArrayStore,\n                               NegativeArraySize, ArithmeticException,\n                               IllegalMonitorState, IllegalThreadState,\n                               InterruptedException]) \\<turnstile> addr2thread_id\n                              (hd (fst (snd\n   (foldl create_initial_object (empty_heap, [], True)\n     [Thread, NullPointer, ClassCast, OutOfMemory, ArrayIndexOutOfBounds,\n      ArrayStore, NegativeArraySize, ArithmeticException,\n      IllegalMonitorState, IllegalThreadState,\n      InterruptedException])))) \\<surd>t", "apply(clarsimp split: prod.split_asm simp add: create_initial_object_simps split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j.\n       \\<lbrakk>wf_syscls P;\n        allocate empty_heap (Class_type Thread) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        allocate x1 (Class_type NullPointer) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        allocate x1a (Class_type ClassCast) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        allocate x1b (Class_type OutOfMemory) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        allocate x1c (Class_type ArrayIndexOutOfBounds) \\<noteq> {};\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        allocate x1d (Class_type ArrayStore) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        allocate x1e (Class_type NegativeArraySize) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        allocate x1f (Class_type ArithmeticException) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        allocate x1g (Class_type IllegalMonitorState) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        allocate x1h (Class_type IllegalThreadState) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        allocate x1i (Class_type InterruptedException) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j)\\<rbrakk>\n       \\<Longrightarrow> P,x1j \\<turnstile> addr2thread_id x2 \\<surd>t", "apply(erule not_empty_pairE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j a b aa ba ab bb ac bc ad bd ae be af bf ag bg ah\n       bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        (a, b) \\<in> allocate empty_heap (Class_type Thread);\n        (aa, ba) \\<in> allocate x1 (Class_type NullPointer);\n        (ab, bb) \\<in> allocate x1a (Class_type ClassCast);\n        (ac, bc) \\<in> allocate x1b (Class_type OutOfMemory);\n        (ad, bd) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (ae, be) \\<in> allocate x1d (Class_type ArrayStore);\n        (af, bf) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (ag, bg) \\<in> allocate x1f (Class_type ArithmeticException);\n        (ah, bh) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (ai, bi) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (aj, bj)\n        \\<in> allocate x1i (Class_type InterruptedException)\\<rbrakk>\n       \\<Longrightarrow> P,x1j \\<turnstile> addr2thread_id x2 \\<surd>t", "apply(drule (1) allocate_Eps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j a b aa ba ab bb ac bc ad bd ae be af bf ag bg ah\n       bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        (aa, ba) \\<in> allocate x1 (Class_type NullPointer);\n        (ab, bb) \\<in> allocate x1a (Class_type ClassCast);\n        (ac, bc) \\<in> allocate x1b (Class_type OutOfMemory);\n        (ad, bd) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (ae, be) \\<in> allocate x1d (Class_type ArrayStore);\n        (af, bf) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (ag, bg) \\<in> allocate x1f (Class_type ArithmeticException);\n        (ah, bh) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (ai, bi) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (aj, bj) \\<in> allocate x1i (Class_type InterruptedException);\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread)\\<rbrakk>\n       \\<Longrightarrow> P,x1j \\<turnstile> addr2thread_id x2 \\<surd>t", "apply(drule (1) allocate_Eps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j a b aa ba ab bb ac bc ad bd ae be af bf ag bg ah\n       bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        (ab, bb) \\<in> allocate x1a (Class_type ClassCast);\n        (ac, bc) \\<in> allocate x1b (Class_type OutOfMemory);\n        (ad, bd) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (ae, be) \\<in> allocate x1d (Class_type ArrayStore);\n        (af, bf) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (ag, bg) \\<in> allocate x1f (Class_type ArithmeticException);\n        (ah, bh) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (ai, bi) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (aj, bj) \\<in> allocate x1i (Class_type InterruptedException);\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer)\\<rbrakk>\n       \\<Longrightarrow> P,x1j \\<turnstile> addr2thread_id x2 \\<surd>t", "apply(drule (1) allocate_Eps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j a b aa ba ab bb ac bc ad bd ae be af bf ag bg ah\n       bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        (ac, bc) \\<in> allocate x1b (Class_type OutOfMemory);\n        (ad, bd) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (ae, be) \\<in> allocate x1d (Class_type ArrayStore);\n        (af, bf) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (ag, bg) \\<in> allocate x1f (Class_type ArithmeticException);\n        (ah, bh) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (ai, bi) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (aj, bj) \\<in> allocate x1i (Class_type InterruptedException);\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast)\\<rbrakk>\n       \\<Longrightarrow> P,x1j \\<turnstile> addr2thread_id x2 \\<surd>t", "apply(drule (1) allocate_Eps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j a b aa ba ab bb ac bc ad bd ae be af bf ag bg ah\n       bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        (ad, bd) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (ae, be) \\<in> allocate x1d (Class_type ArrayStore);\n        (af, bf) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (ag, bg) \\<in> allocate x1f (Class_type ArithmeticException);\n        (ah, bh) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (ai, bi) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (aj, bj) \\<in> allocate x1i (Class_type InterruptedException);\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory)\\<rbrakk>\n       \\<Longrightarrow> P,x1j \\<turnstile> addr2thread_id x2 \\<surd>t", "apply(drule (1) allocate_Eps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j a b aa ba ab bb ac bc ad bd ae be af bf ag bg ah\n       bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        (ae, be) \\<in> allocate x1d (Class_type ArrayStore);\n        (af, bf) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (ag, bg) \\<in> allocate x1f (Class_type ArithmeticException);\n        (ah, bh) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (ai, bi) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (aj, bj) \\<in> allocate x1i (Class_type InterruptedException);\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        (x1d, x2d)\n        \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)\\<rbrakk>\n       \\<Longrightarrow> P,x1j \\<turnstile> addr2thread_id x2 \\<surd>t", "apply(drule (1) allocate_Eps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j a b aa ba ab bb ac bc ad bd ae be af bf ag bg ah\n       bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        (af, bf) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (ag, bg) \\<in> allocate x1f (Class_type ArithmeticException);\n        (ah, bh) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (ai, bi) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (aj, bj) \\<in> allocate x1i (Class_type InterruptedException);\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore)\\<rbrakk>\n       \\<Longrightarrow> P,x1j \\<turnstile> addr2thread_id x2 \\<surd>t", "apply(drule (1) allocate_Eps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j a b aa ba ab bb ac bc ad bd ae be af bf ag bg ah\n       bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        (ag, bg) \\<in> allocate x1f (Class_type ArithmeticException);\n        (ah, bh) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (ai, bi) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (aj, bj) \\<in> allocate x1i (Class_type InterruptedException);\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        (x1f, x2f)\n        \\<in> allocate x1e (Class_type NegativeArraySize)\\<rbrakk>\n       \\<Longrightarrow> P,x1j \\<turnstile> addr2thread_id x2 \\<surd>t", "apply(drule (1) allocate_Eps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j a b aa ba ab bb ac bc ad bd ae be af bf ag bg ah\n       bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        (ah, bh) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (ai, bi) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (aj, bj) \\<in> allocate x1i (Class_type InterruptedException);\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (x1g, x2g)\n        \\<in> allocate x1f (Class_type ArithmeticException)\\<rbrakk>\n       \\<Longrightarrow> P,x1j \\<turnstile> addr2thread_id x2 \\<surd>t", "apply(drule (1) allocate_Eps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j a b aa ba ab bb ac bc ad bd ae be af bf ag bg ah\n       bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        (ai, bi) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (aj, bj) \\<in> allocate x1i (Class_type InterruptedException);\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        (x1h, x2h)\n        \\<in> allocate x1g (Class_type IllegalMonitorState)\\<rbrakk>\n       \\<Longrightarrow> P,x1j \\<turnstile> addr2thread_id x2 \\<surd>t", "apply(drule (1) allocate_Eps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j a b aa ba ab bb ac bc ad bd ae be af bf ag bg ah\n       bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        (aj, bj) \\<in> allocate x1i (Class_type InterruptedException);\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (x1i, x2i)\n        \\<in> allocate x1h (Class_type IllegalThreadState)\\<rbrakk>\n       \\<Longrightarrow> P,x1j \\<turnstile> addr2thread_id x2 \\<surd>t", "apply(drule (1) allocate_Eps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j a b aa ba ab bb ac bc ad bd ae be af bf ag bg ah\n       bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (x1j, x2j)\n        \\<in> allocate x1i (Class_type InterruptedException)\\<rbrakk>\n       \\<Longrightarrow> P,x1j \\<turnstile> addr2thread_id x2 \\<surd>t", "apply(drule allocate_SomeD[where hT=\"Class_type Thread\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j a b aa ba ab bb ac bc ad bd ae be af bf ag bg ah\n       bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (x1j, x2j)\n        \\<in> allocate x1i (Class_type InterruptedException)\\<rbrakk>\n       \\<Longrightarrow> is_htype P (Class_type Thread)\n 2. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j a b aa ba ab bb ac bc ad bd ae be af bf ag bg ah\n       bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (x1j, x2j) \\<in> allocate x1i (Class_type InterruptedException);\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P,x1j \\<turnstile> addr2thread_id x2 \\<surd>t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j a b aa ba ab bb ac bc ad bd ae be af bf ag bg ah\n       bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (x1j, x2j) \\<in> allocate x1i (Class_type InterruptedException);\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P,x1j \\<turnstile> addr2thread_id x2 \\<surd>t", "apply(rule tconfI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j a b aa ba ab bb ac bc ad bd ae be af bf ag bg ah\n       bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (x1j, x2j) \\<in> allocate x1i (Class_type InterruptedException);\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j\n                          (thread_id2addr (addr2thread_id x2)) =\n                         \\<lfloor>Class_type\n                                   (?C333 x1 x2 x1a x2a x1b x2b x1c x2c x1d\n                                     x2d x1e x2e x1f x2f x1g x2g x1h x2h x1i\n                                     x2i x1j x2j a b aa ba ab bb ac bc ad bd\n                                     ae be af bf ag bg ah bh ai bi aj\n                                     bj)\\<rfloor>\n 2. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j a b aa ba ab bb ac bc ad bd ae be af bf ag bg ah\n       bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (x1j, x2j) \\<in> allocate x1i (Class_type InterruptedException);\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> ?C333 x1 x2 x1a x2a x1b x2b x1c x2c\n   x1d x2d x1e x2e x1f x2f x1g x2g x1h x2h x1i x2i x1j x2j a b aa ba ab bb\n   ac bc ad bd ae be af bf ag bg ah bh ai bi aj bj \\<preceq>\\<^sup>* Thread", "apply(erule typeof_addr_hext_mono[OF hext_allocate])+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j a b aa ba ab bb ac bc ad bd ae be af bf ag bg ah\n       bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1\n                          (thread_id2addr (addr2thread_id x2)) =\n                         \\<lfloor>Class_type\n                                   (?C333 x1 x2 x1a x2a x1b x2b x1c x2c x1d\n                                     x2d x1e x2e x1f x2f x1g x2g x1h x2h x1i\n                                     x2i x1j x2j a b aa ba ab bb ac bc ad bd\n                                     ae be af bf ag bg ah bh ai bi aj\n                                     bj)\\<rfloor>\n 2. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j a b aa ba ab bb ac bc ad bd ae be af bf ag bg ah\n       bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (x1j, x2j) \\<in> allocate x1i (Class_type InterruptedException);\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> ?C333 x1 x2 x1a x2a x1b x2b x1c x2c\n   x1d x2d x1e x2e x1f x2f x1g x2g x1h x2h x1i x2i x1j x2j a b aa ba ab bb\n   ac bc ad bd ae be af bf ag bg ah bh ai bi aj bj \\<preceq>\\<^sup>* Thread", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j a b aa ba ab bb ac bc ad bd ae be af bf ag bg ah\n       bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (x1j, x2j) \\<in> allocate x1i (Class_type InterruptedException);\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Thread \\<preceq>\\<^sup>* Thread", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma start_heap_write_typeable:\n  assumes \"WriteMem ad al v \\<in> set start_heap_obs\"\n  shows \"\\<exists>T. P,start_heap \\<turnstile> ad@al : T \\<and> P,start_heap \\<turnstile> v :\\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T.\n       P,start_heap \\<turnstile> ad@al : T \\<and>\n       P,start_heap \\<turnstile> v :\\<le> T", "using assms"], ["proof (prove)\nusing this:\n  WriteMem ad al v \\<in> set start_heap_obs\n\ngoal (1 subgoal):\n 1. \\<exists>T.\n       P,start_heap \\<turnstile> ad@al : T \\<and>\n       P,start_heap \\<turnstile> v :\\<le> T", "unfolding start_heap_obs_def start_heap_def"], ["proof (prove)\nusing this:\n  WriteMem ad al v\n  \\<in> set (map2 (\\<lambda>C a. NewHeapElem a (Class_type C))\n              initialization_list (fst (snd start_heap_data)))\n\ngoal (1 subgoal):\n 1. \\<exists>T.\n       P,fst start_heap_data \\<turnstile> ad@al : T \\<and>\n       P,fst start_heap_data \\<turnstile> v :\\<le> T", "by clarsimp"], ["", "end"], ["", "subsection \\<open>Well-formed start state\\<close>"], ["", "context heap_base begin"], ["", "inductive wf_start_state :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> mname \\<Rightarrow> 'addr val list \\<Rightarrow> bool\"\nfor P :: \"'m prog\" and C :: cname and M :: mname and vs :: \"'addr val list\"\nwhere\n  wf_start_state:\n  \"\\<lbrakk> P \\<turnstile> C sees M:Ts\\<rightarrow>T = \\<lfloor>meth\\<rfloor> in D; start_heap_ok; P,start_heap \\<turnstile> vs [:\\<le>] Ts \\<rbrakk>\n  \\<Longrightarrow> wf_start_state P C M vs\""], ["", "end"], ["", "end"]]}