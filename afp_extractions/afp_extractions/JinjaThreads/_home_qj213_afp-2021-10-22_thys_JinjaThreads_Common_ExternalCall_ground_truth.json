{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Common/ExternalCall.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma is_nativeD: \"is_native P hT M \\<Longrightarrow> \\<exists>Ts T D. P \\<turnstile> class_type_of hT sees M:Ts\\<rightarrow>T = Native in D \\<and> D\\<bullet>M(Ts)::T\"", "lemma external_WT'_iff:\n  \"P,h \\<turnstile> a\\<bullet>M(vs) : U \\<longleftrightarrow> \n  (\\<exists>hT Ts Ts' D. typeof_addr h a = \\<lfloor>hT\\<rfloor> \\<and> map typeof\\<^bsub>h\\<^esub> vs = map Some Ts \\<and> P \\<turnstile> class_type_of hT sees M:Ts'\\<rightarrow>U=Native in D \\<and> P \\<turnstile> Ts [\\<le>] Ts')\"", "lemma external_WT'_hext_mono:\n  \"\\<lbrakk> P,h \\<turnstile> a\\<bullet>M(vs) : T; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow> P,h' \\<turnstile> a\\<bullet>M(vs) : T\"", "lemma rec_extCallRet [simp]: \"rec_extCallRet = case_extCallRet\"", "lemma red_external_imp_red_external_aggr:\n  \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle> \\<Longrightarrow> (ta, va, h') \\<in> red_external_aggr P t a M vs h\"", "lemma hext_heap_copy_loc:\n  \"heap_copy_loc a a' al h obs h' \\<Longrightarrow> h \\<unlhd> h'\"", "lemma hext_heap_copies:\n  assumes \"heap_copies a a' als h obs h'\"\n  shows \"h \\<unlhd> h'\"", "lemma hext_heap_clone:\n  assumes \"heap_clone P h a h' res\"\n  shows \"h \\<unlhd> h'\"", "theorem red_external_hext: \n  assumes \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>\"\n  shows \"hext h h'\"", "lemma red_external_preserves_tconf:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>; P,h \\<turnstile> t' \\<surd>t \\<rbrakk> \\<Longrightarrow> P,h' \\<turnstile> t' \\<surd>t\"", "lemma typeof_addr_heap_clone:\n  assumes \"heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\"\n  and \"hconf h\"\n  shows \"typeof_addr h' a' = typeof_addr h a\"", "lemma red_ext_new_thread_heap:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>; NewThread t' ex h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk> \\<Longrightarrow> h'' = h'\"", "lemma red_ext_aggr_new_thread_heap:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; NewThread t' ex h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk> \\<Longrightarrow> h'' = h'\"", "lemma red_external_new_thread_exists_thread_object:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>; NewThread t' x h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> \\<exists>C. typeof_addr h' (thread_id2addr t') = \\<lfloor>Class_type C\\<rfloor> \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* Thread\"", "lemma red_external_aggr_new_thread_exists_thread_object:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; typeof_addr h a \\<noteq> None;\n     NewThread t' x h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> \\<exists>C. typeof_addr h' (thread_id2addr t') = \\<lfloor>Class_type C\\<rfloor> \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* Thread\"", "lemma red_external_aggr_hext: \n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; is_native P (the (typeof_addr h a)) M \\<rbrakk> \\<Longrightarrow> h \\<unlhd> h'\"", "lemma red_external_aggr_preserves_tconf:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; is_native P (the (typeof_addr h a)) M; P,h \\<turnstile> t' \\<surd>t \\<rbrakk>\n  \\<Longrightarrow> P,h' \\<turnstile> t' \\<surd>t\"", "lemma red_external_Wakeup_no_Join_no_Lock_no_Interrupt:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>; Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or> WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<rbrakk> \\<Longrightarrow>\n  collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = {} \\<and> collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> = {} \\<and> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> = {}\"", "lemma red_external_aggr_Wakeup_no_Join:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h;\n     Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or> WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = {} \\<and> collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> = {} \\<and> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> = {}\"", "lemma red_external_Suspend_StaySame:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>; Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<rbrakk> \\<Longrightarrow> va = RetStaySame\"", "lemma red_external_aggr_Suspend_StaySame:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<rbrakk> \\<Longrightarrow> va = RetStaySame\"", "lemma red_external_Suspend_waitD:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>; Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<rbrakk> \\<Longrightarrow> M = wait\"", "lemma red_external_aggr_Suspend_waitD:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<rbrakk> \\<Longrightarrow> M = wait\"", "lemma red_external_new_thread_sub_thread:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>; NewThread t' (C, M', a') h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> typeof_addr h' a' = \\<lfloor>Class_type C\\<rfloor> \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* Thread \\<and> M' = run\"", "lemma red_external_aggr_new_thread_sub_thread:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; typeof_addr h a \\<noteq> None;\n     NewThread t' (C, M', a') h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> typeof_addr h' a' = \\<lfloor>Class_type C\\<rfloor> \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* Thread \\<and> M' = run\"", "lemma heap_copy_loc_length:\n  assumes \"heap_copy_loc a a' al h obs h'\"\n  shows \"length obs = 2\"", "lemma heap_copies_length:\n  assumes \"heap_copies a a' als h obs h'\"\n  shows \"length obs = 2 * length als\"", "lemma \\<tau>external'_red_external_heap_unchanged:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>; \\<tau>external' P h a M \\<rbrakk> \\<Longrightarrow> h' = h\"", "lemma \\<tau>external'_red_external_aggr_heap_unchanged:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; \\<tau>external' P h a M \\<rbrakk> \\<Longrightarrow> h' = h\"", "lemma \\<tau>external'_red_external_TA_empty:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>; \\<tau>external' P h a M \\<rbrakk> \\<Longrightarrow> ta = \\<epsilon>\"", "lemma \\<tau>external'_red_external_aggr_TA_empty:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; \\<tau>external' P h a M \\<rbrakk> \\<Longrightarrow> ta = \\<epsilon>\"", "lemma red_external_new_thread_addr_conf:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>; NewThread t (C, M, a') h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> P,h' \\<turnstile> Addr a :\\<le> Class Thread\"", "lemma \\<tau>external_red_external_aggr_heap_unchanged:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; \\<tau>external P (the (typeof_addr h a)) M \\<rbrakk> \\<Longrightarrow> h' = h\"", "lemma \\<tau>external_red_external_aggr_TA_empty:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; \\<tau>external P (the (typeof_addr h a)) M \\<rbrakk> \\<Longrightarrow> ta = \\<epsilon>\"", "lemma (in heap_base) RedWaitSpurious_Code:\n  \"spurious_wakeups = True \\<Longrightarrow> \n   P,t \\<turnstile> \\<langle>a\\<bullet>wait([]),h\\<rangle> -\\<lbrace>Unlock\\<rightarrow>a, Lock\\<rightarrow>a, ReleaseAcquire\\<rightarrow>a, IsInterrupted t False, SyncUnlock a\\<rbrace>\\<rightarrow>ext \\<langle>RetVal Unit,h\\<rangle>\"", "lemmas [code_pred_intro] =\n  heap_base.RedNewThread heap_base.RedNewThreadFail \n  heap_base.RedJoin heap_base.RedJoinInterrupt\n  heap_base.RedInterrupt heap_base.RedInterruptInexist heap_base.RedIsInterruptedTrue heap_base.RedIsInterruptedFalse\n  heap_base.RedWaitInterrupt heap_base.RedWait heap_base.RedWaitFail heap_base.RedWaitNotified heap_base.RedWaitInterrupted", "lemmas [code_pred_intro] =\n  heap_base.RedNotify heap_base.RedNotifyFail heap_base.RedNotifyAll heap_base.RedNotifyAllFail \n  heap_base.RedClone heap_base.RedCloneFail\n  heap_base.RedHashcode heap_base.RedPrint heap_base.RedCurrentThread \n  heap_base.RedInterruptedTrue heap_base.RedInterruptedFalse\n  heap_base.RedYield"], "translations": [["", "lemma is_nativeD: \"is_native P hT M \\<Longrightarrow> \\<exists>Ts T D. P \\<turnstile> class_type_of hT sees M:Ts\\<rightarrow>T = Native in D \\<and> D\\<bullet>M(Ts)::T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_native P hT M \\<Longrightarrow>\n    \\<exists>Ts T D.\n       P \\<turnstile> class_type_of\n                       hT sees M: Ts\\<rightarrow>T = Native in D \\<and>\n       D\\<bullet>M(Ts) :: T", "by(simp add: is_native.simps)"], ["", "inductive (in heap_base) external_WT' :: \"'m prog \\<Rightarrow> 'heap \\<Rightarrow> 'addr \\<Rightarrow> mname \\<Rightarrow> 'addr val list \\<Rightarrow> ty \\<Rightarrow> bool\"\n  (\"_,_ \\<turnstile> (_\\<bullet>_'(_')) : _\" [50,0,0,0,50] 60)\nfor P :: \"'m prog\" and h :: 'heap and a :: 'addr and M :: mname and vs :: \"'addr val list\" and U :: ty\nwhere \n  \"\\<lbrakk> typeof_addr h a = \\<lfloor>hT\\<rfloor>; map typeof\\<^bsub>h\\<^esub> vs = map Some Ts; P \\<turnstile> class_type_of hT sees M:Ts'\\<rightarrow>U = Native in D; \n     P \\<turnstile> Ts [\\<le>] Ts' \\<rbrakk> \n  \\<Longrightarrow> P,h \\<turnstile> a\\<bullet>M(vs) : U\""], ["", "context heap_base begin"], ["", "lemma external_WT'_iff:\n  \"P,h \\<turnstile> a\\<bullet>M(vs) : U \\<longleftrightarrow> \n  (\\<exists>hT Ts Ts' D. typeof_addr h a = \\<lfloor>hT\\<rfloor> \\<and> map typeof\\<^bsub>h\\<^esub> vs = map Some Ts \\<and> P \\<turnstile> class_type_of hT sees M:Ts'\\<rightarrow>U=Native in D \\<and> P \\<turnstile> Ts [\\<le>] Ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h \\<turnstile> a\\<bullet>M(vs) : U =\n    (\\<exists>hT Ts Ts' D.\n        typeof_addr h a = \\<lfloor>hT\\<rfloor> \\<and>\n        map typeof\\<^bsub>h\\<^esub> vs = map Some Ts \\<and>\n        P \\<turnstile> class_type_of\n                        hT sees M: Ts'\\<rightarrow>U = Native in D \\<and>\n        P \\<turnstile> Ts [\\<le>] Ts')", "by(simp add: external_WT'.simps)"], ["", "end"], ["", "context heap begin"], ["", "lemma external_WT'_hext_mono:\n  \"\\<lbrakk> P,h \\<turnstile> a\\<bullet>M(vs) : T; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow> P,h' \\<turnstile> a\\<bullet>M(vs) : T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> a\\<bullet>M(vs) : T; h \\<unlhd> h'\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile> a\\<bullet>M(vs) : T", "by(auto 5 2 simp add: external_WT'_iff dest: typeof_addr_hext_mono map_typeof_hext_mono)"], ["", "end"], ["", "subsection \\<open>Semantics of external calls\\<close>"], ["", "datatype 'addr extCallRet = \n    RetVal \"'addr val\"\n  | RetExc 'addr\n  | RetStaySame"], ["", "lemma rec_extCallRet [simp]: \"rec_extCallRet = case_extCallRet\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_extCallRet = case_extCallRet", "by(auto simp add: fun_eq_iff split: extCallRet.split)"], ["", "context heap_base begin"], ["", "abbreviation RetEXC :: \"cname \\<Rightarrow> 'addr extCallRet\"\nwhere \"RetEXC C \\<equiv> RetExc (addr_of_sys_xcpt C)\""], ["", "inductive heap_copy_loc :: \"'addr \\<Rightarrow> 'addr \\<Rightarrow> addr_loc \\<Rightarrow> 'heap \\<Rightarrow> ('addr, 'thread_id) obs_event list \\<Rightarrow> 'heap \\<Rightarrow> bool\"\nfor a :: 'addr and a' :: 'addr and al :: addr_loc and h :: 'heap\nwhere\n  \"\\<lbrakk> heap_read h a al v; heap_write h a' al v h' \\<rbrakk>\n  \\<Longrightarrow> heap_copy_loc a a' al h ([ReadMem a al v, WriteMem a' al v]) h'\""], ["", "inductive heap_copies :: \"'addr \\<Rightarrow> 'addr \\<Rightarrow> addr_loc list \\<Rightarrow> 'heap \\<Rightarrow> ('addr, 'thread_id) obs_event list \\<Rightarrow> 'heap \\<Rightarrow> bool\"\nfor a :: 'addr and a' :: 'addr\nwhere\n  Nil: \"heap_copies a a' [] h [] h\"\n| Cons:\n  \"\\<lbrakk> heap_copy_loc a a' al h ob h'; heap_copies a a' als h' obs h'' \\<rbrakk>\n  \\<Longrightarrow> heap_copies a a' (al # als) h (ob @ obs) h''\""], ["", "inductive_cases heap_copies_cases:\n  \"heap_copies a a' [] h ops h'\"\n  \"heap_copies a a' (al#als) h ops h'\""], ["", "text \\<open>\n  Contrary to Sun's JVM 1.6.0\\_07, cloning an interrupted thread does not yield an interrupted thread,\n  because the interrupt flag is not stored inside the thread object.\n  Starting a clone of a started thread with Sun JVM 1.6.0\\_07 raises an illegal thread state exception,\n  we just start another thread.\n  The thread at @{url \"http://mail.openjdk.java.net/pipermail/core-libs-dev/2010-August/004715.html\"} discusses\n  the general problem of thread cloning and argues against that.\n  The bug report @{url \"http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6968584\"}\n  changes the Thread class implementation\n  such that \\texttt{Object.clone()} can no longer be accessed for Thread and subclasses in Java 7.\n\n  Array cells are never volatile themselves.\n\\<close>"], ["", "inductive heap_clone :: \"'m prog \\<Rightarrow> 'heap \\<Rightarrow> 'addr \\<Rightarrow> 'heap \\<Rightarrow> (('addr, 'thread_id) obs_event list \\<times> 'addr) option \\<Rightarrow> bool\"\nfor P :: \"'m prog\" and h :: 'heap and a :: 'addr \nwhere\n  CloneFail:\n  \"\\<lbrakk> typeof_addr h a = \\<lfloor>hT\\<rfloor>; allocate h hT = {} \\<rbrakk>\n  \\<Longrightarrow> heap_clone P h a h None\"\n| ObjClone:\n  \"\\<lbrakk> typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>; (h', a') \\<in> allocate h (Class_type C);\n     P \\<turnstile> C has_fields FDTs; heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h' obs h'' \\<rbrakk>\n  \\<Longrightarrow> heap_clone P h a h'' \\<lfloor>(NewHeapElem a' (Class_type C) # obs, a')\\<rfloor>\"\n| ArrClone:\n  \"\\<lbrakk> typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>; (h', a') \\<in> allocate h (Array_type T n); P \\<turnstile> Object has_fields FDTs;\n     heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) h' obs  h'' \\<rbrakk>\n  \\<Longrightarrow> heap_clone P h a h'' \\<lfloor>(NewHeapElem a' (Array_type T n) # obs, a')\\<rfloor>\""], ["", "inductive red_external ::\n  \"'m prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> 'addr \\<Rightarrow> mname \\<Rightarrow> 'addr val list \n  \\<Rightarrow> ('addr, 'thread_id, 'heap) external_thread_action \\<Rightarrow> 'addr extCallRet \\<Rightarrow> 'heap \\<Rightarrow> bool\"\n  and red_external_syntax :: \n  \"'m prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'addr \\<Rightarrow> mname \\<Rightarrow> 'addr val list \\<Rightarrow> 'heap \n  \\<Rightarrow> ('addr, 'thread_id, 'heap) external_thread_action \\<Rightarrow> 'addr extCallRet \\<Rightarrow> 'heap \\<Rightarrow> bool\"\n  (\"_,_ \\<turnstile> (\\<langle>(_\\<bullet>_'(_')),/_\\<rangle>) -_\\<rightarrow>ext (\\<langle>(_),/(_)\\<rangle>)\" [50, 0, 0, 0, 0, 0, 0, 0, 0] 51)\nfor P :: \"'m prog\" and t :: 'thread_id and h :: 'heap and a :: 'addr\nwhere\n  \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle> \\<equiv> red_external P t h a M vs ta va h'\"\n\n| RedNewThread:\n  \"\\<lbrakk> typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>; P \\<turnstile> C \\<preceq>\\<^sup>* Thread \\<rbrakk>\n  \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>start([]), h\\<rangle> -\\<lbrace>NewThread (addr2thread_id a) (C, run, a) h, ThreadStart (addr2thread_id a) \\<rbrace>\\<rightarrow>ext \\<langle>RetVal Unit, h\\<rangle>\"\n\n| RedNewThreadFail:\n  \"\\<lbrakk> typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>; P \\<turnstile> C \\<preceq>\\<^sup>* Thread \\<rbrakk>\n  \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>start([]), h\\<rangle> -\\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>\\<rightarrow>ext \\<langle>RetEXC IllegalThreadState, h\\<rangle>\"\n\n| RedJoin:\n  \"\\<lbrakk> typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>; P \\<turnstile> C \\<preceq>\\<^sup>* Thread \\<rbrakk>\n  \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>join([]), h\\<rangle> -\\<lbrace>Join (addr2thread_id a), IsInterrupted t False, ThreadJoin (addr2thread_id a)\\<rbrace>\\<rightarrow>ext \\<langle>RetVal Unit, h\\<rangle>\"\n\n| RedJoinInterrupt:\n  \"\\<lbrakk> typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>; P \\<turnstile> C \\<preceq>\\<^sup>* Thread \\<rbrakk>\n  \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>join([]), h\\<rangle> -\\<lbrace>IsInterrupted t True, ClearInterrupt t, ObsInterrupted t\\<rbrace>\\<rightarrow>ext \\<langle>RetEXC InterruptedException, h\\<rangle>\"\n\n    \\<comment> \\<open>Interruption should produce inter-thread actions (JLS 17.4.4) for the synchronizes-with order.\n    They should synchronize with the inter-thread actions that determine whether a thread has been interrupted.\n    Hence, interruption generates an @{term \"ObsInterrupt\"} action.\n\n    Although @{term WakeUp} causes the interrupted thread to raise an @{term InterruptedException}\n    independent of the interrupt status, the interrupt flag must be set with @{term \"Interrupt\"} \n    such that other threads observe the interrupted thread as interrupted\n    while it competes for the monitor lock again.\n\n    Interrupting a thread which has not yet been started does not set the interrupt flag \n    (tested with Sun HotSpot JVM 1.6.0\\_07).\\<close>\n  \n| RedInterrupt:\n  \"\\<lbrakk> typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>; P \\<turnstile> C \\<preceq>\\<^sup>* Thread \\<rbrakk>\n  \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>interrupt([]), h\\<rangle> \n            -\\<lbrace>ThreadExists (addr2thread_id a) True, WakeUp (addr2thread_id a), \n              Interrupt (addr2thread_id a), ObsInterrupt (addr2thread_id a)\\<rbrace>\\<rightarrow>ext\n            \\<langle>RetVal Unit, h\\<rangle>\"\n\n| RedInterruptInexist:\n  \"\\<lbrakk> typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>; P \\<turnstile> C \\<preceq>\\<^sup>* Thread \\<rbrakk>\n  \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>interrupt([]), h\\<rangle> \n            -\\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>\\<rightarrow>ext\n            \\<langle>RetVal Unit, h\\<rangle>\"\n\n| RedIsInterruptedTrue:\n  \"\\<lbrakk> typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>; P \\<turnstile> C \\<preceq>\\<^sup>* Thread \\<rbrakk>\n  \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>isInterrupted([]), h\\<rangle> -\\<lbrace> IsInterrupted (addr2thread_id a) True, ObsInterrupted (addr2thread_id a)\\<rbrace>\\<rightarrow>ext\n           \\<langle>RetVal (Bool True), h\\<rangle>\"\n\n| RedIsInterruptedFalse:\n  \"\\<lbrakk> typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>; P \\<turnstile> C \\<preceq>\\<^sup>* Thread \\<rbrakk>\n  \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>isInterrupted([]), h\\<rangle> -\\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>\\<rightarrow>ext \\<langle>RetVal (Bool False), h\\<rangle>\"\n\n    \\<comment> \\<open>The JLS leaves unspecified whether @{term wait} first checks for the monitor state\n    (whether the thread holds a lock on the monitor) or for the interrupt flag of the current thread.\n    Sun Hotspot JVM 1.6.0\\_07 seems to check for the monitor state first, so we do it here, too.\\<close>\n| RedWaitInterrupt:\n  \"P,t \\<turnstile> \\<langle>a\\<bullet>wait([]), h\\<rangle> -\\<lbrace>Unlock\\<rightarrow>a, Lock\\<rightarrow>a, IsInterrupted t True, ClearInterrupt t, ObsInterrupted t\\<rbrace> \\<rightarrow>ext \n         \\<langle>RetEXC InterruptedException, h\\<rangle>\"\n\n| RedWait:\n  \"P,t \\<turnstile> \\<langle>a\\<bullet>wait([]), h\\<rangle> -\\<lbrace>Suspend a, Unlock\\<rightarrow>a, Lock\\<rightarrow>a, ReleaseAcquire\\<rightarrow>a, IsInterrupted t False, SyncUnlock a \\<rbrace>\\<rightarrow>ext \n         \\<langle>RetStaySame, h\\<rangle>\"\n\n| RedWaitFail:\n  \"P,t \\<turnstile> \\<langle>a\\<bullet>wait([]), h\\<rangle> -\\<lbrace>UnlockFail\\<rightarrow>a\\<rbrace>\\<rightarrow>ext \\<langle>RetEXC IllegalMonitorState, h\\<rangle>\"\n\n| RedWaitNotified:\n  \"P,t \\<turnstile> \\<langle>a\\<bullet>wait([]), h\\<rangle> -\\<lbrace>Notified\\<rbrace>\\<rightarrow>ext \\<langle>RetVal Unit, h\\<rangle>\"\n\n    \\<comment> \\<open>This rule does NOT check that the interrupted flag is set, but still clears it.\n    The semantics will be that only the executing thread clears its interrupt.\\<close>\n| RedWaitInterrupted:\n  \"P,t \\<turnstile> \\<langle>a\\<bullet>wait([]), h\\<rangle> -\\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>\\<rightarrow>ext \\<langle>RetEXC InterruptedException, h\\<rangle>\"\n\n    \\<comment> \\<open>Calls to wait may decide to immediately wake up spuriously. This is \n    indistinguishable from waking up spuriously any time before being \n    notified or interrupted. Spurious wakeups are configured by the\n    @{term spurious_wakeup} parameter of the @{term heap_base} locale.\\<close>\n| RedWaitSpurious:\n  \"spurious_wakeups \\<Longrightarrow> \n    P,t \\<turnstile> \\<langle>a\\<bullet>wait([]), h\\<rangle> -\\<lbrace>Unlock\\<rightarrow>a, Lock\\<rightarrow>a, ReleaseAcquire\\<rightarrow>a, IsInterrupted t False, SyncUnlock a\\<rbrace> \\<rightarrow>ext\n          \\<langle>RetVal Unit, h\\<rangle>\"\n\n    \\<comment> \\<open>@{term notify} and @{term notifyAll} do not perform synchronization inter-thread actions\n    because they only tests whether the thread holds a lock, but do not change the lock state.\\<close>\n\n| RedNotify:\n  \"P,t \\<turnstile> \\<langle>a\\<bullet>notify([]), h\\<rangle> -\\<lbrace>Notify a, Unlock\\<rightarrow>a, Lock\\<rightarrow>a\\<rbrace>\\<rightarrow>ext \\<langle>RetVal Unit, h\\<rangle>\"\n\n| RedNotifyFail:\n  \"P,t \\<turnstile> \\<langle>a\\<bullet>notify([]), h\\<rangle> -\\<lbrace>UnlockFail\\<rightarrow>a\\<rbrace>\\<rightarrow>ext \\<langle>RetEXC IllegalMonitorState, h\\<rangle>\"\n\n| RedNotifyAll:\n  \"P,t \\<turnstile> \\<langle>a\\<bullet>notifyAll([]), h\\<rangle> -\\<lbrace>NotifyAll a, Unlock\\<rightarrow>a, Lock\\<rightarrow>a\\<rbrace>\\<rightarrow>ext \\<langle>RetVal Unit, h\\<rangle>\"\n\n| RedNotifyAllFail:\n  \"P,t \\<turnstile> \\<langle>a\\<bullet>notifyAll([]), h\\<rangle> -\\<lbrace>UnlockFail\\<rightarrow>a\\<rbrace>\\<rightarrow>ext \\<langle>RetEXC IllegalMonitorState, h\\<rangle>\"\n\n| RedClone:\n  \"heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor> \n    \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>clone([]), h\\<rangle> -(K$ [], [], [], [], [], obs)\\<rightarrow>ext \\<langle>RetVal (Addr a'), h'\\<rangle>\"\n\n| RedCloneFail:\n  \"heap_clone P h a h' None \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>clone([]), h\\<rangle> -\\<epsilon>\\<rightarrow>ext \\<langle>RetEXC OutOfMemory, h'\\<rangle>\"\n\n| RedHashcode:\n  \"P,t \\<turnstile> \\<langle>a\\<bullet>hashcode([]), h\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>ext \\<langle>RetVal (Intg (word_of_int (hash_addr a))), h\\<rangle>\"\n\n| RedPrint:\n  \"P,t \\<turnstile> \\<langle>a\\<bullet>print(vs), h\\<rangle> -\\<lbrace>ExternalCall a print vs Unit\\<rbrace>\\<rightarrow>ext \\<langle>RetVal Unit, h\\<rangle>\"\n\n| RedCurrentThread:\n  \"P,t \\<turnstile> \\<langle>a\\<bullet>currentThread([]), h\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>ext \\<langle>RetVal (Addr (thread_id2addr t)), h\\<rangle>\"\n\n| RedInterruptedTrue:\n  \"P,t \\<turnstile> \\<langle>a\\<bullet>interrupted([]), h\\<rangle> -\\<lbrace>IsInterrupted t True, ClearInterrupt t, ObsInterrupted t\\<rbrace>\\<rightarrow>ext \\<langle>RetVal (Bool True), h\\<rangle>\"\n\n| RedInterruptedFalse:\n  \"P,t \\<turnstile> \\<langle>a\\<bullet>interrupted([]), h\\<rangle> -\\<lbrace>IsInterrupted t False\\<rbrace>\\<rightarrow>ext \\<langle>RetVal (Bool False), h\\<rangle>\"\n\n| RedYield:\n  \"P,t \\<turnstile> \\<langle>a\\<bullet>yield([]), h\\<rangle> -\\<lbrace>Yield\\<rbrace>\\<rightarrow>ext \\<langle>RetVal Unit, h\\<rangle>\""], ["", "subsection \\<open>Aggressive formulation for external cals\\<close>"], ["", "definition red_external_aggr :: \n  \"'m prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'addr \\<Rightarrow> mname \\<Rightarrow> 'addr val list \\<Rightarrow> 'heap \\<Rightarrow> \n  (('addr, 'thread_id, 'heap) external_thread_action \\<times> 'addr extCallRet \\<times> 'heap) set\"\nwhere\n  \"red_external_aggr P t a M vs h =\n   (if M = wait then\n      let ad_t = thread_id2addr t\n      in {(\\<lbrace>Unlock\\<rightarrow>a, Lock\\<rightarrow>a, IsInterrupted t True, ClearInterrupt t, ObsInterrupted t\\<rbrace>, RetEXC InterruptedException, h),\n          (\\<lbrace>Suspend a, Unlock\\<rightarrow>a, Lock\\<rightarrow>a, ReleaseAcquire\\<rightarrow>a, IsInterrupted t False, SyncUnlock a\\<rbrace>, RetStaySame, h),\n          (\\<lbrace>UnlockFail\\<rightarrow>a\\<rbrace>, RetEXC IllegalMonitorState, h),\n          (\\<lbrace>Notified\\<rbrace>, RetVal Unit, h),\n          (\\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>, RetEXC InterruptedException, h)} \\<union>\n         (if spurious_wakeups then {(\\<lbrace>Unlock\\<rightarrow>a, Lock\\<rightarrow>a, ReleaseAcquire\\<rightarrow>a, IsInterrupted t False, SyncUnlock a\\<rbrace>, RetVal Unit, h)} else {})\n    else if M = notify then {(\\<lbrace>Notify a, Unlock\\<rightarrow>a, Lock\\<rightarrow>a\\<rbrace>, RetVal Unit, h),\n                             (\\<lbrace>UnlockFail\\<rightarrow>a\\<rbrace>, RetEXC IllegalMonitorState, h)}\n    else if M = notifyAll then {(\\<lbrace>NotifyAll a, Unlock\\<rightarrow>a, Lock\\<rightarrow>a \\<rbrace>, RetVal Unit, h),\n                                (\\<lbrace>UnlockFail\\<rightarrow>a\\<rbrace>, RetEXC IllegalMonitorState, h)}\n    else if M = clone then\n       {((K$ [], [], [], [], [], obs), RetVal (Addr a'), h')|obs a' h'. heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>}\n       \\<union> {(\\<lbrace>\\<rbrace>, RetEXC OutOfMemory, h')|h'. heap_clone P h a h' None}\n    else if M = hashcode then {(\\<lbrace>\\<rbrace>, RetVal (Intg (word_of_int (hash_addr a))), h)}\n    else if M = print then {(\\<lbrace>ExternalCall a M vs Unit\\<rbrace>, RetVal Unit, h)}\n    else if M = currentThread then {(\\<lbrace>\\<rbrace>, RetVal (Addr (thread_id2addr t)), h)}\n    else if M = interrupted then {(\\<lbrace>IsInterrupted t True, ClearInterrupt t, ObsInterrupted t\\<rbrace>, RetVal (Bool True), h),\n                                  (\\<lbrace>IsInterrupted t False\\<rbrace>, RetVal (Bool False), h)}\n    else if M = yield then {(\\<lbrace>Yield\\<rbrace>, RetVal Unit, h)}\n    else\n      let hT = the (typeof_addr h a)\n      in if P \\<turnstile> ty_of_htype hT \\<le> Class Thread then\n        let t_a = addr2thread_id a \n        in if M = start then \n             {(\\<lbrace>NewThread t_a (the_Class (ty_of_htype hT), run, a) h, ThreadStart t_a\\<rbrace>, RetVal Unit, h), \n              (\\<lbrace>ThreadExists t_a True\\<rbrace>, RetEXC IllegalThreadState, h)}\n           else if M = join then \n             {(\\<lbrace>Join t_a, IsInterrupted t False, ThreadJoin t_a\\<rbrace>, RetVal Unit, h),\n              (\\<lbrace>IsInterrupted t True, ClearInterrupt t, ObsInterrupted t\\<rbrace>, RetEXC InterruptedException, h)}\n           else if M = interrupt then \n             {(\\<lbrace>ThreadExists t_a True, WakeUp t_a, Interrupt t_a, ObsInterrupt t_a\\<rbrace>, RetVal Unit, h), \n              (\\<lbrace>ThreadExists t_a False\\<rbrace>, RetVal Unit, h)}\n           else if M = isInterrupted then\n             {(\\<lbrace>IsInterrupted t_a False\\<rbrace>, RetVal (Bool False), h),\n              (\\<lbrace>IsInterrupted t_a True, ObsInterrupted t_a\\<rbrace>, RetVal (Bool True), h)}\n         else {(\\<lbrace>\\<rbrace>, undefined)}\n      else {(\\<lbrace>\\<rbrace>, undefined)})\""], ["", "lemma red_external_imp_red_external_aggr:\n  \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle> \\<Longrightarrow> (ta, va, h') \\<in> red_external_aggr P t a M vs h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                     h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n              h'\\<rangle> \\<Longrightarrow>\n    (ta, va, h') \\<in> red_external_aggr P t a M vs h", "unfolding red_external_aggr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                     h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n              h'\\<rangle> \\<Longrightarrow>\n    (ta, va, h')\n    \\<in> (if M = wait\n           then let ad_t = thread_id2addr t\n                in {(\\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n                     ClearInterrupt t, ObsInterrupted t\\<rbrace>,\n                     RetEXC InterruptedException, h),\n                    (\\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n                     (ReleaseAcquire, a), IsInterrupted t False,\n                     SyncUnlock a\\<rbrace>, RetStaySame, h),\n                    (\\<lbrace>(UnlockFail, a)\\<rbrace>,\n                     RetEXC IllegalMonitorState, h),\n                    (\\<lbrace>Notified\\<rbrace>, RetVal Unit, h),\n                    (\\<lbrace>WokenUp, ClearInterrupt t,\n                     ObsInterrupted t\\<rbrace>, RetEXC InterruptedException,\n                     h)} \\<union>\n                   (if spurious_wakeups\n                    then {(\\<lbrace>(Unlock, a), (Lock, a),\n                           (ReleaseAcquire, a), IsInterrupted t False,\n                           SyncUnlock a\\<rbrace>, RetVal Unit, h)}\n                    else {})\n           else if M = notify\n                then {(\\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>,\n                       RetVal Unit, h),\n                      (\\<lbrace>(UnlockFail, a)\\<rbrace>,\n                       RetEXC IllegalMonitorState, h)}\n                else if M = notifyAll\n                     then {(\\<lbrace>NotifyAll a, (Unlock, a),\n                            (Lock, a)\\<rbrace>, RetVal Unit, h),\n                           (\\<lbrace>(UnlockFail, a)\\<rbrace>,\n                            RetEXC IllegalMonitorState, h)}\n                     else if M = clone\n                          then {((K$ [], [], [], [], [], obs),\n                                 RetVal (Addr a'), h') |\n                                obs a' h'.\n                                heap_clone P h a h'\n                                 \\<lfloor>(obs, a')\\<rfloor>} \\<union>\n                               {(\\<lbrace>\\<rbrace>, RetEXC OutOfMemory,\n                                 h') |\n                                h'. heap_clone P h a h' None}\n                          else if M = hashcode\n                               then {(\\<lbrace>\\<rbrace>,\nRetVal (Intg (word_of_int (hash_addr a))), h)}\n                               else if M = print\n                                    then {(\\<lbrace>ExternalCall a M vs\n               Unit\\<rbrace>,\n     RetVal Unit, h)}\n                                    else if M = currentThread\n   then {(\\<lbrace>\\<rbrace>, RetVal (Addr (thread_id2addr t)), h)}\n   else if M = interrupted\n        then {(\\<lbrace>IsInterrupted t True, ClearInterrupt t,\n               ObsInterrupted t\\<rbrace>, RetVal (Bool True), h),\n              (\\<lbrace>IsInterrupted t False\\<rbrace>, RetVal (Bool False),\n               h)}\n        else if M = yield then {(\\<lbrace>Yield\\<rbrace>, RetVal Unit, h)}\n             else let hT = the (typeof_addr h a)\n                  in if P \\<turnstile> ty_of_htype hT \\<le> Class Thread\n                     then let t_a = addr2thread_id a\n                          in if M = start\n                             then {(\\<lbrace>NewThread t_a\n        (the_Class (ty_of_htype hT), run, a) h,\n                                    ThreadStart t_a\\<rbrace>, RetVal Unit,\n                                    h),\n                                   (\\<lbrace>ThreadExists t_a True\\<rbrace>,\n                                    RetEXC IllegalThreadState, h)}\n                             else if M = join\n                                  then {(\\<lbrace>Join t_a,\n   IsInterrupted t False, ThreadJoin t_a\\<rbrace>, RetVal Unit, h),\n  (\\<lbrace>IsInterrupted t True, ClearInterrupt t,\n   ObsInterrupted t\\<rbrace>, RetEXC InterruptedException, h)}\n                                  else if M = interrupt\n then {(\\<lbrace>ThreadExists t_a True, WakeUp t_a, Interrupt t_a,\n        ObsInterrupt t_a\\<rbrace>, RetVal Unit, h),\n       (\\<lbrace>ThreadExists t_a False\\<rbrace>, RetVal Unit, h)}\n else if M = isInterrupted\n      then {(\\<lbrace>IsInterrupted t_a False\\<rbrace>, RetVal (Bool False),\n             h),\n            (\\<lbrace>IsInterrupted t_a True, ObsInterrupted t_a\\<rbrace>,\n             RetVal (Bool True), h)}\n      else {(\\<lbrace>\\<rbrace>, undefined)}\n                     else {(\\<lbrace>\\<rbrace>, undefined)})", "by(auto elim!: red_external.cases split del: if_split simp add: split_beta)"], ["", "end"], ["", "context heap begin"], ["", "lemma hext_heap_copy_loc:\n  \"heap_copy_loc a a' al h obs h' \\<Longrightarrow> h \\<unlhd> h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_copy_loc a a' al h obs h' \\<Longrightarrow> h \\<unlhd> h'", "by(blast elim: heap_copy_loc.cases dest: hext_heap_ops)"], ["", "lemma hext_heap_copies:\n  assumes \"heap_copies a a' als h obs h'\"\n  shows \"h \\<unlhd> h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "using assms"], ["proof (prove)\nusing this:\n  heap_copies a a' als h obs h'\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "by induct(blast intro: hext_heap_copy_loc hext_trans)+"], ["", "lemma hext_heap_clone:\n  assumes \"heap_clone P h a h' res\"\n  shows \"h \\<unlhd> h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "using assms"], ["proof (prove)\nusing this:\n  heap_clone P h a h' res\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "by(blast elim: heap_clone.cases dest: hext_heap_ops hext_heap_copies intro: hext_trans)"], ["", "theorem red_external_hext: \n  assumes \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>\"\n  shows \"hext h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "using assms"], ["proof (prove)\nusing this:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "by(cases)(blast intro: hext_heap_ops hext_heap_clone)+"], ["", "lemma red_external_preserves_tconf:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>; P,h \\<turnstile> t' \\<surd>t \\<rbrakk> \\<Longrightarrow> P,h' \\<turnstile> t' \\<surd>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                              h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                       h'\\<rangle>;\n     P,h \\<turnstile> t' \\<surd>t\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile> t' \\<surd>t", "by(drule red_external_hext)(rule tconf_hext_mono)"], ["", "end"], ["", "context heap_conf begin"], ["", "lemma typeof_addr_heap_clone:\n  assumes \"heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\"\n  and \"hconf h\"\n  shows \"typeof_addr h' a' = typeof_addr h a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof_addr h' a' = typeof_addr h a", "using assms"], ["proof (prove)\nusing this:\n  heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\n  hconf h\n\ngoal (1 subgoal):\n 1. typeof_addr h' a' = typeof_addr h a", "by cases (auto dest!: allocate_SomeD hext_heap_copies dest: typeof_addr_hext_mono typeof_addr_is_type is_type_ArrayD)"], ["", "end"], ["", "context heap_base begin"], ["", "lemma red_ext_new_thread_heap:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>; NewThread t' ex h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk> \\<Longrightarrow> h'' = h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                              h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                       h'\\<rangle>;\n     NewThread t' ex h''\n     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> h'' = h'", "by(auto elim: red_external.cases simp add: ta_upd_simps)"], ["", "lemma red_ext_aggr_new_thread_heap:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; NewThread t' ex h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk> \\<Longrightarrow> h'' = h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n     NewThread t' ex h''\n     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> h'' = h'", "by(auto simp add: red_external_aggr_def is_native.simps split_beta ta_upd_simps split: if_split_asm)"], ["", "end"], ["", "context addr_conv begin"], ["", "lemma red_external_new_thread_exists_thread_object:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>; NewThread t' x h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> \\<exists>C. typeof_addr h' (thread_id2addr t') = \\<lfloor>Class_type C\\<rfloor> \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* Thread\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                              h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                       h'\\<rangle>;\n     NewThread t' x h''\n     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>C.\n                         typeof_addr h' (thread_id2addr t') =\n                         \\<lfloor>Class_type C\\<rfloor> \\<and>\n                         P \\<turnstile> C \\<preceq>\\<^sup>* Thread", "by(auto elim!: red_external.cases dest!: Array_widen simp add: ta_upd_simps)"], ["", "lemma red_external_aggr_new_thread_exists_thread_object:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; typeof_addr h a \\<noteq> None;\n     NewThread t' x h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> \\<exists>C. typeof_addr h' (thread_id2addr t') = \\<lfloor>Class_type C\\<rfloor> \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* Thread\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n     typeof_addr h a \\<noteq> None;\n     NewThread t' x h''\n     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>C.\n                         typeof_addr h' (thread_id2addr t') =\n                         \\<lfloor>Class_type C\\<rfloor> \\<and>\n                         P \\<turnstile> C \\<preceq>\\<^sup>* Thread", "by(auto simp add: red_external_aggr_def is_native.simps split_beta ta_upd_simps widen_Class split: if_split_asm dest!: Array_widen)"], ["", "end"], ["", "context heap begin"], ["", "lemma red_external_aggr_hext: \n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; is_native P (the (typeof_addr h a)) M \\<rbrakk> \\<Longrightarrow> h \\<unlhd> h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n     is_native P (the (typeof_addr h a)) M\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'", "apply(auto simp add: red_external_aggr_def split_beta is_native.simps elim!: external_WT_defs_cases hext_heap_clone split: if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Ts T D.\n       \\<lbrakk>M \\<noteq> wait;\n        P \\<turnstile> class_type_of\n                        (the (typeof_addr h\n                               a)) sees M: Ts\\<rightarrow>T = Native in D;\n        D\\<bullet>M(Ts) :: T; M \\<noteq> notify; M \\<noteq> notifyAll;\n        M \\<noteq> clone; M \\<noteq> hashcode; M \\<noteq> print;\n        M \\<noteq> currentThread; M \\<noteq> interrupted; M \\<noteq> yield;\n        P \\<turnstile> ty_of_htype\n                        (the (typeof_addr h a)) \\<le> Class Thread;\n        M \\<noteq> start; M \\<noteq> join; M \\<noteq> interrupt;\n        M \\<noteq> isInterrupted; ta = \\<lbrace>\\<rbrace>;\n        (va, h') = undefined\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>Ts T D.\n       \\<lbrakk>M \\<noteq> wait;\n        P \\<turnstile> class_type_of\n                        (the (typeof_addr h\n                               a)) sees M: Ts\\<rightarrow>T = Native in D;\n        D\\<bullet>M(Ts) :: T; M \\<noteq> notify; M \\<noteq> notifyAll;\n        M \\<noteq> clone; M \\<noteq> hashcode; M \\<noteq> print;\n        M \\<noteq> currentThread; M \\<noteq> interrupted; M \\<noteq> yield;\n        \\<not> P \\<turnstile> ty_of_htype\n                               (the (typeof_addr h a)) \\<le> Class Thread;\n        ta = \\<lbrace>\\<rbrace>; (va, h') = undefined\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'", "apply(auto elim!: external_WT_defs.cases dest!: sees_method_decl_above intro: widen_trans simp add: class_type_of_eq split: htype.split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma red_external_aggr_preserves_tconf:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; is_native P (the (typeof_addr h a)) M; P,h \\<turnstile> t' \\<surd>t \\<rbrakk>\n  \\<Longrightarrow> P,h' \\<turnstile> t' \\<surd>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n     is_native P (the (typeof_addr h a)) M;\n     P,h \\<turnstile> t' \\<surd>t\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile> t' \\<surd>t", "by(blast dest: red_external_aggr_hext intro: tconf_hext_mono)"], ["", "end"], ["", "context heap_base begin"], ["", "lemma red_external_Wakeup_no_Join_no_Lock_no_Interrupt:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>; Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or> WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<rbrakk> \\<Longrightarrow>\n  collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = {} \\<and> collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> = {} \\<and> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                              h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                       h'\\<rangle>;\n     Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n     WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                      {} \\<and>\n                      collect_cond_actions\n                       \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                      {} \\<and>\n                      collect_interrupts\n                       \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                      {}", "by(auto elim!: red_external.cases simp add: ta_upd_simps collect_locks_def collect_interrupts_def)"], ["", "lemma red_external_aggr_Wakeup_no_Join:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h;\n     Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or> WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = {} \\<and> collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> = {} \\<and> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n     Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n     WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                      {} \\<and>\n                      collect_cond_actions\n                       \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                      {} \\<and>\n                      collect_interrupts\n                       \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                      {}", "by(auto simp add: red_external_aggr_def split_beta ta_upd_simps collect_locks_def collect_interrupts_def split: if_split_asm)"], ["", "lemma red_external_Suspend_StaySame:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>; Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<rbrakk> \\<Longrightarrow> va = RetStaySame\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                              h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                       h'\\<rangle>;\n     Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> va = RetStaySame", "by(auto elim!: red_external.cases simp add: ta_upd_simps)"], ["", "lemma red_external_aggr_Suspend_StaySame:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<rbrakk> \\<Longrightarrow> va = RetStaySame\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n     Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> va = RetStaySame", "by(auto simp add: red_external_aggr_def split_beta ta_upd_simps split: if_split_asm)"], ["", "lemma red_external_Suspend_waitD:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>; Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<rbrakk> \\<Longrightarrow> M = wait\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                              h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                       h'\\<rangle>;\n     Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> M = wait", "by(auto elim!: red_external.cases simp add: ta_upd_simps)"], ["", "lemma red_external_aggr_Suspend_waitD:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<rbrakk> \\<Longrightarrow> M = wait\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n     Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> M = wait", "by(auto simp add: red_external_aggr_def split_beta ta_upd_simps split: if_split_asm)"], ["", "lemma red_external_new_thread_sub_thread:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>; NewThread t' (C, M', a') h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> typeof_addr h' a' = \\<lfloor>Class_type C\\<rfloor> \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* Thread \\<and> M' = run\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                              h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                       h'\\<rangle>;\n     NewThread t' (C, M', a') h''\n     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> typeof_addr h' a' =\n                      \\<lfloor>Class_type C\\<rfloor> \\<and>\n                      P \\<turnstile> C \\<preceq>\\<^sup>* Thread \\<and>\n                      M' = run", "by(auto elim!: red_external.cases simp add: widen_Class ta_upd_simps)"], ["", "lemma red_external_aggr_new_thread_sub_thread:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; typeof_addr h a \\<noteq> None;\n     NewThread t' (C, M', a') h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> typeof_addr h' a' = \\<lfloor>Class_type C\\<rfloor> \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* Thread \\<and> M' = run\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n     typeof_addr h a \\<noteq> None;\n     NewThread t' (C, M', a') h''\n     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> typeof_addr h' a' =\n                      \\<lfloor>Class_type C\\<rfloor> \\<and>\n                      P \\<turnstile> C \\<preceq>\\<^sup>* Thread \\<and>\n                      M' = run", "by(auto simp add: red_external_aggr_def split_beta ta_upd_simps widen_Class split: if_split_asm dest!: Array_widen)"], ["", "lemma heap_copy_loc_length:\n  assumes \"heap_copy_loc a a' al h obs h'\"\n  shows \"length obs = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length obs = 2", "using assms"], ["proof (prove)\nusing this:\n  heap_copy_loc a a' al h obs h'\n\ngoal (1 subgoal):\n 1. length obs = 2", "by(cases) simp"], ["", "lemma heap_copies_length:\n  assumes \"heap_copies a a' als h obs h'\"\n  shows \"length obs = 2 * length als\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length obs = 2 * length als", "using assms"], ["proof (prove)\nusing this:\n  heap_copies a a' als h obs h'\n\ngoal (1 subgoal):\n 1. length obs = 2 * length als", "by(induct)(auto dest!: heap_copy_loc_length)"], ["", "end"], ["", "subsection \\<open>\\<open>\\<tau>\\<close>-moves\\<close>"], ["", "inductive \\<tau>external_defs :: \"cname \\<Rightarrow> mname \\<Rightarrow> bool\"\nwhere\n  \"\\<tau>external_defs Object hashcode\"\n| \"\\<tau>external_defs Object currentThread\""], ["", "definition \\<tau>external :: \"'m prog \\<Rightarrow> htype \\<Rightarrow> mname \\<Rightarrow> bool\"\nwhere \"\\<tau>external P hT M \\<longleftrightarrow> (\\<exists>Ts Tr D. P \\<turnstile> class_type_of hT sees M:Ts\\<rightarrow>Tr = Native in D \\<and> \\<tau>external_defs D M)\""], ["", "context heap_base begin"], ["", "definition \\<tau>external' :: \"'m prog \\<Rightarrow> 'heap \\<Rightarrow> 'addr \\<Rightarrow> mname \\<Rightarrow> bool\"\nwhere \"\\<tau>external' P h a M \\<longleftrightarrow> (\\<exists>hT. typeof_addr h a = Some hT \\<and> \\<tau>external P hT M)\""], ["", "lemma \\<tau>external'_red_external_heap_unchanged:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>; \\<tau>external' P h a M \\<rbrakk> \\<Longrightarrow> h' = h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                              h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                       h'\\<rangle>;\n     \\<tau>external' P h a M\\<rbrakk>\n    \\<Longrightarrow> h' = h", "by(auto elim!: red_external.cases \\<tau>external_defs.cases simp add: \\<tau>external_def \\<tau>external'_def)"], ["", "lemma \\<tau>external'_red_external_aggr_heap_unchanged:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; \\<tau>external' P h a M \\<rbrakk> \\<Longrightarrow> h' = h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n     \\<tau>external' P h a M\\<rbrakk>\n    \\<Longrightarrow> h' = h", "by(auto elim!: \\<tau>external_defs.cases simp add: \\<tau>external_def \\<tau>external'_def red_external_aggr_def)"], ["", "lemma \\<tau>external'_red_external_TA_empty:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>; \\<tau>external' P h a M \\<rbrakk> \\<Longrightarrow> ta = \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                              h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                       h'\\<rangle>;\n     \\<tau>external' P h a M\\<rbrakk>\n    \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>", "by(auto elim!: red_external.cases \\<tau>external_defs.cases simp add: \\<tau>external_def \\<tau>external'_def)"], ["", "lemma \\<tau>external'_red_external_aggr_TA_empty:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; \\<tau>external' P h a M \\<rbrakk> \\<Longrightarrow> ta = \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n     \\<tau>external' P h a M\\<rbrakk>\n    \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>", "by(auto elim!: \\<tau>external_defs.cases simp add: \\<tau>external_def \\<tau>external'_def red_external_aggr_def)"], ["", "lemma red_external_new_thread_addr_conf:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>; NewThread t (C, M, a') h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> P,h' \\<turnstile> Addr a :\\<le> Class Thread\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                              h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                       h'\\<rangle>;\n     NewThread t (C, M, a') h''\n     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile> Addr a :\\<le> Class Thread", "by(auto elim!: red_external.cases simp add: conf_def ta_upd_simps)"], ["", "lemma \\<tau>external_red_external_aggr_heap_unchanged:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; \\<tau>external P (the (typeof_addr h a)) M \\<rbrakk> \\<Longrightarrow> h' = h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n     \\<tau>external P (the (typeof_addr h a)) M\\<rbrakk>\n    \\<Longrightarrow> h' = h", "by(auto elim!: \\<tau>external_defs.cases simp add: \\<tau>external_def red_external_aggr_def)"], ["", "lemma \\<tau>external_red_external_aggr_TA_empty:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; \\<tau>external P (the (typeof_addr h a)) M \\<rbrakk> \\<Longrightarrow> ta = \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n     \\<tau>external P (the (typeof_addr h a)) M\\<rbrakk>\n    \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>", "by(auto elim!: \\<tau>external_defs.cases simp add: \\<tau>external_def red_external_aggr_def)"], ["", "end"], ["", "subsection \\<open>Code generation\\<close>"], ["", "code_pred \n  (modes:\n    i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> bool,\n    i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> bool,\n    i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> o \\<Rightarrow> bool,\n    o \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> o \\<Rightarrow> bool)\n  external_WT_defs"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "code_pred\n  (modes: i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> bool)\n  [inductify, skip_proof]\n  is_native"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "declare heap_base.heap_copy_loc.intros[code_pred_intro]"], ["", "code_pred\n  (modes: (i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> bool) \\<Rightarrow> (i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> bool) \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> o \\<Rightarrow> bool) \n  heap_base.heap_copy_loc"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap_base.heap_copy_loc x xa xb xc xd xe xf xg;\n     \\<And>heap_read heap_write a a' al h v h'.\n        \\<lbrakk>x = heap_read; xa = heap_write; xb = a; xc = a'; xd = al;\n         xe = h; xf = [ReadMem a al v, WriteMem a' al v]; xg = h';\n         heap_read h a al v; heap_write h a' al v h'\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap_base.heap_copy_loc x xa xb xc xd xe xf xg;\n     \\<And>heap_read heap_write a a' al h v h'.\n        \\<lbrakk>x = heap_read; xa = heap_write; xb = a; xc = a'; xd = al;\n         xe = h; xf = [ReadMem a al v, WriteMem a' al v]; xg = h';\n         heap_read h a al v; heap_write h a' al v h'\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "case heap_copy_loc"], ["proof (state)\nthis:\n  \\<lbrakk>x = ?heap_read; xa = ?heap_write; xb = ?a; xc = ?a'; xd = ?al;\n   xe = ?h; xf = [ReadMem ?a ?al ?v, WriteMem ?a' ?al ?v]; xg = ?h';\n   ?heap_read ?h ?a ?al ?v; ?heap_write ?h ?a' ?al ?v ?h'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  heap_base.heap_copy_loc x xa xb xc xd xe xf xg\n\ngoal (1 subgoal):\n 1. \\<lbrakk>heap_base.heap_copy_loc x xa xb xc xd xe xf xg;\n     \\<And>heap_read heap_write a a' al h v h'.\n        \\<lbrakk>x = heap_read; xa = heap_write; xb = a; xc = a'; xd = al;\n         xe = h; xf = [ReadMem a al v, WriteMem a' al v]; xg = h';\n         heap_read h a al v; heap_write h a' al v h'\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "from heap_copy_loc.prems"], ["proof (chain)\npicking this:\n  heap_base.heap_copy_loc x xa xb xc xd xe xf xg", "show thesis"], ["proof (prove)\nusing this:\n  heap_base.heap_copy_loc x xa xb xc xd xe xf xg\n\ngoal (1 subgoal):\n 1. thesis", "by(rule heap_base.heap_copy_loc.cases)(rule heap_copy_loc.that[OF refl refl refl refl refl refl])"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "declare heap_base.heap_copies.intros [code_pred_intro]"], ["", "code_pred\n  (modes: (i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> bool) => (i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> bool) \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> o \\<Rightarrow> bool)\n  heap_base.heap_copies"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap_base.heap_copies x xa xb xc xd xe xf xg;\n     \\<And>heap_read heap_write a a' h.\n        \\<lbrakk>x = heap_read; xa = heap_write; xb = a; xc = a'; xd = [];\n         xe = h; xf = []; xg = h\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>heap_read heap_write aa_ a'a_ al_ als_ ha_ ob_ obs_ h''_ h'_.\n        \\<lbrakk>x = heap_read; xa = heap_write; xb = aa_; xc = a'a_;\n         xd = al_ # als_; xe = ha_; xf = ob_ @ obs_; xg = h''_;\n         heap_base.heap_copy_loc heap_read heap_write aa_ a'a_ al_ ha_ ob_\n          h'_;\n         heap_base.heap_copies heap_read heap_write aa_ a'a_ als_ h'_ obs_\n          h''_\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap_base.heap_copies x xa xb xc xd xe xf xg;\n     \\<And>heap_read heap_write a a' h.\n        \\<lbrakk>x = heap_read; xa = heap_write; xb = a; xc = a'; xd = [];\n         xe = h; xf = []; xg = h\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>heap_read heap_write aa_ a'a_ al_ als_ ha_ ob_ obs_ h''_ h'_.\n        \\<lbrakk>x = heap_read; xa = heap_write; xb = aa_; xc = a'a_;\n         xd = al_ # als_; xe = ha_; xf = ob_ @ obs_; xg = h''_;\n         heap_base.heap_copy_loc heap_read heap_write aa_ a'a_ al_ ha_ ob_\n          h'_;\n         heap_base.heap_copies heap_read heap_write aa_ a'a_ als_ h'_ obs_\n          h''_\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "case heap_copies"], ["proof (state)\nthis:\n  \\<lbrakk>x = ?heap_read; xa = ?heap_write; xb = ?a; xc = ?a'; xd = [];\n   xe = ?h; xf = []; xg = ?h\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?heap_read; xa = ?heap_write; xb = ?aa; xc = ?a'a;\n   xd = ?al # ?als; xe = ?ha; xf = ?ob @ ?obs; xg = ?h'';\n   heap_base.heap_copy_loc ?heap_read ?heap_write ?aa ?a'a ?al ?ha ?ob ?h';\n   heap_base.heap_copies ?heap_read ?heap_write ?aa ?a'a ?als ?h' ?obs\n    ?h''\\<rbrakk>\n  \\<Longrightarrow> thesis\n  heap_base.heap_copies x xa xb xc xd xe xf xg\n\ngoal (1 subgoal):\n 1. \\<lbrakk>heap_base.heap_copies x xa xb xc xd xe xf xg;\n     \\<And>heap_read heap_write a a' h.\n        \\<lbrakk>x = heap_read; xa = heap_write; xb = a; xc = a'; xd = [];\n         xe = h; xf = []; xg = h\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>heap_read heap_write aa_ a'a_ al_ als_ ha_ ob_ obs_ h''_ h'_.\n        \\<lbrakk>x = heap_read; xa = heap_write; xb = aa_; xc = a'a_;\n         xd = al_ # als_; xe = ha_; xf = ob_ @ obs_; xg = h''_;\n         heap_base.heap_copy_loc heap_read heap_write aa_ a'a_ al_ ha_ ob_\n          h'_;\n         heap_base.heap_copies heap_read heap_write aa_ a'a_ als_ h'_ obs_\n          h''_\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "from heap_copies.prems"], ["proof (chain)\npicking this:\n  heap_base.heap_copies x xa xb xc xd xe xf xg", "show thesis"], ["proof (prove)\nusing this:\n  heap_base.heap_copies x xa xb xc xd xe xf xg\n\ngoal (1 subgoal):\n 1. thesis", "by(rule heap_base.heap_copies.cases)(erule (3) heap_copies.that[OF refl refl refl refl]|assumption)+"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "declare heap_base.heap_clone.intros [folded Predicate_Compile.contains_def, code_pred_intro]"], ["", "code_pred \n  (modes: i \\<Rightarrow> i \\<Rightarrow> (i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> bool) \\<Rightarrow> (i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> bool) \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> o \\<Rightarrow> bool)\n  heap_base.heap_clone"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap_base.heap_clone x xa xb xc xd xe xf xg xh;\n     \\<And>allocate typeof_addr heap_read heap_write P h a hT.\n        \\<lbrakk>x = allocate; xa = typeof_addr; xb = heap_read;\n         xc = heap_write; xd = P; xe = h; xf = a; xg = h; xh = None;\n         typeof_addr h a = \\<lfloor>hT\\<rfloor>; allocate h hT = {}\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>allocatea_ typeof_addra_ heap_read heap_write Pa_ ha_ aa_ h''_\n        a'_ C_ obs_ h'_ FDTs_.\n        \\<lbrakk>x = allocatea_; xa = typeof_addra_; xb = heap_read;\n         xc = heap_write; xd = Pa_; xe = ha_; xf = aa_; xg = h''_;\n         xh =\n         \\<lfloor>(NewHeapElem a'_ (Class_type C_) # obs_, a'_)\\<rfloor>;\n         typeof_addra_ ha_ aa_ = \\<lfloor>Class_type C_\\<rfloor>;\n         Predicate_Compile.contains (allocatea_ ha_ (Class_type C_))\n          (h'_, a'_);\n         Pa_ \\<turnstile> C_ has_fields FDTs_;\n         heap_base.heap_copies heap_read heap_write aa_ a'_\n          (map (\\<lambda>((F, D), Tfm). CField D F) FDTs_) h'_ obs_\n          h''_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>allocatea_ typeof_addra_ heap_read heap_write Pa_ ha_ aa_ h''_\n        a'_ T_ n_ obs_ h'_ FDTs_.\n        \\<lbrakk>x = allocatea_; xa = typeof_addra_; xb = heap_read;\n         xc = heap_write; xd = Pa_; xe = ha_; xf = aa_; xg = h''_;\n         xh =\n         \\<lfloor>(NewHeapElem a'_ (Array_type T_ n_) # obs_, a'_)\\<rfloor>;\n         typeof_addra_ ha_ aa_ = \\<lfloor>Array_type T_ n_\\<rfloor>;\n         Predicate_Compile.contains (allocatea_ ha_ (Array_type T_ n_))\n          (h'_, a'_);\n         Pa_ \\<turnstile> Object has_fields FDTs_;\n         heap_base.heap_copies heap_read heap_write aa_ a'_\n          (map (\\<lambda>((F, D), Tfm). CField D F) FDTs_ @\n           map ACell [0..<n_])\n          h'_ obs_ h''_\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap_base.heap_clone x xa xb xc xd xe xf xg xh;\n     \\<And>allocate typeof_addr heap_read heap_write P h a hT.\n        \\<lbrakk>x = allocate; xa = typeof_addr; xb = heap_read;\n         xc = heap_write; xd = P; xe = h; xf = a; xg = h; xh = None;\n         typeof_addr h a = \\<lfloor>hT\\<rfloor>; allocate h hT = {}\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>allocatea_ typeof_addra_ heap_read heap_write Pa_ ha_ aa_ h''_\n        a'_ C_ obs_ h'_ FDTs_.\n        \\<lbrakk>x = allocatea_; xa = typeof_addra_; xb = heap_read;\n         xc = heap_write; xd = Pa_; xe = ha_; xf = aa_; xg = h''_;\n         xh =\n         \\<lfloor>(NewHeapElem a'_ (Class_type C_) # obs_, a'_)\\<rfloor>;\n         typeof_addra_ ha_ aa_ = \\<lfloor>Class_type C_\\<rfloor>;\n         Predicate_Compile.contains (allocatea_ ha_ (Class_type C_))\n          (h'_, a'_);\n         Pa_ \\<turnstile> C_ has_fields FDTs_;\n         heap_base.heap_copies heap_read heap_write aa_ a'_\n          (map (\\<lambda>((F, D), Tfm). CField D F) FDTs_) h'_ obs_\n          h''_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>allocatea_ typeof_addra_ heap_read heap_write Pa_ ha_ aa_ h''_\n        a'_ T_ n_ obs_ h'_ FDTs_.\n        \\<lbrakk>x = allocatea_; xa = typeof_addra_; xb = heap_read;\n         xc = heap_write; xd = Pa_; xe = ha_; xf = aa_; xg = h''_;\n         xh =\n         \\<lfloor>(NewHeapElem a'_ (Array_type T_ n_) # obs_, a'_)\\<rfloor>;\n         typeof_addra_ ha_ aa_ = \\<lfloor>Array_type T_ n_\\<rfloor>;\n         Predicate_Compile.contains (allocatea_ ha_ (Array_type T_ n_))\n          (h'_, a'_);\n         Pa_ \\<turnstile> Object has_fields FDTs_;\n         heap_base.heap_copies heap_read heap_write aa_ a'_\n          (map (\\<lambda>((F, D), Tfm). CField D F) FDTs_ @\n           map ACell [0..<n_])\n          h'_ obs_ h''_\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "case heap_clone"], ["proof (state)\nthis:\n  \\<lbrakk>x = ?allocate; xa = ?typeof_addr; xb = ?heap_read;\n   xc = ?heap_write; xd = ?P; xe = ?h; xf = ?a; xg = ?h; xh = None;\n   ?typeof_addr ?h ?a = \\<lfloor>?hT\\<rfloor>;\n   ?allocate ?h ?hT = {}\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?allocatea; xa = ?typeof_addra; xb = ?heap_read;\n   xc = ?heap_write; xd = ?Pa; xe = ?ha; xf = ?aa; xg = ?h'';\n   xh = \\<lfloor>(NewHeapElem ?a' (Class_type ?C) # ?obs, ?a')\\<rfloor>;\n   ?typeof_addra ?ha ?aa = \\<lfloor>Class_type ?C\\<rfloor>;\n   Predicate_Compile.contains (?allocatea ?ha (Class_type ?C)) (?h', ?a');\n   ?Pa \\<turnstile> ?C has_fields ?FDTs;\n   heap_base.heap_copies ?heap_read ?heap_write ?aa ?a'\n    (map (\\<lambda>((F, D), Tfm). CField D F) ?FDTs) ?h' ?obs ?h''\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?allocatea; xa = ?typeof_addra; xb = ?heap_read;\n   xc = ?heap_write; xd = ?Pa; xe = ?ha; xf = ?aa; xg = ?h'';\n   xh = \\<lfloor>(NewHeapElem ?a' (Array_type ?T ?n) # ?obs, ?a')\\<rfloor>;\n   ?typeof_addra ?ha ?aa = \\<lfloor>Array_type ?T ?n\\<rfloor>;\n   Predicate_Compile.contains (?allocatea ?ha (Array_type ?T ?n))\n    (?h', ?a');\n   ?Pa \\<turnstile> Object has_fields ?FDTs;\n   heap_base.heap_copies ?heap_read ?heap_write ?aa ?a'\n    (map (\\<lambda>((F, D), Tfm). CField D F) ?FDTs @ map ACell [0..<?n])\n    ?h' ?obs ?h''\\<rbrakk>\n  \\<Longrightarrow> thesis\n  heap_base.heap_clone x xa xb xc xd xe xf xg xh\n\ngoal (1 subgoal):\n 1. \\<lbrakk>heap_base.heap_clone x xa xb xc xd xe xf xg xh;\n     \\<And>allocate typeof_addr heap_read heap_write P h a hT.\n        \\<lbrakk>x = allocate; xa = typeof_addr; xb = heap_read;\n         xc = heap_write; xd = P; xe = h; xf = a; xg = h; xh = None;\n         typeof_addr h a = \\<lfloor>hT\\<rfloor>; allocate h hT = {}\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>allocatea_ typeof_addra_ heap_read heap_write Pa_ ha_ aa_ h''_\n        a'_ C_ obs_ h'_ FDTs_.\n        \\<lbrakk>x = allocatea_; xa = typeof_addra_; xb = heap_read;\n         xc = heap_write; xd = Pa_; xe = ha_; xf = aa_; xg = h''_;\n         xh =\n         \\<lfloor>(NewHeapElem a'_ (Class_type C_) # obs_, a'_)\\<rfloor>;\n         typeof_addra_ ha_ aa_ = \\<lfloor>Class_type C_\\<rfloor>;\n         Predicate_Compile.contains (allocatea_ ha_ (Class_type C_))\n          (h'_, a'_);\n         Pa_ \\<turnstile> C_ has_fields FDTs_;\n         heap_base.heap_copies heap_read heap_write aa_ a'_\n          (map (\\<lambda>((F, D), Tfm). CField D F) FDTs_) h'_ obs_\n          h''_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>allocatea_ typeof_addra_ heap_read heap_write Pa_ ha_ aa_ h''_\n        a'_ T_ n_ obs_ h'_ FDTs_.\n        \\<lbrakk>x = allocatea_; xa = typeof_addra_; xb = heap_read;\n         xc = heap_write; xd = Pa_; xe = ha_; xf = aa_; xg = h''_;\n         xh =\n         \\<lfloor>(NewHeapElem a'_ (Array_type T_ n_) # obs_, a'_)\\<rfloor>;\n         typeof_addra_ ha_ aa_ = \\<lfloor>Array_type T_ n_\\<rfloor>;\n         Predicate_Compile.contains (allocatea_ ha_ (Array_type T_ n_))\n          (h'_, a'_);\n         Pa_ \\<turnstile> Object has_fields FDTs_;\n         heap_base.heap_copies heap_read heap_write aa_ a'_\n          (map (\\<lambda>((F, D), Tfm). CField D F) FDTs_ @\n           map ACell [0..<n_])\n          h'_ obs_ h''_\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "from heap_clone.prems"], ["proof (chain)\npicking this:\n  heap_base.heap_clone x xa xb xc xd xe xf xg xh", "show thesis"], ["proof (prove)\nusing this:\n  heap_base.heap_clone x xa xb xc xd xe xf xg xh\n\ngoal (1 subgoal):\n 1. thesis", "by(rule heap_base.heap_clone.cases[folded Predicate_Compile.contains_def])(erule (3) heap_clone.that[OF refl refl refl refl refl refl refl]|assumption)+"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  code\\_pred in Isabelle2012 cannot handle boolean parameters as premises properly, \n  so this replacement rule explicitly tests for @{term \"True\"}\n\\<close>"], ["", "lemma (in heap_base) RedWaitSpurious_Code:\n  \"spurious_wakeups = True \\<Longrightarrow> \n   P,t \\<turnstile> \\<langle>a\\<bullet>wait([]),h\\<rangle> -\\<lbrace>Unlock\\<rightarrow>a, Lock\\<rightarrow>a, ReleaseAcquire\\<rightarrow>a, IsInterrupted t False, SyncUnlock a\\<rbrace>\\<rightarrow>ext \\<langle>RetVal Unit,h\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spurious_wakeups = True \\<Longrightarrow>\n    P,t \\<turnstile> \\<langle>a\\<bullet>wait([]),\n                     h\\<rangle> -\\<lbrace>(Unlock, a),\n    (Lock, a), (ReleaseAcquire, a), IsInterrupted t False,\n    SyncUnlock a\\<rbrace>\\<rightarrow>ext \\<langle>RetVal Unit,h\\<rangle>", "by(rule RedWaitSpurious) simp"], ["", "lemmas [code_pred_intro] =\n  heap_base.RedNewThread heap_base.RedNewThreadFail \n  heap_base.RedJoin heap_base.RedJoinInterrupt\n  heap_base.RedInterrupt heap_base.RedInterruptInexist heap_base.RedIsInterruptedTrue heap_base.RedIsInterruptedFalse\n  heap_base.RedWaitInterrupt heap_base.RedWait heap_base.RedWaitFail heap_base.RedWaitNotified heap_base.RedWaitInterrupted"], ["", "declare heap_base.RedWaitSpurious_Code [code_pred_intro RedWaitSpurious]"], ["", "lemmas [code_pred_intro] =\n  heap_base.RedNotify heap_base.RedNotifyFail heap_base.RedNotifyAll heap_base.RedNotifyAllFail \n  heap_base.RedClone heap_base.RedCloneFail\n  heap_base.RedHashcode heap_base.RedPrint heap_base.RedCurrentThread \n  heap_base.RedInterruptedTrue heap_base.RedInterruptedFalse\n  heap_base.RedYield"], ["", "code_pred\n  (modes: i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> (i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> bool) \\<Rightarrow> (i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> bool) \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> o \\<Rightarrow> o \\<Rightarrow> bool)\n  heap_base.red_external"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap_base.red_external x xa xb xc xd xe xf xg xh xi xj xk xl xm\n              (xn, xo, xp, xq, xr, xs) xt xu;\n     \\<And>addr2thread_id thread_id2addr spurious_wakeups empty_heap\n        allocate typeof_addr heap_read heap_write P t h a C.\n        \\<lbrakk>x = addr2thread_id; xa = thread_id2addr;\n         xb = spurious_wakeups; xc = empty_heap; xd = allocate;\n         xe = typeof_addr; xf = heap_read; xg = heap_write; xh = P; xi = t;\n         xj = h; xk = a; xl = start; xm = [];\n         (xn, xo, xp, xq, xr, xs) =\n         \\<lbrace>NewThread (addr2thread_id a) (C, run, a) h,\n         ThreadStart (addr2thread_id a)\\<rbrace>;\n         xt = RetVal Unit; xu = h;\n         typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n         P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_ Ca_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = start; xm = [];\n         (xn, xo, xp, xq, xr, xs) =\n         \\<lbrace>ThreadExists (addr2thread_ida_ aa_) True\\<rbrace>;\n         xt =\n         RetExc\n          (heap_base.addr_of_sys_xcpt empty_heapa_ allocatea_\n            IllegalThreadState);\n         xu = ha_; typeof_addra_ ha_ aa_ = \\<lfloor>Class_type Ca_\\<rfloor>;\n         Pa_ \\<turnstile> Ca_ \\<preceq>\\<^sup>* Thread\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_ Ca_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = join; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>Join (addr2thread_ida_ aa_),\n         IsInterrupted ta_ False,\n         ThreadJoin (addr2thread_ida_ aa_)\\<rbrace>;\n         xt = RetVal Unit; xu = ha_;\n         typeof_addra_ ha_ aa_ = \\<lfloor>Class_type Ca_\\<rfloor>;\n         Pa_ \\<turnstile> Ca_ \\<preceq>\\<^sup>* Thread\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_ Ca_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = join; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>IsInterrupted ta_ True,\n         ClearInterrupt ta_, ObsInterrupted ta_\\<rbrace>;\n         xt =\n         RetExc\n          (heap_base.addr_of_sys_xcpt empty_heapa_ allocatea_\n            InterruptedException);\n         xu = ha_; typeof_addra_ ha_ aa_ = \\<lfloor>Class_type Ca_\\<rfloor>;\n         Pa_ \\<turnstile> Ca_ \\<preceq>\\<^sup>* Thread\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_ Ca_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = interrupt; xm = [];\n         (xn, xo, xp, xq, xr, xs) =\n         \\<lbrace>ThreadExists (addr2thread_ida_ aa_) True,\n         WakeUp (addr2thread_ida_ aa_), Interrupt (addr2thread_ida_ aa_),\n         ObsInterrupt (addr2thread_ida_ aa_)\\<rbrace>;\n         xt = RetVal Unit; xu = ha_;\n         typeof_addra_ ha_ aa_ = \\<lfloor>Class_type Ca_\\<rfloor>;\n         Pa_ \\<turnstile> Ca_ \\<preceq>\\<^sup>* Thread\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_ Ca_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = interrupt; xm = [];\n         (xn, xo, xp, xq, xr, xs) =\n         \\<lbrace>ThreadExists (addr2thread_ida_ aa_) False\\<rbrace>;\n         xt = RetVal Unit; xu = ha_;\n         typeof_addra_ ha_ aa_ = \\<lfloor>Class_type Ca_\\<rfloor>;\n         Pa_ \\<turnstile> Ca_ \\<preceq>\\<^sup>* Thread\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_ Ca_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = isInterrupted; xm = [];\n         (xn, xo, xp, xq, xr, xs) =\n         \\<lbrace>IsInterrupted (addr2thread_ida_ aa_) True,\n         ObsInterrupted (addr2thread_ida_ aa_)\\<rbrace>;\n         xt = RetVal (Bool True); xu = ha_;\n         typeof_addra_ ha_ aa_ = \\<lfloor>Class_type Ca_\\<rfloor>;\n         Pa_ \\<turnstile> Ca_ \\<preceq>\\<^sup>* Thread\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_ Ca_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = isInterrupted; xm = [];\n         (xn, xo, xp, xq, xr, xs) =\n         \\<lbrace>IsInterrupted (addr2thread_ida_ aa_) False\\<rbrace>;\n         xt = RetVal (Bool False); xu = ha_;\n         typeof_addra_ ha_ aa_ = \\<lfloor>Class_type Ca_\\<rfloor>;\n         Pa_ \\<turnstile> Ca_ \\<preceq>\\<^sup>* Thread\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = wait; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>(Unlock, aa_), (Lock, aa_),\n         IsInterrupted ta_ True, ClearInterrupt ta_,\n         ObsInterrupted ta_\\<rbrace>;\n         xt =\n         RetExc\n          (heap_base.addr_of_sys_xcpt empty_heapa_ allocatea_\n            InterruptedException);\n         xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = wait; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>Suspend aa_, (Unlock, aa_),\n         (Lock, aa_), (ReleaseAcquire, aa_), IsInterrupted ta_ False,\n         SyncUnlock aa_\\<rbrace>;\n         xt = RetStaySame; xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = wait; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>(UnlockFail, aa_)\\<rbrace>;\n         xt =\n         RetExc\n          (heap_base.addr_of_sys_xcpt empty_heapa_ allocatea_\n            IllegalMonitorState);\n         xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = wait; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>Notified\\<rbrace>;\n         xt = RetVal Unit; xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = wait; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>WokenUp, ClearInterrupt ta_,\n         ObsInterrupted ta_\\<rbrace>;\n         xt =\n         RetExc\n          (heap_base.addr_of_sys_xcpt empty_heapa_ allocatea_\n            InterruptedException);\n         xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = wait; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>(Unlock, aa_), (Lock, aa_),\n         (ReleaseAcquire, aa_), IsInterrupted ta_ False,\n         SyncUnlock aa_\\<rbrace>;\n         xt = RetVal Unit; xu = ha_; spurious_wakeupsa_ = True\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = notify; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>Notify aa_, (Unlock, aa_),\n         (Lock, aa_)\\<rbrace>;\n         xt = RetVal Unit; xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = notify; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>(UnlockFail, aa_)\\<rbrace>;\n         xt =\n         RetExc\n          (heap_base.addr_of_sys_xcpt empty_heapa_ allocatea_\n            IllegalMonitorState);\n         xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = notifyAll; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>NotifyAll aa_, (Unlock, aa_),\n         (Lock, aa_)\\<rbrace>;\n         xt = RetVal Unit; xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = notifyAll; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>(UnlockFail, aa_)\\<rbrace>;\n         xt =\n         RetExc\n          (heap_base.addr_of_sys_xcpt empty_heapa_ allocatea_\n            IllegalMonitorState);\n         xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_ obs_\n        a'_ h'_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = clone; xm = [];\n         (xn, xo, xp, xq, xr, xs) = (K$ [], [], [], [], [], obs_);\n         xt = RetVal (Addr a'_); xu = h'_;\n         heap_base.heap_clone allocatea_ typeof_addra_ heap_read heap_write\n          Pa_ ha_ aa_ h'_ \\<lfloor>(obs_, a'_)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_ h'_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = clone; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>\\<rbrace>;\n         xt =\n         RetExc\n          (heap_base.addr_of_sys_xcpt empty_heapa_ allocatea_ OutOfMemory);\n         xu = h'_;\n         heap_base.heap_clone allocatea_ typeof_addra_ heap_read heap_write\n          Pa_ ha_ aa_ h'_ None\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = hashcode; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>\\<rbrace>;\n         xt = RetVal (Intg (word_of_int (hash_addr aa_))); xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_ vs_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = print; xm = vs_;\n         (xn, xo, xp, xq, xr, xs) =\n         \\<lbrace>ExternalCall aa_ print vs_ Unit\\<rbrace>;\n         xt = RetVal Unit; xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = currentThread; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>\\<rbrace>;\n         xt = RetVal (Addr (thread_id2addra_ ta_)); xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = interrupted; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>IsInterrupted ta_ True,\n         ClearInterrupt ta_, ObsInterrupted ta_\\<rbrace>;\n         xt = RetVal (Bool True); xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = interrupted; xm = [];\n         (xn, xo, xp, xq, xr, xs) =\n         \\<lbrace>IsInterrupted ta_ False\\<rbrace>;\n         xt = RetVal (Bool False); xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = yield; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>Yield\\<rbrace>;\n         xt = RetVal Unit; xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap_base.red_external x xa xb xc xd xe xf xg xh xi xj xk xl xm\n              (xn, xo, xp, xq, xr, xs) xt xu;\n     \\<And>addr2thread_id thread_id2addr spurious_wakeups empty_heap\n        allocate typeof_addr heap_read heap_write P t h a C.\n        \\<lbrakk>x = addr2thread_id; xa = thread_id2addr;\n         xb = spurious_wakeups; xc = empty_heap; xd = allocate;\n         xe = typeof_addr; xf = heap_read; xg = heap_write; xh = P; xi = t;\n         xj = h; xk = a; xl = start; xm = [];\n         (xn, xo, xp, xq, xr, xs) =\n         \\<lbrace>NewThread (addr2thread_id a) (C, run, a) h,\n         ThreadStart (addr2thread_id a)\\<rbrace>;\n         xt = RetVal Unit; xu = h;\n         typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n         P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_ Ca_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = start; xm = [];\n         (xn, xo, xp, xq, xr, xs) =\n         \\<lbrace>ThreadExists (addr2thread_ida_ aa_) True\\<rbrace>;\n         xt =\n         RetExc\n          (heap_base.addr_of_sys_xcpt empty_heapa_ allocatea_\n            IllegalThreadState);\n         xu = ha_; typeof_addra_ ha_ aa_ = \\<lfloor>Class_type Ca_\\<rfloor>;\n         Pa_ \\<turnstile> Ca_ \\<preceq>\\<^sup>* Thread\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_ Ca_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = join; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>Join (addr2thread_ida_ aa_),\n         IsInterrupted ta_ False,\n         ThreadJoin (addr2thread_ida_ aa_)\\<rbrace>;\n         xt = RetVal Unit; xu = ha_;\n         typeof_addra_ ha_ aa_ = \\<lfloor>Class_type Ca_\\<rfloor>;\n         Pa_ \\<turnstile> Ca_ \\<preceq>\\<^sup>* Thread\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_ Ca_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = join; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>IsInterrupted ta_ True,\n         ClearInterrupt ta_, ObsInterrupted ta_\\<rbrace>;\n         xt =\n         RetExc\n          (heap_base.addr_of_sys_xcpt empty_heapa_ allocatea_\n            InterruptedException);\n         xu = ha_; typeof_addra_ ha_ aa_ = \\<lfloor>Class_type Ca_\\<rfloor>;\n         Pa_ \\<turnstile> Ca_ \\<preceq>\\<^sup>* Thread\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_ Ca_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = interrupt; xm = [];\n         (xn, xo, xp, xq, xr, xs) =\n         \\<lbrace>ThreadExists (addr2thread_ida_ aa_) True,\n         WakeUp (addr2thread_ida_ aa_), Interrupt (addr2thread_ida_ aa_),\n         ObsInterrupt (addr2thread_ida_ aa_)\\<rbrace>;\n         xt = RetVal Unit; xu = ha_;\n         typeof_addra_ ha_ aa_ = \\<lfloor>Class_type Ca_\\<rfloor>;\n         Pa_ \\<turnstile> Ca_ \\<preceq>\\<^sup>* Thread\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_ Ca_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = interrupt; xm = [];\n         (xn, xo, xp, xq, xr, xs) =\n         \\<lbrace>ThreadExists (addr2thread_ida_ aa_) False\\<rbrace>;\n         xt = RetVal Unit; xu = ha_;\n         typeof_addra_ ha_ aa_ = \\<lfloor>Class_type Ca_\\<rfloor>;\n         Pa_ \\<turnstile> Ca_ \\<preceq>\\<^sup>* Thread\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_ Ca_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = isInterrupted; xm = [];\n         (xn, xo, xp, xq, xr, xs) =\n         \\<lbrace>IsInterrupted (addr2thread_ida_ aa_) True,\n         ObsInterrupted (addr2thread_ida_ aa_)\\<rbrace>;\n         xt = RetVal (Bool True); xu = ha_;\n         typeof_addra_ ha_ aa_ = \\<lfloor>Class_type Ca_\\<rfloor>;\n         Pa_ \\<turnstile> Ca_ \\<preceq>\\<^sup>* Thread\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_ Ca_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = isInterrupted; xm = [];\n         (xn, xo, xp, xq, xr, xs) =\n         \\<lbrace>IsInterrupted (addr2thread_ida_ aa_) False\\<rbrace>;\n         xt = RetVal (Bool False); xu = ha_;\n         typeof_addra_ ha_ aa_ = \\<lfloor>Class_type Ca_\\<rfloor>;\n         Pa_ \\<turnstile> Ca_ \\<preceq>\\<^sup>* Thread\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = wait; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>(Unlock, aa_), (Lock, aa_),\n         IsInterrupted ta_ True, ClearInterrupt ta_,\n         ObsInterrupted ta_\\<rbrace>;\n         xt =\n         RetExc\n          (heap_base.addr_of_sys_xcpt empty_heapa_ allocatea_\n            InterruptedException);\n         xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = wait; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>Suspend aa_, (Unlock, aa_),\n         (Lock, aa_), (ReleaseAcquire, aa_), IsInterrupted ta_ False,\n         SyncUnlock aa_\\<rbrace>;\n         xt = RetStaySame; xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = wait; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>(UnlockFail, aa_)\\<rbrace>;\n         xt =\n         RetExc\n          (heap_base.addr_of_sys_xcpt empty_heapa_ allocatea_\n            IllegalMonitorState);\n         xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = wait; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>Notified\\<rbrace>;\n         xt = RetVal Unit; xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = wait; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>WokenUp, ClearInterrupt ta_,\n         ObsInterrupted ta_\\<rbrace>;\n         xt =\n         RetExc\n          (heap_base.addr_of_sys_xcpt empty_heapa_ allocatea_\n            InterruptedException);\n         xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = wait; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>(Unlock, aa_), (Lock, aa_),\n         (ReleaseAcquire, aa_), IsInterrupted ta_ False,\n         SyncUnlock aa_\\<rbrace>;\n         xt = RetVal Unit; xu = ha_; spurious_wakeupsa_ = True\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = notify; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>Notify aa_, (Unlock, aa_),\n         (Lock, aa_)\\<rbrace>;\n         xt = RetVal Unit; xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = notify; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>(UnlockFail, aa_)\\<rbrace>;\n         xt =\n         RetExc\n          (heap_base.addr_of_sys_xcpt empty_heapa_ allocatea_\n            IllegalMonitorState);\n         xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = notifyAll; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>NotifyAll aa_, (Unlock, aa_),\n         (Lock, aa_)\\<rbrace>;\n         xt = RetVal Unit; xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = notifyAll; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>(UnlockFail, aa_)\\<rbrace>;\n         xt =\n         RetExc\n          (heap_base.addr_of_sys_xcpt empty_heapa_ allocatea_\n            IllegalMonitorState);\n         xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_ obs_\n        a'_ h'_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = clone; xm = [];\n         (xn, xo, xp, xq, xr, xs) = (K$ [], [], [], [], [], obs_);\n         xt = RetVal (Addr a'_); xu = h'_;\n         heap_base.heap_clone allocatea_ typeof_addra_ heap_read heap_write\n          Pa_ ha_ aa_ h'_ \\<lfloor>(obs_, a'_)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_ h'_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = clone; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>\\<rbrace>;\n         xt =\n         RetExc\n          (heap_base.addr_of_sys_xcpt empty_heapa_ allocatea_ OutOfMemory);\n         xu = h'_;\n         heap_base.heap_clone allocatea_ typeof_addra_ heap_read heap_write\n          Pa_ ha_ aa_ h'_ None\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = hashcode; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>\\<rbrace>;\n         xt = RetVal (Intg (word_of_int (hash_addr aa_))); xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_ vs_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = print; xm = vs_;\n         (xn, xo, xp, xq, xr, xs) =\n         \\<lbrace>ExternalCall aa_ print vs_ Unit\\<rbrace>;\n         xt = RetVal Unit; xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = currentThread; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>\\<rbrace>;\n         xt = RetVal (Addr (thread_id2addra_ ta_)); xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = interrupted; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>IsInterrupted ta_ True,\n         ClearInterrupt ta_, ObsInterrupted ta_\\<rbrace>;\n         xt = RetVal (Bool True); xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = interrupted; xm = [];\n         (xn, xo, xp, xq, xr, xs) =\n         \\<lbrace>IsInterrupted ta_ False\\<rbrace>;\n         xt = RetVal (Bool False); xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = yield; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>Yield\\<rbrace>;\n         xt = RetVal Unit; xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "case red_external"], ["proof (state)\nthis:\n  \\<lbrakk>x = ?addr2thread_id; xa = ?thread_id2addr;\n   xb = ?spurious_wakeups; xc = ?empty_heap; xd = ?allocate;\n   xe = ?typeof_addr; xf = ?heap_read; xg = ?heap_write; xh = ?P; xi = ?t;\n   xj = ?h; xk = ?a; xl = start; xm = [];\n   (xn, xo, xp, xq, xr, xs) =\n   \\<lbrace>NewThread (?addr2thread_id ?a) (?C, run, ?a) ?h,\n   ThreadStart (?addr2thread_id ?a)\\<rbrace>;\n   xt = RetVal Unit; xu = ?h;\n   ?typeof_addr ?h ?a = \\<lfloor>Class_type ?C\\<rfloor>;\n   ?P \\<turnstile> ?C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?addr2thread_ida; xa = ?thread_id2addra;\n   xb = ?spurious_wakeupsa; xc = ?empty_heapa; xd = ?allocatea;\n   xe = ?typeof_addra; xf = ?heap_read; xg = ?heap_write; xh = ?Pa;\n   xi = ?ta; xj = ?ha; xk = ?aa; xl = start; xm = [];\n   (xn, xo, xp, xq, xr, xs) =\n   \\<lbrace>ThreadExists (?addr2thread_ida ?aa) True\\<rbrace>;\n   xt =\n   RetExc\n    (heap_base.addr_of_sys_xcpt ?empty_heapa ?allocatea IllegalThreadState);\n   xu = ?ha; ?typeof_addra ?ha ?aa = \\<lfloor>Class_type ?Ca\\<rfloor>;\n   ?Pa \\<turnstile> ?Ca \\<preceq>\\<^sup>* Thread\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?addr2thread_ida; xa = ?thread_id2addra;\n   xb = ?spurious_wakeupsa; xc = ?empty_heapa; xd = ?allocatea;\n   xe = ?typeof_addra; xf = ?heap_read; xg = ?heap_write; xh = ?Pa;\n   xi = ?ta; xj = ?ha; xk = ?aa; xl = join; xm = [];\n   (xn, xo, xp, xq, xr, xs) = \\<lbrace>Join (?addr2thread_ida ?aa),\n   IsInterrupted ?ta False, ThreadJoin (?addr2thread_ida ?aa)\\<rbrace>;\n   xt = RetVal Unit; xu = ?ha;\n   ?typeof_addra ?ha ?aa = \\<lfloor>Class_type ?Ca\\<rfloor>;\n   ?Pa \\<turnstile> ?Ca \\<preceq>\\<^sup>* Thread\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?addr2thread_ida; xa = ?thread_id2addra;\n   xb = ?spurious_wakeupsa; xc = ?empty_heapa; xd = ?allocatea;\n   xe = ?typeof_addra; xf = ?heap_read; xg = ?heap_write; xh = ?Pa;\n   xi = ?ta; xj = ?ha; xk = ?aa; xl = join; xm = [];\n   (xn, xo, xp, xq, xr, xs) = \\<lbrace>IsInterrupted ?ta True,\n   ClearInterrupt ?ta, ObsInterrupted ?ta\\<rbrace>;\n   xt =\n   RetExc\n    (heap_base.addr_of_sys_xcpt ?empty_heapa ?allocatea\n      InterruptedException);\n   xu = ?ha; ?typeof_addra ?ha ?aa = \\<lfloor>Class_type ?Ca\\<rfloor>;\n   ?Pa \\<turnstile> ?Ca \\<preceq>\\<^sup>* Thread\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?addr2thread_ida; xa = ?thread_id2addra;\n   xb = ?spurious_wakeupsa; xc = ?empty_heapa; xd = ?allocatea;\n   xe = ?typeof_addra; xf = ?heap_read; xg = ?heap_write; xh = ?Pa;\n   xi = ?ta; xj = ?ha; xk = ?aa; xl = interrupt; xm = [];\n   (xn, xo, xp, xq, xr, xs) =\n   \\<lbrace>ThreadExists (?addr2thread_ida ?aa) True,\n   WakeUp (?addr2thread_ida ?aa), Interrupt (?addr2thread_ida ?aa),\n   ObsInterrupt (?addr2thread_ida ?aa)\\<rbrace>;\n   xt = RetVal Unit; xu = ?ha;\n   ?typeof_addra ?ha ?aa = \\<lfloor>Class_type ?Ca\\<rfloor>;\n   ?Pa \\<turnstile> ?Ca \\<preceq>\\<^sup>* Thread\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?addr2thread_ida; xa = ?thread_id2addra;\n   xb = ?spurious_wakeupsa; xc = ?empty_heapa; xd = ?allocatea;\n   xe = ?typeof_addra; xf = ?heap_read; xg = ?heap_write; xh = ?Pa;\n   xi = ?ta; xj = ?ha; xk = ?aa; xl = interrupt; xm = [];\n   (xn, xo, xp, xq, xr, xs) =\n   \\<lbrace>ThreadExists (?addr2thread_ida ?aa) False\\<rbrace>;\n   xt = RetVal Unit; xu = ?ha;\n   ?typeof_addra ?ha ?aa = \\<lfloor>Class_type ?Ca\\<rfloor>;\n   ?Pa \\<turnstile> ?Ca \\<preceq>\\<^sup>* Thread\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?addr2thread_ida; xa = ?thread_id2addra;\n   xb = ?spurious_wakeupsa; xc = ?empty_heapa; xd = ?allocatea;\n   xe = ?typeof_addra; xf = ?heap_read; xg = ?heap_write; xh = ?Pa;\n   xi = ?ta; xj = ?ha; xk = ?aa; xl = isInterrupted; xm = [];\n   (xn, xo, xp, xq, xr, xs) =\n   \\<lbrace>IsInterrupted (?addr2thread_ida ?aa) True,\n   ObsInterrupted (?addr2thread_ida ?aa)\\<rbrace>;\n   xt = RetVal (Bool True); xu = ?ha;\n   ?typeof_addra ?ha ?aa = \\<lfloor>Class_type ?Ca\\<rfloor>;\n   ?Pa \\<turnstile> ?Ca \\<preceq>\\<^sup>* Thread\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?addr2thread_ida; xa = ?thread_id2addra;\n   xb = ?spurious_wakeupsa; xc = ?empty_heapa; xd = ?allocatea;\n   xe = ?typeof_addra; xf = ?heap_read; xg = ?heap_write; xh = ?Pa;\n   xi = ?ta; xj = ?ha; xk = ?aa; xl = isInterrupted; xm = [];\n   (xn, xo, xp, xq, xr, xs) =\n   \\<lbrace>IsInterrupted (?addr2thread_ida ?aa) False\\<rbrace>;\n   xt = RetVal (Bool False); xu = ?ha;\n   ?typeof_addra ?ha ?aa = \\<lfloor>Class_type ?Ca\\<rfloor>;\n   ?Pa \\<turnstile> ?Ca \\<preceq>\\<^sup>* Thread\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?addr2thread_ida; xa = ?thread_id2addra;\n   xb = ?spurious_wakeupsa; xc = ?empty_heapa; xd = ?allocatea;\n   xe = ?typeof_addra; xf = ?heap_read; xg = ?heap_write; xh = ?Pa;\n   xi = ?ta; xj = ?ha; xk = ?aa; xl = wait; xm = [];\n   (xn, xo, xp, xq, xr, xs) = \\<lbrace>(Unlock, ?aa), (Lock, ?aa),\n   IsInterrupted ?ta True, ClearInterrupt ?ta, ObsInterrupted ?ta\\<rbrace>;\n   xt =\n   RetExc\n    (heap_base.addr_of_sys_xcpt ?empty_heapa ?allocatea\n      InterruptedException);\n   xu = ?ha\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?addr2thread_ida; xa = ?thread_id2addra;\n   xb = ?spurious_wakeupsa; xc = ?empty_heapa; xd = ?allocatea;\n   xe = ?typeof_addra; xf = ?heap_read; xg = ?heap_write; xh = ?Pa;\n   xi = ?ta; xj = ?ha; xk = ?aa; xl = wait; xm = [];\n   (xn, xo, xp, xq, xr, xs) = \\<lbrace>Suspend ?aa, (Unlock, ?aa),\n   (Lock, ?aa), (ReleaseAcquire, ?aa), IsInterrupted ?ta False,\n   SyncUnlock ?aa\\<rbrace>;\n   xt = RetStaySame; xu = ?ha\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?addr2thread_ida; xa = ?thread_id2addra;\n   xb = ?spurious_wakeupsa; xc = ?empty_heapa; xd = ?allocatea;\n   xe = ?typeof_addra; xf = ?heap_read; xg = ?heap_write; xh = ?Pa;\n   xi = ?ta; xj = ?ha; xk = ?aa; xl = wait; xm = [];\n   (xn, xo, xp, xq, xr, xs) = \\<lbrace>(UnlockFail, ?aa)\\<rbrace>;\n   xt =\n   RetExc\n    (heap_base.addr_of_sys_xcpt ?empty_heapa ?allocatea\n      IllegalMonitorState);\n   xu = ?ha\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?addr2thread_ida; xa = ?thread_id2addra;\n   xb = ?spurious_wakeupsa; xc = ?empty_heapa; xd = ?allocatea;\n   xe = ?typeof_addra; xf = ?heap_read; xg = ?heap_write; xh = ?Pa;\n   xi = ?ta; xj = ?ha; xk = ?aa; xl = wait; xm = [];\n   (xn, xo, xp, xq, xr, xs) = \\<lbrace>Notified\\<rbrace>; xt = RetVal Unit;\n   xu = ?ha\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?addr2thread_ida; xa = ?thread_id2addra;\n   xb = ?spurious_wakeupsa; xc = ?empty_heapa; xd = ?allocatea;\n   xe = ?typeof_addra; xf = ?heap_read; xg = ?heap_write; xh = ?Pa;\n   xi = ?ta; xj = ?ha; xk = ?aa; xl = wait; xm = [];\n   (xn, xo, xp, xq, xr, xs) = \\<lbrace>WokenUp, ClearInterrupt ?ta,\n   ObsInterrupted ?ta\\<rbrace>;\n   xt =\n   RetExc\n    (heap_base.addr_of_sys_xcpt ?empty_heapa ?allocatea\n      InterruptedException);\n   xu = ?ha\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?addr2thread_ida; xa = ?thread_id2addra;\n   xb = ?spurious_wakeupsa; xc = ?empty_heapa; xd = ?allocatea;\n   xe = ?typeof_addra; xf = ?heap_read; xg = ?heap_write; xh = ?Pa;\n   xi = ?ta; xj = ?ha; xk = ?aa; xl = wait; xm = [];\n   (xn, xo, xp, xq, xr, xs) = \\<lbrace>(Unlock, ?aa), (Lock, ?aa),\n   (ReleaseAcquire, ?aa), IsInterrupted ?ta False, SyncUnlock ?aa\\<rbrace>;\n   xt = RetVal Unit; xu = ?ha; ?spurious_wakeupsa = True\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?addr2thread_ida; xa = ?thread_id2addra;\n   xb = ?spurious_wakeupsa; xc = ?empty_heapa; xd = ?allocatea;\n   xe = ?typeof_addra; xf = ?heap_read; xg = ?heap_write; xh = ?Pa;\n   xi = ?ta; xj = ?ha; xk = ?aa; xl = notify; xm = [];\n   (xn, xo, xp, xq, xr, xs) = \\<lbrace>Notify ?aa, (Unlock, ?aa),\n   (Lock, ?aa)\\<rbrace>;\n   xt = RetVal Unit; xu = ?ha\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?addr2thread_ida; xa = ?thread_id2addra;\n   xb = ?spurious_wakeupsa; xc = ?empty_heapa; xd = ?allocatea;\n   xe = ?typeof_addra; xf = ?heap_read; xg = ?heap_write; xh = ?Pa;\n   xi = ?ta; xj = ?ha; xk = ?aa; xl = notify; xm = [];\n   (xn, xo, xp, xq, xr, xs) = \\<lbrace>(UnlockFail, ?aa)\\<rbrace>;\n   xt =\n   RetExc\n    (heap_base.addr_of_sys_xcpt ?empty_heapa ?allocatea\n      IllegalMonitorState);\n   xu = ?ha\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?addr2thread_ida; xa = ?thread_id2addra;\n   xb = ?spurious_wakeupsa; xc = ?empty_heapa; xd = ?allocatea;\n   xe = ?typeof_addra; xf = ?heap_read; xg = ?heap_write; xh = ?Pa;\n   xi = ?ta; xj = ?ha; xk = ?aa; xl = notifyAll; xm = [];\n   (xn, xo, xp, xq, xr, xs) = \\<lbrace>NotifyAll ?aa, (Unlock, ?aa),\n   (Lock, ?aa)\\<rbrace>;\n   xt = RetVal Unit; xu = ?ha\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?addr2thread_ida; xa = ?thread_id2addra;\n   xb = ?spurious_wakeupsa; xc = ?empty_heapa; xd = ?allocatea;\n   xe = ?typeof_addra; xf = ?heap_read; xg = ?heap_write; xh = ?Pa;\n   xi = ?ta; xj = ?ha; xk = ?aa; xl = notifyAll; xm = [];\n   (xn, xo, xp, xq, xr, xs) = \\<lbrace>(UnlockFail, ?aa)\\<rbrace>;\n   xt =\n   RetExc\n    (heap_base.addr_of_sys_xcpt ?empty_heapa ?allocatea\n      IllegalMonitorState);\n   xu = ?ha\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?addr2thread_ida; xa = ?thread_id2addra;\n   xb = ?spurious_wakeupsa; xc = ?empty_heapa; xd = ?allocatea;\n   xe = ?typeof_addra; xf = ?heap_read; xg = ?heap_write; xh = ?Pa;\n   xi = ?ta; xj = ?ha; xk = ?aa; xl = clone; xm = [];\n   (xn, xo, xp, xq, xr, xs) = (K$ [], [], [], [], [], ?obs);\n   xt = RetVal (Addr ?a'); xu = ?h';\n   heap_base.heap_clone ?allocatea ?typeof_addra ?heap_read ?heap_write ?Pa\n    ?ha ?aa ?h' \\<lfloor>(?obs, ?a')\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?addr2thread_ida; xa = ?thread_id2addra;\n   xb = ?spurious_wakeupsa; xc = ?empty_heapa; xd = ?allocatea;\n   xe = ?typeof_addra; xf = ?heap_read; xg = ?heap_write; xh = ?Pa;\n   xi = ?ta; xj = ?ha; xk = ?aa; xl = clone; xm = [];\n   (xn, xo, xp, xq, xr, xs) = \\<lbrace>\\<rbrace>;\n   xt =\n   RetExc (heap_base.addr_of_sys_xcpt ?empty_heapa ?allocatea OutOfMemory);\n   xu = ?h';\n   heap_base.heap_clone ?allocatea ?typeof_addra ?heap_read ?heap_write ?Pa\n    ?ha ?aa ?h' None\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?addr2thread_ida; xa = ?thread_id2addra;\n   xb = ?spurious_wakeupsa; xc = ?empty_heapa; xd = ?allocatea;\n   xe = ?typeof_addra; xf = ?heap_read; xg = ?heap_write; xh = ?Pa;\n   xi = ?ta; xj = ?ha; xk = ?aa; xl = hashcode; xm = [];\n   (xn, xo, xp, xq, xr, xs) = \\<lbrace>\\<rbrace>;\n   xt = RetVal (Intg (word_of_int (hash_addr ?aa))); xu = ?ha\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?addr2thread_ida; xa = ?thread_id2addra;\n   xb = ?spurious_wakeupsa; xc = ?empty_heapa; xd = ?allocatea;\n   xe = ?typeof_addra; xf = ?heap_read; xg = ?heap_write; xh = ?Pa;\n   xi = ?ta; xj = ?ha; xk = ?aa; xl = print; xm = ?vs;\n   (xn, xo, xp, xq, xr, xs) =\n   \\<lbrace>ExternalCall ?aa print ?vs Unit\\<rbrace>;\n   xt = RetVal Unit; xu = ?ha\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?addr2thread_ida; xa = ?thread_id2addra;\n   xb = ?spurious_wakeupsa; xc = ?empty_heapa; xd = ?allocatea;\n   xe = ?typeof_addra; xf = ?heap_read; xg = ?heap_write; xh = ?Pa;\n   xi = ?ta; xj = ?ha; xk = ?aa; xl = currentThread; xm = [];\n   (xn, xo, xp, xq, xr, xs) = \\<lbrace>\\<rbrace>;\n   xt = RetVal (Addr (?thread_id2addra ?ta)); xu = ?ha\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?addr2thread_ida; xa = ?thread_id2addra;\n   xb = ?spurious_wakeupsa; xc = ?empty_heapa; xd = ?allocatea;\n   xe = ?typeof_addra; xf = ?heap_read; xg = ?heap_write; xh = ?Pa;\n   xi = ?ta; xj = ?ha; xk = ?aa; xl = interrupted; xm = [];\n   (xn, xo, xp, xq, xr, xs) = \\<lbrace>IsInterrupted ?ta True,\n   ClearInterrupt ?ta, ObsInterrupted ?ta\\<rbrace>;\n   xt = RetVal (Bool True); xu = ?ha\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?addr2thread_ida; xa = ?thread_id2addra;\n   xb = ?spurious_wakeupsa; xc = ?empty_heapa; xd = ?allocatea;\n   xe = ?typeof_addra; xf = ?heap_read; xg = ?heap_write; xh = ?Pa;\n   xi = ?ta; xj = ?ha; xk = ?aa; xl = interrupted; xm = [];\n   (xn, xo, xp, xq, xr, xs) = \\<lbrace>IsInterrupted ?ta False\\<rbrace>;\n   xt = RetVal (Bool False); xu = ?ha\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?addr2thread_ida; xa = ?thread_id2addra;\n   xb = ?spurious_wakeupsa; xc = ?empty_heapa; xd = ?allocatea;\n   xe = ?typeof_addra; xf = ?heap_read; xg = ?heap_write; xh = ?Pa;\n   xi = ?ta; xj = ?ha; xk = ?aa; xl = yield; xm = [];\n   (xn, xo, xp, xq, xr, xs) = \\<lbrace>Yield\\<rbrace>; xt = RetVal Unit;\n   xu = ?ha\\<rbrakk>\n  \\<Longrightarrow> thesis\n  heap_base.red_external x xa xb xc xd xe xf xg xh xi xj xk xl xm\n   (xn, xo, xp, xq, xr, xs) xt xu\n  \\<lbrakk>x = ?addr2thread_ida; xa = ?thread_id2addra;\n   xb = ?spurious_wakeupsa; xc = ?empty_heapa; xd = ?allocatea;\n   xe = ?typeof_addra; xf = ?heap_read; xg = ?heap_write; xh = ?Pa;\n   xi = ?ta; xj = ?ha; xk = ?aa; xl = wait; xm = [];\n   (xn, xo, xp, xq, xr, xs) = \\<lbrace>(Unlock, ?aa), (Lock, ?aa),\n   (ReleaseAcquire, ?aa), IsInterrupted ?ta False, SyncUnlock ?aa\\<rbrace>;\n   xt = RetVal Unit; xu = ?ha; ?spurious_wakeupsa = True\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>heap_base.red_external x xa xb xc xd xe xf xg xh xi xj xk xl xm\n              (xn, xo, xp, xq, xr, xs) xt xu;\n     \\<And>addr2thread_id thread_id2addr spurious_wakeups empty_heap\n        allocate typeof_addr heap_read heap_write P t h a C.\n        \\<lbrakk>x = addr2thread_id; xa = thread_id2addr;\n         xb = spurious_wakeups; xc = empty_heap; xd = allocate;\n         xe = typeof_addr; xf = heap_read; xg = heap_write; xh = P; xi = t;\n         xj = h; xk = a; xl = start; xm = [];\n         (xn, xo, xp, xq, xr, xs) =\n         \\<lbrace>NewThread (addr2thread_id a) (C, run, a) h,\n         ThreadStart (addr2thread_id a)\\<rbrace>;\n         xt = RetVal Unit; xu = h;\n         typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n         P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_ Ca_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = start; xm = [];\n         (xn, xo, xp, xq, xr, xs) =\n         \\<lbrace>ThreadExists (addr2thread_ida_ aa_) True\\<rbrace>;\n         xt =\n         RetExc\n          (heap_base.addr_of_sys_xcpt empty_heapa_ allocatea_\n            IllegalThreadState);\n         xu = ha_; typeof_addra_ ha_ aa_ = \\<lfloor>Class_type Ca_\\<rfloor>;\n         Pa_ \\<turnstile> Ca_ \\<preceq>\\<^sup>* Thread\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_ Ca_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = join; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>Join (addr2thread_ida_ aa_),\n         IsInterrupted ta_ False,\n         ThreadJoin (addr2thread_ida_ aa_)\\<rbrace>;\n         xt = RetVal Unit; xu = ha_;\n         typeof_addra_ ha_ aa_ = \\<lfloor>Class_type Ca_\\<rfloor>;\n         Pa_ \\<turnstile> Ca_ \\<preceq>\\<^sup>* Thread\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_ Ca_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = join; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>IsInterrupted ta_ True,\n         ClearInterrupt ta_, ObsInterrupted ta_\\<rbrace>;\n         xt =\n         RetExc\n          (heap_base.addr_of_sys_xcpt empty_heapa_ allocatea_\n            InterruptedException);\n         xu = ha_; typeof_addra_ ha_ aa_ = \\<lfloor>Class_type Ca_\\<rfloor>;\n         Pa_ \\<turnstile> Ca_ \\<preceq>\\<^sup>* Thread\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_ Ca_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = interrupt; xm = [];\n         (xn, xo, xp, xq, xr, xs) =\n         \\<lbrace>ThreadExists (addr2thread_ida_ aa_) True,\n         WakeUp (addr2thread_ida_ aa_), Interrupt (addr2thread_ida_ aa_),\n         ObsInterrupt (addr2thread_ida_ aa_)\\<rbrace>;\n         xt = RetVal Unit; xu = ha_;\n         typeof_addra_ ha_ aa_ = \\<lfloor>Class_type Ca_\\<rfloor>;\n         Pa_ \\<turnstile> Ca_ \\<preceq>\\<^sup>* Thread\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_ Ca_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = interrupt; xm = [];\n         (xn, xo, xp, xq, xr, xs) =\n         \\<lbrace>ThreadExists (addr2thread_ida_ aa_) False\\<rbrace>;\n         xt = RetVal Unit; xu = ha_;\n         typeof_addra_ ha_ aa_ = \\<lfloor>Class_type Ca_\\<rfloor>;\n         Pa_ \\<turnstile> Ca_ \\<preceq>\\<^sup>* Thread\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_ Ca_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = isInterrupted; xm = [];\n         (xn, xo, xp, xq, xr, xs) =\n         \\<lbrace>IsInterrupted (addr2thread_ida_ aa_) True,\n         ObsInterrupted (addr2thread_ida_ aa_)\\<rbrace>;\n         xt = RetVal (Bool True); xu = ha_;\n         typeof_addra_ ha_ aa_ = \\<lfloor>Class_type Ca_\\<rfloor>;\n         Pa_ \\<turnstile> Ca_ \\<preceq>\\<^sup>* Thread\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_ Ca_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = isInterrupted; xm = [];\n         (xn, xo, xp, xq, xr, xs) =\n         \\<lbrace>IsInterrupted (addr2thread_ida_ aa_) False\\<rbrace>;\n         xt = RetVal (Bool False); xu = ha_;\n         typeof_addra_ ha_ aa_ = \\<lfloor>Class_type Ca_\\<rfloor>;\n         Pa_ \\<turnstile> Ca_ \\<preceq>\\<^sup>* Thread\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = wait; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>(Unlock, aa_), (Lock, aa_),\n         IsInterrupted ta_ True, ClearInterrupt ta_,\n         ObsInterrupted ta_\\<rbrace>;\n         xt =\n         RetExc\n          (heap_base.addr_of_sys_xcpt empty_heapa_ allocatea_\n            InterruptedException);\n         xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = wait; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>Suspend aa_, (Unlock, aa_),\n         (Lock, aa_), (ReleaseAcquire, aa_), IsInterrupted ta_ False,\n         SyncUnlock aa_\\<rbrace>;\n         xt = RetStaySame; xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = wait; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>(UnlockFail, aa_)\\<rbrace>;\n         xt =\n         RetExc\n          (heap_base.addr_of_sys_xcpt empty_heapa_ allocatea_\n            IllegalMonitorState);\n         xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = wait; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>Notified\\<rbrace>;\n         xt = RetVal Unit; xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = wait; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>WokenUp, ClearInterrupt ta_,\n         ObsInterrupted ta_\\<rbrace>;\n         xt =\n         RetExc\n          (heap_base.addr_of_sys_xcpt empty_heapa_ allocatea_\n            InterruptedException);\n         xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = wait; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>(Unlock, aa_), (Lock, aa_),\n         (ReleaseAcquire, aa_), IsInterrupted ta_ False,\n         SyncUnlock aa_\\<rbrace>;\n         xt = RetVal Unit; xu = ha_; spurious_wakeupsa_ = True\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = notify; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>Notify aa_, (Unlock, aa_),\n         (Lock, aa_)\\<rbrace>;\n         xt = RetVal Unit; xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = notify; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>(UnlockFail, aa_)\\<rbrace>;\n         xt =\n         RetExc\n          (heap_base.addr_of_sys_xcpt empty_heapa_ allocatea_\n            IllegalMonitorState);\n         xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = notifyAll; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>NotifyAll aa_, (Unlock, aa_),\n         (Lock, aa_)\\<rbrace>;\n         xt = RetVal Unit; xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = notifyAll; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>(UnlockFail, aa_)\\<rbrace>;\n         xt =\n         RetExc\n          (heap_base.addr_of_sys_xcpt empty_heapa_ allocatea_\n            IllegalMonitorState);\n         xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_ obs_\n        a'_ h'_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = clone; xm = [];\n         (xn, xo, xp, xq, xr, xs) = (K$ [], [], [], [], [], obs_);\n         xt = RetVal (Addr a'_); xu = h'_;\n         heap_base.heap_clone allocatea_ typeof_addra_ heap_read heap_write\n          Pa_ ha_ aa_ h'_ \\<lfloor>(obs_, a'_)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_ h'_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = clone; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>\\<rbrace>;\n         xt =\n         RetExc\n          (heap_base.addr_of_sys_xcpt empty_heapa_ allocatea_ OutOfMemory);\n         xu = h'_;\n         heap_base.heap_clone allocatea_ typeof_addra_ heap_read heap_write\n          Pa_ ha_ aa_ h'_ None\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = hashcode; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>\\<rbrace>;\n         xt = RetVal (Intg (word_of_int (hash_addr aa_))); xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_ vs_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = print; xm = vs_;\n         (xn, xo, xp, xq, xr, xs) =\n         \\<lbrace>ExternalCall aa_ print vs_ Unit\\<rbrace>;\n         xt = RetVal Unit; xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = currentThread; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>\\<rbrace>;\n         xt = RetVal (Addr (thread_id2addra_ ta_)); xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = interrupted; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>IsInterrupted ta_ True,\n         ClearInterrupt ta_, ObsInterrupted ta_\\<rbrace>;\n         xt = RetVal (Bool True); xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = interrupted; xm = [];\n         (xn, xo, xp, xq, xr, xs) =\n         \\<lbrace>IsInterrupted ta_ False\\<rbrace>;\n         xt = RetVal (Bool False); xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>addr2thread_ida_ thread_id2addra_ spurious_wakeupsa_ empty_heapa_\n        allocatea_ typeof_addra_ heap_read heap_write Pa_ ta_ ha_ aa_.\n        \\<lbrakk>x = addr2thread_ida_; xa = thread_id2addra_;\n         xb = spurious_wakeupsa_; xc = empty_heapa_; xd = allocatea_;\n         xe = typeof_addra_; xf = heap_read; xg = heap_write; xh = Pa_;\n         xi = ta_; xj = ha_; xk = aa_; xl = yield; xm = [];\n         (xn, xo, xp, xq, xr, xs) = \\<lbrace>Yield\\<rbrace>;\n         xt = RetVal Unit; xu = ha_\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "from red_external.prems"], ["proof (chain)\npicking this:\n  heap_base.red_external x xa xb xc xd xe xf xg xh xi xj xk xl xm\n   (xn, xo, xp, xq, xr, xs) xt xu", "show ?thesis"], ["proof (prove)\nusing this:\n  heap_base.red_external x xa xb xc xd xe xf xg xh xi xj xk xl xm\n   (xn, xo, xp, xq, xr, xs) xt xu\n\ngoal (1 subgoal):\n 1. thesis", "apply(rule heap_base.red_external.cases)"], ["proof (prove)\ngoal (26 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>xl = start; xm = [];\n        (xn, xo, xp, xq, xr, xs) =\n        \\<lbrace>NewThread (x xk) (C, run, xk) xj,\n        ThreadStart (x xk)\\<rbrace>;\n        xt = RetVal Unit; xu = xj;\n        xe xj xk = \\<lfloor>Class_type C\\<rfloor>;\n        xh \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>C.\n       \\<lbrakk>xl = start; xm = [];\n        (xn, xo, xp, xq, xr, xs) =\n        \\<lbrace>ThreadExists (x xk) True\\<rbrace>;\n        xt = RetExc (heap_base.addr_of_sys_xcpt xc xd IllegalThreadState);\n        xu = xj; xe xj xk = \\<lfloor>Class_type C\\<rfloor>;\n        xh \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>C.\n       \\<lbrakk>xl = join; xm = [];\n        (xn, xo, xp, xq, xr, xs) = \\<lbrace>Join (x xk),\n        IsInterrupted xi False, ThreadJoin (x xk)\\<rbrace>;\n        xt = RetVal Unit; xu = xj;\n        xe xj xk = \\<lfloor>Class_type C\\<rfloor>;\n        xh \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>C.\n       \\<lbrakk>xl = join; xm = [];\n        (xn, xo, xp, xq, xr, xs) = \\<lbrace>IsInterrupted xi True,\n        ClearInterrupt xi, ObsInterrupted xi\\<rbrace>;\n        xt = RetExc (heap_base.addr_of_sys_xcpt xc xd InterruptedException);\n        xu = xj; xe xj xk = \\<lfloor>Class_type C\\<rfloor>;\n        xh \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>C.\n       \\<lbrakk>xl = interrupt; xm = [];\n        (xn, xo, xp, xq, xr, xs) = \\<lbrace>ThreadExists (x xk) True,\n        WakeUp (x xk), Interrupt (x xk), ObsInterrupt (x xk)\\<rbrace>;\n        xt = RetVal Unit; xu = xj;\n        xe xj xk = \\<lfloor>Class_type C\\<rfloor>;\n        xh \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>C.\n       \\<lbrakk>xl = interrupt; xm = [];\n        (xn, xo, xp, xq, xr, xs) =\n        \\<lbrace>ThreadExists (x xk) False\\<rbrace>;\n        xt = RetVal Unit; xu = xj;\n        xe xj xk = \\<lfloor>Class_type C\\<rfloor>;\n        xh \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>C.\n       \\<lbrakk>xl = isInterrupted; xm = [];\n        (xn, xo, xp, xq, xr, xs) = \\<lbrace>IsInterrupted (x xk) True,\n        ObsInterrupted (x xk)\\<rbrace>;\n        xt = RetVal (Bool True); xu = xj;\n        xe xj xk = \\<lfloor>Class_type C\\<rfloor>;\n        xh \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>C.\n       \\<lbrakk>xl = isInterrupted; xm = [];\n        (xn, xo, xp, xq, xr, xs) =\n        \\<lbrace>IsInterrupted (x xk) False\\<rbrace>;\n        xt = RetVal (Bool False); xu = xj;\n        xe xj xk = \\<lfloor>Class_type C\\<rfloor>;\n        xh \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>xl = wait; xm = [];\n     (xn, xo, xp, xq, xr, xs) = \\<lbrace>(Unlock, xk), (Lock, xk),\n     IsInterrupted xi True, ClearInterrupt xi, ObsInterrupted xi\\<rbrace>;\n     xt = RetExc (heap_base.addr_of_sys_xcpt xc xd InterruptedException);\n     xu = xj\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<lbrakk>xl = wait; xm = [];\n      (xn, xo, xp, xq, xr, xs) = \\<lbrace>Suspend xk, (Unlock, xk),\n      (Lock, xk), (ReleaseAcquire, xk), IsInterrupted xi False,\n      SyncUnlock xk\\<rbrace>;\n      xt = RetStaySame; xu = xj\\<rbrakk>\n     \\<Longrightarrow> thesis\nA total of 26 subgoals...", "apply(erule (4) red_external.that[OF refl refl refl refl refl refl refl refl refl refl refl refl]|assumption|erule eqTrueI)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}