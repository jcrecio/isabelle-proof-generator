{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/BV/Effect.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma eff_None:\n  \"eff i P pc xt None = []\"", "lemma eff_Some:\n  \"eff i P pc xt (Some \\<tau>) = norm_eff i P pc \\<tau> @ xcpt_eff i P pc \\<tau> xt\"", "lemma app_Some:\n  \"app i P mxs T\\<^sub>r pc mpc xt (Some \\<tau>) = \n  (app\\<^sub>i (i,P,pc,mxs,T\\<^sub>r,\\<tau>) \\<and> xcpt_app i P pc mxs xt \\<tau> \\<and> \n  (\\<forall>(pc',s') \\<in> set (eff i P pc xt (Some \\<tau>)). pc' < mpc))\"", "lemma length_cases2:\n  assumes \"\\<And>LT. P ([],LT)\"\n  assumes \"\\<And>l ST LT. P (l#ST,LT)\"\n  shows \"P s\"", "lemma length_cases3:\n  assumes \"\\<And>LT. P ([],LT)\"\n  assumes \"\\<And>l LT. P ([l],LT)\"\n  assumes \"\\<And>l l' ST LT. P (l#l'#ST,LT)\"\n  shows \"P s\"", "lemma length_cases4:\n  assumes \"\\<And>LT. P ([],LT)\"\n  assumes \"\\<And>l LT. P ([l],LT)\"\n  assumes \"\\<And>l l' LT. P ([l,l'],LT)\"\n  assumes \"\\<And>l l' l'' ST LT. P (l#l'#l''#ST,LT)\"\n  shows \"P s\"", "lemma length_cases5:\n  assumes \"\\<And>LT. P ([],LT)\"\n  assumes \"\\<And>l LT. P ([l],LT)\"\n  assumes \"\\<And>l l' LT. P ([l,l'],LT)\"\n  assumes \"\\<And>l l' l'' LT. P ([l,l',l''],LT)\"\n  assumes \"\\<And>l l' l'' l''' ST LT. P (l#l'#l''#l'''#ST,LT)\"\n  shows \"P s\"", "lemma appNone[simp]: \"app i P mxs T\\<^sub>r pc mpc et None = True\"", "lemma appLoad[simp]:\n\"app\\<^sub>i (Load idx, P, T\\<^sub>r, mxs, pc, s) = (\\<exists>ST LT. s = (ST,LT) \\<and> idx < length LT \\<and> LT!idx \\<noteq> Err \\<and> length ST < mxs)\"", "lemma appStore[simp]:\n\"app\\<^sub>i (Store idx,P,pc,mxs,T\\<^sub>r,s) = (\\<exists>ts ST LT. s = (ts#ST,LT) \\<and> idx < length LT)\"", "lemma appPush[simp]:\n\"app\\<^sub>i (Push v,P,pc,mxs,T\\<^sub>r,s) =\n (\\<exists>ST LT. s = (ST,LT) \\<and> length ST < mxs \\<and> typeof v \\<noteq> None)\"", "lemma appGetField[simp]:\n\"app\\<^sub>i (Getfield F C,P,pc,mxs,T\\<^sub>r,s) = \n (\\<exists> oT vT ST LT fm. s = (oT#ST, LT) \\<and> \n  P \\<turnstile> C sees F:vT (fm) in C \\<and> P \\<turnstile> oT \\<le> (Class C))\"", "lemma appPutField[simp]:\n\"app\\<^sub>i (Putfield F C,P,pc,mxs,T\\<^sub>r,s) = \n (\\<exists> vT vT' oT ST LT fm. s = (vT#oT#ST, LT) \\<and>\n  P \\<turnstile> C sees F:vT' (fm) in C \\<and> P \\<turnstile> oT \\<le> (Class C) \\<and> P \\<turnstile> vT \\<le> vT')\"", "lemma appCAS[simp]:\n\"app\\<^sub>i (CAS F C, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists> T1 T2 T3 T' ST LT fm. s = (T3 # T2 # T1 # ST, LT) \\<and>\n  P \\<turnstile> C sees F:T' (fm) in C \\<and> volatile fm \\<and> P \\<turnstile> T1 \\<le> Class C \\<and> P \\<turnstile> T2 \\<le> T' \\<and> P \\<turnstile> T3 \\<le> T')\"", "lemma appNew[simp]:\n  \"app\\<^sub>i (New C,P,pc,mxs,T\\<^sub>r,s) = \n  (\\<exists>ST LT. s=(ST,LT) \\<and> is_class P C \\<and> length ST < mxs)\"", "lemma appNewArray[simp]:\n  \"app\\<^sub>i (NewArray Ty,P,pc,mxs,T\\<^sub>r,s) = \n  (\\<exists>ST LT. s=(Integer#ST,LT) \\<and> is_type P (Ty\\<lfloor>\\<rceil>))\"", "lemma appALoad[simp]:\n  \"app\\<^sub>i (ALoad,P,pc,mxs,T\\<^sub>r,s) = \n  (\\<exists>T ST LT. s=(Integer#T#ST,LT) \\<and> (T \\<noteq> NT \\<longrightarrow> (\\<exists>T'.  T = T'\\<lfloor>\\<rceil>)))\"", "lemma appAStore[simp]:\n  \"app\\<^sub>i (AStore,P,pc,mxs,T\\<^sub>r,s) = \n  (\\<exists>T U ST LT. s=(T#Integer#U#ST,LT) \\<and> (U \\<noteq> NT \\<longrightarrow> (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))\"", "lemma appALength[simp]:\n  \"app\\<^sub>i (ALength,P,pc,mxs,T\\<^sub>r,s) = \n  (\\<exists>T ST LT. s=(T#ST,LT) \\<and> (T \\<noteq> NT \\<longrightarrow> (\\<exists>T'.  T = T'\\<lfloor>\\<rceil>)))\"", "lemma appCheckcast[simp]: \n  \"app\\<^sub>i (Checkcast Ty,P,pc,mxs,T\\<^sub>r,s) =  \n  (\\<exists>T ST LT. s = (T#ST,LT) \\<and> is_type P Ty)\"", "lemma appInstanceof[simp]: \n  \"app\\<^sub>i (Instanceof Ty,P,pc,mxs,T\\<^sub>r,s) =  \n  (\\<exists>T ST LT. s = (T#ST,LT) \\<and> is_type P Ty \\<and> is_refT T)\"", "lemma app\\<^sub>iPop[simp]: \n\"app\\<^sub>i (Pop,P,pc,mxs,T\\<^sub>r,s) = (\\<exists>ts ST LT. s = (ts#ST,LT))\"", "lemma appDup[simp]:\n\"app\\<^sub>i (Dup,P,pc,mxs,T\\<^sub>r,s) =\n (\\<exists>T ST LT. s = (T#ST,LT) \\<and> Suc (length ST) < mxs)\"", "lemma app\\<^sub>iSwap[simp]: \n\"app\\<^sub>i (Swap,P,pc,mxs,T\\<^sub>r,s) = (\\<exists>T1 T2 ST LT. s = (T1#T2#ST,LT))\"", "lemma appBinOp[simp]:\n\"app\\<^sub>i (BinOpInstr bop,P,pc,mxs,T\\<^sub>r,s) = (\\<exists>T1 T2 ST LT T. s = (T2 # T1 # ST, LT) \\<and> P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)\"", "lemma appIfFalse [simp]:\n\"app\\<^sub>i (IfFalse b,P,pc,mxs,T\\<^sub>r,s) = \n  (\\<exists>ST LT. s = (Boolean#ST,LT) \\<and> 0 \\<le> int pc + b)\"", "lemma appReturn[simp]:\n\"app\\<^sub>i (Return,P,pc,mxs,T\\<^sub>r,s) = (\\<exists>T ST LT. s = (T#ST,LT) \\<and> P \\<turnstile> T \\<le> T\\<^sub>r)\"", "lemma appThrow[simp]:\n  \"app\\<^sub>i (ThrowExc,P,pc,mxs,T\\<^sub>r,s) = (\\<exists>T ST LT. s=(T#ST,LT) \\<and> (T = NT \\<or> (\\<exists>C. T = Class C \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* Throwable)))\"", "lemma appMEnter[simp]:\n  \"app\\<^sub>i (MEnter,P,pc,mxs,T\\<^sub>r,s) = (\\<exists>T ST LT. s=(T#ST,LT) \\<and> is_refT T)\"", "lemma appMExit[simp]:\n  \"app\\<^sub>i (MExit,P,pc,mxs,T\\<^sub>r,s) = (\\<exists>T ST LT. s=(T#ST,LT) \\<and> is_refT T)\"", "lemma effNone: \n  \"(pc', s') \\<in> set (eff i P pc et None) \\<Longrightarrow> s' = None\"", "lemma relevant_entries_append [simp]:\n  \"relevant_entries P i pc (xt @ xt') = relevant_entries P i pc xt @ relevant_entries P i pc xt'\"", "lemma xcpt_app_append [iff]:\n  \"xcpt_app i P pc mxs (xt@xt') \\<tau> = (xcpt_app i P pc mxs xt \\<tau> \\<and> xcpt_app i P pc mxs xt' \\<tau>)\"", "lemma xcpt_eff_append [simp]:\n  \"xcpt_eff i P pc \\<tau> (xt@xt') = xcpt_eff i P pc \\<tau> xt @ xcpt_eff i P pc \\<tau> xt'\"", "lemma app_append [simp]:\n  \"app i P pc T mxs mpc (xt@xt') \\<tau> = (app i P pc T mxs mpc xt \\<tau> \\<and> app i P pc T mxs mpc xt' \\<tau>)\"", "lemma eff\\<^sub>i_BinOpInstr_code:\n  \"eff\\<^sub>i (BinOpInstr bop, P, (T2#T1#ST,LT)) = (Predicate.the (WTrt_binop_i_i_i_i_o P T1 bop T2) # ST, LT)\"", "lemmas eff\\<^sub>i_code[code] =\n  eff\\<^sub>i_Load eff\\<^sub>i_Store eff\\<^sub>i_Push eff\\<^sub>i_Getfield eff\\<^sub>i_Putfield eff\\<^sub>i_New eff\\<^sub>i_NewArray eff\\<^sub>i_ALoad\n  eff\\<^sub>i_AStore eff\\<^sub>i_ALength eff\\<^sub>i_Checkcast eff\\<^sub>i_Instanceof eff\\<^sub>i_Pop eff\\<^sub>i_Dup eff\\<^sub>i_Swap eff\\<^sub>i_BinOpInstr_code\n  eff\\<^sub>i_IfFalse eff\\<^sub>i_Invoke eff\\<^sub>i_Goto eff\\<^sub>i_MEnter eff\\<^sub>i_MExit", "lemma app\\<^sub>i_Getfield_code:\n  \"app\\<^sub>i (Getfield F C, P, pc, mxs, T\\<^sub>r, (T#ST, LT)) \\<longleftrightarrow>\n  Predicate.holds (Predicate.bind (sees_field_i_i_i_o_o_i P C F C) (\\<lambda>T. Predicate.single ())) \\<and> P \\<turnstile> T \\<le> Class C\"", "lemma app\\<^sub>i_Putfield_code:\n  \"app\\<^sub>i (Putfield F C, P, pc, mxs, T\\<^sub>r, (T\\<^sub>1#T\\<^sub>2#ST, LT)) \\<longleftrightarrow>\n   P \\<turnstile> T\\<^sub>2 \\<le> (Class C) \\<and>\n   Predicate.holds (Predicate.bind (sees_field_i_i_i_o_o_i P C F C) (\\<lambda>(T, fm). if P \\<turnstile> T\\<^sub>1 \\<le> T then Predicate.single () else bot))\"", "lemma app\\<^sub>i_CAS_code:\n  \"app\\<^sub>i (CAS F C, P, pc, mxs, T\\<^sub>r, (T\\<^sub>3#T\\<^sub>2#T\\<^sub>1#ST, LT)) \\<longleftrightarrow>\n   P \\<turnstile> T\\<^sub>1 \\<le> Class C \\<and>\n  Predicate.holds (Predicate.bind (sees_field_i_i_i_o_o_i P C F C) (\\<lambda>(T, fm). if P \\<turnstile> T\\<^sub>2 \\<le> T \\<and> P \\<turnstile> T\\<^sub>3 \\<le> T \\<and> volatile fm then Predicate.single () else bot))\"", "lemma app\\<^sub>i_ALoad_code:\n  \"app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, (T1#T2#ST,LT)) = \n   (T1 = Integer \\<and> (case T2 of Ty\\<lfloor>\\<rceil> \\<Rightarrow> True | NT \\<Rightarrow> True | _ \\<Rightarrow> False))\"", "lemma app\\<^sub>i_AStore_code:\n  \"app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, (T1#T2#T3#ST,LT)) = \n  (T2 = Integer \\<and> (case T3 of Ty\\<lfloor>\\<rceil> \\<Rightarrow> True | NT \\<Rightarrow> True | _ \\<Rightarrow> False))\"", "lemma app\\<^sub>i_ALength_code:\n  \"app\\<^sub>i (ALength, P, pc, mxs, T\\<^sub>r, (T1#ST,LT)) = \n   (case T1 of Ty\\<lfloor>\\<rceil> \\<Rightarrow> True | NT \\<Rightarrow> True | _ \\<Rightarrow> False)\"", "lemma app\\<^sub>i_BinOpInstr_code:\n  \"app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, (T2#T1#ST,LT)) = \n   Predicate.holds (Predicate.bind (WTrt_binop_i_i_i_i_o P T1 bop T2) (\\<lambda>T. Predicate.single ()))\"", "lemma app\\<^sub>i_Invoke_code:\n  \"app\\<^sub>i (Invoke M n, P, pc, mxs, T\\<^sub>r, (ST,LT)) =\n  (n < length ST \\<and> \n  (ST!n \\<noteq> NT \\<longrightarrow>\n     (case class_type_of' (ST ! n) of Some C \\<Rightarrow> \n         Predicate.holds (Predicate.bind (Method_i_i_i_o_o_o_o P C M) \n                                          (\\<lambda>(Ts, _). if P \\<turnstile> rev (take n ST) [\\<le>] Ts then Predicate.single () else bot))\n      | _ \\<Rightarrow> False)))\"", "lemma app\\<^sub>i_Throw_code:\n  \"app\\<^sub>i (ThrowExc, P, pc, mxs, T\\<^sub>r, (T#ST,LT)) = \n  (case T of NT \\<Rightarrow> True | Class C \\<Rightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* Throwable | _ \\<Rightarrow> False)\"", "lemmas app\\<^sub>i_code [code] =\n  app\\<^sub>i_Load app\\<^sub>i_Store app\\<^sub>i_Push\n  app\\<^sub>i_Getfield_code app\\<^sub>i_Putfield_code app\\<^sub>i_CAS_code\n  app\\<^sub>i_New app\\<^sub>i_NewArray\n  app\\<^sub>i_ALoad_code app\\<^sub>i_AStore_code app\\<^sub>i_ALength_code\n  app\\<^sub>i_Checkcast app\\<^sub>i_Instanceof\n  app\\<^sub>i_Pop app\\<^sub>i_Dup app\\<^sub>i_Swap app\\<^sub>i_BinOpInstr_code app\\<^sub>i_IfFalse app\\<^sub>i_Goto\n  app\\<^sub>i_Return app\\<^sub>i_Throw_code app\\<^sub>i_Invoke_code app\\<^sub>i_MEnter app\\<^sub>i_MExit\n  app\\<^sub>i_default"], "translations": [["", "lemma eff_None:\n  \"eff i P pc xt None = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eff i P pc xt None = []", "by (simp add: eff_def)"], ["", "lemma eff_Some:\n  \"eff i P pc xt (Some \\<tau>) = norm_eff i P pc \\<tau> @ xcpt_eff i P pc \\<tau> xt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eff i P pc xt \\<lfloor>\\<tau>\\<rfloor> =\n    norm_eff i P pc \\<tau> @ xcpt_eff i P pc \\<tau> xt", "by (simp add: eff_def)"], ["", "(* FIXME: getfield, \\<exists>T D. P \\<turnstile> C sees F:T in D \\<and> .. *)"], ["", "text \"Conditions under which eff is applicable:\""], ["", "fun app\\<^sub>i :: \"'addr instr \\<times> 'm prog \\<times> pc \\<times> nat \\<times> ty \\<times> ty\\<^sub>i \\<Rightarrow> bool\"\nwhere\n  app\\<^sub>i_Load:\n  \"app\\<^sub>i (Load n, P, pc, mxs, T\\<^sub>r, (ST,LT)) = \n    (n < length LT \\<and> LT ! n \\<noteq> Err \\<and> length ST < mxs)\"\n| app\\<^sub>i_Store:\n  \"app\\<^sub>i (Store n, P, pc, mxs, T\\<^sub>r, (T#ST, LT)) = \n    (n < length LT)\"\n| app\\<^sub>i_Push:\n  \"app\\<^sub>i (Push v, P, pc, mxs, T\\<^sub>r, (ST,LT)) = \n    (length ST < mxs \\<and> typeof v \\<noteq> None)\"\n| app\\<^sub>i_Getfield:\n  \"app\\<^sub>i (Getfield F C, P, pc, mxs, T\\<^sub>r, (T#ST, LT)) = \n    (\\<exists>T\\<^sub>f fm. P \\<turnstile> C sees F:T\\<^sub>f (fm) in C \\<and> P \\<turnstile> T \\<le> Class C)\"\n| app\\<^sub>i_Putfield:\n  \"app\\<^sub>i (Putfield F C, P, pc, mxs, T\\<^sub>r, (T\\<^sub>1#T\\<^sub>2#ST, LT)) = \n    (\\<exists>T\\<^sub>f fm. P \\<turnstile> C sees F:T\\<^sub>f (fm) in C \\<and> P \\<turnstile> T\\<^sub>2 \\<le> (Class C) \\<and> P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>f)\" \n| app\\<^sub>i_CAS:\n  \"app\\<^sub>i (CAS F C, P, pc, mxs, T\\<^sub>r, (T\\<^sub>3#T\\<^sub>2#T\\<^sub>1#ST, LT)) = \n    (\\<exists>T\\<^sub>f fm. P \\<turnstile> C sees F:T\\<^sub>f (fm) in C \\<and> volatile fm \\<and> P \\<turnstile> T\\<^sub>1 \\<le> Class C \\<and> P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>f \\<and> P \\<turnstile> T\\<^sub>3 \\<le> T\\<^sub>f)\" \n| app\\<^sub>i_New:\n  \"app\\<^sub>i (New C, P, pc, mxs, T\\<^sub>r, (ST,LT)) = \n    (is_class P C \\<and> length ST < mxs)\"\n| app\\<^sub>i_NewArray:\n  \"app\\<^sub>i (NewArray Ty, P, pc, mxs, T\\<^sub>r, (Integer#ST,LT)) = \n    is_type P (Ty\\<lfloor>\\<rceil>)\"\n|  app\\<^sub>i_ALoad:\n  \"app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, (T1#T2#ST,LT)) = \n    (T1 = Integer \\<and> (T2 \\<noteq> NT \\<longrightarrow> (\\<exists>Ty. T2 = Ty\\<lfloor>\\<rceil>)))\"\n| app\\<^sub>i_AStore:\n  \"app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, (T1#T2#T3#ST,LT)) = \n    (T2 = Integer \\<and> (T3 \\<noteq> NT \\<longrightarrow> (\\<exists>Ty. T3 = Ty\\<lfloor>\\<rceil>)))\"\n| app\\<^sub>i_ALength:\n  \"app\\<^sub>i (ALength, P, pc, mxs, T\\<^sub>r, (T1#ST,LT)) = \n    (T1 = NT \\<or> (\\<exists>Ty. T1 = Ty\\<lfloor>\\<rceil>))\"\n| app\\<^sub>i_Checkcast:\n  \"app\\<^sub>i (Checkcast Ty, P, pc, mxs, T\\<^sub>r, (T#ST,LT)) = \n    (is_type P Ty)\"\n| app\\<^sub>i_Instanceof:\n  \"app\\<^sub>i (Instanceof Ty, P, pc, mxs, T\\<^sub>r, (T#ST,LT)) = \n    (is_type P Ty \\<and> is_refT T)\"\n| app\\<^sub>i_Pop:\n  \"app\\<^sub>i (Pop, P, pc, mxs, T\\<^sub>r, (T#ST,LT)) = \n    True\"\n| app\\<^sub>i_Dup:\n  \"app\\<^sub>i (Dup, P, pc, mxs, T\\<^sub>r, (T#ST,LT)) = \n    (Suc (length ST) < mxs)\"\n| app\\<^sub>i_Swap:\n  \"app\\<^sub>i (Swap, P, pc, mxs, T\\<^sub>r, (T1#T2#ST,LT)) = True\"\n| app\\<^sub>i_BinOpInstr:\n  \"app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, (T2#T1#ST,LT)) = (\\<exists>T. P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)\"\n| app\\<^sub>i_IfFalse:\n  \"app\\<^sub>i (IfFalse b, P, pc, mxs, T\\<^sub>r, (Boolean#ST,LT)) = \n    (0 \\<le> int pc + b)\"\n| app\\<^sub>i_Goto:\n  \"app\\<^sub>i (Goto b, P, pc, mxs, T\\<^sub>r, s) =  (0 \\<le> int pc + b)\"\n| app\\<^sub>i_Return:\n  \"app\\<^sub>i (Return, P, pc, mxs, T\\<^sub>r, (T#ST,LT)) = (P \\<turnstile> T \\<le> T\\<^sub>r)\"\n| app\\<^sub>i_Throw:\n  \"app\\<^sub>i (ThrowExc, P, pc, mxs, T\\<^sub>r, (T#ST,LT)) = \n    (T = NT \\<or> (\\<exists>C. T = Class C \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* Throwable))\"\n| app\\<^sub>i_Invoke:\n  \"app\\<^sub>i (Invoke M n, P, pc, mxs, T\\<^sub>r, (ST,LT)) =\n    (n < length ST \\<and> \n    (ST!n \\<noteq> NT \\<longrightarrow>\n      (\\<exists>C D Ts T m. class_type_of' (ST ! n) = \\<lfloor>C\\<rfloor> \\<and> P \\<turnstile> C sees M:Ts \\<rightarrow> T = m in D \\<and> P \\<turnstile> rev (take n ST) [\\<le>] Ts)))\"\n| app\\<^sub>i_MEnter:\n  \"app\\<^sub>i (MEnter,P, pc,mxs,T\\<^sub>r,(T#ST,LT)) = (is_refT T)\"\n| app\\<^sub>i_MExit:\n  \"app\\<^sub>i (MExit,P, pc,mxs,T\\<^sub>r,(T#ST,LT)) = (is_refT T)\"\n| app\\<^sub>i_default:\n  \"app\\<^sub>i (i,P, pc,mxs,T\\<^sub>r,s) = False\""], ["", "definition xcpt_app :: \"'addr instr \\<Rightarrow> 'm prog \\<Rightarrow> pc \\<Rightarrow> nat \\<Rightarrow> ex_table \\<Rightarrow> ty\\<^sub>i \\<Rightarrow> bool\"\nwhere\n  \"xcpt_app i P pc mxs xt \\<tau> \\<equiv> \\<forall>(f,t,C,h,d) \\<in> set (relevant_entries P i pc xt). (case C of None \\<Rightarrow> True | Some C' \\<Rightarrow> is_class P C') \\<and> d \\<le> size (fst \\<tau>) \\<and> d < mxs\""], ["", "definition app :: \"'addr instr \\<Rightarrow> 'm prog \\<Rightarrow> nat \\<Rightarrow> ty \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> ex_table \\<Rightarrow> ty\\<^sub>i' \\<Rightarrow> bool\"\nwhere\n  \"app i P mxs T\\<^sub>r pc mpc xt t \\<equiv> case t of None \\<Rightarrow> True | Some \\<tau> \\<Rightarrow> \n  app\\<^sub>i (i,P,pc,mxs,T\\<^sub>r,\\<tau>) \\<and> xcpt_app i P pc mxs xt \\<tau> \\<and> \n  (\\<forall>(pc',\\<tau>') \\<in> set (eff i P pc xt t). pc' < mpc)\""], ["", "lemma app_Some:\n  \"app i P mxs T\\<^sub>r pc mpc xt (Some \\<tau>) = \n  (app\\<^sub>i (i,P,pc,mxs,T\\<^sub>r,\\<tau>) \\<and> xcpt_app i P pc mxs xt \\<tau> \\<and> \n  (\\<forall>(pc',s') \\<in> set (eff i P pc xt (Some \\<tau>)). pc' < mpc))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app i P mxs T\\<^sub>r pc mpc xt \\<lfloor>\\<tau>\\<rfloor> =\n    (app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, \\<tau>) \\<and>\n     xcpt_app i P pc mxs xt \\<tau> \\<and>\n     (\\<forall>(pc', s')\\<in>set (eff i P pc xt \\<lfloor>\\<tau>\\<rfloor>).\n         pc' < mpc))", "by (simp add: app_def)"], ["", "locale eff = jvm_method +\n  fixes eff\\<^sub>i and app\\<^sub>i and eff and app \n  fixes norm_eff and xcpt_app and xcpt_eff\n\n  fixes mpc\n  defines \"mpc \\<equiv> size is\"\n\n  defines \"eff\\<^sub>i i \\<tau> \\<equiv> Effect.eff\\<^sub>i (i,P,\\<tau>)\"\n  notes eff\\<^sub>i_simps [simp] = Effect.eff\\<^sub>i.simps [where P = P, folded eff\\<^sub>i_def]\n\n  defines \"app\\<^sub>i i pc \\<tau> \\<equiv> Effect.app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, \\<tau>)\"\n  notes app\\<^sub>i_simps [simp] = Effect.app\\<^sub>i.simps [where P=P and mxs=mxs and T\\<^sub>r=T\\<^sub>r, folded app\\<^sub>i_def]\n\n  defines \"xcpt_eff i pc \\<tau> \\<equiv> Effect.xcpt_eff i P pc \\<tau> xt\"\n  notes xcpt_eff = Effect.xcpt_eff_def [of _ P _ _ xt, folded xcpt_eff_def]\n\n  defines \"norm_eff i pc \\<tau> \\<equiv> Effect.norm_eff i P pc \\<tau>\"\n  notes norm_eff = Effect.norm_eff_def [of _ P, folded norm_eff_def eff\\<^sub>i_def]\n\n  defines \"eff i pc \\<equiv> Effect.eff i P pc xt\"\n  notes eff = Effect.eff_def [of _ P  _ xt, folded eff_def norm_eff_def xcpt_eff_def]\n\n  defines \"xcpt_app i pc \\<tau> \\<equiv> Effect.xcpt_app i P pc mxs xt \\<tau>\"\n  notes xcpt_app = Effect.xcpt_app_def [of _ P _ mxs xt, folded xcpt_app_def]\n\n  defines \"app i pc \\<equiv> Effect.app i P mxs T\\<^sub>r pc mpc xt\"\n  notes app = Effect.app_def [of _ P mxs T\\<^sub>r _ mpc xt, folded app_def xcpt_app_def app\\<^sub>i_def eff_def]"], ["", "lemma length_cases2:\n  assumes \"\\<And>LT. P ([],LT)\"\n  assumes \"\\<And>l ST LT. P (l#ST,LT)\"\n  shows \"P s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P s", "by (cases s, cases \"fst s\") (auto intro!: assms)"], ["", "lemma length_cases3:\n  assumes \"\\<And>LT. P ([],LT)\"\n  assumes \"\\<And>l LT. P ([l],LT)\"\n  assumes \"\\<And>l l' ST LT. P (l#l'#ST,LT)\"\n  shows \"P s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P s", "apply(rule length_cases2; (rule assms)?)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ST LT. P (l # ST, LT)", "subgoal for l ST LT"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (l # ST, LT)", "by(cases ST; clarsimp simp: assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma length_cases4:\n  assumes \"\\<And>LT. P ([],LT)\"\n  assumes \"\\<And>l LT. P ([l],LT)\"\n  assumes \"\\<And>l l' LT. P ([l,l'],LT)\"\n  assumes \"\\<And>l l' l'' ST LT. P (l#l'#l''#ST,LT)\"\n  shows \"P s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P s", "apply(rule length_cases3; (rule assms)?)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l l' ST LT. P (l # l' # ST, LT)", "subgoal for l l' ST LT"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (l # l' # ST, LT)", "by(cases ST; clarsimp simp: assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma length_cases5:\n  assumes \"\\<And>LT. P ([],LT)\"\n  assumes \"\\<And>l LT. P ([l],LT)\"\n  assumes \"\\<And>l l' LT. P ([l,l'],LT)\"\n  assumes \"\\<And>l l' l'' LT. P ([l,l',l''],LT)\"\n  assumes \"\\<And>l l' l'' l''' ST LT. P (l#l'#l''#l'''#ST,LT)\"\n  shows \"P s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P s", "apply(rule length_cases4; (rule assms)?)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l l' l'' ST LT. P (l # l' # l'' # ST, LT)", "subgoal for l l' l'' ST LT"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (l # l' # l'' # ST, LT)", "by(cases ST; clarsimp simp: assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n\\medskip\nsimp rules for @{term app}\n\\<close>"], ["", "lemma appNone[simp]: \"app i P mxs T\\<^sub>r pc mpc et None = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app i P mxs T\\<^sub>r pc mpc et None = True", "by (simp add: app_def)"], ["", "lemma appLoad[simp]:\n\"app\\<^sub>i (Load idx, P, T\\<^sub>r, mxs, pc, s) = (\\<exists>ST LT. s = (ST,LT) \\<and> idx < length LT \\<and> LT!idx \\<noteq> Err \\<and> length ST < mxs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (Load idx, P, T\\<^sub>r, mxs, pc, s) =\n    (\\<exists>ST LT.\n        s = (ST, LT) \\<and>\n        idx < length LT \\<and> LT ! idx \\<noteq> Err \\<and> length ST < mxs)", "by (cases s, simp)"], ["", "lemma appStore[simp]:\n\"app\\<^sub>i (Store idx,P,pc,mxs,T\\<^sub>r,s) = (\\<exists>ts ST LT. s = (ts#ST,LT) \\<and> idx < length LT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (Store idx, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ts ST LT. s = (ts # ST, LT) \\<and> idx < length LT)", "by (rule length_cases2, auto)"], ["", "lemma appPush[simp]:\n\"app\\<^sub>i (Push v,P,pc,mxs,T\\<^sub>r,s) =\n (\\<exists>ST LT. s = (ST,LT) \\<and> length ST < mxs \\<and> typeof v \\<noteq> None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (Push v, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT.\n        s = (ST, LT) \\<and> length ST < mxs \\<and> typeof v \\<noteq> None)", "by (cases s, simp)"], ["", "lemma appGetField[simp]:\n\"app\\<^sub>i (Getfield F C,P,pc,mxs,T\\<^sub>r,s) = \n (\\<exists> oT vT ST LT fm. s = (oT#ST, LT) \\<and> \n  P \\<turnstile> C sees F:vT (fm) in C \\<and> P \\<turnstile> oT \\<le> (Class C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (Getfield F C, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>oT vT ST LT fm.\n        s = (oT # ST, LT) \\<and>\n        P \\<turnstile> C sees F:vT (fm) in C \\<and>\n        P \\<turnstile> oT \\<le> Class C)", "by (rule length_cases2 [of _ s]) auto"], ["", "lemma appPutField[simp]:\n\"app\\<^sub>i (Putfield F C,P,pc,mxs,T\\<^sub>r,s) = \n (\\<exists> vT vT' oT ST LT fm. s = (vT#oT#ST, LT) \\<and>\n  P \\<turnstile> C sees F:vT' (fm) in C \\<and> P \\<turnstile> oT \\<le> (Class C) \\<and> P \\<turnstile> vT \\<le> vT')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (Putfield F C, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>vT vT' oT ST LT fm.\n        s = (vT # oT # ST, LT) \\<and>\n        P \\<turnstile> C sees F:vT' (fm) in C \\<and>\n        P \\<turnstile> oT \\<le> Class C \\<and> P \\<turnstile> vT \\<le> vT')", "by (rule length_cases4 [of _ s], auto)"], ["", "lemma appCAS[simp]:\n\"app\\<^sub>i (CAS F C, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists> T1 T2 T3 T' ST LT fm. s = (T3 # T2 # T1 # ST, LT) \\<and>\n  P \\<turnstile> C sees F:T' (fm) in C \\<and> volatile fm \\<and> P \\<turnstile> T1 \\<le> Class C \\<and> P \\<turnstile> T2 \\<le> T' \\<and> P \\<turnstile> T3 \\<le> T')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (CAS F C, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T1 T2 T3 T' ST LT fm.\n        s = (T3 # T2 # T1 # ST, LT) \\<and>\n        P \\<turnstile> C sees F:T' (fm) in C \\<and>\n        volatile fm \\<and>\n        P \\<turnstile> T1 \\<le> Class C \\<and>\n        P \\<turnstile> T2 \\<le> T' \\<and> P \\<turnstile> T3 \\<le> T')", "by(rule length_cases4[of _ s]) auto"], ["", "lemma appNew[simp]:\n  \"app\\<^sub>i (New C,P,pc,mxs,T\\<^sub>r,s) = \n  (\\<exists>ST LT. s=(ST,LT) \\<and> is_class P C \\<and> length ST < mxs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (New C, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT.\n        s = (ST, LT) \\<and> is_class P C \\<and> length ST < mxs)", "by (cases s, simp)"], ["", "lemma appNewArray[simp]:\n  \"app\\<^sub>i (NewArray Ty,P,pc,mxs,T\\<^sub>r,s) = \n  (\\<exists>ST LT. s=(Integer#ST,LT) \\<and> is_type P (Ty\\<lfloor>\\<rceil>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (NewArray Ty, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT.\n        s = (Integer # ST, LT) \\<and> is_type P (Ty\\<lfloor>\\<rceil>))", "by (cases s, simp, cases \"fst s\", simp)(cases \"hd (fst s)\", auto)"], ["", "lemma appALoad[simp]:\n  \"app\\<^sub>i (ALoad,P,pc,mxs,T\\<^sub>r,s) = \n  (\\<exists>T ST LT. s=(Integer#T#ST,LT) \\<and> (T \\<noteq> NT \\<longrightarrow> (\\<exists>T'.  T = T'\\<lfloor>\\<rceil>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT.\n        s = (Integer # T # ST, LT) \\<and>\n        (T \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT.\n        s = (Integer # T # ST, LT) \\<and>\n        (T \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))", "obtain ST LT where [simp]: \"s = (ST, LT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ST LT. s = (ST, LT) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases s)"], ["proof (state)\nthis:\n  s = (ST, LT)\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT.\n        s = (Integer # T # ST, LT) \\<and>\n        (T \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))", "have \"ST = [] \\<or> (\\<exists>T. ST = [T]) \\<or> (\\<exists>T\\<^sub>1 T\\<^sub>2 ST'. ST = T\\<^sub>1#T\\<^sub>2#ST')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ST = [] \\<or>\n    (\\<exists>T. ST = [T]) \\<or>\n    (\\<exists>T\\<^sub>1 T\\<^sub>2 ST'. ST = T\\<^sub>1 # T\\<^sub>2 # ST')", "by (cases ST, auto, case_tac list, auto)"], ["proof (state)\nthis:\n  ST = [] \\<or>\n  (\\<exists>T. ST = [T]) \\<or>\n  (\\<exists>T\\<^sub>1 T\\<^sub>2 ST'. ST = T\\<^sub>1 # T\\<^sub>2 # ST')\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT.\n        s = (Integer # T # ST, LT) \\<and>\n        (T \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))", "moreover"], ["proof (state)\nthis:\n  ST = [] \\<or>\n  (\\<exists>T. ST = [T]) \\<or>\n  (\\<exists>T\\<^sub>1 T\\<^sub>2 ST'. ST = T\\<^sub>1 # T\\<^sub>2 # ST')\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT.\n        s = (Integer # T # ST, LT) \\<and>\n        (T \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))", "{"], ["proof (state)\nthis:\n  ST = [] \\<or>\n  (\\<exists>T. ST = [T]) \\<or>\n  (\\<exists>T\\<^sub>1 T\\<^sub>2 ST'. ST = T\\<^sub>1 # T\\<^sub>2 # ST')\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT.\n        s = (Integer # T # ST, LT) \\<and>\n        (T \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))", "assume \"ST = []\""], ["proof (state)\nthis:\n  ST = []\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT.\n        s = (Integer # T # ST, LT) \\<and>\n        (T \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))", "hence ?thesis"], ["proof (prove)\nusing this:\n  ST = []\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT.\n        s = (Integer # T # ST, LT) \\<and>\n        (T \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))", "by simp"], ["proof (state)\nthis:\n  app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T ST LT.\n      s = (Integer # T # ST, LT) \\<and>\n      (T \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT.\n        s = (Integer # T # ST, LT) \\<and>\n        (T \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))", "}"], ["proof (state)\nthis:\n  ST = [] \\<Longrightarrow>\n  app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T ST LT.\n      s = (Integer # T # ST, LT) \\<and>\n      (T \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT.\n        s = (Integer # T # ST, LT) \\<and>\n        (T \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))", "moreover"], ["proof (state)\nthis:\n  ST = [] \\<Longrightarrow>\n  app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T ST LT.\n      s = (Integer # T # ST, LT) \\<and>\n      (T \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT.\n        s = (Integer # T # ST, LT) \\<and>\n        (T \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))", "{"], ["proof (state)\nthis:\n  ST = [] \\<Longrightarrow>\n  app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T ST LT.\n      s = (Integer # T # ST, LT) \\<and>\n      (T \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT.\n        s = (Integer # T # ST, LT) \\<and>\n        (T \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))", "fix T"], ["proof (state)\ngoal (1 subgoal):\n 1. app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT.\n        s = (Integer # T # ST, LT) \\<and>\n        (T \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))", "assume \"ST = [T]\""], ["proof (state)\nthis:\n  ST = [T]\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT.\n        s = (Integer # T # ST, LT) \\<and>\n        (T \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))", "hence ?thesis"], ["proof (prove)\nusing this:\n  ST = [T]\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT.\n        s = (Integer # T # ST, LT) \\<and>\n        (T \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))", "by (cases T, auto)"], ["proof (state)\nthis:\n  app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T ST LT.\n      s = (Integer # T # ST, LT) \\<and>\n      (T \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT.\n        s = (Integer # T # ST, LT) \\<and>\n        (T \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))", "}"], ["proof (state)\nthis:\n  ST = [?T2] \\<Longrightarrow>\n  app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T ST LT.\n      s = (Integer # T # ST, LT) \\<and>\n      (T \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT.\n        s = (Integer # T # ST, LT) \\<and>\n        (T \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))", "moreover"], ["proof (state)\nthis:\n  ST = [?T2] \\<Longrightarrow>\n  app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T ST LT.\n      s = (Integer # T # ST, LT) \\<and>\n      (T \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT.\n        s = (Integer # T # ST, LT) \\<and>\n        (T \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))", "{"], ["proof (state)\nthis:\n  ST = [?T2] \\<Longrightarrow>\n  app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T ST LT.\n      s = (Integer # T # ST, LT) \\<and>\n      (T \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT.\n        s = (Integer # T # ST, LT) \\<and>\n        (T \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))", "fix T\\<^sub>1 T\\<^sub>2 ST'"], ["proof (state)\ngoal (1 subgoal):\n 1. app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT.\n        s = (Integer # T # ST, LT) \\<and>\n        (T \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))", "assume \"ST = T\\<^sub>1#T\\<^sub>2#ST'\""], ["proof (state)\nthis:\n  ST = T\\<^sub>1 # T\\<^sub>2 # ST'\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT.\n        s = (Integer # T # ST, LT) \\<and>\n        (T \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))", "hence ?thesis"], ["proof (prove)\nusing this:\n  ST = T\\<^sub>1 # T\\<^sub>2 # ST'\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT.\n        s = (Integer # T # ST, LT) \\<and>\n        (T \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))", "by (cases T\\<^sub>1, auto)"], ["proof (state)\nthis:\n  app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T ST LT.\n      s = (Integer # T # ST, LT) \\<and>\n      (T \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT.\n        s = (Integer # T # ST, LT) \\<and>\n        (T \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))", "}"], ["proof (state)\nthis:\n  ST = ?T\\<^sub>12 # ?T\\<^sub>22 # ?ST'2 \\<Longrightarrow>\n  app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T ST LT.\n      s = (Integer # T # ST, LT) \\<and>\n      (T \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT.\n        s = (Integer # T # ST, LT) \\<and>\n        (T \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))", "ultimately"], ["proof (chain)\npicking this:\n  ST = [] \\<or>\n  (\\<exists>T. ST = [T]) \\<or>\n  (\\<exists>T\\<^sub>1 T\\<^sub>2 ST'. ST = T\\<^sub>1 # T\\<^sub>2 # ST')\n  ST = [] \\<Longrightarrow>\n  app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T ST LT.\n      s = (Integer # T # ST, LT) \\<and>\n      (T \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))\n  ST = [?T2] \\<Longrightarrow>\n  app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T ST LT.\n      s = (Integer # T # ST, LT) \\<and>\n      (T \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))\n  ST = ?T\\<^sub>12 # ?T\\<^sub>22 # ?ST'2 \\<Longrightarrow>\n  app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T ST LT.\n      s = (Integer # T # ST, LT) \\<and>\n      (T \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))", "show ?thesis"], ["proof (prove)\nusing this:\n  ST = [] \\<or>\n  (\\<exists>T. ST = [T]) \\<or>\n  (\\<exists>T\\<^sub>1 T\\<^sub>2 ST'. ST = T\\<^sub>1 # T\\<^sub>2 # ST')\n  ST = [] \\<Longrightarrow>\n  app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T ST LT.\n      s = (Integer # T # ST, LT) \\<and>\n      (T \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))\n  ST = [?T2] \\<Longrightarrow>\n  app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T ST LT.\n      s = (Integer # T # ST, LT) \\<and>\n      (T \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))\n  ST = ?T\\<^sub>12 # ?T\\<^sub>22 # ?ST'2 \\<Longrightarrow>\n  app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T ST LT.\n      s = (Integer # T # ST, LT) \\<and>\n      (T \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT.\n        s = (Integer # T # ST, LT) \\<and>\n        (T \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))", "by blast"], ["proof (state)\nthis:\n  app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T ST LT.\n      s = (Integer # T # ST, LT) \\<and>\n      (T \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma appAStore[simp]:\n  \"app\\<^sub>i (AStore,P,pc,mxs,T\\<^sub>r,s) = \n  (\\<exists>T U ST LT. s=(T#Integer#U#ST,LT) \\<and> (U \\<noteq> NT \\<longrightarrow> (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T U ST LT.\n        s = (T # Integer # U # ST, LT) \\<and>\n        (U \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T U ST LT.\n        s = (T # Integer # U # ST, LT) \\<and>\n        (U \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))", "obtain ST LT where [simp]: \"s = (ST, LT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ST LT. s = (ST, LT) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases s)"], ["proof (state)\nthis:\n  s = (ST, LT)\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T U ST LT.\n        s = (T # Integer # U # ST, LT) \\<and>\n        (U \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))", "have \"ST = [] \\<or> (\\<exists>T. ST = [T]) \\<or> (\\<exists>T\\<^sub>1 T\\<^sub>2. ST = [T\\<^sub>1, T\\<^sub>2]) \\<or> (\\<exists>T1 T2 T3 ST'. ST = T1 # T2 # T3 # ST')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ST = [] \\<or>\n    (\\<exists>T. ST = [T]) \\<or>\n    (\\<exists>T\\<^sub>1 T\\<^sub>2. ST = [T\\<^sub>1, T\\<^sub>2]) \\<or>\n    (\\<exists>T1 T2 T3 ST'. ST = T1 # T2 # T3 # ST')", "by (cases ST, auto, case_tac list, auto, case_tac lista, auto)"], ["proof (state)\nthis:\n  ST = [] \\<or>\n  (\\<exists>T. ST = [T]) \\<or>\n  (\\<exists>T\\<^sub>1 T\\<^sub>2. ST = [T\\<^sub>1, T\\<^sub>2]) \\<or>\n  (\\<exists>T1 T2 T3 ST'. ST = T1 # T2 # T3 # ST')\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T U ST LT.\n        s = (T # Integer # U # ST, LT) \\<and>\n        (U \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))", "moreover"], ["proof (state)\nthis:\n  ST = [] \\<or>\n  (\\<exists>T. ST = [T]) \\<or>\n  (\\<exists>T\\<^sub>1 T\\<^sub>2. ST = [T\\<^sub>1, T\\<^sub>2]) \\<or>\n  (\\<exists>T1 T2 T3 ST'. ST = T1 # T2 # T3 # ST')\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T U ST LT.\n        s = (T # Integer # U # ST, LT) \\<and>\n        (U \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))", "{"], ["proof (state)\nthis:\n  ST = [] \\<or>\n  (\\<exists>T. ST = [T]) \\<or>\n  (\\<exists>T\\<^sub>1 T\\<^sub>2. ST = [T\\<^sub>1, T\\<^sub>2]) \\<or>\n  (\\<exists>T1 T2 T3 ST'. ST = T1 # T2 # T3 # ST')\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T U ST LT.\n        s = (T # Integer # U # ST, LT) \\<and>\n        (U \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))", "assume \"ST = []\""], ["proof (state)\nthis:\n  ST = []\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T U ST LT.\n        s = (T # Integer # U # ST, LT) \\<and>\n        (U \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))", "hence ?thesis"], ["proof (prove)\nusing this:\n  ST = []\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T U ST LT.\n        s = (T # Integer # U # ST, LT) \\<and>\n        (U \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))", "by simp"], ["proof (state)\nthis:\n  app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T U ST LT.\n      s = (T # Integer # U # ST, LT) \\<and>\n      (U \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T U ST LT.\n        s = (T # Integer # U # ST, LT) \\<and>\n        (U \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))", "}"], ["proof (state)\nthis:\n  ST = [] \\<Longrightarrow>\n  app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T U ST LT.\n      s = (T # Integer # U # ST, LT) \\<and>\n      (U \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T U ST LT.\n        s = (T # Integer # U # ST, LT) \\<and>\n        (U \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))", "moreover"], ["proof (state)\nthis:\n  ST = [] \\<Longrightarrow>\n  app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T U ST LT.\n      s = (T # Integer # U # ST, LT) \\<and>\n      (U \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T U ST LT.\n        s = (T # Integer # U # ST, LT) \\<and>\n        (U \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))", "{"], ["proof (state)\nthis:\n  ST = [] \\<Longrightarrow>\n  app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T U ST LT.\n      s = (T # Integer # U # ST, LT) \\<and>\n      (U \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T U ST LT.\n        s = (T # Integer # U # ST, LT) \\<and>\n        (U \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))", "fix T"], ["proof (state)\ngoal (1 subgoal):\n 1. app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T U ST LT.\n        s = (T # Integer # U # ST, LT) \\<and>\n        (U \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))", "assume \"ST = [T]\""], ["proof (state)\nthis:\n  ST = [T]\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T U ST LT.\n        s = (T # Integer # U # ST, LT) \\<and>\n        (U \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))", "hence ?thesis"], ["proof (prove)\nusing this:\n  ST = [T]\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T U ST LT.\n        s = (T # Integer # U # ST, LT) \\<and>\n        (U \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))", "by(simp)"], ["proof (state)\nthis:\n  app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T U ST LT.\n      s = (T # Integer # U # ST, LT) \\<and>\n      (U \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T U ST LT.\n        s = (T # Integer # U # ST, LT) \\<and>\n        (U \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))", "}"], ["proof (state)\nthis:\n  ST = [?T2] \\<Longrightarrow>\n  app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T U ST LT.\n      s = (T # Integer # U # ST, LT) \\<and>\n      (U \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T U ST LT.\n        s = (T # Integer # U # ST, LT) \\<and>\n        (U \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))", "moreover"], ["proof (state)\nthis:\n  ST = [?T2] \\<Longrightarrow>\n  app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T U ST LT.\n      s = (T # Integer # U # ST, LT) \\<and>\n      (U \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T U ST LT.\n        s = (T # Integer # U # ST, LT) \\<and>\n        (U \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))", "{"], ["proof (state)\nthis:\n  ST = [?T2] \\<Longrightarrow>\n  app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T U ST LT.\n      s = (T # Integer # U # ST, LT) \\<and>\n      (U \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T U ST LT.\n        s = (T # Integer # U # ST, LT) \\<and>\n        (U \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))", "fix T1 T2"], ["proof (state)\ngoal (1 subgoal):\n 1. app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T U ST LT.\n        s = (T # Integer # U # ST, LT) \\<and>\n        (U \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))", "assume \"ST = [T1, T2]\""], ["proof (state)\nthis:\n  ST = [T1, T2]\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T U ST LT.\n        s = (T # Integer # U # ST, LT) \\<and>\n        (U \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))", "hence ?thesis"], ["proof (prove)\nusing this:\n  ST = [T1, T2]\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T U ST LT.\n        s = (T # Integer # U # ST, LT) \\<and>\n        (U \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))", "by simp"], ["proof (state)\nthis:\n  app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T U ST LT.\n      s = (T # Integer # U # ST, LT) \\<and>\n      (U \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T U ST LT.\n        s = (T # Integer # U # ST, LT) \\<and>\n        (U \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))", "}"], ["proof (state)\nthis:\n  ST = [?T1.2, ?T2.2] \\<Longrightarrow>\n  app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T U ST LT.\n      s = (T # Integer # U # ST, LT) \\<and>\n      (U \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T U ST LT.\n        s = (T # Integer # U # ST, LT) \\<and>\n        (U \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))", "moreover"], ["proof (state)\nthis:\n  ST = [?T1.2, ?T2.2] \\<Longrightarrow>\n  app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T U ST LT.\n      s = (T # Integer # U # ST, LT) \\<and>\n      (U \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T U ST LT.\n        s = (T # Integer # U # ST, LT) \\<and>\n        (U \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))", "{"], ["proof (state)\nthis:\n  ST = [?T1.2, ?T2.2] \\<Longrightarrow>\n  app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T U ST LT.\n      s = (T # Integer # U # ST, LT) \\<and>\n      (U \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T U ST LT.\n        s = (T # Integer # U # ST, LT) \\<and>\n        (U \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))", "fix T1 T2 T3 ST'"], ["proof (state)\ngoal (1 subgoal):\n 1. app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T U ST LT.\n        s = (T # Integer # U # ST, LT) \\<and>\n        (U \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))", "assume \"ST = T1 # T2 # T3 # ST'\""], ["proof (state)\nthis:\n  ST = T1 # T2 # T3 # ST'\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T U ST LT.\n        s = (T # Integer # U # ST, LT) \\<and>\n        (U \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))", "hence ?thesis"], ["proof (prove)\nusing this:\n  ST = T1 # T2 # T3 # ST'\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T U ST LT.\n        s = (T # Integer # U # ST, LT) \\<and>\n        (U \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))", "by(cases T2, auto)"], ["proof (state)\nthis:\n  app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T U ST LT.\n      s = (T # Integer # U # ST, LT) \\<and>\n      (U \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T U ST LT.\n        s = (T # Integer # U # ST, LT) \\<and>\n        (U \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))", "}"], ["proof (state)\nthis:\n  ST = ?T1.2 # ?T2.2 # ?T3.2 # ?ST'2 \\<Longrightarrow>\n  app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T U ST LT.\n      s = (T # Integer # U # ST, LT) \\<and>\n      (U \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T U ST LT.\n        s = (T # Integer # U # ST, LT) \\<and>\n        (U \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))", "ultimately"], ["proof (chain)\npicking this:\n  ST = [] \\<or>\n  (\\<exists>T. ST = [T]) \\<or>\n  (\\<exists>T\\<^sub>1 T\\<^sub>2. ST = [T\\<^sub>1, T\\<^sub>2]) \\<or>\n  (\\<exists>T1 T2 T3 ST'. ST = T1 # T2 # T3 # ST')\n  ST = [] \\<Longrightarrow>\n  app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T U ST LT.\n      s = (T # Integer # U # ST, LT) \\<and>\n      (U \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))\n  ST = [?T2] \\<Longrightarrow>\n  app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T U ST LT.\n      s = (T # Integer # U # ST, LT) \\<and>\n      (U \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))\n  ST = [?T1.2, ?T2.2] \\<Longrightarrow>\n  app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T U ST LT.\n      s = (T # Integer # U # ST, LT) \\<and>\n      (U \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))\n  ST = ?T1.2 # ?T2.2 # ?T3.2 # ?ST'2 \\<Longrightarrow>\n  app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T U ST LT.\n      s = (T # Integer # U # ST, LT) \\<and>\n      (U \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))", "show ?thesis"], ["proof (prove)\nusing this:\n  ST = [] \\<or>\n  (\\<exists>T. ST = [T]) \\<or>\n  (\\<exists>T\\<^sub>1 T\\<^sub>2. ST = [T\\<^sub>1, T\\<^sub>2]) \\<or>\n  (\\<exists>T1 T2 T3 ST'. ST = T1 # T2 # T3 # ST')\n  ST = [] \\<Longrightarrow>\n  app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T U ST LT.\n      s = (T # Integer # U # ST, LT) \\<and>\n      (U \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))\n  ST = [?T2] \\<Longrightarrow>\n  app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T U ST LT.\n      s = (T # Integer # U # ST, LT) \\<and>\n      (U \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))\n  ST = [?T1.2, ?T2.2] \\<Longrightarrow>\n  app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T U ST LT.\n      s = (T # Integer # U # ST, LT) \\<and>\n      (U \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))\n  ST = ?T1.2 # ?T2.2 # ?T3.2 # ?ST'2 \\<Longrightarrow>\n  app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T U ST LT.\n      s = (T # Integer # U # ST, LT) \\<and>\n      (U \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T U ST LT.\n        s = (T # Integer # U # ST, LT) \\<and>\n        (U \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))", "by blast"], ["proof (state)\nthis:\n  app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T U ST LT.\n      s = (T # Integer # U # ST, LT) \\<and>\n      (U \\<noteq> NT \\<longrightarrow>\n       (\\<exists>T'. U = T'\\<lfloor>\\<rceil>)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma appALength[simp]:\n  \"app\\<^sub>i (ALength,P,pc,mxs,T\\<^sub>r,s) = \n  (\\<exists>T ST LT. s=(T#ST,LT) \\<and> (T \\<noteq> NT \\<longrightarrow> (\\<exists>T'.  T = T'\\<lfloor>\\<rceil>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (ALength, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT.\n        s = (T # ST, LT) \\<and>\n        (T \\<noteq> NT \\<longrightarrow>\n         (\\<exists>T'. T = T'\\<lfloor>\\<rceil>)))", "by (cases s, cases \"fst s\", simp add: app_def) (cases \"hd (fst s)\", auto)"], ["", "lemma appCheckcast[simp]: \n  \"app\\<^sub>i (Checkcast Ty,P,pc,mxs,T\\<^sub>r,s) =  \n  (\\<exists>T ST LT. s = (T#ST,LT) \\<and> is_type P Ty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (Checkcast Ty, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT. s = (T # ST, LT) \\<and> is_type P Ty)", "by (cases s, cases \"fst s\", simp add: app_def) (cases \"hd (fst s)\", auto)"], ["", "lemma appInstanceof[simp]: \n  \"app\\<^sub>i (Instanceof Ty,P,pc,mxs,T\\<^sub>r,s) =  \n  (\\<exists>T ST LT. s = (T#ST,LT) \\<and> is_type P Ty \\<and> is_refT T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (Instanceof Ty, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT.\n        s = (T # ST, LT) \\<and> is_type P Ty \\<and> is_refT T)", "by (cases s, cases \"fst s\", simp add: app_def) (cases \"hd (fst s)\", auto)"], ["", "lemma app\\<^sub>iPop[simp]: \n\"app\\<^sub>i (Pop,P,pc,mxs,T\\<^sub>r,s) = (\\<exists>ts ST LT. s = (ts#ST,LT))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (Pop, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ts ST LT. s = (ts # ST, LT))", "by (rule length_cases2, auto)"], ["", "lemma appDup[simp]:\n\"app\\<^sub>i (Dup,P,pc,mxs,T\\<^sub>r,s) =\n (\\<exists>T ST LT. s = (T#ST,LT) \\<and> Suc (length ST) < mxs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (Dup, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT. s = (T # ST, LT) \\<and> Suc (length ST) < mxs)", "by (cases s, cases \"fst s\", simp_all)"], ["", "lemma app\\<^sub>iSwap[simp]: \n\"app\\<^sub>i (Swap,P,pc,mxs,T\\<^sub>r,s) = (\\<exists>T1 T2 ST LT. s = (T1#T2#ST,LT))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (Swap, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T1 T2 ST LT. s = (T1 # T2 # ST, LT))", "by(rule length_cases4) auto"], ["", "lemma appBinOp[simp]:\n\"app\\<^sub>i (BinOpInstr bop,P,pc,mxs,T\\<^sub>r,s) = (\\<exists>T1 T2 ST LT T. s = (T2 # T1 # ST, LT) \\<and> P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T1 T2 ST LT T.\n        s = (T2 # T1 # ST, LT) \\<and>\n        P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T1 T2 ST LT T.\n        s = (T2 # T1 # ST, LT) \\<and>\n        P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)", "obtain ST LT where [simp]: \"s = (ST,LT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ST LT. s = (ST, LT) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases s)"], ["proof (state)\nthis:\n  s = (ST, LT)\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T1 T2 ST LT T.\n        s = (T2 # T1 # ST, LT) \\<and>\n        P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)", "have \"ST = [] \\<or> (\\<exists>T. ST = [T]) \\<or> (\\<exists>T\\<^sub>1 T\\<^sub>2 ST'. ST = T\\<^sub>1#T\\<^sub>2#ST')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ST = [] \\<or>\n    (\\<exists>T. ST = [T]) \\<or>\n    (\\<exists>T\\<^sub>1 T\\<^sub>2 ST'. ST = T\\<^sub>1 # T\\<^sub>2 # ST')", "by (cases ST, auto, case_tac list, auto)"], ["proof (state)\nthis:\n  ST = [] \\<or>\n  (\\<exists>T. ST = [T]) \\<or>\n  (\\<exists>T\\<^sub>1 T\\<^sub>2 ST'. ST = T\\<^sub>1 # T\\<^sub>2 # ST')\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T1 T2 ST LT T.\n        s = (T2 # T1 # ST, LT) \\<and>\n        P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)", "moreover"], ["proof (state)\nthis:\n  ST = [] \\<or>\n  (\\<exists>T. ST = [T]) \\<or>\n  (\\<exists>T\\<^sub>1 T\\<^sub>2 ST'. ST = T\\<^sub>1 # T\\<^sub>2 # ST')\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T1 T2 ST LT T.\n        s = (T2 # T1 # ST, LT) \\<and>\n        P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)", "{"], ["proof (state)\nthis:\n  ST = [] \\<or>\n  (\\<exists>T. ST = [T]) \\<or>\n  (\\<exists>T\\<^sub>1 T\\<^sub>2 ST'. ST = T\\<^sub>1 # T\\<^sub>2 # ST')\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T1 T2 ST LT T.\n        s = (T2 # T1 # ST, LT) \\<and>\n        P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)", "assume \"ST = []\""], ["proof (state)\nthis:\n  ST = []\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T1 T2 ST LT T.\n        s = (T2 # T1 # ST, LT) \\<and>\n        P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)", "hence ?thesis"], ["proof (prove)\nusing this:\n  ST = []\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T1 T2 ST LT T.\n        s = (T2 # T1 # ST, LT) \\<and>\n        P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)", "by simp"], ["proof (state)\nthis:\n  app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T1 T2 ST LT T.\n      s = (T2 # T1 # ST, LT) \\<and>\n      P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T1 T2 ST LT T.\n        s = (T2 # T1 # ST, LT) \\<and>\n        P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)", "}"], ["proof (state)\nthis:\n  ST = [] \\<Longrightarrow>\n  app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T1 T2 ST LT T.\n      s = (T2 # T1 # ST, LT) \\<and>\n      P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T1 T2 ST LT T.\n        s = (T2 # T1 # ST, LT) \\<and>\n        P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)", "moreover"], ["proof (state)\nthis:\n  ST = [] \\<Longrightarrow>\n  app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T1 T2 ST LT T.\n      s = (T2 # T1 # ST, LT) \\<and>\n      P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T1 T2 ST LT T.\n        s = (T2 # T1 # ST, LT) \\<and>\n        P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)", "{"], ["proof (state)\nthis:\n  ST = [] \\<Longrightarrow>\n  app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T1 T2 ST LT T.\n      s = (T2 # T1 # ST, LT) \\<and>\n      P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T1 T2 ST LT T.\n        s = (T2 # T1 # ST, LT) \\<and>\n        P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)", "fix T"], ["proof (state)\ngoal (1 subgoal):\n 1. app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T1 T2 ST LT T.\n        s = (T2 # T1 # ST, LT) \\<and>\n        P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)", "assume \"ST = [T]\""], ["proof (state)\nthis:\n  ST = [T]\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T1 T2 ST LT T.\n        s = (T2 # T1 # ST, LT) \\<and>\n        P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)", "hence ?thesis"], ["proof (prove)\nusing this:\n  ST = [T]\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T1 T2 ST LT T.\n        s = (T2 # T1 # ST, LT) \\<and>\n        P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)", "by (cases T, auto)"], ["proof (state)\nthis:\n  app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T1 T2 ST LT T.\n      s = (T2 # T1 # ST, LT) \\<and>\n      P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T1 T2 ST LT T.\n        s = (T2 # T1 # ST, LT) \\<and>\n        P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)", "}"], ["proof (state)\nthis:\n  ST = [?T2] \\<Longrightarrow>\n  app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T1 T2 ST LT T.\n      s = (T2 # T1 # ST, LT) \\<and>\n      P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T1 T2 ST LT T.\n        s = (T2 # T1 # ST, LT) \\<and>\n        P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)", "moreover"], ["proof (state)\nthis:\n  ST = [?T2] \\<Longrightarrow>\n  app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T1 T2 ST LT T.\n      s = (T2 # T1 # ST, LT) \\<and>\n      P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T1 T2 ST LT T.\n        s = (T2 # T1 # ST, LT) \\<and>\n        P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)", "{"], ["proof (state)\nthis:\n  ST = [?T2] \\<Longrightarrow>\n  app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T1 T2 ST LT T.\n      s = (T2 # T1 # ST, LT) \\<and>\n      P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T1 T2 ST LT T.\n        s = (T2 # T1 # ST, LT) \\<and>\n        P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)", "fix T\\<^sub>1 T\\<^sub>2 ST'"], ["proof (state)\ngoal (1 subgoal):\n 1. app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T1 T2 ST LT T.\n        s = (T2 # T1 # ST, LT) \\<and>\n        P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)", "assume \"ST = T\\<^sub>1#T\\<^sub>2#ST'\""], ["proof (state)\nthis:\n  ST = T\\<^sub>1 # T\\<^sub>2 # ST'\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T1 T2 ST LT T.\n        s = (T2 # T1 # ST, LT) \\<and>\n        P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)", "hence ?thesis"], ["proof (prove)\nusing this:\n  ST = T\\<^sub>1 # T\\<^sub>2 # ST'\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T1 T2 ST LT T.\n        s = (T2 # T1 # ST, LT) \\<and>\n        P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)", "by simp"], ["proof (state)\nthis:\n  app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T1 T2 ST LT T.\n      s = (T2 # T1 # ST, LT) \\<and>\n      P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T1 T2 ST LT T.\n        s = (T2 # T1 # ST, LT) \\<and>\n        P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)", "}"], ["proof (state)\nthis:\n  ST = ?T\\<^sub>12 # ?T\\<^sub>22 # ?ST'2 \\<Longrightarrow>\n  app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T1 T2 ST LT T.\n      s = (T2 # T1 # ST, LT) \\<and>\n      P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T1 T2 ST LT T.\n        s = (T2 # T1 # ST, LT) \\<and>\n        P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)", "ultimately"], ["proof (chain)\npicking this:\n  ST = [] \\<or>\n  (\\<exists>T. ST = [T]) \\<or>\n  (\\<exists>T\\<^sub>1 T\\<^sub>2 ST'. ST = T\\<^sub>1 # T\\<^sub>2 # ST')\n  ST = [] \\<Longrightarrow>\n  app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T1 T2 ST LT T.\n      s = (T2 # T1 # ST, LT) \\<and>\n      P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)\n  ST = [?T2] \\<Longrightarrow>\n  app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T1 T2 ST LT T.\n      s = (T2 # T1 # ST, LT) \\<and>\n      P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)\n  ST = ?T\\<^sub>12 # ?T\\<^sub>22 # ?ST'2 \\<Longrightarrow>\n  app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T1 T2 ST LT T.\n      s = (T2 # T1 # ST, LT) \\<and>\n      P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)", "show ?thesis"], ["proof (prove)\nusing this:\n  ST = [] \\<or>\n  (\\<exists>T. ST = [T]) \\<or>\n  (\\<exists>T\\<^sub>1 T\\<^sub>2 ST'. ST = T\\<^sub>1 # T\\<^sub>2 # ST')\n  ST = [] \\<Longrightarrow>\n  app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T1 T2 ST LT T.\n      s = (T2 # T1 # ST, LT) \\<and>\n      P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)\n  ST = [?T2] \\<Longrightarrow>\n  app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T1 T2 ST LT T.\n      s = (T2 # T1 # ST, LT) \\<and>\n      P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)\n  ST = ?T\\<^sub>12 # ?T\\<^sub>22 # ?ST'2 \\<Longrightarrow>\n  app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T1 T2 ST LT T.\n      s = (T2 # T1 # ST, LT) \\<and>\n      P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T1 T2 ST LT T.\n        s = (T2 # T1 # ST, LT) \\<and>\n        P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)", "by blast"], ["proof (state)\nthis:\n  app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>T1 T2 ST LT T.\n      s = (T2 # T1 # ST, LT) \\<and>\n      P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma appIfFalse [simp]:\n\"app\\<^sub>i (IfFalse b,P,pc,mxs,T\\<^sub>r,s) = \n  (\\<exists>ST LT. s = (Boolean#ST,LT) \\<and> 0 \\<le> int pc + b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (IfFalse b, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT. s = (Boolean # ST, LT) \\<and> 0 \\<le> int pc + b)", "apply (rule length_cases2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>LT.\n       app\\<^sub>i (IfFalse b, P, pc, mxs, T\\<^sub>r, [], LT) =\n       (\\<exists>ST LTa.\n           ([], LT) = (Boolean # ST, LTa) \\<and> 0 \\<le> int pc + b)\n 2. \\<And>l ST LT.\n       app\\<^sub>i (IfFalse b, P, pc, mxs, T\\<^sub>r, l # ST, LT) =\n       (\\<exists>STa LTa.\n           (l # ST, LT) = (Boolean # STa, LTa) \\<and> 0 \\<le> int pc + b)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ST LT.\n       app\\<^sub>i (IfFalse b, P, pc, mxs, T\\<^sub>r, l # ST, LT) =\n       (\\<exists>STa LTa.\n           (l # ST, LT) = (Boolean # STa, LTa) \\<and> 0 \\<le> int pc + b)", "apply (case_tac l)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>l ST LT.\n       l = Void \\<Longrightarrow>\n       app\\<^sub>i (IfFalse b, P, pc, mxs, T\\<^sub>r, l # ST, LT) =\n       (\\<exists>STa LTa.\n           (l # ST, LT) = (Boolean # STa, LTa) \\<and> 0 \\<le> int pc + b)\n 2. \\<And>l ST LT.\n       l = Boolean \\<Longrightarrow>\n       app\\<^sub>i (IfFalse b, P, pc, mxs, T\\<^sub>r, l # ST, LT) =\n       (\\<exists>STa LTa.\n           (l # ST, LT) = (Boolean # STa, LTa) \\<and> 0 \\<le> int pc + b)\n 3. \\<And>l ST LT.\n       l = Integer \\<Longrightarrow>\n       app\\<^sub>i (IfFalse b, P, pc, mxs, T\\<^sub>r, l # ST, LT) =\n       (\\<exists>STa LTa.\n           (l # ST, LT) = (Boolean # STa, LTa) \\<and> 0 \\<le> int pc + b)\n 4. \\<And>l ST LT.\n       l = NT \\<Longrightarrow>\n       app\\<^sub>i (IfFalse b, P, pc, mxs, T\\<^sub>r, l # ST, LT) =\n       (\\<exists>STa LTa.\n           (l # ST, LT) = (Boolean # STa, LTa) \\<and> 0 \\<le> int pc + b)\n 5. \\<And>l ST LT x5.\n       l = Class x5 \\<Longrightarrow>\n       app\\<^sub>i (IfFalse b, P, pc, mxs, T\\<^sub>r, l # ST, LT) =\n       (\\<exists>STa LTa.\n           (l # ST, LT) = (Boolean # STa, LTa) \\<and> 0 \\<le> int pc + b)\n 6. \\<And>l ST LT x6.\n       l = x6\\<lfloor>\\<rceil> \\<Longrightarrow>\n       app\\<^sub>i (IfFalse b, P, pc, mxs, T\\<^sub>r, l # ST, LT) =\n       (\\<exists>STa LTa.\n           (l # ST, LT) = (Boolean # STa, LTa) \\<and> 0 \\<le> int pc + b)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma appReturn[simp]:\n\"app\\<^sub>i (Return,P,pc,mxs,T\\<^sub>r,s) = (\\<exists>T ST LT. s = (T#ST,LT) \\<and> P \\<turnstile> T \\<le> T\\<^sub>r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (Return, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT.\n        s = (T # ST, LT) \\<and> P \\<turnstile> T \\<le> T\\<^sub>r)", "by (rule length_cases2, auto)"], ["", "lemma appThrow[simp]:\n  \"app\\<^sub>i (ThrowExc,P,pc,mxs,T\\<^sub>r,s) = (\\<exists>T ST LT. s=(T#ST,LT) \\<and> (T = NT \\<or> (\\<exists>C. T = Class C \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* Throwable)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (ThrowExc, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT.\n        s = (T # ST, LT) \\<and>\n        (T = NT \\<or>\n         (\\<exists>C.\n             T = Class C \\<and>\n             P \\<turnstile> C \\<preceq>\\<^sup>* Throwable)))", "by (rule length_cases2, auto)"], ["", "lemma appMEnter[simp]:\n  \"app\\<^sub>i (MEnter,P,pc,mxs,T\\<^sub>r,s) = (\\<exists>T ST LT. s=(T#ST,LT) \\<and> is_refT T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (MEnter, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT. s = (T # ST, LT) \\<and> is_refT T)", "by (rule length_cases2, auto)"], ["", "lemma appMExit[simp]:\n  \"app\\<^sub>i (MExit,P,pc,mxs,T\\<^sub>r,s) = (\\<exists>T ST LT. s=(T#ST,LT) \\<and> is_refT T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (MExit, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT. s = (T # ST, LT) \\<and> is_refT T)", "by (rule length_cases2, auto)"], ["", "lemma effNone: \n  \"(pc', s') \\<in> set (eff i P pc et None) \\<Longrightarrow> s' = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pc', s') \\<in> set (eff i P pc et None) \\<Longrightarrow> s' = None", "by (auto simp add: eff_def xcpt_eff_def norm_eff_def)"], ["", "lemma relevant_entries_append [simp]:\n  \"relevant_entries P i pc (xt @ xt') = relevant_entries P i pc xt @ relevant_entries P i pc xt'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. relevant_entries P i pc (xt @ xt') =\n    relevant_entries P i pc xt @ relevant_entries P i pc xt'", "by (unfold relevant_entries_def) simp"], ["", "lemma xcpt_app_append [iff]:\n  \"xcpt_app i P pc mxs (xt@xt') \\<tau> = (xcpt_app i P pc mxs xt \\<tau> \\<and> xcpt_app i P pc mxs xt' \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xcpt_app i P pc mxs (xt @ xt') \\<tau> =\n    (xcpt_app i P pc mxs xt \\<tau> \\<and> xcpt_app i P pc mxs xt' \\<tau>)", "unfolding xcpt_app_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>(f, t, C, h, d)\\<in>set (relevant_entries P i pc (xt @ xt')).\n        (case C of None \\<Rightarrow> True\n         | \\<lfloor>C'\\<rfloor> \\<Rightarrow> is_class P C') \\<and>\n        d \\<le> length (fst \\<tau>) \\<and> d < mxs) =\n    ((\\<forall>(f, t, C, h, d)\\<in>set (relevant_entries P i pc xt).\n         (case C of None \\<Rightarrow> True\n          | \\<lfloor>C'\\<rfloor> \\<Rightarrow> is_class P C') \\<and>\n         d \\<le> length (fst \\<tau>) \\<and> d < mxs) \\<and>\n     (\\<forall>(f, t, C, h, d)\\<in>set (relevant_entries P i pc xt').\n         (case C of None \\<Rightarrow> True\n          | \\<lfloor>C'\\<rfloor> \\<Rightarrow> is_class P C') \\<and>\n         d \\<le> length (fst \\<tau>) \\<and> d < mxs))", "by force"], ["", "lemma xcpt_eff_append [simp]:\n  \"xcpt_eff i P pc \\<tau> (xt@xt') = xcpt_eff i P pc \\<tau> xt @ xcpt_eff i P pc \\<tau> xt'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xcpt_eff i P pc \\<tau> (xt @ xt') =\n    xcpt_eff i P pc \\<tau> xt @ xcpt_eff i P pc \\<tau> xt'", "by (unfold xcpt_eff_def, cases \\<tau>) simp"], ["", "lemma app_append [simp]:\n  \"app i P pc T mxs mpc (xt@xt') \\<tau> = (app i P pc T mxs mpc xt \\<tau> \\<and> app i P pc T mxs mpc xt' \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app i P pc T mxs mpc (xt @ xt') \\<tau> =\n    (app i P pc T mxs mpc xt \\<tau> \\<and> app i P pc T mxs mpc xt' \\<tau>)", "by (unfold app_def eff_def) auto"], ["", "subsection \\<open>Code generator setup\\<close>"], ["", "declare list_all2_Nil [code]"], ["", "declare list_all2_Cons [code]"], ["", "lemma eff\\<^sub>i_BinOpInstr_code:\n  \"eff\\<^sub>i (BinOpInstr bop, P, (T2#T1#ST,LT)) = (Predicate.the (WTrt_binop_i_i_i_i_o P T1 bop T2) # ST, LT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eff\\<^sub>i (BinOpInstr bop, P, T2 # T1 # ST, LT) =\n    (Predicate.the (WTrt_binop_i_i_i_i_o P T1 bop T2) # ST, LT)", "by(simp add: the_WTrt_binop_code)"], ["", "lemmas eff\\<^sub>i_code[code] =\n  eff\\<^sub>i_Load eff\\<^sub>i_Store eff\\<^sub>i_Push eff\\<^sub>i_Getfield eff\\<^sub>i_Putfield eff\\<^sub>i_New eff\\<^sub>i_NewArray eff\\<^sub>i_ALoad\n  eff\\<^sub>i_AStore eff\\<^sub>i_ALength eff\\<^sub>i_Checkcast eff\\<^sub>i_Instanceof eff\\<^sub>i_Pop eff\\<^sub>i_Dup eff\\<^sub>i_Swap eff\\<^sub>i_BinOpInstr_code\n  eff\\<^sub>i_IfFalse eff\\<^sub>i_Invoke eff\\<^sub>i_Goto eff\\<^sub>i_MEnter eff\\<^sub>i_MExit"], ["", "lemma app\\<^sub>i_Getfield_code:\n  \"app\\<^sub>i (Getfield F C, P, pc, mxs, T\\<^sub>r, (T#ST, LT)) \\<longleftrightarrow>\n  Predicate.holds (Predicate.bind (sees_field_i_i_i_o_o_i P C F C) (\\<lambda>T. Predicate.single ())) \\<and> P \\<turnstile> T \\<le> Class C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (Getfield F C, P, pc, mxs, T\\<^sub>r, T # ST, LT) =\n    (Predicate.holds\n      (sees_field_i_i_i_o_o_i P C F C \\<bind>\n       (\\<lambda>T. Predicate.single ())) \\<and>\n     P \\<turnstile> T \\<le> Class C)", "apply(clarsimp simp add: Predicate.bind_def Predicate.single_def holds_eq eval_sees_field_i_i_i_o_i_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma app\\<^sub>i_Putfield_code:\n  \"app\\<^sub>i (Putfield F C, P, pc, mxs, T\\<^sub>r, (T\\<^sub>1#T\\<^sub>2#ST, LT)) \\<longleftrightarrow>\n   P \\<turnstile> T\\<^sub>2 \\<le> (Class C) \\<and>\n   Predicate.holds (Predicate.bind (sees_field_i_i_i_o_o_i P C F C) (\\<lambda>(T, fm). if P \\<turnstile> T\\<^sub>1 \\<le> T then Predicate.single () else bot))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i\n     (Putfield F C, P, pc, mxs, T\\<^sub>r, T\\<^sub>1 # T\\<^sub>2 # ST, LT) =\n    (P \\<turnstile> T\\<^sub>2 \\<le> Class C \\<and>\n     Predicate.holds\n      (sees_field_i_i_i_o_o_i P C F C \\<bind>\n       (\\<lambda>(T, fm).\n           if P \\<turnstile> T\\<^sub>1 \\<le> T then Predicate.single ()\n           else bot)))", "by (auto simp add: holds_eq eval_sees_field_i_i_i_o_i_conv split: if_splits)"], ["", "lemma app\\<^sub>i_CAS_code:\n  \"app\\<^sub>i (CAS F C, P, pc, mxs, T\\<^sub>r, (T\\<^sub>3#T\\<^sub>2#T\\<^sub>1#ST, LT)) \\<longleftrightarrow>\n   P \\<turnstile> T\\<^sub>1 \\<le> Class C \\<and>\n  Predicate.holds (Predicate.bind (sees_field_i_i_i_o_o_i P C F C) (\\<lambda>(T, fm). if P \\<turnstile> T\\<^sub>2 \\<le> T \\<and> P \\<turnstile> T\\<^sub>3 \\<le> T \\<and> volatile fm then Predicate.single () else bot))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i\n     (CAS F C, P, pc, mxs, T\\<^sub>r,\n      T\\<^sub>3 # T\\<^sub>2 # T\\<^sub>1 # ST, LT) =\n    (P \\<turnstile> T\\<^sub>1 \\<le> Class C \\<and>\n     Predicate.holds\n      (sees_field_i_i_i_o_o_i P C F C \\<bind>\n       (\\<lambda>(T, fm).\n           if P \\<turnstile> T\\<^sub>2 \\<le> T \\<and>\n              P \\<turnstile> T\\<^sub>3 \\<le> T \\<and> volatile fm\n           then Predicate.single () else bot)))", "by(auto simp add: holds_eq eval_sees_field_i_i_i_o_i_conv)"], ["", "lemma app\\<^sub>i_ALoad_code:\n  \"app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, (T1#T2#ST,LT)) = \n   (T1 = Integer \\<and> (case T2 of Ty\\<lfloor>\\<rceil> \\<Rightarrow> True | NT \\<Rightarrow> True | _ \\<Rightarrow> False))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (ALoad, P, pc, mxs, T\\<^sub>r, T1 # T2 # ST, LT) =\n    (T1 = Integer \\<and>\n     (case T2 of NT \\<Rightarrow> True\n      | Ty\\<lfloor>\\<rceil> \\<Rightarrow> True | _ \\<Rightarrow> False))", "by(simp add: split: ty.split)"], ["", "lemma app\\<^sub>i_AStore_code:\n  \"app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, (T1#T2#T3#ST,LT)) = \n  (T2 = Integer \\<and> (case T3 of Ty\\<lfloor>\\<rceil> \\<Rightarrow> True | NT \\<Rightarrow> True | _ \\<Rightarrow> False))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (AStore, P, pc, mxs, T\\<^sub>r, T1 # T2 # T3 # ST, LT) =\n    (T2 = Integer \\<and>\n     (case T3 of NT \\<Rightarrow> True\n      | Ty\\<lfloor>\\<rceil> \\<Rightarrow> True | _ \\<Rightarrow> False))", "by(simp add: split: ty.split)"], ["", "lemma app\\<^sub>i_ALength_code:\n  \"app\\<^sub>i (ALength, P, pc, mxs, T\\<^sub>r, (T1#ST,LT)) = \n   (case T1 of Ty\\<lfloor>\\<rceil> \\<Rightarrow> True | NT \\<Rightarrow> True | _ \\<Rightarrow> False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (ALength, P, pc, mxs, T\\<^sub>r, T1 # ST, LT) =\n    (case T1 of NT \\<Rightarrow> True\n     | Ty\\<lfloor>\\<rceil> \\<Rightarrow> True | _ \\<Rightarrow> False)", "by(simp add: split: ty.split)"], ["", "lemma app\\<^sub>i_BinOpInstr_code:\n  \"app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, (T2#T1#ST,LT)) = \n   Predicate.holds (Predicate.bind (WTrt_binop_i_i_i_i_o P T1 bop T2) (\\<lambda>T. Predicate.single ()))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (BinOpInstr bop, P, pc, mxs, T\\<^sub>r, T2 # T1 # ST, LT) =\n    Predicate.holds\n     (WTrt_binop_i_i_i_i_o P T1 bop T2 \\<bind>\n      (\\<lambda>T. Predicate.single ()))", "by (auto simp add: holds_eq eval_WTrt_binop_i_i_i_i_o)"], ["", "lemma app\\<^sub>i_Invoke_code:\n  \"app\\<^sub>i (Invoke M n, P, pc, mxs, T\\<^sub>r, (ST,LT)) =\n  (n < length ST \\<and> \n  (ST!n \\<noteq> NT \\<longrightarrow>\n     (case class_type_of' (ST ! n) of Some C \\<Rightarrow> \n         Predicate.holds (Predicate.bind (Method_i_i_i_o_o_o_o P C M) \n                                          (\\<lambda>(Ts, _). if P \\<turnstile> rev (take n ST) [\\<le>] Ts then Predicate.single () else bot))\n      | _ \\<Rightarrow> False)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (Invoke M n, P, pc, mxs, T\\<^sub>r, ST, LT) =\n    (n < length ST \\<and>\n     (ST ! n \\<noteq> NT \\<longrightarrow>\n      (case class_type_of' (ST ! n) of None \\<Rightarrow> False\n       | \\<lfloor>C\\<rfloor> \\<Rightarrow>\n           Predicate.holds\n            (Method_i_i_i_o_o_o_o P C M \\<bind>\n             (\\<lambda>(Ts, uu_).\n                 if P \\<turnstile> rev (take n ST) [\\<le>] Ts\n                 then Predicate.single () else bot)))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. app\\<^sub>i (Invoke M n, P, pc, mxs, T\\<^sub>r, ST, LT) =\n    (n < length ST \\<and>\n     (ST ! n \\<noteq> NT \\<longrightarrow>\n      (case class_type_of' (ST ! n) of None \\<Rightarrow> False\n       | \\<lfloor>C\\<rfloor> \\<Rightarrow>\n           Predicate.holds\n            (Method_i_i_i_o_o_o_o P C M \\<bind>\n             (\\<lambda>(Ts, uu_).\n                 if P \\<turnstile> rev (take n ST) [\\<le>] Ts\n                 then Predicate.single () else bot)))))", "have bind_Ex: \"\\<And>P f. Predicate.bind P f = Predicate.Pred (\\<lambda>x. (\\<exists>y. Predicate.eval P y \\<and> Predicate.eval (f y) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P f.\n       P \\<bind> f =\n       pred.Pred\n        (\\<lambda>x. \\<exists>y. pred.eval P y \\<and> pred.eval (f y) x)", "by (rule pred_eqI) auto"], ["proof (state)\nthis:\n  ?P \\<bind> ?f =\n  pred.Pred\n   (\\<lambda>x. \\<exists>y. pred.eval ?P y \\<and> pred.eval (?f y) x)\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (Invoke M n, P, pc, mxs, T\\<^sub>r, ST, LT) =\n    (n < length ST \\<and>\n     (ST ! n \\<noteq> NT \\<longrightarrow>\n      (case class_type_of' (ST ! n) of None \\<Rightarrow> False\n       | \\<lfloor>C\\<rfloor> \\<Rightarrow>\n           Predicate.holds\n            (Method_i_i_i_o_o_o_o P C M \\<bind>\n             (\\<lambda>(Ts, uu_).\n                 if P \\<turnstile> rev (take n ST) [\\<le>] Ts\n                 then Predicate.single () else bot)))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?P \\<bind> ?f =\n  pred.Pred\n   (\\<lambda>x. \\<exists>y. pred.eval ?P y \\<and> pred.eval (?f y) x)\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (Invoke M n, P, pc, mxs, T\\<^sub>r, ST, LT) =\n    (n < length ST \\<and>\n     (ST ! n \\<noteq> NT \\<longrightarrow>\n      (case class_type_of' (ST ! n) of None \\<Rightarrow> False\n       | \\<lfloor>C\\<rfloor> \\<Rightarrow>\n           Predicate.holds\n            (Method_i_i_i_o_o_o_o P C M \\<bind>\n             (\\<lambda>(Ts, uu_).\n                 if P \\<turnstile> rev (take n ST) [\\<le>] Ts\n                 then Predicate.single () else bot)))))", "by (auto simp add: bind_Ex Predicate.single_def holds_eq eval_Method_i_i_i_o_o_o_o_conv split: ty.split)"], ["proof (state)\nthis:\n  app\\<^sub>i (Invoke M n, P, pc, mxs, T\\<^sub>r, ST, LT) =\n  (n < length ST \\<and>\n   (ST ! n \\<noteq> NT \\<longrightarrow>\n    (case class_type_of' (ST ! n) of None \\<Rightarrow> False\n     | \\<lfloor>C\\<rfloor> \\<Rightarrow>\n         Predicate.holds\n          (Method_i_i_i_o_o_o_o P C M \\<bind>\n           (\\<lambda>(Ts, uu_).\n               if P \\<turnstile> rev (take n ST) [\\<le>] Ts\n               then Predicate.single () else bot)))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma app\\<^sub>i_Throw_code:\n  \"app\\<^sub>i (ThrowExc, P, pc, mxs, T\\<^sub>r, (T#ST,LT)) = \n  (case T of NT \\<Rightarrow> True | Class C \\<Rightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* Throwable | _ \\<Rightarrow> False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (ThrowExc, P, pc, mxs, T\\<^sub>r, T # ST, LT) =\n    (case T of NT \\<Rightarrow> True\n     | Class C \\<Rightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* Throwable\n     | _ \\<Rightarrow> False)", "by(simp split: ty.split)"], ["", "lemmas app\\<^sub>i_code [code] =\n  app\\<^sub>i_Load app\\<^sub>i_Store app\\<^sub>i_Push\n  app\\<^sub>i_Getfield_code app\\<^sub>i_Putfield_code app\\<^sub>i_CAS_code\n  app\\<^sub>i_New app\\<^sub>i_NewArray\n  app\\<^sub>i_ALoad_code app\\<^sub>i_AStore_code app\\<^sub>i_ALength_code\n  app\\<^sub>i_Checkcast app\\<^sub>i_Instanceof\n  app\\<^sub>i_Pop app\\<^sub>i_Dup app\\<^sub>i_Swap app\\<^sub>i_BinOpInstr_code app\\<^sub>i_IfFalse app\\<^sub>i_Goto\n  app\\<^sub>i_Return app\\<^sub>i_Throw_code app\\<^sub>i_Invoke_code app\\<^sub>i_MEnter app\\<^sub>i_MExit\n  app\\<^sub>i_default"], ["", "end"]]}