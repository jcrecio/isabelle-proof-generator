{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/MM/JMM_Type2.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma rec_addr_conv_case_addr [simp]: \"rec_addr = case_addr\"", "lemma jmm_typeof_addr'_conv_jmm_type_addr: \"jmm_typeof_addr' P = jmm_typeof_addr P h\"", "lemma jmm_typeof_addr'_conv_jmm_typeof_addr: \"(\\<lambda>_. jmm_typeof_addr' P) = jmm_typeof_addr P\"", "lemma jmm_typeof_addr_conv_jmm_typeof_addr': \"jmm_typeof_addr = (\\<lambda>P _. jmm_typeof_addr' P)\"", "lemmas jmm_heap_ops_defs =\n  jmm_allocate_def jmm_typeof_addr_def \n  jmm_heap_read_def jmm_heap_write_def\n  jmm_allocated_def jmm_spurious_wakeups_def", "lemma jmm_heap: \"heap addr2thread_id thread_id2addr jmm_allocate (jmm_typeof_addr P) jmm_heap_write P\"", "lemmas jmm'_heap = jmm_heap", "lemma jmm_heap_read_typed_default_val:\n  \"heap_base.heap_read_typed typeof_addr jmm_heap_read P h a al\n   (default_val (THE T. heap_base.addr_loc_type typeof_addr P h a al T))\"", "lemma jmm_allocate_Eps:\n  \"(SOME ha. ha \\<in> jmm_allocate h hT) = (h', a')\n  \\<Longrightarrow> jmm_allocate h hT \\<noteq> {} \\<longrightarrow> (h', a') \\<in> jmm_allocate h hT\"", "lemma jmm_allocate_eq_empty: \"jmm_allocate h hT = {} \\<longleftrightarrow> h hT = UNIV\"", "lemma jmm_allocate_otherD:\n  \"(h', a) \\<in> jmm_allocate h hT \\<Longrightarrow> \\<forall>hT'. hT' \\<noteq> hT \\<longrightarrow> h' hT' = h hT'\"", "lemma jmm_start_heap_ok: \"jmm.start_heap_ok\"", "lemma jmm_heap_read_typeable: \"jmm_heap_read_typeable P\"", "lemma jmm'_heap_read_typeable: \"jmm'_heap_read_typeable P\"", "lemma jmm_heap_conf:\n  \"heap_conf addr2thread_id thread_id2addr jmm_empty jmm_allocate (jmm_typeof_addr P) jmm_heap_write jmm_hconf P\"", "lemmas jmm'_heap_conf = jmm_heap_conf", "lemma jmm_heap_progress:\n  \"heap_progress addr2thread_id thread_id2addr jmm_empty jmm_allocate (jmm_typeof_addr P) jmm_heap_read jmm_heap_write jmm_hconf P\"", "lemma jmm'_heap_progress:\n  \"heap_progress addr2thread_id thread_id2addr jmm_empty jmm_allocate (jmm_typeof_addr P) (jmm_heap_read_typed P) jmm_heap_write jmm'_hconf P\"", "lemma jmm'_heap_conf_read:\n  \"heap_conf_read addr2thread_id thread_id2addr jmm_empty jmm_allocate (jmm_typeof_addr P) (jmm_heap_read_typed P) jmm_heap_write jmm'_hconf P\"", "lemma jmm_allocated_heap:\n  \"allocated_heap addr2thread_id thread_id2addr jmm_empty jmm_allocate (jmm_typeof_addr P) jmm_heap_write jmm_allocated P\"", "lemmas jmm'_allocated_heap = jmm_allocated_heap"], "translations": [["", "lemma rec_addr_conv_case_addr [simp]: \"rec_addr = case_addr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_addr = case_addr", "by(auto intro!: ext split: addr.split)"], ["", "instantiation addr :: addr begin"], ["", "definition \"hash_addr (a :: addr) = (case a of Address ht n \\<Rightarrow> int n)\""], ["", "definition \"monitor_finfun_to_list (ls :: addr \\<Rightarrow>f nat) = (SOME xs. set xs = {x. finfun_dom ls $ x })\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(addr, addr_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f. set (monitor_finfun_to_list f) = Collect (($) (finfun_dom f))", "fix ls :: \"addr \\<Rightarrow>f nat\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f. set (monitor_finfun_to_list f) = Collect (($) (finfun_dom f))", "show \"set (monitor_finfun_to_list ls) = Collect (($) (finfun_dom ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (monitor_finfun_to_list ls) = Collect (($) (finfun_dom ls))", "unfolding monitor_finfun_to_list_addr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (SOME xs. set xs = Collect (($) (finfun_dom ls))) =\n    Collect (($) (finfun_dom ls))", "using finite_list[OF finite_finfun_dom, where ?f.1 = \"ls\"]"], ["proof (prove)\nusing this:\n  \\<exists>xs. set xs = {x. finfun_dom ls $ x}\n\ngoal (1 subgoal):\n 1. set (SOME xs. set xs = Collect (($) (finfun_dom ls))) =\n    Collect (($) (finfun_dom ls))", "by(rule someI_ex)"], ["proof (state)\nthis:\n  set (monitor_finfun_to_list ls) = Collect (($) (finfun_dom ls))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "primrec the_Address :: \"addr \\<Rightarrow> htype \\<times> nat\"\nwhere \"the_Address (Address hT n) = (hT, n)\""], ["", "text \\<open>\n  The JMM heap only stores which sequence numbers of a given @{typ \"htype\"} have already been allocated.\n\\<close>"], ["", "type_synonym JMM_heap = \"htype \\<Rightarrow> nat set\""], ["", "translations (type) \"JMM_heap\" <= (type) \"htype \\<Rightarrow> nat set\""], ["", "definition jmm_allocate :: \"JMM_heap \\<Rightarrow> htype \\<Rightarrow> (JMM_heap \\<times> addr) set\"\nwhere \"jmm_allocate h hT = (let hhT = h hT in (\\<lambda>n. (h(hT := insert n hhT), Address hT n)) ` (- hhT))\""], ["", "abbreviation jmm_empty :: \"JMM_heap\" where \"jmm_empty == (\\<lambda>_. {})\""], ["", "definition jmm_typeof_addr :: \"'m prog \\<Rightarrow> JMM_heap \\<Rightarrow> addr \\<rightharpoonup> htype\"\nwhere \"jmm_typeof_addr P h = (\\<lambda>hT. if is_htype P hT then Some hT else None) \\<circ> fst \\<circ> the_Address\""], ["", "definition jmm_typeof_addr' :: \"'m prog \\<Rightarrow> addr \\<rightharpoonup> htype\"\nwhere \"jmm_typeof_addr' P = (\\<lambda>hT. if is_htype P hT then Some hT else None) \\<circ> fst \\<circ> the_Address\""], ["", "lemma jmm_typeof_addr'_conv_jmm_type_addr: \"jmm_typeof_addr' P = jmm_typeof_addr P h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jmm_typeof_addr' P = jmm_typeof_addr P h", "by(simp add: jmm_typeof_addr_def jmm_typeof_addr'_def)"], ["", "lemma jmm_typeof_addr'_conv_jmm_typeof_addr: \"(\\<lambda>_. jmm_typeof_addr' P) = jmm_typeof_addr P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>_. jmm_typeof_addr' P) = jmm_typeof_addr P", "by(simp add: jmm_typeof_addr_def jmm_typeof_addr'_def fun_eq_iff)"], ["", "lemma jmm_typeof_addr_conv_jmm_typeof_addr': \"jmm_typeof_addr = (\\<lambda>P _. jmm_typeof_addr' P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jmm_typeof_addr = (\\<lambda>P _. jmm_typeof_addr' P)", "by(simp add: jmm_typeof_addr'_conv_jmm_typeof_addr)"], ["", "definition jmm_heap_read :: \"JMM_heap \\<Rightarrow> addr \\<Rightarrow> addr_loc \\<Rightarrow> addr val \\<Rightarrow> bool\"\nwhere \"jmm_heap_read h a ad v = True\""], ["", "context\n  notes [[inductive_internals]]\nbegin"], ["", "inductive jmm_heap_write :: \"JMM_heap \\<Rightarrow> addr \\<Rightarrow> addr_loc \\<Rightarrow> addr val \\<Rightarrow> JMM_heap \\<Rightarrow> bool\"\nwhere \"jmm_heap_write h a ad v h\""], ["", "end"], ["", "definition jmm_hconf :: \"JMM_heap \\<Rightarrow> bool\"\nwhere \"jmm_hconf h \\<longleftrightarrow> True\""], ["", "definition jmm_allocated :: \"JMM_heap \\<Rightarrow> addr set\"\nwhere \"jmm_allocated h = {Address CTn n|CTn n. n \\<in> h CTn}\""], ["", "definition jmm_spurious_wakeups :: \"bool\"\nwhere \"jmm_spurious_wakeups = True\""], ["", "lemmas jmm_heap_ops_defs =\n  jmm_allocate_def jmm_typeof_addr_def \n  jmm_heap_read_def jmm_heap_write_def\n  jmm_allocated_def jmm_spurious_wakeups_def"], ["", "type_synonym thread_id = \"addr\""], ["", "abbreviation (input) addr2thread_id :: \"addr \\<Rightarrow> thread_id\"\nwhere \"addr2thread_id \\<equiv> \\<lambda>x. x\""], ["", "abbreviation (input) thread_id2addr :: \"thread_id \\<Rightarrow> addr\"\nwhere \"thread_id2addr \\<equiv> \\<lambda>x. x\""], ["", "interpretation jmm: heap_base\n  addr2thread_id thread_id2addr\n  jmm_spurious_wakeups\n  jmm_empty jmm_allocate \"jmm_typeof_addr P\" jmm_heap_read jmm_heap_write\n  for P"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "abbreviation jmm_hext :: \"'m prog \\<Rightarrow> JMM_heap \\<Rightarrow> JMM_heap \\<Rightarrow> bool\" (\"_ \\<turnstile> _ \\<unlhd>jmm _\" [51,51,51] 50)\nwhere \"jmm_hext \\<equiv> jmm.hext TYPE('m)\""], ["", "abbreviation jmm_conf :: \"'m prog \\<Rightarrow> JMM_heap \\<Rightarrow> addr val \\<Rightarrow> ty \\<Rightarrow> bool\" \n  (\"_,_ \\<turnstile>jmm _ :\\<le> _\"  [51,51,51,51] 50)\nwhere \"jmm_conf P \\<equiv> jmm.conf TYPE('m) P P\""], ["", "abbreviation jmm_addr_loc_type :: \"'m prog \\<Rightarrow> JMM_heap \\<Rightarrow> addr \\<Rightarrow> addr_loc \\<Rightarrow> ty \\<Rightarrow> bool\" \n  (\"_,_ \\<turnstile>jmm _@_ : _\" [50, 50, 50, 50, 50] 51)\nwhere \"jmm_addr_loc_type P \\<equiv> jmm.addr_loc_type TYPE('m) P P\""], ["", "abbreviation jmm_confs :: \"'m prog \\<Rightarrow> JMM_heap \\<Rightarrow> addr val list \\<Rightarrow> ty list \\<Rightarrow> bool\"\n  (\"_,_ \\<turnstile>jmm _ [:\\<le>] _\"  [51,51,51,51] 50)\nwhere \"jmm_confs P \\<equiv> jmm.confs TYPE('m) P P\""], ["", "abbreviation jmm_tconf :: \"'m prog \\<Rightarrow> JMM_heap \\<Rightarrow> addr \\<Rightarrow> bool\" (\"_,_ \\<turnstile>jmm _ \\<surd>t\" [51,51,51] 50)\nwhere \"jmm_tconf P \\<equiv> jmm.tconf TYPE('m) P P\""], ["", "interpretation jmm: allocated_heap_base\n  addr2thread_id thread_id2addr\n  jmm_spurious_wakeups\n  jmm_empty jmm_allocate \"jmm_typeof_addr P\" jmm_heap_read jmm_heap_write\n  jmm_allocated\n  for P"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text \\<open>Now a variation of the JMM with a different read operation that permits to read only type-conformant values\\<close>"], ["", "abbreviation jmm_heap_read_typed :: \"'m prog \\<Rightarrow> JMM_heap \\<Rightarrow> addr \\<Rightarrow> addr_loc \\<Rightarrow> addr val \\<Rightarrow> bool\"\nwhere \"jmm_heap_read_typed P \\<equiv> jmm.heap_read_typed TYPE('m) P P\""], ["", "interpretation jmm': heap_base\n  addr2thread_id thread_id2addr\n  jmm_spurious_wakeups\n  jmm_empty jmm_allocate \"jmm_typeof_addr P\" \"jmm_heap_read_typed P\" jmm_heap_write\n  for P"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "abbreviation jmm'_hext :: \"'m prog \\<Rightarrow> JMM_heap \\<Rightarrow> JMM_heap \\<Rightarrow> bool\" (\"_ \\<turnstile> _ \\<unlhd>jmm'' _\" [51,51,51] 50)\nwhere \"jmm'_hext \\<equiv> jmm'.hext TYPE('m)\""], ["", "abbreviation jmm'_conf :: \"'m prog \\<Rightarrow> JMM_heap \\<Rightarrow> addr val \\<Rightarrow> ty \\<Rightarrow> bool\" \n  (\"_,_ \\<turnstile>jmm'' _ :\\<le> _\"  [51,51,51,51] 50)\nwhere \"jmm'_conf P \\<equiv> jmm'.conf TYPE('m) P P\""], ["", "abbreviation jmm'_addr_loc_type :: \"'m prog \\<Rightarrow> JMM_heap \\<Rightarrow> addr \\<Rightarrow> addr_loc \\<Rightarrow> ty \\<Rightarrow> bool\" \n  (\"_,_ \\<turnstile>jmm'' _@_ : _\" [50, 50, 50, 50, 50] 51)\nwhere \"jmm'_addr_loc_type P \\<equiv> jmm'.addr_loc_type TYPE('m) P P\""], ["", "abbreviation jmm'_confs :: \"'m prog \\<Rightarrow> JMM_heap \\<Rightarrow> addr val list \\<Rightarrow> ty list \\<Rightarrow> bool\"\n  (\"_,_ \\<turnstile>jmm'' _ [:\\<le>] _\"  [51,51,51,51] 50)\nwhere \"jmm'_confs P \\<equiv> jmm'.confs TYPE('m) P P\""], ["", "abbreviation jmm'_tconf :: \"'m prog \\<Rightarrow> JMM_heap \\<Rightarrow> addr \\<Rightarrow> bool\" (\"_,_ \\<turnstile>jmm'' _ \\<surd>t\" [51,51,51] 50)\nwhere \"jmm'_tconf P \\<equiv> jmm'.tconf TYPE('m) P P\""], ["", "subsection \\<open>Heap locale interpretations\\<close>"], ["", "subsection \\<open>Locale \\<open>heap\\<close>\\<close>"], ["", "lemma jmm_heap: \"heap addr2thread_id thread_id2addr jmm_allocate (jmm_typeof_addr P) jmm_heap_write P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap (\\<lambda>x. x) (\\<lambda>x. x) jmm_allocate (jmm_typeof_addr P)\n     jmm_heap_write P", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>jmm_typeof_addr P h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h' a h hT.\n       \\<lbrakk>(h', a) \\<in> jmm_allocate h hT; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> jmm_typeof_addr P h' a = \\<lfloor>hT\\<rfloor>\n 3. \\<And>h' h hT a.\n       (h', a) \\<in> jmm_allocate h hT \\<Longrightarrow>\n       P \\<turnstile> h \\<unlhd>jmm' h'\n 4. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow>\n       P \\<turnstile> h \\<unlhd>jmm' h'", "fix h' a h hT"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>jmm_typeof_addr P h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h' a h hT.\n       \\<lbrakk>(h', a) \\<in> jmm_allocate h hT; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> jmm_typeof_addr P h' a = \\<lfloor>hT\\<rfloor>\n 3. \\<And>h' h hT a.\n       (h', a) \\<in> jmm_allocate h hT \\<Longrightarrow>\n       P \\<turnstile> h \\<unlhd>jmm' h'\n 4. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow>\n       P \\<turnstile> h \\<unlhd>jmm' h'", "assume \"(h', a) \\<in> jmm_allocate h hT\" \"is_htype P hT\""], ["proof (state)\nthis:\n  (h', a) \\<in> jmm_allocate h hT\n  is_htype P hT\n\ngoal (4 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>jmm_typeof_addr P h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h' a h hT.\n       \\<lbrakk>(h', a) \\<in> jmm_allocate h hT; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> jmm_typeof_addr P h' a = \\<lfloor>hT\\<rfloor>\n 3. \\<And>h' h hT a.\n       (h', a) \\<in> jmm_allocate h hT \\<Longrightarrow>\n       P \\<turnstile> h \\<unlhd>jmm' h'\n 4. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow>\n       P \\<turnstile> h \\<unlhd>jmm' h'", "thus \"jmm_typeof_addr P h' a = \\<lfloor>hT\\<rfloor>\""], ["proof (prove)\nusing this:\n  (h', a) \\<in> jmm_allocate h hT\n  is_htype P hT\n\ngoal (1 subgoal):\n 1. jmm_typeof_addr P h' a = \\<lfloor>hT\\<rfloor>", "by(auto simp add: jmm_heap_ops_defs)"], ["proof (state)\nthis:\n  jmm_typeof_addr P h' a = \\<lfloor>hT\\<rfloor>\n\ngoal (3 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>jmm_typeof_addr P h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h' h hT a.\n       (h', a) \\<in> jmm_allocate h hT \\<Longrightarrow>\n       P \\<turnstile> h \\<unlhd>jmm' h'\n 3. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow>\n       P \\<turnstile> h \\<unlhd>jmm' h'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>jmm_typeof_addr P h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h' h hT a.\n       (h', a) \\<in> jmm_allocate h hT \\<Longrightarrow>\n       P \\<turnstile> h \\<unlhd>jmm' h'\n 3. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow>\n       P \\<turnstile> h \\<unlhd>jmm' h'", "fix h hT h' a"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>jmm_typeof_addr P h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h' h hT a.\n       (h', a) \\<in> jmm_allocate h hT \\<Longrightarrow>\n       P \\<turnstile> h \\<unlhd>jmm' h'\n 3. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow>\n       P \\<turnstile> h \\<unlhd>jmm' h'", "assume \"(h', a) \\<in> jmm_allocate h hT\""], ["proof (state)\nthis:\n  (h', a) \\<in> jmm_allocate h hT\n\ngoal (3 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>jmm_typeof_addr P h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h' h hT a.\n       (h', a) \\<in> jmm_allocate h hT \\<Longrightarrow>\n       P \\<turnstile> h \\<unlhd>jmm' h'\n 3. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow>\n       P \\<turnstile> h \\<unlhd>jmm' h'", "thus \"P \\<turnstile> h \\<unlhd>jmm h'\""], ["proof (prove)\nusing this:\n  (h', a) \\<in> jmm_allocate h hT\n\ngoal (1 subgoal):\n 1. P \\<turnstile> h \\<unlhd>jmm' h'", "by(auto simp add: jmm_heap_ops_defs intro: jmm.hextI)"], ["proof (state)\nthis:\n  P \\<turnstile> h \\<unlhd>jmm' h'\n\ngoal (2 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>jmm_typeof_addr P h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow>\n       P \\<turnstile> h \\<unlhd>jmm' h'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>jmm_typeof_addr P h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow>\n       P \\<turnstile> h \\<unlhd>jmm' h'", "fix h a al v h'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>jmm_typeof_addr P h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow>\n       P \\<turnstile> h \\<unlhd>jmm' h'", "assume \"jmm_heap_write h a al v h'\""], ["proof (state)\nthis:\n  jmm_heap_write h a al v h'\n\ngoal (2 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>jmm_typeof_addr P h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow>\n       P \\<turnstile> h \\<unlhd>jmm' h'", "thus \"P \\<turnstile> h \\<unlhd>jmm h'\""], ["proof (prove)\nusing this:\n  jmm_heap_write h a al v h'\n\ngoal (1 subgoal):\n 1. P \\<turnstile> h \\<unlhd>jmm' h'", "by cases auto"], ["proof (state)\nthis:\n  P \\<turnstile> h \\<unlhd>jmm' h'\n\ngoal (1 subgoal):\n 1. \\<And>h a C.\n       \\<lbrakk>jmm_typeof_addr P h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a", "qed simp"], ["", "interpretation jmm: heap\n  addr2thread_id thread_id2addr\n  jmm_spurious_wakeups\n  jmm_empty jmm_allocate \"jmm_typeof_addr P\" jmm_heap_read jmm_heap_write\n  P\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap (\\<lambda>x. x) (\\<lambda>x. x) jmm_allocate (jmm_typeof_addr P)\n     jmm_heap_write P", "by(rule jmm_heap)"], ["", "declare jmm.typeof_addr_thread_id2_addr_addr2thread_id [simp del]"], ["", "lemmas jmm'_heap = jmm_heap"], ["", "interpretation jmm': heap\n  addr2thread_id thread_id2addr\n  jmm_spurious_wakeups\n  jmm_empty jmm_allocate \"jmm_typeof_addr P\" \"jmm_heap_read_typed P\" jmm_heap_write\n  P\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap (\\<lambda>x. x) (\\<lambda>x. x) jmm_allocate (jmm_typeof_addr P)\n     jmm_heap_write P", "by(rule jmm'_heap)"], ["", "declare jmm'.typeof_addr_thread_id2_addr_addr2thread_id [simp del]"], ["", "lemma jmm_heap_read_typed_default_val:\n  \"heap_base.heap_read_typed typeof_addr jmm_heap_read P h a al\n   (default_val (THE T. heap_base.addr_loc_type typeof_addr P h a al T))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_base.heap_read_typed typeof_addr jmm_heap_read P h a al\n     (default_val (THE T. heap_base.addr_loc_type typeof_addr P h a al T))", "by(rule heap_base.heap_read_typedI)(simp_all add: heap_base.THE_addr_loc_type jmm_heap_read_def heap_base.defval_conf)"], ["", "lemma jmm_allocate_Eps:\n  \"(SOME ha. ha \\<in> jmm_allocate h hT) = (h', a')\n  \\<Longrightarrow> jmm_allocate h hT \\<noteq> {} \\<longrightarrow> (h', a') \\<in> jmm_allocate h hT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME ha. ha \\<in> jmm_allocate h hT) = (h', a') \\<Longrightarrow>\n    jmm_allocate h hT \\<noteq> {} \\<longrightarrow>\n    (h', a') \\<in> jmm_allocate h hT", "by(auto dest: jmm.allocate_Eps)"], ["", "lemma jmm_allocate_eq_empty: \"jmm_allocate h hT = {} \\<longleftrightarrow> h hT = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (jmm_allocate h hT = {}) = (h hT = UNIV)", "by(auto simp add: jmm_allocate_def)"], ["", "lemma jmm_allocate_otherD:\n  \"(h', a) \\<in> jmm_allocate h hT \\<Longrightarrow> \\<forall>hT'. hT' \\<noteq> hT \\<longrightarrow> h' hT' = h hT'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h', a) \\<in> jmm_allocate h hT \\<Longrightarrow>\n    \\<forall>hT'. hT' \\<noteq> hT \\<longrightarrow> h' hT' = h hT'", "by(auto simp add: jmm_allocate_def)"], ["", "lemma jmm_start_heap_ok: \"jmm.start_heap_ok\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jmm'.start_heap_ok", "apply(simp add: jmm.start_heap_ok_def jmm.start_heap_data_def initialization_list_def sys_xcpts_list_def jmm.create_initial_object_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. jmm_allocate jmm_empty (Class_type Thread) \\<noteq> {} \\<and>\n    (jmm_allocate jmm_empty (Class_type Thread) \\<noteq>\n     {} \\<longrightarrow>\n     snd (snd (jmm'.create_initial_object\n                (jmm'.create_initial_object\n                  (jmm'.create_initial_object\n                    (jmm'.create_initial_object\n                      (jmm'.create_initial_object\n                        (jmm'.create_initial_object\n                          (jmm'.create_initial_object\n                            (jmm'.create_initial_object\n                              (jmm'.create_initial_object\n                                (jmm'.create_initial_object\n                                  (case SOME ha.\n     ha \\<in> jmm_allocate jmm_empty (Class_type Thread) of\n                                   (h', a'') \\<Rightarrow>\n                                     (h', [a''], True))\n                                  NullPointer)\n                                ClassCast)\n                              OutOfMemory)\n                            ArrayIndexOutOfBounds)\n                          ArrayStore)\n                        NegativeArraySize)\n                      ArithmeticException)\n                    IllegalMonitorState)\n                  IllegalThreadState)\n                InterruptedException)))", "apply(split prod.split, clarify, clarsimp simp add: jmm.create_initial_object_simps jmm_allocate_eq_empty Thread_neq_sys_xcpts sys_xcpts_neqs dest!: jmm_allocate_Eps jmm_allocate_otherD)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Locale \\<open>heap_conf\\<close>\\<close>"], ["", "interpretation jmm: heap_conf_base\n  addr2thread_id thread_id2addr\n  jmm_spurious_wakeups\n  jmm_empty jmm_allocate \"jmm_typeof_addr P\" jmm_heap_read jmm_heap_write jmm_hconf\n  P\n  for P"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "abbreviation (input) jmm'_hconf :: \"JMM_heap \\<Rightarrow> bool\"\nwhere \"jmm'_hconf == jmm_hconf\""], ["", "interpretation jmm': heap_conf_base\n  addr2thread_id thread_id2addr\n  jmm_spurious_wakeups\n  jmm_empty jmm_allocate \"jmm_typeof_addr P\" \"jmm_heap_read_typed P\" jmm_heap_write jmm'_hconf\n  P\n  for P"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "abbreviation jmm_heap_read_typeable :: \"'m prog \\<Rightarrow> bool\"\nwhere \"jmm_heap_read_typeable P \\<equiv> jmm.heap_read_typeable TYPE('m) P jmm_hconf P\""], ["", "abbreviation jmm'_heap_read_typeable :: \"'m prog \\<Rightarrow> bool\"\nwhere \"jmm'_heap_read_typeable P \\<equiv> jmm'.heap_read_typeable TYPE('m) P jmm_hconf P\""], ["", "lemma jmm_heap_read_typeable: \"jmm_heap_read_typeable P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jmm_heap_read_typeable P", "by(rule jmm.heap_read_typeableI)(simp add: jmm_heap_read_def)"], ["", "lemma jmm'_heap_read_typeable: \"jmm'_heap_read_typeable P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jmm'_heap_read_typeable P", "by(rule jmm'.heap_read_typeableI)(auto simp add: jmm_heap_read_def jmm.heap_read_typed_def dest: jmm'.addr_loc_type_fun)"], ["", "lemma jmm_heap_conf:\n  \"heap_conf addr2thread_id thread_id2addr jmm_empty jmm_allocate (jmm_typeof_addr P) jmm_heap_write jmm_hconf P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_conf (\\<lambda>x. x) (\\<lambda>x. x) jmm_empty jmm_allocate\n     (jmm_typeof_addr P) jmm_heap_write jmm_hconf P", "by(unfold_locales)(simp_all add: jmm_hconf_def jmm_heap_ops_defs split: if_split_asm)"], ["", "interpretation jmm: heap_conf\n  addr2thread_id thread_id2addr\n  jmm_spurious_wakeups\n  jmm_empty jmm_allocate \"jmm_typeof_addr P\" jmm_heap_read jmm_heap_write jmm_hconf\n  P\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_conf (\\<lambda>x. x) (\\<lambda>x. x) jmm_empty jmm_allocate\n     (jmm_typeof_addr P) jmm_heap_write jmm_hconf P", "by(rule jmm_heap_conf)"], ["", "lemmas jmm'_heap_conf = jmm_heap_conf"], ["", "interpretation jmm': heap_conf\n  addr2thread_id thread_id2addr\n  jmm_spurious_wakeups\n  jmm_empty jmm_allocate \"jmm_typeof_addr P\" \"jmm_heap_read_typed P\" jmm_heap_write jmm'_hconf\n  P\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_conf (\\<lambda>x. x) (\\<lambda>x. x) jmm_empty jmm_allocate\n     (jmm_typeof_addr P) jmm_heap_write jmm_hconf P", "by(rule jmm'_heap_conf)"], ["", "subsection \\<open>Locale \\<open>heap_progress\\<close>\\<close>"], ["", "lemma jmm_heap_progress:\n  \"heap_progress addr2thread_id thread_id2addr jmm_empty jmm_allocate (jmm_typeof_addr P) jmm_heap_read jmm_heap_write jmm_hconf P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_progress (\\<lambda>x. x) (\\<lambda>x. x) jmm_empty jmm_allocate\n     (jmm_typeof_addr P) jmm_heap_read jmm_heap_write jmm_hconf P", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h a al T.\n       \\<lbrakk>jmm_hconf h; P,h \\<turnstile>jmm' a@al : T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            jmm_heap_read h a al v \\<and>\n                            P,h \\<turnstile>jmm' v :\\<le> T\n 2. \\<And>h a al T v.\n       \\<lbrakk>jmm_hconf h; P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. jmm_heap_write h a al v h'", "fix h a al T"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h a al T.\n       \\<lbrakk>jmm_hconf h; P,h \\<turnstile>jmm' a@al : T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            jmm_heap_read h a al v \\<and>\n                            P,h \\<turnstile>jmm' v :\\<le> T\n 2. \\<And>h a al T v.\n       \\<lbrakk>jmm_hconf h; P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. jmm_heap_write h a al v h'", "assume \"jmm_hconf h\"\n    and al: \"P,h \\<turnstile>jmm a@al : T\""], ["proof (state)\nthis:\n  jmm_hconf h\n  P,h \\<turnstile>jmm' a@al : T\n\ngoal (2 subgoals):\n 1. \\<And>h a al T.\n       \\<lbrakk>jmm_hconf h; P,h \\<turnstile>jmm' a@al : T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            jmm_heap_read h a al v \\<and>\n                            P,h \\<turnstile>jmm' v :\\<le> T\n 2. \\<And>h a al T v.\n       \\<lbrakk>jmm_hconf h; P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. jmm_heap_write h a al v h'", "show \"\\<exists>v. jmm_heap_read h a al v \\<and> P,h \\<turnstile>jmm v :\\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       jmm_heap_read h a al v \\<and> P,h \\<turnstile>jmm' v :\\<le> T", "using jmm.defval_conf[of P P h T]"], ["proof (prove)\nusing this:\n  P,h \\<turnstile>jmm' default_val T :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       jmm_heap_read h a al v \\<and> P,h \\<turnstile>jmm' v :\\<le> T", "unfolding jmm_heap_ops_defs"], ["proof (prove)\nusing this:\n  heap_base.conf\n   (\\<lambda>h.\n       (\\<lambda>hT.\n           if is_htype P hT then \\<lfloor>hT\\<rfloor> else None) \\<circ>\n       fst \\<circ>\n       the_Address)\n   P h (default_val T) T\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       True \\<and>\n       heap_base.conf\n        (\\<lambda>h.\n            (\\<lambda>hT.\n                if is_htype P hT then \\<lfloor>hT\\<rfloor>\n                else None) \\<circ>\n            fst \\<circ>\n            the_Address)\n        P h v T", "by blast"], ["proof (state)\nthis:\n  \\<exists>v. jmm_heap_read h a al v \\<and> P,h \\<turnstile>jmm' v :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>h a al T v.\n       \\<lbrakk>jmm_hconf h; P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. jmm_heap_write h a al v h'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h a al T v.\n       \\<lbrakk>jmm_hconf h; P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. jmm_heap_write h a al v h'", "fix h a al T v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h a al T v.\n       \\<lbrakk>jmm_hconf h; P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. jmm_heap_write h a al v h'", "assume \"P,h \\<turnstile>jmm a@al : T\""], ["proof (state)\nthis:\n  P,h \\<turnstile>jmm' a@al : T\n\ngoal (1 subgoal):\n 1. \\<And>h a al T v.\n       \\<lbrakk>jmm_hconf h; P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. jmm_heap_write h a al v h'", "show \"\\<exists>h'. jmm_heap_write h a al v h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>h'. jmm_heap_write h a al v h'", "by(auto intro: jmm_heap_write.intros)"], ["proof (state)\nthis:\n  \\<exists>h'. jmm_heap_write h a al v h'\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation jmm: heap_progress\n  addr2thread_id thread_id2addr\n  jmm_spurious_wakeups\n  jmm_empty jmm_allocate \"jmm_typeof_addr P\" jmm_heap_read jmm_heap_write jmm_hconf\n  P\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_progress (\\<lambda>x. x) (\\<lambda>x. x) jmm_empty jmm_allocate\n     (jmm_typeof_addr P) jmm_heap_read jmm_heap_write jmm_hconf P", "by(rule jmm_heap_progress)"], ["", "lemma jmm'_heap_progress:\n  \"heap_progress addr2thread_id thread_id2addr jmm_empty jmm_allocate (jmm_typeof_addr P) (jmm_heap_read_typed P) jmm_heap_write jmm'_hconf P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_progress (\\<lambda>x. x) (\\<lambda>x. x) jmm_empty jmm_allocate\n     (jmm_typeof_addr P) (jmm_heap_read_typed P) jmm_heap_write jmm_hconf P", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h a al T.\n       \\<lbrakk>jmm_hconf h; P,h \\<turnstile>jmm' a@al : T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            jmm_heap_read_typed P h a al v \\<and>\n                            P,h \\<turnstile>jmm' v :\\<le> T\n 2. \\<And>h a al T v.\n       \\<lbrakk>jmm_hconf h; P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. jmm_heap_write h a al v h'", "fix h a al T"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h a al T.\n       \\<lbrakk>jmm_hconf h; P,h \\<turnstile>jmm' a@al : T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            jmm_heap_read_typed P h a al v \\<and>\n                            P,h \\<turnstile>jmm' v :\\<le> T\n 2. \\<And>h a al T v.\n       \\<lbrakk>jmm_hconf h; P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. jmm_heap_write h a al v h'", "assume \"jmm'_hconf h\"\n    and al: \"P,h \\<turnstile>jmm' a@al : T\""], ["proof (state)\nthis:\n  jmm_hconf h\n  P,h \\<turnstile>jmm' a@al : T\n\ngoal (2 subgoals):\n 1. \\<And>h a al T.\n       \\<lbrakk>jmm_hconf h; P,h \\<turnstile>jmm' a@al : T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            jmm_heap_read_typed P h a al v \\<and>\n                            P,h \\<turnstile>jmm' v :\\<le> T\n 2. \\<And>h a al T v.\n       \\<lbrakk>jmm_hconf h; P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. jmm_heap_write h a al v h'", "thus \"\\<exists>v. jmm_heap_read_typed P h a al v \\<and> P,h \\<turnstile>jmm' v :\\<le> T\""], ["proof (prove)\nusing this:\n  jmm_hconf h\n  P,h \\<turnstile>jmm' a@al : T\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       jmm_heap_read_typed P h a al v \\<and> P,h \\<turnstile>jmm' v :\\<le> T", "unfolding jmm_heap_read_def jmm.heap_read_typed_def"], ["proof (prove)\nusing this:\n  jmm_hconf h\n  P,h \\<turnstile>jmm' a@al : T\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       (True \\<and>\n        (\\<forall>T.\n            P,h \\<turnstile>jmm' a@al : T \\<longrightarrow>\n            P,h \\<turnstile>jmm' v :\\<le> T)) \\<and>\n       P,h \\<turnstile>jmm' v :\\<le> T", "by(blast dest: jmm'.addr_loc_type_fun intro: jmm'.defval_conf)+"], ["proof (state)\nthis:\n  \\<exists>v.\n     jmm_heap_read_typed P h a al v \\<and> P,h \\<turnstile>jmm' v :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>h a al T v.\n       \\<lbrakk>jmm_hconf h; P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. jmm_heap_write h a al v h'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h a al T v.\n       \\<lbrakk>jmm_hconf h; P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. jmm_heap_write h a al v h'", "fix h a al T v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h a al T v.\n       \\<lbrakk>jmm_hconf h; P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. jmm_heap_write h a al v h'", "assume \"P,h \\<turnstile>jmm' a@al : T\"\n    and \"P,h \\<turnstile>jmm' v :\\<le> T\""], ["proof (state)\nthis:\n  P,h \\<turnstile>jmm' a@al : T\n  P,h \\<turnstile>jmm' v :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>h a al T v.\n       \\<lbrakk>jmm_hconf h; P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. jmm_heap_write h a al v h'", "thus \"\\<exists>h'. jmm_heap_write h a al v h'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile>jmm' a@al : T\n  P,h \\<turnstile>jmm' v :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<exists>h'. jmm_heap_write h a al v h'", "by(auto intro: jmm_heap_write.intros)"], ["proof (state)\nthis:\n  \\<exists>h'. jmm_heap_write h a al v h'\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation jmm': heap_progress\n  addr2thread_id thread_id2addr\n  jmm_spurious_wakeups\n  jmm_empty jmm_allocate \"jmm_typeof_addr P\" \"jmm_heap_read_typed P\" jmm_heap_write jmm'_hconf\n  P\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_progress (\\<lambda>x. x) (\\<lambda>x. x) jmm_empty jmm_allocate\n     (jmm_typeof_addr P) (jmm_heap_read_typed P) jmm_heap_write jmm_hconf P", "by(rule jmm'_heap_progress)"], ["", "subsection \\<open>Locale \\<open>heap_conf_read\\<close>\\<close>"], ["", "lemma jmm'_heap_conf_read:\n  \"heap_conf_read addr2thread_id thread_id2addr jmm_empty jmm_allocate (jmm_typeof_addr P) (jmm_heap_read_typed P) jmm_heap_write jmm'_hconf P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_conf_read (\\<lambda>x. x) (\\<lambda>x. x) jmm_empty jmm_allocate\n     (jmm_typeof_addr P) (jmm_heap_read_typed P) jmm_heap_write jmm_hconf P", "by(rule jmm.heap_conf_read_heap_read_typed)"], ["", "interpretation jmm': heap_conf_read\n  addr2thread_id thread_id2addr\n  jmm_spurious_wakeups\n  jmm_empty jmm_allocate \"jmm_typeof_addr P\" \"jmm_heap_read_typed P\" jmm_heap_write jmm'_hconf\n  P\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_conf_read (\\<lambda>x. x) (\\<lambda>x. x) jmm_empty jmm_allocate\n     (jmm_typeof_addr P) (jmm_heap_read_typed P) jmm_heap_write jmm_hconf P", "by(rule jmm'_heap_conf_read)"], ["", "interpretation jmm': heap_typesafe\n  addr2thread_id thread_id2addr\n  jmm_spurious_wakeups\n  jmm_empty jmm_allocate \"jmm_typeof_addr P\" \"jmm_heap_read_typed P\" jmm_heap_write jmm'_hconf\n  P\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_typesafe (\\<lambda>x. x) (\\<lambda>x. x) jmm_empty jmm_allocate\n     (jmm_typeof_addr P) (jmm_heap_read_typed P) jmm_heap_write jmm_hconf P", ".."], ["", "subsection \\<open>Locale \\<open>allocated_heap\\<close>\\<close>"], ["", "lemma jmm_allocated_heap:\n  \"allocated_heap addr2thread_id thread_id2addr jmm_empty jmm_allocate (jmm_typeof_addr P) jmm_heap_write jmm_allocated P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. allocated_heap (\\<lambda>x. x) (\\<lambda>x. x) jmm_empty jmm_allocate\n     (jmm_typeof_addr P) jmm_heap_write jmm_allocated P", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. jmm_allocated jmm_empty = {}\n 2. \\<And>h' a h hT.\n       (h', a) \\<in> jmm_allocate h hT \\<Longrightarrow>\n       jmm_allocated h' = insert a (jmm_allocated h) \\<and>\n       a \\<notin> jmm_allocated h\n 3. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow>\n       jmm_allocated h' = jmm_allocated h", "show \"jmm_allocated jmm_empty = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jmm_allocated jmm_empty = {}", "by(simp add: jmm_allocated_def)"], ["proof (state)\nthis:\n  jmm_allocated jmm_empty = {}\n\ngoal (2 subgoals):\n 1. \\<And>h' a h hT.\n       (h', a) \\<in> jmm_allocate h hT \\<Longrightarrow>\n       jmm_allocated h' = insert a (jmm_allocated h) \\<and>\n       a \\<notin> jmm_allocated h\n 2. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow>\n       jmm_allocated h' = jmm_allocated h", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h' a h hT.\n       (h', a) \\<in> jmm_allocate h hT \\<Longrightarrow>\n       jmm_allocated h' = insert a (jmm_allocated h) \\<and>\n       a \\<notin> jmm_allocated h\n 2. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow>\n       jmm_allocated h' = jmm_allocated h", "fix h' a h hT"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h' a h hT.\n       (h', a) \\<in> jmm_allocate h hT \\<Longrightarrow>\n       jmm_allocated h' = insert a (jmm_allocated h) \\<and>\n       a \\<notin> jmm_allocated h\n 2. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow>\n       jmm_allocated h' = jmm_allocated h", "assume \"(h', a) \\<in> jmm_allocate h hT\""], ["proof (state)\nthis:\n  (h', a) \\<in> jmm_allocate h hT\n\ngoal (2 subgoals):\n 1. \\<And>h' a h hT.\n       (h', a) \\<in> jmm_allocate h hT \\<Longrightarrow>\n       jmm_allocated h' = insert a (jmm_allocated h) \\<and>\n       a \\<notin> jmm_allocated h\n 2. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow>\n       jmm_allocated h' = jmm_allocated h", "thus \"jmm_allocated h' = insert a (jmm_allocated h) \\<and> a \\<notin> jmm_allocated h\""], ["proof (prove)\nusing this:\n  (h', a) \\<in> jmm_allocate h hT\n\ngoal (1 subgoal):\n 1. jmm_allocated h' = insert a (jmm_allocated h) \\<and>\n    a \\<notin> jmm_allocated h", "by(auto simp add: jmm_heap_ops_defs split: if_split_asm)"], ["proof (state)\nthis:\n  jmm_allocated h' = insert a (jmm_allocated h) \\<and>\n  a \\<notin> jmm_allocated h\n\ngoal (1 subgoal):\n 1. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow>\n       jmm_allocated h' = jmm_allocated h", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow>\n       jmm_allocated h' = jmm_allocated h", "fix h a al v h'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow>\n       jmm_allocated h' = jmm_allocated h", "assume \"jmm_heap_write h a al v h'\""], ["proof (state)\nthis:\n  jmm_heap_write h a al v h'\n\ngoal (1 subgoal):\n 1. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow>\n       jmm_allocated h' = jmm_allocated h", "thus \"jmm_allocated h' = jmm_allocated h\""], ["proof (prove)\nusing this:\n  jmm_heap_write h a al v h'\n\ngoal (1 subgoal):\n 1. jmm_allocated h' = jmm_allocated h", "by cases simp"], ["proof (state)\nthis:\n  jmm_allocated h' = jmm_allocated h\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation jmm: allocated_heap\n  addr2thread_id thread_id2addr\n  jmm_spurious_wakeups\n  jmm_empty jmm_allocate \"jmm_typeof_addr P\" jmm_heap_read jmm_heap_write\n  jmm_allocated\n  P\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. allocated_heap (\\<lambda>x. x) (\\<lambda>x. x) jmm_empty jmm_allocate\n     (jmm_typeof_addr P) jmm_heap_write jmm_allocated P", "by(rule jmm_allocated_heap)"], ["", "lemmas jmm'_allocated_heap = jmm_allocated_heap"], ["", "interpretation jmm': allocated_heap\n  addr2thread_id thread_id2addr\n  jmm_spurious_wakeups\n  jmm_empty jmm_allocate \"jmm_typeof_addr P\" \"jmm_heap_read_typed P\" jmm_heap_write\n  jmm_allocated\n  P\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. allocated_heap (\\<lambda>x. x) (\\<lambda>x. x) jmm_empty jmm_allocate\n     (jmm_typeof_addr P) jmm_heap_write jmm_allocated P", "by(rule jmm'_allocated_heap)"], ["", "subsection \\<open>Syntax translations\\<close>"], ["", "notation jmm'.external_WT' (\"_,_ \\<turnstile>jmm'' (_\\<bullet>_'(_')) : _\" [50,0,0,0,50] 60)"], ["", "abbreviation jmm'_red_external :: \n  \"'m prog \\<Rightarrow> thread_id \\<Rightarrow> JMM_heap \\<Rightarrow> addr \\<Rightarrow> mname \\<Rightarrow> addr val list\n  \\<Rightarrow> (addr, thread_id, JMM_heap) external_thread_action \n  \\<Rightarrow> addr extCallRet \\<Rightarrow> JMM_heap \\<Rightarrow> bool\"\nwhere \"jmm'_red_external P \\<equiv> jmm'.red_external (TYPE('m)) P P\""], ["", "abbreviation jmm'_red_external_syntax :: \n  \"'m prog \\<Rightarrow> thread_id \\<Rightarrow> addr \\<Rightarrow> mname \\<Rightarrow> addr val list \\<Rightarrow> JMM_heap\n  \\<Rightarrow> (addr, thread_id, JMM_heap) external_thread_action \n  \\<Rightarrow> addr extCallRet \\<Rightarrow> JMM_heap \\<Rightarrow> bool\"\n  (\"_,_ \\<turnstile>jmm'' (\\<langle>(_\\<bullet>_'(_')),/_\\<rangle>) -_\\<rightarrow>ext (\\<langle>(_),/(_)\\<rangle>)\" [50, 0, 0, 0, 0, 0, 0, 0, 0] 51)\nwhere\n  \"P,t \\<turnstile>jmm' \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle> \\<equiv> jmm'_red_external P t h a M vs ta va h'\""], ["", "abbreviation jmm'_red_external_aggr :: \n  \"'m prog \\<Rightarrow> thread_id \\<Rightarrow> addr \\<Rightarrow> mname \\<Rightarrow> addr val list \\<Rightarrow> JMM_heap \n    \\<Rightarrow> ((addr, thread_id, JMM_heap) external_thread_action \\<times> addr extCallRet \\<times> JMM_heap) set\"\nwhere \"jmm'_red_external_aggr P \\<equiv> jmm'.red_external_aggr TYPE('m) P P\""], ["", "abbreviation jmm'_heap_copy_loc :: \n  \"'m prog \\<Rightarrow> addr \\<Rightarrow> addr \\<Rightarrow> addr_loc \\<Rightarrow> JMM_heap\n  \\<Rightarrow> (addr, thread_id) obs_event list \\<Rightarrow> JMM_heap \\<Rightarrow> bool\"\nwhere \"jmm'_heap_copy_loc \\<equiv> jmm'.heap_copy_loc TYPE('m)\""], ["", "abbreviation jmm'_heap_copies :: \n  \"'m prog \\<Rightarrow> addr \\<Rightarrow> addr \\<Rightarrow> addr_loc list \\<Rightarrow> JMM_heap\n  \\<Rightarrow> (addr, thread_id) obs_event list \\<Rightarrow> JMM_heap \\<Rightarrow> bool\"\nwhere \"jmm'_heap_copies \\<equiv> jmm'.heap_copies TYPE('m)\""], ["", "abbreviation jmm'_heap_clone ::\n  \"'m prog \\<Rightarrow> JMM_heap \\<Rightarrow> addr \\<Rightarrow> JMM_heap\n  \\<Rightarrow> ((addr, thread_id) obs_event list \\<times> addr) option \\<Rightarrow> bool\"\nwhere \"jmm'_heap_clone P \\<equiv> jmm'.heap_clone TYPE('m) P P\""], ["", "end"]]}