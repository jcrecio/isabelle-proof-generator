{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/BV/BVSpecTypeSafe.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemmas widen_rules [intro] = conf_widen confT_widen confs_widens confTs_widen", "lemma Invoke_handlers:\n  \"match_ex_table P C pc xt = Some (pc',d') \\<Longrightarrow> \n  \\<exists>(f,t,D,h,d) \\<in> set (relevant_entries P (Invoke n M) pc xt). \n   (case D of None \\<Rightarrow> True | Some D' \\<Rightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D') \\<and> pc \\<in> {f..<t} \\<and> pc' = h \\<and> d' = d\"", "lemma match_is_relevant:\n  assumes rv: \"\\<And>D'. P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<Longrightarrow> is_relevant_class (ins ! i) P D'\"\n  assumes match: \"match_ex_table P D pc xt = Some (pc',d')\"\n  shows \"\\<exists>(f,t,D',h,d) \\<in> set (relevant_entries P (ins ! i) pc xt). (case D' of None \\<Rightarrow> True | Some D'' \\<Rightarrow> P \\<turnstile> D \\<preceq>\\<^sup>* D'') \\<and> pc \\<in> {f..<t} \\<and> pc' = h \\<and> d' = d\"", "lemma exception_step_conform:\n  fixes \\<sigma>' :: \"('addr, 'heap) jvm_state\"\n  assumes wtp: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes correct: \"\\<Phi> \\<turnstile> t:(\\<lfloor>xcp\\<rfloor>, h, fr # frs) \\<surd>\"\n  shows \"\\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>\"", "lemma Invoke_correct: \n  fixes \\<sigma>' :: \"('addr, 'heap) jvm_state\"\n  assumes wtprog: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes meth_C: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C\"\n  assumes ins:    \"ins ! pc = Invoke M' n\"\n  assumes wti:    \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes approx: \"\\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  assumes exec: \"(tas, \\<sigma>) \\<in> exec_instr (ins!pc) P t h stk loc C M pc frs\"\n  shows \"\\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\"", "lemma Return_correct:\n  assumes wt_prog: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes meth: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C\"\n  assumes ins: \"ins ! pc = Return\"\n  assumes wt: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes correct: \"\\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  assumes s': \"(tas, \\<sigma>') \\<in> exec P t (None, h, (stk,loc,C,M,pc)#frs)\"\n  shows \"\\<Phi> \\<turnstile> t:\\<sigma>'\\<surd>\"", "lemma Load_correct:\n\"\\<lbrakk> wf_prog wt P;\n    P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C; \n    ins!pc = Load idx; \n    P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n    \\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd> ;\n    (tas, \\<sigma>') \\<in> exec P t (None, h, (stk,loc,C,M,pc)#frs) \\<rbrakk>\n\\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\"", "lemma Store_correct:\n\"\\<lbrakk> wf_prog wt P;\n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C;\n  ins!pc = Store idx;\n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M;\n  \\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>;\n  (tas, \\<sigma>') \\<in> exec P t (None, h, (stk,loc,C,M,pc)#frs) \\<rbrakk>\n\\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>'\\<surd>\"", "lemma Push_correct:\n\"\\<lbrakk> wf_prog wt P;\n    P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C; \n    ins!pc = Push v;\n    P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n    \\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>; \n    (tas, \\<sigma>') \\<in> exec P t (None, h, (stk,loc,C,M,pc)#frs) \\<rbrakk>\n\\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>'\\<surd>\"", "lemma Checkcast_correct:\n\"\\<lbrakk> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n    P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C; \n    ins!pc = Checkcast D; \n    P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n    \\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>;\n    (tas, \\<sigma>) \\<in> exec_instr (ins!pc) P t h stk loc C M pc frs \\<rbrakk> \n\\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\"", "lemma Instanceof_correct:\n\"\\<lbrakk> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n    P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C; \n    ins!pc = Instanceof Ty; \n    P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n    \\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>;\n    (tas, \\<sigma>) \\<in> exec_instr (ins!pc) P t h stk loc C M pc frs \\<rbrakk> \n\\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\"", "lemma widens_Cons [iff]:\n  \"P \\<turnstile> (T # Ts) [\\<le>] Us = (\\<exists>z zs. Us = z # zs \\<and> P \\<turnstile> T \\<le> z \\<and> P \\<turnstile> Ts [\\<le>] zs)\"", "lemma Getfield_correct:\n  assumes wf: \"wf_prog wt P\"\n  assumes mC: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C\"\n  assumes i:  \"ins!pc = Getfield F D\"\n  assumes wt: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes cf: \"\\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  assumes xc: \"(tas, \\<sigma>') \\<in> exec_instr (ins!pc) P t h stk loc C M pc frs\"\n\n  shows \"\\<Phi> \\<turnstile> t:\\<sigma>'\\<surd>\"", "lemma Putfield_correct:\n  assumes wf: \"wf_prog wt P\"\n  assumes mC: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C\"\n  assumes i:  \"ins!pc = Putfield F D\"\n  assumes wt: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes cf: \"\\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  assumes xc: \"(tas, \\<sigma>') \\<in> exec_instr (ins!pc) P t h stk loc C M pc frs\"\n  shows \"\\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\"", "lemma CAS_correct:\n  assumes wf: \"wf_prog wt P\"\n  assumes mC: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C\"\n  assumes i:  \"ins!pc = CAS F D\"\n  assumes wt: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes cf: \"\\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  assumes xc: \"(tas, \\<sigma>') \\<in> exec_instr (ins!pc) P t h stk loc C M pc frs\"\n  shows \"\\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\"", "lemma New_correct:\n  assumes wf:   \"wf_prog wt P\"\n  assumes meth: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C\"\n  assumes ins:  \"ins!pc = New X\"\n  assumes wt:   \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes conf: \"\\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  assumes no_x: \"(tas, \\<sigma>) \\<in> exec_instr (ins!pc) P t h stk loc C M pc frs\"\n  shows \"\\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\"", "lemma Goto_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C; \n  ins ! pc = Goto branch; \n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  \\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>; \n  (tas, \\<sigma>') \\<in> exec P t (None, h, (stk,loc,C,M,pc)#frs) \\<rbrakk>\n\\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\"", "lemma IfFalse_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C; \n  ins ! pc = IfFalse branch; \n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  \\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>;\n  (tas, \\<sigma>') \\<in> exec P t (None, h, (stk,loc,C,M,pc)#frs) \\<rbrakk>\n\\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>'\\<surd>\"", "lemma BinOp_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C; \n  ins ! pc = BinOpInstr bop;\n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  \\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>;\n  (tas, \\<sigma>') \\<in> exec P t (None, h, (stk,loc,C,M,pc)#frs) \\<rbrakk>\n\\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>'\\<surd>\"", "lemma Pop_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C; \n  ins ! pc = Pop;\n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  \\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>;\n  (tas, \\<sigma>') \\<in> exec P t (None, h, (stk,loc,C,M,pc)#frs) \\<rbrakk>\n\\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>'\\<surd>\"", "lemma Dup_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C; \n  ins ! pc = Dup;\n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  \\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>;\n  (tas, \\<sigma>') \\<in> exec P t (None, h, (stk,loc,C,M,pc)#frs) \\<rbrakk>\n\\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>'\\<surd>\"", "lemma Swap_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C; \n  ins ! pc = Swap;\n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  \\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>;\n  (tas, \\<sigma>') \\<in> exec P t (None, h, (stk,loc,C,M,pc)#frs) \\<rbrakk>\n\\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>'\\<surd>\"", "lemma Throw_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C; \n  ins ! pc = ThrowExc; \n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  \\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>;\n  (tas, \\<sigma>') \\<in> exec_instr (ins!pc) P t h stk loc C M pc frs \\<rbrakk> \n\\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>'\\<surd>\"", "lemma NewArray_correct:\n  assumes wf:   \"wf_prog wt P\"\n  assumes meth: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C\"\n  assumes ins:  \"ins!pc = NewArray X\"\n  assumes wt:   \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes conf: \"\\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  assumes no_x: \"(tas, \\<sigma>) \\<in> exec_instr (ins!pc) P t h stk loc C M pc frs\"\n  shows \"\\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\"", "lemma ALoad_correct:\n  assumes wf:   \"wf_prog wt P\"\n  assumes meth: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C\"\n  assumes ins:  \"ins!pc = ALoad\"\n  assumes wt:   \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes conf: \"\\<Phi> \\<turnstile> t: (None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  assumes no_x: \"(tas, \\<sigma>) \\<in> exec_instr (ins!pc) P t h stk loc C M pc frs\"\n  shows \"\\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\"", "lemma AStore_correct:\n  assumes wf:   \"wf_prog wt P\"\n  assumes meth: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C\"\n  assumes ins:  \"ins!pc = AStore\"\n  assumes wt:   \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes conf: \"\\<Phi> \\<turnstile> t: (None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  assumes no_x: \"(tas, \\<sigma>) \\<in> exec_instr (ins!pc) P t h stk loc C M pc frs\"\n  shows \"\\<Phi> \\<turnstile> t: \\<sigma> \\<surd>\"", "lemma ALength_correct:\n  assumes wf:   \"wf_prog wt P\"\n  assumes meth: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C\"\n  assumes ins:  \"ins!pc = ALength\"\n  assumes wt:   \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes conf: \"\\<Phi> \\<turnstile> t: (None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  assumes no_x: \"(tas, \\<sigma>) \\<in> exec_instr (ins!pc) P t h stk loc C M pc frs\"\n  shows \"\\<Phi> \\<turnstile> t: \\<sigma> \\<surd>\"", "lemma MEnter_correct:\n  assumes wf:   \"wf_prog wt P\"\n  assumes meth: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C\"\n  assumes ins:  \"ins!pc = MEnter\"\n  assumes wt:   \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes conf: \"\\<Phi> \\<turnstile> t: (None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  assumes no_x: \"(tas, \\<sigma>) \\<in> exec_instr (ins!pc) P t h stk loc C M pc frs\"\n  shows \"\\<Phi> \\<turnstile> t: \\<sigma> \\<surd>\"", "lemma MExit_correct:\n  assumes wf:   \"wf_prog wt P\"\n  assumes meth: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C\"\n  assumes ins:  \"ins!pc = MExit\"\n  assumes wt:   \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes conf: \"\\<Phi> \\<turnstile> t: (None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  assumes no_x: \"(tas, \\<sigma>) \\<in> exec_instr (ins!pc) P t h stk loc C M pc frs\"\n  shows \"\\<Phi> \\<turnstile> t: \\<sigma> \\<surd>\"", "theorem instr_correct:\n\"\\<lbrakk> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C;\n  (tas, \\<sigma>') \\<in> exec P t (None, h, (stk,loc,C,M,pc)#frs); \n  \\<Phi> \\<turnstile> t: (None, h, (stk,loc,C,M,pc)#frs)\\<surd> \\<rbrakk> \n\\<Longrightarrow> \\<Phi> \\<turnstile> t: \\<sigma>'\\<surd>\"", "lemma (in JVM_conf_read) BV_correct_1 [rule_format]:\n\"\\<And>\\<sigma>. \\<lbrakk> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; \\<Phi> \\<turnstile> t: \\<sigma>\\<surd>\\<rbrakk> \\<Longrightarrow> P,t \\<turnstile> \\<sigma> -tas-jvm\\<rightarrow> \\<sigma>' \\<longrightarrow> \\<Phi> \\<turnstile> t: \\<sigma>'\\<surd>\"", "theorem (in JVM_progress) progress:\n  assumes wt: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  and cs: \"\\<Phi> \\<turnstile> t: (xcp, h, f # frs)\\<surd>\"\n  shows \"\\<exists>ta \\<sigma>'. P,t \\<turnstile> (xcp, h, f # frs) -ta-jvm\\<rightarrow> \\<sigma>'\"", "lemma (in JVM_heap_conf) BV_correct_initial:\n  shows \"\\<lbrakk> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; start_heap_ok; P \\<turnstile> C sees M:Ts\\<rightarrow>T = \\<lfloor>m\\<rfloor> in D; P,start_heap \\<turnstile> vs [:\\<le>] Ts \\<rbrakk>\n  \\<Longrightarrow> \\<Phi> \\<turnstile> start_tid:JVM_start_state' P C M vs \\<surd>\""], "translations": [["", "lemmas widen_rules [intro] = conf_widen confT_widen confs_widens confTs_widen"], ["", "end"], ["", "subsection \\<open>Exception Handling\\<close>"], ["", "text \\<open>\n  For the \\<open>Invoke\\<close> instruction the BV has checked all handlers\n  that guard the current \\<open>pc\\<close>.\n\\<close>"], ["", "lemma Invoke_handlers:\n  \"match_ex_table P C pc xt = Some (pc',d') \\<Longrightarrow> \n  \\<exists>(f,t,D,h,d) \\<in> set (relevant_entries P (Invoke n M) pc xt). \n   (case D of None \\<Rightarrow> True | Some D' \\<Rightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D') \\<and> pc \\<in> {f..<t} \\<and> pc' = h \\<and> d' = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_ex_table P C pc xt = \\<lfloor>(pc', d')\\<rfloor> \\<Longrightarrow>\n    \\<exists>(f, t, D, h, d)\n             \\<in>set (relevant_entries P (Invoke n M) pc xt).\n       (case D of None \\<Rightarrow> True\n        | \\<lfloor>D'\\<rfloor> \\<Rightarrow>\n            P \\<turnstile> C \\<preceq>\\<^sup>* D') \\<and>\n       pc \\<in> {f..<t} \\<and> pc' = h \\<and> d' = d", "by (induct xt) (auto simp add: relevant_entries_def matches_ex_entry_def \n                                 is_relevant_entry_def split: if_split_asm)"], ["", "lemma match_is_relevant:\n  assumes rv: \"\\<And>D'. P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<Longrightarrow> is_relevant_class (ins ! i) P D'\"\n  assumes match: \"match_ex_table P D pc xt = Some (pc',d')\"\n  shows \"\\<exists>(f,t,D',h,d) \\<in> set (relevant_entries P (ins ! i) pc xt). (case D' of None \\<Rightarrow> True | Some D'' \\<Rightarrow> P \\<turnstile> D \\<preceq>\\<^sup>* D'') \\<and> pc \\<in> {f..<t} \\<and> pc' = h \\<and> d' = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>(f, t, D', h, d)\\<in>set (relevant_entries P (ins ! i) pc xt).\n       (case D' of None \\<Rightarrow> True\n        | \\<lfloor>D''\\<rfloor> \\<Rightarrow>\n            P \\<turnstile> D \\<preceq>\\<^sup>* D'') \\<and>\n       pc \\<in> {f..<t} \\<and> pc' = h \\<and> d' = d", "using rv match"], ["proof (prove)\nusing this:\n  P \\<turnstile> D \\<preceq>\\<^sup>* ?D' \\<Longrightarrow>\n  is_relevant_class (ins ! i) P ?D'\n  match_ex_table P D pc xt = \\<lfloor>(pc', d')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>(f, t, D', h, d)\\<in>set (relevant_entries P (ins ! i) pc xt).\n       (case D' of None \\<Rightarrow> True\n        | \\<lfloor>D''\\<rfloor> \\<Rightarrow>\n            P \\<turnstile> D \\<preceq>\\<^sup>* D'') \\<and>\n       pc \\<in> {f..<t} \\<and> pc' = h \\<and> d' = d", "by(fastforce simp add: relevant_entries_def is_relevant_entry_def matches_ex_entry_def dest: match_ex_table_SomeD)"], ["", "context JVM_heap_conf_base begin"], ["", "lemma exception_step_conform:\n  fixes \\<sigma>' :: \"('addr, 'heap) jvm_state\"\n  assumes wtp: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes correct: \"\\<Phi> \\<turnstile> t:(\\<lfloor>xcp\\<rfloor>, h, fr # frs) \\<surd>\"\n  shows \"\\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>", "obtain stk loc C M pc where fr: \"fr = (stk, loc, C, M, pc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>stk loc C M pc.\n        fr = (stk, loc, C, M, pc) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases fr)"], ["proof (state)\nthis:\n  fr = (stk, loc, C, M, pc)\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>", "from correct"], ["proof (chain)\npicking this:\n  \\<Phi> \\<turnstile> t:(\\<lfloor>xcp\\<rfloor>, h, fr # frs) \\<surd>", "obtain Ts T mxs mxl\\<^sub>0 ins xt \n    where meth: \"P \\<turnstile> C sees M:Ts \\<rightarrow> T = \\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C\""], ["proof (prove)\nusing this:\n  \\<Phi> \\<turnstile> t:(\\<lfloor>xcp\\<rfloor>, h, fr # frs) \\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>Ts T mxs mxl\\<^sub>0 ins xt.\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins,\n                        xt)\\<rfloor> in C \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (simp add: correct_state_def fr) blast"], ["proof (state)\nthis:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>", "from correct meth fr"], ["proof (chain)\npicking this:\n  \\<Phi> \\<turnstile> t:(\\<lfloor>xcp\\<rfloor>, h, fr # frs) \\<surd>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  fr = (stk, loc, C, M, pc)", "obtain D \n    where hxcp: \"typeof_addr h xcp = \\<lfloor>Class_type D\\<rfloor>\" and DsubThrowable: \"P \\<turnstile> D \\<preceq>\\<^sup>* Throwable\"\n    and rv: \"\\<And>D'. P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<Longrightarrow> is_relevant_class (instrs_of P C M ! pc) P D'\""], ["proof (prove)\nusing this:\n  \\<Phi> \\<turnstile> t:(\\<lfloor>xcp\\<rfloor>, h, fr # frs) \\<surd>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  fr = (stk, loc, C, M, pc)\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<lbrakk>typeof_addr h xcp = \\<lfloor>Class_type D\\<rfloor>;\n         P \\<turnstile> D \\<preceq>\\<^sup>* Throwable;\n         \\<And>D'.\n            P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<Longrightarrow>\n            is_relevant_class (instrs_of P C M ! pc) P D'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp add: correct_state_def dest: sees_method_fun)"], ["proof (state)\nthis:\n  typeof_addr h xcp = \\<lfloor>Class_type D\\<rfloor>\n  P \\<turnstile> D \\<preceq>\\<^sup>* Throwable\n  P \\<turnstile> D \\<preceq>\\<^sup>* ?D'15 \\<Longrightarrow>\n  is_relevant_class (instrs_of P C M ! pc) P ?D'15\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>", "from meth"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C", "have [simp]: \"ex_table_of P C M = xt\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n\ngoal (1 subgoal):\n 1. ex_table_of P C M = xt", "by simp"], ["proof (state)\nthis:\n  ex_table_of P C M = xt\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>", "from correct"], ["proof (chain)\npicking this:\n  \\<Phi> \\<turnstile> t:(\\<lfloor>xcp\\<rfloor>, h, fr # frs) \\<surd>", "have tconf: \"P,h \\<turnstile> t \\<surd>t\""], ["proof (prove)\nusing this:\n  \\<Phi> \\<turnstile> t:(\\<lfloor>xcp\\<rfloor>, h, fr # frs) \\<surd>\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> t \\<surd>t", "by(simp add: correct_state_def)"], ["proof (state)\nthis:\n  P,h \\<turnstile> t \\<surd>t\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>", "proof(cases \"match_ex_table P D pc xt\")"], ["proof (state)\ngoal (2 subgoals):\n 1. match_ex_table P D pc xt = None \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>\n 2. \\<And>a.\n       match_ex_table P D pc xt = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>", "case None"], ["proof (state)\nthis:\n  match_ex_table P D pc xt = None\n\ngoal (2 subgoals):\n 1. match_ex_table P D pc xt = None \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>\n 2. \\<And>a.\n       match_ex_table P D pc xt = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>", "with correct fr meth hxcp"], ["proof (chain)\npicking this:\n  \\<Phi> \\<turnstile> t:(\\<lfloor>xcp\\<rfloor>, h, fr # frs) \\<surd>\n  fr = (stk, loc, C, M, pc)\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  typeof_addr h xcp = \\<lfloor>Class_type D\\<rfloor>\n  match_ex_table P D pc xt = None", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Phi> \\<turnstile> t:(\\<lfloor>xcp\\<rfloor>, h, fr # frs) \\<surd>\n  fr = (stk, loc, C, M, pc)\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  typeof_addr h xcp = \\<lfloor>Class_type D\\<rfloor>\n  match_ex_table P D pc xt = None\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>", "by(fastforce simp add: correct_state_def cname_of_def split: list.split)"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P D pc xt = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P D pc xt = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>", "case (Some pc_d)"], ["proof (state)\nthis:\n  match_ex_table P D pc xt = \\<lfloor>pc_d\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P D pc xt = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>", "then"], ["proof (chain)\npicking this:\n  match_ex_table P D pc xt = \\<lfloor>pc_d\\<rfloor>", "obtain pc' d' where pcd: \"pc_d = (pc', d')\"\n      and match: \"match_ex_table P D pc xt = Some (pc',d')\""], ["proof (prove)\nusing this:\n  match_ex_table P D pc xt = \\<lfloor>pc_d\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>pc' d'.\n        \\<lbrakk>pc_d = (pc', d');\n         match_ex_table P D pc xt = \\<lfloor>(pc', d')\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases pc_d) auto"], ["proof (state)\nthis:\n  pc_d = (pc', d')\n  match_ex_table P D pc xt = \\<lfloor>(pc', d')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P D pc xt = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>", "from match_is_relevant[OF rv match] meth"], ["proof (chain)\npicking this:\n  (\\<And>D'.\n      P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<Longrightarrow>\n      P \\<turnstile> D \\<preceq>\\<^sup>* D') \\<Longrightarrow>\n  \\<exists>(f, t, D', h, d)\n           \\<in>set (relevant_entries P (instrs_of P C M ! pc) pc xt).\n     (case D' of None \\<Rightarrow> True\n      | \\<lfloor>D''\\<rfloor> \\<Rightarrow>\n          P \\<turnstile> D \\<preceq>\\<^sup>* D'') \\<and>\n     pc \\<in> {f..<t} \\<and> pc' = h \\<and> d' = d\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C", "obtain f t D'\n      where rv: \"(f, t, D', pc', d') \\<in> set (relevant_entries P (ins ! pc) pc xt)\"\n      and DsubD': \"(case D' of None \\<Rightarrow> True | Some D'' \\<Rightarrow> P \\<turnstile> D \\<preceq>\\<^sup>* D'')\" and pc: \"pc \\<in> {f..<t}\""], ["proof (prove)\nusing this:\n  (\\<And>D'.\n      P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<Longrightarrow>\n      P \\<turnstile> D \\<preceq>\\<^sup>* D') \\<Longrightarrow>\n  \\<exists>(f, t, D', h, d)\n           \\<in>set (relevant_entries P (instrs_of P C M ! pc) pc xt).\n     (case D' of None \\<Rightarrow> True\n      | \\<lfloor>D''\\<rfloor> \\<Rightarrow>\n          P \\<turnstile> D \\<preceq>\\<^sup>* D'') \\<and>\n     pc \\<in> {f..<t} \\<and> pc' = h \\<and> d' = d\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n\ngoal (1 subgoal):\n 1. (\\<And>f t D'.\n        \\<lbrakk>(f, t, D', pc', d')\n                 \\<in> set (relevant_entries P (ins ! pc) pc xt);\n         case D' of None \\<Rightarrow> True\n         | \\<lfloor>D''\\<rfloor> \\<Rightarrow>\n             P \\<turnstile> D \\<preceq>\\<^sup>* D'';\n         pc \\<in> {f..<t}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto)"], ["proof (state)\nthis:\n  (f, t, D', pc', d') \\<in> set (relevant_entries P (ins ! pc) pc xt)\n  case D' of None \\<Rightarrow> True\n  | \\<lfloor>D''\\<rfloor> \\<Rightarrow>\n      P \\<turnstile> D \\<preceq>\\<^sup>* D''\n  pc \\<in> {f..<t}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P D pc xt = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>", "from correct meth"], ["proof (chain)\npicking this:\n  \\<Phi> \\<turnstile> t:(\\<lfloor>xcp\\<rfloor>, h, fr # frs) \\<surd>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C", "obtain ST LT\n      where h_ok:  \"hconf h\"\n      and \\<Phi>_pc: \"\\<Phi> C M ! pc = Some (ST, LT)\"\n      and frame:  \"conf_f P h (ST,LT) ins (stk,loc,C,M,pc)\"\n      and frames: \"conf_fs P h \\<Phi> M (size Ts) T frs\"\n      and preh: \"preallocated h\""], ["proof (prove)\nusing this:\n  \\<Phi> \\<turnstile> t:(\\<lfloor>xcp\\<rfloor>, h, fr # frs) \\<surd>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>hconf h; \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         conf_f P h (ST, LT) ins (stk, loc, C, M, pc);\n         conf_fs P h \\<Phi> M (length Ts) T frs; preallocated h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding correct_state_def fr"], ["proof (prove)\nusing this:\n  case (\\<lfloor>xcp\\<rfloor>, h, (stk, loc, C, M, pc) # frs) of\n  (xp, h, frs) \\<Rightarrow>\n    P,h \\<turnstile> t \\<surd>t \\<and>\n    hconf h \\<and>\n    preallocated h \\<and>\n    (case frs of [] \\<Rightarrow> True\n     | f # fs \\<Rightarrow>\n         let (stk, loc, C, M, pc) = f\n         in \\<exists>Ts T mxs mxl\\<^sub>0 is xt \\<tau>.\n               P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                               mxl\\<^sub>0, is, xt)\\<rfloor> in C \\<and>\n               \\<Phi> C M ! pc = \\<lfloor>\\<tau>\\<rfloor> \\<and>\n               conf_f P h \\<tau> is f \\<and>\n               conf_fs P h \\<Phi> M (length Ts) T fs \\<and>\n               conf_xcp P h xp (is ! pc))\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>hconf h; \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         conf_f P h (ST, LT) ins (stk, loc, C, M, pc);\n         conf_fs P h \\<Phi> M (length Ts) T frs; preallocated h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: sees_method_fun)"], ["proof (state)\nthis:\n  hconf h\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  preallocated h\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P D pc xt = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>", "from frame"], ["proof (chain)\npicking this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)", "obtain stk: \"P,h \\<turnstile> stk [:\\<le>] ST\"\n      and loc: \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\" and pc:  \"pc < size ins\""], ["proof (prove)\nusing this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>P,h \\<turnstile> stk [:\\<le>] ST;\n      P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT;\n      pc < length ins\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (unfold conf_f_def) auto"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P D pc xt = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>", "from stk"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST", "have [simp]: \"size stk = size ST\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. length stk = length ST", ".."], ["proof (state)\nthis:\n  length stk = length ST\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P D pc xt = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>", "from wtp meth correct fr"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> \\<turnstile> t:(\\<lfloor>xcp\\<rfloor>, h, fr # frs) \\<surd>\n  fr = (stk, loc, C, M, pc)", "have wt: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> \\<turnstile> t:(\\<lfloor>xcp\\<rfloor>, h, fr # frs) \\<surd>\n  fr = (stk, loc, C, M, pc)\n\ngoal (1 subgoal):\n 1. P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M", "by (auto simp add: correct_state_def conf_f_def\n                   dest: sees_method_fun\n                   elim!: wt_jvm_prog_impl_wt_instr)"], ["proof (state)\nthis:\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P D pc xt = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>", "from wt \\<Phi>_pc"], ["proof (chain)\npicking this:\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>", "have\n      eff: \"\\<forall>(pc', s')\\<in>set (xcpt_eff (ins!pc) P pc (ST,LT) xt).\n             pc' < size ins \\<and> P \\<turnstile> s' \\<le>' \\<Phi> C M!pc'\""], ["proof (prove)\nusing this:\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<forall>(pc', s')\\<in>set (xcpt_eff (ins ! pc) P pc (ST, LT) xt).\n       pc' < length ins \\<and> P \\<turnstile> s' \\<le>' \\<Phi> C M ! pc'", "by (auto simp add: defs1)"], ["proof (state)\nthis:\n  \\<forall>(pc', s')\\<in>set (xcpt_eff (ins ! pc) P pc (ST, LT) xt).\n     pc' < length ins \\<and> P \\<turnstile> s' \\<le>' \\<Phi> C M ! pc'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P D pc xt = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>", "let ?stk' = \"Addr xcp # drop (length stk - d') stk\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P D pc xt = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>", "let ?f = \"(?stk', loc, C, M, pc')\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P D pc xt = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>", "have conf: \"P,h \\<turnstile> Addr xcp :\\<le> Class (case D' of None \\<Rightarrow> Throwable | Some D'' \\<Rightarrow> D'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h \\<turnstile> Addr\n                      xcp :\\<le> Class\n                                  (case D' of None \\<Rightarrow> Throwable\n                                   | \\<lfloor>D''\\<rfloor> \\<Rightarrow>\n D'')", "using DsubD' hxcp DsubThrowable"], ["proof (prove)\nusing this:\n  case D' of None \\<Rightarrow> True\n  | \\<lfloor>D''\\<rfloor> \\<Rightarrow>\n      P \\<turnstile> D \\<preceq>\\<^sup>* D''\n  typeof_addr h xcp = \\<lfloor>Class_type D\\<rfloor>\n  P \\<turnstile> D \\<preceq>\\<^sup>* Throwable\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> Addr\n                      xcp :\\<le> Class\n                                  (case D' of None \\<Rightarrow> Throwable\n                                   | \\<lfloor>D''\\<rfloor> \\<Rightarrow>\n D'')", "by(auto simp add: conf_def)"], ["proof (state)\nthis:\n  P,h \\<turnstile> Addr\n                    xcp :\\<le> Class\n                                (case D' of None \\<Rightarrow> Throwable\n                                 | \\<lfloor>D''\\<rfloor> \\<Rightarrow> D'')\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P D pc xt = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>", "obtain ST' LT' where\n      \\<Phi>_pc': \"\\<Phi> C M ! pc' = Some (ST', LT')\" and\n      pc':   \"pc' < size ins\" and\n      less:  \"P \\<turnstile> (Class D # drop (size ST - d') ST, LT) \\<le>\\<^sub>i (ST', LT')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ST' LT'.\n        \\<lbrakk>\\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>;\n         pc' < length ins;\n         P \\<turnstile> (Class D # drop (length ST - d') ST,\n                         LT) \\<le>\\<^sub>i (ST', LT')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(cases D')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ST' LT'.\n                \\<lbrakk>\\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>;\n                 pc' < length ins;\n                 P \\<turnstile> (Class D # drop (length ST - d') ST,\n                                 LT) \\<le>\\<^sub>i (ST', LT')\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     D' = Any\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a.\n       \\<lbrakk>\\<And>ST' LT'.\n                   \\<lbrakk>\\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>;\n                    pc' < length ins;\n                    P \\<turnstile> (Class D # drop (length ST - d') ST,\n                                    LT) \\<le>\\<^sub>i (ST', LT')\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        D' = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> thesis", "case Some"], ["proof (state)\nthis:\n  D' = \\<lfloor>a_\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ST' LT'.\n                \\<lbrakk>\\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>;\n                 pc' < length ins;\n                 P \\<turnstile> (Class D # drop (length ST - d') ST,\n                                 LT) \\<le>\\<^sub>i (ST', LT')\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     D' = Any\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a.\n       \\<lbrakk>\\<And>ST' LT'.\n                   \\<lbrakk>\\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>;\n                    pc' < length ins;\n                    P \\<turnstile> (Class D # drop (length ST - d') ST,\n                                    LT) \\<le>\\<^sub>i (ST', LT')\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        D' = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  D' = \\<lfloor>a_\\<rfloor>\n\ngoal (1 subgoal):\n 1. thesis", "using eff rv DsubD' conf that"], ["proof (prove)\nusing this:\n  D' = \\<lfloor>a_\\<rfloor>\n  \\<forall>(pc', s')\\<in>set (xcpt_eff (ins ! pc) P pc (ST, LT) xt).\n     pc' < length ins \\<and> P \\<turnstile> s' \\<le>' \\<Phi> C M ! pc'\n  (f, t, D', pc', d') \\<in> set (relevant_entries P (ins ! pc) pc xt)\n  case D' of None \\<Rightarrow> True\n  | \\<lfloor>D''\\<rfloor> \\<Rightarrow>\n      P \\<turnstile> D \\<preceq>\\<^sup>* D''\n  P,h \\<turnstile> Addr\n                    xcp :\\<le> Class\n                                (case D' of None \\<Rightarrow> Throwable\n                                 | \\<lfloor>D''\\<rfloor> \\<Rightarrow> D'')\n  \\<lbrakk>\\<Phi> C M ! pc' = \\<lfloor>(?ST'15, ?LT'15)\\<rfloor>;\n   pc' < length ins;\n   P \\<turnstile> (Class D # drop (length ST - d') ST,\n                   LT) \\<le>\\<^sub>i (?ST'15, ?LT'15)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by(fastforce simp add: xcpt_eff_def sup_state_opt_any_Some intro: widen_trans[OF widen_subcls])"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ST' LT'.\n                \\<lbrakk>\\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>;\n                 pc' < length ins;\n                 P \\<turnstile> (Class D # drop (length ST - d') ST,\n                                 LT) \\<le>\\<^sub>i (ST', LT')\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     D' = Any\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ST' LT'.\n                \\<lbrakk>\\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>;\n                 pc' < length ins;\n                 P \\<turnstile> (Class D # drop (length ST - d') ST,\n                                 LT) \\<le>\\<^sub>i (ST', LT')\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     D' = Any\\<rbrakk>\n    \\<Longrightarrow> thesis", "case None"], ["proof (state)\nthis:\n  D' = Any\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ST' LT'.\n                \\<lbrakk>\\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>;\n                 pc' < length ins;\n                 P \\<turnstile> (Class D # drop (length ST - d') ST,\n                                 LT) \\<le>\\<^sub>i (ST', LT')\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     D' = Any\\<rbrakk>\n    \\<Longrightarrow> thesis", "with that eff rv conf DsubThrowable"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<Phi> C M ! pc' = \\<lfloor>(?ST'15, ?LT'15)\\<rfloor>;\n   pc' < length ins;\n   P \\<turnstile> (Class D # drop (length ST - d') ST,\n                   LT) \\<le>\\<^sub>i (?ST'15, ?LT'15)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<forall>(pc', s')\\<in>set (xcpt_eff (ins ! pc) P pc (ST, LT) xt).\n     pc' < length ins \\<and> P \\<turnstile> s' \\<le>' \\<Phi> C M ! pc'\n  (f, t, D', pc', d') \\<in> set (relevant_entries P (ins ! pc) pc xt)\n  P,h \\<turnstile> Addr\n                    xcp :\\<le> Class\n                                (case D' of None \\<Rightarrow> Throwable\n                                 | \\<lfloor>D''\\<rfloor> \\<Rightarrow> D'')\n  P \\<turnstile> D \\<preceq>\\<^sup>* Throwable\n  D' = Any", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<Phi> C M ! pc' = \\<lfloor>(?ST'15, ?LT'15)\\<rfloor>;\n   pc' < length ins;\n   P \\<turnstile> (Class D # drop (length ST - d') ST,\n                   LT) \\<le>\\<^sub>i (?ST'15, ?LT'15)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<forall>(pc', s')\\<in>set (xcpt_eff (ins ! pc) P pc (ST, LT) xt).\n     pc' < length ins \\<and> P \\<turnstile> s' \\<le>' \\<Phi> C M ! pc'\n  (f, t, D', pc', d') \\<in> set (relevant_entries P (ins ! pc) pc xt)\n  P,h \\<turnstile> Addr\n                    xcp :\\<le> Class\n                                (case D' of None \\<Rightarrow> Throwable\n                                 | \\<lfloor>D''\\<rfloor> \\<Rightarrow> D'')\n  P \\<turnstile> D \\<preceq>\\<^sup>* Throwable\n  D' = Any\n\ngoal (1 subgoal):\n 1. thesis", "by(fastforce simp add: xcpt_eff_def sup_state_opt_any_Some intro: widen_trans[OF widen_subcls])"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  pc' < length ins\n  P \\<turnstile> (Class D # drop (length ST - d') ST,\n                  LT) \\<le>\\<^sub>i (ST', LT')\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P D pc xt = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>", "with conf loc stk hxcp"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> Addr\n                    xcp :\\<le> Class\n                                (case D' of None \\<Rightarrow> Throwable\n                                 | \\<lfloor>D''\\<rfloor> \\<Rightarrow> D'')\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P,h \\<turnstile> stk [:\\<le>] ST\n  typeof_addr h xcp = \\<lfloor>Class_type D\\<rfloor>\n  \\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  pc' < length ins\n  P \\<turnstile> (Class D # drop (length ST - d') ST,\n                  LT) \\<le>\\<^sub>i (ST', LT')", "have \"conf_f P h (ST',LT') ins ?f\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> Addr\n                    xcp :\\<le> Class\n                                (case D' of None \\<Rightarrow> Throwable\n                                 | \\<lfloor>D''\\<rfloor> \\<Rightarrow> D'')\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P,h \\<turnstile> stk [:\\<le>] ST\n  typeof_addr h xcp = \\<lfloor>Class_type D\\<rfloor>\n  \\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  pc' < length ins\n  P \\<turnstile> (Class D # drop (length ST - d') ST,\n                  LT) \\<le>\\<^sub>i (ST', LT')\n\ngoal (1 subgoal):\n 1. conf_f P h (ST', LT') ins\n     (Addr xcp # drop (length stk - d') stk, loc, C, M, pc')", "by (auto simp add: defs1 conf_def intro: list_all2_dropI)"], ["proof (state)\nthis:\n  conf_f P h (ST', LT') ins\n   (Addr xcp # drop (length stk - d') stk, loc, C, M, pc')\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P D pc xt = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>", "with meth h_ok frames \\<Phi>_pc' fr match hxcp tconf preh"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  hconf h\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  \\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  fr = (stk, loc, C, M, pc)\n  match_ex_table P D pc xt = \\<lfloor>(pc', d')\\<rfloor>\n  typeof_addr h xcp = \\<lfloor>Class_type D\\<rfloor>\n  P,h \\<turnstile> t \\<surd>t\n  preallocated h\n  conf_f P h (ST', LT') ins\n   (Addr xcp # drop (length stk - d') stk, loc, C, M, pc')", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  hconf h\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  \\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  fr = (stk, loc, C, M, pc)\n  match_ex_table P D pc xt = \\<lfloor>(pc', d')\\<rfloor>\n  typeof_addr h xcp = \\<lfloor>Class_type D\\<rfloor>\n  P,h \\<turnstile> t \\<surd>t\n  preallocated h\n  conf_f P h (ST', LT') ins\n   (Addr xcp # drop (length stk - d') stk, loc, C, M, pc')\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>", "unfolding correct_state_def"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  hconf h\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  \\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  fr = (stk, loc, C, M, pc)\n  match_ex_table P D pc xt = \\<lfloor>(pc', d')\\<rfloor>\n  typeof_addr h xcp = \\<lfloor>Class_type D\\<rfloor>\n  P,h \\<turnstile> t \\<surd>t\n  preallocated h\n  conf_f P h (ST', LT') ins\n   (Addr xcp # drop (length stk - d') stk, loc, C, M, pc')\n\ngoal (1 subgoal):\n 1. case exception_step P xcp h fr frs of\n    (xp, h, frs) \\<Rightarrow>\n      P,h \\<turnstile> t \\<surd>t \\<and>\n      hconf h \\<and>\n      preallocated h \\<and>\n      (case frs of [] \\<Rightarrow> True\n       | f # fs \\<Rightarrow>\n           let (stk, loc, C, M, pc) = f\n           in \\<exists>Ts T mxs mxl\\<^sub>0 is xt \\<tau>.\n                 P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                                 mxl\\<^sub>0, is, xt)\\<rfloor> in C \\<and>\n                 \\<Phi> C M ! pc = \\<lfloor>\\<tau>\\<rfloor> \\<and>\n                 conf_f P h \\<tau> is f \\<and>\n                 conf_fs P h \\<Phi> M (length Ts) T fs \\<and>\n                 conf_xcp P h xp (is ! pc))", "by(fastforce dest: sees_method_fun simp add: cname_of_def)"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:exception_step P xcp h fr frs \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Single Instructions\\<close>"], ["", "text \\<open>\n  In this subsection we prove for each single (welltyped) instruction\n  that the state after execution of the instruction still conforms.\n  Since we have already handled raised exceptions above, we can now assume that\n  no exception has been raised in this step.\n\\<close>"], ["", "context JVM_conf_read begin"], ["", "declare defs1 [simp]"], ["", "lemma Invoke_correct: \n  fixes \\<sigma>' :: \"('addr, 'heap) jvm_state\"\n  assumes wtprog: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes meth_C: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C\"\n  assumes ins:    \"ins ! pc = Invoke M' n\"\n  assumes wti:    \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes approx: \"\\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  assumes exec: \"(tas, \\<sigma>) \\<in> exec_instr (ins!pc) P t h stk loc C M pc frs\"\n  shows \"\\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "note split_paired_Ex [simp del]"], ["proof (state)\nthis:\n  (\\<exists>x. ?P x) = (\\<exists>a b. ?P (a, b))\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from wtprog"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P", "obtain wfmb where wfprog: \"wf_prog wfmb P\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n\ngoal (1 subgoal):\n 1. (\\<And>wfmb. wf_prog wfmb P \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: wf_jvm_prog_phi_def)"], ["proof (state)\nthis:\n  wf_prog wfmb P\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from ins meth_C approx"], ["proof (chain)\npicking this:\n  ins ! pc = Invoke M' n\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>", "obtain ST LT where\n    heap_ok: \"hconf h\" and\n    tconf:   \"P,h \\<turnstile> t \\<surd>t\" and\n    \\<Phi>_pc:    \"\\<Phi> C M!pc = Some (ST,LT)\" and\n    frame:   \"conf_f P h (ST,LT) ins (stk,loc,C,M,pc)\" and\n    frames:  \"conf_fs P h \\<Phi> M (size Ts) T frs\" and\n    preh:    \"preallocated h\""], ["proof (prove)\nusing this:\n  ins ! pc = Invoke M' n\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>hconf h; P,h \\<turnstile> t \\<surd>t;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         conf_f P h (ST, LT) ins (stk, loc, C, M, pc);\n         conf_fs P h \\<Phi> M (length Ts) T frs; preallocated h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce dest: sees_method_fun)"], ["proof (state)\nthis:\n  hconf h\n  P,h \\<turnstile> t \\<surd>t\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  preallocated h\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from ins wti \\<Phi>_pc"], ["proof (chain)\npicking this:\n  ins ! pc = Invoke M' n\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>", "have n: \"n < size ST\""], ["proof (prove)\nusing this:\n  ins ! pc = Invoke M' n\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n\ngoal (1 subgoal):\n 1. n < length ST", "by simp"], ["proof (state)\nthis:\n  n < length ST\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "proof(cases \"stk!n = Null\")"], ["proof (state)\ngoal (2 subgoals):\n 1. stk ! n = Null \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "case True"], ["proof (state)\nthis:\n  stk ! n = Null\n\ngoal (2 subgoals):\n 1. stk ! n = Null \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with ins heap_ok \\<Phi>_pc frame frames exec meth_C tconf preh"], ["proof (chain)\npicking this:\n  ins ! pc = Invoke M' n\n  hconf h\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  P,h \\<turnstile> t \\<surd>t\n  preallocated h\n  stk ! n = Null", "show ?thesis"], ["proof (prove)\nusing this:\n  ins ! pc = Invoke M' n\n  hconf h\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  P,h \\<turnstile> t \\<surd>t\n  preallocated h\n  stk ! n = Null\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "by(fastforce elim: wf_preallocatedE[OF wfprog, where C=NullPointer])"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "case False"], ["proof (state)\nthis:\n  stk ! n \\<noteq> Null\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "note Null = this"], ["proof (state)\nthis:\n  stk ! n \\<noteq> Null\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "have NT: \"ST!n \\<noteq> NT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ST ! n \\<noteq> NT", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ST ! n = NT \\<Longrightarrow> False", "assume \"ST!n = NT\""], ["proof (state)\nthis:\n  ST ! n = NT\n\ngoal (1 subgoal):\n 1. ST ! n = NT \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  ST ! n = NT\n\ngoal (1 subgoal):\n 1. ST ! n = NT \\<Longrightarrow> False", "from frame"], ["proof (chain)\npicking this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)", "have \"P,h \\<turnstile> stk [:\\<le>] ST\""], ["proof (prove)\nusing this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> stk [:\\<le>] ST", "by simp"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. ST ! n = NT \\<Longrightarrow> False", "with n"], ["proof (chain)\npicking this:\n  n < length ST\n  P,h \\<turnstile> stk [:\\<le>] ST", "have \"P,h \\<turnstile> stk!n :\\<le> ST!n\""], ["proof (prove)\nusing this:\n  n < length ST\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> stk ! n :\\<le> ST ! n", "by (simp add: list_all2_conv_all_nth)"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk ! n :\\<le> ST ! n\n\ngoal (1 subgoal):\n 1. ST ! n = NT \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  ST ! n = NT\n  P,h \\<turnstile> stk ! n :\\<le> ST ! n", "have \"stk!n = Null\""], ["proof (prove)\nusing this:\n  ST ! n = NT\n  P,h \\<turnstile> stk ! n :\\<le> ST ! n\n\ngoal (1 subgoal):\n 1. stk ! n = Null", "by simp"], ["proof (state)\nthis:\n  stk ! n = Null\n\ngoal (1 subgoal):\n 1. ST ! n = NT \\<Longrightarrow> False", "with Null"], ["proof (chain)\npicking this:\n  stk ! n \\<noteq> Null\n  stk ! n = Null", "show False"], ["proof (prove)\nusing this:\n  stk ! n \\<noteq> Null\n  stk ! n = Null\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ST ! n \\<noteq> NT\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from frame"], ["proof (chain)\npicking this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)", "obtain \n      stk: \"P,h \\<turnstile> stk [:\\<le>] ST\" and\n      loc: \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\""], ["proof (prove)\nusing this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>P,h \\<turnstile> stk [:\\<le>] ST;\n      P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from NT ins wti \\<Phi>_pc"], ["proof (chain)\npicking this:\n  ST ! n \\<noteq> NT\n  ins ! pc = Invoke M' n\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>", "have pc': \"pc+1 < size ins\""], ["proof (prove)\nusing this:\n  ST ! n \\<noteq> NT\n  ins ! pc = Invoke M' n\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n\ngoal (1 subgoal):\n 1. pc + 1 < length ins", "by simp"], ["proof (state)\nthis:\n  pc + 1 < length ins\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from NT ins wti \\<Phi>_pc"], ["proof (chain)\npicking this:\n  ST ! n \\<noteq> NT\n  ins ! pc = Invoke M' n\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>", "obtain ST' LT'\n      where pc': \"pc+1 < size ins\"\n      and \\<Phi>': \"\\<Phi> C M ! (pc+1) = Some (ST', LT')\"\n      and LT': \"P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\""], ["proof (prove)\nusing this:\n  ST ! n \\<noteq> NT\n  ins ! pc = Invoke M' n\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>ST' LT'.\n        \\<lbrakk>pc + 1 < length ins;\n         \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>;\n         P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: neq_Nil_conv sup_state_opt_any_Some split: if_split_asm)"], ["proof (state)\nthis:\n  pc + 1 < length ins\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with NT ins wti \\<Phi>_pc"], ["proof (chain)\npicking this:\n  ST ! n \\<noteq> NT\n  ins ! pc = Invoke M' n\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  pc + 1 < length ins\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'", "obtain D D' TTs TT m\n      where D: \"class_type_of' (ST!n) = \\<lfloor>D\\<rfloor>\"\n      and m_D: \"P \\<turnstile> D sees M': TTs\\<rightarrow>TT = m in D'\"\n      and Ts:  \"P \\<turnstile> rev (take n ST) [\\<le>] TTs\"\n      and ST': \"P \\<turnstile> (TT # drop (n+1) ST) [\\<le>] ST'\""], ["proof (prove)\nusing this:\n  ST ! n \\<noteq> NT\n  ins ! pc = Invoke M' n\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  pc + 1 < length ins\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. (\\<And>D TTs TT m D'.\n        \\<lbrakk>class_type_of' (ST ! n) = \\<lfloor>D\\<rfloor>;\n         P \\<turnstile> D sees M': TTs\\<rightarrow>TT = m in D';\n         P \\<turnstile> rev (take n ST) [\\<le>] TTs;\n         P \\<turnstile> (TT # drop (n + 1) ST) [\\<le>] ST'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto)"], ["proof (state)\nthis:\n  class_type_of' (ST ! n) = \\<lfloor>D\\<rfloor>\n  P \\<turnstile> D sees M': TTs\\<rightarrow>TT = m in D'\n  P \\<turnstile> rev (take n ST) [\\<le>] TTs\n  P \\<turnstile> (TT # drop (n + 1) ST) [\\<le>] ST'\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from n stk D"], ["proof (chain)\npicking this:\n  n < length ST\n  P,h \\<turnstile> stk [:\\<le>] ST\n  class_type_of' (ST ! n) = \\<lfloor>D\\<rfloor>", "have \"P,h \\<turnstile> stk!n :\\<le> ST ! n\""], ["proof (prove)\nusing this:\n  n < length ST\n  P,h \\<turnstile> stk [:\\<le>] ST\n  class_type_of' (ST ! n) = \\<lfloor>D\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> stk ! n :\\<le> ST ! n", "by (auto simp add: list_all2_conv_all_nth)"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk ! n :\\<le> ST ! n\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from \\<open>P,h \\<turnstile> stk!n :\\<le> ST ! n\\<close> Null D"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk ! n :\\<le> ST ! n\n  stk ! n \\<noteq> Null\n  class_type_of' (ST ! n) = \\<lfloor>D\\<rfloor>", "obtain U a where\n      Addr:   \"stk!n = Addr a\" and\n      obj:    \"typeof_addr h a = Some U\" and\n      UsubSTn: \"P \\<turnstile> ty_of_htype U \\<le> ST ! n\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk ! n :\\<le> ST ! n\n  stk ! n \\<noteq> Null\n  class_type_of' (ST ! n) = \\<lfloor>D\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>a U.\n        \\<lbrakk>stk ! n = Addr a; typeof_addr h a = \\<lfloor>U\\<rfloor>;\n         P \\<turnstile> ty_of_htype U \\<le> ST ! n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \"stk ! n\")(auto simp add: conf_def widen_Class)"], ["proof (state)\nthis:\n  stk ! n = Addr a\n  typeof_addr h a = \\<lfloor>U\\<rfloor>\n  P \\<turnstile> ty_of_htype U \\<le> ST ! n\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from D UsubSTn"], ["proof (chain)\npicking this:\n  class_type_of' (ST ! n) = \\<lfloor>D\\<rfloor>\n  P \\<turnstile> ty_of_htype U \\<le> ST ! n", "obtain C' where\n      C': \"class_type_of' (ty_of_htype U) = \\<lfloor>C'\\<rfloor>\" and C'subD: \"P \\<turnstile> C' \\<preceq>\\<^sup>* D\""], ["proof (prove)\nusing this:\n  class_type_of' (ST ! n) = \\<lfloor>D\\<rfloor>\n  P \\<turnstile> ty_of_htype U \\<le> ST ! n\n\ngoal (1 subgoal):\n 1. (\\<And>C'.\n        \\<lbrakk>class_type_of' (ty_of_htype U) = \\<lfloor>C'\\<rfloor>;\n         P \\<turnstile> C' \\<preceq>\\<^sup>* D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule widen_is_class_type_of) simp"], ["proof (state)\nthis:\n  class_type_of' (ty_of_htype U) = \\<lfloor>C'\\<rfloor>\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with wfprog m_D"], ["proof (chain)\npicking this:\n  wf_prog wfmb P\n  P \\<turnstile> D sees M': TTs\\<rightarrow>TT = m in D'\n  class_type_of' (ty_of_htype U) = \\<lfloor>C'\\<rfloor>\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D", "obtain Ts' T' D'' meth' where\n      m_C': \"P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = meth' in D''\" and\n      T':   \"P \\<turnstile> T' \\<le> TT\" and\n      Ts':  \"P \\<turnstile> TTs [\\<le>] Ts'\""], ["proof (prove)\nusing this:\n  wf_prog wfmb P\n  P \\<turnstile> D sees M': TTs\\<rightarrow>TT = m in D'\n  class_type_of' (ty_of_htype U) = \\<lfloor>C'\\<rfloor>\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. (\\<And>Ts' T' meth' D''.\n        \\<lbrakk>P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = meth' in D'';\n         P \\<turnstile> T' \\<le> TT; P \\<turnstile> TTs [\\<le>] Ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: sees_method_mono)"], ["proof (state)\nthis:\n  P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = meth' in D''\n  P \\<turnstile> T' \\<le> TT\n  P \\<turnstile> TTs [\\<le>] Ts'\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from Ts n"], ["proof (chain)\npicking this:\n  P \\<turnstile> rev (take n ST) [\\<le>] TTs\n  n < length ST", "have [simp]: \"size TTs = n\""], ["proof (prove)\nusing this:\n  P \\<turnstile> rev (take n ST) [\\<le>] TTs\n  n < length ST\n\ngoal (1 subgoal):\n 1. length TTs = n", "by (auto dest: list_all2_lengthD simp: min_def)"], ["proof (state)\nthis:\n  length TTs = n\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with Ts'"], ["proof (chain)\npicking this:\n  P \\<turnstile> TTs [\\<le>] Ts'\n  length TTs = n", "have [simp]: \"size Ts' = n\""], ["proof (prove)\nusing this:\n  P \\<turnstile> TTs [\\<le>] Ts'\n  length TTs = n\n\ngoal (1 subgoal):\n 1. length Ts' = n", "by (auto dest: list_all2_lengthD)"], ["proof (state)\nthis:\n  length Ts' = n\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from m_C' wfprog"], ["proof (chain)\npicking this:\n  P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = meth' in D''\n  wf_prog wfmb P", "obtain mD'': \"P \\<turnstile> D'' sees M':Ts'\\<rightarrow>T'=meth' in D''\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = meth' in D''\n  wf_prog wfmb P\n\ngoal (1 subgoal):\n 1. (P \\<turnstile> D'' sees M': Ts'\\<rightarrow>T' = meth' in D'' \\<Longrightarrow>\n     thesis) \\<Longrightarrow>\n    thesis", "by (fast dest: sees_method_idemp)"], ["proof (state)\nthis:\n  P \\<turnstile> D'' sees M': Ts'\\<rightarrow>T' = meth' in D''\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "{"], ["proof (state)\nthis:\n  P \\<turnstile> D'' sees M': Ts'\\<rightarrow>T' = meth' in D''\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "fix mxs' mxl' ins' xt'"], ["proof (state)\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "assume [simp]: \"meth' = \\<lfloor>(mxs', mxl', ins', xt')\\<rfloor>\""], ["proof (state)\nthis:\n  meth' = \\<lfloor>(mxs', mxl', ins', xt')\\<rfloor>\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "let ?loc' = \"Addr a # rev (take n stk) @ replicate mxl' undefined_value\""], ["proof (state)\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "let ?f' = \"([], ?loc', D'', M', 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "let ?f  = \"(stk, loc, C, M, pc)\""], ["proof (state)\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from Addr obj m_C' ins meth_C exec C' False"], ["proof (chain)\npicking this:\n  stk ! n = Addr a\n  typeof_addr h a = \\<lfloor>U\\<rfloor>\n  P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = meth' in D''\n  ins ! pc = Invoke M' n\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  class_type_of' (ty_of_htype U) = \\<lfloor>C'\\<rfloor>\n  stk ! n \\<noteq> Null", "have s': \"\\<sigma> = (None, h, ?f' # ?f # frs)\""], ["proof (prove)\nusing this:\n  stk ! n = Addr a\n  typeof_addr h a = \\<lfloor>U\\<rfloor>\n  P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = meth' in D''\n  ins ! pc = Invoke M' n\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  class_type_of' (ty_of_htype U) = \\<lfloor>C'\\<rfloor>\n  stk ! n \\<noteq> Null\n\ngoal (1 subgoal):\n 1. \\<sigma> =\n    (None, h,\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'',\n      M', 0) #\n     (stk, loc, C, M, pc) # frs)", "by(auto split: if_split_asm)"], ["proof (state)\nthis:\n  \\<sigma> =\n  (None, h,\n   ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'', M',\n    0) #\n   (stk, loc, C, M, pc) # frs)\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "moreover"], ["proof (state)\nthis:\n  \\<sigma> =\n  (None, h,\n   ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'', M',\n    0) #\n   (stk, loc, C, M, pc) # frs)\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from wtprog mD''"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> D'' sees M': Ts'\\<rightarrow>T' = meth' in D''", "obtain start: \"wt_start P D'' Ts' mxl' (\\<Phi> D'' M')\" and ins': \"ins' \\<noteq> []\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> D'' sees M': Ts'\\<rightarrow>T' = meth' in D''\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>wt_start P D'' Ts' mxl' (\\<Phi> D'' M');\n      ins' \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: wt_jvm_prog_impl_wt_start)"], ["proof (state)\nthis:\n  wt_start P D'' Ts' mxl' (\\<Phi> D'' M')\n  ins' \\<noteq> []\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "then"], ["proof (chain)\npicking this:\n  wt_start P D'' Ts' mxl' (\\<Phi> D'' M')\n  ins' \\<noteq> []", "obtain LT\\<^sub>0 where LT\\<^sub>0: \"\\<Phi> D'' M' ! 0 = Some ([], LT\\<^sub>0)\""], ["proof (prove)\nusing this:\n  wt_start P D'' Ts' mxl' (\\<Phi> D'' M')\n  ins' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>LT\\<^sub>0.\n        \\<Phi> D'' M' ! 0 =\n        \\<lfloor>([], LT\\<^sub>0)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (clarsimp simp add: wt_start_def defs1 sup_state_opt_any_Some)"], ["proof (state)\nthis:\n  \\<Phi> D'' M' ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "moreover"], ["proof (state)\nthis:\n  \\<Phi> D'' M' ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "have \"conf_f P h ([], LT\\<^sub>0) ins' ?f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'',\n      M', 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'',\n      M', 0)", "let ?LT = \"OK (Class D'') # (map OK Ts') @ (replicate mxl' Err)\""], ["proof (state)\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'',\n      M', 0)", "from stk"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST", "have \"P,h \\<turnstile> take n stk [:\\<le>] take n ST\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> take n stk [:\\<le>] take n ST", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> take n stk [:\\<le>] take n ST\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'',\n      M', 0)", "hence \"P,h \\<turnstile> rev (take n stk) [:\\<le>] rev (take n ST)\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> take n stk [:\\<le>] take n ST\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> rev (take n stk) [:\\<le>] rev (take n ST)", "by simp"], ["proof (state)\nthis:\n  P,h \\<turnstile> rev (take n stk) [:\\<le>] rev (take n ST)\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'',\n      M', 0)", "also"], ["proof (state)\nthis:\n  P,h \\<turnstile> rev (take n stk) [:\\<le>] rev (take n ST)\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'',\n      M', 0)", "note Ts"], ["proof (state)\nthis:\n  P \\<turnstile> rev (take n ST) [\\<le>] TTs\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'',\n      M', 0)", "also"], ["proof (state)\nthis:\n  P \\<turnstile> rev (take n ST) [\\<le>] TTs\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'',\n      M', 0)", "note Ts'"], ["proof (state)\nthis:\n  P \\<turnstile> TTs [\\<le>] Ts'\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'',\n      M', 0)", "finally"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> rev (take n stk) [:\\<le>] Ts'", "have \"P,h \\<turnstile> rev (take n stk) [:\\<le>\\<^sub>\\<top>] map OK Ts'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> rev (take n stk) [:\\<le>] Ts'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> rev (take n stk) [:\\<le>\\<^sub>\\<top>] map OK Ts'", "by simp"], ["proof (state)\nthis:\n  P,h \\<turnstile> rev (take n stk) [:\\<le>\\<^sub>\\<top>] map OK Ts'\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'',\n      M', 0)", "also"], ["proof (state)\nthis:\n  P,h \\<turnstile> rev (take n stk) [:\\<le>\\<^sub>\\<top>] map OK Ts'\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'',\n      M', 0)", "have \"P,h \\<turnstile> replicate mxl' undefined_value [:\\<le>\\<^sub>\\<top>] replicate mxl' Err\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h \\<turnstile> replicate mxl'\n                      undefined_value [:\\<le>\\<^sub>\\<top>] replicate mxl'\n                       Err", "by simp"], ["proof (state)\nthis:\n  P,h \\<turnstile> replicate mxl'\n                    undefined_value [:\\<le>\\<^sub>\\<top>] replicate mxl' Err\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'',\n      M', 0)", "also"], ["proof (state)\nthis:\n  P,h \\<turnstile> replicate mxl'\n                    undefined_value [:\\<le>\\<^sub>\\<top>] replicate mxl' Err\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'',\n      M', 0)", "from m_C'"], ["proof (chain)\npicking this:\n  P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = meth' in D''", "have \"P \\<turnstile> C' \\<preceq>\\<^sup>* D''\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = meth' in D''\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C' \\<preceq>\\<^sup>* D''", "by (rule sees_method_decl_above)"], ["proof (state)\nthis:\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D''\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'',\n      M', 0)", "from obj heap_ok"], ["proof (chain)\npicking this:\n  typeof_addr h a = \\<lfloor>U\\<rfloor>\n  hconf h", "have \"is_htype P U\""], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>U\\<rfloor>\n  hconf h\n\ngoal (1 subgoal):\n 1. is_htype P U", "by (rule typeof_addr_is_type)"], ["proof (state)\nthis:\n  is_htype P U\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'',\n      M', 0)", "with C'"], ["proof (chain)\npicking this:\n  class_type_of' (ty_of_htype U) = \\<lfloor>C'\\<rfloor>\n  is_htype P U", "have \"P \\<turnstile> ty_of_htype U \\<le> Class C'\""], ["proof (prove)\nusing this:\n  class_type_of' (ty_of_htype U) = \\<lfloor>C'\\<rfloor>\n  is_htype P U\n\ngoal (1 subgoal):\n 1. P \\<turnstile> ty_of_htype U \\<le> Class C'", "by(cases U)(simp_all add: widen_array_object)"], ["proof (state)\nthis:\n  P \\<turnstile> ty_of_htype U \\<le> Class C'\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'',\n      M', 0)", "with \\<open>P \\<turnstile> C' \\<preceq>\\<^sup>* D''\\<close> obj C'"], ["proof (chain)\npicking this:\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D''\n  typeof_addr h a = \\<lfloor>U\\<rfloor>\n  class_type_of' (ty_of_htype U) = \\<lfloor>C'\\<rfloor>\n  P \\<turnstile> ty_of_htype U \\<le> Class C'", "have \"P,h \\<turnstile> Addr a :\\<le> Class D''\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D''\n  typeof_addr h a = \\<lfloor>U\\<rfloor>\n  class_type_of' (ty_of_htype U) = \\<lfloor>C'\\<rfloor>\n  P \\<turnstile> ty_of_htype U \\<le> Class C'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> Addr a :\\<le> Class D''", "by (auto simp add: conf_def intro: widen_trans)"], ["proof (state)\nthis:\n  P,h \\<turnstile> Addr a :\\<le> Class D''\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'',\n      M', 0)", "ultimately"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> rev (take n stk) @\n                   replicate mxl'\n                    undefined_value [:\\<le>\\<^sub>\\<top>] map OK Ts' @\n                    replicate mxl' Err\n  P,h \\<turnstile> Addr a :\\<le> Class D''", "have \"P,h \\<turnstile> ?loc' [:\\<le>\\<^sub>\\<top>] ?LT\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> rev (take n stk) @\n                   replicate mxl'\n                    undefined_value [:\\<le>\\<^sub>\\<top>] map OK Ts' @\n                    replicate mxl' Err\n  P,h \\<turnstile> Addr a :\\<le> Class D''\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> Addr a #\n                     rev (take n stk) @\n                     replicate mxl'\n                      undefined_value [:\\<le>\\<^sub>\\<top>] OK (Class D'') #\n                      map OK Ts' @ replicate mxl' Err", "by simp"], ["proof (state)\nthis:\n  P,h \\<turnstile> Addr a #\n                   rev (take n stk) @\n                   replicate mxl'\n                    undefined_value [:\\<le>\\<^sub>\\<top>] OK (Class D'') #\n                    map OK Ts' @ replicate mxl' Err\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'',\n      M', 0)", "also"], ["proof (state)\nthis:\n  P,h \\<turnstile> Addr a #\n                   rev (take n stk) @\n                   replicate mxl'\n                    undefined_value [:\\<le>\\<^sub>\\<top>] OK (Class D'') #\n                    map OK Ts' @ replicate mxl' Err\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'',\n      M', 0)", "from start LT\\<^sub>0"], ["proof (chain)\npicking this:\n  wt_start P D'' Ts' mxl' (\\<Phi> D'' M')\n  \\<Phi> D'' M' ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>", "have \"P \\<turnstile> \\<dots> [\\<le>\\<^sub>\\<top>] LT\\<^sub>0\""], ["proof (prove)\nusing this:\n  wt_start P D'' Ts' mxl' (\\<Phi> D'' M')\n  \\<Phi> D'' M' ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> (OK (Class D'') #\n                    map OK Ts' @\n                    replicate mxl' Err) [\\<le>\\<^sub>\\<top>] LT\\<^sub>0", "by (simp add: wt_start_def)"], ["proof (state)\nthis:\n  P \\<turnstile> (OK (Class D'') #\n                  map OK Ts' @\n                  replicate mxl' Err) [\\<le>\\<^sub>\\<top>] LT\\<^sub>0\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'',\n      M', 0)", "finally"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> Addr a #\n                   rev (take n stk) @\n                   replicate mxl'\n                    undefined_value [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0", "have \"P,h \\<turnstile> ?loc' [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> Addr a #\n                   rev (take n stk) @\n                   replicate mxl'\n                    undefined_value [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> Addr a #\n                     rev (take n stk) @\n                     replicate mxl'\n                      undefined_value [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0", "."], ["proof (state)\nthis:\n  P,h \\<turnstile> Addr a #\n                   rev (take n stk) @\n                   replicate mxl'\n                    undefined_value [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'',\n      M', 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  P,h \\<turnstile> Addr a #\n                   rev (take n stk) @\n                   replicate mxl'\n                    undefined_value [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'',\n      M', 0)", "using ins'"], ["proof (prove)\nusing this:\n  P,h \\<turnstile> Addr a #\n                   rev (take n stk) @\n                   replicate mxl'\n                    undefined_value [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0\n  ins' \\<noteq> []\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'',\n      M', 0)", "by simp"], ["proof (state)\nthis:\n  conf_f P h ([], LT\\<^sub>0) ins'\n   ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'', M',\n    0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  conf_f P h ([], LT\\<^sub>0) ins'\n   ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'', M',\n    0)\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "ultimately"], ["proof (chain)\npicking this:\n  \\<sigma> =\n  (None, h,\n   ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'', M',\n    0) #\n   (stk, loc, C, M, pc) # frs)\n  \\<Phi> D'' M' ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>\n  conf_f P h ([], LT\\<^sub>0) ins'\n   ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'', M',\n    0)", "have ?thesis"], ["proof (prove)\nusing this:\n  \\<sigma> =\n  (None, h,\n   ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'', M',\n    0) #\n   (stk, loc, C, M, pc) # frs)\n  \\<Phi> D'' M' ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>\n  conf_f P h ([], LT\\<^sub>0) ins'\n   ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'', M',\n    0)\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "using s' \\<Phi>_pc approx meth_C m_D T' ins D tconf C' mD''"], ["proof (prove)\nusing this:\n  \\<sigma> =\n  (None, h,\n   ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'', M',\n    0) #\n   (stk, loc, C, M, pc) # frs)\n  \\<Phi> D'' M' ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>\n  conf_f P h ([], LT\\<^sub>0) ins'\n   ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'', M',\n    0)\n  \\<sigma> =\n  (None, h,\n   ([], Addr a # rev (take n stk) @ replicate mxl' undefined_value, D'', M',\n    0) #\n   (stk, loc, C, M, pc) # frs)\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  P \\<turnstile> D sees M': TTs\\<rightarrow>TT = m in D'\n  P \\<turnstile> T' \\<le> TT\n  ins ! pc = Invoke M' n\n  class_type_of' (ST ! n) = \\<lfloor>D\\<rfloor>\n  P,h \\<turnstile> t \\<surd>t\n  class_type_of' (ty_of_htype U) = \\<lfloor>C'\\<rfloor>\n  P \\<turnstile> D'' sees M': Ts'\\<rightarrow>T' = meth' in D''\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "by (fastforce dest: sees_method_fun [of _ C])"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "}"], ["proof (state)\nthis:\n  meth' =\n  \\<lfloor>(?mxs'17, ?mxl'17, ?ins'17, ?xt'17)\\<rfloor> \\<Longrightarrow>\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "moreover"], ["proof (state)\nthis:\n  meth' =\n  \\<lfloor>(?mxs'17, ?mxl'17, ?ins'17, ?xt'17)\\<rfloor> \\<Longrightarrow>\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "{"], ["proof (state)\nthis:\n  meth' =\n  \\<lfloor>(?mxs'17, ?mxl'17, ?ins'17, ?xt'17)\\<rfloor> \\<Longrightarrow>\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "assume [simp]: \"meth' = Native\""], ["proof (state)\nthis:\n  meth' = None\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with wfprog m_C'"], ["proof (chain)\npicking this:\n  wf_prog wfmb P\n  P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = meth' in D''\n  meth' = None", "have \"D''\\<bullet>M'(Ts') :: T'\""], ["proof (prove)\nusing this:\n  wf_prog wfmb P\n  P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = meth' in D''\n  meth' = None\n\ngoal (1 subgoal):\n 1. D''\\<bullet>M'(Ts') :: T'", "by(simp add: sees_wf_native)"], ["proof (state)\nthis:\n  D''\\<bullet>M'(Ts') :: T'\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with C' m_C'"], ["proof (chain)\npicking this:\n  class_type_of' (ty_of_htype U) = \\<lfloor>C'\\<rfloor>\n  P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = meth' in D''\n  D''\\<bullet>M'(Ts') :: T'", "have nec: \"is_native P U M'\""], ["proof (prove)\nusing this:\n  class_type_of' (ty_of_htype U) = \\<lfloor>C'\\<rfloor>\n  P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = meth' in D''\n  D''\\<bullet>M'(Ts') :: T'\n\ngoal (1 subgoal):\n 1. is_native P U M'", "by(auto intro: is_native.intros)"], ["proof (state)\nthis:\n  is_native P U M'\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from ins n Addr obj exec m_C' C'"], ["proof (chain)\npicking this:\n  ins ! pc = Invoke M' n\n  n < length ST\n  stk ! n = Addr a\n  typeof_addr h a = \\<lfloor>U\\<rfloor>\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = meth' in D''\n  class_type_of' (ty_of_htype U) = \\<lfloor>C'\\<rfloor>", "obtain va h' tas' where va: \"(tas', va, h') \\<in> red_external_aggr P t a M' (rev (take n stk)) h\"\n        and \\<sigma>: \"\\<sigma> = extRet2JVM n h' stk loc C M pc frs va\""], ["proof (prove)\nusing this:\n  ins ! pc = Invoke M' n\n  n < length ST\n  stk ! n = Addr a\n  typeof_addr h a = \\<lfloor>U\\<rfloor>\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = meth' in D''\n  class_type_of' (ty_of_htype U) = \\<lfloor>C'\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>tas' va h'.\n        \\<lbrakk>(tas', va, h')\n                 \\<in> red_external_aggr P t a M' (rev (take n stk)) h;\n         \\<sigma> = extRet2JVM n h' stk loc C M pc frs va\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto)"], ["proof (state)\nthis:\n  (tas', va, h') \\<in> red_external_aggr P t a M' (rev (take n stk)) h\n  \\<sigma> = extRet2JVM n h' stk loc C M pc frs va\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from va nec obj"], ["proof (chain)\npicking this:\n  (tas', va, h') \\<in> red_external_aggr P t a M' (rev (take n stk)) h\n  is_native P U M'\n  typeof_addr h a = \\<lfloor>U\\<rfloor>", "have hext: \"h \\<unlhd> h'\""], ["proof (prove)\nusing this:\n  (tas', va, h') \\<in> red_external_aggr P t a M' (rev (take n stk)) h\n  is_native P U M'\n  typeof_addr h a = \\<lfloor>U\\<rfloor>\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "by(auto intro: red_external_aggr_hext)"], ["proof (state)\nthis:\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with frames"], ["proof (chain)\npicking this:\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  h \\<unlhd> h'", "have frames': \"conf_fs P h' \\<Phi> M (length Ts) T frs\""], ["proof (prove)\nusing this:\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. conf_fs P h' \\<Phi> M (length Ts) T frs", "by(rule conf_fs_hext)"], ["proof (state)\nthis:\n  conf_fs P h' \\<Phi> M (length Ts) T frs\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from preh hext"], ["proof (chain)\npicking this:\n  preallocated h\n  h \\<unlhd> h'", "have preh': \"preallocated h'\""], ["proof (prove)\nusing this:\n  preallocated h\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. preallocated h'", "by(rule preallocated_hext)"], ["proof (state)\nthis:\n  preallocated h'\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from va nec obj tconf"], ["proof (chain)\npicking this:\n  (tas', va, h') \\<in> red_external_aggr P t a M' (rev (take n stk)) h\n  is_native P U M'\n  typeof_addr h a = \\<lfloor>U\\<rfloor>\n  P,h \\<turnstile> t \\<surd>t", "have tconf': \"P,h' \\<turnstile> t \\<surd>t\""], ["proof (prove)\nusing this:\n  (tas', va, h') \\<in> red_external_aggr P t a M' (rev (take n stk)) h\n  is_native P U M'\n  typeof_addr h a = \\<lfloor>U\\<rfloor>\n  P,h \\<turnstile> t \\<surd>t\n\ngoal (1 subgoal):\n 1. P,h' \\<turnstile> t \\<surd>t", "by(auto dest: red_external_aggr_preserves_tconf)"], ["proof (state)\nthis:\n  P,h' \\<turnstile> t \\<surd>t\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from hext obj"], ["proof (chain)\npicking this:\n  h \\<unlhd> h'\n  typeof_addr h a = \\<lfloor>U\\<rfloor>", "have obj': \"typeof_addr h' a = \\<lfloor>U\\<rfloor>\""], ["proof (prove)\nusing this:\n  h \\<unlhd> h'\n  typeof_addr h a = \\<lfloor>U\\<rfloor>\n\ngoal (1 subgoal):\n 1. typeof_addr h' a = \\<lfloor>U\\<rfloor>", "by(rule typeof_addr_hext_mono)"], ["proof (state)\nthis:\n  typeof_addr h' a = \\<lfloor>U\\<rfloor>\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from stk"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST", "have \"P,h \\<turnstile> take n stk [:\\<le>] take n ST\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> take n stk [:\\<le>] take n ST", "by(rule list_all2_takeI)"], ["proof (state)\nthis:\n  P,h \\<turnstile> take n stk [:\\<le>] take n ST\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "then"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> take n stk [:\\<le>] take n ST", "obtain Us where \"map typeof\\<^bsub>h\\<^esub> (take n stk) = map Some Us\" \"P \\<turnstile> Us [\\<le>] take n ST\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> take n stk [:\\<le>] take n ST\n\ngoal (1 subgoal):\n 1. (\\<And>Us.\n        \\<lbrakk>map typeof\\<^bsub>h\\<^esub> (take n stk) = map Some Us;\n         P \\<turnstile> Us [\\<le>] take n ST\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: confs_conv_map)"], ["proof (state)\nthis:\n  map typeof\\<^bsub>h\\<^esub> (take n stk) = map Some Us\n  P \\<turnstile> Us [\\<le>] take n ST\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "hence Us: \"map typeof\\<^bsub>h\\<^esub> (rev (take n stk)) = map Some (rev Us)\" \"P \\<turnstile> rev Us [\\<le>] rev (take n ST)\""], ["proof (prove)\nusing this:\n  map typeof\\<^bsub>h\\<^esub> (take n stk) = map Some Us\n  P \\<turnstile> Us [\\<le>] take n ST\n\ngoal (1 subgoal):\n 1. map typeof\\<^bsub>h\\<^esub> (rev (take n stk)) = map Some (rev Us) &&&\n    P \\<turnstile> rev Us [\\<le>] rev (take n ST)", "by- (simp only: rev_map[symmetric], simp)"], ["proof (state)\nthis:\n  map typeof\\<^bsub>h\\<^esub> (rev (take n stk)) = map Some (rev Us)\n  P \\<turnstile> rev Us [\\<le>] rev (take n ST)\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from \\<open>P \\<turnstile> rev Us [\\<le>] rev (take n ST)\\<close> Ts Ts'"], ["proof (chain)\npicking this:\n  P \\<turnstile> rev Us [\\<le>] rev (take n ST)\n  P \\<turnstile> rev (take n ST) [\\<le>] TTs\n  P \\<turnstile> TTs [\\<le>] Ts'", "have \"P \\<turnstile> rev Us [\\<le>] Ts'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> rev Us [\\<le>] rev (take n ST)\n  P \\<turnstile> rev (take n ST) [\\<le>] TTs\n  P \\<turnstile> TTs [\\<le>] Ts'\n\ngoal (1 subgoal):\n 1. P \\<turnstile> rev Us [\\<le>] Ts'", "by(blast intro: widens_trans)"], ["proof (state)\nthis:\n  P \\<turnstile> rev Us [\\<le>] Ts'\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with obj \\<open>map typeof\\<^bsub>h\\<^esub> (rev (take n stk)) = map Some (rev Us)\\<close> C' m_C'"], ["proof (chain)\npicking this:\n  typeof_addr h a = \\<lfloor>U\\<rfloor>\n  map typeof\\<^bsub>h\\<^esub> (rev (take n stk)) = map Some (rev Us)\n  class_type_of' (ty_of_htype U) = \\<lfloor>C'\\<rfloor>\n  P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = meth' in D''\n  P \\<turnstile> rev Us [\\<le>] Ts'", "have wtext': \"P,h \\<turnstile> a\\<bullet>M'(rev (take n stk)) : T'\""], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>U\\<rfloor>\n  map typeof\\<^bsub>h\\<^esub> (rev (take n stk)) = map Some (rev Us)\n  class_type_of' (ty_of_htype U) = \\<lfloor>C'\\<rfloor>\n  P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = meth' in D''\n  P \\<turnstile> rev Us [\\<le>] Ts'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> a\\<bullet>M'(rev (take n stk)) : T'", "by(simp add: external_WT'.intros)"], ["proof (state)\nthis:\n  P,h \\<turnstile> a\\<bullet>M'(rev (take n stk)) : T'\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from va"], ["proof (chain)\npicking this:\n  (tas', va, h') \\<in> red_external_aggr P t a M' (rev (take n stk)) h", "have va': \"P,t \\<turnstile> \\<langle>a\\<bullet>M'(rev (take n stk)),h\\<rangle> -tas'\\<rightarrow>ext \\<langle>va,h'\\<rangle>\""], ["proof (prove)\nusing this:\n  (tas', va, h') \\<in> red_external_aggr P t a M' (rev (take n stk)) h\n\ngoal (1 subgoal):\n 1. P,t \\<turnstile> \\<langle>a\\<bullet>M'(rev (take n stk)),\n                     h\\<rangle> -tas'\\<rightarrow>ext \\<langle>va,\n                h'\\<rangle>", "by(unfold WT_red_external_list_conv[OF wfprog wtext' tconf])"], ["proof (state)\nthis:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M'(rev (take n stk)),\n                   h\\<rangle> -tas'\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with heap_ok wtext' tconf wfprog"], ["proof (chain)\npicking this:\n  hconf h\n  P,h \\<turnstile> a\\<bullet>M'(rev (take n stk)) : T'\n  P,h \\<turnstile> t \\<surd>t\n  wf_prog wfmb P\n  P,t \\<turnstile> \\<langle>a\\<bullet>M'(rev (take n stk)),\n                   h\\<rangle> -tas'\\<rightarrow>ext \\<langle>va,h'\\<rangle>", "have heap_ok': \"hconf h'\""], ["proof (prove)\nusing this:\n  hconf h\n  P,h \\<turnstile> a\\<bullet>M'(rev (take n stk)) : T'\n  P,h \\<turnstile> t \\<surd>t\n  wf_prog wfmb P\n  P,t \\<turnstile> \\<langle>a\\<bullet>M'(rev (take n stk)),\n                   h\\<rangle> -tas'\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (1 subgoal):\n 1. hconf h'", "by(auto dest: external_call_hconf)"], ["proof (state)\nthis:\n  hconf h'\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "have ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "proof(cases va)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       va = RetVal x1 \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<And>x2.\n       va = RetExc x2 \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 3. va = RetStaySame \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "case (RetExc a')"], ["proof (state)\nthis:\n  va = RetExc a'\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       va = RetVal x1 \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<And>x2.\n       va = RetExc x2 \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 3. va = RetStaySame \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from frame hext"], ["proof (chain)\npicking this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  h \\<unlhd> h'", "have \"conf_f P h' (ST, LT) ins (stk, loc, C, M, pc)\""], ["proof (prove)\nusing this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. conf_f P h' (ST, LT) ins (stk, loc, C, M, pc)", "by(rule conf_f_hext)"], ["proof (state)\nthis:\n  conf_f P h' (ST, LT) ins (stk, loc, C, M, pc)\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       va = RetVal x1 \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<And>x2.\n       va = RetExc x2 \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 3. va = RetStaySame \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with \\<sigma> tconf' heap_ok' meth_C \\<Phi>_pc frames' RetExc red_external_conf_extRet[OF wfprog va' wtext' heap_ok preh tconf] ins preh'"], ["proof (chain)\npicking this:\n  \\<sigma> = extRet2JVM n h' stk loc C M pc frs va\n  P,h' \\<turnstile> t \\<surd>t\n  hconf h'\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  conf_fs P h' \\<Phi> M (length Ts) T frs\n  va = RetExc a'\n  conf_extRet P h' va T'\n  ins ! pc = Invoke M' n\n  preallocated h'\n  conf_f P h' (ST, LT) ins (stk, loc, C, M, pc)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<sigma> = extRet2JVM n h' stk loc C M pc frs va\n  P,h' \\<turnstile> t \\<surd>t\n  hconf h'\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  conf_fs P h' \\<Phi> M (length Ts) T frs\n  va = RetExc a'\n  conf_extRet P h' va T'\n  ins ! pc = Invoke M' n\n  preallocated h'\n  conf_f P h' (ST, LT) ins (stk, loc, C, M, pc)\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "by(fastforce simp add: conf_def widen_Class)"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       va = RetVal x1 \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. va = RetStaySame \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       va = RetVal x1 \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. va = RetStaySame \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "case RetStaySame"], ["proof (state)\nthis:\n  va = RetStaySame\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       va = RetVal x1 \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. va = RetStaySame \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from frame hext"], ["proof (chain)\npicking this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  h \\<unlhd> h'", "have \"conf_f P h' (ST, LT) ins (stk, loc, C, M, pc)\""], ["proof (prove)\nusing this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. conf_f P h' (ST, LT) ins (stk, loc, C, M, pc)", "by(rule conf_f_hext)"], ["proof (state)\nthis:\n  conf_f P h' (ST, LT) ins (stk, loc, C, M, pc)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       va = RetVal x1 \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. va = RetStaySame \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with \\<sigma> heap_ok' meth_C \\<Phi>_pc RetStaySame frames' tconf' preh'"], ["proof (chain)\npicking this:\n  \\<sigma> = extRet2JVM n h' stk loc C M pc frs va\n  hconf h'\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  va = RetStaySame\n  conf_fs P h' \\<Phi> M (length Ts) T frs\n  P,h' \\<turnstile> t \\<surd>t\n  preallocated h'\n  conf_f P h' (ST, LT) ins (stk, loc, C, M, pc)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<sigma> = extRet2JVM n h' stk loc C M pc frs va\n  hconf h'\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  va = RetStaySame\n  conf_fs P h' \\<Phi> M (length Ts) T frs\n  P,h' \\<turnstile> t \\<surd>t\n  preallocated h'\n  conf_f P h' (ST, LT) ins (stk, loc, C, M, pc)\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "by fastforce"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       va = RetVal x1 \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1.\n       va = RetVal x1 \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "case (RetVal v)"], ["proof (state)\nthis:\n  va = RetVal v\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       va = RetVal x1 \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with \\<sigma>"], ["proof (chain)\npicking this:\n  \\<sigma> = extRet2JVM n h' stk loc C M pc frs va\n  va = RetVal v", "have \\<sigma>: \"\\<sigma> = (None, h', (v # drop (n+1) stk, loc, C, M, pc+1) # frs)\""], ["proof (prove)\nusing this:\n  \\<sigma> = extRet2JVM n h' stk loc C M pc frs va\n  va = RetVal v\n\ngoal (1 subgoal):\n 1. \\<sigma> = (None, h', (v # drop (n + 1) stk, loc, C, M, pc + 1) # frs)", "by simp"], ["proof (state)\nthis:\n  \\<sigma> = (None, h', (v # drop (n + 1) stk, loc, C, M, pc + 1) # frs)\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       va = RetVal x1 \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from heap_ok wtext' va' RetVal preh tconf"], ["proof (chain)\npicking this:\n  hconf h\n  P,h \\<turnstile> a\\<bullet>M'(rev (take n stk)) : T'\n  P,t \\<turnstile> \\<langle>a\\<bullet>M'(rev (take n stk)),\n                   h\\<rangle> -tas'\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n  va = RetVal v\n  preallocated h\n  P,h \\<turnstile> t \\<surd>t", "have \"P,h' \\<turnstile> v :\\<le> T'\""], ["proof (prove)\nusing this:\n  hconf h\n  P,h \\<turnstile> a\\<bullet>M'(rev (take n stk)) : T'\n  P,t \\<turnstile> \\<langle>a\\<bullet>M'(rev (take n stk)),\n                   h\\<rangle> -tas'\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n  va = RetVal v\n  preallocated h\n  P,h \\<turnstile> t \\<surd>t\n\ngoal (1 subgoal):\n 1. P,h' \\<turnstile> v :\\<le> T'", "by(auto dest: red_external_conf_extRet[OF wfprog])"], ["proof (state)\nthis:\n  P,h' \\<turnstile> v :\\<le> T'\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       va = RetVal x1 \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from stk"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST", "have \"P,h \\<turnstile> drop (n + 1) stk [:\\<le>] drop (n+1) ST\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> drop (n + 1) stk [:\\<le>] drop (n + 1) ST", "by(rule list_all2_dropI)"], ["proof (state)\nthis:\n  P,h \\<turnstile> drop (n + 1) stk [:\\<le>] drop (n + 1) ST\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       va = RetVal x1 \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "hence \"P,h' \\<turnstile> drop (n + 1) stk [:\\<le>] drop (n+1) ST\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> drop (n + 1) stk [:\\<le>] drop (n + 1) ST\n\ngoal (1 subgoal):\n 1. P,h' \\<turnstile> drop (n + 1) stk [:\\<le>] drop (n + 1) ST", "using hext"], ["proof (prove)\nusing this:\n  P,h \\<turnstile> drop (n + 1) stk [:\\<le>] drop (n + 1) ST\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. P,h' \\<turnstile> drop (n + 1) stk [:\\<le>] drop (n + 1) ST", "by(rule confs_hext)"], ["proof (state)\nthis:\n  P,h' \\<turnstile> drop (n + 1) stk [:\\<le>] drop (n + 1) ST\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       va = RetVal x1 \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with \\<open>P,h' \\<turnstile> v :\\<le> T'\\<close>"], ["proof (chain)\npicking this:\n  P,h' \\<turnstile> v :\\<le> T'\n  P,h' \\<turnstile> drop (n + 1) stk [:\\<le>] drop (n + 1) ST", "have \"P,h' \\<turnstile> v # drop (n + 1) stk [:\\<le>] T' # drop (n+1) ST\""], ["proof (prove)\nusing this:\n  P,h' \\<turnstile> v :\\<le> T'\n  P,h' \\<turnstile> drop (n + 1) stk [:\\<le>] drop (n + 1) ST\n\ngoal (1 subgoal):\n 1. P,h' \\<turnstile> v # drop (n + 1) stk [:\\<le>] T' # drop (n + 1) ST", "by(auto simp add: conf_def intro: widen_trans)"], ["proof (state)\nthis:\n  P,h' \\<turnstile> v # drop (n + 1) stk [:\\<le>] T' # drop (n + 1) ST\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       va = RetVal x1 \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "also"], ["proof (state)\nthis:\n  P,h' \\<turnstile> v # drop (n + 1) stk [:\\<le>] T' # drop (n + 1) ST\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       va = RetVal x1 \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with NT ins wti \\<Phi>_pc \\<Phi>' nec False D m_D T'"], ["proof (chain)\npicking this:\n  ST ! n \\<noteq> NT\n  ins ! pc = Invoke M' n\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  is_native P U M'\n  stk ! n \\<noteq> Null\n  class_type_of' (ST ! n) = \\<lfloor>D\\<rfloor>\n  P \\<turnstile> D sees M': TTs\\<rightarrow>TT = m in D'\n  P \\<turnstile> T' \\<le> TT\n  P,h' \\<turnstile> v # drop (n + 1) stk [:\\<le>] T' # drop (n + 1) ST", "have \"P \\<turnstile> (T' # drop (n + 1) ST) [\\<le>] ST'\""], ["proof (prove)\nusing this:\n  ST ! n \\<noteq> NT\n  ins ! pc = Invoke M' n\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  is_native P U M'\n  stk ! n \\<noteq> Null\n  class_type_of' (ST ! n) = \\<lfloor>D\\<rfloor>\n  P \\<turnstile> D sees M': TTs\\<rightarrow>TT = m in D'\n  P \\<turnstile> T' \\<le> TT\n  P,h' \\<turnstile> v # drop (n + 1) stk [:\\<le>] T' # drop (n + 1) ST\n\ngoal (1 subgoal):\n 1. P \\<turnstile> (T' # drop (n + 1) ST) [\\<le>] ST'", "by(auto dest: sees_method_fun intro: widen_trans)"], ["proof (state)\nthis:\n  P \\<turnstile> (T' # drop (n + 1) ST) [\\<le>] ST'\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       va = RetVal x1 \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "also"], ["proof (state)\nthis:\n  P \\<turnstile> (T' # drop (n + 1) ST) [\\<le>] ST'\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       va = RetVal x1 \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from loc hext"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  h \\<unlhd> h'", "have \"P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT", "by(rule confTs_hext)"], ["proof (state)\nthis:\n  P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       va = RetVal x1 \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "hence \"P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\""], ["proof (prove)\nusing this:\n  P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n\ngoal (1 subgoal):\n 1. P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'", "using LT'"], ["proof (prove)\nusing this:\n  P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'", "by(rule confTs_widen)"], ["proof (state)\nthis:\n  P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       va = RetVal x1 \\<Longrightarrow>\n       \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "ultimately"], ["proof (chain)\npicking this:\n  P,h' \\<turnstile> v # drop (n + 1) stk [:\\<le>] ST'\n  P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'", "show ?thesis"], ["proof (prove)\nusing this:\n  P,h' \\<turnstile> v # drop (n + 1) stk [:\\<le>] ST'\n  P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "using \\<open>hconf h'\\<close> \\<sigma> meth_C \\<Phi>' pc' frames' tconf' preh'"], ["proof (prove)\nusing this:\n  P,h' \\<turnstile> v # drop (n + 1) stk [:\\<le>] ST'\n  P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  hconf h'\n  \\<sigma> = (None, h', (v # drop (n + 1) stk, loc, C, M, pc + 1) # frs)\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  pc + 1 < length ins\n  conf_fs P h' \\<Phi> M (length Ts) T frs\n  P,h' \\<turnstile> t \\<surd>t\n  preallocated h'\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "by fastforce"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "}"], ["proof (state)\nthis:\n  meth' = None \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "ultimately"], ["proof (chain)\npicking this:\n  meth' =\n  \\<lfloor>(?mxs'17, ?mxl'17, ?ins'17, ?xt'17)\\<rfloor> \\<Longrightarrow>\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n  meth' = None \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "show ?thesis"], ["proof (prove)\nusing this:\n  meth' =\n  \\<lfloor>(?mxs'17, ?mxl'17, ?ins'17, ?xt'17)\\<rfloor> \\<Longrightarrow>\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n  meth' = None \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "by(cases meth') auto"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "declare list_all2_Cons2 [iff]"], ["", "lemma Return_correct:\n  assumes wt_prog: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes meth: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C\"\n  assumes ins: \"ins ! pc = Return\"\n  assumes wt: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes correct: \"\\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  assumes s': \"(tas, \\<sigma>') \\<in> exec P t (None, h, (stk,loc,C,M,pc)#frs)\"\n  shows \"\\<Phi> \\<turnstile> t:\\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from wt_prog"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P", "obtain wfmb where wf: \"wf_prog wfmb P\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n\ngoal (1 subgoal):\n 1. (\\<And>wfmb. wf_prog wfmb P \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: wf_jvm_prog_phi_def)"], ["proof (state)\nthis:\n  wf_prog wfmb P\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from meth ins s' correct"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  ins ! pc = Return\n  (tas, \\<sigma>') \\<in> exec P t (None, h, (stk, loc, C, M, pc) # frs)\n  \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>", "have \"frs = [] \\<Longrightarrow> ?thesis\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  ins ! pc = Return\n  (tas, \\<sigma>') \\<in> exec P t (None, h, (stk, loc, C, M, pc) # frs)\n  \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>\n\ngoal (1 subgoal):\n 1. frs = [] \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "by (simp add: correct_state_def)"], ["proof (state)\nthis:\n  frs = [] \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "moreover"], ["proof (state)\nthis:\n  frs = [] \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "{"], ["proof (state)\nthis:\n  frs = [] \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "fix f frs'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "assume frs': \"frs = f#frs'\""], ["proof (state)\nthis:\n  frs = f # frs'\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "moreover"], ["proof (state)\nthis:\n  frs = f # frs'\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "obtain stk' loc' C' M' pc' where \n      f: \"f = (stk',loc',C',M',pc')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>stk' loc' C' M' pc'.\n        f = (stk', loc', C', M', pc') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases f)"], ["proof (state)\nthis:\n  f = (stk', loc', C', M', pc')\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "moreover"], ["proof (state)\nthis:\n  f = (stk', loc', C', M', pc')\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "note meth ins s'"], ["proof (state)\nthis:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  ins ! pc = Return\n  (tas, \\<sigma>') \\<in> exec P t (None, h, (stk, loc, C, M, pc) # frs)\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "ultimately"], ["proof (chain)\npicking this:\n  frs = f # frs'\n  f = (stk', loc', C', M', pc')\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  ins ! pc = Return\n  (tas, \\<sigma>') \\<in> exec P t (None, h, (stk, loc, C, M, pc) # frs)", "have \\<sigma>':\n      \"\\<sigma>' = (None,h,(hd stk#(drop (1+size Ts) stk'),loc',C',M',pc'+1)#frs')\"\n      (is \"\\<sigma>' = (None,h,?f'#frs')\")"], ["proof (prove)\nusing this:\n  frs = f # frs'\n  f = (stk', loc', C', M', pc')\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  ins ! pc = Return\n  (tas, \\<sigma>') \\<in> exec P t (None, h, (stk, loc, C, M, pc) # frs)\n\ngoal (1 subgoal):\n 1. \\<sigma>' =\n    (None, h,\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1) # frs')", "by simp"], ["proof (state)\nthis:\n  \\<sigma>' =\n  (None, h,\n   (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1) # frs')\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from correct meth"], ["proof (chain)\npicking this:\n  \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C", "obtain ST LT where\n      h_ok:   \"hconf h\" and\n      tconf: \"P,h \\<turnstile> t \\<surd>t\" and\n      \\<Phi>_pc: \"\\<Phi> C M ! pc = Some (ST, LT)\" and\n      frame:  \"conf_f P h (ST, LT) ins (stk,loc,C,M,pc)\" and\n      frames: \"conf_fs P h \\<Phi> M (size Ts) T frs\" and\n      preh: \"preallocated h\""], ["proof (prove)\nusing this:\n  \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>hconf h; P,h \\<turnstile> t \\<surd>t;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         conf_f P h (ST, LT) ins (stk, loc, C, M, pc);\n         conf_fs P h \\<Phi> M (length Ts) T frs; preallocated h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: sees_method_fun)"], ["proof (state)\nthis:\n  hconf h\n  P,h \\<turnstile> t \\<surd>t\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  preallocated h\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from \\<Phi>_pc ins wt"], ["proof (chain)\npicking this:\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  ins ! pc = Return\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M", "obtain U ST\\<^sub>0 where \"ST = U # ST\\<^sub>0\" \"P \\<turnstile> U \\<le> T\""], ["proof (prove)\nusing this:\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  ins ! pc = Return\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n\ngoal (1 subgoal):\n 1. (\\<And>U ST\\<^sub>0.\n        \\<lbrakk>ST = U # ST\\<^sub>0; P \\<turnstile> U \\<le> T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: wt_instr_def app_def) blast"], ["proof (state)\nthis:\n  ST = U # ST\\<^sub>0\n  P \\<turnstile> U \\<le> T\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "with wf frame"], ["proof (chain)\npicking this:\n  wf_prog wfmb P\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  ST = U # ST\\<^sub>0\n  P \\<turnstile> U \\<le> T", "have hd_stk: \"P,h \\<turnstile> hd stk :\\<le> T\""], ["proof (prove)\nusing this:\n  wf_prog wfmb P\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  ST = U # ST\\<^sub>0\n  P \\<turnstile> U \\<le> T\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> hd stk :\\<le> T", "by (auto simp add: conf_f_def)"], ["proof (state)\nthis:\n  P,h \\<turnstile> hd stk :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from f frs' frames"], ["proof (chain)\npicking this:\n  f = (stk', loc', C', M', pc')\n  frs = f # frs'\n  conf_fs P h \\<Phi> M (length Ts) T frs", "obtain ST' LT' Ts'' T'' mxs' mxl\\<^sub>0' ins' xt' Ts' T' where\n      \\<Phi>': \"\\<Phi> C' M' ! pc' = Some (ST', LT')\" and\n      meth_C':  \"P \\<turnstile> C' sees M':Ts''\\<rightarrow>T''=\\<lfloor>(mxs',mxl\\<^sub>0',ins',xt')\\<rfloor> in C'\" and\n      ins': \"ins' ! pc' = Invoke M (size Ts)\" and\n      D: \"\\<exists>D m D'. class_type_of' (ST' ! (size Ts)) = Some D \\<and> P \\<turnstile> D sees M: Ts'\\<rightarrow>T' = m in D'\" and\n      T': \"P \\<turnstile> T \\<le> T'\" and\n      frame':   \"conf_f P h (ST',LT') ins' f\" and\n      conf_fs:  \"conf_fs P h \\<Phi> M' (size Ts'') T'' frs'\""], ["proof (prove)\nusing this:\n  f = (stk', loc', C', M', pc')\n  frs = f # frs'\n  conf_fs P h \\<Phi> M (length Ts) T frs\n\ngoal (1 subgoal):\n 1. (\\<And>ST' LT' Ts'' T'' mxs' mxl\\<^sub>0' ins' xt' Ts' T'.\n        \\<lbrakk>\\<Phi> C' M' ! pc' = \\<lfloor>(ST', LT')\\<rfloor>;\n         P \\<turnstile> C' sees M': Ts''\\<rightarrow>T'' = \\<lfloor>(mxs',\n                               mxl\\<^sub>0', ins', xt')\\<rfloor> in C';\n         ins' ! pc' = Invoke M (length Ts);\n         \\<exists>D m D'.\n            class_type_of' (ST' ! length Ts) = \\<lfloor>D\\<rfloor> \\<and>\n            P \\<turnstile> D sees M: Ts'\\<rightarrow>T' = m in D';\n         P \\<turnstile> T \\<le> T'; conf_f P h (ST', LT') ins' f;\n         conf_fs P h \\<Phi> M' (length Ts'') T'' frs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by clarsimp blast"], ["proof (state)\nthis:\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> C' sees M': Ts''\\<rightarrow>T'' = \\<lfloor>(mxs',\n                        mxl\\<^sub>0', ins', xt')\\<rfloor> in C'\n  ins' ! pc' = Invoke M (length Ts)\n  \\<exists>D m D'.\n     class_type_of' (ST' ! length Ts) = \\<lfloor>D\\<rfloor> \\<and>\n     P \\<turnstile> D sees M: Ts'\\<rightarrow>T' = m in D'\n  P \\<turnstile> T \\<le> T'\n  conf_f P h (ST', LT') ins' f\n  conf_fs P h \\<Phi> M' (length Ts'') T'' frs'\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from f frame'"], ["proof (chain)\npicking this:\n  f = (stk', loc', C', M', pc')\n  conf_f P h (ST', LT') ins' f", "obtain\n      stk': \"P,h \\<turnstile> stk' [:\\<le>] ST'\" and\n      loc': \"P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT'\" and\n      pc':  \"pc' < size ins'\""], ["proof (prove)\nusing this:\n  f = (stk', loc', C', M', pc')\n  conf_f P h (ST', LT') ins' f\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>P,h \\<turnstile> stk' [:\\<le>] ST';\n      P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT';\n      pc' < length ins'\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: conf_f_def)"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT'\n  pc' < length ins'\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from wt_prog meth_C' pc'"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> C' sees M': Ts''\\<rightarrow>T'' = \\<lfloor>(mxs',\n                        mxl\\<^sub>0', ins', xt')\\<rfloor> in C'\n  pc' < length ins'", "have wti: \"P,T'',mxs',size ins',xt' \\<turnstile> ins'!pc',pc' :: \\<Phi> C' M'\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> C' sees M': Ts''\\<rightarrow>T'' = \\<lfloor>(mxs',\n                        mxl\\<^sub>0', ins', xt')\\<rfloor> in C'\n  pc' < length ins'\n\ngoal (1 subgoal):\n 1. P,T'',mxs',length ins',xt' \\<turnstile> ins' ! pc',pc' :: \\<Phi> C' M'", "by (rule wt_jvm_prog_impl_wt_instr)"], ["proof (state)\nthis:\n  P,T'',mxs',length ins',xt' \\<turnstile> ins' ! pc',pc' :: \\<Phi> C' M'\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "obtain aTs ST'' LT'' where\n      \\<Phi>_suc:   \"\\<Phi> C' M' ! Suc pc' = Some (ST'', LT'')\" and\n      less:    \"P \\<turnstile> (T' # drop (size Ts+1) ST', LT') \\<le>\\<^sub>i (ST'', LT'')\" and\n      suc_pc': \"Suc pc' < size ins'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ST'' LT''.\n        \\<lbrakk>\\<Phi> C' M' ! Suc pc' = \\<lfloor>(ST'', LT'')\\<rfloor>;\n         P \\<turnstile> (T' # drop (length Ts + 1) ST',\n                         LT') \\<le>\\<^sub>i (ST'', LT'');\n         Suc pc' < length ins'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ins' \\<Phi>' D T' wti"], ["proof (prove)\nusing this:\n  ins' ! pc' = Invoke M (length Ts)\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  \\<exists>D m D'.\n     class_type_of' (ST' ! length Ts) = \\<lfloor>D\\<rfloor> \\<and>\n     P \\<turnstile> D sees M: Ts'\\<rightarrow>T' = m in D'\n  P \\<turnstile> T \\<le> T'\n  P,T'',mxs',length ins',xt' \\<turnstile> ins' ! pc',pc' :: \\<Phi> C' M'\n\ngoal (1 subgoal):\n 1. (\\<And>ST'' LT''.\n        \\<lbrakk>\\<Phi> C' M' ! Suc pc' = \\<lfloor>(ST'', LT'')\\<rfloor>;\n         P \\<turnstile> (T' # drop (length Ts + 1) ST',\n                         LT') \\<le>\\<^sub>i (ST'', LT'');\n         Suc pc' < length ins'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp add: sup_state_opt_any_Some split: if_split_asm)"], ["proof (state)\nthis:\n  \\<Phi> C' M' ! Suc pc' = \\<lfloor>(ST'', LT'')\\<rfloor>\n  P \\<turnstile> (T' # drop (length Ts + 1) ST',\n                  LT') \\<le>\\<^sub>i (ST'', LT'')\n  Suc pc' < length ins'\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from hd_stk T'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> hd stk :\\<le> T\n  P \\<turnstile> T \\<le> T'", "have hd_stk': \"P,h \\<turnstile> hd stk :\\<le> T'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> hd stk :\\<le> T\n  P \\<turnstile> T \\<le> T'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> hd stk :\\<le> T'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> hd stk :\\<le> T'\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "have frame'':\n      \"conf_f P h (ST'',LT'') ins' ?f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_f P h (ST'', LT'') ins'\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. conf_f P h (ST'', LT'') ins'\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1)", "from stk'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk' [:\\<le>] ST'", "have \"P,h \\<turnstile> drop (1+size Ts) stk' [:\\<le>] drop (1+size Ts) ST'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> drop (1 + length Ts)\n                      stk' [:\\<le>] drop (1 + length Ts) ST'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> drop (1 + length Ts)\n                    stk' [:\\<le>] drop (1 + length Ts) ST'\n\ngoal (1 subgoal):\n 1. conf_f P h (ST'', LT'') ins'\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1)", "moreover"], ["proof (state)\nthis:\n  P,h \\<turnstile> drop (1 + length Ts)\n                    stk' [:\\<le>] drop (1 + length Ts) ST'\n\ngoal (1 subgoal):\n 1. conf_f P h (ST'', LT'') ins'\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1)", "with hd_stk' less"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> hd stk :\\<le> T'\n  P \\<turnstile> (T' # drop (length Ts + 1) ST',\n                  LT') \\<le>\\<^sub>i (ST'', LT'')\n  P,h \\<turnstile> drop (1 + length Ts)\n                    stk' [:\\<le>] drop (1 + length Ts) ST'", "have \"P,h \\<turnstile> hd stk # drop (1+size Ts) stk' [:\\<le>] ST''\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> hd stk :\\<le> T'\n  P \\<turnstile> (T' # drop (length Ts + 1) ST',\n                  LT') \\<le>\\<^sub>i (ST'', LT'')\n  P,h \\<turnstile> drop (1 + length Ts)\n                    stk' [:\\<le>] drop (1 + length Ts) ST'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> hd stk # drop (1 + length Ts) stk' [:\\<le>] ST''", "by auto"], ["proof (state)\nthis:\n  P,h \\<turnstile> hd stk # drop (1 + length Ts) stk' [:\\<le>] ST''\n\ngoal (1 subgoal):\n 1. conf_f P h (ST'', LT'') ins'\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1)", "moreover"], ["proof (state)\nthis:\n  P,h \\<turnstile> hd stk # drop (1 + length Ts) stk' [:\\<le>] ST''\n\ngoal (1 subgoal):\n 1. conf_f P h (ST'', LT'') ins'\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1)", "from wf loc' less"], ["proof (chain)\npicking this:\n  wf_prog wfmb P\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT'\n  P \\<turnstile> (T' # drop (length Ts + 1) ST',\n                  LT') \\<le>\\<^sub>i (ST'', LT'')", "have \"P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT''\""], ["proof (prove)\nusing this:\n  wf_prog wfmb P\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT'\n  P \\<turnstile> (T' # drop (length Ts + 1) ST',\n                  LT') \\<le>\\<^sub>i (ST'', LT'')\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT''", "by auto"], ["proof (state)\nthis:\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT''\n\ngoal (1 subgoal):\n 1. conf_f P h (ST'', LT'') ins'\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1)", "moreover"], ["proof (state)\nthis:\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT''\n\ngoal (1 subgoal):\n 1. conf_f P h (ST'', LT'') ins'\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1)", "note suc_pc'"], ["proof (state)\nthis:\n  Suc pc' < length ins'\n\ngoal (1 subgoal):\n 1. conf_f P h (ST'', LT'') ins'\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1)", "ultimately"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> drop (1 + length Ts)\n                    stk' [:\\<le>] drop (1 + length Ts) ST'\n  P,h \\<turnstile> hd stk # drop (1 + length Ts) stk' [:\\<le>] ST''\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT''\n  Suc pc' < length ins'", "show ?thesis"], ["proof (prove)\nusing this:\n  P,h \\<turnstile> drop (1 + length Ts)\n                    stk' [:\\<le>] drop (1 + length Ts) ST'\n  P,h \\<turnstile> hd stk # drop (1 + length Ts) stk' [:\\<le>] ST''\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT''\n  Suc pc' < length ins'\n\ngoal (1 subgoal):\n 1. conf_f P h (ST'', LT'') ins'\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1)", "by (simp add: conf_f_def)"], ["proof (state)\nthis:\n  conf_f P h (ST'', LT'') ins'\n   (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  conf_f P h (ST'', LT'') ins'\n   (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1)\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "with \\<sigma>' frs' f meth h_ok hd_stk \\<Phi>_suc frames meth_C' \\<Phi>'  tconf preh"], ["proof (chain)\npicking this:\n  \\<sigma>' =\n  (None, h,\n   (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1) # frs')\n  frs = f # frs'\n  f = (stk', loc', C', M', pc')\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  hconf h\n  P,h \\<turnstile> hd stk :\\<le> T\n  \\<Phi> C' M' ! Suc pc' = \\<lfloor>(ST'', LT'')\\<rfloor>\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  P \\<turnstile> C' sees M': Ts''\\<rightarrow>T'' = \\<lfloor>(mxs',\n                        mxl\\<^sub>0', ins', xt')\\<rfloor> in C'\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  P,h \\<turnstile> t \\<surd>t\n  preallocated h\n  conf_f P h (ST'', LT'') ins'\n   (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1)", "have ?thesis"], ["proof (prove)\nusing this:\n  \\<sigma>' =\n  (None, h,\n   (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1) # frs')\n  frs = f # frs'\n  f = (stk', loc', C', M', pc')\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  hconf h\n  P,h \\<turnstile> hd stk :\\<le> T\n  \\<Phi> C' M' ! Suc pc' = \\<lfloor>(ST'', LT'')\\<rfloor>\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  P \\<turnstile> C' sees M': Ts''\\<rightarrow>T'' = \\<lfloor>(mxs',\n                        mxl\\<^sub>0', ins', xt')\\<rfloor> in C'\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  P,h \\<turnstile> t \\<surd>t\n  preallocated h\n  conf_f P h (ST'', LT'') ins'\n   (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1)\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "by (fastforce dest: sees_method_fun [of _ C'])"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "}"], ["proof (state)\nthis:\n  frs = ?f17 # ?frs'17 \\<Longrightarrow>\n  \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "ultimately"], ["proof (chain)\npicking this:\n  frs = [] \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n  frs = ?f17 # ?frs'17 \\<Longrightarrow>\n  \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "show ?thesis"], ["proof (prove)\nusing this:\n  frs = [] \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n  frs = ?f17 # ?frs'17 \\<Longrightarrow>\n  \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "by (cases frs) blast+"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "declare sup_state_opt_any_Some [iff]"], ["", "declare not_Err_eq [iff]"], ["", "lemma Load_correct:\n\"\\<lbrakk> wf_prog wt P;\n    P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C; \n    ins!pc = Load idx; \n    P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n    \\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd> ;\n    (tas, \\<sigma>') \\<in> exec P t (None, h, (stk,loc,C,M,pc)#frs) \\<rbrakk>\n\\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                     ins, xt)\\<rfloor> in C;\n     ins ! pc = Load idx;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n     (tas, \\<sigma>')\n     \\<in> exec P t (None, h, (stk, loc, C, M, pc) # frs)\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "by (fastforce dest: sees_method_fun [of _ C] elim!: confTs_confT_sup)"], ["", "declare [[simproc del: list_to_set_comprehension]]"], ["", "lemma Store_correct:\n\"\\<lbrakk> wf_prog wt P;\n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C;\n  ins!pc = Store idx;\n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M;\n  \\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>;\n  (tas, \\<sigma>') \\<in> exec P t (None, h, (stk,loc,C,M,pc)#frs) \\<rbrakk>\n\\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                     ins, xt)\\<rfloor> in C;\n     ins ! pc = Store idx;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n     (tas, \\<sigma>')\n     \\<in> exec P t (None, h, (stk, loc, C, M, pc) # frs)\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta ts ST LT z zs ab bb.\n       \\<lbrakk>wf_prog wt P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        ins ! pc = Store idx; P,h \\<turnstile> t \\<surd>t;\n        tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' = (None, h, (zs, loc[idx := z], C, M, Suc pc) # frs);\n        hconf h; preallocated h;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = \\<lfloor>(mxsa,\n                          mxl\\<^sub>0', is, xta)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(ts # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P (Store idx) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        idx < length LT; Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Store idx) P pc (ts # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        stk = z # zs;\n        \\<forall>x\\<in>set (xcpt_eff (Store idx) P pc (ts # ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        P,h \\<turnstile> z :\\<le> ts; P,h \\<turnstile> zs [:\\<le>] ST;\n        \\<Phi> C M ! Suc pc = \\<lfloor>(ab, bb)\\<rfloor>;\n        P \\<turnstile> ST [\\<le>] ab;\n        P \\<turnstile> LT[idx := OK ts] [\\<le>\\<^sub>\\<top>] bb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            P,h \\<turnstile> zs [:\\<le>] ab \\<and>\n                            P,h \\<turnstile> loc\n                            [idx := z] [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                            Suc pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs", "apply (drule (1) sees_method_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta ts ST LT z zs ab bb.\n       \\<lbrakk>wf_prog wt P; ins ! pc = Store idx;\n        P,h \\<turnstile> t \\<surd>t; tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' = (None, h, (zs, loc[idx := z], C, M, Suc pc) # frs);\n        hconf h; preallocated h;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = \\<lfloor>(mxsa,\n                          mxl\\<^sub>0', is, xta)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(ts # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P (Store idx) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        idx < length LT; Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Store idx) P pc (ts # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        stk = z # zs;\n        \\<forall>x\\<in>set (xcpt_eff (Store idx) P pc (ts # ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        P,h \\<turnstile> z :\\<le> ts; P,h \\<turnstile> zs [:\\<le>] ST;\n        \\<Phi> C M ! Suc pc = \\<lfloor>(ab, bb)\\<rfloor>;\n        P \\<turnstile> ST [\\<le>] ab;\n        P \\<turnstile> LT[idx := OK ts] [\\<le>\\<^sub>\\<top>] bb;\n        Tsa = Ts \\<and>\n        Ta = T \\<and>\n        \\<lfloor>(mxsa, mxl\\<^sub>0', is, xta)\\<rfloor> =\n        \\<lfloor>(mxs, mxl\\<^sub>0, ins, xt)\\<rfloor> \\<and>\n        C = C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            P,h \\<turnstile> zs [:\\<le>] ab \\<and>\n                            P,h \\<turnstile> loc\n                            [idx := z] [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                            Suc pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts ST LT z zs ab bb.\n       \\<lbrakk>wf_prog wt P; ins ! pc = Store idx;\n        P,h \\<turnstile> t \\<surd>t; tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' = (None, h, (zs, loc[idx := z], C, M, Suc pc) # frs);\n        hconf h; preallocated h;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(ts # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT;\n        conf_fs P h \\<Phi> M (length Ts) T frs;\n        \\<forall>x\\<in>set (relevant_entries P (Store idx) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        idx < length LT; Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Store idx) P pc (ts # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        stk = z # zs;\n        \\<forall>x\\<in>set (xcpt_eff (Store idx) P pc (ts # ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        P,h \\<turnstile> z :\\<le> ts; P,h \\<turnstile> zs [:\\<le>] ST;\n        \\<Phi> C M ! Suc pc = \\<lfloor>(ab, bb)\\<rfloor>;\n        P \\<turnstile> ST [\\<le>] ab;\n        P \\<turnstile> LT[idx := OK ts] [\\<le>\\<^sub>\\<top>] bb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            P,h \\<turnstile> zs [:\\<le>] ab \\<and>\n                            P,h \\<turnstile> loc\n                            [idx := z] [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                            Suc pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs", "apply (blast intro!: list_all2_update_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Push_correct:\n\"\\<lbrakk> wf_prog wt P;\n    P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C; \n    ins!pc = Push v;\n    P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n    \\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>; \n    (tas, \\<sigma>') \\<in> exec P t (None, h, (stk,loc,C,M,pc)#frs) \\<rbrakk>\n\\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                     ins, xt)\\<rfloor> in C;\n     ins ! pc = Push v;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n     (tas, \\<sigma>')\n     \\<in> exec P t (None, h, (stk, loc, C, M, pc) # frs)\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta ST LT y bb z zs.\n       \\<lbrakk>wf_prog wt P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        ins ! pc = Push v; P,h \\<turnstile> t \\<surd>t;\n        tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' = (None, h, (v # stk, loc, C, M, Suc pc) # frs); hconf h;\n        preallocated h;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = \\<lfloor>(mxsa,\n                          mxl\\<^sub>0', is, xta)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n        P,h \\<turnstile> stk [:\\<le>] ST;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P (Push v) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> length ST \\<and> d < mxs);\n        Suc pc < length ins; length ST < mxs;\n        typeof v = \\<lfloor>y\\<rfloor>;\n        \\<forall>x\\<in>set (xcpt_eff (Push v) P pc (ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Push v) P pc (ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        \\<Phi> C M ! Suc pc = \\<lfloor>(z # zs, bb)\\<rfloor>;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] bb; P \\<turnstile> y \\<le> z;\n        P \\<turnstile> ST [\\<le>] zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            P,h \\<turnstile> v :\\<le> z \\<and>\n                            P,h \\<turnstile> stk [:\\<le>] zs \\<and>\n                            P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                            Suc pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs", "apply (drule (1) sees_method_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta ST LT y bb z zs.\n       \\<lbrakk>wf_prog wt P; ins ! pc = Push v;\n        P,h \\<turnstile> t \\<surd>t; tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' = (None, h, (v # stk, loc, C, M, Suc pc) # frs); hconf h;\n        preallocated h;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = \\<lfloor>(mxsa,\n                          mxl\\<^sub>0', is, xta)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n        P,h \\<turnstile> stk [:\\<le>] ST;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P (Push v) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> length ST \\<and> d < mxs);\n        Suc pc < length ins; length ST < mxs;\n        typeof v = \\<lfloor>y\\<rfloor>;\n        \\<forall>x\\<in>set (xcpt_eff (Push v) P pc (ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Push v) P pc (ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        \\<Phi> C M ! Suc pc = \\<lfloor>(z # zs, bb)\\<rfloor>;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] bb; P \\<turnstile> y \\<le> z;\n        P \\<turnstile> ST [\\<le>] zs;\n        Tsa = Ts \\<and>\n        Ta = T \\<and>\n        \\<lfloor>(mxsa, mxl\\<^sub>0', is, xta)\\<rfloor> =\n        \\<lfloor>(mxs, mxl\\<^sub>0, ins, xt)\\<rfloor> \\<and>\n        C = C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            P,h \\<turnstile> v :\\<le> z \\<and>\n                            P,h \\<turnstile> stk [:\\<le>] zs \\<and>\n                            P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                            Suc pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ST LT y bb z zs.\n       \\<lbrakk>wf_prog wt P; ins ! pc = Push v;\n        P,h \\<turnstile> t \\<surd>t; tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' = (None, h, (v # stk, loc, C, M, Suc pc) # frs); hconf h;\n        preallocated h;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n        P,h \\<turnstile> stk [:\\<le>] ST;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT;\n        conf_fs P h \\<Phi> M (length Ts) T frs;\n        \\<forall>x\\<in>set (relevant_entries P (Push v) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> length ST \\<and> d < mxs);\n        Suc pc < length ins; length ST < mxs;\n        typeof v = \\<lfloor>y\\<rfloor>;\n        \\<forall>x\\<in>set (xcpt_eff (Push v) P pc (ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Push v) P pc (ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        \\<Phi> C M ! Suc pc = \\<lfloor>(z # zs, bb)\\<rfloor>;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] bb; P \\<turnstile> y \\<le> z;\n        P \\<turnstile> ST [\\<le>] zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            P,h \\<turnstile> v :\\<le> z \\<and>\n                            P,h \\<turnstile> stk [:\\<le>] zs \\<and>\n                            P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                            Suc pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs", "apply (blast dest: typeof_lit_conf)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare [[simproc add: list_to_set_comprehension]]"], ["", "lemma Checkcast_correct:\n\"\\<lbrakk> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n    P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C; \n    ins!pc = Checkcast D; \n    P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n    \\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>;\n    (tas, \\<sigma>) \\<in> exec_instr (ins!pc) P t h stk loc C M pc frs \\<rbrakk> \n\\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                     ins, xt)\\<rfloor> in C;\n     ins ! pc = Checkcast D;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n     (tas, \\<sigma>)\n     \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "using wf_preallocatedD[of \"\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt). wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C M)\" P h ClassCast]"], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_prog\n            (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n                wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n                 (\\<Phi> C M))\n            P;\n   preallocated h; ClassCast \\<in> sys_xcpts\\<rbrakk>\n  \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt ClassCast) =\n                    \\<lfloor>Class_type ClassCast\\<rfloor> \\<and>\n                    P \\<turnstile> ClassCast \\<preceq>\\<^sup>* Throwable\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                     ins, xt)\\<rfloor> in C;\n     ins ! pc = Checkcast D;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n     (tas, \\<sigma>)\n     \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "apply (clarsimp simp add: wf_jvm_prog_phi_def split: if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta ba Taa ST z zs.\n       \\<lbrakk>hconf h; preallocated h;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = \\<lfloor>(mxsa,\n                          mxl\\<^sub>0', is, xta)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(Taa # ST, ba)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] ba; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        P \\<turnstile> ClassCast \\<preceq>\\<^sup>* Throwable;\n        wf_prog\n         (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n             wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C M))\n         P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        ins ! pc = Checkcast D; P,h \\<turnstile> t \\<surd>t;\n        tas = \\<lbrace>\\<rbrace>;\n        P \\<turnstile> the (typeof\\<^bsub>h\\<^esub> z) \\<le> D; is_type P D;\n        \\<forall>x\\<in>set (relevant_entries P (Checkcast D) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Checkcast D) P pc (Taa # ST, ba) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>a b.\n           (a = Suc pc \\<and>\n            b = \\<lfloor>(D # ST, ba)\\<rfloor> \\<longrightarrow>\n            (\\<exists>a b.\n                \\<Phi> C M ! Suc pc = \\<lfloor>(a, b)\\<rfloor> \\<and>\n                (\\<exists>z zs.\n                    a = z # zs \\<and>\n                    P \\<turnstile> D \\<le> z \\<and>\n                    P \\<turnstile> ST [\\<le>] zs) \\<and>\n                P \\<turnstile> ba [\\<le>\\<^sub>\\<top>] b)) \\<and>\n           ((a, b)\n            \\<in> set (xcpt_eff (Checkcast D) P pc (Taa # ST, ba)\n                        xt) \\<longrightarrow>\n            P \\<turnstile> b \\<le>' \\<Phi> C M ! a);\n        \\<sigma> = (None, h, (z # zs, loc, C, M, Suc pc) # frs);\n        stk = z # zs; P,h \\<turnstile> z :\\<le> Taa;\n        P,h \\<turnstile> zs [:\\<le>] ST\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            (\\<exists>a b.\n                                \\<Phi> C M ! Suc pc =\n                                \\<lfloor>(a, b)\\<rfloor> \\<and>\n                                P,h \\<turnstile> z # zs [:\\<le>] a \\<and>\n                                P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] b \\<and>\n                                Suc pc < length is \\<and>\n                                conf_fs P h \\<Phi> M (length Ts) T frs)\n 2. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta ba Taa ST z zs.\n       \\<lbrakk>hconf h; preallocated h;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = \\<lfloor>(mxsa,\n                          mxl\\<^sub>0', is, xta)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(Taa # ST, ba)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] ba; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        P \\<turnstile> ClassCast \\<preceq>\\<^sup>* Throwable;\n        wf_prog\n         (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n             wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C M))\n         P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        ins ! pc = Checkcast D; P,h \\<turnstile> t \\<surd>t;\n        tas = \\<lbrace>\\<rbrace>;\n        \\<not> P \\<turnstile> the (typeof\\<^bsub>h\\<^esub> z) \\<le> D;\n        is_type P D;\n        \\<forall>x\\<in>set (relevant_entries P (Checkcast D) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Checkcast D) P pc (Taa # ST, ba) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>a b.\n           (a = Suc pc \\<and>\n            b = \\<lfloor>(D # ST, ba)\\<rfloor> \\<longrightarrow>\n            (\\<exists>a b.\n                \\<Phi> C M ! Suc pc = \\<lfloor>(a, b)\\<rfloor> \\<and>\n                (\\<exists>z zs.\n                    a = z # zs \\<and>\n                    P \\<turnstile> D \\<le> z \\<and>\n                    P \\<turnstile> ST [\\<le>] zs) \\<and>\n                P \\<turnstile> ba [\\<le>\\<^sub>\\<top>] b)) \\<and>\n           ((a, b)\n            \\<in> set (xcpt_eff (Checkcast D) P pc (Taa # ST, ba)\n                        xt) \\<longrightarrow>\n            P \\<turnstile> b \\<le>' \\<Phi> C M ! a);\n        \\<sigma> =\n        (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n         (z # zs, loc, C, M, pc) # frs);\n        stk = z # zs; P,h \\<turnstile> z :\\<le> Taa;\n        P,h \\<turnstile> zs [:\\<le>] ST\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs \\<and>\n                            (\\<forall>D'.\n                                P \\<turnstile> ClassCast \\<preceq>\\<^sup>* D' \\<longrightarrow>\n                                is_relevant_class (is ! pc) P D')", "apply(drule (1) sees_method_fun)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta ba Taa ST z zs.\n       \\<lbrakk>hconf h; preallocated h;\n        \\<Phi> C M ! pc = \\<lfloor>(Taa # ST, ba)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] ba; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        P \\<turnstile> ClassCast \\<preceq>\\<^sup>* Throwable;\n        wf_prog\n         (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n             wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C M))\n         P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        ins ! pc = Checkcast D; P,h \\<turnstile> t \\<surd>t;\n        tas = \\<lbrace>\\<rbrace>;\n        P \\<turnstile> the (typeof\\<^bsub>h\\<^esub> z) \\<le> D; is_type P D;\n        \\<forall>x\\<in>set (relevant_entries P (Checkcast D) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Checkcast D) P pc (Taa # ST, ba) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>a b.\n           (a = Suc pc \\<and>\n            b = \\<lfloor>(D # ST, ba)\\<rfloor> \\<longrightarrow>\n            (\\<exists>a b.\n                \\<Phi> C M ! Suc pc = \\<lfloor>(a, b)\\<rfloor> \\<and>\n                (\\<exists>z zs.\n                    a = z # zs \\<and>\n                    P \\<turnstile> D \\<le> z \\<and>\n                    P \\<turnstile> ST [\\<le>] zs) \\<and>\n                P \\<turnstile> ba [\\<le>\\<^sub>\\<top>] b)) \\<and>\n           ((a, b)\n            \\<in> set (xcpt_eff (Checkcast D) P pc (Taa # ST, ba)\n                        xt) \\<longrightarrow>\n            P \\<turnstile> b \\<le>' \\<Phi> C M ! a);\n        \\<sigma> = (None, h, (z # zs, loc, C, M, Suc pc) # frs);\n        stk = z # zs; P,h \\<turnstile> z :\\<le> Taa;\n        P,h \\<turnstile> zs [:\\<le>] ST;\n        Ts = Tsa \\<and>\n        T = Ta \\<and>\n        \\<lfloor>(mxs, mxl\\<^sub>0, ins, xt)\\<rfloor> =\n        \\<lfloor>(mxsa, mxl\\<^sub>0', is, xta)\\<rfloor> \\<and>\n        C = C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            (\\<exists>a b.\n                                \\<Phi> C M ! Suc pc =\n                                \\<lfloor>(a, b)\\<rfloor> \\<and>\n                                P,h \\<turnstile> z # zs [:\\<le>] a \\<and>\n                                P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] b \\<and>\n                                Suc pc < length is \\<and>\n                                conf_fs P h \\<Phi> M (length Ts) T frs)\n 2. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta ba Taa ST z zs.\n       \\<lbrakk>hconf h; preallocated h;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = \\<lfloor>(mxsa,\n                          mxl\\<^sub>0', is, xta)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(Taa # ST, ba)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] ba; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        P \\<turnstile> ClassCast \\<preceq>\\<^sup>* Throwable;\n        wf_prog\n         (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n             wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C M))\n         P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        ins ! pc = Checkcast D; P,h \\<turnstile> t \\<surd>t;\n        tas = \\<lbrace>\\<rbrace>;\n        \\<not> P \\<turnstile> the (typeof\\<^bsub>h\\<^esub> z) \\<le> D;\n        is_type P D;\n        \\<forall>x\\<in>set (relevant_entries P (Checkcast D) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Checkcast D) P pc (Taa # ST, ba) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>a b.\n           (a = Suc pc \\<and>\n            b = \\<lfloor>(D # ST, ba)\\<rfloor> \\<longrightarrow>\n            (\\<exists>a b.\n                \\<Phi> C M ! Suc pc = \\<lfloor>(a, b)\\<rfloor> \\<and>\n                (\\<exists>z zs.\n                    a = z # zs \\<and>\n                    P \\<turnstile> D \\<le> z \\<and>\n                    P \\<turnstile> ST [\\<le>] zs) \\<and>\n                P \\<turnstile> ba [\\<le>\\<^sub>\\<top>] b)) \\<and>\n           ((a, b)\n            \\<in> set (xcpt_eff (Checkcast D) P pc (Taa # ST, ba)\n                        xt) \\<longrightarrow>\n            P \\<turnstile> b \\<le>' \\<Phi> C M ! a);\n        \\<sigma> =\n        (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n         (z # zs, loc, C, M, pc) # frs);\n        stk = z # zs; P,h \\<turnstile> z :\\<le> Taa;\n        P,h \\<turnstile> zs [:\\<le>] ST\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs \\<and>\n                            (\\<forall>D'.\n                                P \\<turnstile> ClassCast \\<preceq>\\<^sup>* D' \\<longrightarrow>\n                                is_relevant_class (is ! pc) P D')", "apply(fastforce simp add: conf_def intro: widen_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta ba Taa ST z zs.\n       \\<lbrakk>hconf h; preallocated h;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = \\<lfloor>(mxsa,\n                          mxl\\<^sub>0', is, xta)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(Taa # ST, ba)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] ba; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        P \\<turnstile> ClassCast \\<preceq>\\<^sup>* Throwable;\n        wf_prog\n         (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n             wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C M))\n         P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        ins ! pc = Checkcast D; P,h \\<turnstile> t \\<surd>t;\n        tas = \\<lbrace>\\<rbrace>;\n        \\<not> P \\<turnstile> the (typeof\\<^bsub>h\\<^esub> z) \\<le> D;\n        is_type P D;\n        \\<forall>x\\<in>set (relevant_entries P (Checkcast D) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Checkcast D) P pc (Taa # ST, ba) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>a b.\n           (a = Suc pc \\<and>\n            b = \\<lfloor>(D # ST, ba)\\<rfloor> \\<longrightarrow>\n            (\\<exists>a b.\n                \\<Phi> C M ! Suc pc = \\<lfloor>(a, b)\\<rfloor> \\<and>\n                (\\<exists>z zs.\n                    a = z # zs \\<and>\n                    P \\<turnstile> D \\<le> z \\<and>\n                    P \\<turnstile> ST [\\<le>] zs) \\<and>\n                P \\<turnstile> ba [\\<le>\\<^sub>\\<top>] b)) \\<and>\n           ((a, b)\n            \\<in> set (xcpt_eff (Checkcast D) P pc (Taa # ST, ba)\n                        xt) \\<longrightarrow>\n            P \\<turnstile> b \\<le>' \\<Phi> C M ! a);\n        \\<sigma> =\n        (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n         (z # zs, loc, C, M, pc) # frs);\n        stk = z # zs; P,h \\<turnstile> z :\\<le> Taa;\n        P,h \\<turnstile> zs [:\\<le>] ST\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs \\<and>\n                            (\\<forall>D'.\n                                P \\<turnstile> ClassCast \\<preceq>\\<^sup>* D' \\<longrightarrow>\n                                is_relevant_class (is ! pc) P D')", "apply (drule (1) sees_method_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta ba Taa ST z zs.\n       \\<lbrakk>hconf h; preallocated h;\n        \\<Phi> C M ! pc = \\<lfloor>(Taa # ST, ba)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] ba; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        P \\<turnstile> ClassCast \\<preceq>\\<^sup>* Throwable;\n        wf_prog\n         (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n             wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C M))\n         P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        ins ! pc = Checkcast D; P,h \\<turnstile> t \\<surd>t;\n        tas = \\<lbrace>\\<rbrace>;\n        \\<not> P \\<turnstile> the (typeof\\<^bsub>h\\<^esub> z) \\<le> D;\n        is_type P D;\n        \\<forall>x\\<in>set (relevant_entries P (Checkcast D) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Checkcast D) P pc (Taa # ST, ba) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>a b.\n           (a = Suc pc \\<and>\n            b = \\<lfloor>(D # ST, ba)\\<rfloor> \\<longrightarrow>\n            (\\<exists>a b.\n                \\<Phi> C M ! Suc pc = \\<lfloor>(a, b)\\<rfloor> \\<and>\n                (\\<exists>z zs.\n                    a = z # zs \\<and>\n                    P \\<turnstile> D \\<le> z \\<and>\n                    P \\<turnstile> ST [\\<le>] zs) \\<and>\n                P \\<turnstile> ba [\\<le>\\<^sub>\\<top>] b)) \\<and>\n           ((a, b)\n            \\<in> set (xcpt_eff (Checkcast D) P pc (Taa # ST, ba)\n                        xt) \\<longrightarrow>\n            P \\<turnstile> b \\<le>' \\<Phi> C M ! a);\n        \\<sigma> =\n        (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n         (z # zs, loc, C, M, pc) # frs);\n        stk = z # zs; P,h \\<turnstile> z :\\<le> Taa;\n        P,h \\<turnstile> zs [:\\<le>] ST;\n        Ts = Tsa \\<and>\n        T = Ta \\<and>\n        \\<lfloor>(mxs, mxl\\<^sub>0, ins, xt)\\<rfloor> =\n        \\<lfloor>(mxsa, mxl\\<^sub>0', is, xta)\\<rfloor> \\<and>\n        C = C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs \\<and>\n                            (\\<forall>D'.\n                                P \\<turnstile> ClassCast \\<preceq>\\<^sup>* D' \\<longrightarrow>\n                                is_relevant_class (is ! pc) P D')", "apply(fastforce simp add: conf_def intro: widen_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Instanceof_correct:\n\"\\<lbrakk> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n    P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C; \n    ins!pc = Instanceof Ty; \n    P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n    \\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>;\n    (tas, \\<sigma>) \\<in> exec_instr (ins!pc) P t h stk loc C M pc frs \\<rbrakk> \n\\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                     ins, xt)\\<rfloor> in C;\n     ins ! pc = Instanceof Ty;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n     (tas, \\<sigma>)\n     \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "apply (clarsimp simp add: wf_jvm_prog_phi_def split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta Taa ST LT z zs.\n       \\<lbrakk>wf_prog\n                 (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n                     wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n                      (\\<Phi> C M))\n                 P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        ins ! pc = Instanceof Ty; P,h \\<turnstile> t \\<surd>t;\n        tas = \\<lbrace>\\<rbrace>;\n        \\<sigma> =\n        (None, h,\n         (Bool\n           (z \\<noteq> Null \\<and>\n            P \\<turnstile> the (typeof\\<^bsub>h\\<^esub> z) \\<le> Ty) #\n          zs,\n          loc, C, M, Suc pc) #\n         frs);\n        hconf h; preallocated h;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = \\<lfloor>(mxsa,\n                          mxl\\<^sub>0', is, xta)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(Taa # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P (Instanceof Ty) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        Suc pc < length ins; is_type P Ty; is_refT Taa;\n        \\<forall>x\\<in>set (xcpt_eff (Instanceof Ty) P pc (Taa # ST, LT)\n                             xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>a b.\n           (a = Suc pc \\<and>\n            b = \\<lfloor>(Boolean # ST, LT)\\<rfloor> \\<longrightarrow>\n            (\\<exists>a b.\n                \\<Phi> C M ! Suc pc = \\<lfloor>(a, b)\\<rfloor> \\<and>\n                (\\<exists>zs.\n                    a = Boolean # zs \\<and>\n                    P \\<turnstile> ST [\\<le>] zs) \\<and>\n                P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] b)) \\<and>\n           ((a, b)\n            \\<in> set (xcpt_eff (Instanceof Ty) P pc (Taa # ST, LT)\n                        xt) \\<longrightarrow>\n            P \\<turnstile> b \\<le>' \\<Phi> C M ! a);\n        stk = z # zs; P,h \\<turnstile> z :\\<le> Taa;\n        P,h \\<turnstile> zs [:\\<le>] ST\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            (\\<exists>a b.\n                                \\<Phi> C M ! Suc pc =\n                                \\<lfloor>(a, b)\\<rfloor> \\<and>\n                                P,h \\<turnstile> Bool\n            (z \\<noteq> Null \\<and>\n             P \\<turnstile> the (typeof\\<^bsub>h\\<^esub> z) \\<le> Ty) #\n           zs [:\\<le>] a \\<and>\n                                P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] b \\<and>\n                                Suc pc < length is \\<and>\n                                conf_fs P h \\<Phi> M (length Ts) T frs)", "apply (drule (1) sees_method_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta Taa ST LT z zs.\n       \\<lbrakk>wf_prog\n                 (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n                     wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n                      (\\<Phi> C M))\n                 P;\n        ins ! pc = Instanceof Ty; P,h \\<turnstile> t \\<surd>t;\n        tas = \\<lbrace>\\<rbrace>;\n        \\<sigma> =\n        (None, h,\n         (Bool\n           (z \\<noteq> Null \\<and>\n            P \\<turnstile> the (typeof\\<^bsub>h\\<^esub> z) \\<le> Ty) #\n          zs,\n          loc, C, M, Suc pc) #\n         frs);\n        hconf h; preallocated h;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = \\<lfloor>(mxsa,\n                          mxl\\<^sub>0', is, xta)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(Taa # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P (Instanceof Ty) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        Suc pc < length ins; is_type P Ty; is_refT Taa;\n        \\<forall>x\\<in>set (xcpt_eff (Instanceof Ty) P pc (Taa # ST, LT)\n                             xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>a b.\n           (a = Suc pc \\<and>\n            b = \\<lfloor>(Boolean # ST, LT)\\<rfloor> \\<longrightarrow>\n            (\\<exists>a b.\n                \\<Phi> C M ! Suc pc = \\<lfloor>(a, b)\\<rfloor> \\<and>\n                (\\<exists>zs.\n                    a = Boolean # zs \\<and>\n                    P \\<turnstile> ST [\\<le>] zs) \\<and>\n                P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] b)) \\<and>\n           ((a, b)\n            \\<in> set (xcpt_eff (Instanceof Ty) P pc (Taa # ST, LT)\n                        xt) \\<longrightarrow>\n            P \\<turnstile> b \\<le>' \\<Phi> C M ! a);\n        stk = z # zs; P,h \\<turnstile> z :\\<le> Taa;\n        P,h \\<turnstile> zs [:\\<le>] ST;\n        Tsa = Ts \\<and>\n        Ta = T \\<and>\n        \\<lfloor>(mxsa, mxl\\<^sub>0', is, xta)\\<rfloor> =\n        \\<lfloor>(mxs, mxl\\<^sub>0, ins, xt)\\<rfloor> \\<and>\n        C = C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            (\\<exists>a b.\n                                \\<Phi> C M ! Suc pc =\n                                \\<lfloor>(a, b)\\<rfloor> \\<and>\n                                P,h \\<turnstile> Bool\n            (z \\<noteq> Null \\<and>\n             P \\<turnstile> the (typeof\\<^bsub>h\\<^esub> z) \\<le> Ty) #\n           zs [:\\<le>] a \\<and>\n                                P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] b \\<and>\n                                Suc pc < length is \\<and>\n                                conf_fs P h \\<Phi> M (length Ts) T frs)", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare split_paired_All [simp del]"], ["", "end"], ["", "lemma widens_Cons [iff]:\n  \"P \\<turnstile> (T # Ts) [\\<le>] Us = (\\<exists>z zs. Us = z # zs \\<and> P \\<turnstile> T \\<le> z \\<and> P \\<turnstile> Ts [\\<le>] zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> (T # Ts) [\\<le>] Us =\n    (\\<exists>z zs.\n        Us = z # zs \\<and>\n        P \\<turnstile> T \\<le> z \\<and> P \\<turnstile> Ts [\\<le>] zs)", "by(rule list_all2_Cons1)"], ["", "context heap_conf_base begin"], ["", "end"], ["", "context JVM_conf_read begin"], ["", "lemma Getfield_correct:\n  assumes wf: \"wf_prog wt P\"\n  assumes mC: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C\"\n  assumes i:  \"ins!pc = Getfield F D\"\n  assumes wt: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes cf: \"\\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  assumes xc: \"(tas, \\<sigma>') \\<in> exec_instr (ins!pc) P t h stk loc C M pc frs\"\n\n  shows \"\\<Phi> \\<turnstile> t:\\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from mC cf"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>", "obtain ST LT where    \n    \"h\\<surd>\": \"hconf h\" and\n    tconf: \"P,h \\<turnstile> t \\<surd>t\" and\n    \\<Phi>: \"\\<Phi> C M ! pc = Some (ST,LT)\" and\n    stk: \"P,h \\<turnstile> stk [:\\<le>] ST\" and loc: \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\" and\n    pc: \"pc < size ins\" and \n    fs: \"conf_fs P h \\<Phi> M (size Ts) T frs\" and\n    preh: \"preallocated h\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>hconf h; P,h \\<turnstile> t \\<surd>t;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         P,h \\<turnstile> stk [:\\<le>] ST;\n         P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length ins;\n         conf_fs P h \\<Phi> M (length Ts) T frs; preallocated h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce dest: sees_method_fun)"], ["proof (state)\nthis:\n  hconf h\n  P,h \\<turnstile> t \\<surd>t\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  preallocated h\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from i \\<Phi> wt"], ["proof (chain)\npicking this:\n  ins ! pc = Getfield F D\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M", "obtain oT ST'' vT ST' LT' vT' fm where \n    oT: \"P \\<turnstile> oT \\<le> Class D\" and\n    ST: \"ST = oT # ST''\" and\n    F:  \"P \\<turnstile> D sees F:vT (fm) in D\" and\n    pc': \"pc+1 < size ins\"  and\n    \\<Phi>': \"\\<Phi> C M ! (pc+1) = Some (vT'#ST', LT')\" and\n    ST': \"P \\<turnstile> ST'' [\\<le>] ST'\" and LT': \"P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\" and  \n    vT': \"P \\<turnstile> vT \\<le> vT'\""], ["proof (prove)\nusing this:\n  ins ! pc = Getfield F D\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n\ngoal (1 subgoal):\n 1. (\\<And>oT ST'' vT fm vT' ST' LT'.\n        \\<lbrakk>P \\<turnstile> oT \\<le> Class D; ST = oT # ST'';\n         P \\<turnstile> D sees F:vT (fm) in D; pc + 1 < length ins;\n         \\<Phi> C M ! (pc + 1) = \\<lfloor>(vT' # ST', LT')\\<rfloor>;\n         P \\<turnstile> ST'' [\\<le>] ST';\n         P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT';\n         P \\<turnstile> vT \\<le> vT'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  P \\<turnstile> oT \\<le> Class D\n  ST = oT # ST''\n  P \\<turnstile> D sees F:vT (fm) in D\n  pc + 1 < length ins\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(vT' # ST', LT')\\<rfloor>\n  P \\<turnstile> ST'' [\\<le>] ST'\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n  P \\<turnstile> vT \\<le> vT'\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from stk ST"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = oT # ST''", "obtain ref stk' where \n    stk': \"stk = ref#stk'\" and\n    ref:  \"P,h \\<turnstile> ref :\\<le> oT\" and\n    ST'': \"P,h \\<turnstile> stk' [:\\<le>] ST''\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = oT # ST''\n\ngoal (1 subgoal):\n 1. (\\<And>ref stk'.\n        \\<lbrakk>stk = ref # stk'; P,h \\<turnstile> ref :\\<le> oT;\n         P,h \\<turnstile> stk' [:\\<le>] ST''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  stk = ref # stk'\n  P,h \\<turnstile> ref :\\<le> oT\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "proof(cases \"ref = Null\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ref = Null \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "case True"], ["proof (state)\nthis:\n  ref = Null\n\ngoal (2 subgoals):\n 1. ref = Null \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "with tconf \"h\\<surd>\" i xc stk' mC fs \\<Phi> ST'' ref ST loc pc' \n      wf_preallocatedD[OF wf, of h NullPointer] preh"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> t \\<surd>t\n  hconf h\n  ins ! pc = Getfield F D\n  (tas, \\<sigma>') \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  stk = ref # stk'\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n  P,h \\<turnstile> ref :\\<le> oT\n  ST = oT # ST''\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc + 1 < length ins\n  \\<lbrakk>preallocated h; NullPointer \\<in> sys_xcpts\\<rbrakk>\n  \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt NullPointer) =\n                    \\<lfloor>Class_type NullPointer\\<rfloor> \\<and>\n                    P \\<turnstile> NullPointer \\<preceq>\\<^sup>* Throwable\n  preallocated h\n  ref = Null", "show ?thesis"], ["proof (prove)\nusing this:\n  P,h \\<turnstile> t \\<surd>t\n  hconf h\n  ins ! pc = Getfield F D\n  (tas, \\<sigma>') \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  stk = ref # stk'\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n  P,h \\<turnstile> ref :\\<le> oT\n  ST = oT # ST''\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc + 1 < length ins\n  \\<lbrakk>preallocated h; NullPointer \\<in> sys_xcpts\\<rbrakk>\n  \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt NullPointer) =\n                    \\<lfloor>Class_type NullPointer\\<rfloor> \\<and>\n                    P \\<turnstile> NullPointer \\<preceq>\\<^sup>* Throwable\n  preallocated h\n  ref = Null\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "by(fastforce)"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "case False"], ["proof (state)\nthis:\n  ref \\<noteq> Null\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from ref oT"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> ref :\\<le> oT\n  P \\<turnstile> oT \\<le> Class D", "have \"P,h \\<turnstile> ref :\\<le> Class D\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> ref :\\<le> oT\n  P \\<turnstile> oT \\<le> Class D\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> ref :\\<le> Class D", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> ref :\\<le> Class D\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "with False"], ["proof (chain)\npicking this:\n  ref \\<noteq> Null\n  P,h \\<turnstile> ref :\\<le> Class D", "obtain a U' D' where a: \"ref = Addr a\"\n      and h: \"typeof_addr h a = Some U'\"\n      and U': \"D' = class_type_of U'\" and D': \"P \\<turnstile> D' \\<preceq>\\<^sup>* D\""], ["proof (prove)\nusing this:\n  ref \\<noteq> Null\n  P,h \\<turnstile> ref :\\<le> Class D\n\ngoal (1 subgoal):\n 1. (\\<And>a U' D'.\n        \\<lbrakk>ref = Addr a; typeof_addr h a = \\<lfloor>U'\\<rfloor>;\n         D' = class_type_of U';\n         P \\<turnstile> D' \\<preceq>\\<^sup>* D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: non_npD2)"], ["proof (state)\nthis:\n  ref = Addr a\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  D' = class_type_of U'\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "{"], ["proof (state)\nthis:\n  ref = Addr a\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  D' = class_type_of U'\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "assume read: \"heap_read h a (CField D F) v\""], ["proof (state)\nthis:\n  heap_read h a (CField D F) v\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from D' F"], ["proof (chain)\npicking this:\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D\n  P \\<turnstile> D sees F:vT (fm) in D", "have has_field: \"P \\<turnstile> D' has F:vT (fm) in D\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D\n  P \\<turnstile> D sees F:vT (fm) in D\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D' has F:vT (fm) in D", "by (blast intro: has_field_mono has_visible_field)"], ["proof (state)\nthis:\n  P \\<turnstile> D' has F:vT (fm) in D\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "with h"], ["proof (chain)\npicking this:\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  P \\<turnstile> D' has F:vT (fm) in D", "have \"P,h \\<turnstile> a@CField D F : vT\""], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  P \\<turnstile> D' has F:vT (fm) in D\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> a@CField D F : vT", "unfolding U'"], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  P \\<turnstile> class_type_of U' has F:vT (fm) in D\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> a@CField D F : vT", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> a@CField D F : vT\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "with read"], ["proof (chain)\npicking this:\n  heap_read h a (CField D F) v\n  P,h \\<turnstile> a@CField D F : vT", "have v: \"P,h \\<turnstile> v :\\<le> vT\""], ["proof (prove)\nusing this:\n  heap_read h a (CField D F) v\n  P,h \\<turnstile> a@CField D F : vT\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> v :\\<le> vT", "using \"h\\<surd>\""], ["proof (prove)\nusing this:\n  heap_read h a (CField D F) v\n  P,h \\<turnstile> a@CField D F : vT\n  hconf h\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> v :\\<le> vT", "by(rule heap_read_conf)"], ["proof (state)\nthis:\n  P,h \\<turnstile> v :\\<le> vT\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from ST'' ST'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n  P \\<turnstile> ST'' [\\<le>] ST'", "have \"P,h \\<turnstile> stk' [:\\<le>] ST'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n  P \\<turnstile> ST'' [\\<le>] ST'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> stk' [:\\<le>] ST'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "moreover"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from v vT'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> v :\\<le> vT\n  P \\<turnstile> vT \\<le> vT'", "have \"P,h \\<turnstile> v :\\<le> vT'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> v :\\<le> vT\n  P \\<turnstile> vT \\<le> vT'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> v :\\<le> vT'", "by blast"], ["proof (state)\nthis:\n  P,h \\<turnstile> v :\\<le> vT'\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "moreover"], ["proof (state)\nthis:\n  P,h \\<turnstile> v :\\<le> vT'\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from loc LT'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'", "have \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "moreover"], ["proof (state)\nthis:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "note \"h\\<surd>\" mC \\<Phi>' pc' v fs tconf preh"], ["proof (state)\nthis:\n  hconf h\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(vT' # ST', LT')\\<rfloor>\n  pc + 1 < length ins\n  P,h \\<turnstile> v :\\<le> vT\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  P,h \\<turnstile> t \\<surd>t\n  preallocated h\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "ultimately"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n  P,h \\<turnstile> v :\\<le> vT'\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  hconf h\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(vT' # ST', LT')\\<rfloor>\n  pc + 1 < length ins\n  P,h \\<turnstile> v :\\<le> vT\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  P,h \\<turnstile> t \\<surd>t\n  preallocated h", "have \"\\<Phi> \\<turnstile> t:(None, h, (v#stk',loc,C,M,pc+1)#frs) \\<surd>\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n  P,h \\<turnstile> v :\\<le> vT'\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  hconf h\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(vT' # ST', LT')\\<rfloor>\n  pc + 1 < length ins\n  P,h \\<turnstile> v :\\<le> vT\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  P,h \\<turnstile> t \\<surd>t\n  preallocated h\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:(None, h,\n                           (v # stk', loc, C, M, pc + 1) # frs) \\<surd>", "by fastforce"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:(None, h,\n                         (v # stk', loc, C, M, pc + 1) # frs) \\<surd>\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "}"], ["proof (state)\nthis:\n  heap_read h a (CField D F) ?v17 \\<Longrightarrow>\n  \\<Phi> \\<turnstile> t:(None, h,\n                         (?v17 # stk', loc, C, M, pc + 1) # frs) \\<surd>\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "with a h i mC stk' xc"], ["proof (chain)\npicking this:\n  ref = Addr a\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  ins ! pc = Getfield F D\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  stk = ref # stk'\n  (tas, \\<sigma>') \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  heap_read h a (CField D F) ?v17 \\<Longrightarrow>\n  \\<Phi> \\<turnstile> t:(None, h,\n                         (?v17 # stk', loc, C, M, pc + 1) # frs) \\<surd>", "show ?thesis"], ["proof (prove)\nusing this:\n  ref = Addr a\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  ins ! pc = Getfield F D\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  stk = ref # stk'\n  (tas, \\<sigma>') \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  heap_read h a (CField D F) ?v17 \\<Longrightarrow>\n  \\<Phi> \\<turnstile> t:(None, h,\n                         (?v17 # stk', loc, C, M, pc + 1) # frs) \\<surd>\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "by auto"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Putfield_correct:\n  assumes wf: \"wf_prog wt P\"\n  assumes mC: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C\"\n  assumes i:  \"ins!pc = Putfield F D\"\n  assumes wt: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes cf: \"\\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  assumes xc: \"(tas, \\<sigma>') \\<in> exec_instr (ins!pc) P t h stk loc C M pc frs\"\n  shows \"\\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from mC cf"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>", "obtain ST LT where    \n    \"h\\<surd>\": \"hconf h\" and    \n    tconf: \"P,h \\<turnstile> t \\<surd>t\" and\n    \\<Phi>: \"\\<Phi> C M ! pc = Some (ST,LT)\" and\n    stk: \"P,h \\<turnstile> stk [:\\<le>] ST\" and loc: \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\" and\n    pc: \"pc < size ins\" and \n    fs: \"conf_fs P h \\<Phi> M (size Ts) T frs\" and\n    preh: \"preallocated h\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>hconf h; P,h \\<turnstile> t \\<surd>t;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         P,h \\<turnstile> stk [:\\<le>] ST;\n         P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length ins;\n         conf_fs P h \\<Phi> M (length Ts) T frs; preallocated h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce dest: sees_method_fun)"], ["proof (state)\nthis:\n  hconf h\n  P,h \\<turnstile> t \\<surd>t\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  preallocated h\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from i \\<Phi> wt"], ["proof (chain)\npicking this:\n  ins ! pc = Putfield F D\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M", "obtain vT vT' oT ST'' ST' LT' fm where \n    ST: \"ST = vT # oT # ST''\" and\n    field: \"P \\<turnstile> D sees F:vT' (fm) in D\" and\n    oT: \"P \\<turnstile> oT \\<le> Class D\" and vT: \"P \\<turnstile> vT \\<le> vT'\" and\n    pc': \"pc+1 < size ins\" and \n    \\<Phi>': \"\\<Phi> C M!(pc+1) = Some (ST',LT')\" and\n    ST': \"P \\<turnstile> ST'' [\\<le>] ST'\" and LT': \"P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\""], ["proof (prove)\nusing this:\n  ins ! pc = Putfield F D\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n\ngoal (1 subgoal):\n 1. (\\<And>vT oT ST'' vT' fm ST' LT'.\n        \\<lbrakk>ST = vT # oT # ST''; P \\<turnstile> D sees F:vT' (fm) in D;\n         P \\<turnstile> oT \\<le> Class D; P \\<turnstile> vT \\<le> vT';\n         pc + 1 < length ins;\n         \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>;\n         P \\<turnstile> ST'' [\\<le>] ST';\n         P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by clarsimp"], ["proof (state)\nthis:\n  ST = vT # oT # ST''\n  P \\<turnstile> D sees F:vT' (fm) in D\n  P \\<turnstile> oT \\<le> Class D\n  P \\<turnstile> vT \\<le> vT'\n  pc + 1 < length ins\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> ST'' [\\<le>] ST'\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from stk ST"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = vT # oT # ST''", "obtain v ref stk' where \n    stk': \"stk = v#ref#stk'\" and\n    v:    \"P,h \\<turnstile> v :\\<le> vT\" and \n    ref:  \"P,h \\<turnstile> ref :\\<le> oT\" and\n    ST'': \"P,h \\<turnstile> stk' [:\\<le>] ST''\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = vT # oT # ST''\n\ngoal (1 subgoal):\n 1. (\\<And>v ref stk'.\n        \\<lbrakk>stk = v # ref # stk'; P,h \\<turnstile> v :\\<le> vT;\n         P,h \\<turnstile> ref :\\<le> oT;\n         P,h \\<turnstile> stk' [:\\<le>] ST''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  stk = v # ref # stk'\n  P,h \\<turnstile> v :\\<le> vT\n  P,h \\<turnstile> ref :\\<le> oT\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "proof(cases \"ref = Null\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ref = Null \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "case True"], ["proof (state)\nthis:\n  ref = Null\n\ngoal (2 subgoals):\n 1. ref = Null \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "with tconf \"h\\<surd>\" i xc stk' mC fs \\<Phi> ST'' ref ST loc pc' v\n      wf_preallocatedD[OF wf, of h NullPointer] preh"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> t \\<surd>t\n  hconf h\n  ins ! pc = Putfield F D\n  (tas, \\<sigma>') \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  stk = v # ref # stk'\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n  P,h \\<turnstile> ref :\\<le> oT\n  ST = vT # oT # ST''\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc + 1 < length ins\n  P,h \\<turnstile> v :\\<le> vT\n  \\<lbrakk>preallocated h; NullPointer \\<in> sys_xcpts\\<rbrakk>\n  \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt NullPointer) =\n                    \\<lfloor>Class_type NullPointer\\<rfloor> \\<and>\n                    P \\<turnstile> NullPointer \\<preceq>\\<^sup>* Throwable\n  preallocated h\n  ref = Null", "show ?thesis"], ["proof (prove)\nusing this:\n  P,h \\<turnstile> t \\<surd>t\n  hconf h\n  ins ! pc = Putfield F D\n  (tas, \\<sigma>') \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  stk = v # ref # stk'\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n  P,h \\<turnstile> ref :\\<le> oT\n  ST = vT # oT # ST''\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc + 1 < length ins\n  P,h \\<turnstile> v :\\<le> vT\n  \\<lbrakk>preallocated h; NullPointer \\<in> sys_xcpts\\<rbrakk>\n  \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt NullPointer) =\n                    \\<lfloor>Class_type NullPointer\\<rfloor> \\<and>\n                    P \\<turnstile> NullPointer \\<preceq>\\<^sup>* Throwable\n  preallocated h\n  ref = Null\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "by(fastforce)"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "case False"], ["proof (state)\nthis:\n  ref \\<noteq> Null\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from ref oT"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> ref :\\<le> oT\n  P \\<turnstile> oT \\<le> Class D", "have \"P,h \\<turnstile> ref :\\<le> Class D\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> ref :\\<le> oT\n  P \\<turnstile> oT \\<le> Class D\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> ref :\\<le> Class D", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> ref :\\<le> Class D\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "with False"], ["proof (chain)\npicking this:\n  ref \\<noteq> Null\n  P,h \\<turnstile> ref :\\<le> Class D", "obtain a U' D' where \n      a: \"ref = Addr a\" and h: \"typeof_addr h a = Some U'\"\n      and U': \"D' = class_type_of U'\" and D': \"P \\<turnstile> D' \\<preceq>\\<^sup>* D\""], ["proof (prove)\nusing this:\n  ref \\<noteq> Null\n  P,h \\<turnstile> ref :\\<le> Class D\n\ngoal (1 subgoal):\n 1. (\\<And>a U' D'.\n        \\<lbrakk>ref = Addr a; typeof_addr h a = \\<lfloor>U'\\<rfloor>;\n         D' = class_type_of U';\n         P \\<turnstile> D' \\<preceq>\\<^sup>* D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: non_npD2)"], ["proof (state)\nthis:\n  ref = Addr a\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  D' = class_type_of U'\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from v vT"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> v :\\<le> vT\n  P \\<turnstile> vT \\<le> vT'", "have vT': \"P,h \\<turnstile> v :\\<le> vT'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> v :\\<le> vT\n  P \\<turnstile> vT \\<le> vT'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> v :\\<le> vT'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> v :\\<le> vT'\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from field D'"], ["proof (chain)\npicking this:\n  P \\<turnstile> D sees F:vT' (fm) in D\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D", "have has_field: \"P \\<turnstile> D' has F:vT' (fm) in D\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D sees F:vT' (fm) in D\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D' has F:vT' (fm) in D", "by (blast intro: has_field_mono has_visible_field)"], ["proof (state)\nthis:\n  P \\<turnstile> D' has F:vT' (fm) in D\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "with h"], ["proof (chain)\npicking this:\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  P \\<turnstile> D' has F:vT' (fm) in D", "have al: \"P,h \\<turnstile> a@CField D F : vT'\""], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  P \\<turnstile> D' has F:vT' (fm) in D\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> a@CField D F : vT'", "unfolding U'"], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  P \\<turnstile> class_type_of U' has F:vT' (fm) in D\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> a@CField D F : vT'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> a@CField D F : vT'\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "let ?f' = \"(stk',loc,C,M,pc+1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "fix h'"], ["proof (state)\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "assume \"write\": \"heap_write h a (CField D F) v h'\""], ["proof (state)\nthis:\n  heap_write h a (CField D F) v h'\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "hence hext: \"h \\<unlhd> h'\""], ["proof (prove)\nusing this:\n  heap_write h a (CField D F) v h'\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "by(rule hext_heap_write)"], ["proof (state)\nthis:\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "with preh"], ["proof (chain)\npicking this:\n  preallocated h\n  h \\<unlhd> h'", "have \"preallocated h'\""], ["proof (prove)\nusing this:\n  preallocated h\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. preallocated h'", "by(rule preallocated_hext)"], ["proof (state)\nthis:\n  preallocated h'\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "moreover"], ["proof (state)\nthis:\n  preallocated h'\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from \"write\" \"h\\<surd>\" al vT'"], ["proof (chain)\npicking this:\n  heap_write h a (CField D F) v h'\n  hconf h\n  P,h \\<turnstile> a@CField D F : vT'\n  P,h \\<turnstile> v :\\<le> vT'", "have \"hconf h'\""], ["proof (prove)\nusing this:\n  heap_write h a (CField D F) v h'\n  hconf h\n  P,h \\<turnstile> a@CField D F : vT'\n  P,h \\<turnstile> v :\\<le> vT'\n\ngoal (1 subgoal):\n 1. hconf h'", "by(rule hconf_heap_write_mono)"], ["proof (state)\nthis:\n  hconf h'\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "moreover"], ["proof (state)\nthis:\n  hconf h'\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from ST'' ST'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n  P \\<turnstile> ST'' [\\<le>] ST'", "have \"P,h \\<turnstile> stk' [:\\<le>] ST'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n  P \\<turnstile> ST'' [\\<le>] ST'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> stk' [:\\<le>] ST'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from this hext"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n  h \\<unlhd> h'", "have \"P,h' \\<turnstile> stk' [:\\<le>] ST'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. P,h' \\<turnstile> stk' [:\\<le>] ST'", "by (rule confs_hext)"], ["proof (state)\nthis:\n  P,h' \\<turnstile> stk' [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "moreover"], ["proof (state)\nthis:\n  P,h' \\<turnstile> stk' [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from loc LT'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'", "have \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from this hext"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  h \\<unlhd> h'", "have \"P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'", "by (rule confTs_hext)"], ["proof (state)\nthis:\n  P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "moreover"], ["proof (state)\nthis:\n  P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from fs hext"], ["proof (chain)\npicking this:\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  h \\<unlhd> h'", "have \"conf_fs P h' \\<Phi> M (size Ts) T frs\""], ["proof (prove)\nusing this:\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. conf_fs P h' \\<Phi> M (length Ts) T frs", "by (rule conf_fs_hext)"], ["proof (state)\nthis:\n  conf_fs P h' \\<Phi> M (length Ts) T frs\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "moreover"], ["proof (state)\nthis:\n  conf_fs P h' \\<Phi> M (length Ts) T frs\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "note mC \\<Phi>' pc'"], ["proof (state)\nthis:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  pc + 1 < length ins\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "moreover"], ["proof (state)\nthis:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  pc + 1 < length ins\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from tconf hext"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> t \\<surd>t\n  h \\<unlhd> h'", "have \"P,h' \\<turnstile> t \\<surd>t\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> t \\<surd>t\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. P,h' \\<turnstile> t \\<surd>t", "by(rule tconf_hext_mono)"], ["proof (state)\nthis:\n  P,h' \\<turnstile> t \\<surd>t\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "ultimately"], ["proof (chain)\npicking this:\n  preallocated h'\n  hconf h'\n  P,h' \\<turnstile> stk' [:\\<le>] ST'\n  P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  conf_fs P h' \\<Phi> M (length Ts) T frs\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  pc + 1 < length ins\n  P,h' \\<turnstile> t \\<surd>t", "have \"\\<Phi> \\<turnstile> t:(None, h', ?f'#frs) \\<surd>\""], ["proof (prove)\nusing this:\n  preallocated h'\n  hconf h'\n  P,h' \\<turnstile> stk' [:\\<le>] ST'\n  P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  conf_fs P h' \\<Phi> M (length Ts) T frs\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  pc + 1 < length ins\n  P,h' \\<turnstile> t \\<surd>t\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:(None, h',\n                           (stk', loc, C, M, pc + 1) # frs) \\<surd>", "by fastforce"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:(None, h', (stk', loc, C, M, pc + 1) # frs) \\<surd>\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "}"], ["proof (state)\nthis:\n  heap_write h a (CField D F) v ?h'17 \\<Longrightarrow>\n  \\<Phi> \\<turnstile> t:(None, ?h'17,\n                         (stk', loc, C, M, pc + 1) # frs) \\<surd>\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "with a h i mC stk' xc"], ["proof (chain)\npicking this:\n  ref = Addr a\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  ins ! pc = Putfield F D\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  stk = v # ref # stk'\n  (tas, \\<sigma>') \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  heap_write h a (CField D F) v ?h'17 \\<Longrightarrow>\n  \\<Phi> \\<turnstile> t:(None, ?h'17,\n                         (stk', loc, C, M, pc + 1) # frs) \\<surd>", "show ?thesis"], ["proof (prove)\nusing this:\n  ref = Addr a\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  ins ! pc = Putfield F D\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  stk = v # ref # stk'\n  (tas, \\<sigma>') \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  heap_write h a (CField D F) v ?h'17 \\<Longrightarrow>\n  \\<Phi> \\<turnstile> t:(None, ?h'17,\n                         (stk', loc, C, M, pc + 1) # frs) \\<surd>\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "by(auto simp del: correct_state_def)"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma CAS_correct:\n  assumes wf: \"wf_prog wt P\"\n  assumes mC: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C\"\n  assumes i:  \"ins!pc = CAS F D\"\n  assumes wt: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes cf: \"\\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  assumes xc: \"(tas, \\<sigma>') \\<in> exec_instr (ins!pc) P t h stk loc C M pc frs\"\n  shows \"\\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from mC cf"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>", "obtain ST LT where    \n    \"h\\<surd>\": \"hconf h\" and    \n    tconf: \"P,h \\<turnstile> t \\<surd>t\" and\n    \\<Phi>: \"\\<Phi> C M ! pc = Some (ST,LT)\" and\n    stk: \"P,h \\<turnstile> stk [:\\<le>] ST\" and loc: \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\" and\n    pc: \"pc < size ins\" and \n    fs: \"conf_fs P h \\<Phi> M (size Ts) T frs\" and\n    preh: \"preallocated h\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>hconf h; P,h \\<turnstile> t \\<surd>t;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         P,h \\<turnstile> stk [:\\<le>] ST;\n         P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length ins;\n         conf_fs P h \\<Phi> M (length Ts) T frs; preallocated h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce dest: sees_method_fun)"], ["proof (state)\nthis:\n  hconf h\n  P,h \\<turnstile> t \\<surd>t\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  preallocated h\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from i \\<Phi> wt"], ["proof (chain)\npicking this:\n  ins ! pc = CAS F D\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M", "obtain T1 T2 T3 T' ST'' ST' LT' fm where \n    ST: \"ST = T3 # T2 # T1 # ST''\" and\n    field: \"P \\<turnstile> D sees F:T' (fm) in D\" and\n    oT: \"P \\<turnstile> T1 \\<le> Class D\" and T2: \"P \\<turnstile> T2 \\<le> T'\" and T3: \"P \\<turnstile> T3 \\<le> T'\" and\n    pc': \"pc+1 < size ins\" and \n    \\<Phi>': \"\\<Phi> C M!(pc+1) = Some (Boolean # ST',LT')\" and\n    ST': \"P \\<turnstile> ST'' [\\<le>] ST'\" and LT': \"P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\""], ["proof (prove)\nusing this:\n  ins ! pc = CAS F D\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n\ngoal (1 subgoal):\n 1. (\\<And>T3 T2 T1 ST'' T' fm ST' LT'.\n        \\<lbrakk>ST = T3 # T2 # T1 # ST'';\n         P \\<turnstile> D sees F:T' (fm) in D;\n         P \\<turnstile> T1 \\<le> Class D; P \\<turnstile> T2 \\<le> T';\n         P \\<turnstile> T3 \\<le> T'; pc + 1 < length ins;\n         \\<Phi> C M ! (pc + 1) = \\<lfloor>(Boolean # ST', LT')\\<rfloor>;\n         P \\<turnstile> ST'' [\\<le>] ST';\n         P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by clarsimp"], ["proof (state)\nthis:\n  ST = T3 # T2 # T1 # ST''\n  P \\<turnstile> D sees F:T' (fm) in D\n  P \\<turnstile> T1 \\<le> Class D\n  P \\<turnstile> T2 \\<le> T'\n  P \\<turnstile> T3 \\<le> T'\n  pc + 1 < length ins\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(Boolean # ST', LT')\\<rfloor>\n  P \\<turnstile> ST'' [\\<le>] ST'\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from stk ST"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = T3 # T2 # T1 # ST''", "obtain v'' v' v stk' where \n    stk': \"stk = v''#v'#v#stk'\" and\n    v:    \"P,h \\<turnstile> v :\\<le> T1\" and \n    v':  \"P,h \\<turnstile> v' :\\<le> T2\" and\n    v'': \"P,h \\<turnstile> v'' :\\<le> T3\" and\n    ST'': \"P,h \\<turnstile> stk' [:\\<le>] ST''\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = T3 # T2 # T1 # ST''\n\ngoal (1 subgoal):\n 1. (\\<And>v'' v' v stk'.\n        \\<lbrakk>stk = v'' # v' # v # stk'; P,h \\<turnstile> v :\\<le> T1;\n         P,h \\<turnstile> v' :\\<le> T2; P,h \\<turnstile> v'' :\\<le> T3;\n         P,h \\<turnstile> stk' [:\\<le>] ST''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  stk = v'' # v' # v # stk'\n  P,h \\<turnstile> v :\\<le> T1\n  P,h \\<turnstile> v' :\\<le> T2\n  P,h \\<turnstile> v'' :\\<le> T3\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "proof(cases \"v = Null\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v = Null \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "case True"], ["proof (state)\nthis:\n  v = Null\n\ngoal (2 subgoals):\n 1. v = Null \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "with tconf \"h\\<surd>\" i xc stk' mC fs \\<Phi> ST'' v ST loc pc' v' v''\n      wf_preallocatedD[OF wf, of h NullPointer] preh"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> t \\<surd>t\n  hconf h\n  ins ! pc = CAS F D\n  (tas, \\<sigma>') \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  stk = v'' # v' # v # stk'\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n  P,h \\<turnstile> v :\\<le> T1\n  ST = T3 # T2 # T1 # ST''\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc + 1 < length ins\n  P,h \\<turnstile> v' :\\<le> T2\n  P,h \\<turnstile> v'' :\\<le> T3\n  \\<lbrakk>preallocated h; NullPointer \\<in> sys_xcpts\\<rbrakk>\n  \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt NullPointer) =\n                    \\<lfloor>Class_type NullPointer\\<rfloor> \\<and>\n                    P \\<turnstile> NullPointer \\<preceq>\\<^sup>* Throwable\n  preallocated h\n  v = Null", "show ?thesis"], ["proof (prove)\nusing this:\n  P,h \\<turnstile> t \\<surd>t\n  hconf h\n  ins ! pc = CAS F D\n  (tas, \\<sigma>') \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  stk = v'' # v' # v # stk'\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n  P,h \\<turnstile> v :\\<le> T1\n  ST = T3 # T2 # T1 # ST''\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc + 1 < length ins\n  P,h \\<turnstile> v' :\\<le> T2\n  P,h \\<turnstile> v'' :\\<le> T3\n  \\<lbrakk>preallocated h; NullPointer \\<in> sys_xcpts\\<rbrakk>\n  \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt NullPointer) =\n                    \\<lfloor>Class_type NullPointer\\<rfloor> \\<and>\n                    P \\<turnstile> NullPointer \\<preceq>\\<^sup>* Throwable\n  preallocated h\n  v = Null\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "by(fastforce)"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "case False"], ["proof (state)\nthis:\n  v \\<noteq> Null\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from v oT"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> v :\\<le> T1\n  P \\<turnstile> T1 \\<le> Class D", "have \"P,h \\<turnstile> v :\\<le> Class D\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> v :\\<le> T1\n  P \\<turnstile> T1 \\<le> Class D\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> v :\\<le> Class D", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> v :\\<le> Class D\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "with False"], ["proof (chain)\npicking this:\n  v \\<noteq> Null\n  P,h \\<turnstile> v :\\<le> Class D", "obtain a U' D' where \n      a: \"v = Addr a\" and h: \"typeof_addr h a = Some U'\"\n      and U': \"D' = class_type_of U'\" and D': \"P \\<turnstile> D' \\<preceq>\\<^sup>* D\""], ["proof (prove)\nusing this:\n  v \\<noteq> Null\n  P,h \\<turnstile> v :\\<le> Class D\n\ngoal (1 subgoal):\n 1. (\\<And>a U' D'.\n        \\<lbrakk>v = Addr a; typeof_addr h a = \\<lfloor>U'\\<rfloor>;\n         D' = class_type_of U';\n         P \\<turnstile> D' \\<preceq>\\<^sup>* D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: non_npD2)"], ["proof (state)\nthis:\n  v = Addr a\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  D' = class_type_of U'\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from v' T2"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> v' :\\<le> T2\n  P \\<turnstile> T2 \\<le> T'", "have vT': \"P,h \\<turnstile> v' :\\<le> T'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> v' :\\<le> T2\n  P \\<turnstile> T2 \\<le> T'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> v' :\\<le> T'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> v' :\\<le> T'\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from v'' T3"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> v'' :\\<le> T3\n  P \\<turnstile> T3 \\<le> T'", "have vT'': \"P,h \\<turnstile> v'' :\\<le> T'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> v'' :\\<le> T3\n  P \\<turnstile> T3 \\<le> T'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> v'' :\\<le> T'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> v'' :\\<le> T'\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from field D'"], ["proof (chain)\npicking this:\n  P \\<turnstile> D sees F:T' (fm) in D\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D", "have has_field: \"P \\<turnstile> D' has F:T' (fm) in D\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D sees F:T' (fm) in D\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D' has F:T' (fm) in D", "by (blast intro: has_field_mono has_visible_field)"], ["proof (state)\nthis:\n  P \\<turnstile> D' has F:T' (fm) in D\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "with h"], ["proof (chain)\npicking this:\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  P \\<turnstile> D' has F:T' (fm) in D", "have al: \"P,h \\<turnstile> a@CField D F : T'\""], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  P \\<turnstile> D' has F:T' (fm) in D\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> a@CField D F : T'", "unfolding U'"], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  P \\<turnstile> class_type_of U' has F:T' (fm) in D\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> a@CField D F : T'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> a@CField D F : T'\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from ST'' ST'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n  P \\<turnstile> ST'' [\\<le>] ST'", "have stk'': \"P,h \\<turnstile> stk' [:\\<le>] ST'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n  P \\<turnstile> ST'' [\\<le>] ST'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> stk' [:\\<le>] ST'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from loc LT'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'", "have loc': \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "{"], ["proof (state)\nthis:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "fix h'"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "assume \"write\": \"heap_write h a (CField D F) v'' h'\""], ["proof (state)\nthis:\n  heap_write h a (CField D F) v'' h'\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "hence hext: \"h \\<unlhd> h'\""], ["proof (prove)\nusing this:\n  heap_write h a (CField D F) v'' h'\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "by(rule hext_heap_write)"], ["proof (state)\nthis:\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "with preh"], ["proof (chain)\npicking this:\n  preallocated h\n  h \\<unlhd> h'", "have \"preallocated h'\""], ["proof (prove)\nusing this:\n  preallocated h\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. preallocated h'", "by(rule preallocated_hext)"], ["proof (state)\nthis:\n  preallocated h'\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "moreover"], ["proof (state)\nthis:\n  preallocated h'\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from \"write\" \"h\\<surd>\" al vT''"], ["proof (chain)\npicking this:\n  heap_write h a (CField D F) v'' h'\n  hconf h\n  P,h \\<turnstile> a@CField D F : T'\n  P,h \\<turnstile> v'' :\\<le> T'", "have \"hconf h'\""], ["proof (prove)\nusing this:\n  heap_write h a (CField D F) v'' h'\n  hconf h\n  P,h \\<turnstile> a@CField D F : T'\n  P,h \\<turnstile> v'' :\\<le> T'\n\ngoal (1 subgoal):\n 1. hconf h'", "by(rule hconf_heap_write_mono)"], ["proof (state)\nthis:\n  hconf h'\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "moreover"], ["proof (state)\nthis:\n  hconf h'\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from stk'' hext"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n  h \\<unlhd> h'", "have \"P,h' \\<turnstile> stk' [:\\<le>] ST'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. P,h' \\<turnstile> stk' [:\\<le>] ST'", "by (rule confs_hext)"], ["proof (state)\nthis:\n  P,h' \\<turnstile> stk' [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "moreover"], ["proof (state)\nthis:\n  P,h' \\<turnstile> stk' [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from loc' hext"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  h \\<unlhd> h'", "have \"P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'", "by (rule confTs_hext)"], ["proof (state)\nthis:\n  P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "moreover"], ["proof (state)\nthis:\n  P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from fs hext"], ["proof (chain)\npicking this:\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  h \\<unlhd> h'", "have \"conf_fs P h' \\<Phi> M (size Ts) T frs\""], ["proof (prove)\nusing this:\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. conf_fs P h' \\<Phi> M (length Ts) T frs", "by (rule conf_fs_hext)"], ["proof (state)\nthis:\n  conf_fs P h' \\<Phi> M (length Ts) T frs\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "moreover"], ["proof (state)\nthis:\n  conf_fs P h' \\<Phi> M (length Ts) T frs\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "note mC \\<Phi>' pc'"], ["proof (state)\nthis:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(Boolean # ST', LT')\\<rfloor>\n  pc + 1 < length ins\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "moreover"], ["proof (state)\nthis:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(Boolean # ST', LT')\\<rfloor>\n  pc + 1 < length ins\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "let ?f' = \"(Bool True # stk',loc,C,M,pc+1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "from tconf hext"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> t \\<surd>t\n  h \\<unlhd> h'", "have \"P,h' \\<turnstile> t \\<surd>t\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> t \\<surd>t\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. P,h' \\<turnstile> t \\<surd>t", "by(rule tconf_hext_mono)"], ["proof (state)\nthis:\n  P,h' \\<turnstile> t \\<surd>t\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "ultimately"], ["proof (chain)\npicking this:\n  preallocated h'\n  hconf h'\n  P,h' \\<turnstile> stk' [:\\<le>] ST'\n  P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  conf_fs P h' \\<Phi> M (length Ts) T frs\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(Boolean # ST', LT')\\<rfloor>\n  pc + 1 < length ins\n  P,h' \\<turnstile> t \\<surd>t", "have \"\\<Phi> \\<turnstile> t:(None, h', ?f'#frs) \\<surd>\""], ["proof (prove)\nusing this:\n  preallocated h'\n  hconf h'\n  P,h' \\<turnstile> stk' [:\\<le>] ST'\n  P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  conf_fs P h' \\<Phi> M (length Ts) T frs\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(Boolean # ST', LT')\\<rfloor>\n  pc + 1 < length ins\n  P,h' \\<turnstile> t \\<surd>t\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:(None, h',\n                           (Bool True # stk', loc, C, M, pc + 1) #\n                           frs) \\<surd>", "by fastforce"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:(None, h',\n                         (Bool True # stk', loc, C, M, pc + 1) #\n                         frs) \\<surd>\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "}"], ["proof (state)\nthis:\n  heap_write h a (CField D F) v'' ?h'17 \\<Longrightarrow>\n  \\<Phi> \\<turnstile> t:(None, ?h'17,\n                         (Bool True # stk', loc, C, M, pc + 1) #\n                         frs) \\<surd>\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "moreover"], ["proof (state)\nthis:\n  heap_write h a (CField D F) v'' ?h'17 \\<Longrightarrow>\n  \\<Phi> \\<turnstile> t:(None, ?h'17,\n                         (Bool True # stk', loc, C, M, pc + 1) #\n                         frs) \\<surd>\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "{"], ["proof (state)\nthis:\n  heap_write h a (CField D F) v'' ?h'17 \\<Longrightarrow>\n  \\<Phi> \\<turnstile> t:(None, ?h'17,\n                         (Bool True # stk', loc, C, M, pc + 1) #\n                         frs) \\<surd>\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "let ?f' = \"(Bool False # stk',loc,C,M,pc+1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "have \"\\<Phi> \\<turnstile> t:(None, h, ?f'#frs) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:(None, h,\n                           (Bool False # stk', loc, C, M, pc + 1) #\n                           frs) \\<surd>", "using tconf \"h\\<surd>\" preh mC \\<Phi>' stk'' loc' pc' fs"], ["proof (prove)\nusing this:\n  P,h \\<turnstile> t \\<surd>t\n  hconf h\n  preallocated h\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(Boolean # ST', LT')\\<rfloor>\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  pc + 1 < length ins\n  conf_fs P h \\<Phi> M (length Ts) T frs\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:(None, h,\n                           (Bool False # stk', loc, C, M, pc + 1) #\n                           frs) \\<surd>", "by fastforce"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:(None, h,\n                         (Bool False # stk', loc, C, M, pc + 1) #\n                         frs) \\<surd>\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "}"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:(None, h,\n                         (Bool False # stk', loc, C, M, pc + 1) #\n                         frs) \\<surd>\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "ultimately"], ["proof (chain)\npicking this:\n  heap_write h a (CField D F) v'' ?h'17 \\<Longrightarrow>\n  \\<Phi> \\<turnstile> t:(None, ?h'17,\n                         (Bool True # stk', loc, C, M, pc + 1) #\n                         frs) \\<surd>\n  \\<Phi> \\<turnstile> t:(None, h,\n                         (Bool False # stk', loc, C, M, pc + 1) #\n                         frs) \\<surd>", "show ?thesis"], ["proof (prove)\nusing this:\n  heap_write h a (CField D F) v'' ?h'17 \\<Longrightarrow>\n  \\<Phi> \\<turnstile> t:(None, ?h'17,\n                         (Bool True # stk', loc, C, M, pc + 1) #\n                         frs) \\<surd>\n  \\<Phi> \\<turnstile> t:(None, h,\n                         (Bool False # stk', loc, C, M, pc + 1) #\n                         frs) \\<surd>\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "using a h i mC stk' xc"], ["proof (prove)\nusing this:\n  heap_write h a (CField D F) v'' ?h'17 \\<Longrightarrow>\n  \\<Phi> \\<turnstile> t:(None, ?h'17,\n                         (Bool True # stk', loc, C, M, pc + 1) #\n                         frs) \\<surd>\n  \\<Phi> \\<turnstile> t:(None, h,\n                         (Bool False # stk', loc, C, M, pc + 1) #\n                         frs) \\<surd>\n  v = Addr a\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  ins ! pc = CAS F D\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  stk = v'' # v' # v # stk'\n  (tas, \\<sigma>') \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "by(auto simp del: correct_state_def)"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma New_correct:\n  assumes wf:   \"wf_prog wt P\"\n  assumes meth: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C\"\n  assumes ins:  \"ins!pc = New X\"\n  assumes wt:   \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes conf: \"\\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  assumes no_x: \"(tas, \\<sigma>) \\<in> exec_instr (ins!pc) P t h stk loc C M pc frs\"\n  shows \"\\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from ins conf meth"], ["proof (chain)\npicking this:\n  ins ! pc = New X\n  \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C", "obtain ST LT where\n    heap_ok: \"hconf h\" and\n    tconf:   \"P,h \\<turnstile> t \\<surd>t\" and\n    \\<Phi>_pc:    \"\\<Phi> C M!pc = Some (ST,LT)\" and\n    frame:   \"conf_f P h (ST,LT) ins (stk,loc,C,M,pc)\" and\n    frames:  \"conf_fs P h \\<Phi> M (size Ts) T frs\" and\n    preh:    \"preallocated h\""], ["proof (prove)\nusing this:\n  ins ! pc = New X\n  \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>hconf h; P,h \\<turnstile> t \\<surd>t;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         conf_f P h (ST, LT) ins (stk, loc, C, M, pc);\n         conf_fs P h \\<Phi> M (length Ts) T frs; preallocated h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: sees_method_fun)"], ["proof (state)\nthis:\n  hconf h\n  P,h \\<turnstile> t \\<surd>t\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  preallocated h\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from \\<Phi>_pc ins wt"], ["proof (chain)\npicking this:\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  ins ! pc = New X\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M", "obtain ST' LT' where\n    is_class_X: \"is_class P X\" and\n    mxs:       \"size ST < mxs\" and\n    suc_pc:     \"pc+1 < size ins\" and\n    \\<Phi>_suc:      \"\\<Phi> C M!(pc+1) = Some (ST', LT')\" and\n    less:       \"P \\<turnstile> (Class X # ST, LT) \\<le>\\<^sub>i (ST', LT')\""], ["proof (prove)\nusing this:\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  ins ! pc = New X\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n\ngoal (1 subgoal):\n 1. (\\<And>ST' LT'.\n        \\<lbrakk>is_class P X; length ST < mxs; pc + 1 < length ins;\n         \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>;\n         P \\<turnstile> (Class X # ST, LT) \\<le>\\<^sub>i (ST', LT')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_class P X\n  length ST < mxs\n  pc + 1 < length ins\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> (Class X # ST, LT) \\<le>\\<^sub>i (ST', LT')\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "proof(cases \"allocate h (Class_type X) = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. allocate h (Class_type X) = {} \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. allocate h (Class_type X) \\<noteq> {} \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "case True"], ["proof (state)\nthis:\n  allocate h (Class_type X) = {}\n\ngoal (2 subgoals):\n 1. allocate h (Class_type X) = {} \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. allocate h (Class_type X) \\<noteq> {} \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with frame frames tconf suc_pc no_x ins meth \\<Phi>_pc\n      wf_preallocatedD[OF wf, of h OutOfMemory] preh is_class_X heap_ok"], ["proof (chain)\npicking this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  P,h \\<turnstile> t \\<surd>t\n  pc + 1 < length ins\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  ins ! pc = New X\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  \\<lbrakk>preallocated h; OutOfMemory \\<in> sys_xcpts\\<rbrakk>\n  \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt OutOfMemory) =\n                    \\<lfloor>Class_type OutOfMemory\\<rfloor> \\<and>\n                    P \\<turnstile> OutOfMemory \\<preceq>\\<^sup>* Throwable\n  preallocated h\n  is_class P X\n  hconf h\n  allocate h (Class_type X) = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  P,h \\<turnstile> t \\<surd>t\n  pc + 1 < length ins\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  ins ! pc = New X\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  \\<lbrakk>preallocated h; OutOfMemory \\<in> sys_xcpts\\<rbrakk>\n  \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt OutOfMemory) =\n                    \\<lfloor>Class_type OutOfMemory\\<rfloor> \\<and>\n                    P \\<turnstile> OutOfMemory \\<preceq>\\<^sup>* Throwable\n  preallocated h\n  is_class P X\n  hconf h\n  allocate h (Class_type X) = {}\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "by(fastforce intro: tconf_hext_mono confs_hext confTs_hext conf_fs_hext)"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal (1 subgoal):\n 1. allocate h (Class_type X) \\<noteq> {} \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. allocate h (Class_type X) \\<noteq> {} \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "case False"], ["proof (state)\nthis:\n  allocate h (Class_type X) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. allocate h (Class_type X) \\<noteq> {} \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with ins meth no_x"], ["proof (chain)\npicking this:\n  ins ! pc = New X\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  allocate h (Class_type X) \\<noteq> {}", "obtain h' oref \n      where new: \"(h', oref) \\<in> allocate h (Class_type X)\"\n      and \\<sigma>': \"\\<sigma> = (None, h', (Addr oref#stk,loc,C,M,pc+1)#frs)\" (is \"\\<sigma> = (None, h', ?f # frs)\")"], ["proof (prove)\nusing this:\n  ins ! pc = New X\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  allocate h (Class_type X) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>h' oref.\n        \\<lbrakk>(h', oref) \\<in> allocate h (Class_type X);\n         \\<sigma> =\n         (None, h', (Addr oref # stk, loc, C, M, pc + 1) # frs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (h', oref) \\<in> allocate h (Class_type X)\n  \\<sigma> = (None, h', (Addr oref # stk, loc, C, M, pc + 1) # frs)\n\ngoal (1 subgoal):\n 1. allocate h (Class_type X) \\<noteq> {} \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from new"], ["proof (chain)\npicking this:\n  (h', oref) \\<in> allocate h (Class_type X)", "have hext: \"h \\<unlhd> h'\""], ["proof (prove)\nusing this:\n  (h', oref) \\<in> allocate h (Class_type X)\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "by(rule hext_allocate)"], ["proof (state)\nthis:\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. allocate h (Class_type X) \\<noteq> {} \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with preh"], ["proof (chain)\npicking this:\n  preallocated h\n  h \\<unlhd> h'", "have preh': \"preallocated h'\""], ["proof (prove)\nusing this:\n  preallocated h\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. preallocated h'", "by(rule preallocated_hext)"], ["proof (state)\nthis:\n  preallocated h'\n\ngoal (1 subgoal):\n 1. allocate h (Class_type X) \\<noteq> {} \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from new heap_ok is_class_X"], ["proof (chain)\npicking this:\n  (h', oref) \\<in> allocate h (Class_type X)\n  hconf h\n  is_class P X", "have heap_ok': \"hconf h'\""], ["proof (prove)\nusing this:\n  (h', oref) \\<in> allocate h (Class_type X)\n  hconf h\n  is_class P X\n\ngoal (1 subgoal):\n 1. hconf h'", "by(auto intro: hconf_allocate_mono)"], ["proof (state)\nthis:\n  hconf h'\n\ngoal (1 subgoal):\n 1. allocate h (Class_type X) \\<noteq> {} \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with new is_class_X"], ["proof (chain)\npicking this:\n  (h', oref) \\<in> allocate h (Class_type X)\n  is_class P X\n  hconf h'", "have h': \"typeof_addr h' oref = \\<lfloor>Class_type X\\<rfloor>\""], ["proof (prove)\nusing this:\n  (h', oref) \\<in> allocate h (Class_type X)\n  is_class P X\n  hconf h'\n\ngoal (1 subgoal):\n 1. typeof_addr h' oref = \\<lfloor>Class_type X\\<rfloor>", "by(auto dest: allocate_SomeD)"], ["proof (state)\nthis:\n  typeof_addr h' oref = \\<lfloor>Class_type X\\<rfloor>\n\ngoal (1 subgoal):\n 1. allocate h (Class_type X) \\<noteq> {} \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "note heap_ok' \\<sigma>'"], ["proof (state)\nthis:\n  hconf h'\n  \\<sigma> = (None, h', (Addr oref # stk, loc, C, M, pc + 1) # frs)\n\ngoal (1 subgoal):\n 1. allocate h (Class_type X) \\<noteq> {} \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "moreover"], ["proof (state)\nthis:\n  hconf h'\n  \\<sigma> = (None, h', (Addr oref # stk, loc, C, M, pc + 1) # frs)\n\ngoal (1 subgoal):\n 1. allocate h (Class_type X) \\<noteq> {} \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from frame less suc_pc wf h' hext"], ["proof (chain)\npicking this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  P \\<turnstile> (Class X # ST, LT) \\<le>\\<^sub>i (ST', LT')\n  pc + 1 < length ins\n  wf_prog wt P\n  typeof_addr h' oref = \\<lfloor>Class_type X\\<rfloor>\n  h \\<unlhd> h'", "have \"conf_f P h' (ST', LT') ins ?f\""], ["proof (prove)\nusing this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  P \\<turnstile> (Class X # ST, LT) \\<le>\\<^sub>i (ST', LT')\n  pc + 1 < length ins\n  wf_prog wt P\n  typeof_addr h' oref = \\<lfloor>Class_type X\\<rfloor>\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. conf_f P h' (ST', LT') ins (Addr oref # stk, loc, C, M, pc + 1)", "apply (clarsimp simp add: fun_upd_apply conf_def split_beta)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z zs.\n       \\<lbrakk>Suc pc < length ins; wf_prog wt P;\n        typeof_addr h' oref = \\<lfloor>Class_type X\\<rfloor>; h \\<unlhd> h';\n        P,h \\<turnstile> stk [:\\<le>] ST;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'; ST' = z # zs;\n        P \\<turnstile> Class X \\<le> z;\n        P \\<turnstile> ST [\\<le>] zs\\<rbrakk>\n       \\<Longrightarrow> P,h' \\<turnstile> stk [:\\<le>] zs \\<and>\n                         P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'", "apply (auto intro: confs_hext confTs_hext)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  conf_f P h' (ST', LT') ins (Addr oref # stk, loc, C, M, pc + 1)\n\ngoal (1 subgoal):\n 1. allocate h (Class_type X) \\<noteq> {} \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "moreover"], ["proof (state)\nthis:\n  conf_f P h' (ST', LT') ins (Addr oref # stk, loc, C, M, pc + 1)\n\ngoal (1 subgoal):\n 1. allocate h (Class_type X) \\<noteq> {} \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from frames hext"], ["proof (chain)\npicking this:\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  h \\<unlhd> h'", "have \"conf_fs P h' \\<Phi> M (size Ts) T frs\""], ["proof (prove)\nusing this:\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. conf_fs P h' \\<Phi> M (length Ts) T frs", "by (rule conf_fs_hext)"], ["proof (state)\nthis:\n  conf_fs P h' \\<Phi> M (length Ts) T frs\n\ngoal (1 subgoal):\n 1. allocate h (Class_type X) \\<noteq> {} \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "moreover"], ["proof (state)\nthis:\n  conf_fs P h' \\<Phi> M (length Ts) T frs\n\ngoal (1 subgoal):\n 1. allocate h (Class_type X) \\<noteq> {} \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from tconf hext"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> t \\<surd>t\n  h \\<unlhd> h'", "have \"P,h' \\<turnstile> t \\<surd>t\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> t \\<surd>t\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. P,h' \\<turnstile> t \\<surd>t", "by(rule tconf_hext_mono)"], ["proof (state)\nthis:\n  P,h' \\<turnstile> t \\<surd>t\n\ngoal (1 subgoal):\n 1. allocate h (Class_type X) \\<noteq> {} \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "ultimately"], ["proof (chain)\npicking this:\n  hconf h'\n  \\<sigma> = (None, h', (Addr oref # stk, loc, C, M, pc + 1) # frs)\n  conf_f P h' (ST', LT') ins (Addr oref # stk, loc, C, M, pc + 1)\n  conf_fs P h' \\<Phi> M (length Ts) T frs\n  P,h' \\<turnstile> t \\<surd>t", "show ?thesis"], ["proof (prove)\nusing this:\n  hconf h'\n  \\<sigma> = (None, h', (Addr oref # stk, loc, C, M, pc + 1) # frs)\n  conf_f P h' (ST', LT') ins (Addr oref # stk, loc, C, M, pc + 1)\n  conf_fs P h' \\<Phi> M (length Ts) T frs\n  P,h' \\<turnstile> t \\<surd>t\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "using meth \\<Phi>_suc preh'"], ["proof (prove)\nusing this:\n  hconf h'\n  \\<sigma> = (None, h', (Addr oref # stk, loc, C, M, pc + 1) # frs)\n  conf_f P h' (ST', LT') ins (Addr oref # stk, loc, C, M, pc + 1)\n  conf_fs P h' \\<Phi> M (length Ts) T frs\n  P,h' \\<turnstile> t \\<surd>t\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  preallocated h'\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "by fastforce"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Goto_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C; \n  ins ! pc = Goto branch; \n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  \\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>; \n  (tas, \\<sigma>') \\<in> exec P t (None, h, (stk,loc,C,M,pc)#frs) \\<rbrakk>\n\\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                     ins, xt)\\<rfloor> in C;\n     ins ! pc = Goto branch;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n     (tas, \\<sigma>')\n     \\<in> exec P t (None, h, (stk, loc, C, M, pc) # frs)\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b Tsa Ta mxsa mxl\\<^sub>0' is xta.\n       \\<lbrakk>wf_prog wt P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        ins ! pc = Goto branch; P,h \\<turnstile> t \\<surd>t;\n        tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' =\n        (None, h, (stk, loc, C, M, nat (int pc + branch)) # frs);\n        hconf h; preallocated h;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = \\<lfloor>(mxsa,\n                          mxl\\<^sub>0', is, xta)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(a, b)\\<rfloor>;\n        P,h \\<turnstile> stk [:\\<le>] a;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] b; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs; 0 \\<le> int pc + branch;\n        \\<forall>x\\<in>set (relevant_entries P (Goto branch) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> length a \\<and> d < mxs);\n        nat (int pc + branch) < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Goto branch) P pc (a, b) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x.\n           (x =\n            (nat (int pc + branch),\n             \\<lfloor>(a, b)\\<rfloor>) \\<longrightarrow>\n            (\\<exists>aa ba.\n                \\<Phi> C M ! nat (int pc + branch) =\n                \\<lfloor>(aa, ba)\\<rfloor> \\<and>\n                P \\<turnstile> a [\\<le>] aa \\<and>\n                P \\<turnstile> b [\\<le>\\<^sub>\\<top>] ba)) \\<and>\n           (x \\<in> set (xcpt_eff (Goto branch) P pc (a, b)\n                          xt) \\<longrightarrow>\n            (case x of\n             (pc', \\<tau>') \\<Rightarrow>\n               P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc'))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            (\\<exists>a b.\n                                \\<Phi> C M ! nat (int pc + branch) =\n                                \\<lfloor>(a, b)\\<rfloor> \\<and>\n                                P,h \\<turnstile> stk [:\\<le>] a \\<and>\n                                P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] b \\<and>\n                                nat (int pc + branch) < length is \\<and>\n                                conf_fs P h \\<Phi> M (length Ts) T frs)", "apply (drule (1) sees_method_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b Tsa Ta mxsa mxl\\<^sub>0' is xta.\n       \\<lbrakk>wf_prog wt P; ins ! pc = Goto branch;\n        P,h \\<turnstile> t \\<surd>t; tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' =\n        (None, h, (stk, loc, C, M, nat (int pc + branch)) # frs);\n        hconf h; preallocated h;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = \\<lfloor>(mxsa,\n                          mxl\\<^sub>0', is, xta)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(a, b)\\<rfloor>;\n        P,h \\<turnstile> stk [:\\<le>] a;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] b; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs; 0 \\<le> int pc + branch;\n        \\<forall>x\\<in>set (relevant_entries P (Goto branch) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> length a \\<and> d < mxs);\n        nat (int pc + branch) < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Goto branch) P pc (a, b) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x.\n           (x =\n            (nat (int pc + branch),\n             \\<lfloor>(a, b)\\<rfloor>) \\<longrightarrow>\n            (\\<exists>aa ba.\n                \\<Phi> C M ! nat (int pc + branch) =\n                \\<lfloor>(aa, ba)\\<rfloor> \\<and>\n                P \\<turnstile> a [\\<le>] aa \\<and>\n                P \\<turnstile> b [\\<le>\\<^sub>\\<top>] ba)) \\<and>\n           (x \\<in> set (xcpt_eff (Goto branch) P pc (a, b)\n                          xt) \\<longrightarrow>\n            (case x of\n             (pc', \\<tau>') \\<Rightarrow>\n               P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc'));\n        Tsa = Ts \\<and>\n        Ta = T \\<and>\n        \\<lfloor>(mxsa, mxl\\<^sub>0', is, xta)\\<rfloor> =\n        \\<lfloor>(mxs, mxl\\<^sub>0, ins, xt)\\<rfloor> \\<and>\n        C = C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            (\\<exists>a b.\n                                \\<Phi> C M ! nat (int pc + branch) =\n                                \\<lfloor>(a, b)\\<rfloor> \\<and>\n                                P,h \\<turnstile> stk [:\\<le>] a \\<and>\n                                P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] b \\<and>\n                                nat (int pc + branch) < length is \\<and>\n                                conf_fs P h \\<Phi> M (length Ts) T frs)", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare [[simproc del: list_to_set_comprehension]]"], ["", "lemma IfFalse_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C; \n  ins ! pc = IfFalse branch; \n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  \\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>;\n  (tas, \\<sigma>') \\<in> exec P t (None, h, (stk,loc,C,M,pc)#frs) \\<rbrakk>\n\\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                     ins, xt)\\<rfloor> in C;\n     ins ! pc = IfFalse branch;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n     (tas, \\<sigma>')\n     \\<in> exec P t (None, h, (stk, loc, C, M, pc) # frs)\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta ST LT z zs ab bb ac bc.\n       \\<lbrakk>wf_prog wt P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        ins ! pc = IfFalse branch; P,h \\<turnstile> t \\<surd>t;\n        tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' =\n        (None, h,\n         (zs, loc, C, M,\n          if z = Bool False then nat (int pc + branch) else pc + 1) #\n         frs);\n        hconf h; preallocated h;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = \\<lfloor>(mxsa,\n                          mxl\\<^sub>0', is, xta)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(Boolean # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs; 0 \\<le> int pc + branch;\n        \\<forall>x\\<in>set (relevant_entries P (IfFalse branch) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        stk = z # zs; Suc pc < length ins;\n        P,h \\<turnstile> z :\\<le> Boolean; P,h \\<turnstile> zs [:\\<le>] ST;\n        nat (int pc + branch) < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (IfFalse branch) P pc\n                             (Boolean # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (IfFalse branch) P pc\n                             (Boolean # ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        \\<Phi> C M ! Suc pc = \\<lfloor>(ab, bb)\\<rfloor>;\n        \\<Phi> C M ! nat (int pc + branch) = \\<lfloor>(ac, bc)\\<rfloor>;\n        P \\<turnstile> ST [\\<le>] ab;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] bb;\n        P \\<turnstile> ST [\\<le>] ac;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] bc\\<rbrakk>\n       \\<Longrightarrow> (z = Bool False \\<longrightarrow>\n                          (\\<exists>Ts T mxs mxl\\<^sub>0 is.\n                              (\\<exists>xt.\n                                  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n            mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                              P,h \\<turnstile> zs [:\\<le>] ac \\<and>\n                              P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bc \\<and>\n                              nat (int pc + branch) < length is \\<and>\n                              conf_fs P h \\<Phi> M (length Ts) T\n                               frs)) \\<and>\n                         (z \\<noteq> Bool False \\<longrightarrow>\n                          (\\<exists>Ts T mxs mxl\\<^sub>0 is.\n                              (\\<exists>xt.\n                                  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n            mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                              P,h \\<turnstile> zs [:\\<le>] ab \\<and>\n                              P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                              Suc pc < length is \\<and>\n                              conf_fs P h \\<Phi> M (length Ts) T frs))", "apply (drule (1) sees_method_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta ST LT z zs ab bb ac bc.\n       \\<lbrakk>wf_prog wt P; ins ! pc = IfFalse branch;\n        P,h \\<turnstile> t \\<surd>t; tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' =\n        (None, h,\n         (zs, loc, C, M,\n          if z = Bool False then nat (int pc + branch) else pc + 1) #\n         frs);\n        hconf h; preallocated h;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = \\<lfloor>(mxsa,\n                          mxl\\<^sub>0', is, xta)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(Boolean # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs; 0 \\<le> int pc + branch;\n        \\<forall>x\\<in>set (relevant_entries P (IfFalse branch) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        stk = z # zs; Suc pc < length ins;\n        P,h \\<turnstile> z :\\<le> Boolean; P,h \\<turnstile> zs [:\\<le>] ST;\n        nat (int pc + branch) < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (IfFalse branch) P pc\n                             (Boolean # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (IfFalse branch) P pc\n                             (Boolean # ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        \\<Phi> C M ! Suc pc = \\<lfloor>(ab, bb)\\<rfloor>;\n        \\<Phi> C M ! nat (int pc + branch) = \\<lfloor>(ac, bc)\\<rfloor>;\n        P \\<turnstile> ST [\\<le>] ab;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] bb;\n        P \\<turnstile> ST [\\<le>] ac;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] bc;\n        Tsa = Ts \\<and>\n        Ta = T \\<and>\n        \\<lfloor>(mxsa, mxl\\<^sub>0', is, xta)\\<rfloor> =\n        \\<lfloor>(mxs, mxl\\<^sub>0, ins, xt)\\<rfloor> \\<and>\n        C = C\\<rbrakk>\n       \\<Longrightarrow> (z = Bool False \\<longrightarrow>\n                          (\\<exists>Ts T mxs mxl\\<^sub>0 is.\n                              (\\<exists>xt.\n                                  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n            mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                              P,h \\<turnstile> zs [:\\<le>] ac \\<and>\n                              P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bc \\<and>\n                              nat (int pc + branch) < length is \\<and>\n                              conf_fs P h \\<Phi> M (length Ts) T\n                               frs)) \\<and>\n                         (z \\<noteq> Bool False \\<longrightarrow>\n                          (\\<exists>Ts T mxs mxl\\<^sub>0 is.\n                              (\\<exists>xt.\n                                  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n            mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                              P,h \\<turnstile> zs [:\\<le>] ab \\<and>\n                              P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                              Suc pc < length is \\<and>\n                              conf_fs P h \\<Phi> M (length Ts) T frs))", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare [[simproc add: list_to_set_comprehension]]"], ["", "lemma BinOp_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C; \n  ins ! pc = BinOpInstr bop;\n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  \\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>;\n  (tas, \\<sigma>') \\<in> exec P t (None, h, (stk,loc,C,M,pc)#frs) \\<rbrakk>\n\\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                     ins, xt)\\<rfloor> in C;\n     ins ! pc = BinOpInstr bop;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n     (tas, \\<sigma>')\n     \\<in> exec P t (None, h, (stk, loc, C, M, pc) # frs)\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta xp ab bb T1 T2 ST x LT z za zsa.\n       \\<lbrakk>wf_prog wt P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        ins ! pc = BinOpInstr bop; P,h \\<turnstile> t \\<surd>t;\n        tas = \\<lbrace>\\<rbrace>; \\<sigma>' = (xp, ab, bb); hconf h;\n        preallocated h;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = \\<lfloor>(mxsa,\n                          mxl\\<^sub>0', is, xta)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(T2 # T1 # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        (case the (binop bop za z) of\n         Inl v \\<Rightarrow>\n           (None, h, (v # tl (tl (z # za # zsa)), loc, C, M, pc + 1) # frs)\n         | Inr a \\<Rightarrow>\n             (\\<lfloor>a\\<rfloor>, h,\n              (z # za # zsa, loc, C, M, pc) # frs)) =\n        (xp, ab, bb);\n        \\<forall>x\\<in>set (relevant_entries P (BinOpInstr bop) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow>\n                d \\<le> Suc (Suc (length ST)) \\<and> d < mxs);\n        P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : x;\n        Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (BinOpInstr bop) P pc\n                             (T2 # T1 # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>xa.\n           (xa = (Suc pc, \\<lfloor>(x # ST, LT)\\<rfloor>) \\<longrightarrow>\n            (\\<exists>a b.\n                \\<Phi> C M ! Suc pc = \\<lfloor>(a, b)\\<rfloor> \\<and>\n                (\\<exists>z zs.\n                    a = z # zs \\<and>\n                    P \\<turnstile> x \\<le> z \\<and>\n                    P \\<turnstile> ST [\\<le>] zs) \\<and>\n                P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] b)) \\<and>\n           (xa \\<in> set (xcpt_eff (BinOpInstr bop) P pc (T2 # T1 # ST, LT)\n                           xt) \\<longrightarrow>\n            (case xa of\n             (pc', \\<tau>') \\<Rightarrow>\n               P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc'));\n        stk = z # za # zsa; P,h \\<turnstile> z :\\<le> T2;\n        P,h \\<turnstile> za :\\<le> T1;\n        P,h \\<turnstile> zsa [:\\<le>] ST\\<rbrakk>\n       \\<Longrightarrow> P,ab \\<turnstile> t \\<surd>t \\<and>\n                         hconf ab \\<and>\n                         preallocated ab \\<and>\n                         (case bb of [] \\<Rightarrow> True\n                          | f # fs \\<Rightarrow>\n                              let (stk, loc, C, M, pc) = f\n                              in \\<exists>Ts T mxs mxl\\<^sub>0 is xt \\<tau>.\n                                    P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n              mxl\\<^sub>0, is, xt)\\<rfloor> in C \\<and>\n                                    \\<Phi> C M ! pc =\n                                    \\<lfloor>\\<tau>\\<rfloor> \\<and>\n                                    conf_f P ab \\<tau> is f \\<and>\n                                    conf_fs P ab \\<Phi> M (length Ts) T\n                                     fs \\<and>\n                                    conf_xcp P ab xp (is ! pc))", "apply (drule (1) sees_method_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta xp ab bb T1 T2 ST x LT z za zsa.\n       \\<lbrakk>wf_prog wt P; ins ! pc = BinOpInstr bop;\n        P,h \\<turnstile> t \\<surd>t; tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' = (xp, ab, bb); hconf h; preallocated h;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = \\<lfloor>(mxsa,\n                          mxl\\<^sub>0', is, xta)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(T2 # T1 # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        (case the (binop bop za z) of\n         Inl v \\<Rightarrow>\n           (None, h, (v # tl (tl (z # za # zsa)), loc, C, M, pc + 1) # frs)\n         | Inr a \\<Rightarrow>\n             (\\<lfloor>a\\<rfloor>, h,\n              (z # za # zsa, loc, C, M, pc) # frs)) =\n        (xp, ab, bb);\n        \\<forall>x\\<in>set (relevant_entries P (BinOpInstr bop) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow>\n                d \\<le> Suc (Suc (length ST)) \\<and> d < mxs);\n        P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : x;\n        Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (BinOpInstr bop) P pc\n                             (T2 # T1 # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>xa.\n           (xa = (Suc pc, \\<lfloor>(x # ST, LT)\\<rfloor>) \\<longrightarrow>\n            (\\<exists>a b.\n                \\<Phi> C M ! Suc pc = \\<lfloor>(a, b)\\<rfloor> \\<and>\n                (\\<exists>z zs.\n                    a = z # zs \\<and>\n                    P \\<turnstile> x \\<le> z \\<and>\n                    P \\<turnstile> ST [\\<le>] zs) \\<and>\n                P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] b)) \\<and>\n           (xa \\<in> set (xcpt_eff (BinOpInstr bop) P pc (T2 # T1 # ST, LT)\n                           xt) \\<longrightarrow>\n            (case xa of\n             (pc', \\<tau>') \\<Rightarrow>\n               P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc'));\n        stk = z # za # zsa; P,h \\<turnstile> z :\\<le> T2;\n        P,h \\<turnstile> za :\\<le> T1; P,h \\<turnstile> zsa [:\\<le>] ST;\n        Tsa = Ts \\<and>\n        Ta = T \\<and>\n        \\<lfloor>(mxsa, mxl\\<^sub>0', is, xta)\\<rfloor> =\n        \\<lfloor>(mxs, mxl\\<^sub>0, ins, xt)\\<rfloor> \\<and>\n        C = C\\<rbrakk>\n       \\<Longrightarrow> P,ab \\<turnstile> t \\<surd>t \\<and>\n                         hconf ab \\<and>\n                         preallocated ab \\<and>\n                         (case bb of [] \\<Rightarrow> True\n                          | f # fs \\<Rightarrow>\n                              let (stk, loc, C, M, pc) = f\n                              in \\<exists>Ts T mxs mxl\\<^sub>0 is xt \\<tau>.\n                                    P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n              mxl\\<^sub>0, is, xt)\\<rfloor> in C \\<and>\n                                    \\<Phi> C M ! pc =\n                                    \\<lfloor>\\<tau>\\<rfloor> \\<and>\n                                    conf_f P ab \\<tau> is f \\<and>\n                                    conf_fs P ab \\<Phi> M (length Ts) T\n                                     fs \\<and>\n                                    conf_xcp P ab xp (is ! pc))", "apply(clarsimp simp add: conf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xp ab bb T1 T2 ST x LT z za zsa T' T'a.\n       \\<lbrakk>wf_prog wt P; ins ! pc = BinOpInstr bop;\n        P,h \\<turnstile> t \\<surd>t; tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' = (xp, ab, bb); hconf h; preallocated h;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(T2 # T1 # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT;\n        conf_fs P h \\<Phi> M (length Ts) T frs;\n        (case the (binop bop za z) of\n         Inl v \\<Rightarrow>\n           (None, h, (v # tl (tl (z # za # zsa)), loc, C, M, pc + 1) # frs)\n         | Inr a \\<Rightarrow>\n             (\\<lfloor>a\\<rfloor>, h,\n              (z # za # zsa, loc, C, M, pc) # frs)) =\n        (xp, ab, bb);\n        \\<forall>x\\<in>set (relevant_entries P (BinOpInstr bop) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow>\n                d \\<le> Suc (Suc (length ST)) \\<and> d < mxs);\n        P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : x;\n        Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (BinOpInstr bop) P pc\n                             (T2 # T1 # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>xa.\n           (xa = (Suc pc, \\<lfloor>(x # ST, LT)\\<rfloor>) \\<longrightarrow>\n            (\\<exists>a b.\n                \\<Phi> C M ! Suc pc = \\<lfloor>(a, b)\\<rfloor> \\<and>\n                (\\<exists>z zs.\n                    a = z # zs \\<and>\n                    P \\<turnstile> x \\<le> z \\<and>\n                    P \\<turnstile> ST [\\<le>] zs) \\<and>\n                P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] b)) \\<and>\n           (xa \\<in> set (xcpt_eff (BinOpInstr bop) P pc (T2 # T1 # ST, LT)\n                           xt) \\<longrightarrow>\n            (case xa of\n             (pc', \\<tau>') \\<Rightarrow>\n               P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc'));\n        stk = z # za # zsa; P,h \\<turnstile> zsa [:\\<le>] ST;\n        typeof\\<^bsub>h\\<^esub> z = \\<lfloor>T'\\<rfloor>;\n        P \\<turnstile> T' \\<le> T2;\n        typeof\\<^bsub>h\\<^esub> za = \\<lfloor>T'a\\<rfloor>;\n        P \\<turnstile> T'a \\<le> T1\\<rbrakk>\n       \\<Longrightarrow> P,ab \\<turnstile> t \\<surd>t \\<and>\n                         hconf ab \\<and>\n                         preallocated ab \\<and>\n                         (case bb of [] \\<Rightarrow> True\n                          | f # fs \\<Rightarrow>\n                              let (stk, loc, C, M, pc) = f\n                              in \\<exists>Ts T mxs mxl\\<^sub>0 is xt \\<tau>.\n                                    P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n              mxl\\<^sub>0, is, xt)\\<rfloor> in C \\<and>\n                                    \\<Phi> C M ! pc =\n                                    \\<lfloor>\\<tau>\\<rfloor> \\<and>\n                                    conf_f P ab \\<tau> is f \\<and>\n                                    conf_fs P ab \\<Phi> M (length Ts) T\n                                     fs \\<and>\n                                    conf_xcp P ab xp (is ! pc))", "apply(drule (2) WTrt_binop_widen_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xp ab bb T1 T2 ST x LT z za zsa T' T'a.\n       \\<lbrakk>wf_prog wt P; ins ! pc = BinOpInstr bop;\n        P,h \\<turnstile> t \\<surd>t; tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' = (xp, ab, bb); hconf h; preallocated h;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(T2 # T1 # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT;\n        conf_fs P h \\<Phi> M (length Ts) T frs;\n        (case the (binop bop za z) of\n         Inl v \\<Rightarrow>\n           (None, h, (v # tl (tl (z # za # zsa)), loc, C, M, pc + 1) # frs)\n         | Inr a \\<Rightarrow>\n             (\\<lfloor>a\\<rfloor>, h,\n              (z # za # zsa, loc, C, M, pc) # frs)) =\n        (xp, ab, bb);\n        \\<forall>x\\<in>set (relevant_entries P (BinOpInstr bop) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow>\n                d \\<le> Suc (Suc (length ST)) \\<and> d < mxs);\n        Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (BinOpInstr bop) P pc\n                             (T2 # T1 # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>xa.\n           (xa = (Suc pc, \\<lfloor>(x # ST, LT)\\<rfloor>) \\<longrightarrow>\n            (\\<exists>a b.\n                \\<Phi> C M ! Suc pc = \\<lfloor>(a, b)\\<rfloor> \\<and>\n                (\\<exists>z zs.\n                    a = z # zs \\<and>\n                    P \\<turnstile> x \\<le> z \\<and>\n                    P \\<turnstile> ST [\\<le>] zs) \\<and>\n                P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] b)) \\<and>\n           (xa \\<in> set (xcpt_eff (BinOpInstr bop) P pc (T2 # T1 # ST, LT)\n                           xt) \\<longrightarrow>\n            (case xa of\n             (pc', \\<tau>') \\<Rightarrow>\n               P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc'));\n        stk = z # za # zsa; P,h \\<turnstile> zsa [:\\<le>] ST;\n        typeof\\<^bsub>h\\<^esub> z = \\<lfloor>T'\\<rfloor>;\n        P \\<turnstile> T' \\<le> T2;\n        typeof\\<^bsub>h\\<^esub> za = \\<lfloor>T'a\\<rfloor>;\n        P \\<turnstile> T'a \\<le> T1;\n        \\<exists>T'aa.\n           P \\<turnstile> T'a\\<guillemotleft>bop\\<guillemotright>T' : T'aa \\<and>\n           P \\<turnstile> T'aa \\<le> x\\<rbrakk>\n       \\<Longrightarrow> P,ab \\<turnstile> t \\<surd>t \\<and>\n                         hconf ab \\<and>\n                         preallocated ab \\<and>\n                         (case bb of [] \\<Rightarrow> True\n                          | f # fs \\<Rightarrow>\n                              let (stk, loc, C, M, pc) = f\n                              in \\<exists>Ts T mxs mxl\\<^sub>0 is xt \\<tau>.\n                                    P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n              mxl\\<^sub>0, is, xt)\\<rfloor> in C \\<and>\n                                    \\<Phi> C M ! pc =\n                                    \\<lfloor>\\<tau>\\<rfloor> \\<and>\n                                    conf_f P ab \\<tau> is f \\<and>\n                                    conf_fs P ab \\<Phi> M (length Ts) T\n                                     fs \\<and>\n                                    conf_xcp P ab xp (is ! pc))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xp ab bb T1 T2 ST x LT z za zsa T' T'a T'b.\n       \\<lbrakk>wf_prog wt P; ins ! pc = BinOpInstr bop;\n        P,h \\<turnstile> t \\<surd>t; tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' = (xp, ab, bb); hconf h; preallocated h;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(T2 # T1 # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT;\n        conf_fs P h \\<Phi> M (length Ts) T frs;\n        (case the (binop bop za z) of\n         Inl v \\<Rightarrow>\n           (None, h, (v # tl (tl (z # za # zsa)), loc, C, M, pc + 1) # frs)\n         | Inr a \\<Rightarrow>\n             (\\<lfloor>a\\<rfloor>, h,\n              (z # za # zsa, loc, C, M, pc) # frs)) =\n        (xp, ab, bb);\n        \\<forall>x\\<in>set (relevant_entries P (BinOpInstr bop) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow>\n                d \\<le> Suc (Suc (length ST)) \\<and> d < mxs);\n        Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (BinOpInstr bop) P pc\n                             (T2 # T1 # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>xa.\n           (xa = (Suc pc, \\<lfloor>(x # ST, LT)\\<rfloor>) \\<longrightarrow>\n            (\\<exists>a b.\n                \\<Phi> C M ! Suc pc = \\<lfloor>(a, b)\\<rfloor> \\<and>\n                (\\<exists>z zs.\n                    a = z # zs \\<and>\n                    P \\<turnstile> x \\<le> z \\<and>\n                    P \\<turnstile> ST [\\<le>] zs) \\<and>\n                P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] b)) \\<and>\n           (xa \\<in> set (xcpt_eff (BinOpInstr bop) P pc (T2 # T1 # ST, LT)\n                           xt) \\<longrightarrow>\n            (case xa of\n             (pc', \\<tau>') \\<Rightarrow>\n               P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc'));\n        stk = z # za # zsa; P,h \\<turnstile> zsa [:\\<le>] ST;\n        typeof\\<^bsub>h\\<^esub> z = \\<lfloor>T'\\<rfloor>;\n        P \\<turnstile> T' \\<le> T2;\n        typeof\\<^bsub>h\\<^esub> za = \\<lfloor>T'a\\<rfloor>;\n        P \\<turnstile> T'a \\<le> T1;\n        P \\<turnstile> T'a\\<guillemotleft>bop\\<guillemotright>T' : T'b;\n        P \\<turnstile> T'b \\<le> x\\<rbrakk>\n       \\<Longrightarrow> P,ab \\<turnstile> t \\<surd>t \\<and>\n                         hconf ab \\<and>\n                         preallocated ab \\<and>\n                         (case bb of [] \\<Rightarrow> True\n                          | f # fs \\<Rightarrow>\n                              let (stk, loc, C, M, pc) = f\n                              in \\<exists>Ts T mxs mxl\\<^sub>0 is xt \\<tau>.\n                                    P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n              mxl\\<^sub>0, is, xt)\\<rfloor> in C \\<and>\n                                    \\<Phi> C M ! pc =\n                                    \\<lfloor>\\<tau>\\<rfloor> \\<and>\n                                    conf_f P ab \\<tau> is f \\<and>\n                                    conf_fs P ab \\<Phi> M (length Ts) T\n                                     fs \\<and>\n                                    conf_xcp P ab xp (is ! pc))", "apply(frule (2) binop_progress)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xp ab bb T1 T2 ST x LT z za zsa T' T'a T'b.\n       \\<lbrakk>wf_prog wt P; ins ! pc = BinOpInstr bop;\n        P,h \\<turnstile> t \\<surd>t; tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' = (xp, ab, bb); hconf h; preallocated h;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(T2 # T1 # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT;\n        conf_fs P h \\<Phi> M (length Ts) T frs;\n        (case the (binop bop za z) of\n         Inl v \\<Rightarrow>\n           (None, h, (v # tl (tl (z # za # zsa)), loc, C, M, pc + 1) # frs)\n         | Inr a \\<Rightarrow>\n             (\\<lfloor>a\\<rfloor>, h,\n              (z # za # zsa, loc, C, M, pc) # frs)) =\n        (xp, ab, bb);\n        \\<forall>x\\<in>set (relevant_entries P (BinOpInstr bop) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow>\n                d \\<le> Suc (Suc (length ST)) \\<and> d < mxs);\n        Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (BinOpInstr bop) P pc\n                             (T2 # T1 # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>xa.\n           (xa = (Suc pc, \\<lfloor>(x # ST, LT)\\<rfloor>) \\<longrightarrow>\n            (\\<exists>a b.\n                \\<Phi> C M ! Suc pc = \\<lfloor>(a, b)\\<rfloor> \\<and>\n                (\\<exists>z zs.\n                    a = z # zs \\<and>\n                    P \\<turnstile> x \\<le> z \\<and>\n                    P \\<turnstile> ST [\\<le>] zs) \\<and>\n                P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] b)) \\<and>\n           (xa \\<in> set (xcpt_eff (BinOpInstr bop) P pc (T2 # T1 # ST, LT)\n                           xt) \\<longrightarrow>\n            (case xa of\n             (pc', \\<tau>') \\<Rightarrow>\n               P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc'));\n        stk = z # za # zsa; P,h \\<turnstile> zsa [:\\<le>] ST;\n        typeof\\<^bsub>h\\<^esub> z = \\<lfloor>T'\\<rfloor>;\n        P \\<turnstile> T' \\<le> T2;\n        typeof\\<^bsub>h\\<^esub> za = \\<lfloor>T'a\\<rfloor>;\n        P \\<turnstile> T'a \\<le> T1;\n        P \\<turnstile> T'a\\<guillemotleft>bop\\<guillemotright>T' : T'b;\n        P \\<turnstile> T'b \\<le> x;\n        \\<exists>va. binop bop za z = \\<lfloor>va\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P,ab \\<turnstile> t \\<surd>t \\<and>\n                         hconf ab \\<and>\n                         preallocated ab \\<and>\n                         (case bb of [] \\<Rightarrow> True\n                          | f # fs \\<Rightarrow>\n                              let (stk, loc, C, M, pc) = f\n                              in \\<exists>Ts T mxs mxl\\<^sub>0 is xt \\<tau>.\n                                    P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n              mxl\\<^sub>0, is, xt)\\<rfloor> in C \\<and>\n                                    \\<Phi> C M ! pc =\n                                    \\<lfloor>\\<tau>\\<rfloor> \\<and>\n                                    conf_f P ab \\<tau> is f \\<and>\n                                    conf_fs P ab \\<Phi> M (length Ts) T\n                                     fs \\<and>\n                                    conf_xcp P ab xp (is ! pc))", "apply(clarsimp split: sum.split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>T1 T2 ST x LT z za zsa T' T'a T'b x1.\n       \\<lbrakk>\\<forall>x\\<in>set (relevant_entries P (BinOpInstr bop) pc\n                                     xt).\n                   case x of\n                   (f, t, C, ab) \\<Rightarrow>\n                     (case C of None \\<Rightarrow> True\n                      | \\<lfloor>x\\<rfloor> \\<Rightarrow>\n                          is_class P x) \\<and>\n                     (case ab of\n                      (h, d) \\<Rightarrow>\n                        d \\<le> Suc (Suc (length ST)) \\<and> d < mxs);\n        Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (BinOpInstr bop) P pc\n                             (T2 # T1 # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>xa.\n           (xa = (Suc pc, \\<lfloor>(x # ST, LT)\\<rfloor>) \\<longrightarrow>\n            (\\<exists>a b.\n                \\<Phi> C M ! Suc pc = \\<lfloor>(a, b)\\<rfloor> \\<and>\n                (\\<exists>z zs.\n                    a = z # zs \\<and>\n                    P \\<turnstile> x \\<le> z \\<and>\n                    P \\<turnstile> ST [\\<le>] zs) \\<and>\n                P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] b)) \\<and>\n           (xa \\<in> set (xcpt_eff (BinOpInstr bop) P pc (T2 # T1 # ST, LT)\n                           xt) \\<longrightarrow>\n            (case xa of\n             (pc', \\<tau>') \\<Rightarrow>\n               P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc'));\n        stk = z # za # zsa; P,h \\<turnstile> zsa [:\\<le>] ST;\n        typeof\\<^bsub>h\\<^esub> z = \\<lfloor>T'\\<rfloor>;\n        P \\<turnstile> T' \\<le> T2;\n        typeof\\<^bsub>h\\<^esub> za = \\<lfloor>T'a\\<rfloor>;\n        P \\<turnstile> T'a \\<le> T1;\n        P \\<turnstile> T'a\\<guillemotleft>bop\\<guillemotright>T' : T'b;\n        P \\<turnstile> T'b \\<le> x; wf_prog wt P; ins ! pc = BinOpInstr bop;\n        P,h \\<turnstile> t \\<surd>t; tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' = (None, h, (x1 # zsa, loc, C, M, Suc pc) # frs); hconf h;\n        preallocated h;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(T2 # T1 # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT;\n        conf_fs P h \\<Phi> M (length Ts) T frs;\n        binop bop za z = \\<lfloor>Inl x1\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            (\\<exists>a b.\n                                \\<Phi> C M ! Suc pc =\n                                \\<lfloor>(a, b)\\<rfloor> \\<and>\n                                P,h \\<turnstile> x1 # zsa [:\\<le>] a \\<and>\n                                P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] b \\<and>\n                                Suc pc < length is \\<and>\n                                conf_fs P h \\<Phi> M (length Ts) T frs)\n 2. \\<And>T1 T2 ST x LT z za zsa T' T'a T'b x2.\n       \\<lbrakk>\\<forall>x\\<in>set (relevant_entries P (BinOpInstr bop) pc\n                                     xt).\n                   case x of\n                   (f, t, C, ab) \\<Rightarrow>\n                     (case C of None \\<Rightarrow> True\n                      | \\<lfloor>x\\<rfloor> \\<Rightarrow>\n                          is_class P x) \\<and>\n                     (case ab of\n                      (h, d) \\<Rightarrow>\n                        d \\<le> Suc (Suc (length ST)) \\<and> d < mxs);\n        Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (BinOpInstr bop) P pc\n                             (T2 # T1 # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>xa.\n           (xa = (Suc pc, \\<lfloor>(x # ST, LT)\\<rfloor>) \\<longrightarrow>\n            (\\<exists>a b.\n                \\<Phi> C M ! Suc pc = \\<lfloor>(a, b)\\<rfloor> \\<and>\n                (\\<exists>z zs.\n                    a = z # zs \\<and>\n                    P \\<turnstile> x \\<le> z \\<and>\n                    P \\<turnstile> ST [\\<le>] zs) \\<and>\n                P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] b)) \\<and>\n           (xa \\<in> set (xcpt_eff (BinOpInstr bop) P pc (T2 # T1 # ST, LT)\n                           xt) \\<longrightarrow>\n            (case xa of\n             (pc', \\<tau>') \\<Rightarrow>\n               P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc'));\n        stk = z # za # zsa; P,h \\<turnstile> zsa [:\\<le>] ST;\n        typeof\\<^bsub>h\\<^esub> z = \\<lfloor>T'\\<rfloor>;\n        P \\<turnstile> T' \\<le> T2;\n        typeof\\<^bsub>h\\<^esub> za = \\<lfloor>T'a\\<rfloor>;\n        P \\<turnstile> T'a \\<le> T1;\n        P \\<turnstile> T'a\\<guillemotleft>bop\\<guillemotright>T' : T'b;\n        P \\<turnstile> T'b \\<le> x; wf_prog wt P; ins ! pc = BinOpInstr bop;\n        P,h \\<turnstile> t \\<surd>t; tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' =\n        (\\<lfloor>x2\\<rfloor>, h, (z # za # zsa, loc, C, M, pc) # frs);\n        hconf h; preallocated h;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(T2 # T1 # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT;\n        conf_fs P h \\<Phi> M (length Ts) T frs;\n        binop bop za z = \\<lfloor>Inr x2\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            P,h \\<turnstile> z :\\<le> T2 \\<and>\n                            P,h \\<turnstile> za :\\<le> T1 \\<and>\n                            pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs \\<and>\n                            (\\<exists>D.\n                                typeof_addr h x2 =\n                                \\<lfloor>Class_type D\\<rfloor> \\<and>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* Throwable \\<and>\n                                (\\<forall>D'.\n                                    P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<longrightarrow>\n                                    is_relevant_class (is ! pc) P D'))", "apply(frule (5) binop_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>T1 T2 ST x LT z za zsa T' T'a T'b x1.\n       \\<lbrakk>\\<forall>x\\<in>set (relevant_entries P (BinOpInstr bop) pc\n                                     xt).\n                   case x of\n                   (f, t, C, ab) \\<Rightarrow>\n                     (case C of None \\<Rightarrow> True\n                      | \\<lfloor>x\\<rfloor> \\<Rightarrow>\n                          is_class P x) \\<and>\n                     (case ab of\n                      (h, d) \\<Rightarrow>\n                        d \\<le> Suc (Suc (length ST)) \\<and> d < mxs);\n        Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (BinOpInstr bop) P pc\n                             (T2 # T1 # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>xa.\n           (xa = (Suc pc, \\<lfloor>(x # ST, LT)\\<rfloor>) \\<longrightarrow>\n            (\\<exists>a b.\n                \\<Phi> C M ! Suc pc = \\<lfloor>(a, b)\\<rfloor> \\<and>\n                (\\<exists>z zs.\n                    a = z # zs \\<and>\n                    P \\<turnstile> x \\<le> z \\<and>\n                    P \\<turnstile> ST [\\<le>] zs) \\<and>\n                P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] b)) \\<and>\n           (xa \\<in> set (xcpt_eff (BinOpInstr bop) P pc (T2 # T1 # ST, LT)\n                           xt) \\<longrightarrow>\n            (case xa of\n             (pc', \\<tau>') \\<Rightarrow>\n               P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc'));\n        stk = z # za # zsa; P,h \\<turnstile> zsa [:\\<le>] ST;\n        typeof\\<^bsub>h\\<^esub> z = \\<lfloor>T'\\<rfloor>;\n        P \\<turnstile> T' \\<le> T2;\n        typeof\\<^bsub>h\\<^esub> za = \\<lfloor>T'a\\<rfloor>;\n        P \\<turnstile> T'a \\<le> T1;\n        P \\<turnstile> T'a\\<guillemotleft>bop\\<guillemotright>T' : T'b;\n        P \\<turnstile> T'b \\<le> x; wf_prog wt P; ins ! pc = BinOpInstr bop;\n        P,h \\<turnstile> t \\<surd>t; tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' = (None, h, (x1 # zsa, loc, C, M, Suc pc) # frs); hconf h;\n        preallocated h;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(T2 # T1 # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT;\n        conf_fs P h \\<Phi> M (length Ts) T frs;\n        binop bop za z = \\<lfloor>Inl x1\\<rfloor>;\n        P,h \\<turnstile> x1 :\\<le> T'b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            (\\<exists>a b.\n                                \\<Phi> C M ! Suc pc =\n                                \\<lfloor>(a, b)\\<rfloor> \\<and>\n                                P,h \\<turnstile> x1 # zsa [:\\<le>] a \\<and>\n                                P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] b \\<and>\n                                Suc pc < length is \\<and>\n                                conf_fs P h \\<Phi> M (length Ts) T frs)\n 2. \\<And>T1 T2 ST x LT z za zsa T' T'a T'b x2.\n       \\<lbrakk>\\<forall>x\\<in>set (relevant_entries P (BinOpInstr bop) pc\n                                     xt).\n                   case x of\n                   (f, t, C, ab) \\<Rightarrow>\n                     (case C of None \\<Rightarrow> True\n                      | \\<lfloor>x\\<rfloor> \\<Rightarrow>\n                          is_class P x) \\<and>\n                     (case ab of\n                      (h, d) \\<Rightarrow>\n                        d \\<le> Suc (Suc (length ST)) \\<and> d < mxs);\n        Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (BinOpInstr bop) P pc\n                             (T2 # T1 # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>xa.\n           (xa = (Suc pc, \\<lfloor>(x # ST, LT)\\<rfloor>) \\<longrightarrow>\n            (\\<exists>a b.\n                \\<Phi> C M ! Suc pc = \\<lfloor>(a, b)\\<rfloor> \\<and>\n                (\\<exists>z zs.\n                    a = z # zs \\<and>\n                    P \\<turnstile> x \\<le> z \\<and>\n                    P \\<turnstile> ST [\\<le>] zs) \\<and>\n                P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] b)) \\<and>\n           (xa \\<in> set (xcpt_eff (BinOpInstr bop) P pc (T2 # T1 # ST, LT)\n                           xt) \\<longrightarrow>\n            (case xa of\n             (pc', \\<tau>') \\<Rightarrow>\n               P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc'));\n        stk = z # za # zsa; P,h \\<turnstile> zsa [:\\<le>] ST;\n        typeof\\<^bsub>h\\<^esub> z = \\<lfloor>T'\\<rfloor>;\n        P \\<turnstile> T' \\<le> T2;\n        typeof\\<^bsub>h\\<^esub> za = \\<lfloor>T'a\\<rfloor>;\n        P \\<turnstile> T'a \\<le> T1;\n        P \\<turnstile> T'a\\<guillemotleft>bop\\<guillemotright>T' : T'b;\n        P \\<turnstile> T'b \\<le> x; wf_prog wt P; ins ! pc = BinOpInstr bop;\n        P,h \\<turnstile> t \\<surd>t; tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' =\n        (\\<lfloor>x2\\<rfloor>, h, (z # za # zsa, loc, C, M, pc) # frs);\n        hconf h; preallocated h;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(T2 # T1 # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT;\n        conf_fs P h \\<Phi> M (length Ts) T frs;\n        binop bop za z = \\<lfloor>Inr x2\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            P,h \\<turnstile> z :\\<le> T2 \\<and>\n                            P,h \\<turnstile> za :\\<le> T1 \\<and>\n                            pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs \\<and>\n                            (\\<exists>D.\n                                typeof_addr h x2 =\n                                \\<lfloor>Class_type D\\<rfloor> \\<and>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* Throwable \\<and>\n                                (\\<forall>D'.\n                                    P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<longrightarrow>\n                                    is_relevant_class (is ! pc) P D'))", "apply(fastforce intro: widen_trans simp add: conf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ST x LT z za zsa T' T'a T'b x2.\n       \\<lbrakk>\\<forall>x\\<in>set (relevant_entries P (BinOpInstr bop) pc\n                                     xt).\n                   case x of\n                   (f, t, C, ab) \\<Rightarrow>\n                     (case C of None \\<Rightarrow> True\n                      | \\<lfloor>x\\<rfloor> \\<Rightarrow>\n                          is_class P x) \\<and>\n                     (case ab of\n                      (h, d) \\<Rightarrow>\n                        d \\<le> Suc (Suc (length ST)) \\<and> d < mxs);\n        Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (BinOpInstr bop) P pc\n                             (T2 # T1 # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>xa.\n           (xa = (Suc pc, \\<lfloor>(x # ST, LT)\\<rfloor>) \\<longrightarrow>\n            (\\<exists>a b.\n                \\<Phi> C M ! Suc pc = \\<lfloor>(a, b)\\<rfloor> \\<and>\n                (\\<exists>z zs.\n                    a = z # zs \\<and>\n                    P \\<turnstile> x \\<le> z \\<and>\n                    P \\<turnstile> ST [\\<le>] zs) \\<and>\n                P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] b)) \\<and>\n           (xa \\<in> set (xcpt_eff (BinOpInstr bop) P pc (T2 # T1 # ST, LT)\n                           xt) \\<longrightarrow>\n            (case xa of\n             (pc', \\<tau>') \\<Rightarrow>\n               P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc'));\n        stk = z # za # zsa; P,h \\<turnstile> zsa [:\\<le>] ST;\n        typeof\\<^bsub>h\\<^esub> z = \\<lfloor>T'\\<rfloor>;\n        P \\<turnstile> T' \\<le> T2;\n        typeof\\<^bsub>h\\<^esub> za = \\<lfloor>T'a\\<rfloor>;\n        P \\<turnstile> T'a \\<le> T1;\n        P \\<turnstile> T'a\\<guillemotleft>bop\\<guillemotright>T' : T'b;\n        P \\<turnstile> T'b \\<le> x; wf_prog wt P; ins ! pc = BinOpInstr bop;\n        P,h \\<turnstile> t \\<surd>t; tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' =\n        (\\<lfloor>x2\\<rfloor>, h, (z # za # zsa, loc, C, M, pc) # frs);\n        hconf h; preallocated h;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(T2 # T1 # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT;\n        conf_fs P h \\<Phi> M (length Ts) T frs;\n        binop bop za z = \\<lfloor>Inr x2\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            P,h \\<turnstile> z :\\<le> T2 \\<and>\n                            P,h \\<turnstile> za :\\<le> T1 \\<and>\n                            pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs \\<and>\n                            (\\<exists>D.\n                                typeof_addr h x2 =\n                                \\<lfloor>Class_type D\\<rfloor> \\<and>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* Throwable \\<and>\n                                (\\<forall>D'.\n                                    P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<longrightarrow>\n                                    is_relevant_class (is ! pc) P D'))", "apply(frule (5) binop_type)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ST x LT z za zsa T' T'a T'b x2.\n       \\<lbrakk>\\<forall>x\\<in>set (relevant_entries P (BinOpInstr bop) pc\n                                     xt).\n                   case x of\n                   (f, t, C, ab) \\<Rightarrow>\n                     (case C of None \\<Rightarrow> True\n                      | \\<lfloor>x\\<rfloor> \\<Rightarrow>\n                          is_class P x) \\<and>\n                     (case ab of\n                      (h, d) \\<Rightarrow>\n                        d \\<le> Suc (Suc (length ST)) \\<and> d < mxs);\n        Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (BinOpInstr bop) P pc\n                             (T2 # T1 # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>xa.\n           (xa = (Suc pc, \\<lfloor>(x # ST, LT)\\<rfloor>) \\<longrightarrow>\n            (\\<exists>a b.\n                \\<Phi> C M ! Suc pc = \\<lfloor>(a, b)\\<rfloor> \\<and>\n                (\\<exists>z zs.\n                    a = z # zs \\<and>\n                    P \\<turnstile> x \\<le> z \\<and>\n                    P \\<turnstile> ST [\\<le>] zs) \\<and>\n                P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] b)) \\<and>\n           (xa \\<in> set (xcpt_eff (BinOpInstr bop) P pc (T2 # T1 # ST, LT)\n                           xt) \\<longrightarrow>\n            (case xa of\n             (pc', \\<tau>') \\<Rightarrow>\n               P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc'));\n        stk = z # za # zsa; P,h \\<turnstile> zsa [:\\<le>] ST;\n        typeof\\<^bsub>h\\<^esub> z = \\<lfloor>T'\\<rfloor>;\n        P \\<turnstile> T' \\<le> T2;\n        typeof\\<^bsub>h\\<^esub> za = \\<lfloor>T'a\\<rfloor>;\n        P \\<turnstile> T'a \\<le> T1;\n        P \\<turnstile> T'a\\<guillemotleft>bop\\<guillemotright>T' : T'b;\n        P \\<turnstile> T'b \\<le> x; wf_prog wt P; ins ! pc = BinOpInstr bop;\n        P,h \\<turnstile> t \\<surd>t; tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' =\n        (\\<lfloor>x2\\<rfloor>, h, (z # za # zsa, loc, C, M, pc) # frs);\n        hconf h; preallocated h;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(T2 # T1 # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT;\n        conf_fs P h \\<Phi> M (length Ts) T frs;\n        binop bop za z = \\<lfloor>Inr x2\\<rfloor>;\n        P,h \\<turnstile> Addr x2 :\\<le> Class Throwable\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            P,h \\<turnstile> z :\\<le> T2 \\<and>\n                            P,h \\<turnstile> za :\\<le> T1 \\<and>\n                            pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs \\<and>\n                            (\\<exists>D.\n                                typeof_addr h x2 =\n                                \\<lfloor>Class_type D\\<rfloor> \\<and>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* Throwable \\<and>\n                                (\\<forall>D'.\n                                    P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<longrightarrow>\n                                    is_relevant_class (is ! pc) P D'))", "apply(clarsimp simp add: conf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ST x LT z za zsa T' T'a T'b x2 zb.\n       \\<lbrakk>\\<forall>x\\<in>set (relevant_entries P (BinOpInstr bop) pc\n                                     xt).\n                   case x of\n                   (f, t, C, ab) \\<Rightarrow>\n                     (case C of None \\<Rightarrow> True\n                      | \\<lfloor>x\\<rfloor> \\<Rightarrow>\n                          is_class P x) \\<and>\n                     (case ab of\n                      (h, d) \\<Rightarrow>\n                        d \\<le> Suc (Suc (length ST)) \\<and> d < mxs);\n        Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (BinOpInstr bop) P pc\n                             (T2 # T1 # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>xa.\n           (xa = (Suc pc, \\<lfloor>(x # ST, LT)\\<rfloor>) \\<longrightarrow>\n            (\\<exists>a b.\n                \\<Phi> C M ! Suc pc = \\<lfloor>(a, b)\\<rfloor> \\<and>\n                (\\<exists>z zs.\n                    a = z # zs \\<and>\n                    P \\<turnstile> x \\<le> z \\<and>\n                    P \\<turnstile> ST [\\<le>] zs) \\<and>\n                P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] b)) \\<and>\n           (xa \\<in> set (xcpt_eff (BinOpInstr bop) P pc (T2 # T1 # ST, LT)\n                           xt) \\<longrightarrow>\n            (case xa of\n             (pc', \\<tau>') \\<Rightarrow>\n               P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc'));\n        stk = z # za # zsa; P,h \\<turnstile> zsa [:\\<le>] ST;\n        typeof\\<^bsub>h\\<^esub> z = \\<lfloor>T'\\<rfloor>;\n        P \\<turnstile> T' \\<le> T2;\n        typeof\\<^bsub>h\\<^esub> za = \\<lfloor>T'a\\<rfloor>;\n        P \\<turnstile> T'a \\<le> T1;\n        P \\<turnstile> T'a\\<guillemotleft>bop\\<guillemotright>T' : T'b;\n        P \\<turnstile> T'b \\<le> x; wf_prog wt P; ins ! pc = BinOpInstr bop;\n        P,h \\<turnstile> t \\<surd>t; tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' =\n        (\\<lfloor>x2\\<rfloor>, h, (z # za # zsa, loc, C, M, pc) # frs);\n        hconf h; preallocated h;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(T2 # T1 # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT;\n        conf_fs P h \\<Phi> M (length Ts) T frs;\n        binop bop za z = \\<lfloor>Inr x2\\<rfloor>;\n        P \\<turnstile> ty_of_htype zb \\<le> Class Throwable;\n        typeof_addr h x2 = \\<lfloor>zb\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs \\<and>\n                            (\\<exists>D.\n                                zb = Class_type D \\<and>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* Throwable \\<and>\n                                (\\<forall>D'.\n                                    P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<longrightarrow>\n                                    is_relevant_class (is ! pc) P D'))", "apply(clarsimp simp add: widen_Class)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ST x LT z za zsa T' T'a T'b x2 D.\n       \\<lbrakk>\\<forall>x\\<in>set (relevant_entries P (BinOpInstr bop) pc\n                                     xt).\n                   case x of\n                   (f, t, C, ab) \\<Rightarrow>\n                     (case C of None \\<Rightarrow> True\n                      | \\<lfloor>x\\<rfloor> \\<Rightarrow>\n                          is_class P x) \\<and>\n                     (case ab of\n                      (h, d) \\<Rightarrow>\n                        d \\<le> Suc (Suc (length ST)) \\<and> d < mxs);\n        Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (BinOpInstr bop) P pc\n                             (T2 # T1 # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>xa.\n           (xa = (Suc pc, \\<lfloor>(x # ST, LT)\\<rfloor>) \\<longrightarrow>\n            (\\<exists>a b.\n                \\<Phi> C M ! Suc pc = \\<lfloor>(a, b)\\<rfloor> \\<and>\n                (\\<exists>z zs.\n                    a = z # zs \\<and>\n                    P \\<turnstile> x \\<le> z \\<and>\n                    P \\<turnstile> ST [\\<le>] zs) \\<and>\n                P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] b)) \\<and>\n           (xa \\<in> set (xcpt_eff (BinOpInstr bop) P pc (T2 # T1 # ST, LT)\n                           xt) \\<longrightarrow>\n            (case xa of\n             (pc', \\<tau>') \\<Rightarrow>\n               P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc'));\n        stk = z # za # zsa; P,h \\<turnstile> zsa [:\\<le>] ST;\n        typeof\\<^bsub>h\\<^esub> z = \\<lfloor>T'\\<rfloor>;\n        P \\<turnstile> T' \\<le> T2;\n        typeof\\<^bsub>h\\<^esub> za = \\<lfloor>T'a\\<rfloor>;\n        P \\<turnstile> T'a \\<le> T1;\n        P \\<turnstile> T'a\\<guillemotleft>bop\\<guillemotright>T' : T'b;\n        P \\<turnstile> T'b \\<le> x; wf_prog wt P; ins ! pc = BinOpInstr bop;\n        P,h \\<turnstile> t \\<surd>t; tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' =\n        (\\<lfloor>x2\\<rfloor>, h, (z # za # zsa, loc, C, M, pc) # frs);\n        hconf h; preallocated h;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(T2 # T1 # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT;\n        conf_fs P h \\<Phi> M (length Ts) T frs;\n        binop bop za z = \\<lfloor>Inr x2\\<rfloor>;\n        typeof_addr h x2 = \\<lfloor>Class_type D\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Throwable\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs \\<and>\n                            (\\<forall>D'.\n                                P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<longrightarrow>\n                                is_relevant_class (is ! pc) P D')", "apply(fastforce intro: widen_trans dest: binop_relevant_class simp add: cname_of_def conf_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Pop_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C; \n  ins ! pc = Pop;\n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  \\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>;\n  (tas, \\<sigma>') \\<in> exec P t (None, h, (stk,loc,C,M,pc)#frs) \\<rbrakk>\n\\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                     ins, xt)\\<rfloor> in C;\n     ins ! pc = Pop;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n     (tas, \\<sigma>')\n     \\<in> exec P t (None, h, (stk, loc, C, M, pc) # frs)\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta ts ST LT z zs.\n       \\<lbrakk>wf_prog wt P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        ins ! pc = Pop; P,h \\<turnstile> t \\<surd>t;\n        tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' = (None, h, (zs, loc, C, M, Suc pc) # frs); hconf h;\n        preallocated h;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = \\<lfloor>(mxsa,\n                          mxl\\<^sub>0', is, xta)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(ts # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P Pop pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        Suc pc < length ins; stk = z # zs;\n        \\<forall>x\\<in>set (xcpt_eff Pop P pc (ts # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x.\n           (x = (Suc pc, \\<lfloor>(ST, LT)\\<rfloor>) \\<longrightarrow>\n            (\\<exists>a b.\n                \\<Phi> C M ! Suc pc = \\<lfloor>(a, b)\\<rfloor> \\<and>\n                P \\<turnstile> ST [\\<le>] a \\<and>\n                P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] b)) \\<and>\n           (x \\<in> set (xcpt_eff Pop P pc (ts # ST, LT)\n                          xt) \\<longrightarrow>\n            (case x of\n             (pc', \\<tau>') \\<Rightarrow>\n               P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc'));\n        P,h \\<turnstile> z :\\<le> ts;\n        P,h \\<turnstile> zs [:\\<le>] ST\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            (\\<exists>a b.\n                                \\<Phi> C M ! Suc pc =\n                                \\<lfloor>(a, b)\\<rfloor> \\<and>\n                                P,h \\<turnstile> zs [:\\<le>] a \\<and>\n                                P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] b \\<and>\n                                Suc pc < length is \\<and>\n                                conf_fs P h \\<Phi> M (length Ts) T frs)", "apply (drule (1) sees_method_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta ts ST LT z zs.\n       \\<lbrakk>wf_prog wt P; ins ! pc = Pop; P,h \\<turnstile> t \\<surd>t;\n        tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' = (None, h, (zs, loc, C, M, Suc pc) # frs); hconf h;\n        preallocated h;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = \\<lfloor>(mxsa,\n                          mxl\\<^sub>0', is, xta)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(ts # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P Pop pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        Suc pc < length ins; stk = z # zs;\n        \\<forall>x\\<in>set (xcpt_eff Pop P pc (ts # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x.\n           (x = (Suc pc, \\<lfloor>(ST, LT)\\<rfloor>) \\<longrightarrow>\n            (\\<exists>a b.\n                \\<Phi> C M ! Suc pc = \\<lfloor>(a, b)\\<rfloor> \\<and>\n                P \\<turnstile> ST [\\<le>] a \\<and>\n                P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] b)) \\<and>\n           (x \\<in> set (xcpt_eff Pop P pc (ts # ST, LT)\n                          xt) \\<longrightarrow>\n            (case x of\n             (pc', \\<tau>') \\<Rightarrow>\n               P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc'));\n        P,h \\<turnstile> z :\\<le> ts; P,h \\<turnstile> zs [:\\<le>] ST;\n        Tsa = Ts \\<and>\n        Ta = T \\<and>\n        \\<lfloor>(mxsa, mxl\\<^sub>0', is, xta)\\<rfloor> =\n        \\<lfloor>(mxs, mxl\\<^sub>0, ins, xt)\\<rfloor> \\<and>\n        C = C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            (\\<exists>a b.\n                                \\<Phi> C M ! Suc pc =\n                                \\<lfloor>(a, b)\\<rfloor> \\<and>\n                                P,h \\<turnstile> zs [:\\<le>] a \\<and>\n                                P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] b \\<and>\n                                Suc pc < length is \\<and>\n                                conf_fs P h \\<Phi> M (length Ts) T frs)", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Dup_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C; \n  ins ! pc = Dup;\n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  \\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>;\n  (tas, \\<sigma>') \\<in> exec P t (None, h, (stk,loc,C,M,pc)#frs) \\<rbrakk>\n\\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                     ins, xt)\\<rfloor> in C;\n     ins ! pc = Dup;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n     (tas, \\<sigma>')\n     \\<in> exec P t (None, h, (stk, loc, C, M, pc) # frs)\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta Taa ST LT z zs.\n       \\<lbrakk>wf_prog wt P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        ins ! pc = Dup; P,h \\<turnstile> t \\<surd>t;\n        tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' = (None, h, (z # z # zs, loc, C, M, Suc pc) # frs);\n        hconf h; preallocated h;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = \\<lfloor>(mxsa,\n                          mxl\\<^sub>0', is, xta)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(Taa # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P Dup pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        Suc (length ST) < mxs; Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff Dup P pc (Taa # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x.\n           (x =\n            (Suc pc,\n             \\<lfloor>(Taa # Taa # ST, LT)\\<rfloor>) \\<longrightarrow>\n            (\\<exists>a b.\n                \\<Phi> C M ! Suc pc = \\<lfloor>(a, b)\\<rfloor> \\<and>\n                (\\<exists>z zs.\n                    a = z # zs \\<and>\n                    P \\<turnstile> Taa \\<le> z \\<and>\n                    (\\<exists>z zsa.\n                        zs = z # zsa \\<and>\n                        P \\<turnstile> Taa \\<le> z \\<and>\n                        P \\<turnstile> ST [\\<le>] zsa)) \\<and>\n                P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] b)) \\<and>\n           (x \\<in> set (xcpt_eff Dup P pc (Taa # ST, LT)\n                          xt) \\<longrightarrow>\n            (case x of\n             (pc', \\<tau>') \\<Rightarrow>\n               P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc'));\n        stk = z # zs; P,h \\<turnstile> z :\\<le> Taa;\n        P,h \\<turnstile> zs [:\\<le>] ST\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            (\\<exists>a b.\n                                \\<Phi> C M ! Suc pc =\n                                \\<lfloor>(a, b)\\<rfloor> \\<and>\n                                P,h \\<turnstile> z #\n           z # zs [:\\<le>] a \\<and>\n                                P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] b \\<and>\n                                Suc pc < length is \\<and>\n                                conf_fs P h \\<Phi> M (length Ts) T frs)", "apply (drule (1) sees_method_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta Taa ST LT z zs.\n       \\<lbrakk>wf_prog wt P; ins ! pc = Dup; P,h \\<turnstile> t \\<surd>t;\n        tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' = (None, h, (z # z # zs, loc, C, M, Suc pc) # frs);\n        hconf h; preallocated h;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = \\<lfloor>(mxsa,\n                          mxl\\<^sub>0', is, xta)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(Taa # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P Dup pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        Suc (length ST) < mxs; Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff Dup P pc (Taa # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x.\n           (x =\n            (Suc pc,\n             \\<lfloor>(Taa # Taa # ST, LT)\\<rfloor>) \\<longrightarrow>\n            (\\<exists>a b.\n                \\<Phi> C M ! Suc pc = \\<lfloor>(a, b)\\<rfloor> \\<and>\n                (\\<exists>z zs.\n                    a = z # zs \\<and>\n                    P \\<turnstile> Taa \\<le> z \\<and>\n                    (\\<exists>z zsa.\n                        zs = z # zsa \\<and>\n                        P \\<turnstile> Taa \\<le> z \\<and>\n                        P \\<turnstile> ST [\\<le>] zsa)) \\<and>\n                P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] b)) \\<and>\n           (x \\<in> set (xcpt_eff Dup P pc (Taa # ST, LT)\n                          xt) \\<longrightarrow>\n            (case x of\n             (pc', \\<tau>') \\<Rightarrow>\n               P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc'));\n        stk = z # zs; P,h \\<turnstile> z :\\<le> Taa;\n        P,h \\<turnstile> zs [:\\<le>] ST;\n        Tsa = Ts \\<and>\n        Ta = T \\<and>\n        \\<lfloor>(mxsa, mxl\\<^sub>0', is, xta)\\<rfloor> =\n        \\<lfloor>(mxs, mxl\\<^sub>0, ins, xt)\\<rfloor> \\<and>\n        C = C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            (\\<exists>a b.\n                                \\<Phi> C M ! Suc pc =\n                                \\<lfloor>(a, b)\\<rfloor> \\<and>\n                                P,h \\<turnstile> z #\n           z # zs [:\\<le>] a \\<and>\n                                P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] b \\<and>\n                                Suc pc < length is \\<and>\n                                conf_fs P h \\<Phi> M (length Ts) T frs)", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Swap_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C; \n  ins ! pc = Swap;\n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  \\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>;\n  (tas, \\<sigma>') \\<in> exec P t (None, h, (stk,loc,C,M,pc)#frs) \\<rbrakk>\n\\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                     ins, xt)\\<rfloor> in C;\n     ins ! pc = Swap;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n     (tas, \\<sigma>')\n     \\<in> exec P t (None, h, (stk, loc, C, M, pc) # frs)\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta T1 T2 ST LT z za zsa.\n       \\<lbrakk>wf_prog wt P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        ins ! pc = Swap; P,h \\<turnstile> t \\<surd>t;\n        tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' = (None, h, (za # z # zsa, loc, C, M, Suc pc) # frs);\n        hconf h; preallocated h;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = \\<lfloor>(mxsa,\n                          mxl\\<^sub>0', is, xta)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(T1 # T2 # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P Swap pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow>\n                d \\<le> Suc (Suc (length ST)) \\<and> d < mxs);\n        Suc pc < length ins; stk = z # za # zsa;\n        \\<forall>x\\<in>set (xcpt_eff Swap P pc (T1 # T2 # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x.\n           (x =\n            (Suc pc, \\<lfloor>(T2 # T1 # ST, LT)\\<rfloor>) \\<longrightarrow>\n            (\\<exists>a b.\n                \\<Phi> C M ! Suc pc = \\<lfloor>(a, b)\\<rfloor> \\<and>\n                (\\<exists>z zs.\n                    a = z # zs \\<and>\n                    P \\<turnstile> T2 \\<le> z \\<and>\n                    (\\<exists>z zsa.\n                        zs = z # zsa \\<and>\n                        P \\<turnstile> T1 \\<le> z \\<and>\n                        P \\<turnstile> ST [\\<le>] zsa)) \\<and>\n                P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] b)) \\<and>\n           (x \\<in> set (xcpt_eff Swap P pc (T1 # T2 # ST, LT)\n                          xt) \\<longrightarrow>\n            (case x of\n             (pc', \\<tau>') \\<Rightarrow>\n               P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc'));\n        P,h \\<turnstile> z :\\<le> T1; P,h \\<turnstile> za :\\<le> T2;\n        P,h \\<turnstile> zsa [:\\<le>] ST\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            (\\<exists>a b.\n                                \\<Phi> C M ! Suc pc =\n                                \\<lfloor>(a, b)\\<rfloor> \\<and>\n                                P,h \\<turnstile> za #\n           z # zsa [:\\<le>] a \\<and>\n                                P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] b \\<and>\n                                Suc pc < length is \\<and>\n                                conf_fs P h \\<Phi> M (length Ts) T frs)", "apply (drule (1) sees_method_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta T1 T2 ST LT z za zsa.\n       \\<lbrakk>wf_prog wt P; ins ! pc = Swap; P,h \\<turnstile> t \\<surd>t;\n        tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' = (None, h, (za # z # zsa, loc, C, M, Suc pc) # frs);\n        hconf h; preallocated h;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = \\<lfloor>(mxsa,\n                          mxl\\<^sub>0', is, xta)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(T1 # T2 # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P Swap pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow>\n                d \\<le> Suc (Suc (length ST)) \\<and> d < mxs);\n        Suc pc < length ins; stk = z # za # zsa;\n        \\<forall>x\\<in>set (xcpt_eff Swap P pc (T1 # T2 # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x.\n           (x =\n            (Suc pc, \\<lfloor>(T2 # T1 # ST, LT)\\<rfloor>) \\<longrightarrow>\n            (\\<exists>a b.\n                \\<Phi> C M ! Suc pc = \\<lfloor>(a, b)\\<rfloor> \\<and>\n                (\\<exists>z zs.\n                    a = z # zs \\<and>\n                    P \\<turnstile> T2 \\<le> z \\<and>\n                    (\\<exists>z zsa.\n                        zs = z # zsa \\<and>\n                        P \\<turnstile> T1 \\<le> z \\<and>\n                        P \\<turnstile> ST [\\<le>] zsa)) \\<and>\n                P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] b)) \\<and>\n           (x \\<in> set (xcpt_eff Swap P pc (T1 # T2 # ST, LT)\n                          xt) \\<longrightarrow>\n            (case x of\n             (pc', \\<tau>') \\<Rightarrow>\n               P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc'));\n        P,h \\<turnstile> z :\\<le> T1; P,h \\<turnstile> za :\\<le> T2;\n        P,h \\<turnstile> zsa [:\\<le>] ST;\n        Tsa = Ts \\<and>\n        Ta = T \\<and>\n        \\<lfloor>(mxsa, mxl\\<^sub>0', is, xta)\\<rfloor> =\n        \\<lfloor>(mxs, mxl\\<^sub>0, ins, xt)\\<rfloor> \\<and>\n        C = C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            (\\<exists>a b.\n                                \\<Phi> C M ! Suc pc =\n                                \\<lfloor>(a, b)\\<rfloor> \\<and>\n                                P,h \\<turnstile> za #\n           z # zsa [:\\<le>] a \\<and>\n                                P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] b \\<and>\n                                Suc pc < length is \\<and>\n                                conf_fs P h \\<Phi> M (length Ts) T frs)", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare [[simproc del: list_to_set_comprehension]]"], ["", "lemma Throw_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C; \n  ins ! pc = ThrowExc; \n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  \\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>;\n  (tas, \\<sigma>') \\<in> exec_instr (ins!pc) P t h stk loc C M pc frs \\<rbrakk> \n\\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                     ins, xt)\\<rfloor> in C;\n     ins ! pc = ThrowExc;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n     (tas, \\<sigma>')\n     \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "using wf_preallocatedD[of wt P h NullPointer]"], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_prog wt P; preallocated h;\n   NullPointer \\<in> sys_xcpts\\<rbrakk>\n  \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt NullPointer) =\n                    \\<lfloor>Class_type NullPointer\\<rfloor> \\<and>\n                    P \\<turnstile> NullPointer \\<preceq>\\<^sup>* Throwable\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                     ins, xt)\\<rfloor> in C;\n     ins ! pc = ThrowExc;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n     (tas, \\<sigma>')\n     \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta Taa ST LT z zs.\n       \\<lbrakk>P \\<turnstile> NullPointer \\<preceq>\\<^sup>* Throwable;\n        wf_prog wt P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        ins ! pc = ThrowExc; P,h \\<turnstile> t \\<surd>t;\n        tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' =\n        (if z = Null then \\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>\n         else \\<lfloor>the_Addr (hd (z # zs))\\<rfloor>,\n         h, (z # zs, loc, C, M, pc) # frs);\n        hconf h; preallocated h;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = \\<lfloor>(mxsa,\n                          mxl\\<^sub>0', is, xta)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(Taa # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P ThrowExc pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        Taa = NT \\<or>\n        (\\<exists>C.\n            Taa = Class C \\<and>\n            P \\<turnstile> C \\<preceq>\\<^sup>* Throwable);\n        \\<forall>x\\<in>set (xcpt_eff ThrowExc P pc (Taa # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff ThrowExc P pc (Taa # ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        stk = z # zs; P,h \\<turnstile> z :\\<le> Taa;\n        P,h \\<turnstile> zs [:\\<le>] ST\\<rbrakk>\n       \\<Longrightarrow> (z = Null \\<longrightarrow>\n                          (\\<exists>Ts T mxs mxl\\<^sub>0 is.\n                              (\\<exists>xt.\n                                  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n            mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                              P \\<turnstile> NT \\<le> Taa \\<and>\n                              pc < length is \\<and>\n                              conf_fs P h \\<Phi> M (length Ts) T frs \\<and>\n                              (\\<forall>D'.\n                                  P \\<turnstile> NullPointer \\<preceq>\\<^sup>* D' \\<longrightarrow>\n                                  is_relevant_class (is ! pc) P D'))) \\<and>\n                         (z \\<noteq> Null \\<longrightarrow>\n                          (\\<exists>Ts T mxs mxl\\<^sub>0 is.\n                              (\\<exists>xt.\n                                  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n            mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                              pc < length is \\<and>\n                              conf_fs P h \\<Phi> M (length Ts) T frs \\<and>\n                              (\\<exists>D.\n                                  typeof_addr h (the_Addr z) =\n                                  \\<lfloor>Class_type D\\<rfloor> \\<and>\n                                  P \\<turnstile> D \\<preceq>\\<^sup>* Throwable \\<and>\n                                  (\\<forall>D'.\nP \\<turnstile> D \\<preceq>\\<^sup>* D' \\<longrightarrow>\nis_relevant_class (is ! pc) P D'))))", "apply(drule (1) sees_method_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta Taa ST LT z zs.\n       \\<lbrakk>P \\<turnstile> NullPointer \\<preceq>\\<^sup>* Throwable;\n        wf_prog wt P; ins ! pc = ThrowExc; P,h \\<turnstile> t \\<surd>t;\n        tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' =\n        (if z = Null then \\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>\n         else \\<lfloor>the_Addr (hd (z # zs))\\<rfloor>,\n         h, (z # zs, loc, C, M, pc) # frs);\n        hconf h; preallocated h;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = \\<lfloor>(mxsa,\n                          mxl\\<^sub>0', is, xta)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(Taa # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P ThrowExc pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        Taa = NT \\<or>\n        (\\<exists>C.\n            Taa = Class C \\<and>\n            P \\<turnstile> C \\<preceq>\\<^sup>* Throwable);\n        \\<forall>x\\<in>set (xcpt_eff ThrowExc P pc (Taa # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff ThrowExc P pc (Taa # ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        stk = z # zs; P,h \\<turnstile> z :\\<le> Taa;\n        P,h \\<turnstile> zs [:\\<le>] ST;\n        Tsa = Ts \\<and>\n        Ta = T \\<and>\n        \\<lfloor>(mxsa, mxl\\<^sub>0', is, xta)\\<rfloor> =\n        \\<lfloor>(mxs, mxl\\<^sub>0, ins, xt)\\<rfloor> \\<and>\n        C = C\\<rbrakk>\n       \\<Longrightarrow> (z = Null \\<longrightarrow>\n                          (\\<exists>Ts T mxs mxl\\<^sub>0 is.\n                              (\\<exists>xt.\n                                  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n            mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                              P \\<turnstile> NT \\<le> Taa \\<and>\n                              pc < length is \\<and>\n                              conf_fs P h \\<Phi> M (length Ts) T frs \\<and>\n                              (\\<forall>D'.\n                                  P \\<turnstile> NullPointer \\<preceq>\\<^sup>* D' \\<longrightarrow>\n                                  is_relevant_class (is ! pc) P D'))) \\<and>\n                         (z \\<noteq> Null \\<longrightarrow>\n                          (\\<exists>Ts T mxs mxl\\<^sub>0 is.\n                              (\\<exists>xt.\n                                  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n            mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                              pc < length is \\<and>\n                              conf_fs P h \\<Phi> M (length Ts) T frs \\<and>\n                              (\\<exists>D.\n                                  typeof_addr h (the_Addr z) =\n                                  \\<lfloor>Class_type D\\<rfloor> \\<and>\n                                  P \\<turnstile> D \\<preceq>\\<^sup>* Throwable \\<and>\n                                  (\\<forall>D'.\nP \\<turnstile> D \\<preceq>\\<^sup>* D' \\<longrightarrow>\nis_relevant_class (is ! pc) P D'))))", "apply(auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ST LT zs.\n       \\<lbrakk>P \\<turnstile> NullPointer \\<preceq>\\<^sup>* Throwable;\n        wf_prog wt P; ins ! pc = ThrowExc; P,h \\<turnstile> t \\<surd>t;\n        tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' =\n        (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n         (Null # zs, loc, C, M, pc) # frs);\n        hconf h; preallocated h;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(NT # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length ins;\n        conf_fs P h \\<Phi> M (length Ts) T frs;\n        \\<forall>x\\<in>set (relevant_entries P ThrowExc pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        \\<forall>x\\<in>set (xcpt_eff ThrowExc P pc (NT # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff ThrowExc P pc (NT # ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        stk = Null # zs; P,h \\<turnstile> zs [:\\<le>] ST\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs \\<and>\n                            (\\<forall>D'.\n                                P \\<turnstile> NullPointer \\<preceq>\\<^sup>* D' \\<longrightarrow>\n                                is_relevant_class (is ! pc) P D')\n 2. \\<And>ST LT zs Ca.\n       \\<lbrakk>P \\<turnstile> NullPointer \\<preceq>\\<^sup>* Throwable;\n        wf_prog wt P; ins ! pc = ThrowExc; P,h \\<turnstile> t \\<surd>t;\n        tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' =\n        (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n         (Null # zs, loc, C, M, pc) # frs);\n        hconf h; preallocated h;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(Class Ca # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length ins;\n        conf_fs P h \\<Phi> M (length Ts) T frs;\n        \\<forall>x\\<in>set (relevant_entries P ThrowExc pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        \\<forall>x\\<in>set (xcpt_eff ThrowExc P pc (Class Ca # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff ThrowExc P pc (Class Ca # ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        stk = Null # zs; P,h \\<turnstile> zs [:\\<le>] ST;\n        P \\<turnstile> Ca \\<preceq>\\<^sup>* Throwable\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs \\<and>\n                            (\\<forall>D'.\n                                P \\<turnstile> NullPointer \\<preceq>\\<^sup>* D' \\<longrightarrow>\n                                is_relevant_class (is ! pc) P D')\n 3. \\<And>ST LT z zs Ca.\n       \\<lbrakk>P \\<turnstile> NullPointer \\<preceq>\\<^sup>* Throwable;\n        wf_prog wt P; ins ! pc = ThrowExc; P,h \\<turnstile> t \\<surd>t;\n        tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' =\n        (\\<lfloor>the_Addr z\\<rfloor>, h, (z # zs, loc, C, M, pc) # frs);\n        hconf h; preallocated h;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(Class Ca # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length ins;\n        conf_fs P h \\<Phi> M (length Ts) T frs;\n        \\<forall>x\\<in>set (relevant_entries P ThrowExc pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        \\<forall>x\\<in>set (xcpt_eff ThrowExc P pc (Class Ca # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff ThrowExc P pc (Class Ca # ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        stk = z # zs; P,h \\<turnstile> z :\\<le> Class Ca;\n        P,h \\<turnstile> zs [:\\<le>] ST;\n        P \\<turnstile> Ca \\<preceq>\\<^sup>* Throwable;\n        z \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs \\<and>\n                            (\\<exists>D.\n                                typeof_addr h (the_Addr z) =\n                                \\<lfloor>Class_type D\\<rfloor> \\<and>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* Throwable \\<and>\n                                (\\<forall>D'.\n                                    P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<longrightarrow>\n                                    is_relevant_class (is ! pc) P D'))", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ST LT zs Ca.\n       \\<lbrakk>P \\<turnstile> NullPointer \\<preceq>\\<^sup>* Throwable;\n        wf_prog wt P; ins ! pc = ThrowExc; P,h \\<turnstile> t \\<surd>t;\n        tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' =\n        (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n         (Null # zs, loc, C, M, pc) # frs);\n        hconf h; preallocated h;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(Class Ca # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length ins;\n        conf_fs P h \\<Phi> M (length Ts) T frs;\n        \\<forall>x\\<in>set (relevant_entries P ThrowExc pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        \\<forall>x\\<in>set (xcpt_eff ThrowExc P pc (Class Ca # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff ThrowExc P pc (Class Ca # ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        stk = Null # zs; P,h \\<turnstile> zs [:\\<le>] ST;\n        P \\<turnstile> Ca \\<preceq>\\<^sup>* Throwable\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs \\<and>\n                            (\\<forall>D'.\n                                P \\<turnstile> NullPointer \\<preceq>\\<^sup>* D' \\<longrightarrow>\n                                is_relevant_class (is ! pc) P D')\n 2. \\<And>ST LT z zs Ca.\n       \\<lbrakk>P \\<turnstile> NullPointer \\<preceq>\\<^sup>* Throwable;\n        wf_prog wt P; ins ! pc = ThrowExc; P,h \\<turnstile> t \\<surd>t;\n        tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' =\n        (\\<lfloor>the_Addr z\\<rfloor>, h, (z # zs, loc, C, M, pc) # frs);\n        hconf h; preallocated h;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(Class Ca # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length ins;\n        conf_fs P h \\<Phi> M (length Ts) T frs;\n        \\<forall>x\\<in>set (relevant_entries P ThrowExc pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        \\<forall>x\\<in>set (xcpt_eff ThrowExc P pc (Class Ca # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff ThrowExc P pc (Class Ca # ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        stk = z # zs; P,h \\<turnstile> z :\\<le> Class Ca;\n        P,h \\<turnstile> zs [:\\<le>] ST;\n        P \\<turnstile> Ca \\<preceq>\\<^sup>* Throwable;\n        z \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs \\<and>\n                            (\\<exists>D.\n                                typeof_addr h (the_Addr z) =\n                                \\<lfloor>Class_type D\\<rfloor> \\<and>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* Throwable \\<and>\n                                (\\<forall>D'.\n                                    P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<longrightarrow>\n                                    is_relevant_class (is ! pc) P D'))", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ST LT z zs Ca.\n       \\<lbrakk>P \\<turnstile> NullPointer \\<preceq>\\<^sup>* Throwable;\n        wf_prog wt P; ins ! pc = ThrowExc; P,h \\<turnstile> t \\<surd>t;\n        tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' =\n        (\\<lfloor>the_Addr z\\<rfloor>, h, (z # zs, loc, C, M, pc) # frs);\n        hconf h; preallocated h;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(Class Ca # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length ins;\n        conf_fs P h \\<Phi> M (length Ts) T frs;\n        \\<forall>x\\<in>set (relevant_entries P ThrowExc pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        \\<forall>x\\<in>set (xcpt_eff ThrowExc P pc (Class Ca # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff ThrowExc P pc (Class Ca # ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        stk = z # zs; P,h \\<turnstile> z :\\<le> Class Ca;\n        P,h \\<turnstile> zs [:\\<le>] ST;\n        P \\<turnstile> Ca \\<preceq>\\<^sup>* Throwable;\n        z \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs \\<and>\n                            (\\<exists>D.\n                                typeof_addr h (the_Addr z) =\n                                \\<lfloor>Class_type D\\<rfloor> \\<and>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* Throwable \\<and>\n                                (\\<forall>D'.\n                                    P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<longrightarrow>\n                                    is_relevant_class (is ! pc) P D'))", "apply(drule (1) non_npD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ST LT z zs Ca.\n       \\<lbrakk>P \\<turnstile> NullPointer \\<preceq>\\<^sup>* Throwable;\n        wf_prog wt P; ins ! pc = ThrowExc; P,h \\<turnstile> t \\<surd>t;\n        tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' =\n        (\\<lfloor>the_Addr z\\<rfloor>, h, (z # zs, loc, C, M, pc) # frs);\n        hconf h; preallocated h;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(Class Ca # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length ins;\n        conf_fs P h \\<Phi> M (length Ts) T frs;\n        \\<forall>x\\<in>set (relevant_entries P ThrowExc pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        \\<forall>x\\<in>set (xcpt_eff ThrowExc P pc (Class Ca # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff ThrowExc P pc (Class Ca # ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        stk = z # zs; P,h \\<turnstile> z :\\<le> Class Ca;\n        P,h \\<turnstile> zs [:\\<le>] ST;\n        P \\<turnstile> Ca \\<preceq>\\<^sup>* Throwable\\<rbrakk>\n       \\<Longrightarrow> Ca \\<noteq> Object\n 2. \\<And>ST LT z zs Ca.\n       \\<lbrakk>P \\<turnstile> NullPointer \\<preceq>\\<^sup>* Throwable;\n        wf_prog wt P; ins ! pc = ThrowExc; P,h \\<turnstile> t \\<surd>t;\n        tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' =\n        (\\<lfloor>the_Addr z\\<rfloor>, h, (z # zs, loc, C, M, pc) # frs);\n        hconf h; preallocated h;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(Class Ca # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length ins;\n        conf_fs P h \\<Phi> M (length Ts) T frs;\n        \\<forall>x\\<in>set (relevant_entries P ThrowExc pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             (case C of None \\<Rightarrow> True\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow> is_class P x) \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        \\<forall>x\\<in>set (xcpt_eff ThrowExc P pc (Class Ca # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff ThrowExc P pc (Class Ca # ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        stk = z # zs; P,h \\<turnstile> z :\\<le> Class Ca;\n        P,h \\<turnstile> zs [:\\<le>] ST;\n        P \\<turnstile> Ca \\<preceq>\\<^sup>* Throwable;\n        \\<exists>a C'.\n           z = Addr a \\<and>\n           typeof_addr h a = \\<lfloor>Class_type C'\\<rfloor> \\<and>\n           P \\<turnstile> C' \\<preceq>\\<^sup>* Ca\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in C) \\<and>\n                            pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs \\<and>\n                            (\\<exists>D.\n                                typeof_addr h (the_Addr z) =\n                                \\<lfloor>Class_type D\\<rfloor> \\<and>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* Throwable \\<and>\n                                (\\<forall>D'.\n                                    P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<longrightarrow>\n                                    is_relevant_class (is ! pc) P D'))", "apply fastforce+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare [[simproc add: list_to_set_comprehension]]"], ["", "lemma NewArray_correct:\n  assumes wf:   \"wf_prog wt P\"\n  assumes meth: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C\"\n  assumes ins:  \"ins!pc = NewArray X\"\n  assumes wt:   \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes conf: \"\\<Phi> \\<turnstile> t:(None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  assumes no_x: \"(tas, \\<sigma>) \\<in> exec_instr (ins!pc) P t h stk loc C M pc frs\"\n  shows \"\\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from ins conf meth"], ["proof (chain)\npicking this:\n  ins ! pc = NewArray X\n  \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C", "obtain ST LT where\n    heap_ok: \"hconf h\" and\n    tconf: \"P,h \\<turnstile> t \\<surd>t\" and\n    \\<Phi>_pc:    \"\\<Phi> C M!pc = Some (ST,LT)\" and\n    stk: \"P,h \\<turnstile> stk [:\\<le>] ST\" and loc: \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\" and\n    pc: \"pc < size ins\" and \n    frame:   \"conf_f P h (ST,LT) ins (stk,loc,C,M,pc)\" and\n    frames:  \"conf_fs P h \\<Phi> M (size Ts) T frs\" and\n    preh:    \"preallocated h\""], ["proof (prove)\nusing this:\n  ins ! pc = NewArray X\n  \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>hconf h; P,h \\<turnstile> t \\<surd>t;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         P,h \\<turnstile> stk [:\\<le>] ST;\n         P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length ins;\n         conf_f P h (ST, LT) ins (stk, loc, C, M, pc);\n         conf_fs P h \\<Phi> M (length Ts) T frs; preallocated h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: sees_method_fun)"], ["proof (state)\nthis:\n  hconf h\n  P,h \\<turnstile> t \\<surd>t\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  preallocated h\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from ins \\<Phi>_pc wt"], ["proof (chain)\npicking this:\n  ins ! pc = NewArray X\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M", "obtain ST'' X' ST' LT' where \n    ST: \"ST = Integer # ST''\" and\n    pc': \"pc+1 < size ins\"  and\n    \\<Phi>': \"\\<Phi> C M ! (pc+1) = Some (X'#ST', LT')\" and\n    ST': \"P \\<turnstile> ST'' [\\<le>] ST'\" and LT': \"P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\" and\n    XX': \"P \\<turnstile> X\\<lfloor>\\<rceil> \\<le> X'\" and\n    suc_pc:     \"pc+1 < size ins\" and\n    is_type_X: \"is_type P (X\\<lfloor>\\<rceil>)\""], ["proof (prove)\nusing this:\n  ins ! pc = NewArray X\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n\ngoal (1 subgoal):\n 1. (\\<And>ST'' X' ST' LT'.\n        \\<lbrakk>ST = Integer # ST''; pc + 1 < length ins;\n         \\<Phi> C M ! (pc + 1) = \\<lfloor>(X' # ST', LT')\\<rfloor>;\n         P \\<turnstile> ST'' [\\<le>] ST';\n         P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT';\n         P \\<turnstile> X\\<lfloor>\\<rceil> \\<le> X'; pc + 1 < length ins;\n         is_type P (X\\<lfloor>\\<rceil>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest: Array_widen)"], ["proof (state)\nthis:\n  ST = Integer # ST''\n  pc + 1 < length ins\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(X' # ST', LT')\\<rfloor>\n  P \\<turnstile> ST'' [\\<le>] ST'\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n  P \\<turnstile> X\\<lfloor>\\<rceil> \\<le> X'\n  pc + 1 < length ins\n  is_type P (X\\<lfloor>\\<rceil>)\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from stk ST"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = Integer # ST''", "obtain si stk' where si: \"stk = Intg si # stk'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = Integer # ST''\n\ngoal (1 subgoal):\n 1. (\\<And>si stk'.\n        stk = Intg si # stk' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: conf_def)"], ["proof (state)\nthis:\n  stk = Intg si # stk'\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "proof(cases \"si <s 0 \\<or> allocate h (Array_type X (nat (sint si))) = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. si <s 0 \\<or>\n    allocate h (Array_type X (nat (sint si))) = {} \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> (si <s 0 \\<or>\n            allocate h (Array_type X (nat (sint si))) =\n            {}) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "case True"], ["proof (state)\nthis:\n  si <s 0 \\<or> allocate h (Array_type X (nat (sint si))) = {}\n\ngoal (2 subgoals):\n 1. si <s 0 \\<or>\n    allocate h (Array_type X (nat (sint si))) = {} \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> (si <s 0 \\<or>\n            allocate h (Array_type X (nat (sint si))) =\n            {}) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with frame frames tconf heap_ok suc_pc no_x ins meth \\<Phi>_pc si preh\n      wf_preallocatedD[OF wf, of h OutOfMemory] wf_preallocatedD[OF wf, of h NegativeArraySize]"], ["proof (chain)\npicking this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  P,h \\<turnstile> t \\<surd>t\n  hconf h\n  pc + 1 < length ins\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  ins ! pc = NewArray X\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  stk = Intg si # stk'\n  preallocated h\n  \\<lbrakk>preallocated h; OutOfMemory \\<in> sys_xcpts\\<rbrakk>\n  \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt OutOfMemory) =\n                    \\<lfloor>Class_type OutOfMemory\\<rfloor> \\<and>\n                    P \\<turnstile> OutOfMemory \\<preceq>\\<^sup>* Throwable\n  \\<lbrakk>preallocated h; NegativeArraySize \\<in> sys_xcpts\\<rbrakk>\n  \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt NegativeArraySize) =\n                    \\<lfloor>Class_type NegativeArraySize\\<rfloor> \\<and>\n                    P \\<turnstile> NegativeArraySize \\<preceq>\\<^sup>* Throwable\n  si <s 0 \\<or> allocate h (Array_type X (nat (sint si))) = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  P,h \\<turnstile> t \\<surd>t\n  hconf h\n  pc + 1 < length ins\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  ins ! pc = NewArray X\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  stk = Intg si # stk'\n  preallocated h\n  \\<lbrakk>preallocated h; OutOfMemory \\<in> sys_xcpts\\<rbrakk>\n  \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt OutOfMemory) =\n                    \\<lfloor>Class_type OutOfMemory\\<rfloor> \\<and>\n                    P \\<turnstile> OutOfMemory \\<preceq>\\<^sup>* Throwable\n  \\<lbrakk>preallocated h; NegativeArraySize \\<in> sys_xcpts\\<rbrakk>\n  \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt NegativeArraySize) =\n                    \\<lfloor>Class_type NegativeArraySize\\<rfloor> \\<and>\n                    P \\<turnstile> NegativeArraySize \\<preceq>\\<^sup>* Throwable\n  si <s 0 \\<or> allocate h (Array_type X (nat (sint si))) = {}\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "by(fastforce intro: tconf_hext_mono confs_hext confTs_hext conf_fs_hext split: if_split_asm)+"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal (1 subgoal):\n 1. \\<not> (si <s 0 \\<or>\n            allocate h (Array_type X (nat (sint si))) =\n            {}) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (si <s 0 \\<or>\n            allocate h (Array_type X (nat (sint si))) =\n            {}) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "case False"], ["proof (state)\nthis:\n  \\<not> (si <s 0 \\<or> allocate h (Array_type X (nat (sint si))) = {})\n\ngoal (1 subgoal):\n 1. \\<not> (si <s 0 \\<or>\n            allocate h (Array_type X (nat (sint si))) =\n            {}) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with ins meth si no_x"], ["proof (chain)\npicking this:\n  ins ! pc = NewArray X\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  stk = Intg si # stk'\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  \\<not> (si <s 0 \\<or> allocate h (Array_type X (nat (sint si))) = {})", "obtain h' oref \n      where new: \"(h', oref) \\<in> allocate h (Array_type X (nat (sint si)))\"\n      and \\<sigma>': \"\\<sigma> = (None, h', (Addr oref#tl stk,loc,C,M,pc+1)#frs)\" (is \"\\<sigma> = (None, h', ?f # frs)\")"], ["proof (prove)\nusing this:\n  ins ! pc = NewArray X\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  stk = Intg si # stk'\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  \\<not> (si <s 0 \\<or> allocate h (Array_type X (nat (sint si))) = {})\n\ngoal (1 subgoal):\n 1. (\\<And>h' oref.\n        \\<lbrakk>(h', oref) \\<in> allocate h (Array_type X (nat (sint si)));\n         \\<sigma> =\n         (None, h', (Addr oref # tl stk, loc, C, M, pc + 1) # frs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto split: if_split_asm)"], ["proof (state)\nthis:\n  (h', oref) \\<in> allocate h (Array_type X (nat (sint si)))\n  \\<sigma> = (None, h', (Addr oref # tl stk, loc, C, M, pc + 1) # frs)\n\ngoal (1 subgoal):\n 1. \\<not> (si <s 0 \\<or>\n            allocate h (Array_type X (nat (sint si))) =\n            {}) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from new"], ["proof (chain)\npicking this:\n  (h', oref) \\<in> allocate h (Array_type X (nat (sint si)))", "have hext: \"h \\<unlhd> h'\""], ["proof (prove)\nusing this:\n  (h', oref) \\<in> allocate h (Array_type X (nat (sint si)))\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "by(rule hext_allocate)"], ["proof (state)\nthis:\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. \\<not> (si <s 0 \\<or>\n            allocate h (Array_type X (nat (sint si))) =\n            {}) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with preh"], ["proof (chain)\npicking this:\n  preallocated h\n  h \\<unlhd> h'", "have preh': \"preallocated h'\""], ["proof (prove)\nusing this:\n  preallocated h\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. preallocated h'", "by(rule preallocated_hext)"], ["proof (state)\nthis:\n  preallocated h'\n\ngoal (1 subgoal):\n 1. \\<not> (si <s 0 \\<or>\n            allocate h (Array_type X (nat (sint si))) =\n            {}) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from new heap_ok is_type_X"], ["proof (chain)\npicking this:\n  (h', oref) \\<in> allocate h (Array_type X (nat (sint si)))\n  hconf h\n  is_type P (X\\<lfloor>\\<rceil>)", "have heap_ok': \"hconf h'\""], ["proof (prove)\nusing this:\n  (h', oref) \\<in> allocate h (Array_type X (nat (sint si)))\n  hconf h\n  is_type P (X\\<lfloor>\\<rceil>)\n\ngoal (1 subgoal):\n 1. hconf h'", "by(auto intro: hconf_allocate_mono)"], ["proof (state)\nthis:\n  hconf h'\n\ngoal (1 subgoal):\n 1. \\<not> (si <s 0 \\<or>\n            allocate h (Array_type X (nat (sint si))) =\n            {}) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from False"], ["proof (chain)\npicking this:\n  \\<not> (si <s 0 \\<or> allocate h (Array_type X (nat (sint si))) = {})", "have si': \"0 <=s si\""], ["proof (prove)\nusing this:\n  \\<not> (si <s 0 \\<or> allocate h (Array_type X (nat (sint si))) = {})\n\ngoal (1 subgoal):\n 1. 0 \\<le>s si", "by auto"], ["proof (state)\nthis:\n  0 \\<le>s si\n\ngoal (1 subgoal):\n 1. \\<not> (si <s 0 \\<or>\n            allocate h (Array_type X (nat (sint si))) =\n            {}) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with new is_type_X"], ["proof (chain)\npicking this:\n  (h', oref) \\<in> allocate h (Array_type X (nat (sint si)))\n  is_type P (X\\<lfloor>\\<rceil>)\n  0 \\<le>s si", "have h': \"typeof_addr h' oref = \\<lfloor>Array_type X (nat (sint si))\\<rfloor>\""], ["proof (prove)\nusing this:\n  (h', oref) \\<in> allocate h (Array_type X (nat (sint si)))\n  is_type P (X\\<lfloor>\\<rceil>)\n  0 \\<le>s si\n\ngoal (1 subgoal):\n 1. typeof_addr h' oref = \\<lfloor>Array_type X (nat (sint si))\\<rfloor>", "by(auto dest: allocate_SomeD)"], ["proof (state)\nthis:\n  typeof_addr h' oref = \\<lfloor>Array_type X (nat (sint si))\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<not> (si <s 0 \\<or>\n            allocate h (Array_type X (nat (sint si))) =\n            {}) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "note \\<sigma>' heap_ok'"], ["proof (state)\nthis:\n  \\<sigma> = (None, h', (Addr oref # tl stk, loc, C, M, pc + 1) # frs)\n  hconf h'\n\ngoal (1 subgoal):\n 1. \\<not> (si <s 0 \\<or>\n            allocate h (Array_type X (nat (sint si))) =\n            {}) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "moreover"], ["proof (state)\nthis:\n  \\<sigma> = (None, h', (Addr oref # tl stk, loc, C, M, pc + 1) # frs)\n  hconf h'\n\ngoal (1 subgoal):\n 1. \\<not> (si <s 0 \\<or>\n            allocate h (Array_type X (nat (sint si))) =\n            {}) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from frame ST' ST LT' suc_pc wf XX' h' hext"], ["proof (chain)\npicking this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  P \\<turnstile> ST'' [\\<le>] ST'\n  ST = Integer # ST''\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n  pc + 1 < length ins\n  wf_prog wt P\n  P \\<turnstile> X\\<lfloor>\\<rceil> \\<le> X'\n  typeof_addr h' oref = \\<lfloor>Array_type X (nat (sint si))\\<rfloor>\n  h \\<unlhd> h'", "have \"conf_f P h' (X' # ST', LT') ins ?f\""], ["proof (prove)\nusing this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  P \\<turnstile> ST'' [\\<le>] ST'\n  ST = Integer # ST''\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n  pc + 1 < length ins\n  wf_prog wt P\n  P \\<turnstile> X\\<lfloor>\\<rceil> \\<le> X'\n  typeof_addr h' oref = \\<lfloor>Array_type X (nat (sint si))\\<rfloor>\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. conf_f P h' (X' # ST', LT') ins (Addr oref # tl stk, loc, C, M, pc + 1)", "by(clarsimp simp add: fun_upd_apply conf_def split_beta)(auto intro: confs_hext confTs_hext)"], ["proof (state)\nthis:\n  conf_f P h' (X' # ST', LT') ins (Addr oref # tl stk, loc, C, M, pc + 1)\n\ngoal (1 subgoal):\n 1. \\<not> (si <s 0 \\<or>\n            allocate h (Array_type X (nat (sint si))) =\n            {}) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "moreover"], ["proof (state)\nthis:\n  conf_f P h' (X' # ST', LT') ins (Addr oref # tl stk, loc, C, M, pc + 1)\n\ngoal (1 subgoal):\n 1. \\<not> (si <s 0 \\<or>\n            allocate h (Array_type X (nat (sint si))) =\n            {}) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from frames hext"], ["proof (chain)\npicking this:\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  h \\<unlhd> h'", "have \"conf_fs P h' \\<Phi> M (size Ts) T frs\""], ["proof (prove)\nusing this:\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. conf_fs P h' \\<Phi> M (length Ts) T frs", "by (rule conf_fs_hext)"], ["proof (state)\nthis:\n  conf_fs P h' \\<Phi> M (length Ts) T frs\n\ngoal (1 subgoal):\n 1. \\<not> (si <s 0 \\<or>\n            allocate h (Array_type X (nat (sint si))) =\n            {}) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "moreover"], ["proof (state)\nthis:\n  conf_fs P h' \\<Phi> M (length Ts) T frs\n\ngoal (1 subgoal):\n 1. \\<not> (si <s 0 \\<or>\n            allocate h (Array_type X (nat (sint si))) =\n            {}) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from tconf hext"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> t \\<surd>t\n  h \\<unlhd> h'", "have \"P,h' \\<turnstile> t \\<surd>t\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> t \\<surd>t\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. P,h' \\<turnstile> t \\<surd>t", "by(rule tconf_hext_mono)"], ["proof (state)\nthis:\n  P,h' \\<turnstile> t \\<surd>t\n\ngoal (1 subgoal):\n 1. \\<not> (si <s 0 \\<or>\n            allocate h (Array_type X (nat (sint si))) =\n            {}) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "ultimately"], ["proof (chain)\npicking this:\n  \\<sigma> = (None, h', (Addr oref # tl stk, loc, C, M, pc + 1) # frs)\n  hconf h'\n  conf_f P h' (X' # ST', LT') ins (Addr oref # tl stk, loc, C, M, pc + 1)\n  conf_fs P h' \\<Phi> M (length Ts) T frs\n  P,h' \\<turnstile> t \\<surd>t", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<sigma> = (None, h', (Addr oref # tl stk, loc, C, M, pc + 1) # frs)\n  hconf h'\n  conf_f P h' (X' # ST', LT') ins (Addr oref # tl stk, loc, C, M, pc + 1)\n  conf_fs P h' \\<Phi> M (length Ts) T frs\n  P,h' \\<turnstile> t \\<surd>t\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "using meth \\<Phi>' preh'"], ["proof (prove)\nusing this:\n  \\<sigma> = (None, h', (Addr oref # tl stk, loc, C, M, pc + 1) # frs)\n  hconf h'\n  conf_f P h' (X' # ST', LT') ins (Addr oref # tl stk, loc, C, M, pc + 1)\n  conf_fs P h' \\<Phi> M (length Ts) T frs\n  P,h' \\<turnstile> t \\<surd>t\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(X' # ST', LT')\\<rfloor>\n  preallocated h'\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "by fastforce"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ALoad_correct:\n  assumes wf:   \"wf_prog wt P\"\n  assumes meth: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C\"\n  assumes ins:  \"ins!pc = ALoad\"\n  assumes wt:   \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes conf: \"\\<Phi> \\<turnstile> t: (None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  assumes no_x: \"(tas, \\<sigma>) \\<in> exec_instr (ins!pc) P t h stk loc C M pc frs\"\n  shows \"\\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from ins conf meth"], ["proof (chain)\npicking this:\n  ins ! pc = ALoad\n  \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C", "obtain ST LT where\n    heap_ok: \"hconf h\" and\n    tconf:   \"P,h \\<turnstile> t \\<surd>t\" and\n    \\<Phi>_pc:    \"\\<Phi> C M!pc = Some (ST,LT)\" and\n    stk: \"P,h \\<turnstile> stk [:\\<le>] ST\" and loc: \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\" and\n    pc: \"pc < size ins\" and \n    frame:   \"conf_f P h (ST,LT) ins (stk,loc,C,M,pc)\" and\n    frames:  \"conf_fs P h \\<Phi> M (size Ts) T frs\" and\n    preh:    \"preallocated h\""], ["proof (prove)\nusing this:\n  ins ! pc = ALoad\n  \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>hconf h; P,h \\<turnstile> t \\<surd>t;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         P,h \\<turnstile> stk [:\\<le>] ST;\n         P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length ins;\n         conf_f P h (ST, LT) ins (stk, loc, C, M, pc);\n         conf_fs P h \\<Phi> M (length Ts) T frs; preallocated h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: sees_method_fun)"], ["proof (state)\nthis:\n  hconf h\n  P,h \\<turnstile> t \\<surd>t\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  preallocated h\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from ins wt \\<Phi>_pc"], ["proof (chain)\npicking this:\n  ins ! pc = ALoad\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>", "have lST: \"length ST > 1\""], ["proof (prove)\nusing this:\n  ins ! pc = ALoad\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n\ngoal (1 subgoal):\n 1. 1 < length ST", "by(auto)"], ["proof (state)\nthis:\n  1 < length ST\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "proof(cases \"hd (tl stk) = Null\")"], ["proof (state)\ngoal (2 subgoals):\n 1. hd (tl stk) = Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. hd (tl stk) \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "case True"], ["proof (state)\nthis:\n  hd (tl stk) = Null\n\ngoal (2 subgoals):\n 1. hd (tl stk) = Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. hd (tl stk) \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with ins no_x heap_ok tconf \\<Phi>_pc stk loc frame frames meth wf_preallocatedD[OF wf, of h NullPointer] preh"], ["proof (chain)\npicking this:\n  ins ! pc = ALoad\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  hconf h\n  P,h \\<turnstile> t \\<surd>t\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<lbrakk>preallocated h; NullPointer \\<in> sys_xcpts\\<rbrakk>\n  \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt NullPointer) =\n                    \\<lfloor>Class_type NullPointer\\<rfloor> \\<and>\n                    P \\<turnstile> NullPointer \\<preceq>\\<^sup>* Throwable\n  preallocated h\n  hd (tl stk) = Null", "show ?thesis"], ["proof (prove)\nusing this:\n  ins ! pc = ALoad\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  hconf h\n  P,h \\<turnstile> t \\<surd>t\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<lbrakk>preallocated h; NullPointer \\<in> sys_xcpts\\<rbrakk>\n  \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt NullPointer) =\n                    \\<lfloor>Class_type NullPointer\\<rfloor> \\<and>\n                    P \\<turnstile> NullPointer \\<preceq>\\<^sup>* Throwable\n  preallocated h\n  hd (tl stk) = Null\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "by(fastforce)"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal (1 subgoal):\n 1. hd (tl stk) \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. hd (tl stk) \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "case False"], ["proof (state)\nthis:\n  hd (tl stk) \\<noteq> Null\n\ngoal (1 subgoal):\n 1. hd (tl stk) \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "note stkNN = this"], ["proof (state)\nthis:\n  hd (tl stk) \\<noteq> Null\n\ngoal (1 subgoal):\n 1. hd (tl stk) \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "have STNN: \"hd (tl ST) \\<noteq> NT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (tl ST) \\<noteq> NT", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. hd (tl ST) = NT \\<Longrightarrow> False", "assume \"hd (tl ST) = NT\""], ["proof (state)\nthis:\n  hd (tl ST) = NT\n\ngoal (1 subgoal):\n 1. hd (tl ST) = NT \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  hd (tl ST) = NT\n\ngoal (1 subgoal):\n 1. hd (tl ST) = NT \\<Longrightarrow> False", "from frame"], ["proof (chain)\npicking this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)", "have \"P,h \\<turnstile> stk [:\\<le>] ST\""], ["proof (prove)\nusing this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> stk [:\\<le>] ST", "by simp"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. hd (tl ST) = NT \\<Longrightarrow> False", "with lST"], ["proof (chain)\npicking this:\n  1 < length ST\n  P,h \\<turnstile> stk [:\\<le>] ST", "have \"P,h \\<turnstile> hd (tl stk) :\\<le> hd (tl ST)\""], ["proof (prove)\nusing this:\n  1 < length ST\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> hd (tl stk) :\\<le> hd (tl ST)", "by (cases ST, auto, case_tac list, auto)"], ["proof (state)\nthis:\n  P,h \\<turnstile> hd (tl stk) :\\<le> hd (tl ST)\n\ngoal (1 subgoal):\n 1. hd (tl ST) = NT \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  hd (tl ST) = NT\n  P,h \\<turnstile> hd (tl stk) :\\<le> hd (tl ST)", "have \"hd (tl stk) = Null\""], ["proof (prove)\nusing this:\n  hd (tl ST) = NT\n  P,h \\<turnstile> hd (tl stk) :\\<le> hd (tl ST)\n\ngoal (1 subgoal):\n 1. hd (tl stk) = Null", "by simp"], ["proof (state)\nthis:\n  hd (tl stk) = Null\n\ngoal (1 subgoal):\n 1. hd (tl ST) = NT \\<Longrightarrow> False", "with stkNN"], ["proof (chain)\npicking this:\n  hd (tl stk) \\<noteq> Null\n  hd (tl stk) = Null", "show False"], ["proof (prove)\nusing this:\n  hd (tl stk) \\<noteq> Null\n  hd (tl stk) = Null\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hd (tl ST) \\<noteq> NT\n\ngoal (1 subgoal):\n 1. hd (tl stk) \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with stkNN ins \\<Phi>_pc wt"], ["proof (chain)\npicking this:\n  hd (tl stk) \\<noteq> Null\n  ins ! pc = ALoad\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  hd (tl ST) \\<noteq> NT", "obtain ST'' X X' ST' LT' where \n      ST: \"ST = Integer # X\\<lfloor>\\<rceil> # ST''\" and\n      pc': \"pc+1 < size ins\"  and\n      \\<Phi>': \"\\<Phi> C M ! (pc+1) = Some (X'#ST', LT')\" and\n      ST': \"P \\<turnstile> ST'' [\\<le>] ST'\" and LT': \"P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\" and\n      XX': \"P \\<turnstile> X \\<le> X'\" and\n      suc_pc:     \"pc+1 < size ins\""], ["proof (prove)\nusing this:\n  hd (tl stk) \\<noteq> Null\n  ins ! pc = ALoad\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  hd (tl ST) \\<noteq> NT\n\ngoal (1 subgoal):\n 1. (\\<And>X ST'' X' ST' LT'.\n        \\<lbrakk>ST = Integer # X\\<lfloor>\\<rceil> # ST'';\n         pc + 1 < length ins;\n         \\<Phi> C M ! (pc + 1) = \\<lfloor>(X' # ST', LT')\\<rfloor>;\n         P \\<turnstile> ST'' [\\<le>] ST';\n         P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT';\n         P \\<turnstile> X \\<le> X'; pc + 1 < length ins\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce)"], ["proof (state)\nthis:\n  ST = Integer # X\\<lfloor>\\<rceil> # ST''\n  pc + 1 < length ins\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(X' # ST', LT')\\<rfloor>\n  P \\<turnstile> ST'' [\\<le>] ST'\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n  P \\<turnstile> X \\<le> X'\n  pc + 1 < length ins\n\ngoal (1 subgoal):\n 1. hd (tl stk) \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from stk ST"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = Integer # X\\<lfloor>\\<rceil> # ST''", "obtain ref idx stk' where \n      stk': \"stk = idx#ref#stk'\" and\n      idx: \"P,h \\<turnstile> idx :\\<le> Integer\" and\n      ref:  \"P,h \\<turnstile> ref :\\<le> X\\<lfloor>\\<rceil>\" and\n      ST'': \"P,h \\<turnstile> stk' [:\\<le>] ST''\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = Integer # X\\<lfloor>\\<rceil> # ST''\n\ngoal (1 subgoal):\n 1. (\\<And>idx ref stk'.\n        \\<lbrakk>stk = idx # ref # stk';\n         P,h \\<turnstile> idx :\\<le> Integer;\n         P,h \\<turnstile> ref :\\<le> X\\<lfloor>\\<rceil>;\n         P,h \\<turnstile> stk' [:\\<le>] ST''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  stk = idx # ref # stk'\n  P,h \\<turnstile> idx :\\<le> Integer\n  P,h \\<turnstile> ref :\\<le> X\\<lfloor>\\<rceil>\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n\ngoal (1 subgoal):\n 1. hd (tl stk) \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from stkNN stk'"], ["proof (chain)\npicking this:\n  hd (tl stk) \\<noteq> Null\n  stk = idx # ref # stk'", "have \"ref \\<noteq> Null\""], ["proof (prove)\nusing this:\n  hd (tl stk) \\<noteq> Null\n  stk = idx # ref # stk'\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null", "by(simp)"], ["proof (state)\nthis:\n  ref \\<noteq> Null\n\ngoal (1 subgoal):\n 1. hd (tl stk) \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with ref"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> ref :\\<le> X\\<lfloor>\\<rceil>\n  ref \\<noteq> Null", "obtain a Xel n\n      where a: \"ref = Addr a\"\n      and ha: \"typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\"\n      and Xel: \"P \\<turnstile> Xel \\<le> X\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> ref :\\<le> X\\<lfloor>\\<rceil>\n  ref \\<noteq> Null\n\ngoal (1 subgoal):\n 1. (\\<And>a Xel n.\n        \\<lbrakk>ref = Addr a;\n         typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>;\n         P \\<turnstile> Xel \\<le> X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases ref)(fastforce simp add: conf_def widen_Array)+"], ["proof (state)\nthis:\n  ref = Addr a\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  P \\<turnstile> Xel \\<le> X\n\ngoal (1 subgoal):\n 1. hd (tl stk) \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from idx"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> idx :\\<le> Integer", "obtain idxI where idxI: \"idx = Intg idxI\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> idx :\\<le> Integer\n\ngoal (1 subgoal):\n 1. (\\<And>idxI. idx = Intg idxI \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: conf_def)"], ["proof (state)\nthis:\n  idx = Intg idxI\n\ngoal (1 subgoal):\n 1. hd (tl stk) \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "proof(cases \"0 <=s idxI \\<and> sint idxI < int n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le>s idxI \\<and> sint idxI < int n \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "case True"], ["proof (state)\nthis:\n  0 \\<le>s idxI \\<and> sint idxI < int n\n\ngoal (2 subgoals):\n 1. 0 \\<le>s idxI \\<and> sint idxI < int n \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "hence si': \"0 <=s idxI\" \"sint idxI < int n\""], ["proof (prove)\nusing this:\n  0 \\<le>s idxI \\<and> sint idxI < int n\n\ngoal (1 subgoal):\n 1. 0 \\<le>s idxI &&& sint idxI < int n", "by auto"], ["proof (state)\nthis:\n  0 \\<le>s idxI\n  sint idxI < int n\n\ngoal (2 subgoals):\n 1. 0 \\<le>s idxI \\<and> sint idxI < int n \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "hence \"nat (sint idxI) < n\""], ["proof (prove)\nusing this:\n  0 \\<le>s idxI\n  sint idxI < int n\n\ngoal (1 subgoal):\n 1. nat (sint idxI) < n", "by (simp add: word_sle_eq nat_less_iff)"], ["proof (state)\nthis:\n  nat (sint idxI) < n\n\ngoal (2 subgoals):\n 1. 0 \\<le>s idxI \\<and> sint idxI < int n \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with ha"], ["proof (chain)\npicking this:\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  nat (sint idxI) < n", "have al: \"P,h \\<turnstile> a@ACell (nat (sint idxI)) : Xel\""], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  nat (sint idxI) < n\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> a@ACell (nat (sint idxI)) : Xel", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> a@ACell (nat (sint idxI)) : Xel\n\ngoal (2 subgoals):\n 1. 0 \\<le>s idxI \\<and> sint idxI < int n \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "{"], ["proof (state)\nthis:\n  P,h \\<turnstile> a@ACell (nat (sint idxI)) : Xel\n\ngoal (2 subgoals):\n 1. 0 \\<le>s idxI \\<and> sint idxI < int n \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "fix v"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le>s idxI \\<and> sint idxI < int n \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "assume read: \"heap_read h a (ACell (nat (sint idxI))) v\""], ["proof (state)\nthis:\n  heap_read h a (ACell (nat (sint idxI))) v\n\ngoal (2 subgoals):\n 1. 0 \\<le>s idxI \\<and> sint idxI < int n \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "hence v: \"P,h \\<turnstile> v :\\<le> Xel\""], ["proof (prove)\nusing this:\n  heap_read h a (ACell (nat (sint idxI))) v\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> v :\\<le> Xel", "using al heap_ok"], ["proof (prove)\nusing this:\n  heap_read h a (ACell (nat (sint idxI))) v\n  P,h \\<turnstile> a@ACell (nat (sint idxI)) : Xel\n  hconf h\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> v :\\<le> Xel", "by(rule heap_read_conf)"], ["proof (state)\nthis:\n  P,h \\<turnstile> v :\\<le> Xel\n\ngoal (2 subgoals):\n 1. 0 \\<le>s idxI \\<and> sint idxI < int n \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "let ?f = \"(v # stk', loc, C, M, pc + 1)\""], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le>s idxI \\<and> sint idxI < int n \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from frame ST' ST LT' suc_pc wf XX' Xel idxI si' v ST''"], ["proof (chain)\npicking this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  P \\<turnstile> ST'' [\\<le>] ST'\n  ST = Integer # X\\<lfloor>\\<rceil> # ST''\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n  pc + 1 < length ins\n  wf_prog wt P\n  P \\<turnstile> X \\<le> X'\n  P \\<turnstile> Xel \\<le> X\n  idx = Intg idxI\n  0 \\<le>s idxI\n  sint idxI < int n\n  P,h \\<turnstile> v :\\<le> Xel\n  P,h \\<turnstile> stk' [:\\<le>] ST''", "have \"conf_f P h (X' # ST', LT') ins ?f\""], ["proof (prove)\nusing this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  P \\<turnstile> ST'' [\\<le>] ST'\n  ST = Integer # X\\<lfloor>\\<rceil> # ST''\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n  pc + 1 < length ins\n  wf_prog wt P\n  P \\<turnstile> X \\<le> X'\n  P \\<turnstile> Xel \\<le> X\n  idx = Intg idxI\n  0 \\<le>s idxI\n  sint idxI < int n\n  P,h \\<turnstile> v :\\<le> Xel\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n\ngoal (1 subgoal):\n 1. conf_f P h (X' # ST', LT') ins (v # stk', loc, C, M, pc + 1)", "by(auto intro: widen_trans simp add: conf_def)"], ["proof (state)\nthis:\n  conf_f P h (X' # ST', LT') ins (v # stk', loc, C, M, pc + 1)\n\ngoal (2 subgoals):\n 1. 0 \\<le>s idxI \\<and> sint idxI < int n \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "hence \"\\<Phi> \\<turnstile> t:(None, h, ?f # frs) \\<surd>\""], ["proof (prove)\nusing this:\n  conf_f P h (X' # ST', LT') ins (v # stk', loc, C, M, pc + 1)\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:(None, h,\n                           (v # stk', loc, C, M, pc + 1) # frs) \\<surd>", "using meth \\<Phi>' heap_ok \\<Phi>_pc frames tconf preh"], ["proof (prove)\nusing this:\n  conf_f P h (X' # ST', LT') ins (v # stk', loc, C, M, pc + 1)\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(X' # ST', LT')\\<rfloor>\n  hconf h\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  P,h \\<turnstile> t \\<surd>t\n  preallocated h\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:(None, h,\n                           (v # stk', loc, C, M, pc + 1) # frs) \\<surd>", "by fastforce"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:(None, h,\n                         (v # stk', loc, C, M, pc + 1) # frs) \\<surd>\n\ngoal (2 subgoals):\n 1. 0 \\<le>s idxI \\<and> sint idxI < int n \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "}"], ["proof (state)\nthis:\n  heap_read h a (ACell (nat (sint idxI))) ?v17 \\<Longrightarrow>\n  \\<Phi> \\<turnstile> t:(None, h,\n                         (?v17 # stk', loc, C, M, pc + 1) # frs) \\<surd>\n\ngoal (2 subgoals):\n 1. 0 \\<le>s idxI \\<and> sint idxI < int n \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with ins meth si' stk' a ha no_x idxI idx"], ["proof (chain)\npicking this:\n  ins ! pc = ALoad\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  0 \\<le>s idxI\n  sint idxI < int n\n  stk = idx # ref # stk'\n  ref = Addr a\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  idx = Intg idxI\n  P,h \\<turnstile> idx :\\<le> Integer\n  heap_read h a (ACell (nat (sint idxI))) ?v17 \\<Longrightarrow>\n  \\<Phi> \\<turnstile> t:(None, h,\n                         (?v17 # stk', loc, C, M, pc + 1) # frs) \\<surd>", "show ?thesis"], ["proof (prove)\nusing this:\n  ins ! pc = ALoad\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  0 \\<le>s idxI\n  sint idxI < int n\n  stk = idx # ref # stk'\n  ref = Addr a\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  idx = Intg idxI\n  P,h \\<turnstile> idx :\\<le> Integer\n  heap_read h a (ACell (nat (sint idxI))) ?v17 \\<Longrightarrow>\n  \\<Phi> \\<turnstile> t:(None, h,\n                         (?v17 # stk', loc, C, M, pc + 1) # frs) \\<surd>\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "by(auto simp del: correct_state_def split: if_split_asm)"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal (1 subgoal):\n 1. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "case False"], ["proof (state)\nthis:\n  \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n)\n\ngoal (1 subgoal):\n 1. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with stk' idxI ins no_x heap_ok tconf meth a ha Xel \\<Phi>_pc frame frames\n        wf_preallocatedD[OF wf, of h ArrayIndexOutOfBounds] preh"], ["proof (chain)\npicking this:\n  stk = idx # ref # stk'\n  idx = Intg idxI\n  ins ! pc = ALoad\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  hconf h\n  P,h \\<turnstile> t \\<surd>t\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  ref = Addr a\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  P \\<turnstile> Xel \\<le> X\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  \\<lbrakk>preallocated h; ArrayIndexOutOfBounds \\<in> sys_xcpts\\<rbrakk>\n  \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt ArrayIndexOutOfBounds) =\n                    \\<lfloor>Class_type\n                              ArrayIndexOutOfBounds\\<rfloor> \\<and>\n                    P \\<turnstile> ArrayIndexOutOfBounds \\<preceq>\\<^sup>* Throwable\n  preallocated h\n  \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n)", "show ?thesis"], ["proof (prove)\nusing this:\n  stk = idx # ref # stk'\n  idx = Intg idxI\n  ins ! pc = ALoad\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  hconf h\n  P,h \\<turnstile> t \\<surd>t\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  ref = Addr a\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  P \\<turnstile> Xel \\<le> X\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  \\<lbrakk>preallocated h; ArrayIndexOutOfBounds \\<in> sys_xcpts\\<rbrakk>\n  \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt ArrayIndexOutOfBounds) =\n                    \\<lfloor>Class_type\n                              ArrayIndexOutOfBounds\\<rfloor> \\<and>\n                    P \\<turnstile> ArrayIndexOutOfBounds \\<preceq>\\<^sup>* Throwable\n  preallocated h\n  \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n)\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "by(fastforce split: if_split_asm)"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma AStore_correct:\n  assumes wf:   \"wf_prog wt P\"\n  assumes meth: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C\"\n  assumes ins:  \"ins!pc = AStore\"\n  assumes wt:   \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes conf: \"\\<Phi> \\<turnstile> t: (None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  assumes no_x: \"(tas, \\<sigma>) \\<in> exec_instr (ins!pc) P t h stk loc C M pc frs\"\n  shows \"\\<Phi> \\<turnstile> t: \\<sigma> \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from ins conf meth"], ["proof (chain)\npicking this:\n  ins ! pc = AStore\n  \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C", "obtain ST LT where\n    heap_ok: \"hconf h\" and\n    tconf: \"P,h \\<turnstile> t \\<surd>t\" and\n    \\<Phi>_pc:    \"\\<Phi> C M!pc = Some (ST,LT)\" and\n    stk: \"P,h \\<turnstile> stk [:\\<le>] ST\" and loc: \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\" and\n    pc: \"pc < size ins\" and \n    frame:   \"conf_f P h (ST,LT) ins (stk,loc,C,M,pc)\" and\n    frames:  \"conf_fs P h \\<Phi> M (size Ts) T frs\" and\n    preh:    \"preallocated h\""], ["proof (prove)\nusing this:\n  ins ! pc = AStore\n  \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>hconf h; P,h \\<turnstile> t \\<surd>t;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         P,h \\<turnstile> stk [:\\<le>] ST;\n         P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length ins;\n         conf_f P h (ST, LT) ins (stk, loc, C, M, pc);\n         conf_fs P h \\<Phi> M (length Ts) T frs; preallocated h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: sees_method_fun)"], ["proof (state)\nthis:\n  hconf h\n  P,h \\<turnstile> t \\<surd>t\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  preallocated h\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from ins wt \\<Phi>_pc"], ["proof (chain)\npicking this:\n  ins ! pc = AStore\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>", "have lST: \"length ST > 2\""], ["proof (prove)\nusing this:\n  ins ! pc = AStore\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n\ngoal (1 subgoal):\n 1. 2 < length ST", "by(auto)"], ["proof (state)\nthis:\n  2 < length ST\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "proof(cases \"hd (tl (tl stk)) = Null\")"], ["proof (state)\ngoal (2 subgoals):\n 1. hd (tl (tl stk)) = Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. hd (tl (tl stk)) \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "case True"], ["proof (state)\nthis:\n  hd (tl (tl stk)) = Null\n\ngoal (2 subgoals):\n 1. hd (tl (tl stk)) = Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. hd (tl (tl stk)) \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with ins no_x heap_ok tconf \\<Phi>_pc stk loc frame frames meth wf_preallocatedD[OF wf, of h NullPointer] preh"], ["proof (chain)\npicking this:\n  ins ! pc = AStore\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  hconf h\n  P,h \\<turnstile> t \\<surd>t\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<lbrakk>preallocated h; NullPointer \\<in> sys_xcpts\\<rbrakk>\n  \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt NullPointer) =\n                    \\<lfloor>Class_type NullPointer\\<rfloor> \\<and>\n                    P \\<turnstile> NullPointer \\<preceq>\\<^sup>* Throwable\n  preallocated h\n  hd (tl (tl stk)) = Null", "show ?thesis"], ["proof (prove)\nusing this:\n  ins ! pc = AStore\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  hconf h\n  P,h \\<turnstile> t \\<surd>t\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<lbrakk>preallocated h; NullPointer \\<in> sys_xcpts\\<rbrakk>\n  \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt NullPointer) =\n                    \\<lfloor>Class_type NullPointer\\<rfloor> \\<and>\n                    P \\<turnstile> NullPointer \\<preceq>\\<^sup>* Throwable\n  preallocated h\n  hd (tl (tl stk)) = Null\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "by(fastforce)"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal (1 subgoal):\n 1. hd (tl (tl stk)) \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. hd (tl (tl stk)) \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "case False"], ["proof (state)\nthis:\n  hd (tl (tl stk)) \\<noteq> Null\n\ngoal (1 subgoal):\n 1. hd (tl (tl stk)) \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "note stkNN = this"], ["proof (state)\nthis:\n  hd (tl (tl stk)) \\<noteq> Null\n\ngoal (1 subgoal):\n 1. hd (tl (tl stk)) \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "have STNN: \"hd (tl (tl ST)) \\<noteq> NT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (tl (tl ST)) \\<noteq> NT", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. hd (tl (tl ST)) = NT \\<Longrightarrow> False", "assume \"hd (tl (tl ST)) = NT\""], ["proof (state)\nthis:\n  hd (tl (tl ST)) = NT\n\ngoal (1 subgoal):\n 1. hd (tl (tl ST)) = NT \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  hd (tl (tl ST)) = NT\n\ngoal (1 subgoal):\n 1. hd (tl (tl ST)) = NT \\<Longrightarrow> False", "from frame"], ["proof (chain)\npicking this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)", "have \"P,h \\<turnstile> stk [:\\<le>] ST\""], ["proof (prove)\nusing this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> stk [:\\<le>] ST", "by simp"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. hd (tl (tl ST)) = NT \\<Longrightarrow> False", "with lST"], ["proof (chain)\npicking this:\n  2 < length ST\n  P,h \\<turnstile> stk [:\\<le>] ST", "have \"P,h \\<turnstile> hd (tl (tl stk)) :\\<le> hd (tl (tl ST))\""], ["proof (prove)\nusing this:\n  2 < length ST\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> hd (tl (tl stk)) :\\<le> hd (tl (tl ST))", "by (cases ST, auto, case_tac list, auto, case_tac lista, auto)"], ["proof (state)\nthis:\n  P,h \\<turnstile> hd (tl (tl stk)) :\\<le> hd (tl (tl ST))\n\ngoal (1 subgoal):\n 1. hd (tl (tl ST)) = NT \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  hd (tl (tl ST)) = NT\n  P,h \\<turnstile> hd (tl (tl stk)) :\\<le> hd (tl (tl ST))", "have \"hd (tl (tl stk)) = Null\""], ["proof (prove)\nusing this:\n  hd (tl (tl ST)) = NT\n  P,h \\<turnstile> hd (tl (tl stk)) :\\<le> hd (tl (tl ST))\n\ngoal (1 subgoal):\n 1. hd (tl (tl stk)) = Null", "by simp"], ["proof (state)\nthis:\n  hd (tl (tl stk)) = Null\n\ngoal (1 subgoal):\n 1. hd (tl (tl ST)) = NT \\<Longrightarrow> False", "with stkNN"], ["proof (chain)\npicking this:\n  hd (tl (tl stk)) \\<noteq> Null\n  hd (tl (tl stk)) = Null", "show False"], ["proof (prove)\nusing this:\n  hd (tl (tl stk)) \\<noteq> Null\n  hd (tl (tl stk)) = Null\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hd (tl (tl ST)) \\<noteq> NT\n\ngoal (1 subgoal):\n 1. hd (tl (tl stk)) \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with ins stkNN \\<Phi>_pc wt"], ["proof (chain)\npicking this:\n  ins ! pc = AStore\n  hd (tl (tl stk)) \\<noteq> Null\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  hd (tl (tl ST)) \\<noteq> NT", "obtain ST'' Y X ST' LT' where \n      ST: \"ST = Y # Integer # X\\<lfloor>\\<rceil> # ST''\" and\n      pc': \"pc+1 < size ins\"  and\n      \\<Phi>': \"\\<Phi> C M ! (pc+1) = Some (ST', LT')\" and\n      ST': \"P \\<turnstile> ST'' [\\<le>] ST'\" and LT': \"P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\" and\n      suc_pc:     \"pc+1 < size ins\""], ["proof (prove)\nusing this:\n  ins ! pc = AStore\n  hd (tl (tl stk)) \\<noteq> Null\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  hd (tl (tl ST)) \\<noteq> NT\n\ngoal (1 subgoal):\n 1. (\\<And>Y X ST'' ST' LT'.\n        \\<lbrakk>ST = Y # Integer # X\\<lfloor>\\<rceil> # ST'';\n         pc + 1 < length ins;\n         \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>;\n         P \\<turnstile> ST'' [\\<le>] ST';\n         P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT';\n         pc + 1 < length ins\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce)"], ["proof (state)\nthis:\n  ST = Y # Integer # X\\<lfloor>\\<rceil> # ST''\n  pc + 1 < length ins\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> ST'' [\\<le>] ST'\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n  pc + 1 < length ins\n\ngoal (1 subgoal):\n 1. hd (tl (tl stk)) \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from stk ST"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = Y # Integer # X\\<lfloor>\\<rceil> # ST''", "obtain ref e idx stk' where \n      stk': \"stk = e#idx#ref#stk'\" and\n      idx: \"P,h \\<turnstile> idx :\\<le> Integer\" and\n      ref:  \"P,h \\<turnstile> ref :\\<le> X\\<lfloor>\\<rceil>\" and\n      e: \"P,h \\<turnstile> e :\\<le> Y\" and\n      ST'': \"P,h \\<turnstile> stk' [:\\<le>] ST''\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = Y # Integer # X\\<lfloor>\\<rceil> # ST''\n\ngoal (1 subgoal):\n 1. (\\<And>e idx ref stk'.\n        \\<lbrakk>stk = e # idx # ref # stk';\n         P,h \\<turnstile> idx :\\<le> Integer;\n         P,h \\<turnstile> ref :\\<le> X\\<lfloor>\\<rceil>;\n         P,h \\<turnstile> e :\\<le> Y;\n         P,h \\<turnstile> stk' [:\\<le>] ST''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  stk = e # idx # ref # stk'\n  P,h \\<turnstile> idx :\\<le> Integer\n  P,h \\<turnstile> ref :\\<le> X\\<lfloor>\\<rceil>\n  P,h \\<turnstile> e :\\<le> Y\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n\ngoal (1 subgoal):\n 1. hd (tl (tl stk)) \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from stkNN stk'"], ["proof (chain)\npicking this:\n  hd (tl (tl stk)) \\<noteq> Null\n  stk = e # idx # ref # stk'", "have \"ref \\<noteq> Null\""], ["proof (prove)\nusing this:\n  hd (tl (tl stk)) \\<noteq> Null\n  stk = e # idx # ref # stk'\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null", "by(simp)"], ["proof (state)\nthis:\n  ref \\<noteq> Null\n\ngoal (1 subgoal):\n 1. hd (tl (tl stk)) \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with ref"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> ref :\\<le> X\\<lfloor>\\<rceil>\n  ref \\<noteq> Null", "obtain a Xel n\n      where a: \"ref = Addr a\"\n      and ha: \"typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\"\n      and Xel: \"P \\<turnstile> Xel \\<le> X\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> ref :\\<le> X\\<lfloor>\\<rceil>\n  ref \\<noteq> Null\n\ngoal (1 subgoal):\n 1. (\\<And>a Xel n.\n        \\<lbrakk>ref = Addr a;\n         typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>;\n         P \\<turnstile> Xel \\<le> X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases ref)(fastforce simp add: conf_def widen_Array)+"], ["proof (state)\nthis:\n  ref = Addr a\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  P \\<turnstile> Xel \\<le> X\n\ngoal (1 subgoal):\n 1. hd (tl (tl stk)) \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from idx"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> idx :\\<le> Integer", "obtain idxI where idxI: \"idx = Intg idxI\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> idx :\\<le> Integer\n\ngoal (1 subgoal):\n 1. (\\<And>idxI. idx = Intg idxI \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: conf_def)"], ["proof (state)\nthis:\n  idx = Intg idxI\n\ngoal (1 subgoal):\n 1. hd (tl (tl stk)) \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "proof(cases \"0 <=s idxI \\<and> sint idxI < int n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le>s idxI \\<and> sint idxI < int n \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "case True"], ["proof (state)\nthis:\n  0 \\<le>s idxI \\<and> sint idxI < int n\n\ngoal (2 subgoals):\n 1. 0 \\<le>s idxI \\<and> sint idxI < int n \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "hence si': \"0 <=s idxI\" \"sint idxI < int n\""], ["proof (prove)\nusing this:\n  0 \\<le>s idxI \\<and> sint idxI < int n\n\ngoal (1 subgoal):\n 1. 0 \\<le>s idxI &&& sint idxI < int n", "by simp_all"], ["proof (state)\nthis:\n  0 \\<le>s idxI\n  sint idxI < int n\n\ngoal (2 subgoals):\n 1. 0 \\<le>s idxI \\<and> sint idxI < int n \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from e"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> e :\\<le> Y", "obtain Te where Te: \"typeof\\<^bsub>h\\<^esub> e = \\<lfloor>Te\\<rfloor>\" \"P \\<turnstile> Te \\<le> Y\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> e :\\<le> Y\n\ngoal (1 subgoal):\n 1. (\\<And>Te.\n        \\<lbrakk>typeof\\<^bsub>h\\<^esub> e = \\<lfloor>Te\\<rfloor>;\n         P \\<turnstile> Te \\<le> Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: conf_def)"], ["proof (state)\nthis:\n  typeof\\<^bsub>h\\<^esub> e = \\<lfloor>Te\\<rfloor>\n  P \\<turnstile> Te \\<le> Y\n\ngoal (2 subgoals):\n 1. 0 \\<le>s idxI \\<and> sint idxI < int n \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "proof(cases \"P \\<turnstile> Te \\<le> Xel\")"], ["proof (state)\ngoal (2 subgoals):\n 1. P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "case True"], ["proof (state)\nthis:\n  P \\<turnstile> Te \\<le> Xel\n\ngoal (2 subgoals):\n 1. P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with Te"], ["proof (chain)\npicking this:\n  typeof\\<^bsub>h\\<^esub> e = \\<lfloor>Te\\<rfloor>\n  P \\<turnstile> Te \\<le> Y\n  P \\<turnstile> Te \\<le> Xel", "have eXel: \"P,h \\<turnstile> e :\\<le> Xel\""], ["proof (prove)\nusing this:\n  typeof\\<^bsub>h\\<^esub> e = \\<lfloor>Te\\<rfloor>\n  P \\<turnstile> Te \\<le> Y\n  P \\<turnstile> Te \\<le> Xel\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> e :\\<le> Xel", "by(auto simp add: conf_def intro: widen_trans)"], ["proof (state)\nthis:\n  P,h \\<turnstile> e :\\<le> Xel\n\ngoal (2 subgoals):\n 1. P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "{"], ["proof (state)\nthis:\n  P,h \\<turnstile> e :\\<le> Xel\n\ngoal (2 subgoals):\n 1. P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "fix h'"], ["proof (state)\ngoal (2 subgoals):\n 1. P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "assume \"write\": \"heap_write h a (ACell (nat (sint idxI))) e h'\""], ["proof (state)\nthis:\n  heap_write h a (ACell (nat (sint idxI))) e h'\n\ngoal (2 subgoals):\n 1. P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "hence hext: \"h \\<unlhd> h'\""], ["proof (prove)\nusing this:\n  heap_write h a (ACell (nat (sint idxI))) e h'\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "by(rule hext_heap_write)"], ["proof (state)\nthis:\n  h \\<unlhd> h'\n\ngoal (2 subgoals):\n 1. P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with preh"], ["proof (chain)\npicking this:\n  preallocated h\n  h \\<unlhd> h'", "have preh': \"preallocated h'\""], ["proof (prove)\nusing this:\n  preallocated h\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. preallocated h'", "by(rule preallocated_hext)"], ["proof (state)\nthis:\n  preallocated h'\n\ngoal (2 subgoals):\n 1. P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "let ?f = \"(stk', loc, C, M, pc + 1)\""], ["proof (state)\ngoal (2 subgoals):\n 1. P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from si'"], ["proof (chain)\npicking this:\n  0 \\<le>s idxI\n  sint idxI < int n", "have \"nat (sint idxI) < n\""], ["proof (prove)\nusing this:\n  0 \\<le>s idxI\n  sint idxI < int n\n\ngoal (1 subgoal):\n 1. nat (sint idxI) < n", "by (simp add: word_sle_eq nat_less_iff)"], ["proof (state)\nthis:\n  nat (sint idxI) < n\n\ngoal (2 subgoals):\n 1. P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with ha"], ["proof (chain)\npicking this:\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  nat (sint idxI) < n", "have \"P,h \\<turnstile> a@ACell (nat (sint idxI)) : Xel\""], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  nat (sint idxI) < n\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> a@ACell (nat (sint idxI)) : Xel", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> a@ACell (nat (sint idxI)) : Xel\n\ngoal (2 subgoals):\n 1. P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with \"write\" heap_ok"], ["proof (chain)\npicking this:\n  heap_write h a (ACell (nat (sint idxI))) e h'\n  hconf h\n  P,h \\<turnstile> a@ACell (nat (sint idxI)) : Xel", "have heap_ok': \"hconf h'\""], ["proof (prove)\nusing this:\n  heap_write h a (ACell (nat (sint idxI))) e h'\n  hconf h\n  P,h \\<turnstile> a@ACell (nat (sint idxI)) : Xel\n\ngoal (1 subgoal):\n 1. hconf h'", "using eXel"], ["proof (prove)\nusing this:\n  heap_write h a (ACell (nat (sint idxI))) e h'\n  hconf h\n  P,h \\<turnstile> a@ACell (nat (sint idxI)) : Xel\n  P,h \\<turnstile> e :\\<le> Xel\n\ngoal (1 subgoal):\n 1. hconf h'", "by(rule hconf_heap_write_mono)"], ["proof (state)\nthis:\n  hconf h'\n\ngoal (2 subgoals):\n 1. P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "moreover"], ["proof (state)\nthis:\n  hconf h'\n\ngoal (2 subgoals):\n 1. P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from ST stk stk' ST'"], ["proof (chain)\npicking this:\n  ST = Y # Integer # X\\<lfloor>\\<rceil> # ST''\n  P,h \\<turnstile> stk [:\\<le>] ST\n  stk = e # idx # ref # stk'\n  P \\<turnstile> ST'' [\\<le>] ST'", "have \"P,h \\<turnstile> stk' [:\\<le>] ST'\""], ["proof (prove)\nusing this:\n  ST = Y # Integer # X\\<lfloor>\\<rceil> # ST''\n  P,h \\<turnstile> stk [:\\<le>] ST\n  stk = e # idx # ref # stk'\n  P \\<turnstile> ST'' [\\<le>] ST'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> stk' [:\\<le>] ST'", "by auto"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n\ngoal (2 subgoals):\n 1. P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with hext"], ["proof (chain)\npicking this:\n  h \\<unlhd> h'\n  P,h \\<turnstile> stk' [:\\<le>] ST'", "have stk'': \"P,h' \\<turnstile> stk' [:\\<le>] ST'\""], ["proof (prove)\nusing this:\n  h \\<unlhd> h'\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. P,h' \\<turnstile> stk' [:\\<le>] ST'", "by- (rule confs_hext)"], ["proof (state)\nthis:\n  P,h' \\<turnstile> stk' [:\\<le>] ST'\n\ngoal (2 subgoals):\n 1. P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "moreover"], ["proof (state)\nthis:\n  P,h' \\<turnstile> stk' [:\\<le>] ST'\n\ngoal (2 subgoals):\n 1. P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from loc LT'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'", "have \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (2 subgoals):\n 1. P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with hext"], ["proof (chain)\npicking this:\n  h \\<unlhd> h'\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'", "have \"P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\""], ["proof (prove)\nusing this:\n  h \\<unlhd> h'\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'", "by - (rule confTs_hext)"], ["proof (state)\nthis:\n  P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (2 subgoals):\n 1. P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "moreover"], ["proof (state)\nthis:\n  P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (2 subgoals):\n 1. P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with frame ST' ST LT' suc_pc wf Xel idxI si' stk''"], ["proof (chain)\npicking this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  P \\<turnstile> ST'' [\\<le>] ST'\n  ST = Y # Integer # X\\<lfloor>\\<rceil> # ST''\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n  pc + 1 < length ins\n  wf_prog wt P\n  P \\<turnstile> Xel \\<le> X\n  idx = Intg idxI\n  0 \\<le>s idxI\n  sint idxI < int n\n  P,h' \\<turnstile> stk' [:\\<le>] ST'\n  P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'", "have \"conf_f P h' (ST', LT') ins ?f\""], ["proof (prove)\nusing this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  P \\<turnstile> ST'' [\\<le>] ST'\n  ST = Y # Integer # X\\<lfloor>\\<rceil> # ST''\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n  pc + 1 < length ins\n  wf_prog wt P\n  P \\<turnstile> Xel \\<le> X\n  idx = Intg idxI\n  0 \\<le>s idxI\n  sint idxI < int n\n  P,h' \\<turnstile> stk' [:\\<le>] ST'\n  P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. conf_f P h' (ST', LT') ins (stk', loc, C, M, pc + 1)", "by(clarsimp)"], ["proof (state)\nthis:\n  conf_f P h' (ST', LT') ins (stk', loc, C, M, pc + 1)\n\ngoal (2 subgoals):\n 1. P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with frames hext"], ["proof (chain)\npicking this:\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  h \\<unlhd> h'\n  conf_f P h' (ST', LT') ins (stk', loc, C, M, pc + 1)", "have \"conf_fs P h' \\<Phi> M (size Ts) T frs\""], ["proof (prove)\nusing this:\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  h \\<unlhd> h'\n  conf_f P h' (ST', LT') ins (stk', loc, C, M, pc + 1)\n\ngoal (1 subgoal):\n 1. conf_fs P h' \\<Phi> M (length Ts) T frs", "by- (rule conf_fs_hext)"], ["proof (state)\nthis:\n  conf_fs P h' \\<Phi> M (length Ts) T frs\n\ngoal (2 subgoals):\n 1. P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "moreover"], ["proof (state)\nthis:\n  conf_fs P h' \\<Phi> M (length Ts) T frs\n\ngoal (2 subgoals):\n 1. P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from tconf hext"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> t \\<surd>t\n  h \\<unlhd> h'", "have \"P,h' \\<turnstile> t \\<surd>t\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> t \\<surd>t\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. P,h' \\<turnstile> t \\<surd>t", "by(rule tconf_hext_mono)"], ["proof (state)\nthis:\n  P,h' \\<turnstile> t \\<surd>t\n\ngoal (2 subgoals):\n 1. P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "ultimately"], ["proof (chain)\npicking this:\n  hconf h'\n  P,h' \\<turnstile> stk' [:\\<le>] ST'\n  P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  conf_fs P h' \\<Phi> M (length Ts) T frs\n  P,h' \\<turnstile> t \\<surd>t", "have \"\\<Phi> \\<turnstile> t:(None, h', ?f # frs) \\<surd>\""], ["proof (prove)\nusing this:\n  hconf h'\n  P,h' \\<turnstile> stk' [:\\<le>] ST'\n  P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  conf_fs P h' \\<Phi> M (length Ts) T frs\n  P,h' \\<turnstile> t \\<surd>t\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:(None, h',\n                           (stk', loc, C, M, pc + 1) # frs) \\<surd>", "using meth \\<Phi>' \\<Phi>_pc suc_pc preh'"], ["proof (prove)\nusing this:\n  hconf h'\n  P,h' \\<turnstile> stk' [:\\<le>] ST'\n  P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  conf_fs P h' \\<Phi> M (length Ts) T frs\n  P,h' \\<turnstile> t \\<surd>t\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  pc + 1 < length ins\n  preallocated h'\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:(None, h',\n                           (stk', loc, C, M, pc + 1) # frs) \\<surd>", "by(fastforce)"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:(None, h', (stk', loc, C, M, pc + 1) # frs) \\<surd>\n\ngoal (2 subgoals):\n 1. P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "}"], ["proof (state)\nthis:\n  heap_write h a (ACell (nat (sint idxI))) e ?h'17 \\<Longrightarrow>\n  \\<Phi> \\<turnstile> t:(None, ?h'17,\n                         (stk', loc, C, M, pc + 1) # frs) \\<surd>\n\ngoal (2 subgoals):\n 1. P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. \\<not> P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with True si' ins meth stk' a ha no_x idxI idx Te"], ["proof (chain)\npicking this:\n  P \\<turnstile> Te \\<le> Xel\n  0 \\<le>s idxI\n  sint idxI < int n\n  ins ! pc = AStore\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  stk = e # idx # ref # stk'\n  ref = Addr a\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  idx = Intg idxI\n  P,h \\<turnstile> idx :\\<le> Integer\n  typeof\\<^bsub>h\\<^esub> e = \\<lfloor>Te\\<rfloor>\n  P \\<turnstile> Te \\<le> Y\n  heap_write h a (ACell (nat (sint idxI))) e ?h'17 \\<Longrightarrow>\n  \\<Phi> \\<turnstile> t:(None, ?h'17,\n                         (stk', loc, C, M, pc + 1) # frs) \\<surd>", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> Te \\<le> Xel\n  0 \\<le>s idxI\n  sint idxI < int n\n  ins ! pc = AStore\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  stk = e # idx # ref # stk'\n  ref = Addr a\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  idx = Intg idxI\n  P,h \\<turnstile> idx :\\<le> Integer\n  typeof\\<^bsub>h\\<^esub> e = \\<lfloor>Te\\<rfloor>\n  P \\<turnstile> Te \\<le> Y\n  heap_write h a (ACell (nat (sint idxI))) e ?h'17 \\<Longrightarrow>\n  \\<Phi> \\<turnstile> t:(None, ?h'17,\n                         (stk', loc, C, M, pc + 1) # frs) \\<surd>\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "by(auto split: if_split_asm simp del: correct_state_def intro: widen_trans)"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal (1 subgoal):\n 1. \\<not> P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "case False"], ["proof (state)\nthis:\n  \\<not> P \\<turnstile> Te \\<le> Xel\n\ngoal (1 subgoal):\n 1. \\<not> P \\<turnstile> Te \\<le> Xel \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with stk' idxI ins no_x heap_ok tconf meth a ha Xel Te \\<Phi>_pc frame frames si' preh\n          wf_preallocatedD[OF wf, of h ArrayStore]"], ["proof (chain)\npicking this:\n  stk = e # idx # ref # stk'\n  idx = Intg idxI\n  ins ! pc = AStore\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  hconf h\n  P,h \\<turnstile> t \\<surd>t\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  ref = Addr a\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  P \\<turnstile> Xel \\<le> X\n  typeof\\<^bsub>h\\<^esub> e = \\<lfloor>Te\\<rfloor>\n  P \\<turnstile> Te \\<le> Y\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  0 \\<le>s idxI\n  sint idxI < int n\n  preallocated h\n  \\<lbrakk>preallocated h; ArrayStore \\<in> sys_xcpts\\<rbrakk>\n  \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt ArrayStore) =\n                    \\<lfloor>Class_type ArrayStore\\<rfloor> \\<and>\n                    P \\<turnstile> ArrayStore \\<preceq>\\<^sup>* Throwable\n  \\<not> P \\<turnstile> Te \\<le> Xel", "show ?thesis"], ["proof (prove)\nusing this:\n  stk = e # idx # ref # stk'\n  idx = Intg idxI\n  ins ! pc = AStore\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  hconf h\n  P,h \\<turnstile> t \\<surd>t\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  ref = Addr a\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  P \\<turnstile> Xel \\<le> X\n  typeof\\<^bsub>h\\<^esub> e = \\<lfloor>Te\\<rfloor>\n  P \\<turnstile> Te \\<le> Y\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  0 \\<le>s idxI\n  sint idxI < int n\n  preallocated h\n  \\<lbrakk>preallocated h; ArrayStore \\<in> sys_xcpts\\<rbrakk>\n  \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt ArrayStore) =\n                    \\<lfloor>Class_type ArrayStore\\<rfloor> \\<and>\n                    P \\<turnstile> ArrayStore \\<preceq>\\<^sup>* Throwable\n  \\<not> P \\<turnstile> Te \\<le> Xel\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "by(fastforce split: if_split_asm)"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal (1 subgoal):\n 1. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "case False"], ["proof (state)\nthis:\n  \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n)\n\ngoal (1 subgoal):\n 1. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with stk' idxI ins no_x heap_ok tconf meth a ha Xel \\<Phi>_pc frame frames preh\n        wf_preallocatedD[OF wf, of h ArrayIndexOutOfBounds]"], ["proof (chain)\npicking this:\n  stk = e # idx # ref # stk'\n  idx = Intg idxI\n  ins ! pc = AStore\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  hconf h\n  P,h \\<turnstile> t \\<surd>t\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  ref = Addr a\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  P \\<turnstile> Xel \\<le> X\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  preallocated h\n  \\<lbrakk>preallocated h; ArrayIndexOutOfBounds \\<in> sys_xcpts\\<rbrakk>\n  \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt ArrayIndexOutOfBounds) =\n                    \\<lfloor>Class_type\n                              ArrayIndexOutOfBounds\\<rfloor> \\<and>\n                    P \\<turnstile> ArrayIndexOutOfBounds \\<preceq>\\<^sup>* Throwable\n  \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n)", "show ?thesis"], ["proof (prove)\nusing this:\n  stk = e # idx # ref # stk'\n  idx = Intg idxI\n  ins ! pc = AStore\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  hconf h\n  P,h \\<turnstile> t \\<surd>t\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  ref = Addr a\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  P \\<turnstile> Xel \\<le> X\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  preallocated h\n  \\<lbrakk>preallocated h; ArrayIndexOutOfBounds \\<in> sys_xcpts\\<rbrakk>\n  \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt ArrayIndexOutOfBounds) =\n                    \\<lfloor>Class_type\n                              ArrayIndexOutOfBounds\\<rfloor> \\<and>\n                    P \\<turnstile> ArrayIndexOutOfBounds \\<preceq>\\<^sup>* Throwable\n  \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n)\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "by(fastforce split: if_split_asm)"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ALength_correct:\n  assumes wf:   \"wf_prog wt P\"\n  assumes meth: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C\"\n  assumes ins:  \"ins!pc = ALength\"\n  assumes wt:   \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes conf: \"\\<Phi> \\<turnstile> t: (None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  assumes no_x: \"(tas, \\<sigma>) \\<in> exec_instr (ins!pc) P t h stk loc C M pc frs\"\n  shows \"\\<Phi> \\<turnstile> t: \\<sigma> \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from ins conf meth"], ["proof (chain)\npicking this:\n  ins ! pc = ALength\n  \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C", "obtain ST LT where\n    heap_ok: \"hconf h\" and\n    tconf:   \"P,h \\<turnstile> t \\<surd>t\" and\n    \\<Phi>_pc:    \"\\<Phi> C M!pc = Some (ST,LT)\" and\n    stk: \"P,h \\<turnstile> stk [:\\<le>] ST\" and loc: \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\" and\n    pc: \"pc < size ins\" and \n    frame:   \"conf_f P h (ST,LT) ins (stk,loc,C,M,pc)\" and\n    frames:  \"conf_fs P h \\<Phi> M (size Ts) T frs\" and\n    preh:    \"preallocated h\""], ["proof (prove)\nusing this:\n  ins ! pc = ALength\n  \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>hconf h; P,h \\<turnstile> t \\<surd>t;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         P,h \\<turnstile> stk [:\\<le>] ST;\n         P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length ins;\n         conf_f P h (ST, LT) ins (stk, loc, C, M, pc);\n         conf_fs P h \\<Phi> M (length Ts) T frs; preallocated h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: sees_method_fun)"], ["proof (state)\nthis:\n  hconf h\n  P,h \\<turnstile> t \\<surd>t\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  preallocated h\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from ins wt \\<Phi>_pc"], ["proof (chain)\npicking this:\n  ins ! pc = ALength\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>", "have lST: \"length ST > 0\""], ["proof (prove)\nusing this:\n  ins ! pc = ALength\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n\ngoal (1 subgoal):\n 1. 0 < length ST", "by(auto)"], ["proof (state)\nthis:\n  0 < length ST\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "proof(cases \"hd stk = Null\")"], ["proof (state)\ngoal (2 subgoals):\n 1. hd stk = Null \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "case True"], ["proof (state)\nthis:\n  hd stk = Null\n\ngoal (2 subgoals):\n 1. hd stk = Null \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with ins no_x heap_ok tconf \\<Phi>_pc stk loc frame frames meth wf_preallocatedD[OF wf, of h NullPointer] preh"], ["proof (chain)\npicking this:\n  ins ! pc = ALength\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  hconf h\n  P,h \\<turnstile> t \\<surd>t\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<lbrakk>preallocated h; NullPointer \\<in> sys_xcpts\\<rbrakk>\n  \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt NullPointer) =\n                    \\<lfloor>Class_type NullPointer\\<rfloor> \\<and>\n                    P \\<turnstile> NullPointer \\<preceq>\\<^sup>* Throwable\n  preallocated h\n  hd stk = Null", "show ?thesis"], ["proof (prove)\nusing this:\n  ins ! pc = ALength\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  hconf h\n  P,h \\<turnstile> t \\<surd>t\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<lbrakk>preallocated h; NullPointer \\<in> sys_xcpts\\<rbrakk>\n  \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt NullPointer) =\n                    \\<lfloor>Class_type NullPointer\\<rfloor> \\<and>\n                    P \\<turnstile> NullPointer \\<preceq>\\<^sup>* Throwable\n  preallocated h\n  hd stk = Null\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "by(fastforce)"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "case False"], ["proof (state)\nthis:\n  hd stk \\<noteq> Null\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "note stkNN = this"], ["proof (state)\nthis:\n  hd stk \\<noteq> Null\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "have STNN: \"hd ST \\<noteq> NT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd ST \\<noteq> NT", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. hd ST = NT \\<Longrightarrow> False", "assume \"hd ST = NT\""], ["proof (state)\nthis:\n  hd ST = NT\n\ngoal (1 subgoal):\n 1. hd ST = NT \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  hd ST = NT\n\ngoal (1 subgoal):\n 1. hd ST = NT \\<Longrightarrow> False", "from frame"], ["proof (chain)\npicking this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)", "have \"P,h \\<turnstile> stk [:\\<le>] ST\""], ["proof (prove)\nusing this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> stk [:\\<le>] ST", "by simp"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. hd ST = NT \\<Longrightarrow> False", "with lST"], ["proof (chain)\npicking this:\n  0 < length ST\n  P,h \\<turnstile> stk [:\\<le>] ST", "have \"P,h \\<turnstile> hd stk :\\<le> hd ST\""], ["proof (prove)\nusing this:\n  0 < length ST\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> hd stk :\\<le> hd ST", "by (cases ST, auto)"], ["proof (state)\nthis:\n  P,h \\<turnstile> hd stk :\\<le> hd ST\n\ngoal (1 subgoal):\n 1. hd ST = NT \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  hd ST = NT\n  P,h \\<turnstile> hd stk :\\<le> hd ST", "have \"hd stk = Null\""], ["proof (prove)\nusing this:\n  hd ST = NT\n  P,h \\<turnstile> hd stk :\\<le> hd ST\n\ngoal (1 subgoal):\n 1. hd stk = Null", "by simp"], ["proof (state)\nthis:\n  hd stk = Null\n\ngoal (1 subgoal):\n 1. hd ST = NT \\<Longrightarrow> False", "with stkNN"], ["proof (chain)\npicking this:\n  hd stk \\<noteq> Null\n  hd stk = Null", "show False"], ["proof (prove)\nusing this:\n  hd stk \\<noteq> Null\n  hd stk = Null\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hd ST \\<noteq> NT\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with stkNN ins \\<Phi>_pc wt"], ["proof (chain)\npicking this:\n  hd stk \\<noteq> Null\n  ins ! pc = ALength\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  hd ST \\<noteq> NT", "obtain ST'' X ST' LT' where \n      ST: \"ST = (X\\<lfloor>\\<rceil>) # ST''\" and\n      pc': \"pc+1 < size ins\"  and\n      \\<Phi>': \"\\<Phi> C M ! (pc+1) = Some (ST', LT')\" and\n      ST': \"P \\<turnstile> (Integer # ST'') [\\<le>] ST'\" and LT': \"P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\" and\n      suc_pc:     \"pc+1 < size ins\""], ["proof (prove)\nusing this:\n  hd stk \\<noteq> Null\n  ins ! pc = ALength\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  hd ST \\<noteq> NT\n\ngoal (1 subgoal):\n 1. (\\<And>X ST'' ST' LT'.\n        \\<lbrakk>ST = X\\<lfloor>\\<rceil> # ST''; pc + 1 < length ins;\n         \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>;\n         P \\<turnstile> (Integer # ST'') [\\<le>] ST';\n         P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT';\n         pc + 1 < length ins\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce)"], ["proof (state)\nthis:\n  ST = X\\<lfloor>\\<rceil> # ST''\n  pc + 1 < length ins\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> (Integer # ST'') [\\<le>] ST'\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n  pc + 1 < length ins\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from stk ST"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = X\\<lfloor>\\<rceil> # ST''", "obtain ref stk' where \n      stk': \"stk = ref#stk'\" and\n      ref:  \"P,h \\<turnstile> ref :\\<le> X\\<lfloor>\\<rceil>\" and\n      ST'': \"P,h \\<turnstile> stk' [:\\<le>] ST''\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = X\\<lfloor>\\<rceil> # ST''\n\ngoal (1 subgoal):\n 1. (\\<And>ref stk'.\n        \\<lbrakk>stk = ref # stk';\n         P,h \\<turnstile> ref :\\<le> X\\<lfloor>\\<rceil>;\n         P,h \\<turnstile> stk' [:\\<le>] ST''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  stk = ref # stk'\n  P,h \\<turnstile> ref :\\<le> X\\<lfloor>\\<rceil>\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from stkNN stk'"], ["proof (chain)\npicking this:\n  hd stk \\<noteq> Null\n  stk = ref # stk'", "have \"ref \\<noteq> Null\""], ["proof (prove)\nusing this:\n  hd stk \\<noteq> Null\n  stk = ref # stk'\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null", "by(simp)"], ["proof (state)\nthis:\n  ref \\<noteq> Null\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with ref"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> ref :\\<le> X\\<lfloor>\\<rceil>\n  ref \\<noteq> Null", "obtain a Xel n\n      where a: \"ref = Addr a\"\n      and ha: \"typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\"\n      and Xel: \"P \\<turnstile> Xel \\<le> X\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> ref :\\<le> X\\<lfloor>\\<rceil>\n  ref \\<noteq> Null\n\ngoal (1 subgoal):\n 1. (\\<And>a Xel n.\n        \\<lbrakk>ref = Addr a;\n         typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>;\n         P \\<turnstile> Xel \\<le> X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases ref)(fastforce simp add: conf_def widen_Array)+"], ["proof (state)\nthis:\n  ref = Addr a\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  P \\<turnstile> Xel \\<le> X\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from ins meth stk' a ha no_x"], ["proof (chain)\npicking this:\n  ins ! pc = ALength\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  stk = ref # stk'\n  ref = Addr a\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs", "have \\<sigma>':\n      \"\\<sigma> = (None, h, (Intg (word_of_int (int n)) # stk', loc, C, M, pc + 1) # frs)\"\n      (is \"\\<sigma> = (None, h, ?f # frs)\")"], ["proof (prove)\nusing this:\n  ins ! pc = ALength\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  stk = ref # stk'\n  ref = Addr a\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n\ngoal (1 subgoal):\n 1. \\<sigma> =\n    (None, h, (Intg (word_of_int (int n)) # stk', loc, C, M, pc + 1) # frs)", "by(auto)"], ["proof (state)\nthis:\n  \\<sigma> =\n  (None, h, (Intg (word_of_int (int n)) # stk', loc, C, M, pc + 1) # frs)\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "moreover"], ["proof (state)\nthis:\n  \\<sigma> =\n  (None, h, (Intg (word_of_int (int n)) # stk', loc, C, M, pc + 1) # frs)\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from ST stk stk' ST'"], ["proof (chain)\npicking this:\n  ST = X\\<lfloor>\\<rceil> # ST''\n  P,h \\<turnstile> stk [:\\<le>] ST\n  stk = ref # stk'\n  P \\<turnstile> (Integer # ST'') [\\<le>] ST'", "have \"P,h \\<turnstile> Intg si # stk' [:\\<le>] ST'\""], ["proof (prove)\nusing this:\n  ST = X\\<lfloor>\\<rceil> # ST''\n  P,h \\<turnstile> stk [:\\<le>] ST\n  stk = ref # stk'\n  P \\<turnstile> (Integer # ST'') [\\<le>] ST'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> Intg si # stk' [:\\<le>] ST'", "by(auto)"], ["proof (state)\nthis:\n  P,h \\<turnstile> Intg si # stk' [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with frame ST' ST LT' suc_pc wf"], ["proof (chain)\npicking this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  P \\<turnstile> (Integer # ST'') [\\<le>] ST'\n  ST = X\\<lfloor>\\<rceil> # ST''\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n  pc + 1 < length ins\n  wf_prog wt P\n  P,h \\<turnstile> Intg si # stk' [:\\<le>] ST'", "have \"conf_f P h (ST', LT') ins ?f\""], ["proof (prove)\nusing this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  P \\<turnstile> (Integer # ST'') [\\<le>] ST'\n  ST = X\\<lfloor>\\<rceil> # ST''\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n  pc + 1 < length ins\n  wf_prog wt P\n  P,h \\<turnstile> Intg si # stk' [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. conf_f P h (ST', LT') ins\n     (Intg (word_of_int (int n)) # stk', loc, C, M, pc + 1)", "by(fastforce intro: widen_trans)"], ["proof (state)\nthis:\n  conf_f P h (ST', LT') ins\n   (Intg (word_of_int (int n)) # stk', loc, C, M, pc + 1)\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "ultimately"], ["proof (chain)\npicking this:\n  \\<sigma> =\n  (None, h, (Intg (word_of_int (int n)) # stk', loc, C, M, pc + 1) # frs)\n  conf_f P h (ST', LT') ins\n   (Intg (word_of_int (int n)) # stk', loc, C, M, pc + 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<sigma> =\n  (None, h, (Intg (word_of_int (int n)) # stk', loc, C, M, pc + 1) # frs)\n  conf_f P h (ST', LT') ins\n   (Intg (word_of_int (int n)) # stk', loc, C, M, pc + 1)\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "using meth \\<Phi>' heap_ok \\<Phi>_pc frames tconf preh"], ["proof (prove)\nusing this:\n  \\<sigma> =\n  (None, h, (Intg (word_of_int (int n)) # stk', loc, C, M, pc + 1) # frs)\n  conf_f P h (ST', LT') ins\n   (Intg (word_of_int (int n)) # stk', loc, C, M, pc + 1)\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  hconf h\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  P,h \\<turnstile> t \\<surd>t\n  preallocated h\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "by fastforce"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma MEnter_correct:\n  assumes wf:   \"wf_prog wt P\"\n  assumes meth: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C\"\n  assumes ins:  \"ins!pc = MEnter\"\n  assumes wt:   \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes conf: \"\\<Phi> \\<turnstile> t: (None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  assumes no_x: \"(tas, \\<sigma>) \\<in> exec_instr (ins!pc) P t h stk loc C M pc frs\"\n  shows \"\\<Phi> \\<turnstile> t: \\<sigma> \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from ins conf meth"], ["proof (chain)\npicking this:\n  ins ! pc = MEnter\n  \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C", "obtain ST LT where\n    heap_ok: \"hconf h\" and\n    tconf:   \"P,h \\<turnstile> t \\<surd>t\" and\n    \\<Phi>_pc:    \"\\<Phi> C M!pc = Some (ST,LT)\" and\n    stk: \"P,h \\<turnstile> stk [:\\<le>] ST\" and loc: \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\" and\n    pc: \"pc < size ins\" and \n    frame:   \"conf_f P h (ST,LT) ins (stk,loc,C,M,pc)\" and\n    frames:  \"conf_fs P h \\<Phi> M (size Ts) T frs\" and\n    preh:    \"preallocated h\""], ["proof (prove)\nusing this:\n  ins ! pc = MEnter\n  \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>hconf h; P,h \\<turnstile> t \\<surd>t;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         P,h \\<turnstile> stk [:\\<le>] ST;\n         P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length ins;\n         conf_f P h (ST, LT) ins (stk, loc, C, M, pc);\n         conf_fs P h \\<Phi> M (length Ts) T frs; preallocated h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: sees_method_fun)"], ["proof (state)\nthis:\n  hconf h\n  P,h \\<turnstile> t \\<surd>t\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  preallocated h\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from ins wt \\<Phi>_pc"], ["proof (chain)\npicking this:\n  ins ! pc = MEnter\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>", "have lST: \"length ST > 0\""], ["proof (prove)\nusing this:\n  ins ! pc = MEnter\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n\ngoal (1 subgoal):\n 1. 0 < length ST", "by(auto)"], ["proof (state)\nthis:\n  0 < length ST\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "proof(cases \"hd stk = Null\")"], ["proof (state)\ngoal (2 subgoals):\n 1. hd stk = Null \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "case True"], ["proof (state)\nthis:\n  hd stk = Null\n\ngoal (2 subgoals):\n 1. hd stk = Null \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with ins no_x heap_ok tconf \\<Phi>_pc stk loc frame frames meth wf_preallocatedD[OF wf, of h NullPointer] preh"], ["proof (chain)\npicking this:\n  ins ! pc = MEnter\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  hconf h\n  P,h \\<turnstile> t \\<surd>t\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<lbrakk>preallocated h; NullPointer \\<in> sys_xcpts\\<rbrakk>\n  \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt NullPointer) =\n                    \\<lfloor>Class_type NullPointer\\<rfloor> \\<and>\n                    P \\<turnstile> NullPointer \\<preceq>\\<^sup>* Throwable\n  preallocated h\n  hd stk = Null", "show ?thesis"], ["proof (prove)\nusing this:\n  ins ! pc = MEnter\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  hconf h\n  P,h \\<turnstile> t \\<surd>t\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<lbrakk>preallocated h; NullPointer \\<in> sys_xcpts\\<rbrakk>\n  \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt NullPointer) =\n                    \\<lfloor>Class_type NullPointer\\<rfloor> \\<and>\n                    P \\<turnstile> NullPointer \\<preceq>\\<^sup>* Throwable\n  preallocated h\n  hd stk = Null\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "by(fastforce)"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "case False"], ["proof (state)\nthis:\n  hd stk \\<noteq> Null\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "note stkNN = this"], ["proof (state)\nthis:\n  hd stk \\<noteq> Null\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "have STNN: \"hd ST \\<noteq> NT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd ST \\<noteq> NT", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. hd ST = NT \\<Longrightarrow> False", "assume \"hd ST = NT\""], ["proof (state)\nthis:\n  hd ST = NT\n\ngoal (1 subgoal):\n 1. hd ST = NT \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  hd ST = NT\n\ngoal (1 subgoal):\n 1. hd ST = NT \\<Longrightarrow> False", "from frame"], ["proof (chain)\npicking this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)", "have \"P,h \\<turnstile> stk [:\\<le>] ST\""], ["proof (prove)\nusing this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> stk [:\\<le>] ST", "by simp"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. hd ST = NT \\<Longrightarrow> False", "with lST"], ["proof (chain)\npicking this:\n  0 < length ST\n  P,h \\<turnstile> stk [:\\<le>] ST", "have \"P,h \\<turnstile> hd stk :\\<le> hd ST\""], ["proof (prove)\nusing this:\n  0 < length ST\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> hd stk :\\<le> hd ST", "by (cases ST, auto)"], ["proof (state)\nthis:\n  P,h \\<turnstile> hd stk :\\<le> hd ST\n\ngoal (1 subgoal):\n 1. hd ST = NT \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  hd ST = NT\n  P,h \\<turnstile> hd stk :\\<le> hd ST", "have \"hd stk = Null\""], ["proof (prove)\nusing this:\n  hd ST = NT\n  P,h \\<turnstile> hd stk :\\<le> hd ST\n\ngoal (1 subgoal):\n 1. hd stk = Null", "by simp"], ["proof (state)\nthis:\n  hd stk = Null\n\ngoal (1 subgoal):\n 1. hd ST = NT \\<Longrightarrow> False", "with stkNN"], ["proof (chain)\npicking this:\n  hd stk \\<noteq> Null\n  hd stk = Null", "show False"], ["proof (prove)\nusing this:\n  hd stk \\<noteq> Null\n  hd stk = Null\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hd ST \\<noteq> NT\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with stkNN ins \\<Phi>_pc wt"], ["proof (chain)\npicking this:\n  hd stk \\<noteq> Null\n  ins ! pc = MEnter\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  hd ST \\<noteq> NT", "obtain ST'' X ST' LT' where \n      ST: \"ST = X # ST''\" and\n      refT: \"is_refT X\" and\n      pc': \"pc+1 < size ins\"  and\n      \\<Phi>': \"\\<Phi> C M ! (pc+1) = Some (ST', LT')\" and\n      ST': \"P \\<turnstile> ST'' [\\<le>] ST'\" and LT': \"P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\" and\n      suc_pc:     \"pc+1 < size ins\""], ["proof (prove)\nusing this:\n  hd stk \\<noteq> Null\n  ins ! pc = MEnter\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  hd ST \\<noteq> NT\n\ngoal (1 subgoal):\n 1. (\\<And>X ST'' ST' LT'.\n        \\<lbrakk>ST = X # ST''; is_refT X; pc + 1 < length ins;\n         \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>;\n         P \\<turnstile> ST'' [\\<le>] ST';\n         P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT';\n         pc + 1 < length ins\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce)"], ["proof (state)\nthis:\n  ST = X # ST''\n  is_refT X\n  pc + 1 < length ins\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> ST'' [\\<le>] ST'\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n  pc + 1 < length ins\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from stk ST"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = X # ST''", "obtain ref stk' where \n      stk': \"stk = ref#stk'\" and\n      ref:  \"P,h \\<turnstile> ref :\\<le> X\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = X # ST''\n\ngoal (1 subgoal):\n 1. (\\<And>ref stk'.\n        \\<lbrakk>stk = ref # stk'; P,h \\<turnstile> ref :\\<le> X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  stk = ref # stk'\n  P,h \\<turnstile> ref :\\<le> X\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from stkNN stk'"], ["proof (chain)\npicking this:\n  hd stk \\<noteq> Null\n  stk = ref # stk'", "have \"ref \\<noteq> Null\""], ["proof (prove)\nusing this:\n  hd stk \\<noteq> Null\n  stk = ref # stk'\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null", "by(simp)"], ["proof (state)\nthis:\n  ref \\<noteq> Null\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "moreover"], ["proof (state)\nthis:\n  ref \\<noteq> Null\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from loc LT'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'", "have \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "moreover"], ["proof (state)\nthis:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from ST stk stk' ST'"], ["proof (chain)\npicking this:\n  ST = X # ST''\n  P,h \\<turnstile> stk [:\\<le>] ST\n  stk = ref # stk'\n  P \\<turnstile> ST'' [\\<le>] ST'", "have \"P,h \\<turnstile> stk' [:\\<le>] ST'\""], ["proof (prove)\nusing this:\n  ST = X # ST''\n  P,h \\<turnstile> stk [:\\<le>] ST\n  stk = ref # stk'\n  P \\<turnstile> ST'' [\\<le>] ST'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> stk' [:\\<le>] ST'", "by(auto)"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "ultimately"], ["proof (chain)\npicking this:\n  ref \\<noteq> Null\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  P,h \\<turnstile> stk' [:\\<le>] ST'", "show ?thesis"], ["proof (prove)\nusing this:\n  ref \\<noteq> Null\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "using meth \\<Phi>' heap_ok \\<Phi>_pc suc_pc frames loc LT' no_x ins stk' ST' tconf preh"], ["proof (prove)\nusing this:\n  ref \\<noteq> Null\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  hconf h\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  pc + 1 < length ins\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  ins ! pc = MEnter\n  stk = ref # stk'\n  P \\<turnstile> ST'' [\\<le>] ST'\n  P,h \\<turnstile> t \\<surd>t\n  preallocated h\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "by(fastforce)"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma MExit_correct:\n  assumes wf:   \"wf_prog wt P\"\n  assumes meth: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C\"\n  assumes ins:  \"ins!pc = MExit\"\n  assumes wt:   \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes conf: \"\\<Phi> \\<turnstile> t: (None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  assumes no_x: \"(tas, \\<sigma>) \\<in> exec_instr (ins!pc) P t h stk loc C M pc frs\"\n  shows \"\\<Phi> \\<turnstile> t: \\<sigma> \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from ins conf meth"], ["proof (chain)\npicking this:\n  ins ! pc = MExit\n  \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C", "obtain ST LT where\n    heap_ok: \"hconf h\" and\n    tconf:   \"P,h \\<turnstile> t \\<surd>t\" and\n    \\<Phi>_pc:    \"\\<Phi> C M!pc = Some (ST,LT)\" and\n    stk: \"P,h \\<turnstile> stk [:\\<le>] ST\" and loc: \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\" and\n    pc: \"pc < size ins\" and \n    frame:   \"conf_f P h (ST,LT) ins (stk,loc,C,M,pc)\" and\n    frames:  \"conf_fs P h \\<Phi> M (size Ts) T frs\" and\n    preh:    \"preallocated h\""], ["proof (prove)\nusing this:\n  ins ! pc = MExit\n  \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>hconf h; P,h \\<turnstile> t \\<surd>t;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         P,h \\<turnstile> stk [:\\<le>] ST;\n         P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length ins;\n         conf_f P h (ST, LT) ins (stk, loc, C, M, pc);\n         conf_fs P h \\<Phi> M (length Ts) T frs; preallocated h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: sees_method_fun)"], ["proof (state)\nthis:\n  hconf h\n  P,h \\<turnstile> t \\<surd>t\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  preallocated h\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from ins wt \\<Phi>_pc"], ["proof (chain)\npicking this:\n  ins ! pc = MExit\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>", "have lST: \"length ST > 0\""], ["proof (prove)\nusing this:\n  ins ! pc = MExit\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n\ngoal (1 subgoal):\n 1. 0 < length ST", "by(auto)"], ["proof (state)\nthis:\n  0 < length ST\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "proof(cases \"hd stk = Null\")"], ["proof (state)\ngoal (2 subgoals):\n 1. hd stk = Null \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "case True"], ["proof (state)\nthis:\n  hd stk = Null\n\ngoal (2 subgoals):\n 1. hd stk = Null \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n 2. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with ins no_x heap_ok tconf \\<Phi>_pc stk loc frame frames meth wf_preallocatedD[OF wf, of h NullPointer] preh"], ["proof (chain)\npicking this:\n  ins ! pc = MExit\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  hconf h\n  P,h \\<turnstile> t \\<surd>t\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<lbrakk>preallocated h; NullPointer \\<in> sys_xcpts\\<rbrakk>\n  \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt NullPointer) =\n                    \\<lfloor>Class_type NullPointer\\<rfloor> \\<and>\n                    P \\<turnstile> NullPointer \\<preceq>\\<^sup>* Throwable\n  preallocated h\n  hd stk = Null", "show ?thesis"], ["proof (prove)\nusing this:\n  ins ! pc = MExit\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  hconf h\n  P,h \\<turnstile> t \\<surd>t\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<lbrakk>preallocated h; NullPointer \\<in> sys_xcpts\\<rbrakk>\n  \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt NullPointer) =\n                    \\<lfloor>Class_type NullPointer\\<rfloor> \\<and>\n                    P \\<turnstile> NullPointer \\<preceq>\\<^sup>* Throwable\n  preallocated h\n  hd stk = Null\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "by(fastforce)"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "case False"], ["proof (state)\nthis:\n  hd stk \\<noteq> Null\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "note stkNN = this"], ["proof (state)\nthis:\n  hd stk \\<noteq> Null\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "have STNN: \"hd ST \\<noteq> NT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd ST \\<noteq> NT", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. hd ST = NT \\<Longrightarrow> False", "assume \"hd ST = NT\""], ["proof (state)\nthis:\n  hd ST = NT\n\ngoal (1 subgoal):\n 1. hd ST = NT \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  hd ST = NT\n\ngoal (1 subgoal):\n 1. hd ST = NT \\<Longrightarrow> False", "from frame"], ["proof (chain)\npicking this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)", "have \"P,h \\<turnstile> stk [:\\<le>] ST\""], ["proof (prove)\nusing this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> stk [:\\<le>] ST", "by simp"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. hd ST = NT \\<Longrightarrow> False", "with lST"], ["proof (chain)\npicking this:\n  0 < length ST\n  P,h \\<turnstile> stk [:\\<le>] ST", "have \"P,h \\<turnstile> hd stk :\\<le> hd ST\""], ["proof (prove)\nusing this:\n  0 < length ST\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> hd stk :\\<le> hd ST", "by (cases ST, auto)"], ["proof (state)\nthis:\n  P,h \\<turnstile> hd stk :\\<le> hd ST\n\ngoal (1 subgoal):\n 1. hd ST = NT \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  hd ST = NT\n  P,h \\<turnstile> hd stk :\\<le> hd ST", "have \"hd stk = Null\""], ["proof (prove)\nusing this:\n  hd ST = NT\n  P,h \\<turnstile> hd stk :\\<le> hd ST\n\ngoal (1 subgoal):\n 1. hd stk = Null", "by simp"], ["proof (state)\nthis:\n  hd stk = Null\n\ngoal (1 subgoal):\n 1. hd ST = NT \\<Longrightarrow> False", "with stkNN"], ["proof (chain)\npicking this:\n  hd stk \\<noteq> Null\n  hd stk = Null", "show False"], ["proof (prove)\nusing this:\n  hd stk \\<noteq> Null\n  hd stk = Null\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hd ST \\<noteq> NT\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "with stkNN ins \\<Phi>_pc wt"], ["proof (chain)\npicking this:\n  hd stk \\<noteq> Null\n  ins ! pc = MExit\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  hd ST \\<noteq> NT", "obtain ST'' X ST' LT' where \n      ST: \"ST = X # ST''\" and\n      refT: \"is_refT X\" and\n      pc': \"pc+1 < size ins\"  and\n      \\<Phi>': \"\\<Phi> C M ! (pc+1) = Some (ST', LT')\" and\n      ST': \"P \\<turnstile> ST'' [\\<le>] ST'\" and LT': \"P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\" and\n      suc_pc:     \"pc+1 < size ins\""], ["proof (prove)\nusing this:\n  hd stk \\<noteq> Null\n  ins ! pc = MExit\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  hd ST \\<noteq> NT\n\ngoal (1 subgoal):\n 1. (\\<And>X ST'' ST' LT'.\n        \\<lbrakk>ST = X # ST''; is_refT X; pc + 1 < length ins;\n         \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>;\n         P \\<turnstile> ST'' [\\<le>] ST';\n         P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT';\n         pc + 1 < length ins\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce)"], ["proof (state)\nthis:\n  ST = X # ST''\n  is_refT X\n  pc + 1 < length ins\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> ST'' [\\<le>] ST'\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n  pc + 1 < length ins\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from stk ST"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = X # ST''", "obtain ref stk' where \n      stk': \"stk = ref#stk'\" and\n      ref:  \"P,h \\<turnstile> ref :\\<le> X\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = X # ST''\n\ngoal (1 subgoal):\n 1. (\\<And>ref stk'.\n        \\<lbrakk>stk = ref # stk'; P,h \\<turnstile> ref :\\<le> X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  stk = ref # stk'\n  P,h \\<turnstile> ref :\\<le> X\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from stkNN stk'"], ["proof (chain)\npicking this:\n  hd stk \\<noteq> Null\n  stk = ref # stk'", "have \"ref \\<noteq> Null\""], ["proof (prove)\nusing this:\n  hd stk \\<noteq> Null\n  stk = ref # stk'\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null", "by(simp)"], ["proof (state)\nthis:\n  ref \\<noteq> Null\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "moreover"], ["proof (state)\nthis:\n  ref \\<noteq> Null\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from loc LT'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'", "have \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "moreover"], ["proof (state)\nthis:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "from ST stk stk' ST'"], ["proof (chain)\npicking this:\n  ST = X # ST''\n  P,h \\<turnstile> stk [:\\<le>] ST\n  stk = ref # stk'\n  P \\<turnstile> ST'' [\\<le>] ST'", "have \"P,h \\<turnstile> stk' [:\\<le>] ST'\""], ["proof (prove)\nusing this:\n  ST = X # ST''\n  P,h \\<turnstile> stk [:\\<le>] ST\n  stk = ref # stk'\n  P \\<turnstile> ST'' [\\<le>] ST'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> stk' [:\\<le>] ST'", "by(auto)"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. hd stk \\<noteq> Null \\<Longrightarrow>\n    \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "ultimately"], ["proof (chain)\npicking this:\n  ref \\<noteq> Null\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  P,h \\<turnstile> stk' [:\\<le>] ST'", "show ?thesis"], ["proof (prove)\nusing this:\n  ref \\<noteq> Null\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "using meth \\<Phi>' heap_ok \\<Phi>_pc suc_pc frames loc LT' no_x ins stk' ST' tconf frame preh\n      wf_preallocatedD[OF wf, of h IllegalMonitorState]"], ["proof (prove)\nusing this:\n  ref \\<noteq> Null\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  ins, xt)\\<rfloor> in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  hconf h\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  pc + 1 < length ins\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n  (tas, \\<sigma>) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  ins ! pc = MExit\n  stk = ref # stk'\n  P \\<turnstile> ST'' [\\<le>] ST'\n  P,h \\<turnstile> t \\<surd>t\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  preallocated h\n  \\<lbrakk>preallocated h; IllegalMonitorState \\<in> sys_xcpts\\<rbrakk>\n  \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt IllegalMonitorState) =\n                    \\<lfloor>Class_type IllegalMonitorState\\<rfloor> \\<and>\n                    P \\<turnstile> IllegalMonitorState \\<preceq>\\<^sup>* Throwable\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>", "by(fastforce)"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The next theorem collects the results of the sections above,\n  i.e.~exception handling and the execution step for each \n  instruction. It states type safety for single step execution:\n  in welltyped programs, a conforming state is transformed\n  into another conforming state when one instruction is executed.\n\\<close>"], ["", "theorem instr_correct:\n\"\\<lbrakk> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> in C;\n  (tas, \\<sigma>') \\<in> exec P t (None, h, (stk,loc,C,M,pc)#frs); \n  \\<Phi> \\<turnstile> t: (None, h, (stk,loc,C,M,pc)#frs)\\<surd> \\<rbrakk> \n\\<Longrightarrow> \\<Phi> \\<turnstile> t: \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                     ins, xt)\\<rfloor> in C;\n     (tas, \\<sigma>') \\<in> exec P t (None, h, (stk, loc, C, M, pc) # frs);\n     \\<Phi> \\<turnstile> t:(None, h,\n                            (stk, loc, C, M, pc) # frs) \\<surd>\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply (subgoal_tac \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                     ins, xt)\\<rfloor> in C;\n     (tas, \\<sigma>') \\<in> exec P t (None, h, (stk, loc, C, M, pc) # frs);\n     \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                     ins, xt)\\<rfloor> in C;\n     (tas, \\<sigma>') \\<in> exec P t (None, h, (stk, loc, C, M, pc) # frs);\n     \\<Phi> \\<turnstile> t:(None, h,\n                            (stk, loc, C, M, pc) # frs) \\<surd>\\<rbrakk>\n    \\<Longrightarrow> P,T,mxs,length\n                               ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                     ins, xt)\\<rfloor> in C;\n     (tas, \\<sigma>') \\<in> exec P t (None, h, (stk, loc, C, M, pc) # frs);\n     \\<Phi> \\<turnstile> t:(None, h,\n                            (stk, loc, C, M, pc) # frs) \\<surd>\\<rbrakk>\n    \\<Longrightarrow> P,T,mxs,length\n                               ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n 2. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                     ins, xt)\\<rfloor> in C;\n     (tas, \\<sigma>') \\<in> exec P t (None, h, (stk, loc, C, M, pc) # frs);\n     \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply (erule wt_jvm_prog_impl_wt_instr, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                             mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n     (tas, \\<sigma>') \\<in> exec P t (None, h, (stk, loc, C, M, pc) # frs);\n     \\<Phi> \\<turnstile> t:(None, h,\n                            (stk, loc, C, M, pc) # frs) \\<surd>\\<rbrakk>\n    \\<Longrightarrow> pc < length ins\n 2. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                     ins, xt)\\<rfloor> in C;\n     (tas, \\<sigma>') \\<in> exec P t (None, h, (stk, loc, C, M, pc) # frs);\n     \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta a b.\n       \\<lbrakk>P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                                mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs;\n        P,h \\<turnstile> t \\<surd>t; hconf h; preallocated h;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = \\<lfloor>(mxsa,\n                          mxl\\<^sub>0', is, xta)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(a, b)\\<rfloor>;\n        P,h \\<turnstile> stk [:\\<le>] a;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] b; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs\\<rbrakk>\n       \\<Longrightarrow> pc < length ins\n 2. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                     ins, xt)\\<rfloor> in C;\n     (tas, \\<sigma>') \\<in> exec P t (None, h, (stk, loc, C, M, pc) # frs);\n     \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply (drule (1) sees_method_fun)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta a b.\n       \\<lbrakk>(tas, \\<sigma>')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs;\n        P,h \\<turnstile> t \\<surd>t; hconf h; preallocated h;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = \\<lfloor>(mxsa,\n                          mxl\\<^sub>0', is, xta)\\<rfloor> in C;\n        \\<Phi> C M ! pc = \\<lfloor>(a, b)\\<rfloor>;\n        P,h \\<turnstile> stk [:\\<le>] a;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] b; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        Tsa = Ts \\<and>\n        Ta = T \\<and>\n        \\<lfloor>(mxsa, mxl\\<^sub>0', is, xta)\\<rfloor> =\n        \\<lfloor>(mxs, mxl\\<^sub>0, ins, xt)\\<rfloor> \\<and>\n        C = C\\<rbrakk>\n       \\<Longrightarrow> pc < length ins\n 2. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                     ins, xt)\\<rfloor> in C;\n     (tas, \\<sigma>') \\<in> exec P t (None, h, (stk, loc, C, M, pc) # frs);\n     \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                     ins, xt)\\<rfloor> in C;\n     (tas, \\<sigma>') \\<in> exec P t (None, h, (stk, loc, C, M, pc) # frs);\n     \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply(unfold exec.simps Let_def set_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                     ins, xt)\\<rfloor> in C;\n     (tas, \\<sigma>')\n     \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n     \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply (frule wt_jvm_progD, erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply (cases \"ins ! pc\")"], ["proof (prove)\ngoal (24 subgoals):\n 1. \\<And>wt x1.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. \\<And>wt x2.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 3. \\<And>wt x3.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 4. \\<And>wt x4.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 5. \\<And>wt x5.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 6. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = ALoad\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 7. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = AStore\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 8. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = ALength\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 9. \\<And>wt x91 x92.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 10. \\<And>wt x101 x102.\n        \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n         P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                         mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n         (tas, \\<sigma>')\n         \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n         \\<Phi> \\<turnstile> t:(None, h,\n                                (stk, loc, C, M, pc) # frs) \\<surd>;\n         P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n         wf_prog wt P; ins ! pc = Putfield x101 x102\\<rbrakk>\n        \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\nA total of 24 subgoals...", "apply (rule Load_correct, assumption+, fastforce)"], ["proof (prove)\ngoal (23 subgoals):\n 1. \\<And>wt x2.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. \\<And>wt x3.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 3. \\<And>wt x4.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 4. \\<And>wt x5.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 5. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = ALoad\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 6. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = AStore\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 7. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = ALength\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 8. \\<And>wt x91 x92.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 9. \\<And>wt x101 x102.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Putfield x101 x102\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 10. \\<And>wt x111 x112.\n        \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n         P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                         mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n         (tas, \\<sigma>')\n         \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n         \\<Phi> \\<turnstile> t:(None, h,\n                                (stk, loc, C, M, pc) # frs) \\<surd>;\n         P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n         wf_prog wt P; ins ! pc = CAS x111 x112\\<rbrakk>\n        \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\nA total of 23 subgoals...", "apply (rule Store_correct, assumption+, fastforce)"], ["proof (prove)\ngoal (22 subgoals):\n 1. \\<And>wt x3.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. \\<And>wt x4.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 3. \\<And>wt x5.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 4. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = ALoad\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 5. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = AStore\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 6. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = ALength\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 7. \\<And>wt x91 x92.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 8. \\<And>wt x101 x102.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Putfield x101 x102\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 9. \\<And>wt x111 x112.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = CAS x111 x112\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 10. \\<And>wt x12.\n        \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n         P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                         mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n         (tas, \\<sigma>')\n         \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n         \\<Phi> \\<turnstile> t:(None, h,\n                                (stk, loc, C, M, pc) # frs) \\<surd>;\n         P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n         wf_prog wt P; ins ! pc = Checkcast x12\\<rbrakk>\n        \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\nA total of 22 subgoals...", "apply (rule Push_correct, assumption+, fastforce)"], ["proof (prove)\ngoal (21 subgoals):\n 1. \\<And>wt x4.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. \\<And>wt x5.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 3. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = ALoad\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 4. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = AStore\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 5. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = ALength\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 6. \\<And>wt x91 x92.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 7. \\<And>wt x101 x102.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Putfield x101 x102\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 8. \\<And>wt x111 x112.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = CAS x111 x112\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 9. \\<And>wt x12.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Checkcast x12\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 10. \\<And>wt x13.\n        \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n         P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                         mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n         (tas, \\<sigma>')\n         \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n         \\<Phi> \\<turnstile> t:(None, h,\n                                (stk, loc, C, M, pc) # frs) \\<surd>;\n         P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n         wf_prog wt P; ins ! pc = Instanceof x13\\<rbrakk>\n        \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\nA total of 21 subgoals...", "apply (rule New_correct, assumption+, fastforce)"], ["proof (prove)\ngoal (20 subgoals):\n 1. \\<And>wt x5.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = ALoad\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 3. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = AStore\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 4. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = ALength\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 5. \\<And>wt x91 x92.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 6. \\<And>wt x101 x102.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Putfield x101 x102\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 7. \\<And>wt x111 x112.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = CAS x111 x112\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 8. \\<And>wt x12.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Checkcast x12\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 9. \\<And>wt x13.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Instanceof x13\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 10. \\<And>wt x141 x142.\n        \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n         P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                         mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n         (tas, \\<sigma>')\n         \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n         \\<Phi> \\<turnstile> t:(None, h,\n                                (stk, loc, C, M, pc) # frs) \\<surd>;\n         P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n         wf_prog wt P; ins ! pc = Invoke x141 x142\\<rbrakk>\n        \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\nA total of 20 subgoals...", "apply (rule NewArray_correct, assumption+, fastforce)"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = ALoad\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = AStore\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 3. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = ALength\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 4. \\<And>wt x91 x92.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 5. \\<And>wt x101 x102.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Putfield x101 x102\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 6. \\<And>wt x111 x112.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = CAS x111 x112\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 7. \\<And>wt x12.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Checkcast x12\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 8. \\<And>wt x13.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Instanceof x13\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 9. \\<And>wt x141 x142.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Invoke x141 x142\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 10. \\<And>wt.\n        \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n         P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                         mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n         (tas, \\<sigma>')\n         \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n         \\<Phi> \\<turnstile> t:(None, h,\n                                (stk, loc, C, M, pc) # frs) \\<surd>;\n         P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n         wf_prog wt P; ins ! pc = Return\\<rbrakk>\n        \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\nA total of 19 subgoals...", "apply (rule ALoad_correct, assumption+, fastforce)"], ["proof (prove)\ngoal (18 subgoals):\n 1. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = AStore\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = ALength\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 3. \\<And>wt x91 x92.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 4. \\<And>wt x101 x102.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Putfield x101 x102\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 5. \\<And>wt x111 x112.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = CAS x111 x112\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 6. \\<And>wt x12.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Checkcast x12\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 7. \\<And>wt x13.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Instanceof x13\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 8. \\<And>wt x141 x142.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Invoke x141 x142\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 9. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 10. \\<And>wt.\n        \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n         P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                         mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n         (tas, \\<sigma>')\n         \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n         \\<Phi> \\<turnstile> t:(None, h,\n                                (stk, loc, C, M, pc) # frs) \\<surd>;\n         P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n         wf_prog wt P; ins ! pc = Pop\\<rbrakk>\n        \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\nA total of 18 subgoals...", "apply (rule AStore_correct, assumption+, fastforce)"], ["proof (prove)\ngoal (17 subgoals):\n 1. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = ALength\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. \\<And>wt x91 x92.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 3. \\<And>wt x101 x102.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Putfield x101 x102\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 4. \\<And>wt x111 x112.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = CAS x111 x112\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 5. \\<And>wt x12.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Checkcast x12\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 6. \\<And>wt x13.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Instanceof x13\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 7. \\<And>wt x141 x142.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Invoke x141 x142\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 8. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 9. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Pop\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 10. \\<And>wt.\n        \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n         P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                         mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n         (tas, \\<sigma>')\n         \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n         \\<Phi> \\<turnstile> t:(None, h,\n                                (stk, loc, C, M, pc) # frs) \\<surd>;\n         P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n         wf_prog wt P; ins ! pc = Dup\\<rbrakk>\n        \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\nA total of 17 subgoals...", "apply (rule ALength_correct, assumption+, fastforce)"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>wt x91 x92.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. \\<And>wt x101 x102.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Putfield x101 x102\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 3. \\<And>wt x111 x112.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = CAS x111 x112\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 4. \\<And>wt x12.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Checkcast x12\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 5. \\<And>wt x13.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Instanceof x13\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 6. \\<And>wt x141 x142.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Invoke x141 x142\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 7. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 8. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Pop\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 9. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Dup\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 10. \\<And>wt.\n        \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n         P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                         mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n         (tas, \\<sigma>')\n         \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n         \\<Phi> \\<turnstile> t:(None, h,\n                                (stk, loc, C, M, pc) # frs) \\<surd>;\n         P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n         wf_prog wt P; ins ! pc = Swap\\<rbrakk>\n        \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\nA total of 16 subgoals...", "apply (rule Getfield_correct, assumption+, fastforce)"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>wt x101 x102.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Putfield x101 x102\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. \\<And>wt x111 x112.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = CAS x111 x112\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 3. \\<And>wt x12.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Checkcast x12\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 4. \\<And>wt x13.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Instanceof x13\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 5. \\<And>wt x141 x142.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Invoke x141 x142\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 6. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 7. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Pop\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 8. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Dup\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 9. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Swap\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 10. \\<And>wt x19.\n        \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n         P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                         mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n         (tas, \\<sigma>')\n         \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n         \\<Phi> \\<turnstile> t:(None, h,\n                                (stk, loc, C, M, pc) # frs) \\<surd>;\n         P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n         wf_prog wt P; ins ! pc = BinOpInstr x19\\<rbrakk>\n        \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\nA total of 15 subgoals...", "apply (rule Putfield_correct, assumption+, fastforce)"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>wt x111 x112.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = CAS x111 x112\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. \\<And>wt x12.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Checkcast x12\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 3. \\<And>wt x13.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Instanceof x13\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 4. \\<And>wt x141 x142.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Invoke x141 x142\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 5. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 6. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Pop\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 7. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Dup\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 8. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Swap\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 9. \\<And>wt x19.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = BinOpInstr x19\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 10. \\<And>wt x20.\n        \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n         P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                         mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n         (tas, \\<sigma>')\n         \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n         \\<Phi> \\<turnstile> t:(None, h,\n                                (stk, loc, C, M, pc) # frs) \\<surd>;\n         P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n         wf_prog wt P; ins ! pc = Goto x20\\<rbrakk>\n        \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\nA total of 14 subgoals...", "apply (rule CAS_correct, assumption+, fastforce)"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>wt x12.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Checkcast x12\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. \\<And>wt x13.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Instanceof x13\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 3. \\<And>wt x141 x142.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Invoke x141 x142\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 4. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 5. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Pop\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 6. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Dup\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 7. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Swap\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 8. \\<And>wt x19.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = BinOpInstr x19\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 9. \\<And>wt x20.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Goto x20\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 10. \\<And>wt x21.\n        \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n         P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                         mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n         (tas, \\<sigma>')\n         \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n         \\<Phi> \\<turnstile> t:(None, h,\n                                (stk, loc, C, M, pc) # frs) \\<surd>;\n         P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n         wf_prog wt P; ins ! pc = IfFalse x21\\<rbrakk>\n        \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\nA total of 13 subgoals...", "apply (rule Checkcast_correct, assumption+, fastforce)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>wt x13.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Instanceof x13\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. \\<And>wt x141 x142.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Invoke x141 x142\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 3. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 4. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Pop\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 5. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Dup\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 6. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Swap\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 7. \\<And>wt x19.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = BinOpInstr x19\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 8. \\<And>wt x20.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Goto x20\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 9. \\<And>wt x21.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = IfFalse x21\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 10. \\<And>wt.\n        \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n         P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                         mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n         (tas, \\<sigma>')\n         \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n         \\<Phi> \\<turnstile> t:(None, h,\n                                (stk, loc, C, M, pc) # frs) \\<surd>;\n         P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n         wf_prog wt P; ins ! pc = ThrowExc\\<rbrakk>\n        \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\nA total of 12 subgoals...", "apply (rule Instanceof_correct, assumption+, fastforce)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>wt x141 x142.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Invoke x141 x142\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 3. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Pop\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 4. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Dup\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 5. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Swap\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 6. \\<And>wt x19.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = BinOpInstr x19\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 7. \\<And>wt x20.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Goto x20\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 8. \\<And>wt x21.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = IfFalse x21\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 9. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = ThrowExc\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 10. \\<And>wt.\n        \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n         P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                         mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n         (tas, \\<sigma>')\n         \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n         \\<Phi> \\<turnstile> t:(None, h,\n                                (stk, loc, C, M, pc) # frs) \\<surd>;\n         P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n         wf_prog wt P; ins ! pc = MEnter\\<rbrakk>\n        \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\nA total of 11 subgoals...", "apply (rule Invoke_correct, assumption+, fastforce)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Return\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Pop\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 3. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Dup\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 4. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Swap\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 5. \\<And>wt x19.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = BinOpInstr x19\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 6. \\<And>wt x20.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Goto x20\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 7. \\<And>wt x21.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = IfFalse x21\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 8. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = ThrowExc\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 9. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = MEnter\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 10. \\<And>wt.\n        \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n         P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                         mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n         (tas, \\<sigma>')\n         \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n         \\<Phi> \\<turnstile> t:(None, h,\n                                (stk, loc, C, M, pc) # frs) \\<surd>;\n         P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n         wf_prog wt P; ins ! pc = MExit\\<rbrakk>\n        \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply (rule Return_correct, assumption+, fastforce simp add: split_beta)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Pop\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Dup\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 3. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Swap\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 4. \\<And>wt x19.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = BinOpInstr x19\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 5. \\<And>wt x20.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Goto x20\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 6. \\<And>wt x21.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = IfFalse x21\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 7. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = ThrowExc\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 8. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = MEnter\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 9. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = MExit\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply (rule Pop_correct, assumption+, fastforce)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Dup\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Swap\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 3. \\<And>wt x19.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = BinOpInstr x19\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 4. \\<And>wt x20.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Goto x20\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 5. \\<And>wt x21.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = IfFalse x21\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 6. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = ThrowExc\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 7. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = MEnter\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 8. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = MExit\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply (rule Dup_correct, assumption+, fastforce)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Swap\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. \\<And>wt x19.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = BinOpInstr x19\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 3. \\<And>wt x20.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Goto x20\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 4. \\<And>wt x21.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = IfFalse x21\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 5. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = ThrowExc\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 6. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = MEnter\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 7. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = MExit\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply (rule Swap_correct, assumption+, fastforce)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>wt x19.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = BinOpInstr x19\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. \\<And>wt x20.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Goto x20\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 3. \\<And>wt x21.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = IfFalse x21\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 4. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = ThrowExc\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 5. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = MEnter\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 6. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = MExit\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply (rule BinOp_correct, assumption+, fastforce)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>wt x20.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = Goto x20\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. \\<And>wt x21.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = IfFalse x21\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 3. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = ThrowExc\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 4. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = MEnter\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 5. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = MExit\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply (rule Goto_correct, assumption+, fastforce)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>wt x21.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = IfFalse x21\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = ThrowExc\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 3. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = MEnter\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 4. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = MExit\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply (rule IfFalse_correct, assumption+, fastforce)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = ThrowExc\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = MEnter\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 3. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = MExit\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply (rule Throw_correct, assumption+, fastforce)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = MEnter\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = MExit\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply (rule MEnter_correct, assumption+, fastforce)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                        mxl\\<^sub>0, ins, xt)\\<rfloor> in C;\n        (tas, \\<sigma>')\n        \\<in> exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs;\n        \\<Phi> \\<turnstile> t:(None, h, (stk, loc, C, M, pc) # frs) \\<surd>;\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        wf_prog wt P; ins ! pc = MExit\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply (rule MExit_correct, assumption+, fastforce)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare defs1 [simp del]"], ["", "end"], ["", "subsection \\<open>Main\\<close>"], ["", "lemma (in JVM_conf_read) BV_correct_1 [rule_format]:\n\"\\<And>\\<sigma>. \\<lbrakk> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; \\<Phi> \\<turnstile> t: \\<sigma>\\<surd>\\<rbrakk> \\<Longrightarrow> P,t \\<turnstile> \\<sigma> -tas-jvm\\<rightarrow> \\<sigma>' \\<longrightarrow> \\<Phi> \\<turnstile> t: \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:\\<sigma> \\<surd>\\<rbrakk>\n       \\<Longrightarrow> P,t \\<turnstile> \\<sigma> -tas-jvm\\<rightarrow>\n                         \\<sigma>' \\<longrightarrow>\n                         \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply (simp only: split_tupled_all exec_1_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(a, aa, b) \\<surd>\\<rbrakk>\n       \\<Longrightarrow> (tas, \\<sigma>')\n                         \\<in> exec P t (a, aa, b) \\<longrightarrow>\n                         \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply (rename_tac xp h frs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xp h frs.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(xp, h, frs) \\<surd>\\<rbrakk>\n       \\<Longrightarrow> (tas, \\<sigma>')\n                         \\<in> exec P t (xp, h, frs) \\<longrightarrow>\n                         \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply (case_tac xp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xp h frs.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(xp, h, frs) \\<surd>; xp = None\\<rbrakk>\n       \\<Longrightarrow> (tas, \\<sigma>')\n                         \\<in> exec P t (xp, h, frs) \\<longrightarrow>\n                         \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. \\<And>xp h frs a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(xp, h, frs) \\<surd>;\n        xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (tas, \\<sigma>')\n                         \\<in> exec P t (xp, h, frs) \\<longrightarrow>\n                         \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply (case_tac frs)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xp h frs.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(xp, h, frs) \\<surd>; xp = None;\n        frs = []\\<rbrakk>\n       \\<Longrightarrow> (tas, \\<sigma>')\n                         \\<in> exec P t (xp, h, frs) \\<longrightarrow>\n                         \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. \\<And>xp h frs a list.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(xp, h, frs) \\<surd>; xp = None;\n        frs = a # list\\<rbrakk>\n       \\<Longrightarrow> (tas, \\<sigma>')\n                         \\<in> exec P t (xp, h, frs) \\<longrightarrow>\n                         \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 3. \\<And>xp h frs a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(xp, h, frs) \\<surd>;\n        xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (tas, \\<sigma>')\n                         \\<in> exec P t (xp, h, frs) \\<longrightarrow>\n                         \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xp h frs a list.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(xp, h, frs) \\<surd>; xp = None;\n        frs = a # list\\<rbrakk>\n       \\<Longrightarrow> (tas, \\<sigma>')\n                         \\<in> exec P t (xp, h, frs) \\<longrightarrow>\n                         \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. \\<And>xp h frs a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(xp, h, frs) \\<surd>;\n        xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (tas, \\<sigma>')\n                         \\<in> exec P t (xp, h, frs) \\<longrightarrow>\n                         \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply (simp only: split_tupled_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xp h frs a aa ab ac b list.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(None, h, (a, aa, ab, ac, b) # list) \\<surd>;\n        xp = None; frs = (a, aa, ab, ac, b) # list\\<rbrakk>\n       \\<Longrightarrow> (tas, \\<sigma>')\n                         \\<in> exec P t\n                                (None, h,\n                                 (a, aa, ab, ac, b) #\n                                 list) \\<longrightarrow>\n                         \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. \\<And>xp h frs a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(xp, h, frs) \\<surd>;\n        xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (tas, \\<sigma>')\n                         \\<in> exec P t (xp, h, frs) \\<longrightarrow>\n                         \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply hypsubst"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xp h frs a aa ab ac b list.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(None, h,\n                               (a, aa, ab, ac, b) # list) \\<surd>\\<rbrakk>\n       \\<Longrightarrow> (tas, \\<sigma>')\n                         \\<in> exec P t\n                                (None, h,\n                                 (a, aa, ab, ac, b) #\n                                 list) \\<longrightarrow>\n                         \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. \\<And>xp h frs a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(xp, h, frs) \\<surd>;\n        xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (tas, \\<sigma>')\n                         \\<in> exec P t (xp, h, frs) \\<longrightarrow>\n                         \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply (frule correct_state_impl_Some_method)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xp h frs a aa ab ac b list.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(None, h, (a, aa, ab, ac, b) # list) \\<surd>;\n        \\<exists>m Ts T.\n           P \\<turnstile> ab sees ac: Ts\\<rightarrow>T = \\<lfloor>m\\<rfloor> in ab\\<rbrakk>\n       \\<Longrightarrow> (tas, \\<sigma>')\n                         \\<in> exec P t\n                                (None, h,\n                                 (a, aa, ab, ac, b) #\n                                 list) \\<longrightarrow>\n                         \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. \\<And>xp h frs a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(xp, h, frs) \\<surd>;\n        xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (tas, \\<sigma>')\n                         \\<in> exec P t (xp, h, frs) \\<longrightarrow>\n                         \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xp h frs a aa ab ac b list ad ae af ba Ts T.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(None, h, (a, aa, ab, ac, b) # list) \\<surd>;\n        P \\<turnstile> ab sees ac: Ts\\<rightarrow>T = \\<lfloor>(ad, ae, af,\n                          ba)\\<rfloor> in ab;\n        (tas, \\<sigma>')\n        \\<in> exec P t (None, h, (a, aa, ab, ac, b) # list)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. \\<And>xp h frs a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(xp, h, frs) \\<surd>;\n        xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (tas, \\<sigma>')\n                         \\<in> exec P t (xp, h, frs) \\<longrightarrow>\n                         \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply (rule instr_correct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>xp h frs a aa ab ac b list ad ae af ba Ts T.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(None, h, (a, aa, ab, ac, b) # list) \\<surd>;\n        P \\<turnstile> ab sees ac: Ts\\<rightarrow>T = \\<lfloor>(ad, ae, af,\n                          ba)\\<rfloor> in ab;\n        (tas, \\<sigma>')\n        \\<in> exec P t (None, h, (a, aa, ab, ac, b) # list)\\<rbrakk>\n       \\<Longrightarrow> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n 2. \\<And>xp h frs a aa ab ac b list ad ae af ba Ts T.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(None, h, (a, aa, ab, ac, b) # list) \\<surd>;\n        P \\<turnstile> ab sees ac: Ts\\<rightarrow>T = \\<lfloor>(ad, ae, af,\n                          ba)\\<rfloor> in ab;\n        (tas, \\<sigma>')\n        \\<in> exec P t (None, h, (a, aa, ab, ac, b) # list)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> ?C13 xp h frs a aa ab ac b list ad\n   ae af ba Ts\n   T sees ?M13 xp h frs a aa ab ac b list ad ae af ba Ts\n           T: ?Ts13 xp h frs a aa ab ac b list ad ae af ba Ts\n               T\\<rightarrow>?T13 xp h frs a aa ab ac b list ad ae af ba Ts\n                              T = \\<lfloor>(?mxs13 xp h frs a aa ab ac b\n       list ad ae af ba Ts T,\n      ?mxl\\<^sub>013 xp h frs a aa ab ac b list ad ae af ba Ts T,\n      ?ins13 xp h frs a aa ab ac b list ad ae af ba Ts T,\n      ?xt13 xp h frs a aa ab ac b list ad ae af ba Ts\n       T)\\<rfloor> in ?C13 xp h frs a aa ab ac b list ad ae af ba Ts T\n 3. \\<And>xp h frs a aa ab ac b list ad ae af ba Ts T.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(None, h, (a, aa, ab, ac, b) # list) \\<surd>;\n        P \\<turnstile> ab sees ac: Ts\\<rightarrow>T = \\<lfloor>(ad, ae, af,\n                          ba)\\<rfloor> in ab;\n        (tas, \\<sigma>')\n        \\<in> exec P t (None, h, (a, aa, ab, ac, b) # list)\\<rbrakk>\n       \\<Longrightarrow> (?tas13 xp h frs a aa ab ac b list ad ae af ba Ts\n                           T,\n                          \\<sigma>')\n                         \\<in> exec P t\n                                (None,\n                                 ?h13 xp h frs a aa ab ac b list ad ae af ba\n                                  Ts T,\n                                 (?stk13 xp h frs a aa ab ac b list ad ae af\n                                   ba Ts T,\n                                  ?loc13 xp h frs a aa ab ac b list ad ae af\n                                   ba Ts T,\n                                  ?C13 xp h frs a aa ab ac b list ad ae af\n                                   ba Ts T,\n                                  ?M13 xp h frs a aa ab ac b list ad ae af\n                                   ba Ts T,\n                                  ?pc13 xp h frs a aa ab ac b list ad ae af\n                                   ba Ts T) #\n                                 ?frs13 xp h frs a aa ab ac b list ad ae af\n                                  ba Ts T)\n 4. \\<And>xp h frs a aa ab ac b list ad ae af ba Ts T.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(None, h, (a, aa, ab, ac, b) # list) \\<surd>;\n        P \\<turnstile> ab sees ac: Ts\\<rightarrow>T = \\<lfloor>(ad, ae, af,\n                          ba)\\<rfloor> in ab;\n        (tas, \\<sigma>')\n        \\<in> exec P t (None, h, (a, aa, ab, ac, b) # list)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:(None,\n          ?h13 xp h frs a aa ab ac b list ad ae af ba Ts T,\n          (?stk13 xp h frs a aa ab ac b list ad ae af ba Ts T,\n           ?loc13 xp h frs a aa ab ac b list ad ae af ba Ts T,\n           ?C13 xp h frs a aa ab ac b list ad ae af ba Ts T,\n           ?M13 xp h frs a aa ab ac b list ad ae af ba Ts T,\n           ?pc13 xp h frs a aa ab ac b list ad ae af ba Ts T) #\n          ?frs13 xp h frs a aa ab ac b list ad ae af ba Ts T) \\<surd>\n 5. \\<And>xp h frs a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(xp, h, frs) \\<surd>;\n        xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (tas, \\<sigma>')\n                         \\<in> exec P t (xp, h, frs) \\<longrightarrow>\n                         \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply assumption+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xp h frs a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(xp, h, frs) \\<surd>;\n        xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (tas, \\<sigma>')\n                         \\<in> exec P t (xp, h, frs) \\<longrightarrow>\n                         \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xp h frs a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(\\<lfloor>a\\<rfloor>, h, frs) \\<surd>;\n        (tas, \\<sigma>')\n        \\<in> exec P t (\\<lfloor>a\\<rfloor>, h, frs)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply(case_tac frs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xp h frs a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(\\<lfloor>a\\<rfloor>, h, frs) \\<surd>;\n        (tas, \\<sigma>') \\<in> exec P t (\\<lfloor>a\\<rfloor>, h, frs);\n        frs = []\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>\n 2. \\<And>xp h frs a aa list.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(\\<lfloor>a\\<rfloor>, h, frs) \\<surd>;\n        (tas, \\<sigma>') \\<in> exec P t (\\<lfloor>a\\<rfloor>, h, frs);\n        frs = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xp h frs a aa list.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(\\<lfloor>a\\<rfloor>, h, frs) \\<surd>;\n        (tas, \\<sigma>') \\<in> exec P t (\\<lfloor>a\\<rfloor>, h, frs);\n        frs = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:\\<sigma>' \\<surd>", "apply(clarsimp simp only: exec.simps set_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xp h frs a aa ab ac ad b list.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(\\<lfloor>a\\<rfloor>, h,\n                               (aa, ab, ac, ad, b) # list) \\<surd>;\n        tas = \\<lbrace>\\<rbrace>;\n        \\<sigma>' = exception_step P a h (aa, ab, ac, ad, b) list\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:exception_step P a h\n          (aa, ab, ac, ad, b) list \\<surd>", "apply(erule (1) exception_step_conform)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem (in JVM_progress) progress:\n  assumes wt: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  and cs: \"\\<Phi> \\<turnstile> t: (xcp, h, f # frs)\\<surd>\"\n  shows \"\\<exists>ta \\<sigma>'. P,t \\<turnstile> (xcp, h, f # frs) -ta-jvm\\<rightarrow> \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n       (xcp, h, f # frs) -ta-jvm\\<rightarrow> \\<sigma>'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n       (xcp, h, f # frs) -ta-jvm\\<rightarrow> \\<sigma>'", "obtain stk loc C M pc where f: \"f = (stk, loc, C, M, pc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>stk loc C M pc.\n        f = (stk, loc, C, M, pc) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases f)"], ["proof (state)\nthis:\n  f = (stk, loc, C, M, pc)\n\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n       (xcp, h, f # frs) -ta-jvm\\<rightarrow> \\<sigma>'", "with cs"], ["proof (chain)\npicking this:\n  \\<Phi> \\<turnstile> t:(xcp, h, f # frs) \\<surd>\n  f = (stk, loc, C, M, pc)", "obtain Ts T mxs mxl\\<^sub>0 \"is\" xt ST LT\n    where hconf: \"hconf h\"\n    and sees: \"P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0, is, xt)\\<rfloor> in C\"\n    and \\<Phi>_pc: \"\\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\"\n    and ST: \"P,h \\<turnstile> stk [:\\<le>] ST\"\n    and LT: \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\"\n    and pc: \"pc < length is\""], ["proof (prove)\nusing this:\n  \\<Phi> \\<turnstile> t:(xcp, h, f # frs) \\<surd>\n  f = (stk, loc, C, M, pc)\n\ngoal (1 subgoal):\n 1. (\\<And>Ts T mxs mxl\\<^sub>0 is xt ST LT.\n        \\<lbrakk>hconf h;\n         P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                         mxl\\<^sub>0, is, xt)\\<rfloor> in C;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         P,h \\<turnstile> stk [:\\<le>] ST;\n         P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT;\n         pc < length is\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: defs1)"], ["proof (state)\nthis:\n  hconf h\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  is, xt)\\<rfloor> in C\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length is\n\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n       (xcp, h, f # frs) -ta-jvm\\<rightarrow> \\<sigma>'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n       (xcp, h, f # frs) -ta-jvm\\<rightarrow> \\<sigma>'", "proof(cases xcp)"], ["proof (state)\ngoal (2 subgoals):\n 1. xcp = None \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n       (xcp, h, f # frs) -ta-jvm\\<rightarrow> \\<sigma>'\n 2. \\<And>a.\n       xcp = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n          (xcp, h, f # frs) -ta-jvm\\<rightarrow> \\<sigma>'", "case Some"], ["proof (state)\nthis:\n  xcp = \\<lfloor>a_\\<rfloor>\n\ngoal (2 subgoals):\n 1. xcp = None \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n       (xcp, h, f # frs) -ta-jvm\\<rightarrow> \\<sigma>'\n 2. \\<And>a.\n       xcp = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n          (xcp, h, f # frs) -ta-jvm\\<rightarrow> \\<sigma>'", "thus ?thesis"], ["proof (prove)\nusing this:\n  xcp = \\<lfloor>a_\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n       (xcp, h, f # frs) -ta-jvm\\<rightarrow> \\<sigma>'", "unfolding f exec_1_iff"], ["proof (prove)\nusing this:\n  xcp = \\<lfloor>a_\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # frs)", "by auto"], ["proof (state)\nthis:\n  \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n     (xcp, h, f # frs) -ta-jvm\\<rightarrow> \\<sigma>'\n\ngoal (1 subgoal):\n 1. xcp = None \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n       (xcp, h, f # frs) -ta-jvm\\<rightarrow> \\<sigma>'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xcp = None \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n       (xcp, h, f # frs) -ta-jvm\\<rightarrow> \\<sigma>'", "case [simp]: None"], ["proof (state)\nthis:\n  xcp = None\n\ngoal (1 subgoal):\n 1. xcp = None \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n       (xcp, h, f # frs) -ta-jvm\\<rightarrow> \\<sigma>'", "note [simp del] = split_paired_Ex"], ["proof (state)\nthis:\n  (\\<exists>x. ?P x) = (\\<exists>a b. ?P (a, b))\n\ngoal (1 subgoal):\n 1. xcp = None \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n       (xcp, h, f # frs) -ta-jvm\\<rightarrow> \\<sigma>'", "note [simp] = defs1 list_all2_Cons2"], ["proof (state)\nthis:\n  correct_state ?\\<Phi> ?t \\<equiv>\n  \\<lambda>(xp, h, frs).\n     P,h \\<turnstile> ?t \\<surd>t \\<and>\n     hconf h \\<and>\n     preallocated h \\<and>\n     (case frs of [] \\<Rightarrow> True\n      | f # fs \\<Rightarrow>\n          let (stk, loc, C, M, pc) = f\n          in \\<exists>Ts T mxs mxl\\<^sub>0 is xt \\<tau>.\n                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                                mxl\\<^sub>0, is, xt)\\<rfloor> in C \\<and>\n                ?\\<Phi> C M ! pc = \\<lfloor>\\<tau>\\<rfloor> \\<and>\n                conf_f P h \\<tau> is f \\<and>\n                conf_fs P h ?\\<Phi> M (length Ts) T fs \\<and>\n                conf_xcp P h xp (is ! pc))\n  conf_f ?P ?h \\<equiv>\n  \\<lambda>(ST, LT) is (stk, loc, C, M, pc).\n     ?P,?h \\<turnstile> stk [:\\<le>] ST \\<and>\n     ?P,?h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT \\<and> pc < length is\n  ?P,?T,?mxs,?mpc,?xt \\<turnstile> ?i,?pc :: ?\\<tau>s \\<equiv>\n  app ?i ?P ?mxs ?T ?pc ?mpc ?xt (?\\<tau>s ! ?pc) \\<and>\n  (\\<forall>(pc', \\<tau>')\\<in>set (eff ?i ?P ?pc ?xt (?\\<tau>s ! ?pc)).\n      ?P \\<turnstile> \\<tau>' \\<le>' ?\\<tau>s ! pc')\n  eff ?i ?P ?pc ?et ?t \\<equiv>\n  case ?t of None \\<Rightarrow> []\n  | \\<lfloor>\\<tau>\\<rfloor> \\<Rightarrow>\n      norm_eff ?i ?P ?pc \\<tau> @ xcpt_eff ?i ?P ?pc \\<tau> ?et\n  norm_eff ?i ?P ?pc ?\\<tau> \\<equiv>\n  map (\\<lambda>pc'. (pc', \\<lfloor>eff\\<^sub>i (?i, ?P, ?\\<tau>)\\<rfloor>))\n   (succs ?i ?\\<tau> ?pc)\n  app ?i ?P ?mxs ?T\\<^sub>r ?pc ?mpc ?xt ?t \\<equiv>\n  case ?t of None \\<Rightarrow> True\n  | \\<lfloor>\\<tau>\\<rfloor> \\<Rightarrow>\n      app\\<^sub>i (?i, ?P, ?pc, ?mxs, ?T\\<^sub>r, \\<tau>) \\<and>\n      xcpt_app ?i ?P ?pc ?mxs ?xt \\<tau> \\<and>\n      (\\<forall>(pc', \\<tau>')\\<in>set (eff ?i ?P ?pc ?xt ?t). pc' < ?mpc)\n  xcpt_app ?i ?P ?pc ?mxs ?xt ?\\<tau> \\<equiv>\n  \\<forall>(f, t, C, h, d)\\<in>set (relevant_entries ?P ?i ?pc ?xt).\n     (case C of None \\<Rightarrow> True\n      | \\<lfloor>C'\\<rfloor> \\<Rightarrow> is_class ?P C') \\<and>\n     d \\<le> length (fst ?\\<tau>) \\<and> d < ?mxs\n  list_all2 ?P ?xs (?y # ?ys) =\n  (\\<exists>z zs. ?xs = z # zs \\<and> ?P z ?y \\<and> list_all2 ?P zs ?ys)\n\ngoal (1 subgoal):\n 1. xcp = None \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n       (xcp, h, f # frs) -ta-jvm\\<rightarrow> \\<sigma>'", "from wt"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P", "obtain wf_md where wf: \"wf_prog wf_md P\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n\ngoal (1 subgoal):\n 1. (\\<And>wf_md.\n        wf_prog wf_md P \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: wt_jvm_progD)"], ["proof (state)\nthis:\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. xcp = None \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n       (xcp, h, f # frs) -ta-jvm\\<rightarrow> \\<sigma>'", "from wt sees pc"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  is, xt)\\<rfloor> in C\n  pc < length is", "have wt: \"P,T,mxs,size is,xt \\<turnstile> is!pc,pc :: \\<Phi> C M\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  is, xt)\\<rfloor> in C\n  pc < length is\n\ngoal (1 subgoal):\n 1. P,T,mxs,length is,xt \\<turnstile> is ! pc,pc :: \\<Phi> C M", "by(rule wt_jvm_prog_impl_wt_instr)"], ["proof (state)\nthis:\n  P,T,mxs,length is,xt \\<turnstile> is ! pc,pc :: \\<Phi> C M\n\ngoal (1 subgoal):\n 1. xcp = None \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n       (xcp, h, f # frs) -ta-jvm\\<rightarrow> \\<sigma>'", "have \"\\<exists>ta \\<sigma>'. (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "proof(cases \"is ! pc\")"], ["proof (state)\ngoal (24 subgoals):\n 1. \\<And>x1.\n       is ! pc = Load x1 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<And>x2.\n       is ! pc = Store x2 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 3. \\<And>x3.\n       is ! pc = Push x3 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 4. \\<And>x4.\n       is ! pc = New x4 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 5. \\<And>x5.\n       is ! pc = NewArray x5 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 6. is ! pc = ALoad \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 7. is ! pc = AStore \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 8. is ! pc = ALength \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 9. \\<And>x91 x92.\n       is ! pc = Getfield x91 x92 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 10. \\<And>x101 x102.\n        is ! pc = Putfield x101 x102 \\<Longrightarrow>\n        \\<exists>ta \\<sigma>'.\n           (ta, \\<sigma>')\n           \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\nA total of 24 subgoals...", "case [simp]: ALoad"], ["proof (state)\nthis:\n  is ! pc = ALoad\n\ngoal (24 subgoals):\n 1. \\<And>x1.\n       is ! pc = Load x1 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<And>x2.\n       is ! pc = Store x2 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 3. \\<And>x3.\n       is ! pc = Push x3 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 4. \\<And>x4.\n       is ! pc = New x4 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 5. \\<And>x5.\n       is ! pc = NewArray x5 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 6. is ! pc = ALoad \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 7. is ! pc = AStore \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 8. is ! pc = ALength \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 9. \\<And>x91 x92.\n       is ! pc = Getfield x91 x92 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 10. \\<And>x101 x102.\n        is ! pc = Putfield x101 x102 \\<Longrightarrow>\n        \\<exists>ta \\<sigma>'.\n           (ta, \\<sigma>')\n           \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\nA total of 24 subgoals...", "with wt \\<Phi>_pc"], ["proof (chain)\npicking this:\n  P,T,mxs,length is,xt \\<turnstile> is ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  is ! pc = ALoad", "have lST: \"length ST > 1\""], ["proof (prove)\nusing this:\n  P,T,mxs,length is,xt \\<turnstile> is ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  is ! pc = ALoad\n\ngoal (1 subgoal):\n 1. 1 < length ST", "by(auto)"], ["proof (state)\nthis:\n  1 < length ST\n\ngoal (24 subgoals):\n 1. \\<And>x1.\n       is ! pc = Load x1 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<And>x2.\n       is ! pc = Store x2 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 3. \\<And>x3.\n       is ! pc = Push x3 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 4. \\<And>x4.\n       is ! pc = New x4 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 5. \\<And>x5.\n       is ! pc = NewArray x5 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 6. is ! pc = ALoad \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 7. is ! pc = AStore \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 8. is ! pc = ALength \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 9. \\<And>x91 x92.\n       is ! pc = Getfield x91 x92 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 10. \\<And>x101 x102.\n        is ! pc = Putfield x101 x102 \\<Longrightarrow>\n        \\<exists>ta \\<sigma>'.\n           (ta, \\<sigma>')\n           \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\nA total of 24 subgoals...", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "proof(cases \"hd (tl stk) = Null\")"], ["proof (state)\ngoal (2 subgoals):\n 1. hd (tl stk) = Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. hd (tl stk) \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "case True"], ["proof (state)\nthis:\n  hd (tl stk) = Null\n\ngoal (2 subgoals):\n 1. hd (tl stk) = Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. hd (tl stk) \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "thus ?thesis"], ["proof (prove)\nusing this:\n  hd (tl stk) = Null\n\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "by simp"], ["proof (state)\nthis:\n  \\<exists>ta \\<sigma>'.\n     (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n\ngoal (1 subgoal):\n 1. hd (tl stk) \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. hd (tl stk) \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "case False"], ["proof (state)\nthis:\n  hd (tl stk) \\<noteq> Null\n\ngoal (1 subgoal):\n 1. hd (tl stk) \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "have STNN: \"hd (tl ST) \\<noteq> NT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (tl ST) \\<noteq> NT", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. hd (tl ST) = NT \\<Longrightarrow> False", "assume \"hd (tl ST) = NT\""], ["proof (state)\nthis:\n  hd (tl ST) = NT\n\ngoal (1 subgoal):\n 1. hd (tl ST) = NT \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  hd (tl ST) = NT\n\ngoal (1 subgoal):\n 1. hd (tl ST) = NT \\<Longrightarrow> False", "from ST lST"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  1 < length ST", "have \"P,h \\<turnstile> hd (tl stk) :\\<le> hd (tl ST)\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  1 < length ST\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> hd (tl stk) :\\<le> hd (tl ST)", "by (cases ST)(auto, case_tac list, auto)"], ["proof (state)\nthis:\n  P,h \\<turnstile> hd (tl stk) :\\<le> hd (tl ST)\n\ngoal (1 subgoal):\n 1. hd (tl ST) = NT \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  hd (tl ST) = NT\n  P,h \\<turnstile> hd (tl stk) :\\<le> hd (tl ST)", "have \"hd (tl stk) = Null\""], ["proof (prove)\nusing this:\n  hd (tl ST) = NT\n  P,h \\<turnstile> hd (tl stk) :\\<le> hd (tl ST)\n\ngoal (1 subgoal):\n 1. hd (tl stk) = Null", "by simp"], ["proof (state)\nthis:\n  hd (tl stk) = Null\n\ngoal (1 subgoal):\n 1. hd (tl ST) = NT \\<Longrightarrow> False", "with False"], ["proof (chain)\npicking this:\n  hd (tl stk) \\<noteq> Null\n  hd (tl stk) = Null", "show False"], ["proof (prove)\nusing this:\n  hd (tl stk) \\<noteq> Null\n  hd (tl stk) = Null\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hd (tl ST) \\<noteq> NT\n\ngoal (1 subgoal):\n 1. hd (tl stk) \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "with False \\<Phi>_pc wt"], ["proof (chain)\npicking this:\n  hd (tl stk) \\<noteq> Null\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length is,xt \\<turnstile> is ! pc,pc :: \\<Phi> C M\n  hd (tl ST) \\<noteq> NT", "obtain ST'' X where \"ST = Integer # X\\<lfloor>\\<rceil> # ST''\""], ["proof (prove)\nusing this:\n  hd (tl stk) \\<noteq> Null\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length is,xt \\<turnstile> is ! pc,pc :: \\<Phi> C M\n  hd (tl ST) \\<noteq> NT\n\ngoal (1 subgoal):\n 1. (\\<And>X ST''.\n        ST = Integer # X\\<lfloor>\\<rceil> # ST'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ST = Integer # X\\<lfloor>\\<rceil> # ST''\n\ngoal (1 subgoal):\n 1. hd (tl stk) \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "with ST"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = Integer # X\\<lfloor>\\<rceil> # ST''", "obtain ref idx stk' where stk': \"stk = idx#ref#stk'\" and idx: \"P,h \\<turnstile> idx :\\<le> Integer\" \n          and ref:  \"P,h \\<turnstile> ref :\\<le> X\\<lfloor>\\<rceil>\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = Integer # X\\<lfloor>\\<rceil> # ST''\n\ngoal (1 subgoal):\n 1. (\\<And>idx ref stk'.\n        \\<lbrakk>stk = idx # ref # stk';\n         P,h \\<turnstile> idx :\\<le> Integer;\n         P,h \\<turnstile> ref :\\<le> X\\<lfloor>\\<rceil>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto)"], ["proof (state)\nthis:\n  stk = idx # ref # stk'\n  P,h \\<turnstile> idx :\\<le> Integer\n  P,h \\<turnstile> ref :\\<le> X\\<lfloor>\\<rceil>\n\ngoal (1 subgoal):\n 1. hd (tl stk) \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "from False stk'"], ["proof (chain)\npicking this:\n  hd (tl stk) \\<noteq> Null\n  stk = idx # ref # stk'", "have \"ref \\<noteq> Null\""], ["proof (prove)\nusing this:\n  hd (tl stk) \\<noteq> Null\n  stk = idx # ref # stk'\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null", "by(simp)"], ["proof (state)\nthis:\n  ref \\<noteq> Null\n\ngoal (1 subgoal):\n 1. hd (tl stk) \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "with ref"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> ref :\\<le> X\\<lfloor>\\<rceil>\n  ref \\<noteq> Null", "obtain a Xel n where a: \"ref = Addr a\"\n          and ha: \"typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\"\n          and Xel: \"P \\<turnstile> Xel \\<le> X\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> ref :\\<le> X\\<lfloor>\\<rceil>\n  ref \\<noteq> Null\n\ngoal (1 subgoal):\n 1. (\\<And>a Xel n.\n        \\<lbrakk>ref = Addr a;\n         typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>;\n         P \\<turnstile> Xel \\<le> X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases ref)(fastforce simp add: conf_def widen_Array)+"], ["proof (state)\nthis:\n  ref = Addr a\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  P \\<turnstile> Xel \\<le> X\n\ngoal (1 subgoal):\n 1. hd (tl stk) \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "from idx"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> idx :\\<le> Integer", "obtain idxI where idxI: \"idx = Intg idxI\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> idx :\\<le> Integer\n\ngoal (1 subgoal):\n 1. (\\<And>idxI. idx = Intg idxI \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: conf_def)"], ["proof (state)\nthis:\n  idx = Intg idxI\n\ngoal (1 subgoal):\n 1. hd (tl stk) \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "proof(cases \"0 <=s idxI \\<and> sint idxI < int n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le>s idxI \\<and> sint idxI < int n \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "case True"], ["proof (state)\nthis:\n  0 \\<le>s idxI \\<and> sint idxI < int n\n\ngoal (2 subgoals):\n 1. 0 \\<le>s idxI \\<and> sint idxI < int n \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "hence si': \"0 <=s idxI\" \"sint idxI < int n\""], ["proof (prove)\nusing this:\n  0 \\<le>s idxI \\<and> sint idxI < int n\n\ngoal (1 subgoal):\n 1. 0 \\<le>s idxI &&& sint idxI < int n", "by auto"], ["proof (state)\nthis:\n  0 \\<le>s idxI\n  sint idxI < int n\n\ngoal (2 subgoals):\n 1. 0 \\<le>s idxI \\<and> sint idxI < int n \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "hence \"nat (sint idxI) < n\""], ["proof (prove)\nusing this:\n  0 \\<le>s idxI\n  sint idxI < int n\n\ngoal (1 subgoal):\n 1. nat (sint idxI) < n", "by (simp add: word_sle_eq nat_less_iff)"], ["proof (state)\nthis:\n  nat (sint idxI) < n\n\ngoal (2 subgoals):\n 1. 0 \\<le>s idxI \\<and> sint idxI < int n \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "with ha"], ["proof (chain)\npicking this:\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  nat (sint idxI) < n", "have al: \"P,h \\<turnstile> a@ACell (nat (sint idxI)) : Xel\""], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  nat (sint idxI) < n\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> a@ACell (nat (sint idxI)) : Xel", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> a@ACell (nat (sint idxI)) : Xel\n\ngoal (2 subgoals):\n 1. 0 \\<le>s idxI \\<and> sint idxI < int n \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "from heap_read_total[OF hconf this] True False ha stk' idxI a"], ["proof (chain)\npicking this:\n  \\<exists>v.\n     heap_read h a (ACell (nat (sint idxI))) v \\<and>\n     P,h \\<turnstile> v :\\<le> Xel\n  0 \\<le>s idxI \\<and> sint idxI < int n\n  hd (tl stk) \\<noteq> Null\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  stk = idx # ref # stk'\n  idx = Intg idxI\n  ref = Addr a", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>v.\n     heap_read h a (ACell (nat (sint idxI))) v \\<and>\n     P,h \\<turnstile> v :\\<le> Xel\n  0 \\<le>s idxI \\<and> sint idxI < int n\n  hd (tl stk) \\<noteq> Null\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  stk = idx # ref # stk'\n  idx = Intg idxI\n  ref = Addr a\n\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "by auto"], ["proof (state)\nthis:\n  \\<exists>ta \\<sigma>'.\n     (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n\ngoal (1 subgoal):\n 1. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "case False"], ["proof (state)\nthis:\n  \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n)\n\ngoal (1 subgoal):\n 1. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "with ha stk' idxI a"], ["proof (chain)\npicking this:\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  stk = idx # ref # stk'\n  idx = Intg idxI\n  ref = Addr a\n  \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n)", "show ?thesis"], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  stk = idx # ref # stk'\n  idx = Intg idxI\n  ref = Addr a\n  \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n)\n\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "by auto"], ["proof (state)\nthis:\n  \\<exists>ta \\<sigma>'.\n     (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ta \\<sigma>'.\n     (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ta \\<sigma>'.\n     (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n\ngoal (23 subgoals):\n 1. \\<And>x1.\n       is ! pc = Load x1 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<And>x2.\n       is ! pc = Store x2 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 3. \\<And>x3.\n       is ! pc = Push x3 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 4. \\<And>x4.\n       is ! pc = New x4 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 5. \\<And>x5.\n       is ! pc = NewArray x5 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 6. is ! pc = AStore \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 7. is ! pc = ALength \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 8. \\<And>x91 x92.\n       is ! pc = Getfield x91 x92 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 9. \\<And>x101 x102.\n       is ! pc = Putfield x101 x102 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 10. \\<And>x111 x112.\n        is ! pc = CAS x111 x112 \\<Longrightarrow>\n        \\<exists>ta \\<sigma>'.\n           (ta, \\<sigma>')\n           \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\nA total of 23 subgoals...", "next"], ["proof (state)\ngoal (23 subgoals):\n 1. \\<And>x1.\n       is ! pc = Load x1 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<And>x2.\n       is ! pc = Store x2 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 3. \\<And>x3.\n       is ! pc = Push x3 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 4. \\<And>x4.\n       is ! pc = New x4 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 5. \\<And>x5.\n       is ! pc = NewArray x5 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 6. is ! pc = AStore \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 7. is ! pc = ALength \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 8. \\<And>x91 x92.\n       is ! pc = Getfield x91 x92 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 9. \\<And>x101 x102.\n       is ! pc = Putfield x101 x102 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 10. \\<And>x111 x112.\n        is ! pc = CAS x111 x112 \\<Longrightarrow>\n        \\<exists>ta \\<sigma>'.\n           (ta, \\<sigma>')\n           \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\nA total of 23 subgoals...", "case [simp]: AStore"], ["proof (state)\nthis:\n  is ! pc = AStore\n\ngoal (23 subgoals):\n 1. \\<And>x1.\n       is ! pc = Load x1 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<And>x2.\n       is ! pc = Store x2 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 3. \\<And>x3.\n       is ! pc = Push x3 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 4. \\<And>x4.\n       is ! pc = New x4 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 5. \\<And>x5.\n       is ! pc = NewArray x5 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 6. is ! pc = AStore \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 7. is ! pc = ALength \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 8. \\<And>x91 x92.\n       is ! pc = Getfield x91 x92 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 9. \\<And>x101 x102.\n       is ! pc = Putfield x101 x102 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 10. \\<And>x111 x112.\n        is ! pc = CAS x111 x112 \\<Longrightarrow>\n        \\<exists>ta \\<sigma>'.\n           (ta, \\<sigma>')\n           \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\nA total of 23 subgoals...", "from wt \\<Phi>_pc"], ["proof (chain)\npicking this:\n  P,T,mxs,length is,xt \\<turnstile> is ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>", "have lST: \"length ST > 2\""], ["proof (prove)\nusing this:\n  P,T,mxs,length is,xt \\<turnstile> is ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n\ngoal (1 subgoal):\n 1. 2 < length ST", "by(auto)"], ["proof (state)\nthis:\n  2 < length ST\n\ngoal (23 subgoals):\n 1. \\<And>x1.\n       is ! pc = Load x1 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<And>x2.\n       is ! pc = Store x2 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 3. \\<And>x3.\n       is ! pc = Push x3 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 4. \\<And>x4.\n       is ! pc = New x4 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 5. \\<And>x5.\n       is ! pc = NewArray x5 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 6. is ! pc = AStore \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 7. is ! pc = ALength \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 8. \\<And>x91 x92.\n       is ! pc = Getfield x91 x92 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 9. \\<And>x101 x102.\n       is ! pc = Putfield x101 x102 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 10. \\<And>x111 x112.\n        is ! pc = CAS x111 x112 \\<Longrightarrow>\n        \\<exists>ta \\<sigma>'.\n           (ta, \\<sigma>')\n           \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\nA total of 23 subgoals...", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "proof(cases \"hd (tl (tl stk)) = Null\")"], ["proof (state)\ngoal (2 subgoals):\n 1. hd (tl (tl stk)) = Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. hd (tl (tl stk)) \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "case True"], ["proof (state)\nthis:\n  hd (tl (tl stk)) = Null\n\ngoal (2 subgoals):\n 1. hd (tl (tl stk)) = Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. hd (tl (tl stk)) \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "thus ?thesis"], ["proof (prove)\nusing this:\n  hd (tl (tl stk)) = Null\n\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "by(fastforce)"], ["proof (state)\nthis:\n  \\<exists>ta \\<sigma>'.\n     (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n\ngoal (1 subgoal):\n 1. hd (tl (tl stk)) \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. hd (tl (tl stk)) \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "case False"], ["proof (state)\nthis:\n  hd (tl (tl stk)) \\<noteq> Null\n\ngoal (1 subgoal):\n 1. hd (tl (tl stk)) \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "note stkNN = this"], ["proof (state)\nthis:\n  hd (tl (tl stk)) \\<noteq> Null\n\ngoal (1 subgoal):\n 1. hd (tl (tl stk)) \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "have STNN: \"hd (tl (tl ST)) \\<noteq> NT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (tl (tl ST)) \\<noteq> NT", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. hd (tl (tl ST)) = NT \\<Longrightarrow> False", "assume \"hd (tl (tl ST)) = NT\""], ["proof (state)\nthis:\n  hd (tl (tl ST)) = NT\n\ngoal (1 subgoal):\n 1. hd (tl (tl ST)) = NT \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  hd (tl (tl ST)) = NT\n\ngoal (1 subgoal):\n 1. hd (tl (tl ST)) = NT \\<Longrightarrow> False", "from ST lST"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  2 < length ST", "have \"P,h \\<turnstile> hd (tl (tl stk)) :\\<le> hd (tl (tl ST))\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  2 < length ST\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> hd (tl (tl stk)) :\\<le> hd (tl (tl ST))", "by (cases ST, auto, case_tac list, auto, case_tac lista, auto)"], ["proof (state)\nthis:\n  P,h \\<turnstile> hd (tl (tl stk)) :\\<le> hd (tl (tl ST))\n\ngoal (1 subgoal):\n 1. hd (tl (tl ST)) = NT \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  hd (tl (tl ST)) = NT\n  P,h \\<turnstile> hd (tl (tl stk)) :\\<le> hd (tl (tl ST))", "have \"hd (tl (tl stk)) = Null\""], ["proof (prove)\nusing this:\n  hd (tl (tl ST)) = NT\n  P,h \\<turnstile> hd (tl (tl stk)) :\\<le> hd (tl (tl ST))\n\ngoal (1 subgoal):\n 1. hd (tl (tl stk)) = Null", "by simp"], ["proof (state)\nthis:\n  hd (tl (tl stk)) = Null\n\ngoal (1 subgoal):\n 1. hd (tl (tl ST)) = NT \\<Longrightarrow> False", "with stkNN"], ["proof (chain)\npicking this:\n  hd (tl (tl stk)) \\<noteq> Null\n  hd (tl (tl stk)) = Null", "show False"], ["proof (prove)\nusing this:\n  hd (tl (tl stk)) \\<noteq> Null\n  hd (tl (tl stk)) = Null\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hd (tl (tl ST)) \\<noteq> NT\n\ngoal (1 subgoal):\n 1. hd (tl (tl stk)) \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "with stkNN \\<Phi>_pc wt"], ["proof (chain)\npicking this:\n  hd (tl (tl stk)) \\<noteq> Null\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length is,xt \\<turnstile> is ! pc,pc :: \\<Phi> C M\n  hd (tl (tl ST)) \\<noteq> NT", "obtain ST'' Y X\n          where \"ST = Y # Integer # X\\<lfloor>\\<rceil> # ST''\""], ["proof (prove)\nusing this:\n  hd (tl (tl stk)) \\<noteq> Null\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length is,xt \\<turnstile> is ! pc,pc :: \\<Phi> C M\n  hd (tl (tl ST)) \\<noteq> NT\n\ngoal (1 subgoal):\n 1. (\\<And>Y X ST''.\n        ST = Y # Integer # X\\<lfloor>\\<rceil> # ST'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce)"], ["proof (state)\nthis:\n  ST = Y # Integer # X\\<lfloor>\\<rceil> # ST''\n\ngoal (1 subgoal):\n 1. hd (tl (tl stk)) \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "with ST"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = Y # Integer # X\\<lfloor>\\<rceil> # ST''", "obtain ref e idx stk' where stk': \"stk = e#idx#ref#stk'\" \n          and idx: \"P,h \\<turnstile> idx :\\<le> Integer\" and ref:  \"P,h \\<turnstile> ref :\\<le> X\\<lfloor>\\<rceil>\" \n          and e: \"P,h \\<turnstile> e :\\<le> Y\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = Y # Integer # X\\<lfloor>\\<rceil> # ST''\n\ngoal (1 subgoal):\n 1. (\\<And>e idx ref stk'.\n        \\<lbrakk>stk = e # idx # ref # stk';\n         P,h \\<turnstile> idx :\\<le> Integer;\n         P,h \\<turnstile> ref :\\<le> X\\<lfloor>\\<rceil>;\n         P,h \\<turnstile> e :\\<le> Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  stk = e # idx # ref # stk'\n  P,h \\<turnstile> idx :\\<le> Integer\n  P,h \\<turnstile> ref :\\<le> X\\<lfloor>\\<rceil>\n  P,h \\<turnstile> e :\\<le> Y\n\ngoal (1 subgoal):\n 1. hd (tl (tl stk)) \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "from stkNN stk'"], ["proof (chain)\npicking this:\n  hd (tl (tl stk)) \\<noteq> Null\n  stk = e # idx # ref # stk'", "have \"ref \\<noteq> Null\""], ["proof (prove)\nusing this:\n  hd (tl (tl stk)) \\<noteq> Null\n  stk = e # idx # ref # stk'\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null", "by(simp)"], ["proof (state)\nthis:\n  ref \\<noteq> Null\n\ngoal (1 subgoal):\n 1. hd (tl (tl stk)) \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "with ref"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> ref :\\<le> X\\<lfloor>\\<rceil>\n  ref \\<noteq> Null", "obtain a Xel n where a: \"ref = Addr a\"\n          and ha: \"typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\"\n          and Xel: \"P \\<turnstile> Xel \\<le> X\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> ref :\\<le> X\\<lfloor>\\<rceil>\n  ref \\<noteq> Null\n\ngoal (1 subgoal):\n 1. (\\<And>a Xel n.\n        \\<lbrakk>ref = Addr a;\n         typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>;\n         P \\<turnstile> Xel \\<le> X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases ref)(fastforce simp add: conf_def widen_Array)+"], ["proof (state)\nthis:\n  ref = Addr a\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  P \\<turnstile> Xel \\<le> X\n\ngoal (1 subgoal):\n 1. hd (tl (tl stk)) \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "from idx"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> idx :\\<le> Integer", "obtain idxI where idxI: \"idx = Intg idxI\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> idx :\\<le> Integer\n\ngoal (1 subgoal):\n 1. (\\<And>idxI. idx = Intg idxI \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: conf_def)"], ["proof (state)\nthis:\n  idx = Intg idxI\n\ngoal (1 subgoal):\n 1. hd (tl (tl stk)) \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "proof(cases \"0 <=s idxI \\<and> sint idxI < int n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le>s idxI \\<and> sint idxI < int n \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "case True"], ["proof (state)\nthis:\n  0 \\<le>s idxI \\<and> sint idxI < int n\n\ngoal (2 subgoals):\n 1. 0 \\<le>s idxI \\<and> sint idxI < int n \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "hence si': \"0 <=s idxI\" \"sint idxI < int n\""], ["proof (prove)\nusing this:\n  0 \\<le>s idxI \\<and> sint idxI < int n\n\ngoal (1 subgoal):\n 1. 0 \\<le>s idxI &&& sint idxI < int n", "by simp_all"], ["proof (state)\nthis:\n  0 \\<le>s idxI\n  sint idxI < int n\n\ngoal (2 subgoals):\n 1. 0 \\<le>s idxI \\<and> sint idxI < int n \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "hence \"nat (sint idxI) < n\""], ["proof (prove)\nusing this:\n  0 \\<le>s idxI\n  sint idxI < int n\n\ngoal (1 subgoal):\n 1. nat (sint idxI) < n", "by (simp add: word_sle_eq nat_less_iff)"], ["proof (state)\nthis:\n  nat (sint idxI) < n\n\ngoal (2 subgoals):\n 1. 0 \\<le>s idxI \\<and> sint idxI < int n \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "with ha"], ["proof (chain)\npicking this:\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  nat (sint idxI) < n", "have adal: \"P,h \\<turnstile> a@ACell (nat (sint idxI)) : Xel\""], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  nat (sint idxI) < n\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> a@ACell (nat (sint idxI)) : Xel", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> a@ACell (nat (sint idxI)) : Xel\n\ngoal (2 subgoals):\n 1. 0 \\<le>s idxI \\<and> sint idxI < int n \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "proof(cases \"P \\<turnstile> the (typeof\\<^bsub>h\\<^esub> e) \\<le> Xel\")"], ["proof (state)\ngoal (2 subgoals):\n 1. P \\<turnstile> the (typeof\\<^bsub>h\\<^esub>\n                         e) \\<le> Xel \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<not> P \\<turnstile> the (typeof\\<^bsub>h\\<^esub>\n                                e) \\<le> Xel \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "case False"], ["proof (state)\nthis:\n  \\<not> P \\<turnstile> the (typeof\\<^bsub>h\\<^esub> e) \\<le> Xel\n\ngoal (2 subgoals):\n 1. P \\<turnstile> the (typeof\\<^bsub>h\\<^esub>\n                         e) \\<le> Xel \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<not> P \\<turnstile> the (typeof\\<^bsub>h\\<^esub>\n                                e) \\<le> Xel \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "with ha stk' idxI a"], ["proof (chain)\npicking this:\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  stk = e # idx # ref # stk'\n  idx = Intg idxI\n  ref = Addr a\n  \\<not> P \\<turnstile> the (typeof\\<^bsub>h\\<^esub> e) \\<le> Xel", "show ?thesis"], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  stk = e # idx # ref # stk'\n  idx = Intg idxI\n  ref = Addr a\n  \\<not> P \\<turnstile> the (typeof\\<^bsub>h\\<^esub> e) \\<le> Xel\n\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "by auto"], ["proof (state)\nthis:\n  \\<exists>ta \\<sigma>'.\n     (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n\ngoal (1 subgoal):\n 1. P \\<turnstile> the (typeof\\<^bsub>h\\<^esub>\n                         e) \\<le> Xel \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<turnstile> the (typeof\\<^bsub>h\\<^esub>\n                         e) \\<le> Xel \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "case True"], ["proof (state)\nthis:\n  P \\<turnstile> the (typeof\\<^bsub>h\\<^esub> e) \\<le> Xel\n\ngoal (1 subgoal):\n 1. P \\<turnstile> the (typeof\\<^bsub>h\\<^esub>\n                         e) \\<le> Xel \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "hence \"P,h \\<turnstile> e :\\<le> Xel\""], ["proof (prove)\nusing this:\n  P \\<turnstile> the (typeof\\<^bsub>h\\<^esub> e) \\<le> Xel\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> e :\\<le> Xel", "using e"], ["proof (prove)\nusing this:\n  P \\<turnstile> the (typeof\\<^bsub>h\\<^esub> e) \\<le> Xel\n  P,h \\<turnstile> e :\\<le> Y\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> e :\\<le> Xel", "by(auto simp add: conf_def)"], ["proof (state)\nthis:\n  P,h \\<turnstile> e :\\<le> Xel\n\ngoal (1 subgoal):\n 1. P \\<turnstile> the (typeof\\<^bsub>h\\<^esub>\n                         e) \\<le> Xel \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "from heap_write_total[OF hconf adal this] ha stk' idxI a"], ["proof (chain)\npicking this:\n  \\<exists>h'. heap_write h a (ACell (nat (sint idxI))) e h'\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  stk = e # idx # ref # stk'\n  idx = Intg idxI\n  ref = Addr a", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>h'. heap_write h a (ACell (nat (sint idxI))) e h'\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  stk = e # idx # ref # stk'\n  idx = Intg idxI\n  ref = Addr a\n\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "by auto"], ["proof (state)\nthis:\n  \\<exists>ta \\<sigma>'.\n     (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ta \\<sigma>'.\n     (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n\ngoal (1 subgoal):\n 1. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "case False"], ["proof (state)\nthis:\n  \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n)\n\ngoal (1 subgoal):\n 1. \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n) \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "with ha stk' idxI a"], ["proof (chain)\npicking this:\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  stk = e # idx # ref # stk'\n  idx = Intg idxI\n  ref = Addr a\n  \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n)", "show ?thesis"], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>Array_type Xel n\\<rfloor>\n  stk = e # idx # ref # stk'\n  idx = Intg idxI\n  ref = Addr a\n  \\<not> (0 \\<le>s idxI \\<and> sint idxI < int n)\n\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "by auto"], ["proof (state)\nthis:\n  \\<exists>ta \\<sigma>'.\n     (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ta \\<sigma>'.\n     (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ta \\<sigma>'.\n     (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n\ngoal (22 subgoals):\n 1. \\<And>x1.\n       is ! pc = Load x1 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<And>x2.\n       is ! pc = Store x2 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 3. \\<And>x3.\n       is ! pc = Push x3 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 4. \\<And>x4.\n       is ! pc = New x4 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 5. \\<And>x5.\n       is ! pc = NewArray x5 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 6. is ! pc = ALength \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 7. \\<And>x91 x92.\n       is ! pc = Getfield x91 x92 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 8. \\<And>x101 x102.\n       is ! pc = Putfield x101 x102 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 9. \\<And>x111 x112.\n       is ! pc = CAS x111 x112 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 10. \\<And>x12.\n        is ! pc = Checkcast x12 \\<Longrightarrow>\n        \\<exists>ta \\<sigma>'.\n           (ta, \\<sigma>')\n           \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\nA total of 22 subgoals...", "next"], ["proof (state)\ngoal (22 subgoals):\n 1. \\<And>x1.\n       is ! pc = Load x1 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<And>x2.\n       is ! pc = Store x2 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 3. \\<And>x3.\n       is ! pc = Push x3 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 4. \\<And>x4.\n       is ! pc = New x4 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 5. \\<And>x5.\n       is ! pc = NewArray x5 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 6. is ! pc = ALength \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 7. \\<And>x91 x92.\n       is ! pc = Getfield x91 x92 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 8. \\<And>x101 x102.\n       is ! pc = Putfield x101 x102 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 9. \\<And>x111 x112.\n       is ! pc = CAS x111 x112 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 10. \\<And>x12.\n        is ! pc = Checkcast x12 \\<Longrightarrow>\n        \\<exists>ta \\<sigma>'.\n           (ta, \\<sigma>')\n           \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\nA total of 22 subgoals...", "case [simp]: (Getfield F D)"], ["proof (state)\nthis:\n  is ! pc = Getfield F D\n\ngoal (22 subgoals):\n 1. \\<And>x1.\n       is ! pc = Load x1 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<And>x2.\n       is ! pc = Store x2 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 3. \\<And>x3.\n       is ! pc = Push x3 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 4. \\<And>x4.\n       is ! pc = New x4 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 5. \\<And>x5.\n       is ! pc = NewArray x5 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 6. is ! pc = ALength \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 7. \\<And>x91 x92.\n       is ! pc = Getfield x91 x92 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 8. \\<And>x101 x102.\n       is ! pc = Putfield x101 x102 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 9. \\<And>x111 x112.\n       is ! pc = CAS x111 x112 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 10. \\<And>x12.\n        is ! pc = Checkcast x12 \\<Longrightarrow>\n        \\<exists>ta \\<sigma>'.\n           (ta, \\<sigma>')\n           \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\nA total of 22 subgoals...", "from \\<Phi>_pc wt"], ["proof (chain)\npicking this:\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length is,xt \\<turnstile> is ! pc,pc :: \\<Phi> C M", "obtain oT ST'' vT fm where oT: \"P \\<turnstile> oT \\<le> Class D\" \n        and \"ST = oT # ST''\" and F: \"P \\<turnstile> D sees F:vT (fm) in D\""], ["proof (prove)\nusing this:\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length is,xt \\<turnstile> is ! pc,pc :: \\<Phi> C M\n\ngoal (1 subgoal):\n 1. (\\<And>oT ST'' vT fm.\n        \\<lbrakk>P \\<turnstile> oT \\<le> Class D; ST = oT # ST'';\n         P \\<turnstile> D sees F:vT (fm) in D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  P \\<turnstile> oT \\<le> Class D\n  ST = oT # ST''\n  P \\<turnstile> D sees F:vT (fm) in D\n\ngoal (22 subgoals):\n 1. \\<And>x1.\n       is ! pc = Load x1 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<And>x2.\n       is ! pc = Store x2 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 3. \\<And>x3.\n       is ! pc = Push x3 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 4. \\<And>x4.\n       is ! pc = New x4 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 5. \\<And>x5.\n       is ! pc = NewArray x5 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 6. is ! pc = ALength \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 7. \\<And>x91 x92.\n       is ! pc = Getfield x91 x92 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 8. \\<And>x101 x102.\n       is ! pc = Putfield x101 x102 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 9. \\<And>x111 x112.\n       is ! pc = CAS x111 x112 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 10. \\<And>x12.\n        is ! pc = Checkcast x12 \\<Longrightarrow>\n        \\<exists>ta \\<sigma>'.\n           (ta, \\<sigma>')\n           \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\nA total of 22 subgoals...", "with ST"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P \\<turnstile> oT \\<le> Class D\n  ST = oT # ST''\n  P \\<turnstile> D sees F:vT (fm) in D", "obtain ref stk' where stk': \"stk = ref#stk'\" \n        and ref:  \"P,h \\<turnstile> ref :\\<le> oT\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P \\<turnstile> oT \\<le> Class D\n  ST = oT # ST''\n  P \\<turnstile> D sees F:vT (fm) in D\n\ngoal (1 subgoal):\n 1. (\\<And>ref stk'.\n        \\<lbrakk>stk = ref # stk'; P,h \\<turnstile> ref :\\<le> oT\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  stk = ref # stk'\n  P,h \\<turnstile> ref :\\<le> oT\n\ngoal (22 subgoals):\n 1. \\<And>x1.\n       is ! pc = Load x1 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<And>x2.\n       is ! pc = Store x2 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 3. \\<And>x3.\n       is ! pc = Push x3 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 4. \\<And>x4.\n       is ! pc = New x4 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 5. \\<And>x5.\n       is ! pc = NewArray x5 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 6. is ! pc = ALength \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 7. \\<And>x91 x92.\n       is ! pc = Getfield x91 x92 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 8. \\<And>x101 x102.\n       is ! pc = Putfield x101 x102 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 9. \\<And>x111 x112.\n       is ! pc = CAS x111 x112 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 10. \\<And>x12.\n        is ! pc = Checkcast x12 \\<Longrightarrow>\n        \\<exists>ta \\<sigma>'.\n           (ta, \\<sigma>')\n           \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\nA total of 22 subgoals...", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "proof(cases \"ref = Null\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ref = Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. ref \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "case True"], ["proof (state)\nthis:\n  ref = Null\n\ngoal (2 subgoals):\n 1. ref = Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. ref \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "thus ?thesis"], ["proof (prove)\nusing this:\n  ref = Null\n\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "using stk'"], ["proof (prove)\nusing this:\n  ref = Null\n  stk = ref # stk'\n\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "by auto"], ["proof (state)\nthis:\n  \\<exists>ta \\<sigma>'.\n     (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "case False"], ["proof (state)\nthis:\n  ref \\<noteq> Null\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "from ref oT"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> ref :\\<le> oT\n  P \\<turnstile> oT \\<le> Class D", "have \"P,h \\<turnstile> ref :\\<le> Class D\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> ref :\\<le> oT\n  P \\<turnstile> oT \\<le> Class D\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> ref :\\<le> Class D", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> ref :\\<le> Class D\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "with False"], ["proof (chain)\npicking this:\n  ref \\<noteq> Null\n  P,h \\<turnstile> ref :\\<le> Class D", "obtain a U' D' where \n          a: \"ref = Addr a\" and h: \"typeof_addr h a = Some U'\"\n          and U': \"D' = class_type_of U'\" and D': \"P \\<turnstile> D' \\<preceq>\\<^sup>* D\""], ["proof (prove)\nusing this:\n  ref \\<noteq> Null\n  P,h \\<turnstile> ref :\\<le> Class D\n\ngoal (1 subgoal):\n 1. (\\<And>a U' D'.\n        \\<lbrakk>ref = Addr a; typeof_addr h a = \\<lfloor>U'\\<rfloor>;\n         D' = class_type_of U';\n         P \\<turnstile> D' \\<preceq>\\<^sup>* D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: non_npD2)"], ["proof (state)\nthis:\n  ref = Addr a\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  D' = class_type_of U'\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "from D' F"], ["proof (chain)\npicking this:\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D\n  P \\<turnstile> D sees F:vT (fm) in D", "have has_field: \"P \\<turnstile> D' has F:vT (fm) in D\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D\n  P \\<turnstile> D sees F:vT (fm) in D\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D' has F:vT (fm) in D", "by (blast intro: has_field_mono has_visible_field)"], ["proof (state)\nthis:\n  P \\<turnstile> D' has F:vT (fm) in D\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "with h"], ["proof (chain)\npicking this:\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  P \\<turnstile> D' has F:vT (fm) in D", "have \"P,h \\<turnstile> a@CField D F : vT\""], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  P \\<turnstile> D' has F:vT (fm) in D\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> a@CField D F : vT", "unfolding U'"], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  P \\<turnstile> class_type_of U' has F:vT (fm) in D\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> a@CField D F : vT", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> a@CField D F : vT\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "from heap_read_total[OF hconf this]"], ["proof (chain)\npicking this:\n  \\<exists>v.\n     heap_read h a (CField D F) v \\<and> P,h \\<turnstile> v :\\<le> vT", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>v.\n     heap_read h a (CField D F) v \\<and> P,h \\<turnstile> v :\\<le> vT\n\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "using stk' a"], ["proof (prove)\nusing this:\n  \\<exists>v.\n     heap_read h a (CField D F) v \\<and> P,h \\<turnstile> v :\\<le> vT\n  stk = ref # stk'\n  ref = Addr a\n\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "by auto"], ["proof (state)\nthis:\n  \\<exists>ta \\<sigma>'.\n     (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ta \\<sigma>'.\n     (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n\ngoal (21 subgoals):\n 1. \\<And>x1.\n       is ! pc = Load x1 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<And>x2.\n       is ! pc = Store x2 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 3. \\<And>x3.\n       is ! pc = Push x3 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 4. \\<And>x4.\n       is ! pc = New x4 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 5. \\<And>x5.\n       is ! pc = NewArray x5 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 6. is ! pc = ALength \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 7. \\<And>x101 x102.\n       is ! pc = Putfield x101 x102 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 8. \\<And>x111 x112.\n       is ! pc = CAS x111 x112 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 9. \\<And>x12.\n       is ! pc = Checkcast x12 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 10. \\<And>x13.\n        is ! pc = Instanceof x13 \\<Longrightarrow>\n        \\<exists>ta \\<sigma>'.\n           (ta, \\<sigma>')\n           \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\nA total of 21 subgoals...", "next"], ["proof (state)\ngoal (21 subgoals):\n 1. \\<And>x1.\n       is ! pc = Load x1 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<And>x2.\n       is ! pc = Store x2 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 3. \\<And>x3.\n       is ! pc = Push x3 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 4. \\<And>x4.\n       is ! pc = New x4 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 5. \\<And>x5.\n       is ! pc = NewArray x5 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 6. is ! pc = ALength \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 7. \\<And>x101 x102.\n       is ! pc = Putfield x101 x102 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 8. \\<And>x111 x112.\n       is ! pc = CAS x111 x112 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 9. \\<And>x12.\n       is ! pc = Checkcast x12 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 10. \\<And>x13.\n        is ! pc = Instanceof x13 \\<Longrightarrow>\n        \\<exists>ta \\<sigma>'.\n           (ta, \\<sigma>')\n           \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\nA total of 21 subgoals...", "case [simp]: (Putfield F D)"], ["proof (state)\nthis:\n  is ! pc = Putfield F D\n\ngoal (21 subgoals):\n 1. \\<And>x1.\n       is ! pc = Load x1 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<And>x2.\n       is ! pc = Store x2 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 3. \\<And>x3.\n       is ! pc = Push x3 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 4. \\<And>x4.\n       is ! pc = New x4 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 5. \\<And>x5.\n       is ! pc = NewArray x5 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 6. is ! pc = ALength \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 7. \\<And>x101 x102.\n       is ! pc = Putfield x101 x102 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 8. \\<And>x111 x112.\n       is ! pc = CAS x111 x112 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 9. \\<And>x12.\n       is ! pc = Checkcast x12 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 10. \\<And>x13.\n        is ! pc = Instanceof x13 \\<Longrightarrow>\n        \\<exists>ta \\<sigma>'.\n           (ta, \\<sigma>')\n           \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\nA total of 21 subgoals...", "from \\<Phi>_pc wt"], ["proof (chain)\npicking this:\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length is,xt \\<turnstile> is ! pc,pc :: \\<Phi> C M", "obtain vT vT' oT ST'' fm where \"ST = vT # oT # ST''\" \n        and field: \"P \\<turnstile> D sees F:vT' (fm) in D\"\n        and oT: \"P \\<turnstile> oT \\<le> Class D\"\n        and vT': \"P \\<turnstile> vT \\<le> vT'\""], ["proof (prove)\nusing this:\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length is,xt \\<turnstile> is ! pc,pc :: \\<Phi> C M\n\ngoal (1 subgoal):\n 1. (\\<And>vT oT ST'' vT' fm.\n        \\<lbrakk>ST = vT # oT # ST''; P \\<turnstile> D sees F:vT' (fm) in D;\n         P \\<turnstile> oT \\<le> Class D;\n         P \\<turnstile> vT \\<le> vT'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ST = vT # oT # ST''\n  P \\<turnstile> D sees F:vT' (fm) in D\n  P \\<turnstile> oT \\<le> Class D\n  P \\<turnstile> vT \\<le> vT'\n\ngoal (21 subgoals):\n 1. \\<And>x1.\n       is ! pc = Load x1 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<And>x2.\n       is ! pc = Store x2 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 3. \\<And>x3.\n       is ! pc = Push x3 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 4. \\<And>x4.\n       is ! pc = New x4 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 5. \\<And>x5.\n       is ! pc = NewArray x5 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 6. is ! pc = ALength \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 7. \\<And>x101 x102.\n       is ! pc = Putfield x101 x102 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 8. \\<And>x111 x112.\n       is ! pc = CAS x111 x112 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 9. \\<And>x12.\n       is ! pc = Checkcast x12 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 10. \\<And>x13.\n        is ! pc = Instanceof x13 \\<Longrightarrow>\n        \\<exists>ta \\<sigma>'.\n           (ta, \\<sigma>')\n           \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\nA total of 21 subgoals...", "with ST"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = vT # oT # ST''\n  P \\<turnstile> D sees F:vT' (fm) in D\n  P \\<turnstile> oT \\<le> Class D\n  P \\<turnstile> vT \\<le> vT'", "obtain v ref stk' where stk': \"stk = v#ref#stk'\" \n        and ref:  \"P,h \\<turnstile> ref :\\<le> oT\" \n        and v: \"P,h \\<turnstile> v :\\<le> vT\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = vT # oT # ST''\n  P \\<turnstile> D sees F:vT' (fm) in D\n  P \\<turnstile> oT \\<le> Class D\n  P \\<turnstile> vT \\<le> vT'\n\ngoal (1 subgoal):\n 1. (\\<And>v ref stk'.\n        \\<lbrakk>stk = v # ref # stk'; P,h \\<turnstile> ref :\\<le> oT;\n         P,h \\<turnstile> v :\\<le> vT\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  stk = v # ref # stk'\n  P,h \\<turnstile> ref :\\<le> oT\n  P,h \\<turnstile> v :\\<le> vT\n\ngoal (21 subgoals):\n 1. \\<And>x1.\n       is ! pc = Load x1 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<And>x2.\n       is ! pc = Store x2 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 3. \\<And>x3.\n       is ! pc = Push x3 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 4. \\<And>x4.\n       is ! pc = New x4 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 5. \\<And>x5.\n       is ! pc = NewArray x5 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 6. is ! pc = ALength \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 7. \\<And>x101 x102.\n       is ! pc = Putfield x101 x102 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 8. \\<And>x111 x112.\n       is ! pc = CAS x111 x112 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 9. \\<And>x12.\n       is ! pc = Checkcast x12 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 10. \\<And>x13.\n        is ! pc = Instanceof x13 \\<Longrightarrow>\n        \\<exists>ta \\<sigma>'.\n           (ta, \\<sigma>')\n           \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\nA total of 21 subgoals...", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "proof(cases \"ref = Null\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ref = Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. ref \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "case True"], ["proof (state)\nthis:\n  ref = Null\n\ngoal (2 subgoals):\n 1. ref = Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. ref \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "with stk'"], ["proof (chain)\npicking this:\n  stk = v # ref # stk'\n  ref = Null", "show ?thesis"], ["proof (prove)\nusing this:\n  stk = v # ref # stk'\n  ref = Null\n\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "by auto"], ["proof (state)\nthis:\n  \\<exists>ta \\<sigma>'.\n     (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "case False"], ["proof (state)\nthis:\n  ref \\<noteq> Null\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "from ref oT"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> ref :\\<le> oT\n  P \\<turnstile> oT \\<le> Class D", "have \"P,h \\<turnstile> ref :\\<le> Class D\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> ref :\\<le> oT\n  P \\<turnstile> oT \\<le> Class D\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> ref :\\<le> Class D", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> ref :\\<le> Class D\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "with False"], ["proof (chain)\npicking this:\n  ref \\<noteq> Null\n  P,h \\<turnstile> ref :\\<le> Class D", "obtain a U' D' where \n          a: \"ref = Addr a\" and h: \"typeof_addr h a = Some U'\" and\n          U': \"D' = class_type_of U'\" and D': \"P \\<turnstile> D' \\<preceq>\\<^sup>* D\""], ["proof (prove)\nusing this:\n  ref \\<noteq> Null\n  P,h \\<turnstile> ref :\\<le> Class D\n\ngoal (1 subgoal):\n 1. (\\<And>a U' D'.\n        \\<lbrakk>ref = Addr a; typeof_addr h a = \\<lfloor>U'\\<rfloor>;\n         D' = class_type_of U';\n         P \\<turnstile> D' \\<preceq>\\<^sup>* D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: non_npD2)"], ["proof (state)\nthis:\n  ref = Addr a\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  D' = class_type_of U'\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "from field D'"], ["proof (chain)\npicking this:\n  P \\<turnstile> D sees F:vT' (fm) in D\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D", "have has_field: \"P \\<turnstile> D' has F:vT' (fm) in D\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D sees F:vT' (fm) in D\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D' has F:vT' (fm) in D", "by (blast intro: has_field_mono has_visible_field)"], ["proof (state)\nthis:\n  P \\<turnstile> D' has F:vT' (fm) in D\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "with h"], ["proof (chain)\npicking this:\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  P \\<turnstile> D' has F:vT' (fm) in D", "have al: \"P,h \\<turnstile> a@CField D F : vT'\""], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  P \\<turnstile> D' has F:vT' (fm) in D\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> a@CField D F : vT'", "unfolding U'"], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  P \\<turnstile> class_type_of U' has F:vT' (fm) in D\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> a@CField D F : vT'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> a@CField D F : vT'\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "from v vT'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> v :\\<le> vT\n  P \\<turnstile> vT \\<le> vT'", "have \"P,h \\<turnstile> v :\\<le> vT'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> v :\\<le> vT\n  P \\<turnstile> vT \\<le> vT'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> v :\\<le> vT'", "by auto"], ["proof (state)\nthis:\n  P,h \\<turnstile> v :\\<le> vT'\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "from heap_write_total[OF hconf al this] v a stk' h"], ["proof (chain)\npicking this:\n  \\<exists>h'. heap_write h a (CField D F) v h'\n  P,h \\<turnstile> v :\\<le> vT\n  ref = Addr a\n  stk = v # ref # stk'\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>h'. heap_write h a (CField D F) v h'\n  P,h \\<turnstile> v :\\<le> vT\n  ref = Addr a\n  stk = v # ref # stk'\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "by auto"], ["proof (state)\nthis:\n  \\<exists>ta \\<sigma>'.\n     (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ta \\<sigma>'.\n     (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n\ngoal (20 subgoals):\n 1. \\<And>x1.\n       is ! pc = Load x1 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<And>x2.\n       is ! pc = Store x2 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 3. \\<And>x3.\n       is ! pc = Push x3 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 4. \\<And>x4.\n       is ! pc = New x4 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 5. \\<And>x5.\n       is ! pc = NewArray x5 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 6. is ! pc = ALength \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 7. \\<And>x111 x112.\n       is ! pc = CAS x111 x112 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 8. \\<And>x12.\n       is ! pc = Checkcast x12 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 9. \\<And>x13.\n       is ! pc = Instanceof x13 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 10. \\<And>x141 x142.\n        is ! pc = Invoke x141 x142 \\<Longrightarrow>\n        \\<exists>ta \\<sigma>'.\n           (ta, \\<sigma>')\n           \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\nA total of 20 subgoals...", "next"], ["proof (state)\ngoal (20 subgoals):\n 1. \\<And>x1.\n       is ! pc = Load x1 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<And>x2.\n       is ! pc = Store x2 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 3. \\<And>x3.\n       is ! pc = Push x3 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 4. \\<And>x4.\n       is ! pc = New x4 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 5. \\<And>x5.\n       is ! pc = NewArray x5 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 6. is ! pc = ALength \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 7. \\<And>x111 x112.\n       is ! pc = CAS x111 x112 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 8. \\<And>x12.\n       is ! pc = Checkcast x12 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 9. \\<And>x13.\n       is ! pc = Instanceof x13 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 10. \\<And>x141 x142.\n        is ! pc = Invoke x141 x142 \\<Longrightarrow>\n        \\<exists>ta \\<sigma>'.\n           (ta, \\<sigma>')\n           \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\nA total of 20 subgoals...", "case [simp]: (CAS F D)"], ["proof (state)\nthis:\n  is ! pc = CAS F D\n\ngoal (20 subgoals):\n 1. \\<And>x1.\n       is ! pc = Load x1 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<And>x2.\n       is ! pc = Store x2 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 3. \\<And>x3.\n       is ! pc = Push x3 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 4. \\<And>x4.\n       is ! pc = New x4 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 5. \\<And>x5.\n       is ! pc = NewArray x5 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 6. is ! pc = ALength \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 7. \\<And>x111 x112.\n       is ! pc = CAS x111 x112 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 8. \\<And>x12.\n       is ! pc = Checkcast x12 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 9. \\<And>x13.\n       is ! pc = Instanceof x13 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 10. \\<And>x141 x142.\n        is ! pc = Invoke x141 x142 \\<Longrightarrow>\n        \\<exists>ta \\<sigma>'.\n           (ta, \\<sigma>')\n           \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\nA total of 20 subgoals...", "from \\<Phi>_pc wt"], ["proof (chain)\npicking this:\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length is,xt \\<turnstile> is ! pc,pc :: \\<Phi> C M", "obtain T' T1 T2 T3 ST'' fm where \"ST = T3 # T2 # T1 # ST''\" \n        and field: \"P \\<turnstile> D sees F:T' (fm) in D\"\n        and oT: \"P \\<turnstile> T1 \\<le> Class D\"\n        and vT': \"P \\<turnstile> T2 \\<le> T'\" \"P \\<turnstile> T3 \\<le> T'\""], ["proof (prove)\nusing this:\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length is,xt \\<turnstile> is ! pc,pc :: \\<Phi> C M\n\ngoal (1 subgoal):\n 1. (\\<And>T3 T2 T1 ST'' T' fm.\n        \\<lbrakk>ST = T3 # T2 # T1 # ST'';\n         P \\<turnstile> D sees F:T' (fm) in D;\n         P \\<turnstile> T1 \\<le> Class D; P \\<turnstile> T2 \\<le> T';\n         P \\<turnstile> T3 \\<le> T'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ST = T3 # T2 # T1 # ST''\n  P \\<turnstile> D sees F:T' (fm) in D\n  P \\<turnstile> T1 \\<le> Class D\n  P \\<turnstile> T2 \\<le> T'\n  P \\<turnstile> T3 \\<le> T'\n\ngoal (20 subgoals):\n 1. \\<And>x1.\n       is ! pc = Load x1 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<And>x2.\n       is ! pc = Store x2 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 3. \\<And>x3.\n       is ! pc = Push x3 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 4. \\<And>x4.\n       is ! pc = New x4 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 5. \\<And>x5.\n       is ! pc = NewArray x5 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 6. is ! pc = ALength \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 7. \\<And>x111 x112.\n       is ! pc = CAS x111 x112 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 8. \\<And>x12.\n       is ! pc = Checkcast x12 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 9. \\<And>x13.\n       is ! pc = Instanceof x13 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 10. \\<And>x141 x142.\n        is ! pc = Invoke x141 x142 \\<Longrightarrow>\n        \\<exists>ta \\<sigma>'.\n           (ta, \\<sigma>')\n           \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\nA total of 20 subgoals...", "with ST"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = T3 # T2 # T1 # ST''\n  P \\<turnstile> D sees F:T' (fm) in D\n  P \\<turnstile> T1 \\<le> Class D\n  P \\<turnstile> T2 \\<le> T'\n  P \\<turnstile> T3 \\<le> T'", "obtain v v' v'' stk' where stk': \"stk = v''#v'#v#stk'\" \n        and v:  \"P,h \\<turnstile> v :\\<le> T1\" \n        and v': \"P,h \\<turnstile> v' :\\<le> T2\"\n        and v'': \"P,h \\<turnstile> v'' :\\<le> T3\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = T3 # T2 # T1 # ST''\n  P \\<turnstile> D sees F:T' (fm) in D\n  P \\<turnstile> T1 \\<le> Class D\n  P \\<turnstile> T2 \\<le> T'\n  P \\<turnstile> T3 \\<le> T'\n\ngoal (1 subgoal):\n 1. (\\<And>v'' v' v stk'.\n        \\<lbrakk>stk = v'' # v' # v # stk'; P,h \\<turnstile> v :\\<le> T1;\n         P,h \\<turnstile> v' :\\<le> T2;\n         P,h \\<turnstile> v'' :\\<le> T3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  stk = v'' # v' # v # stk'\n  P,h \\<turnstile> v :\\<le> T1\n  P,h \\<turnstile> v' :\\<le> T2\n  P,h \\<turnstile> v'' :\\<le> T3\n\ngoal (20 subgoals):\n 1. \\<And>x1.\n       is ! pc = Load x1 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<And>x2.\n       is ! pc = Store x2 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 3. \\<And>x3.\n       is ! pc = Push x3 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 4. \\<And>x4.\n       is ! pc = New x4 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 5. \\<And>x5.\n       is ! pc = NewArray x5 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 6. is ! pc = ALength \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 7. \\<And>x111 x112.\n       is ! pc = CAS x111 x112 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 8. \\<And>x12.\n       is ! pc = Checkcast x12 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 9. \\<And>x13.\n       is ! pc = Instanceof x13 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 10. \\<And>x141 x142.\n        is ! pc = Invoke x141 x142 \\<Longrightarrow>\n        \\<exists>ta \\<sigma>'.\n           (ta, \\<sigma>')\n           \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\nA total of 20 subgoals...", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "proof(cases \"v= Null\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v = Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. v \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "case True"], ["proof (state)\nthis:\n  v = Null\n\ngoal (2 subgoals):\n 1. v = Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. v \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "with stk'"], ["proof (chain)\npicking this:\n  stk = v'' # v' # v # stk'\n  v = Null", "show ?thesis"], ["proof (prove)\nusing this:\n  stk = v'' # v' # v # stk'\n  v = Null\n\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "by auto"], ["proof (state)\nthis:\n  \\<exists>ta \\<sigma>'.\n     (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "case False"], ["proof (state)\nthis:\n  v \\<noteq> Null\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "from v oT"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> v :\\<le> T1\n  P \\<turnstile> T1 \\<le> Class D", "have \"P,h \\<turnstile> v :\\<le> Class D\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> v :\\<le> T1\n  P \\<turnstile> T1 \\<le> Class D\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> v :\\<le> Class D", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> v :\\<le> Class D\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "with False"], ["proof (chain)\npicking this:\n  v \\<noteq> Null\n  P,h \\<turnstile> v :\\<le> Class D", "obtain a U' D' where \n          a: \"v = Addr a\" and h: \"typeof_addr h a = Some U'\" and\n          U': \"D' = class_type_of U'\" and D': \"P \\<turnstile> D' \\<preceq>\\<^sup>* D\""], ["proof (prove)\nusing this:\n  v \\<noteq> Null\n  P,h \\<turnstile> v :\\<le> Class D\n\ngoal (1 subgoal):\n 1. (\\<And>a U' D'.\n        \\<lbrakk>v = Addr a; typeof_addr h a = \\<lfloor>U'\\<rfloor>;\n         D' = class_type_of U';\n         P \\<turnstile> D' \\<preceq>\\<^sup>* D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: non_npD2)"], ["proof (state)\nthis:\n  v = Addr a\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  D' = class_type_of U'\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "from field D'"], ["proof (chain)\npicking this:\n  P \\<turnstile> D sees F:T' (fm) in D\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D", "have has_field: \"P \\<turnstile> D' has F:T' (fm) in D\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D sees F:T' (fm) in D\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D' has F:T' (fm) in D", "by (blast intro: has_field_mono has_visible_field)"], ["proof (state)\nthis:\n  P \\<turnstile> D' has F:T' (fm) in D\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "with h"], ["proof (chain)\npicking this:\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  P \\<turnstile> D' has F:T' (fm) in D", "have al: \"P,h \\<turnstile> a@CField D F : T'\""], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  P \\<turnstile> D' has F:T' (fm) in D\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> a@CField D F : T'", "unfolding U'"], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  P \\<turnstile> class_type_of U' has F:T' (fm) in D\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> a@CField D F : T'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> a@CField D F : T'\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "from v' vT'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> v' :\\<le> T2\n  P \\<turnstile> T2 \\<le> T'\n  P \\<turnstile> T3 \\<le> T'", "have \"P,h \\<turnstile> v' :\\<le> T'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> v' :\\<le> T2\n  P \\<turnstile> T2 \\<le> T'\n  P \\<turnstile> T3 \\<le> T'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> v' :\\<le> T'", "by auto"], ["proof (state)\nthis:\n  P,h \\<turnstile> v' :\\<le> T'\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "from heap_read_total[OF hconf al]"], ["proof (chain)\npicking this:\n  \\<exists>v.\n     heap_read h a (CField D F) v \\<and> P,h \\<turnstile> v :\\<le> T'", "obtain v''' where v''': \"heap_read h a (CField D F) v'''\""], ["proof (prove)\nusing this:\n  \\<exists>v.\n     heap_read h a (CField D F) v \\<and> P,h \\<turnstile> v :\\<le> T'\n\ngoal (1 subgoal):\n 1. (\\<And>v'''.\n        heap_read h a (CField D F) v''' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  heap_read h a (CField D F) v'''\n\ngoal (1 subgoal):\n 1. v \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "proof(cases \"v''' = v'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v''' = v' \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. v''' \\<noteq> v' \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "case True"], ["proof (state)\nthis:\n  v''' = v'\n\ngoal (2 subgoals):\n 1. v''' = v' \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. v''' \\<noteq> v' \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "from v'' vT'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> v'' :\\<le> T3\n  P \\<turnstile> T2 \\<le> T'\n  P \\<turnstile> T3 \\<le> T'", "have \"P,h \\<turnstile> v'' :\\<le> T'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> v'' :\\<le> T3\n  P \\<turnstile> T2 \\<le> T'\n  P \\<turnstile> T3 \\<le> T'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> v'' :\\<le> T'", "by auto"], ["proof (state)\nthis:\n  P,h \\<turnstile> v'' :\\<le> T'\n\ngoal (2 subgoals):\n 1. v''' = v' \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. v''' \\<noteq> v' \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "from heap_write_total[OF hconf al this] v a stk' h v''' True"], ["proof (chain)\npicking this:\n  \\<exists>h'. heap_write h a (CField D F) v'' h'\n  P,h \\<turnstile> v :\\<le> T1\n  v = Addr a\n  stk = v'' # v' # v # stk'\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  heap_read h a (CField D F) v'''\n  v''' = v'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>h'. heap_write h a (CField D F) v'' h'\n  P,h \\<turnstile> v :\\<le> T1\n  v = Addr a\n  stk = v'' # v' # v # stk'\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  heap_read h a (CField D F) v'''\n  v''' = v'\n\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "by auto"], ["proof (state)\nthis:\n  \\<exists>ta \\<sigma>'.\n     (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n\ngoal (1 subgoal):\n 1. v''' \\<noteq> v' \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v''' \\<noteq> v' \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "case False"], ["proof (state)\nthis:\n  v''' \\<noteq> v'\n\ngoal (1 subgoal):\n 1. v''' \\<noteq> v' \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "from v''' v a stk' h False"], ["proof (chain)\npicking this:\n  heap_read h a (CField D F) v'''\n  P,h \\<turnstile> v :\\<le> T1\n  v = Addr a\n  stk = v'' # v' # v # stk'\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  v''' \\<noteq> v'", "show ?thesis"], ["proof (prove)\nusing this:\n  heap_read h a (CField D F) v'''\n  P,h \\<turnstile> v :\\<le> T1\n  v = Addr a\n  stk = v'' # v' # v # stk'\n  typeof_addr h a = \\<lfloor>U'\\<rfloor>\n  v''' \\<noteq> v'\n\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "by auto"], ["proof (state)\nthis:\n  \\<exists>ta \\<sigma>'.\n     (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ta \\<sigma>'.\n     (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ta \\<sigma>'.\n     (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n\ngoal (19 subgoals):\n 1. \\<And>x1.\n       is ! pc = Load x1 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<And>x2.\n       is ! pc = Store x2 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 3. \\<And>x3.\n       is ! pc = Push x3 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 4. \\<And>x4.\n       is ! pc = New x4 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 5. \\<And>x5.\n       is ! pc = NewArray x5 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 6. is ! pc = ALength \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 7. \\<And>x12.\n       is ! pc = Checkcast x12 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 8. \\<And>x13.\n       is ! pc = Instanceof x13 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 9. \\<And>x141 x142.\n       is ! pc = Invoke x141 x142 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 10. is ! pc = Return \\<Longrightarrow>\n     \\<exists>ta \\<sigma>'.\n        (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\nA total of 19 subgoals...", "next"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>x1.\n       is ! pc = Load x1 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<And>x2.\n       is ! pc = Store x2 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 3. \\<And>x3.\n       is ! pc = Push x3 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 4. \\<And>x4.\n       is ! pc = New x4 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 5. \\<And>x5.\n       is ! pc = NewArray x5 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 6. is ! pc = ALength \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 7. \\<And>x12.\n       is ! pc = Checkcast x12 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 8. \\<And>x13.\n       is ! pc = Instanceof x13 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 9. \\<And>x141 x142.\n       is ! pc = Invoke x141 x142 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 10. is ! pc = Return \\<Longrightarrow>\n     \\<exists>ta \\<sigma>'.\n        (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\nA total of 19 subgoals...", "case [simp]: (Invoke M' n)"], ["proof (state)\nthis:\n  is ! pc = Invoke M' n\n\ngoal (19 subgoals):\n 1. \\<And>x1.\n       is ! pc = Load x1 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<And>x2.\n       is ! pc = Store x2 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 3. \\<And>x3.\n       is ! pc = Push x3 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 4. \\<And>x4.\n       is ! pc = New x4 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 5. \\<And>x5.\n       is ! pc = NewArray x5 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 6. is ! pc = ALength \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 7. \\<And>x12.\n       is ! pc = Checkcast x12 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 8. \\<And>x13.\n       is ! pc = Instanceof x13 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 9. \\<And>x141 x142.\n       is ! pc = Invoke x141 x142 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 10. is ! pc = Return \\<Longrightarrow>\n     \\<exists>ta \\<sigma>'.\n        (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\nA total of 19 subgoals...", "from wt \\<Phi>_pc"], ["proof (chain)\npicking this:\n  P,T,mxs,length is,xt \\<turnstile> is ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>", "have n: \"n < size ST\""], ["proof (prove)\nusing this:\n  P,T,mxs,length is,xt \\<turnstile> is ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n\ngoal (1 subgoal):\n 1. n < length ST", "by simp"], ["proof (state)\nthis:\n  n < length ST\n\ngoal (19 subgoals):\n 1. \\<And>x1.\n       is ! pc = Load x1 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<And>x2.\n       is ! pc = Store x2 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 3. \\<And>x3.\n       is ! pc = Push x3 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 4. \\<And>x4.\n       is ! pc = New x4 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 5. \\<And>x5.\n       is ! pc = NewArray x5 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 6. is ! pc = ALength \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 7. \\<And>x12.\n       is ! pc = Checkcast x12 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 8. \\<And>x13.\n       is ! pc = Instanceof x13 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 9. \\<And>x141 x142.\n       is ! pc = Invoke x141 x142 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 10. is ! pc = Return \\<Longrightarrow>\n     \\<exists>ta \\<sigma>'.\n        (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\nA total of 19 subgoals...", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "proof(cases \"stk!n = Null\")"], ["proof (state)\ngoal (2 subgoals):\n 1. stk ! n = Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "case True"], ["proof (state)\nthis:\n  stk ! n = Null\n\ngoal (2 subgoals):\n 1. stk ! n = Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "thus ?thesis"], ["proof (prove)\nusing this:\n  stk ! n = Null\n\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "by simp"], ["proof (state)\nthis:\n  \\<exists>ta \\<sigma>'.\n     (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "case False"], ["proof (state)\nthis:\n  stk ! n \\<noteq> Null\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "note Null = this"], ["proof (state)\nthis:\n  stk ! n \\<noteq> Null\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "have NT: \"ST!n \\<noteq> NT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ST ! n \\<noteq> NT", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ST ! n = NT \\<Longrightarrow> False", "assume \"ST!n = NT\""], ["proof (state)\nthis:\n  ST ! n = NT\n\ngoal (1 subgoal):\n 1. ST ! n = NT \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  ST ! n = NT\n\ngoal (1 subgoal):\n 1. ST ! n = NT \\<Longrightarrow> False", "from ST n"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  n < length ST", "have \"P,h \\<turnstile> stk!n :\\<le> ST!n\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  n < length ST\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> stk ! n :\\<le> ST ! n", "by (simp add: list_all2_conv_all_nth)"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk ! n :\\<le> ST ! n\n\ngoal (1 subgoal):\n 1. ST ! n = NT \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  ST ! n = NT\n  P,h \\<turnstile> stk ! n :\\<le> ST ! n", "have \"stk!n = Null\""], ["proof (prove)\nusing this:\n  ST ! n = NT\n  P,h \\<turnstile> stk ! n :\\<le> ST ! n\n\ngoal (1 subgoal):\n 1. stk ! n = Null", "by simp"], ["proof (state)\nthis:\n  stk ! n = Null\n\ngoal (1 subgoal):\n 1. ST ! n = NT \\<Longrightarrow> False", "with Null"], ["proof (chain)\npicking this:\n  stk ! n \\<noteq> Null\n  stk ! n = Null", "show False"], ["proof (prove)\nusing this:\n  stk ! n \\<noteq> Null\n  stk ! n = Null\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ST ! n \\<noteq> NT\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "from NT wt \\<Phi>_pc"], ["proof (chain)\npicking this:\n  ST ! n \\<noteq> NT\n  P,T,mxs,length is,xt \\<turnstile> is ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>", "obtain D D' Ts T m\n          where D: \"class_type_of' (ST!n) = Some D\"\n          and m_D: \"P \\<turnstile> D sees M': Ts\\<rightarrow>T = m in D'\"\n          and Ts:  \"P \\<turnstile> rev (take n ST) [\\<le>] Ts\""], ["proof (prove)\nusing this:\n  ST ! n \\<noteq> NT\n  P,T,mxs,length is,xt \\<turnstile> is ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>D Ts T m D'.\n        \\<lbrakk>class_type_of' (ST ! n) = \\<lfloor>D\\<rfloor>;\n         P \\<turnstile> D sees M': Ts\\<rightarrow>T = m in D';\n         P \\<turnstile> rev (take n ST) [\\<le>] Ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  class_type_of' (ST ! n) = \\<lfloor>D\\<rfloor>\n  P \\<turnstile> D sees M': Ts\\<rightarrow>T = m in D'\n  P \\<turnstile> rev (take n ST) [\\<le>] Ts\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "from n ST D"], ["proof (chain)\npicking this:\n  n < length ST\n  P,h \\<turnstile> stk [:\\<le>] ST\n  class_type_of' (ST ! n) = \\<lfloor>D\\<rfloor>", "have \"P,h \\<turnstile> stk!n :\\<le> ST!n\""], ["proof (prove)\nusing this:\n  n < length ST\n  P,h \\<turnstile> stk [:\\<le>] ST\n  class_type_of' (ST ! n) = \\<lfloor>D\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> stk ! n :\\<le> ST ! n", "by (auto simp add: list_all2_conv_all_nth)"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk ! n :\\<le> ST ! n\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "from \\<open>P,h \\<turnstile> stk!n :\\<le> ST!n\\<close> Null D"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk ! n :\\<le> ST ! n\n  stk ! n \\<noteq> Null\n  class_type_of' (ST ! n) = \\<lfloor>D\\<rfloor>", "obtain a T' where\n          Addr:   \"stk!n = Addr a\" and\n          obj:    \"typeof_addr h a = Some T'\" and\n          T'subSTn: \"P \\<turnstile> ty_of_htype T' \\<le> ST ! n\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk ! n :\\<le> ST ! n\n  stk ! n \\<noteq> Null\n  class_type_of' (ST ! n) = \\<lfloor>D\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>a T'.\n        \\<lbrakk>stk ! n = Addr a; typeof_addr h a = \\<lfloor>T'\\<rfloor>;\n         P \\<turnstile> ty_of_htype T' \\<le> ST ! n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \"stk ! n\")(auto simp add: conf_def widen_Class)"], ["proof (state)\nthis:\n  stk ! n = Addr a\n  typeof_addr h a = \\<lfloor>T'\\<rfloor>\n  P \\<turnstile> ty_of_htype T' \\<le> ST ! n\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "from D T'subSTn"], ["proof (chain)\npicking this:\n  class_type_of' (ST ! n) = \\<lfloor>D\\<rfloor>\n  P \\<turnstile> ty_of_htype T' \\<le> ST ! n", "obtain C' where\n          C': \"class_type_of' (ty_of_htype T') = \\<lfloor>C'\\<rfloor>\" and C'subD: \"P \\<turnstile> C' \\<preceq>\\<^sup>* D\""], ["proof (prove)\nusing this:\n  class_type_of' (ST ! n) = \\<lfloor>D\\<rfloor>\n  P \\<turnstile> ty_of_htype T' \\<le> ST ! n\n\ngoal (1 subgoal):\n 1. (\\<And>C'.\n        \\<lbrakk>class_type_of' (ty_of_htype T') = \\<lfloor>C'\\<rfloor>;\n         P \\<turnstile> C' \\<preceq>\\<^sup>* D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule widen_is_class_type_of) simp"], ["proof (state)\nthis:\n  class_type_of' (ty_of_htype T') = \\<lfloor>C'\\<rfloor>\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "from Call_lemma[OF m_D C'subD wf]"], ["proof (chain)\npicking this:\n  \\<exists>D' Ts' T' m'.\n     P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = m' in D' \\<and>\n     P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n     P \\<turnstile> T' \\<le> T \\<and>\n     P \\<turnstile> C' \\<preceq>\\<^sup>* D' \\<and>\n     is_type P T' \\<and>\n     (\\<forall>T\\<in>set Ts'. is_type P T) \\<and>\n     (m' \\<noteq> None \\<longrightarrow> wf_md P D' (M', Ts', T', the m'))", "obtain D' Ts' T' m' \n          where Call': \"P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = m' in D'\" \"P \\<turnstile> Ts [\\<le>] Ts'\"\n            \"P \\<turnstile> T' \\<le> T\" \"P \\<turnstile> C' \\<preceq>\\<^sup>* D'\" \"is_type P T'\" \"\\<forall>T\\<in>set Ts'. is_type P T\""], ["proof (prove)\nusing this:\n  \\<exists>D' Ts' T' m'.\n     P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = m' in D' \\<and>\n     P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n     P \\<turnstile> T' \\<le> T \\<and>\n     P \\<turnstile> C' \\<preceq>\\<^sup>* D' \\<and>\n     is_type P T' \\<and>\n     (\\<forall>T\\<in>set Ts'. is_type P T) \\<and>\n     (m' \\<noteq> None \\<longrightarrow> wf_md P D' (M', Ts', T', the m'))\n\ngoal (1 subgoal):\n 1. (\\<And>Ts' T' m' D'.\n        \\<lbrakk>P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = m' in D';\n         P \\<turnstile> Ts [\\<le>] Ts'; P \\<turnstile> T' \\<le> T;\n         P \\<turnstile> C' \\<preceq>\\<^sup>* D'; is_type P T';\n         \\<forall>T\\<in>set Ts'. is_type P T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = m' in D'\n  P \\<turnstile> Ts [\\<le>] Ts'\n  P \\<turnstile> T' \\<le> T\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D'\n  is_type P T'\n  \\<forall>T\\<in>set Ts'. is_type P T\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "proof(cases m')"], ["proof (state)\ngoal (2 subgoals):\n 1. m' = None \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<And>a.\n       m' = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "case Some"], ["proof (state)\nthis:\n  m' = \\<lfloor>a_\\<rfloor>\n\ngoal (2 subgoals):\n 1. m' = None \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<And>a.\n       m' = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "with Call' C' obj Addr C' C'subD"], ["proof (chain)\npicking this:\n  P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = m' in D'\n  P \\<turnstile> Ts [\\<le>] Ts'\n  P \\<turnstile> T' \\<le> T\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D'\n  is_type P T'\n  \\<forall>T\\<in>set Ts'. is_type P T\n  class_type_of' (ty_of_htype T'__) = \\<lfloor>C'\\<rfloor>\n  typeof_addr h a = \\<lfloor>T'__\\<rfloor>\n  stk ! n = Addr a\n  class_type_of' (ty_of_htype T'__) = \\<lfloor>C'\\<rfloor>\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D\n  m' = \\<lfloor>a_\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = m' in D'\n  P \\<turnstile> Ts [\\<le>] Ts'\n  P \\<turnstile> T' \\<le> T\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D'\n  is_type P T'\n  \\<forall>T\\<in>set Ts'. is_type P T\n  class_type_of' (ty_of_htype T'__) = \\<lfloor>C'\\<rfloor>\n  typeof_addr h a = \\<lfloor>T'__\\<rfloor>\n  stk ! n = Addr a\n  class_type_of' (ty_of_htype T'__) = \\<lfloor>C'\\<rfloor>\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D\n  m' = \\<lfloor>a_\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "by(auto)"], ["proof (state)\nthis:\n  \\<exists>ta \\<sigma>'.\n     (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n\ngoal (1 subgoal):\n 1. m' = None \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. m' = None \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "case [simp]: None"], ["proof (state)\nthis:\n  m' = None\n\ngoal (1 subgoal):\n 1. m' = None \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "from ST"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST", "have \"P,h \\<turnstile> take n stk [:\\<le>] take n ST\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> take n stk [:\\<le>] take n ST", "by(rule list_all2_takeI)"], ["proof (state)\nthis:\n  P,h \\<turnstile> take n stk [:\\<le>] take n ST\n\ngoal (1 subgoal):\n 1. m' = None \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "then"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> take n stk [:\\<le>] take n ST", "obtain Us where \"map typeof\\<^bsub>h\\<^esub> (take n stk) = map Some Us\" \"P \\<turnstile> Us [\\<le>] take n ST\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> take n stk [:\\<le>] take n ST\n\ngoal (1 subgoal):\n 1. (\\<And>Us.\n        \\<lbrakk>map typeof\\<^bsub>h\\<^esub> (take n stk) = map Some Us;\n         P \\<turnstile> Us [\\<le>] take n ST\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: confs_conv_map)"], ["proof (state)\nthis:\n  map typeof\\<^bsub>h\\<^esub> (take n stk) = map Some Us\n  P \\<turnstile> Us [\\<le>] take n ST\n\ngoal (1 subgoal):\n 1. m' = None \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "hence Us: \"map typeof\\<^bsub>h\\<^esub> (rev (take n stk)) = map Some (rev Us)\" \"P \\<turnstile> rev Us [\\<le>] rev (take n ST)\""], ["proof (prove)\nusing this:\n  map typeof\\<^bsub>h\\<^esub> (take n stk) = map Some Us\n  P \\<turnstile> Us [\\<le>] take n ST\n\ngoal (1 subgoal):\n 1. map typeof\\<^bsub>h\\<^esub> (rev (take n stk)) = map Some (rev Us) &&&\n    P \\<turnstile> rev Us [\\<le>] rev (take n ST)", "by- (simp only: rev_map[symmetric], simp)"], ["proof (state)\nthis:\n  map typeof\\<^bsub>h\\<^esub> (rev (take n stk)) = map Some (rev Us)\n  P \\<turnstile> rev Us [\\<le>] rev (take n ST)\n\ngoal (1 subgoal):\n 1. m' = None \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "with Ts \\<open>P \\<turnstile> Ts [\\<le>] Ts'\\<close>"], ["proof (chain)\npicking this:\n  P \\<turnstile> rev (take n ST) [\\<le>] Ts\n  P \\<turnstile> Ts [\\<le>] Ts'\n  map typeof\\<^bsub>h\\<^esub> (rev (take n stk)) = map Some (rev Us)\n  P \\<turnstile> rev Us [\\<le>] rev (take n ST)", "have \"P \\<turnstile> rev Us [\\<le>] Ts'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> rev (take n ST) [\\<le>] Ts\n  P \\<turnstile> Ts [\\<le>] Ts'\n  map typeof\\<^bsub>h\\<^esub> (rev (take n stk)) = map Some (rev Us)\n  P \\<turnstile> rev Us [\\<le>] rev (take n ST)\n\ngoal (1 subgoal):\n 1. P \\<turnstile> rev Us [\\<le>] Ts'", "by(blast intro: widens_trans)"], ["proof (state)\nthis:\n  P \\<turnstile> rev Us [\\<le>] Ts'\n\ngoal (1 subgoal):\n 1. m' = None \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "with obj Us Call' C'"], ["proof (chain)\npicking this:\n  typeof_addr h a = \\<lfloor>T'__\\<rfloor>\n  map typeof\\<^bsub>h\\<^esub> (rev (take n stk)) = map Some (rev Us)\n  P \\<turnstile> rev Us [\\<le>] rev (take n ST)\n  P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = m' in D'\n  P \\<turnstile> Ts [\\<le>] Ts'\n  P \\<turnstile> T' \\<le> T\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D'\n  is_type P T'\n  \\<forall>T\\<in>set Ts'. is_type P T\n  class_type_of' (ty_of_htype T'__) = \\<lfloor>C'\\<rfloor>\n  P \\<turnstile> rev Us [\\<le>] Ts'", "have \"P,h \\<turnstile> a\\<bullet>M'(rev (take n stk)) : T'\""], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>T'__\\<rfloor>\n  map typeof\\<^bsub>h\\<^esub> (rev (take n stk)) = map Some (rev Us)\n  P \\<turnstile> rev Us [\\<le>] rev (take n ST)\n  P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = m' in D'\n  P \\<turnstile> Ts [\\<le>] Ts'\n  P \\<turnstile> T' \\<le> T\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D'\n  is_type P T'\n  \\<forall>T\\<in>set Ts'. is_type P T\n  class_type_of' (ty_of_htype T'__) = \\<lfloor>C'\\<rfloor>\n  P \\<turnstile> rev Us [\\<le>] Ts'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> a\\<bullet>M'(rev (take n stk)) : T'", "by(auto intro!: external_WT'.intros)"], ["proof (state)\nthis:\n  P,h \\<turnstile> a\\<bullet>M'(rev (take n stk)) : T'\n\ngoal (1 subgoal):\n 1. m' = None \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "from external_call_progress[OF wf this hconf, of t] obj Addr Call' C'"], ["proof (chain)\npicking this:\n  \\<exists>ta va h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M'(rev (take n stk)),\n                      h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n  typeof_addr h a = \\<lfloor>T'__\\<rfloor>\n  stk ! n = Addr a\n  P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = m' in D'\n  P \\<turnstile> Ts [\\<le>] Ts'\n  P \\<turnstile> T' \\<le> T\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D'\n  is_type P T'\n  \\<forall>T\\<in>set Ts'. is_type P T\n  class_type_of' (ty_of_htype T'__) = \\<lfloor>C'\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>ta va h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M'(rev (take n stk)),\n                      h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n  typeof_addr h a = \\<lfloor>T'__\\<rfloor>\n  stk ! n = Addr a\n  P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = m' in D'\n  P \\<turnstile> Ts [\\<le>] Ts'\n  P \\<turnstile> T' \\<le> T\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D'\n  is_type P T'\n  \\<forall>T\\<in>set Ts'. is_type P T\n  class_type_of' (ty_of_htype T'__) = \\<lfloor>C'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs", "by(auto dest!: red_external_imp_red_external_aggr)"], ["proof (state)\nthis:\n  \\<exists>ta \\<sigma>'.\n     (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ta \\<sigma>'.\n     (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ta \\<sigma>'.\n     (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n\ngoal (18 subgoals):\n 1. \\<And>x1.\n       is ! pc = Load x1 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 2. \\<And>x2.\n       is ! pc = Store x2 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 3. \\<And>x3.\n       is ! pc = Push x3 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 4. \\<And>x4.\n       is ! pc = New x4 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 5. \\<And>x5.\n       is ! pc = NewArray x5 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 6. is ! pc = ALength \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 7. \\<And>x12.\n       is ! pc = Checkcast x12 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 8. \\<And>x13.\n       is ! pc = Instanceof x13 \\<Longrightarrow>\n       \\<exists>ta \\<sigma>'.\n          (ta, \\<sigma>')\n          \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 9. is ! pc = Return \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n 10. is ! pc = Pop \\<Longrightarrow>\n     \\<exists>ta \\<sigma>'.\n        (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\nA total of 18 subgoals...", "qed(auto 4 4 simp add: split_beta split: if_split_asm)"], ["proof (state)\nthis:\n  \\<exists>ta \\<sigma>'.\n     (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n\ngoal (1 subgoal):\n 1. xcp = None \\<Longrightarrow>\n    \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n       (xcp, h, f # frs) -ta-jvm\\<rightarrow> \\<sigma>'", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>ta \\<sigma>'.\n     (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n       (xcp, h, f # frs) -ta-jvm\\<rightarrow> \\<sigma>'", "using sees None"], ["proof (prove)\nusing this:\n  \\<exists>ta \\<sigma>'.\n     (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  is, xt)\\<rfloor> in C\n  xcp = None\n\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n       (xcp, h, f # frs) -ta-jvm\\<rightarrow> \\<sigma>'", "unfolding f exec_1_iff"], ["proof (prove)\nusing this:\n  \\<exists>ta \\<sigma>'.\n     (ta, \\<sigma>') \\<in> exec_instr (is ! pc) P t h stk loc C M pc frs\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0,\n                  is, xt)\\<rfloor> in C\n  xcp = None\n\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'.\n       (ta, \\<sigma>') \\<in> exec P t (xcp, h, (stk, loc, C, M, pc) # frs)", "by(simp del: split_paired_Ex)"], ["proof (state)\nthis:\n  \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n     (xcp, h, f # frs) -ta-jvm\\<rightarrow> \\<sigma>'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n     (xcp, h, f # frs) -ta-jvm\\<rightarrow> \\<sigma>'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in JVM_heap_conf) BV_correct_initial:\n  shows \"\\<lbrakk> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; start_heap_ok; P \\<turnstile> C sees M:Ts\\<rightarrow>T = \\<lfloor>m\\<rfloor> in D; P,start_heap \\<turnstile> vs [:\\<le>] Ts \\<rbrakk>\n  \\<Longrightarrow> \\<Phi> \\<turnstile> start_tid:JVM_start_state' P C M vs \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; start_heap_ok;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>m\\<rfloor> in D;\n     P,start_heap \\<turnstile> vs [:\\<le>] Ts\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> \\<turnstile> start_tid:JVM_start_state' P C M\n               vs \\<surd>", "apply (cases m)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; start_heap_ok;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>m\\<rfloor> in D;\n        P,start_heap \\<turnstile> vs [:\\<le>] Ts; m = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> start_tid:JVM_start_state' P C\n                  M vs \\<surd>", "apply (unfold JVM_start_state'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; start_heap_ok;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>m\\<rfloor> in D;\n        P,start_heap \\<turnstile> vs [:\\<le>] Ts; m = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> start_tid:let (D, Ts, T,\n                       meth) = method P C M;\n                     (mxs, mxl0, ins, xt) = the meth\n                 in (None, start_heap,\n                     [([], Null # vs @ replicate mxl0 undefined_value, D, M,\n                       0)]) \\<surd>", "apply (unfold correct_state_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; start_heap_ok;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>m\\<rfloor> in D;\n        P,start_heap \\<turnstile> vs [:\\<le>] Ts; m = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> case let (D, Ts, T, meth) = method P C M;\n                                  (mxs, mxl0, ins, xt) = the meth\n                              in (None, start_heap,\n                                  [([],\n                                    Null #\n                                    vs @ replicate mxl0 undefined_value,\n                                    D, M, 0)]) of\n                         (xp, h, frs) \\<Rightarrow>\n                           P,h \\<turnstile> start_tid \\<surd>t \\<and>\n                           hconf h \\<and>\n                           preallocated h \\<and>\n                           (case frs of [] \\<Rightarrow> True\n                            | f # fs \\<Rightarrow>\n                                let (stk, loc, C, M, pc) = f\n                                in \\<exists>Ts T mxs mxl\\<^sub>0 is xt\n\\<tau>.\nP \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl\\<^sub>0, is,\n                xt)\\<rfloor> in C \\<and>\n\\<Phi> C M ! pc = \\<lfloor>\\<tau>\\<rfloor> \\<and>\nconf_f P h \\<tau> is f \\<and>\nconf_fs P h \\<Phi> M (length Ts) T fs \\<and> conf_xcp P h xp (is ! pc))", "apply (clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; start_heap_ok;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a, b, c,\n                        d)\\<rfloor> in D;\n        P,start_heap \\<turnstile> vs [:\\<le>] Ts; m = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> P,start_heap \\<turnstile> start_tid \\<surd>t \\<and>\n                         hconf start_heap \\<and>\n                         preallocated start_heap \\<and>\n                         (\\<exists>Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 P \\<turnstile> D sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n           mxl\\<^sub>0, is, xt)\\<rfloor> in D) \\<and>\n                             (\\<exists>a ba.\n                                 \\<Phi> D M ! 0 =\n                                 \\<lfloor>(a, ba)\\<rfloor> \\<and>\n                                 conf_f P start_heap (a, ba) is\n                                  ([],\n                                   Null # vs @ replicate b undefined_value,\n                                   D, M, 0)))", "apply (frule wt_jvm_progD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; start_heap_ok;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a, b, c,\n                        d)\\<rfloor> in D;\n        P,start_heap \\<turnstile> vs [:\\<le>] Ts; m = (a, b, c, d);\n        \\<exists>wt. wf_prog wt P\\<rbrakk>\n       \\<Longrightarrow> P,start_heap \\<turnstile> start_tid \\<surd>t \\<and>\n                         hconf start_heap \\<and>\n                         preallocated start_heap \\<and>\n                         (\\<exists>Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 P \\<turnstile> D sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n           mxl\\<^sub>0, is, xt)\\<rfloor> in D) \\<and>\n                             (\\<exists>a ba.\n                                 \\<Phi> D M ! 0 =\n                                 \\<lfloor>(a, ba)\\<rfloor> \\<and>\n                                 conf_f P start_heap (a, ba) is\n                                  ([],\n                                   Null # vs @ replicate b undefined_value,\n                                   D, M, 0)))", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; start_heap_ok;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a, b, c,\n                        d)\\<rfloor> in D;\n        P,start_heap \\<turnstile> vs [:\\<le>] Ts; m = (a, b, c, d);\n        wf_prog wt P\\<rbrakk>\n       \\<Longrightarrow> P,start_heap \\<turnstile> start_tid \\<surd>t \\<and>\n                         hconf start_heap \\<and>\n                         preallocated start_heap \\<and>\n                         (\\<exists>Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 P \\<turnstile> D sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n           mxl\\<^sub>0, is, xt)\\<rfloor> in D) \\<and>\n                             (\\<exists>a ba.\n                                 \\<Phi> D M ! 0 =\n                                 \\<lfloor>(a, ba)\\<rfloor> \\<and>\n                                 conf_f P start_heap (a, ba) is\n                                  ([],\n                                   Null # vs @ replicate b undefined_value,\n                                   D, M, 0)))", "apply (frule wf_prog_wf_syscls)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; start_heap_ok;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a, b, c,\n                        d)\\<rfloor> in D;\n        P,start_heap \\<turnstile> vs [:\\<le>] Ts; m = (a, b, c, d);\n        wf_prog wt P; wf_syscls P\\<rbrakk>\n       \\<Longrightarrow> P,start_heap \\<turnstile> start_tid \\<surd>t \\<and>\n                         hconf start_heap \\<and>\n                         preallocated start_heap \\<and>\n                         (\\<exists>Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 P \\<turnstile> D sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n           mxl\\<^sub>0, is, xt)\\<rfloor> in D) \\<and>\n                             (\\<exists>a ba.\n                                 \\<Phi> D M ! 0 =\n                                 \\<lfloor>(a, ba)\\<rfloor> \\<and>\n                                 conf_f P start_heap (a, ba) is\n                                  ([],\n                                   Null # vs @ replicate b undefined_value,\n                                   D, M, 0)))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c d wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; start_heap_ok;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a, b, c,\n                        d)\\<rfloor> in D;\n        P,start_heap \\<turnstile> vs [:\\<le>] Ts; m = (a, b, c, d);\n        wf_prog wt P; wf_syscls P\\<rbrakk>\n       \\<Longrightarrow> P,start_heap \\<turnstile> start_tid \\<surd>t\n 2. \\<And>a b c d wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; start_heap_ok;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a, b, c,\n                        d)\\<rfloor> in D;\n        P,start_heap \\<turnstile> vs [:\\<le>] Ts; m = (a, b, c, d);\n        wf_prog wt P; wf_syscls P\\<rbrakk>\n       \\<Longrightarrow> hconf start_heap \\<and>\n                         preallocated start_heap \\<and>\n                         (\\<exists>Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 P \\<turnstile> D sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n           mxl\\<^sub>0, is, xt)\\<rfloor> in D) \\<and>\n                             (\\<exists>a ba.\n                                 \\<Phi> D M ! 0 =\n                                 \\<lfloor>(a, ba)\\<rfloor> \\<and>\n                                 conf_f P start_heap (a, ba) is\n                                  ([],\n                                   Null # vs @ replicate b undefined_value,\n                                   D, M, 0)))", "apply(erule (1) tconf_start_heap_start_tid)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; start_heap_ok;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a, b, c,\n                        d)\\<rfloor> in D;\n        P,start_heap \\<turnstile> vs [:\\<le>] Ts; m = (a, b, c, d);\n        wf_prog wt P; wf_syscls P\\<rbrakk>\n       \\<Longrightarrow> hconf start_heap \\<and>\n                         preallocated start_heap \\<and>\n                         (\\<exists>Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 P \\<turnstile> D sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n           mxl\\<^sub>0, is, xt)\\<rfloor> in D) \\<and>\n                             (\\<exists>a ba.\n                                 \\<Phi> D M ! 0 =\n                                 \\<lfloor>(a, ba)\\<rfloor> \\<and>\n                                 conf_f P start_heap (a, ba) is\n                                  ([],\n                                   Null # vs @ replicate b undefined_value,\n                                   D, M, 0)))", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c d wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; start_heap_ok;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a, b, c,\n                        d)\\<rfloor> in D;\n        P,start_heap \\<turnstile> vs [:\\<le>] Ts; m = (a, b, c, d);\n        wf_prog wt P; wf_syscls P\\<rbrakk>\n       \\<Longrightarrow> hconf start_heap\n 2. \\<And>a b c d wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; start_heap_ok;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a, b, c,\n                        d)\\<rfloor> in D;\n        P,start_heap \\<turnstile> vs [:\\<le>] Ts; m = (a, b, c, d);\n        wf_prog wt P; wf_syscls P\\<rbrakk>\n       \\<Longrightarrow> preallocated start_heap \\<and>\n                         (\\<exists>Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 P \\<turnstile> D sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n           mxl\\<^sub>0, is, xt)\\<rfloor> in D) \\<and>\n                             (\\<exists>a ba.\n                                 \\<Phi> D M ! 0 =\n                                 \\<lfloor>(a, ba)\\<rfloor> \\<and>\n                                 conf_f P start_heap (a, ba) is\n                                  ([],\n                                   Null # vs @ replicate b undefined_value,\n                                   D, M, 0)))", "apply (simp add: wf_jvm_prog_phi_def hconf_start_heap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; start_heap_ok;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a, b, c,\n                        d)\\<rfloor> in D;\n        P,start_heap \\<turnstile> vs [:\\<le>] Ts; m = (a, b, c, d);\n        wf_prog wt P; wf_syscls P\\<rbrakk>\n       \\<Longrightarrow> preallocated start_heap \\<and>\n                         (\\<exists>Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 P \\<turnstile> D sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n           mxl\\<^sub>0, is, xt)\\<rfloor> in D) \\<and>\n                             (\\<exists>a ba.\n                                 \\<Phi> D M ! 0 =\n                                 \\<lfloor>(a, ba)\\<rfloor> \\<and>\n                                 conf_f P start_heap (a, ba) is\n                                  ([],\n                                   Null # vs @ replicate b undefined_value,\n                                   D, M, 0)))", "apply(frule sees_method_idemp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; start_heap_ok;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a, b, c,\n                        d)\\<rfloor> in D;\n        P,start_heap \\<turnstile> vs [:\\<le>] Ts; m = (a, b, c, d);\n        wf_prog wt P; wf_syscls P;\n        P \\<turnstile> D sees M: Ts\\<rightarrow>T = \\<lfloor>(a, b, c,\n                        d)\\<rfloor> in D\\<rbrakk>\n       \\<Longrightarrow> preallocated start_heap \\<and>\n                         (\\<exists>Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 P \\<turnstile> D sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n           mxl\\<^sub>0, is, xt)\\<rfloor> in D) \\<and>\n                             (\\<exists>a ba.\n                                 \\<Phi> D M ! 0 =\n                                 \\<lfloor>(a, ba)\\<rfloor> \\<and>\n                                 conf_f P start_heap (a, ba) is\n                                  ([],\n                                   Null # vs @ replicate b undefined_value,\n                                   D, M, 0)))", "apply (frule wt_jvm_prog_impl_wt_start, assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; start_heap_ok;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a, b, c,\n                        d)\\<rfloor> in D;\n        P,start_heap \\<turnstile> vs [:\\<le>] Ts; m = (a, b, c, d);\n        wf_prog wt P; wf_syscls P;\n        P \\<turnstile> D sees M: Ts\\<rightarrow>T = \\<lfloor>(a, b, c,\n                        d)\\<rfloor> in D;\n        0 < length c \\<and> wt_start P D Ts b (\\<Phi> D M)\\<rbrakk>\n       \\<Longrightarrow> preallocated start_heap \\<and>\n                         (\\<exists>Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 P \\<turnstile> D sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n           mxl\\<^sub>0, is, xt)\\<rfloor> in D) \\<and>\n                             (\\<exists>a ba.\n                                 \\<Phi> D M ! 0 =\n                                 \\<lfloor>(a, ba)\\<rfloor> \\<and>\n                                 conf_f P start_heap (a, ba) is\n                                  ([],\n                                   Null # vs @ replicate b undefined_value,\n                                   D, M, 0)))", "apply (unfold conf_f_def wt_start_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; start_heap_ok;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a, b, c,\n                        d)\\<rfloor> in D;\n        P,start_heap \\<turnstile> vs [:\\<le>] Ts; m = (a, b, c, d);\n        wf_prog wt P; wf_syscls P;\n        P \\<turnstile> D sees M: Ts\\<rightarrow>T = \\<lfloor>(a, b, c,\n                        d)\\<rfloor> in D;\n        0 < length c \\<and>\n        P \\<turnstile> \\<lfloor>([],\n                                 OK (Class D) #\n                                 map OK Ts @\n                                 replicate b\n                                  Err)\\<rfloor> \\<le>' \\<Phi> D M !\n                 0\\<rbrakk>\n       \\<Longrightarrow> preallocated start_heap \\<and>\n                         (\\<exists>Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 P \\<turnstile> D sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n           mxl\\<^sub>0, is, xt)\\<rfloor> in D) \\<and>\n                             (\\<exists>a ba.\n                                 \\<Phi> D M ! 0 =\n                                 \\<lfloor>(a, ba)\\<rfloor> \\<and>\n                                 (case (a, ba) of\n                                  (ST, LT) \\<Rightarrow>\n                                    \\<lambda>is (stk, loc, C, M, pc).\n P,start_heap \\<turnstile> stk [:\\<le>] ST \\<and>\n P,start_heap \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT \\<and>\n pc < length is)\n                                  is ([],\nNull # vs @ replicate b undefined_value, D, M, 0)))", "apply(auto simp add: sup_state_opt_any_Some)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c d wt z zs.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; start_heap_ok;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a, b, c,\n                        d)\\<rfloor> in D;\n        P,start_heap \\<turnstile> vs [:\\<le>] Ts; m = (a, b, c, d);\n        wf_prog wt P; wf_syscls P;\n        P \\<turnstile> D sees M: Ts\\<rightarrow>T = \\<lfloor>(a, b, c,\n                        d)\\<rfloor> in D;\n        c \\<noteq> []; \\<Phi> D M ! 0 = \\<lfloor>([], z # zs)\\<rfloor>;\n        P \\<turnstile> OK (Class D) \\<le>\\<^sub>\\<top> z;\n        P \\<turnstile> (map OK Ts @\n                        replicate b Err) [\\<le>\\<^sub>\\<top>] zs\\<rbrakk>\n       \\<Longrightarrow> preallocated start_heap\n 2. \\<And>a b c d wt z zs.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; start_heap_ok;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a, b, c,\n                        d)\\<rfloor> in D;\n        P,start_heap \\<turnstile> vs [:\\<le>] Ts; m = (a, b, c, d);\n        wf_prog wt P; wf_syscls P;\n        P \\<turnstile> D sees M: Ts\\<rightarrow>T = \\<lfloor>(a, b, c,\n                        d)\\<rfloor> in D;\n        c \\<noteq> []; \\<Phi> D M ! 0 = \\<lfloor>([], z # zs)\\<rfloor>;\n        P \\<turnstile> OK (Class D) \\<le>\\<^sub>\\<top> z;\n        P \\<turnstile> (map OK Ts @\n                        replicate b Err) [\\<le>\\<^sub>\\<top>] zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> D sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in D) \\<and>\n                            P,start_heap \\<turnstile> Null :\\<le>\\<^sub>\\<top> z \\<and>\n                            P,start_heap \\<turnstile> vs @\n                replicate b undefined_value [:\\<le>\\<^sub>\\<top>] zs \\<and>\n                            is \\<noteq> []", "apply(erule preallocated_start_heap)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c d wt z zs.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a, b, c,\n                        d)\\<rfloor> in D;\n        P,start_heap \\<turnstile> vs [:\\<le>] Ts; m = (a, b, c, d);\n        wf_prog wt P; wf_syscls P;\n        P \\<turnstile> D sees M: Ts\\<rightarrow>T = \\<lfloor>(a, b, c,\n                        d)\\<rfloor> in D;\n        c \\<noteq> []; \\<Phi> D M ! 0 = \\<lfloor>([], z # zs)\\<rfloor>;\n        P \\<turnstile> OK (Class D) \\<le>\\<^sub>\\<top> z;\n        P \\<turnstile> (map OK Ts @\n                        replicate b Err) [\\<le>\\<^sub>\\<top>] zs\\<rbrakk>\n       \\<Longrightarrow> wf_syscls P\n 2. \\<And>a b c d wt z zs.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; start_heap_ok;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a, b, c,\n                        d)\\<rfloor> in D;\n        P,start_heap \\<turnstile> vs [:\\<le>] Ts; m = (a, b, c, d);\n        wf_prog wt P; wf_syscls P;\n        P \\<turnstile> D sees M: Ts\\<rightarrow>T = \\<lfloor>(a, b, c,\n                        d)\\<rfloor> in D;\n        c \\<noteq> []; \\<Phi> D M ! 0 = \\<lfloor>([], z # zs)\\<rfloor>;\n        P \\<turnstile> OK (Class D) \\<le>\\<^sub>\\<top> z;\n        P \\<turnstile> (map OK Ts @\n                        replicate b Err) [\\<le>\\<^sub>\\<top>] zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> D sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n          mxl\\<^sub>0, is, xt)\\<rfloor> in D) \\<and>\n                            P,start_heap \\<turnstile> Null :\\<le>\\<^sub>\\<top> z \\<and>\n                            P,start_heap \\<turnstile> vs @\n                replicate b undefined_value [:\\<le>\\<^sub>\\<top>] zs \\<and>\n                            is \\<noteq> []", "apply(rule exI conjI|assumption)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c d wt z zs.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; start_heap_ok;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a, b, c,\n                        d)\\<rfloor> in D;\n        P,start_heap \\<turnstile> vs [:\\<le>] Ts; m = (a, b, c, d);\n        wf_prog wt P; wf_syscls P;\n        P \\<turnstile> D sees M: Ts\\<rightarrow>T = \\<lfloor>(a, b, c,\n                        d)\\<rfloor> in D;\n        c \\<noteq> []; \\<Phi> D M ! 0 = \\<lfloor>([], z # zs)\\<rfloor>;\n        P \\<turnstile> OK (Class D) \\<le>\\<^sub>\\<top> z;\n        P \\<turnstile> (map OK Ts @\n                        replicate b Err) [\\<le>\\<^sub>\\<top>] zs\\<rbrakk>\n       \\<Longrightarrow> P,start_heap \\<turnstile> Null :\\<le>\\<^sub>\\<top> z\n 2. \\<And>a b c d wt z zs.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; start_heap_ok;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a, b, c,\n                        d)\\<rfloor> in D;\n        P,start_heap \\<turnstile> vs [:\\<le>] Ts; m = (a, b, c, d);\n        wf_prog wt P; wf_syscls P;\n        P \\<turnstile> D sees M: Ts\\<rightarrow>T = \\<lfloor>(a, b, c,\n                        d)\\<rfloor> in D;\n        c \\<noteq> []; \\<Phi> D M ! 0 = \\<lfloor>([], z # zs)\\<rfloor>;\n        P \\<turnstile> OK (Class D) \\<le>\\<^sub>\\<top> z;\n        P \\<turnstile> (map OK Ts @\n                        replicate b Err) [\\<le>\\<^sub>\\<top>] zs\\<rbrakk>\n       \\<Longrightarrow> P,start_heap \\<turnstile> vs @\n             replicate b undefined_value [:\\<le>\\<^sub>\\<top>] zs \\<and>\n                         c \\<noteq> []", "apply(auto simp add: list_all2_append1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d wt z us.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; start_heap_ok;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(a, b, c,\n                        d)\\<rfloor> in D;\n        P,start_heap \\<turnstile> vs [:\\<le>] Ts; m = (a, b, c, d);\n        wf_prog wt P; wf_syscls P;\n        P \\<turnstile> D sees M: Ts\\<rightarrow>T = \\<lfloor>(a, b, c,\n                        d)\\<rfloor> in D;\n        c \\<noteq> [];\n        \\<Phi> D M ! 0 = \\<lfloor>([], z # us @ replicate b Err)\\<rfloor>;\n        P \\<turnstile> OK (Class D) \\<le>\\<^sub>\\<top> z;\n        length us = length Ts;\n        P \\<turnstile> map OK Ts [\\<le>\\<^sub>\\<top>] us\\<rbrakk>\n       \\<Longrightarrow> \\<exists>usa vsa.\n                            us @ replicate b Err = usa @ vsa \\<and>\n                            length usa = length vs \\<and>\n                            length vsa = b \\<and>\n                            P,start_heap \\<turnstile> vs [:\\<le>\\<^sub>\\<top>] usa \\<and>\n                            P,start_heap \\<turnstile> replicate b\n                 undefined_value [:\\<le>\\<^sub>\\<top>] vsa", "apply(auto dest: list_all2_lengthD intro!: exI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}