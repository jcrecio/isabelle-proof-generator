{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Common/Heap.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma rec_addr_loc [simp]: \"rec_addr_loc = case_addr_loc\"", "lemma typeof_lit_eq_Boolean [simp]: \"(typeof v = Some Boolean) = (\\<exists>b. v = Bool b)\"", "lemma typeof_lit_eq_Integer [simp]: \"(typeof v = Some Integer) = (\\<exists>i. v = Intg i)\"", "lemma typeof_lit_eq_NT [simp]: \"(typeof v = Some NT) = (v = Null)\"", "lemma typeof_lit_eq_Void [simp]: \"typeof v = Some Void \\<longleftrightarrow> v = Unit\"", "lemma typeof_lit_neq_Class [simp]: \"typeof v \\<noteq> Some (Class C)\"", "lemma typeof_lit_neq_Array [simp]: \"typeof v \\<noteq> Some (Array T)\"", "lemma typeof_NoneD [simp,dest]:\n  \"typeof v = Some x \\<Longrightarrow> \\<not> is_Addr v\"", "lemma typeof_lit_is_type:\n  \"typeof v = Some T \\<Longrightarrow> is_type P T\"", "lemma typeof_h_eq_Boolean [simp]: \"(typeof\\<^bsub>h\\<^esub> v = Some Boolean) = (\\<exists>b. v = Bool b)\"", "lemma typeof_h_eq_Integer [simp]: \"(typeof\\<^bsub>h\\<^esub> v = Some Integer) = (\\<exists>i. v = Intg i)\"", "lemma typeof_h_eq_NT [simp]: \"(typeof\\<^bsub>h\\<^esub> v = Some NT) = (v = Null)\"", "lemma hextI:\n  \"\\<lbrakk> \\<And>a C. typeof_addr h a = \\<lfloor>Class_type C\\<rfloor> \\<Longrightarrow> typeof_addr h' a = \\<lfloor>Class_type C\\<rfloor>;\n     \\<And>a T n. typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor> \\<Longrightarrow> typeof_addr h' a = \\<lfloor>Array_type T n\\<rfloor> \\<rbrakk>\n  \\<Longrightarrow> h \\<unlhd> h'\"", "lemma hext_objD:\n  assumes \"h \\<unlhd> h'\"\n  and \"typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\"\n  shows \"typeof_addr h' a = \\<lfloor>Class_type C\\<rfloor>\"", "lemma hext_arrD:\n  assumes \"h \\<unlhd> h'\" \"typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>\"\n  shows \"typeof_addr h' a = \\<lfloor>Array_type T n\\<rfloor>\"", "lemma hext_refl [iff]: \"h \\<unlhd> h\"", "lemma hext_trans [trans]: \"\\<lbrakk> h \\<unlhd> h'; h' \\<unlhd> h'' \\<rbrakk> \\<Longrightarrow> h \\<unlhd> h''\"", "lemma typeof_lit_typeof:\n  \"typeof v = \\<lfloor>T\\<rfloor> \\<Longrightarrow> typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>\"", "lemma addr_loc_type_fun:\n  \"\\<lbrakk> P,h \\<turnstile> a@al : T; P,h \\<turnstile> a@al : T' \\<rbrakk> \\<Longrightarrow> T = T'\"", "lemma THE_addr_loc_type:\n  \"P,h \\<turnstile> a@al : T \\<Longrightarrow> (THE T. P,h \\<turnstile> a@al : T) = T\"", "lemma typeof_addr_locI [simp]:\n  \"P,h \\<turnstile> a@al : T \\<Longrightarrow> typeof_addr_loc P h a al = T\"", "lemma deterministic_heap_opsI:\n  \"\\<lbrakk> \\<And>h ad al v v'. \\<lbrakk> heap_read h ad al v; heap_read h ad al v' \\<rbrakk> \\<Longrightarrow> v = v';\n     \\<And>h ad al v h' h''. \\<lbrakk> heap_write h ad al v h'; heap_write h ad al v h'' \\<rbrakk> \\<Longrightarrow> h' = h'';\n     \\<And>h hT h' a h'' a'. \\<lbrakk> (h', a) \\<in> allocate h hT; (h'', a') \\<in> allocate h hT \\<rbrakk> \\<Longrightarrow> h' = h'' \\<and> a = a';\n     \\<not> spurious_wakeups \\<rbrakk>\n  \\<Longrightarrow> deterministic_heap_ops\"", "lemma deterministic_heap_ops_readD:\n  \"\\<lbrakk> deterministic_heap_ops; heap_read h ad al v; heap_read h ad al v' \\<rbrakk> \\<Longrightarrow> v = v'\"", "lemma deterministic_heap_ops_writeD:\n  \"\\<lbrakk> deterministic_heap_ops; heap_write h ad al v h'; heap_write h ad al v h'' \\<rbrakk> \\<Longrightarrow> h' = h''\"", "lemma deterministic_heap_ops_allocateD:\n  \"\\<lbrakk> deterministic_heap_ops; (h', a) \\<in> allocate h hT; (h'', a') \\<in> allocate h hT \\<rbrakk> \\<Longrightarrow> h' = h'' \\<and> a = a'\"", "lemma deterministic_heap_ops_no_spurious_wakeups:\n  \"deterministic_heap_ops \\<Longrightarrow> \\<not> spurious_wakeups\"", "lemma typeof_addr_thread_id2_addr_addr2thread_id [simp]:\n  \"\\<lbrakk> typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>; P \\<turnstile> C \\<preceq>\\<^sup>* Thread \\<rbrakk> \\<Longrightarrow> typeof_addr h (thread_id2addr (addr2thread_id a)) = \\<lfloor>Class_type C\\<rfloor>\"", "lemmas hext_heap_ops = hext_allocate hext_heap_write", "lemma typeof_addr_hext_mono:\n  \"\\<lbrakk> h \\<unlhd> h'; typeof_addr h a = \\<lfloor>hT\\<rfloor> \\<rbrakk> \\<Longrightarrow> typeof_addr h' a = \\<lfloor>hT\\<rfloor>\"", "lemma hext_typeof_mono:\n  \"\\<lbrakk> h \\<unlhd> h'; typeof\\<^bsub>h\\<^esub> v = Some T \\<rbrakk> \\<Longrightarrow> typeof\\<^bsub>h'\\<^esub> v = Some T\"", "lemma addr_loc_type_hext_mono:\n  \"\\<lbrakk> P,h \\<turnstile> a@al : T; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow> P,h' \\<turnstile> a@al : T\"", "lemma type_of_hext_type_of: \\<comment> \\<open>FIXME: What's this rule good for?\\<close>\n  \"\\<lbrakk> typeof\\<^bsub>h\\<^esub> w = \\<lfloor>T\\<rfloor>; hext h h' \\<rbrakk> \\<Longrightarrow> typeof\\<^bsub>h'\\<^esub> w = \\<lfloor>T\\<rfloor>\"", "lemma hext_None: \"\\<lbrakk> h \\<unlhd> h'; typeof_addr h' a = None \\<rbrakk> \\<Longrightarrow> typeof_addr h a = None\"", "lemma map_typeof_hext_mono:\n  \"\\<lbrakk> map typeof\\<^bsub>h\\<^esub> vs = map Some Ts; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow>  map typeof\\<^bsub>h'\\<^esub> vs = map Some Ts\"", "lemma hext_typeof_addr_map_le:\n  \"h \\<unlhd> h' \\<Longrightarrow> typeof_addr h \\<subseteq>\\<^sub>m typeof_addr h'\"", "lemma hext_dom_typeof_addr_subset:\n  \"h \\<unlhd> h' \\<Longrightarrow> dom (typeof_addr h) \\<subseteq> dom (typeof_addr h')\""], "translations": [["", "lemma rec_addr_loc [simp]: \"rec_addr_loc = case_addr_loc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_addr_loc = case_addr_loc", "by(auto simp add: fun_eq_iff split: addr_loc.splits)"], ["", "primrec is_volatile :: \"'m prog \\<Rightarrow> addr_loc \\<Rightarrow> bool\"\nwhere \n  \"is_volatile P (ACell n) = False\"\n| \"is_volatile P (CField D F) = volatile (snd (snd (field P D F)))\""], ["", "locale heap_base =\n  addr_base addr2thread_id thread_id2addr \n  for addr2thread_id :: \"('addr :: addr) \\<Rightarrow> 'thread_id\"\n  and thread_id2addr :: \"'thread_id \\<Rightarrow> 'addr\"\n  +\n  fixes spurious_wakeups :: bool\n  and empty_heap :: \"'heap\"\n  and allocate :: \"'heap \\<Rightarrow> htype \\<Rightarrow> ('heap \\<times> 'addr) set\"\n  and typeof_addr :: \"'heap \\<Rightarrow> 'addr \\<rightharpoonup> htype\"\n  and heap_read :: \"'heap \\<Rightarrow> 'addr \\<Rightarrow> addr_loc \\<Rightarrow> 'addr val \\<Rightarrow> bool\"\n  and heap_write :: \"'heap \\<Rightarrow> 'addr \\<Rightarrow> addr_loc \\<Rightarrow> 'addr val \\<Rightarrow> 'heap \\<Rightarrow> bool\"\nbegin"], ["", "fun typeof_h :: \"'heap \\<Rightarrow> 'addr val \\<Rightarrow> ty option\"  (\"typeof\\<^bsub>_\\<^esub>\")\nwhere\n  \"typeof\\<^bsub>h\\<^esub> (Addr a) = map_option ty_of_htype (typeof_addr h a)\"\n| \"typeof\\<^bsub>h\\<^esub>  v = typeof v\""], ["", "definition cname_of :: \"'heap \\<Rightarrow> 'addr \\<Rightarrow> cname\"\nwhere \"cname_of h a = the_Class (ty_of_htype (the (typeof_addr h a)))\""], ["", "definition hext :: \"'heap \\<Rightarrow> 'heap \\<Rightarrow> bool\" (\"_ \\<unlhd> _\" [51,51] 50)\nwhere\n  \"h \\<unlhd> h' \\<equiv> typeof_addr h \\<subseteq>\\<^sub>m typeof_addr h'\""], ["", "context\n  notes [[inductive_internals]]\nbegin"], ["", "inductive addr_loc_type :: \"'m prog \\<Rightarrow> 'heap \\<Rightarrow> 'addr \\<Rightarrow> addr_loc \\<Rightarrow> ty \\<Rightarrow> bool\"\n  (\"_,_ \\<turnstile> _@_ : _\" [50, 50, 50, 50, 50] 51)\nfor P :: \"'m prog\" and h :: 'heap and a :: 'addr\nwhere\n  addr_loc_type_field:\n  \"\\<lbrakk> typeof_addr h a = \\<lfloor>U\\<rfloor>; P \\<turnstile> class_type_of U has F:T (fm) in D \\<rbrakk> \n  \\<Longrightarrow> P,h \\<turnstile> a@CField D F : T\"\n\n| addr_loc_type_cell:\n  \"\\<lbrakk> typeof_addr h a = \\<lfloor>Array_type T n'\\<rfloor>; n < n' \\<rbrakk>\n  \\<Longrightarrow> P,h \\<turnstile> a@ACell n : T\""], ["", "end"], ["", "definition typeof_addr_loc :: \"'m prog \\<Rightarrow> 'heap \\<Rightarrow> 'addr \\<Rightarrow> addr_loc \\<Rightarrow> ty\"\nwhere \"typeof_addr_loc P h a al = (THE T. P,h \\<turnstile> a@al : T)\""], ["", "definition deterministic_heap_ops :: bool\nwhere\n  \"deterministic_heap_ops \\<longleftrightarrow>\n  (\\<forall>h ad al v v'. heap_read h ad al v \\<longrightarrow> heap_read h ad al v' \\<longrightarrow> v = v') \\<and>\n  (\\<forall>h ad al v h' h''. heap_write h ad al v h' \\<longrightarrow> heap_write h ad al v h'' \\<longrightarrow> h' = h'') \\<and>\n  (\\<forall>h hT h' a h'' a'. (h', a) \\<in> allocate h hT \\<longrightarrow> (h'', a') \\<in> allocate h hT \\<longrightarrow> h' = h'' \\<and> a = a') \\<and>\n  \\<not> spurious_wakeups\""], ["", "end"], ["", "lemma typeof_lit_eq_Boolean [simp]: \"(typeof v = Some Boolean) = (\\<exists>b. v = Bool b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (typeof v = \\<lfloor>Boolean\\<rfloor>) = (\\<exists>b. v = Bool b)", "by(cases v)(auto)"], ["", "lemma typeof_lit_eq_Integer [simp]: \"(typeof v = Some Integer) = (\\<exists>i. v = Intg i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (typeof v = \\<lfloor>Integer\\<rfloor>) = (\\<exists>i. v = Intg i)", "by(cases v)(auto)"], ["", "lemma typeof_lit_eq_NT [simp]: \"(typeof v = Some NT) = (v = Null)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (typeof v = \\<lfloor>NT\\<rfloor>) = (v = Null)", "by(cases v)(auto)"], ["", "lemma typeof_lit_eq_Void [simp]: \"typeof v = Some Void \\<longleftrightarrow> v = Unit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (typeof v = \\<lfloor>Void\\<rfloor>) = (v = Unit)", "by(cases v)(auto)"], ["", "lemma typeof_lit_neq_Class [simp]: \"typeof v \\<noteq> Some (Class C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof v \\<noteq> \\<lfloor>Class C\\<rfloor>", "by(cases v) auto"], ["", "lemma typeof_lit_neq_Array [simp]: \"typeof v \\<noteq> Some (Array T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof v \\<noteq> \\<lfloor>T\\<lfloor>\\<rceil>\\<rfloor>", "by(cases v) auto"], ["", "lemma typeof_NoneD [simp,dest]:\n  \"typeof v = Some x \\<Longrightarrow> \\<not> is_Addr v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof v = \\<lfloor>x\\<rfloor> \\<Longrightarrow> \\<not> is_Addr v", "by (cases v) auto"], ["", "lemma typeof_lit_is_type:\n  \"typeof v = Some T \\<Longrightarrow> is_type P T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof v = \\<lfloor>T\\<rfloor> \\<Longrightarrow> is_type P T", "by(cases v) auto"], ["", "context heap_base begin"], ["", "lemma typeof_h_eq_Boolean [simp]: \"(typeof\\<^bsub>h\\<^esub> v = Some Boolean) = (\\<exists>b. v = Bool b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (typeof\\<^bsub>h\\<^esub> v = \\<lfloor>Boolean\\<rfloor>) =\n    (\\<exists>b. v = Bool b)", "by(cases v)(auto)"], ["", "lemma typeof_h_eq_Integer [simp]: \"(typeof\\<^bsub>h\\<^esub> v = Some Integer) = (\\<exists>i. v = Intg i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (typeof\\<^bsub>h\\<^esub> v = \\<lfloor>Integer\\<rfloor>) =\n    (\\<exists>i. v = Intg i)", "by(cases v)(auto)"], ["", "lemma typeof_h_eq_NT [simp]: \"(typeof\\<^bsub>h\\<^esub> v = Some NT) = (v = Null)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (typeof\\<^bsub>h\\<^esub> v = \\<lfloor>NT\\<rfloor>) = (v = Null)", "by(cases v)(auto)"], ["", "lemma hextI:\n  \"\\<lbrakk> \\<And>a C. typeof_addr h a = \\<lfloor>Class_type C\\<rfloor> \\<Longrightarrow> typeof_addr h' a = \\<lfloor>Class_type C\\<rfloor>;\n     \\<And>a T n. typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor> \\<Longrightarrow> typeof_addr h' a = \\<lfloor>Array_type T n\\<rfloor> \\<rbrakk>\n  \\<Longrightarrow> h \\<unlhd> h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a C.\n                typeof_addr h a =\n                \\<lfloor>Class_type C\\<rfloor> \\<Longrightarrow>\n                typeof_addr h' a = \\<lfloor>Class_type C\\<rfloor>;\n     \\<And>a T n.\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor> \\<Longrightarrow>\n        typeof_addr h' a = \\<lfloor>Array_type T n\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'", "unfolding hext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a C.\n                typeof_addr h a =\n                \\<lfloor>Class_type C\\<rfloor> \\<Longrightarrow>\n                typeof_addr h' a = \\<lfloor>Class_type C\\<rfloor>;\n     \\<And>a T n.\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor> \\<Longrightarrow>\n        typeof_addr h' a = \\<lfloor>Array_type T n\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> typeof_addr h \\<subseteq>\\<^sub>m typeof_addr h'", "by(rule map_leI)(case_tac v, simp_all)"], ["", "lemma hext_objD:\n  assumes \"h \\<unlhd> h'\"\n  and \"typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\"\n  shows \"typeof_addr h' a = \\<lfloor>Class_type C\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof_addr h' a = \\<lfloor>Class_type C\\<rfloor>", "using assms"], ["proof (prove)\nusing this:\n  h \\<unlhd> h'\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (1 subgoal):\n 1. typeof_addr h' a = \\<lfloor>Class_type C\\<rfloor>", "unfolding hext_def"], ["proof (prove)\nusing this:\n  typeof_addr h \\<subseteq>\\<^sub>m typeof_addr h'\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (1 subgoal):\n 1. typeof_addr h' a = \\<lfloor>Class_type C\\<rfloor>", "by(auto dest: map_le_SomeD)"], ["", "lemma hext_arrD:\n  assumes \"h \\<unlhd> h'\" \"typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>\"\n  shows \"typeof_addr h' a = \\<lfloor>Array_type T n\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof_addr h' a = \\<lfloor>Array_type T n\\<rfloor>", "using assms"], ["proof (prove)\nusing this:\n  h \\<unlhd> h'\n  typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>\n\ngoal (1 subgoal):\n 1. typeof_addr h' a = \\<lfloor>Array_type T n\\<rfloor>", "unfolding hext_def"], ["proof (prove)\nusing this:\n  typeof_addr h \\<subseteq>\\<^sub>m typeof_addr h'\n  typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>\n\ngoal (1 subgoal):\n 1. typeof_addr h' a = \\<lfloor>Array_type T n\\<rfloor>", "by(blast dest: map_le_SomeD)"], ["", "lemma hext_refl [iff]: \"h \\<unlhd> h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<unlhd> h", "by (rule hextI) blast+"], ["", "lemma hext_trans [trans]: \"\\<lbrakk> h \\<unlhd> h'; h' \\<unlhd> h'' \\<rbrakk> \\<Longrightarrow> h \\<unlhd> h''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<unlhd> h'; h' \\<unlhd> h''\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h''", "unfolding hext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>typeof_addr h \\<subseteq>\\<^sub>m typeof_addr h';\n     typeof_addr h' \\<subseteq>\\<^sub>m typeof_addr h''\\<rbrakk>\n    \\<Longrightarrow> typeof_addr h \\<subseteq>\\<^sub>m typeof_addr h''", "by(rule map_le_trans)"], ["", "lemma typeof_lit_typeof:\n  \"typeof v = \\<lfloor>T\\<rfloor> \\<Longrightarrow> typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof v = \\<lfloor>T\\<rfloor> \\<Longrightarrow>\n    typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>", "by(cases v)(simp_all)"], ["", "lemma addr_loc_type_fun:\n  \"\\<lbrakk> P,h \\<turnstile> a@al : T; P,h \\<turnstile> a@al : T' \\<rbrakk> \\<Longrightarrow> T = T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> a@al : T; P,h \\<turnstile> a@al : T'\\<rbrakk>\n    \\<Longrightarrow> T = T'", "by(auto elim!: addr_loc_type.cases dest: has_field_fun)"], ["", "lemma THE_addr_loc_type:\n  \"P,h \\<turnstile> a@al : T \\<Longrightarrow> (THE T. P,h \\<turnstile> a@al : T) = T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h \\<turnstile> a@al : T \\<Longrightarrow>\n    (THE T. P,h \\<turnstile> a@al : T) = T", "by(rule the_equality)(auto dest: addr_loc_type_fun)"], ["", "lemma typeof_addr_locI [simp]:\n  \"P,h \\<turnstile> a@al : T \\<Longrightarrow> typeof_addr_loc P h a al = T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h \\<turnstile> a@al : T \\<Longrightarrow> typeof_addr_loc P h a al = T", "by(auto simp add: typeof_addr_loc_def dest: addr_loc_type_fun)"], ["", "lemma deterministic_heap_opsI:\n  \"\\<lbrakk> \\<And>h ad al v v'. \\<lbrakk> heap_read h ad al v; heap_read h ad al v' \\<rbrakk> \\<Longrightarrow> v = v';\n     \\<And>h ad al v h' h''. \\<lbrakk> heap_write h ad al v h'; heap_write h ad al v h'' \\<rbrakk> \\<Longrightarrow> h' = h'';\n     \\<And>h hT h' a h'' a'. \\<lbrakk> (h', a) \\<in> allocate h hT; (h'', a') \\<in> allocate h hT \\<rbrakk> \\<Longrightarrow> h' = h'' \\<and> a = a';\n     \\<not> spurious_wakeups \\<rbrakk>\n  \\<Longrightarrow> deterministic_heap_ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>h ad al v v'.\n                \\<lbrakk>heap_read h ad al v; heap_read h ad al v'\\<rbrakk>\n                \\<Longrightarrow> v = v';\n     \\<And>h ad al v h' h''.\n        \\<lbrakk>heap_write h ad al v h'; heap_write h ad al v h''\\<rbrakk>\n        \\<Longrightarrow> h' = h'';\n     \\<And>h hT h' a h'' a'.\n        \\<lbrakk>(h', a) \\<in> allocate h hT;\n         (h'', a') \\<in> allocate h hT\\<rbrakk>\n        \\<Longrightarrow> h' = h'' \\<and> a = a';\n     \\<not> spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> deterministic_heap_ops", "unfolding deterministic_heap_ops_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>h ad al v v'.\n                \\<lbrakk>heap_read h ad al v; heap_read h ad al v'\\<rbrakk>\n                \\<Longrightarrow> v = v';\n     \\<And>h ad al v h' h''.\n        \\<lbrakk>heap_write h ad al v h'; heap_write h ad al v h''\\<rbrakk>\n        \\<Longrightarrow> h' = h'';\n     \\<And>h hT h' a h'' a'.\n        \\<lbrakk>(h', a) \\<in> allocate h hT;\n         (h'', a') \\<in> allocate h hT\\<rbrakk>\n        \\<Longrightarrow> h' = h'' \\<and> a = a';\n     \\<not> spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>h ad al v v'.\n                          heap_read h ad al v \\<longrightarrow>\n                          heap_read h ad al v' \\<longrightarrow>\n                          v = v') \\<and>\n                      (\\<forall>h ad al v h' h''.\n                          heap_write h ad al v h' \\<longrightarrow>\n                          heap_write h ad al v h'' \\<longrightarrow>\n                          h' = h'') \\<and>\n                      (\\<forall>h hT h' a h'' a'.\n                          (h', a) \\<in> allocate h hT \\<longrightarrow>\n                          (h'', a') \\<in> allocate h hT \\<longrightarrow>\n                          h' = h'' \\<and> a = a') \\<and>\n                      \\<not> spurious_wakeups", "by blast"], ["", "lemma deterministic_heap_ops_readD:\n  \"\\<lbrakk> deterministic_heap_ops; heap_read h ad al v; heap_read h ad al v' \\<rbrakk> \\<Longrightarrow> v = v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>deterministic_heap_ops; heap_read h ad al v;\n     heap_read h ad al v'\\<rbrakk>\n    \\<Longrightarrow> v = v'", "unfolding deterministic_heap_ops_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>h ad al v v'.\n                 heap_read h ad al v \\<longrightarrow>\n                 heap_read h ad al v' \\<longrightarrow> v = v') \\<and>\n             (\\<forall>h ad al v h' h''.\n                 heap_write h ad al v h' \\<longrightarrow>\n                 heap_write h ad al v h'' \\<longrightarrow> h' = h'') \\<and>\n             (\\<forall>h hT h' a h'' a'.\n                 (h', a) \\<in> allocate h hT \\<longrightarrow>\n                 (h'', a') \\<in> allocate h hT \\<longrightarrow>\n                 h' = h'' \\<and> a = a') \\<and>\n             \\<not> spurious_wakeups;\n     heap_read h ad al v; heap_read h ad al v'\\<rbrakk>\n    \\<Longrightarrow> v = v'", "by blast"], ["", "lemma deterministic_heap_ops_writeD:\n  \"\\<lbrakk> deterministic_heap_ops; heap_write h ad al v h'; heap_write h ad al v h'' \\<rbrakk> \\<Longrightarrow> h' = h''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>deterministic_heap_ops; heap_write h ad al v h';\n     heap_write h ad al v h''\\<rbrakk>\n    \\<Longrightarrow> h' = h''", "unfolding deterministic_heap_ops_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>h ad al v v'.\n                 heap_read h ad al v \\<longrightarrow>\n                 heap_read h ad al v' \\<longrightarrow> v = v') \\<and>\n             (\\<forall>h ad al v h' h''.\n                 heap_write h ad al v h' \\<longrightarrow>\n                 heap_write h ad al v h'' \\<longrightarrow> h' = h'') \\<and>\n             (\\<forall>h hT h' a h'' a'.\n                 (h', a) \\<in> allocate h hT \\<longrightarrow>\n                 (h'', a') \\<in> allocate h hT \\<longrightarrow>\n                 h' = h'' \\<and> a = a') \\<and>\n             \\<not> spurious_wakeups;\n     heap_write h ad al v h'; heap_write h ad al v h''\\<rbrakk>\n    \\<Longrightarrow> h' = h''", "by blast"], ["", "lemma deterministic_heap_ops_allocateD:\n  \"\\<lbrakk> deterministic_heap_ops; (h', a) \\<in> allocate h hT; (h'', a') \\<in> allocate h hT \\<rbrakk> \\<Longrightarrow> h' = h'' \\<and> a = a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>deterministic_heap_ops; (h', a) \\<in> allocate h hT;\n     (h'', a') \\<in> allocate h hT\\<rbrakk>\n    \\<Longrightarrow> h' = h'' \\<and> a = a'", "unfolding deterministic_heap_ops_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>h ad al v v'.\n                 heap_read h ad al v \\<longrightarrow>\n                 heap_read h ad al v' \\<longrightarrow> v = v') \\<and>\n             (\\<forall>h ad al v h' h''.\n                 heap_write h ad al v h' \\<longrightarrow>\n                 heap_write h ad al v h'' \\<longrightarrow> h' = h'') \\<and>\n             (\\<forall>h hT h' a h'' a'.\n                 (h', a) \\<in> allocate h hT \\<longrightarrow>\n                 (h'', a') \\<in> allocate h hT \\<longrightarrow>\n                 h' = h'' \\<and> a = a') \\<and>\n             \\<not> spurious_wakeups;\n     (h', a) \\<in> allocate h hT; (h'', a') \\<in> allocate h hT\\<rbrakk>\n    \\<Longrightarrow> h' = h'' \\<and> a = a'", "by blast"], ["", "lemma deterministic_heap_ops_no_spurious_wakeups:\n  \"deterministic_heap_ops \\<Longrightarrow> \\<not> spurious_wakeups\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deterministic_heap_ops \\<Longrightarrow> \\<not> spurious_wakeups", "unfolding deterministic_heap_ops_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>h ad al v v'.\n        heap_read h ad al v \\<longrightarrow>\n        heap_read h ad al v' \\<longrightarrow> v = v') \\<and>\n    (\\<forall>h ad al v h' h''.\n        heap_write h ad al v h' \\<longrightarrow>\n        heap_write h ad al v h'' \\<longrightarrow> h' = h'') \\<and>\n    (\\<forall>h hT h' a h'' a'.\n        (h', a) \\<in> allocate h hT \\<longrightarrow>\n        (h'', a') \\<in> allocate h hT \\<longrightarrow>\n        h' = h'' \\<and> a = a') \\<and>\n    \\<not> spurious_wakeups \\<Longrightarrow>\n    \\<not> spurious_wakeups", "by blast"], ["", "end"], ["", "locale addr_conv =\n  heap_base\n    addr2thread_id thread_id2addr\n    spurious_wakeups\n    empty_heap allocate typeof_addr heap_read heap_write\n  +\n  prog P\n  for addr2thread_id :: \"('addr :: addr) \\<Rightarrow> 'thread_id\"\n  and thread_id2addr :: \"'thread_id \\<Rightarrow> 'addr\"\n  and spurious_wakeups :: bool\n  and empty_heap :: \"'heap\"\n  and allocate :: \"'heap \\<Rightarrow> htype \\<Rightarrow> ('heap \\<times> 'addr) set\"\n  and typeof_addr :: \"'heap \\<Rightarrow> 'addr \\<rightharpoonup> htype\"\n  and heap_read :: \"'heap \\<Rightarrow> 'addr \\<Rightarrow> addr_loc \\<Rightarrow> 'addr val \\<Rightarrow> bool\"\n  and heap_write :: \"'heap \\<Rightarrow> 'addr \\<Rightarrow> addr_loc \\<Rightarrow> 'addr val \\<Rightarrow> 'heap \\<Rightarrow> bool\"\n  and P :: \"'m prog\"\n  +\n  assumes addr2thread_id_inverse: \n  \"\\<lbrakk> typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>; P \\<turnstile> C \\<preceq>\\<^sup>* Thread \\<rbrakk> \\<Longrightarrow> thread_id2addr (addr2thread_id a) = a\"\nbegin"], ["", "lemma typeof_addr_thread_id2_addr_addr2thread_id [simp]:\n  \"\\<lbrakk> typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>; P \\<turnstile> C \\<preceq>\\<^sup>* Thread \\<rbrakk> \\<Longrightarrow> typeof_addr h (thread_id2addr (addr2thread_id a)) = \\<lfloor>Class_type C\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n     P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n    \\<Longrightarrow> typeof_addr h (thread_id2addr (addr2thread_id a)) =\n                      \\<lfloor>Class_type C\\<rfloor>", "by(simp add: addr2thread_id_inverse)"], ["", "end"], ["", "locale heap =\n  addr_conv\n    addr2thread_id thread_id2addr\n    spurious_wakeups\n    empty_heap allocate typeof_addr heap_read heap_write\n    P\n  for addr2thread_id :: \"('addr :: addr) \\<Rightarrow> 'thread_id\"\n  and thread_id2addr :: \"'thread_id \\<Rightarrow> 'addr\"\n  and spurious_wakeups :: bool\n  and empty_heap :: \"'heap\"\n  and allocate :: \"'heap \\<Rightarrow> htype \\<Rightarrow> ('heap \\<times> 'addr) set\"\n  and typeof_addr :: \"'heap \\<Rightarrow> 'addr \\<rightharpoonup> htype\"\n  and heap_read :: \"'heap \\<Rightarrow> 'addr \\<Rightarrow> addr_loc \\<Rightarrow> 'addr val \\<Rightarrow> bool\"\n  and heap_write :: \"'heap \\<Rightarrow> 'addr \\<Rightarrow> addr_loc \\<Rightarrow> 'addr val \\<Rightarrow> 'heap \\<Rightarrow> bool\"\n  and P :: \"'m prog\"\n  +\n  assumes allocate_SomeD: \"\\<lbrakk> (h', a) \\<in> allocate h hT; is_htype P hT \\<rbrakk> \\<Longrightarrow> typeof_addr h' a = Some hT\"\n\n  and hext_allocate: \"\\<And>a. (h', a) \\<in> allocate h hT \\<Longrightarrow> h \\<unlhd> h'\"\n\n  and hext_heap_write:\n  \"heap_write h a al v h' \\<Longrightarrow> h \\<unlhd> h'\"\n\nbegin"], ["", "lemmas hext_heap_ops = hext_allocate hext_heap_write"], ["", "lemma typeof_addr_hext_mono:\n  \"\\<lbrakk> h \\<unlhd> h'; typeof_addr h a = \\<lfloor>hT\\<rfloor> \\<rbrakk> \\<Longrightarrow> typeof_addr h' a = \\<lfloor>hT\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<unlhd> h'; typeof_addr h a = \\<lfloor>hT\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> typeof_addr h' a = \\<lfloor>hT\\<rfloor>", "unfolding hext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>typeof_addr h \\<subseteq>\\<^sub>m typeof_addr h';\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> typeof_addr h' a = \\<lfloor>hT\\<rfloor>", "by(rule map_le_SomeD)"], ["", "lemma hext_typeof_mono:\n  \"\\<lbrakk> h \\<unlhd> h'; typeof\\<^bsub>h\\<^esub> v = Some T \\<rbrakk> \\<Longrightarrow> typeof\\<^bsub>h'\\<^esub> v = Some T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<unlhd> h';\n     typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> typeof\\<^bsub>h'\\<^esub> v = \\<lfloor>T\\<rfloor>", "by (cases v)(auto intro: typeof_addr_hext_mono)"], ["", "lemma addr_loc_type_hext_mono:\n  \"\\<lbrakk> P,h \\<turnstile> a@al : T; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow> P,h' \\<turnstile> a@al : T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> a@al : T; h \\<unlhd> h'\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile> a@al : T", "by(force elim!: addr_loc_type.cases intro: addr_loc_type.intros elim: typeof_addr_hext_mono dest: hext_arrD)"], ["", "lemma type_of_hext_type_of: \\<comment> \\<open>FIXME: What's this rule good for?\\<close>\n  \"\\<lbrakk> typeof\\<^bsub>h\\<^esub> w = \\<lfloor>T\\<rfloor>; hext h h' \\<rbrakk> \\<Longrightarrow> typeof\\<^bsub>h'\\<^esub> w = \\<lfloor>T\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>typeof\\<^bsub>h\\<^esub> w = \\<lfloor>T\\<rfloor>;\n     h \\<unlhd> h'\\<rbrakk>\n    \\<Longrightarrow> typeof\\<^bsub>h'\\<^esub> w = \\<lfloor>T\\<rfloor>", "by(rule hext_typeof_mono)"], ["", "lemma hext_None: \"\\<lbrakk> h \\<unlhd> h'; typeof_addr h' a = None \\<rbrakk> \\<Longrightarrow> typeof_addr h a = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<unlhd> h'; typeof_addr h' a = None\\<rbrakk>\n    \\<Longrightarrow> typeof_addr h a = None", "by(rule ccontr)(auto dest: typeof_addr_hext_mono)"], ["", "lemma map_typeof_hext_mono:\n  \"\\<lbrakk> map typeof\\<^bsub>h\\<^esub> vs = map Some Ts; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow>  map typeof\\<^bsub>h'\\<^esub> vs = map Some Ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     h \\<unlhd> h'\\<rbrakk>\n    \\<Longrightarrow> map typeof\\<^bsub>h'\\<^esub> vs = map Some Ts", "apply(induct vs arbitrary: Ts)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Ts.\n       \\<lbrakk>map typeof\\<^bsub>h\\<^esub> [] = map Some Ts;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> map typeof\\<^bsub>h'\\<^esub> [] = map Some Ts\n 2. \\<And>a vs Ts.\n       \\<lbrakk>\\<And>Ts.\n                   \\<lbrakk>map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n                    h \\<unlhd> h'\\<rbrakk>\n                   \\<Longrightarrow> map typeof\\<^bsub>h'\\<^esub> vs =\n                                     map Some Ts;\n        map typeof\\<^bsub>h\\<^esub> (a # vs) = map Some Ts;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> map typeof\\<^bsub>h'\\<^esub> (a # vs) = map Some Ts", "apply(auto simp add: Cons_eq_map_conv intro: hext_typeof_mono)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hext_typeof_addr_map_le:\n  \"h \\<unlhd> h' \\<Longrightarrow> typeof_addr h \\<subseteq>\\<^sub>m typeof_addr h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<unlhd> h' \\<Longrightarrow>\n    typeof_addr h \\<subseteq>\\<^sub>m typeof_addr h'", "by(auto simp add: map_le_def dest: typeof_addr_hext_mono)"], ["", "lemma hext_dom_typeof_addr_subset:\n  \"h \\<unlhd> h' \\<Longrightarrow> dom (typeof_addr h) \\<subseteq> dom (typeof_addr h')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<unlhd> h' \\<Longrightarrow>\n    dom (typeof_addr h) \\<subseteq> dom (typeof_addr h')", "by (metis hext_typeof_addr_map_le map_le_implies_dom_le)"], ["", "end"], ["", "declare heap_base.typeof_h.simps [code]"], ["", "declare heap_base.cname_of_def [code]"], ["", "end"]]}