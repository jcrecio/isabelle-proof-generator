{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/JVM/JVMDefensive.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma jvmd_NormalD:\n  \"P,t \\<turnstile> Normal \\<sigma> -ta-jvmd\\<rightarrow> Normal \\<sigma>' \\<Longrightarrow> check P \\<sigma> \\<and> (ta, \\<sigma>') \\<in> exec P t \\<sigma> \\<and> (\\<exists>xcp h f frs. \\<sigma> = (xcp, h, f # frs))\"", "lemma jvmd_NormalE:\n  assumes \"P,t \\<turnstile> Normal \\<sigma> -ta-jvmd\\<rightarrow> Normal \\<sigma>'\"\n  obtains xcp h f frs where \"check P \\<sigma>\" \"(ta, \\<sigma>') \\<in> exec P t \\<sigma>\" \"\\<sigma> = (xcp, h, f # frs)\"", "lemma exec_d_eq_TypeError: \"exec_d P t \\<sigma> = TypeError \\<longleftrightarrow> \\<not> check P \\<sigma>\"", "lemma exec_d_eq_Normal: \"exec_d P t \\<sigma> = Normal (exec P t \\<sigma>) \\<longleftrightarrow> check P \\<sigma>\"", "lemma if_neq [dest!]:\n  \"(if P then A else B) \\<noteq> B \\<Longrightarrow> P\"", "lemma exec_d_no_errorI [intro]:\n  \"check P \\<sigma> \\<Longrightarrow> exec_d P t \\<sigma> \\<noteq> TypeError\"", "theorem no_type_error_commutes:\n  \"exec_d P t \\<sigma> \\<noteq> TypeError \\<Longrightarrow> exec_d P t \\<sigma> = Normal (exec P t \\<sigma>)\"", "lemma defensive_imp_aggressive_1:\n  \"P,t \\<turnstile> (Normal \\<sigma>) -tas-jvmd\\<rightarrow> (Normal \\<sigma>') \\<Longrightarrow> P,t \\<turnstile> \\<sigma> -tas-jvm\\<rightarrow> \\<sigma>'\"", "lemma check_exec_hext:\n  assumes exec: \"(ta, xcp', h', frs') \\<in> exec P t (xcp, h, frs)\"\n  and check: \"check P (xcp, h, frs)\"\n  shows \"h \\<unlhd> h'\"", "lemma exec_1_d_hext:\n  \"\\<lbrakk> P,t \\<turnstile> Normal (xcp, h, frs) -ta-jvmd\\<rightarrow> Normal (xcp', h', frs') \\<rbrakk> \\<Longrightarrow> h \\<unlhd> h'\""], "translations": [["", "lemma jvmd_NormalD:\n  \"P,t \\<turnstile> Normal \\<sigma> -ta-jvmd\\<rightarrow> Normal \\<sigma>' \\<Longrightarrow> check P \\<sigma> \\<and> (ta, \\<sigma>') \\<in> exec P t \\<sigma> \\<and> (\\<exists>xcp h f frs. \\<sigma> = (xcp, h, f # frs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,t \\<turnstile> Normal\n                      \\<sigma> -ta-jvmd\\<rightarrow> Normal\n                \\<sigma>' \\<Longrightarrow>\n    check P \\<sigma> \\<and>\n    (ta, \\<sigma>') \\<in> exec P t \\<sigma> \\<and>\n    (\\<exists>xcp h f frs. \\<sigma> = (xcp, h, f # frs))", "apply(erule exec_1_d.cases, auto simp add: exec_d_def split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ac ad ae af ba ag ah bb.\n       \\<lbrakk>((ab, ac, ad, ae, af, ba), ag, ah, bb)\n                \\<in> exec P t (a, aa, b);\n        \\<sigma> = (a, aa, b); ta = (ab, ac, ad, ae, af, ba);\n        \\<sigma>' = (ag, ah, bb); check P (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ab ac ba frs.\n                            b = (a, aa, ab, ac, ba) # frs", "apply(case_tac b, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma jvmd_NormalE:\n  assumes \"P,t \\<turnstile> Normal \\<sigma> -ta-jvmd\\<rightarrow> Normal \\<sigma>'\"\n  obtains xcp h f frs where \"check P \\<sigma>\" \"(ta, \\<sigma>') \\<in> exec P t \\<sigma>\" \"\\<sigma> = (xcp, h, f # frs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xcp h f frs.\n        \\<lbrakk>check P \\<sigma>; (ta, \\<sigma>') \\<in> exec P t \\<sigma>;\n         \\<sigma> = (xcp, h, f # frs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  P,t \\<turnstile> Normal \\<sigma> -ta-jvmd\\<rightarrow> Normal \\<sigma>'\n\ngoal (1 subgoal):\n 1. (\\<And>xcp h f frs.\n        \\<lbrakk>check P \\<sigma>; (ta, \\<sigma>') \\<in> exec P t \\<sigma>;\n         \\<sigma> = (xcp, h, f # frs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: jvmd_NormalD)"], ["", "lemma exec_d_eq_TypeError: \"exec_d P t \\<sigma> = TypeError \\<longleftrightarrow> \\<not> check P \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (exec_d P t \\<sigma> = TypeError) = (\\<not> check P \\<sigma>)", "by(simp add: exec_d_def)"], ["", "lemma exec_d_eq_Normal: \"exec_d P t \\<sigma> = Normal (exec P t \\<sigma>) \\<longleftrightarrow> check P \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (exec_d P t \\<sigma> = Normal (exec P t \\<sigma>)) = check P \\<sigma>", "by(auto simp add: exec_d_def)"], ["", "end"], ["", "declare split_paired_All [simp del]"], ["", "declare split_paired_Ex [simp del]"], ["", "lemma if_neq [dest!]:\n  \"(if P then A else B) \\<noteq> B \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if P then A else B) \\<noteq> B \\<Longrightarrow> P", "by (cases P, auto)"], ["", "context JVM_heap_base begin"], ["", "lemma exec_d_no_errorI [intro]:\n  \"check P \\<sigma> \\<Longrightarrow> exec_d P t \\<sigma> \\<noteq> TypeError\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check P \\<sigma> \\<Longrightarrow>\n    exec_d P t \\<sigma> \\<noteq> TypeError", "by (unfold exec_d_def) simp"], ["", "theorem no_type_error_commutes:\n  \"exec_d P t \\<sigma> \\<noteq> TypeError \\<Longrightarrow> exec_d P t \\<sigma> = Normal (exec P t \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_d P t \\<sigma> \\<noteq> TypeError \\<Longrightarrow>\n    exec_d P t \\<sigma> = Normal (exec P t \\<sigma>)", "by (unfold exec_d_def, auto)"], ["", "lemma defensive_imp_aggressive_1:\n  \"P,t \\<turnstile> (Normal \\<sigma>) -tas-jvmd\\<rightarrow> (Normal \\<sigma>') \\<Longrightarrow> P,t \\<turnstile> \\<sigma> -tas-jvm\\<rightarrow> \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,t \\<turnstile> Normal\n                      \\<sigma> -tas-jvmd\\<rightarrow> Normal\n                 \\<sigma>' \\<Longrightarrow>\n    P,t \\<turnstile> \\<sigma> -tas-jvm\\<rightarrow> \\<sigma>'", "by(auto elim!: exec_1_d.cases intro!: exec_1.intros simp add: exec_d_def split: if_split_asm)"], ["", "end"], ["", "context JVM_heap begin"], ["", "lemma check_exec_hext:\n  assumes exec: \"(ta, xcp', h', frs') \\<in> exec P t (xcp, h, frs)\"\n  and check: \"check P (xcp, h, frs)\"\n  shows \"h \\<unlhd> h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "from exec"], ["proof (chain)\npicking this:\n  (ta, xcp', h', frs') \\<in> exec P t (xcp, h, frs)", "have \"frs \\<noteq> []\""], ["proof (prove)\nusing this:\n  (ta, xcp', h', frs') \\<in> exec P t (xcp, h, frs)\n\ngoal (1 subgoal):\n 1. frs \\<noteq> []", "by(auto)"], ["proof (state)\nthis:\n  frs \\<noteq> []\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "then"], ["proof (chain)\npicking this:\n  frs \\<noteq> []", "obtain f Frs where frs [simp]: \"frs = f # Frs\""], ["proof (prove)\nusing this:\n  frs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>f Frs. frs = f # Frs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp add: neq_Nil_conv)"], ["proof (state)\nthis:\n  frs = f # Frs\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "obtain stk loc C0 M0 pc where f [simp]: \"f = (stk, loc, C0, M0, pc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>stk loc C0 M0 pc.\n        f = (stk, loc, C0, M0, pc) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases f, blast)"], ["proof (state)\nthis:\n  f = (stk, loc, C0, M0, pc)\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "proof(cases xcp)"], ["proof (state)\ngoal (2 subgoals):\n 1. xcp = None \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>a. xcp = \\<lfloor>a\\<rfloor> \\<Longrightarrow> h \\<unlhd> h'", "case None"], ["proof (state)\nthis:\n  xcp = None\n\ngoal (2 subgoals):\n 1. xcp = None \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>a. xcp = \\<lfloor>a\\<rfloor> \\<Longrightarrow> h \\<unlhd> h'", "with check"], ["proof (chain)\npicking this:\n  check P (xcp, h, frs)\n  xcp = None", "obtain C' Ts T mxs mxl0 ins xt\n      where mthd: \"P \\<turnstile> C0 sees M0 : Ts \\<rightarrow> T = \\<lfloor>(mxs, mxl0, ins, xt)\\<rfloor> in C'\"\n                  \"method P C0 M0 = (C', Ts, T, \\<lfloor>(mxs, mxl0, ins, xt)\\<rfloor>)\"\n      and check_ins: \"check_instr (ins ! pc) P h stk loc C0 M0 pc Frs\"\n      and \"pc < length ins\"\n      and \"length stk \\<le> mxs\""], ["proof (prove)\nusing this:\n  check P (xcp, h, frs)\n  xcp = None\n\ngoal (1 subgoal):\n 1. (\\<And>Ts T mxs mxl0 ins xt C'.\n        \\<lbrakk>P \\<turnstile> C0 sees M0: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                                   mxl0, ins, xt)\\<rfloor> in C';\n         method P C0 M0 =\n         (C', Ts, T, \\<lfloor>(mxs, mxl0, ins, xt)\\<rfloor>);\n         check_instr (ins ! pc) P h stk loc C0 M0 pc Frs; pc < length ins;\n         length stk \\<le> mxs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: check_def has_method_def)"], ["proof (state)\nthis:\n  P \\<turnstile> C0 sees M0: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl0, ins,\n                    xt)\\<rfloor> in C'\n  method P C0 M0 = (C', Ts, T, \\<lfloor>(mxs, mxl0, ins, xt)\\<rfloor>)\n  check_instr (ins ! pc) P h stk loc C0 M0 pc Frs\n  pc < length ins\n  length stk \\<le> mxs\n\ngoal (2 subgoals):\n 1. xcp = None \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>a. xcp = \\<lfloor>a\\<rfloor> \\<Longrightarrow> h \\<unlhd> h'", "from None exec mthd"], ["proof (chain)\npicking this:\n  xcp = None\n  (ta, xcp', h', frs') \\<in> exec P t (xcp, h, frs)\n  P \\<turnstile> C0 sees M0: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl0, ins,\n                    xt)\\<rfloor> in C'\n  method P C0 M0 = (C', Ts, T, \\<lfloor>(mxs, mxl0, ins, xt)\\<rfloor>)", "have xexec: \"(ta, xcp', h', frs') \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs\""], ["proof (prove)\nusing this:\n  xcp = None\n  (ta, xcp', h', frs') \\<in> exec P t (xcp, h, frs)\n  P \\<turnstile> C0 sees M0: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl0, ins,\n                    xt)\\<rfloor> in C'\n  method P C0 M0 = (C', Ts, T, \\<lfloor>(mxs, mxl0, ins, xt)\\<rfloor>)\n\ngoal (1 subgoal):\n 1. (ta, xcp', h', frs')\n    \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs", "by(clarsimp)"], ["proof (state)\nthis:\n  (ta, xcp', h', frs')\n  \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs\n\ngoal (2 subgoals):\n 1. xcp = None \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>a. xcp = \\<lfloor>a\\<rfloor> \\<Longrightarrow> h \\<unlhd> h'", "thus ?thesis"], ["proof (prove)\nusing this:\n  (ta, xcp', h', frs')\n  \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "proof(cases \"ins ! pc\")"], ["proof (state)\ngoal (24 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 4. \\<And>x4.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 5. \\<And>x5.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 6. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 7. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = AStore\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 8. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 9. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 10. \\<And>x101 x102.\n        \\<lbrakk>(ta, xcp', h', frs')\n                 \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n         ins ! pc = Putfield x101 x102\\<rbrakk>\n        \\<Longrightarrow> h \\<unlhd> h'\nA total of 24 subgoals...", "case (New C)"], ["proof (state)\nthis:\n  ins ! pc = New C\n\ngoal (24 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 4. \\<And>x4.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 5. \\<And>x5.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 6. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 7. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = AStore\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 8. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 9. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 10. \\<And>x101 x102.\n        \\<lbrakk>(ta, xcp', h', frs')\n                 \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n         ins ! pc = Putfield x101 x102\\<rbrakk>\n        \\<Longrightarrow> h \\<unlhd> h'\nA total of 24 subgoals...", "with xexec"], ["proof (chain)\npicking this:\n  (ta, xcp', h', frs')\n  \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs\n  ins ! pc = New C", "show ?thesis"], ["proof (prove)\nusing this:\n  (ta, xcp', h', frs')\n  \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs\n  ins ! pc = New C\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "by(auto intro: hext_allocate split: if_split_asm)"], ["proof (state)\nthis:\n  h \\<unlhd> h'\n\ngoal (23 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 4. \\<And>x5.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 5. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 6. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = AStore\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 7. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 8. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 9. \\<And>x101 x102.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Putfield x101 x102\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 10. \\<And>x111 x112.\n        \\<lbrakk>(ta, xcp', h', frs')\n                 \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n         ins ! pc = CAS x111 x112\\<rbrakk>\n        \\<Longrightarrow> h \\<unlhd> h'\nA total of 23 subgoals...", "next"], ["proof (state)\ngoal (23 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 4. \\<And>x5.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 5. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 6. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = AStore\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 7. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 8. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 9. \\<And>x101 x102.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Putfield x101 x102\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 10. \\<And>x111 x112.\n        \\<lbrakk>(ta, xcp', h', frs')\n                 \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n         ins ! pc = CAS x111 x112\\<rbrakk>\n        \\<Longrightarrow> h \\<unlhd> h'\nA total of 23 subgoals...", "case (NewArray T)"], ["proof (state)\nthis:\n  ins ! pc = NewArray T\n\ngoal (23 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 4. \\<And>x5.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 5. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 6. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = AStore\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 7. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 8. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 9. \\<And>x101 x102.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Putfield x101 x102\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 10. \\<And>x111 x112.\n        \\<lbrakk>(ta, xcp', h', frs')\n                 \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n         ins ! pc = CAS x111 x112\\<rbrakk>\n        \\<Longrightarrow> h \\<unlhd> h'\nA total of 23 subgoals...", "with xexec"], ["proof (chain)\npicking this:\n  (ta, xcp', h', frs')\n  \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs\n  ins ! pc = NewArray T", "show ?thesis"], ["proof (prove)\nusing this:\n  (ta, xcp', h', frs')\n  \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs\n  ins ! pc = NewArray T\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "by(auto intro: hext_allocate split: if_split_asm)"], ["proof (state)\nthis:\n  h \\<unlhd> h'\n\ngoal (22 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 4. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 5. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = AStore\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 6. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 7. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 8. \\<And>x101 x102.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Putfield x101 x102\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 9. \\<And>x111 x112.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = CAS x111 x112\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 10. \\<And>x12.\n        \\<lbrakk>(ta, xcp', h', frs')\n                 \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n         ins ! pc = Checkcast x12\\<rbrakk>\n        \\<Longrightarrow> h \\<unlhd> h'\nA total of 22 subgoals...", "next"], ["proof (state)\ngoal (22 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 4. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 5. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = AStore\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 6. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 7. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 8. \\<And>x101 x102.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Putfield x101 x102\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 9. \\<And>x111 x112.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = CAS x111 x112\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 10. \\<And>x12.\n        \\<lbrakk>(ta, xcp', h', frs')\n                 \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n         ins ! pc = Checkcast x12\\<rbrakk>\n        \\<Longrightarrow> h \\<unlhd> h'\nA total of 22 subgoals...", "case AStore"], ["proof (state)\nthis:\n  ins ! pc = AStore\n\ngoal (22 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 4. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 5. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = AStore\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 6. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 7. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 8. \\<And>x101 x102.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Putfield x101 x102\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 9. \\<And>x111 x112.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = CAS x111 x112\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 10. \\<And>x12.\n        \\<lbrakk>(ta, xcp', h', frs')\n                 \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n         ins ! pc = Checkcast x12\\<rbrakk>\n        \\<Longrightarrow> h \\<unlhd> h'\nA total of 22 subgoals...", "with xexec check_ins"], ["proof (chain)\npicking this:\n  (ta, xcp', h', frs')\n  \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs\n  check_instr (ins ! pc) P h stk loc C0 M0 pc Frs\n  ins ! pc = AStore", "show ?thesis"], ["proof (prove)\nusing this:\n  (ta, xcp', h', frs')\n  \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs\n  check_instr (ins ! pc) P h stk loc C0 M0 pc Frs\n  ins ! pc = AStore\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "by(auto simp add: split_beta split: if_split_asm intro: hext_heap_write)"], ["proof (state)\nthis:\n  h \\<unlhd> h'\n\ngoal (21 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 4. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 5. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 6. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 7. \\<And>x101 x102.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Putfield x101 x102\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 8. \\<And>x111 x112.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = CAS x111 x112\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 9. \\<And>x12.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Checkcast x12\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 10. \\<And>x13.\n        \\<lbrakk>(ta, xcp', h', frs')\n                 \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n         ins ! pc = Instanceof x13\\<rbrakk>\n        \\<Longrightarrow> h \\<unlhd> h'\nA total of 21 subgoals...", "next"], ["proof (state)\ngoal (21 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 4. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 5. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 6. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 7. \\<And>x101 x102.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Putfield x101 x102\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 8. \\<And>x111 x112.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = CAS x111 x112\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 9. \\<And>x12.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Checkcast x12\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 10. \\<And>x13.\n        \\<lbrakk>(ta, xcp', h', frs')\n                 \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n         ins ! pc = Instanceof x13\\<rbrakk>\n        \\<Longrightarrow> h \\<unlhd> h'\nA total of 21 subgoals...", "case Putfield"], ["proof (state)\nthis:\n  ins ! pc = Putfield x101_ x102_\n\ngoal (21 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 4. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 5. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 6. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 7. \\<And>x101 x102.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Putfield x101 x102\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 8. \\<And>x111 x112.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = CAS x111 x112\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 9. \\<And>x12.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Checkcast x12\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 10. \\<And>x13.\n        \\<lbrakk>(ta, xcp', h', frs')\n                 \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n         ins ! pc = Instanceof x13\\<rbrakk>\n        \\<Longrightarrow> h \\<unlhd> h'\nA total of 21 subgoals...", "with xexec check_ins"], ["proof (chain)\npicking this:\n  (ta, xcp', h', frs')\n  \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs\n  check_instr (ins ! pc) P h stk loc C0 M0 pc Frs\n  ins ! pc = Putfield x101_ x102_", "show ?thesis"], ["proof (prove)\nusing this:\n  (ta, xcp', h', frs')\n  \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs\n  check_instr (ins ! pc) P h stk loc C0 M0 pc Frs\n  ins ! pc = Putfield x101_ x102_\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "by(auto intro: hext_heap_write simp add: split_beta split: if_split_asm)"], ["proof (state)\nthis:\n  h \\<unlhd> h'\n\ngoal (20 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 4. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 5. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 6. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 7. \\<And>x111 x112.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = CAS x111 x112\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 8. \\<And>x12.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Checkcast x12\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 9. \\<And>x13.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Instanceof x13\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 10. \\<And>x141 x142.\n        \\<lbrakk>(ta, xcp', h', frs')\n                 \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n         ins ! pc = Invoke x141 x142\\<rbrakk>\n        \\<Longrightarrow> h \\<unlhd> h'\nA total of 20 subgoals...", "next"], ["proof (state)\ngoal (20 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 4. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 5. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 6. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 7. \\<And>x111 x112.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = CAS x111 x112\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 8. \\<And>x12.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Checkcast x12\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 9. \\<And>x13.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Instanceof x13\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 10. \\<And>x141 x142.\n        \\<lbrakk>(ta, xcp', h', frs')\n                 \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n         ins ! pc = Invoke x141 x142\\<rbrakk>\n        \\<Longrightarrow> h \\<unlhd> h'\nA total of 20 subgoals...", "case CAS"], ["proof (state)\nthis:\n  ins ! pc = CAS x111_ x112_\n\ngoal (20 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 4. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 5. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 6. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 7. \\<And>x111 x112.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = CAS x111 x112\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 8. \\<And>x12.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Checkcast x12\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 9. \\<And>x13.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Instanceof x13\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 10. \\<And>x141 x142.\n        \\<lbrakk>(ta, xcp', h', frs')\n                 \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n         ins ! pc = Invoke x141 x142\\<rbrakk>\n        \\<Longrightarrow> h \\<unlhd> h'\nA total of 20 subgoals...", "with xexec check_ins"], ["proof (chain)\npicking this:\n  (ta, xcp', h', frs')\n  \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs\n  check_instr (ins ! pc) P h stk loc C0 M0 pc Frs\n  ins ! pc = CAS x111_ x112_", "show ?thesis"], ["proof (prove)\nusing this:\n  (ta, xcp', h', frs')\n  \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs\n  check_instr (ins ! pc) P h stk loc C0 M0 pc Frs\n  ins ! pc = CAS x111_ x112_\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "by(auto intro: hext_heap_write simp add: split_beta split: if_split_asm)"], ["proof (state)\nthis:\n  h \\<unlhd> h'\n\ngoal (19 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 4. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 5. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 6. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 7. \\<And>x12.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Checkcast x12\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 8. \\<And>x13.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Instanceof x13\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 9. \\<And>x141 x142.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Invoke x141 x142\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 10. \\<lbrakk>(ta, xcp', h', frs')\n              \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n      ins ! pc = Return\\<rbrakk>\n     \\<Longrightarrow> h \\<unlhd> h'\nA total of 19 subgoals...", "next"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 4. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 5. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 6. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 7. \\<And>x12.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Checkcast x12\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 8. \\<And>x13.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Instanceof x13\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 9. \\<And>x141 x142.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Invoke x141 x142\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 10. \\<lbrakk>(ta, xcp', h', frs')\n              \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n      ins ! pc = Return\\<rbrakk>\n     \\<Longrightarrow> h \\<unlhd> h'\nA total of 19 subgoals...", "case (Invoke M n)"], ["proof (state)\nthis:\n  ins ! pc = Invoke M n\n\ngoal (19 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 4. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 5. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 6. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 7. \\<And>x12.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Checkcast x12\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 8. \\<And>x13.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Instanceof x13\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 9. \\<And>x141 x142.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Invoke x141 x142\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 10. \\<lbrakk>(ta, xcp', h', frs')\n              \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n      ins ! pc = Return\\<rbrakk>\n     \\<Longrightarrow> h \\<unlhd> h'\nA total of 19 subgoals...", "with xexec check_ins"], ["proof (chain)\npicking this:\n  (ta, xcp', h', frs')\n  \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs\n  check_instr (ins ! pc) P h stk loc C0 M0 pc Frs\n  ins ! pc = Invoke M n", "show ?thesis"], ["proof (prove)\nusing this:\n  (ta, xcp', h', frs')\n  \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs\n  check_instr (ins ! pc) P h stk loc C0 M0 pc Frs\n  ins ! pc = Invoke M n\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "apply(auto simp add: min_def split_beta is_Ref_def extRet2JVM_def has_method_def\n                split: if_split_asm intro: red_external_aggr_hext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y Ts T x a aa ab ac ad ae b va h'a.\n       \\<lbrakk>ins ! pc = Invoke M n; n < length stk;\n        P,h \\<turnstile> rev (take n stk) [:\\<le>] Ts; x\\<bullet>M(Ts) :: T;\n        typeof_addr h a = \\<lfloor>y\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        y sees M: Ts\\<rightarrow>T = Native in x;\n        stk ! n = Addr a;\n        ta =\n        (aa, map (convert_new_thread_action (extNTA2JVM P)) ab, ac, ad, ae,\n         b);\n        (xcp', h', frs') =\n        (case va of\n         RetVal v \\<Rightarrow>\n           \\<lambda>n h stk loc C M pc frs.\n              (None, h, (v # drop (Suc n) stk, loc, C, M, Suc pc) # frs)\n         | RetExc a \\<Rightarrow>\n             \\<lambda>n h stk loc C M pc frs.\n                (\\<lfloor>a\\<rfloor>, h, (stk, loc, C, M, pc) # frs)\n         | RetStaySame \\<Rightarrow>\n             \\<lambda>n h stk loc C M pc frs.\n                (None, h, (stk, loc, C, M, pc) # frs))\n         n h'a stk loc C0 M0 pc Frs;\n        ((aa, ab, ac, ad, ae, b), va, h'a)\n        \\<in> red_external_aggr P t a M (rev (take n stk)) h\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'", "apply(case_tac va)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y Ts T x a aa ab ac ad ae b va h'a x1.\n       \\<lbrakk>ins ! pc = Invoke M n; n < length stk;\n        P,h \\<turnstile> rev (take n stk) [:\\<le>] Ts; x\\<bullet>M(Ts) :: T;\n        typeof_addr h a = \\<lfloor>y\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        y sees M: Ts\\<rightarrow>T = Native in x;\n        stk ! n = Addr a;\n        ta =\n        (aa, map (convert_new_thread_action (extNTA2JVM P)) ab, ac, ad, ae,\n         b);\n        (xcp', h', frs') =\n        (case va of\n         RetVal v \\<Rightarrow>\n           \\<lambda>n h stk loc C M pc frs.\n              (None, h, (v # drop (Suc n) stk, loc, C, M, Suc pc) # frs)\n         | RetExc a \\<Rightarrow>\n             \\<lambda>n h stk loc C M pc frs.\n                (\\<lfloor>a\\<rfloor>, h, (stk, loc, C, M, pc) # frs)\n         | RetStaySame \\<Rightarrow>\n             \\<lambda>n h stk loc C M pc frs.\n                (None, h, (stk, loc, C, M, pc) # frs))\n         n h'a stk loc C0 M0 pc Frs;\n        ((aa, ab, ac, ad, ae, b), va, h'a)\n        \\<in> red_external_aggr P t a M (rev (take n stk)) h;\n        va = RetVal x1\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>y Ts T x a aa ab ac ad ae b va h'a x2.\n       \\<lbrakk>ins ! pc = Invoke M n; n < length stk;\n        P,h \\<turnstile> rev (take n stk) [:\\<le>] Ts; x\\<bullet>M(Ts) :: T;\n        typeof_addr h a = \\<lfloor>y\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        y sees M: Ts\\<rightarrow>T = Native in x;\n        stk ! n = Addr a;\n        ta =\n        (aa, map (convert_new_thread_action (extNTA2JVM P)) ab, ac, ad, ae,\n         b);\n        (xcp', h', frs') =\n        (case va of\n         RetVal v \\<Rightarrow>\n           \\<lambda>n h stk loc C M pc frs.\n              (None, h, (v # drop (Suc n) stk, loc, C, M, Suc pc) # frs)\n         | RetExc a \\<Rightarrow>\n             \\<lambda>n h stk loc C M pc frs.\n                (\\<lfloor>a\\<rfloor>, h, (stk, loc, C, M, pc) # frs)\n         | RetStaySame \\<Rightarrow>\n             \\<lambda>n h stk loc C M pc frs.\n                (None, h, (stk, loc, C, M, pc) # frs))\n         n h'a stk loc C0 M0 pc Frs;\n        ((aa, ab, ac, ad, ae, b), va, h'a)\n        \\<in> red_external_aggr P t a M (rev (take n stk)) h;\n        va = RetExc x2\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 3. \\<And>y Ts T x a aa ab ac ad ae b va h'a.\n       \\<lbrakk>ins ! pc = Invoke M n; n < length stk;\n        P,h \\<turnstile> rev (take n stk) [:\\<le>] Ts; x\\<bullet>M(Ts) :: T;\n        typeof_addr h a = \\<lfloor>y\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        y sees M: Ts\\<rightarrow>T = Native in x;\n        stk ! n = Addr a;\n        ta =\n        (aa, map (convert_new_thread_action (extNTA2JVM P)) ab, ac, ad, ae,\n         b);\n        (xcp', h', frs') =\n        (case va of\n         RetVal v \\<Rightarrow>\n           \\<lambda>n h stk loc C M pc frs.\n              (None, h, (v # drop (Suc n) stk, loc, C, M, Suc pc) # frs)\n         | RetExc a \\<Rightarrow>\n             \\<lambda>n h stk loc C M pc frs.\n                (\\<lfloor>a\\<rfloor>, h, (stk, loc, C, M, pc) # frs)\n         | RetStaySame \\<Rightarrow>\n             \\<lambda>n h stk loc C M pc frs.\n                (None, h, (stk, loc, C, M, pc) # frs))\n         n h'a stk loc C0 M0 pc Frs;\n        ((aa, ab, ac, ad, ae, b), va, h'a)\n        \\<in> red_external_aggr P t a M (rev (take n stk)) h;\n        va = RetStaySame\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'", "apply(auto 4 3 intro: red_external_aggr_hext is_native.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  h \\<unlhd> h'\n\ngoal (18 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 4. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 5. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 6. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 7. \\<And>x12.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Checkcast x12\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 8. \\<And>x13.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Instanceof x13\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 9. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = Return\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 10. \\<lbrakk>(ta, xcp', h', frs')\n              \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n      ins ! pc = Pop\\<rbrakk>\n     \\<Longrightarrow> h \\<unlhd> h'\nA total of 18 subgoals...", "next"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 4. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 5. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 6. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 7. \\<And>x12.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Checkcast x12\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 8. \\<And>x13.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Instanceof x13\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 9. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = Return\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 10. \\<lbrakk>(ta, xcp', h', frs')\n              \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n      ins ! pc = Pop\\<rbrakk>\n     \\<Longrightarrow> h \\<unlhd> h'\nA total of 18 subgoals...", "case (BinOpInstr bop)"], ["proof (state)\nthis:\n  ins ! pc = BinOpInstr bop\n\ngoal (18 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 4. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 5. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 6. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 7. \\<And>x12.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Checkcast x12\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 8. \\<And>x13.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Instanceof x13\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 9. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = Return\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 10. \\<lbrakk>(ta, xcp', h', frs')\n              \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n      ins ! pc = Pop\\<rbrakk>\n     \\<Longrightarrow> h \\<unlhd> h'\nA total of 18 subgoals...", "with xexec check_ins"], ["proof (chain)\npicking this:\n  (ta, xcp', h', frs')\n  \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs\n  check_instr (ins ! pc) P h stk loc C0 M0 pc Frs\n  ins ! pc = BinOpInstr bop", "show ?thesis"], ["proof (prove)\nusing this:\n  (ta, xcp', h', frs')\n  \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs\n  check_instr (ins ! pc) P h stk loc C0 M0 pc Frs\n  ins ! pc = BinOpInstr bop\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "by(auto split: sum.split_asm)"], ["proof (state)\nthis:\n  h \\<unlhd> h'\n\ngoal (17 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 4. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 5. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 6. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 7. \\<And>x12.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Checkcast x12\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 8. \\<And>x13.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n        ins ! pc = Instanceof x13\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 9. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n     ins ! pc = Return\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h'\n 10. \\<lbrakk>(ta, xcp', h', frs')\n              \\<in> exec_instr (ins ! pc) P t h stk loc C0 M0 pc Frs;\n      ins ! pc = Pop\\<rbrakk>\n     \\<Longrightarrow> h \\<unlhd> h'\nA total of 17 subgoals...", "qed(auto simp add: split_beta split: if_split_asm)"], ["proof (state)\nthis:\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. \\<And>a. xcp = \\<lfloor>a\\<rfloor> \\<Longrightarrow> h \\<unlhd> h'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. xcp = \\<lfloor>a\\<rfloor> \\<Longrightarrow> h \\<unlhd> h'", "case (Some a)"], ["proof (state)\nthis:\n  xcp = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a. xcp = \\<lfloor>a\\<rfloor> \\<Longrightarrow> h \\<unlhd> h'", "with exec"], ["proof (chain)\npicking this:\n  (ta, xcp', h', frs') \\<in> exec P t (xcp, h, frs)\n  xcp = \\<lfloor>a\\<rfloor>", "have \"h' = h\""], ["proof (prove)\nusing this:\n  (ta, xcp', h', frs') \\<in> exec P t (xcp, h, frs)\n  xcp = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. h' = h", "by auto"], ["proof (state)\nthis:\n  h' = h\n\ngoal (1 subgoal):\n 1. \\<And>a. xcp = \\<lfloor>a\\<rfloor> \\<Longrightarrow> h \\<unlhd> h'", "thus ?thesis"], ["proof (prove)\nusing this:\n  h' = h\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "by auto"], ["proof (state)\nthis:\n  h \\<unlhd> h'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  h \\<unlhd> h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exec_1_d_hext:\n  \"\\<lbrakk> P,t \\<turnstile> Normal (xcp, h, frs) -ta-jvmd\\<rightarrow> Normal (xcp', h', frs') \\<rbrakk> \\<Longrightarrow> h \\<unlhd> h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,t \\<turnstile> Normal\n                      (xcp, h,\n                       frs) -ta-jvmd\\<rightarrow> Normal\n             (xcp', h', frs') \\<Longrightarrow>\n    h \\<unlhd> h'", "by(auto elim!: exec_1_d.cases simp add: exec_d_def split: if_split_asm intro: check_exec_hext)"], ["", "end"], ["", "end"]]}