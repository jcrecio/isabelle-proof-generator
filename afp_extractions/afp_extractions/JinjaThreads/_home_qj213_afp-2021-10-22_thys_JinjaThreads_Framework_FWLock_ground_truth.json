{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Framework/FWLock.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma has_locks_iff: \n  \"has_locks l t = n \\<longleftrightarrow>\n  (l = None \\<and> n = 0) \\<or> \n  (\\<exists>n'. l = \\<lfloor>(t, n')\\<rfloor> \\<and> Suc n' = n) \\<or> (\\<exists>t' n'. l = \\<lfloor>(t', n')\\<rfloor> \\<and> t' \\<noteq> t \\<and> n = 0)\"", "lemma has_locksE:\n  \"\\<lbrakk> has_locks l t = n;\n     \\<lbrakk> l = None; n = 0 \\<rbrakk> \\<Longrightarrow> P;\n     \\<And>n'. \\<lbrakk> l = \\<lfloor>(t, n')\\<rfloor>; Suc n' = n \\<rbrakk> \\<Longrightarrow> P;\n     \\<And>t' n'. \\<lbrakk> l = \\<lfloor>(t', n')\\<rfloor>; t' \\<noteq> t; n = 0 \\<rbrakk> \\<Longrightarrow> P \\<rbrakk>\n  \\<Longrightarrow> P\"", "lemma may_lock_iff [code]:\n  \"may_lock l t = (case l of None \\<Rightarrow> True | \\<lfloor>(t', n)\\<rfloor> \\<Rightarrow> t = t')\"", "lemma may_lockI:\n  \"l = None \\<or> (\\<exists>n. l = \\<lfloor>(t, n)\\<rfloor>) \\<Longrightarrow> may_lock l t\"", "lemma may_lockE [consumes 1, case_names None Locked]:\n  \"\\<lbrakk> may_lock l t; l = None \\<Longrightarrow> P; \\<And>n. l = \\<lfloor>(t, n)\\<rfloor>  \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma may_lock_may_lock_t_eq:\n  \"\\<lbrakk> may_lock l t; may_lock l t' \\<rbrakk> \\<Longrightarrow> (l = None) \\<or> (t = t')\"", "lemma has_locks_Suc_has_lock:\n  \"has_locks l t = Suc n \\<Longrightarrow> has_lock l t\"", "lemmas has_lock_has_locks_Suc = gr0_implies_Suc[where n = \"has_locks l t\"] for l t", "lemma has_lock_has_locks_conv:\n  \"has_lock l t \\<longleftrightarrow> (\\<exists>n. has_locks l t = (Suc n))\"", "lemma has_lock_may_lock:\n  \"has_lock l t \\<Longrightarrow> may_lock l t\"", "lemma has_lock_may_lock_t_eq:\n  \"\\<lbrakk> has_lock l t; may_lock l t' \\<rbrakk> \\<Longrightarrow> t = t'\"", "lemma has_locks_has_locks_t_eq: \n  \"\\<lbrakk>has_locks l t = Suc n; has_locks l t' = Suc n'\\<rbrakk> \\<Longrightarrow> t = t'\"", "lemma has_lock_has_lock_t_eq:\n  \"\\<lbrakk> has_lock l t; has_lock l t' \\<rbrakk> \\<Longrightarrow> t = t'\"", "lemma not_may_lock_conv:\n  \"\\<not> may_lock l t \\<longleftrightarrow> (\\<exists>t'. t' \\<noteq> t \\<and> has_lock l t')\"", "lemma acquire_locks_conv:\n  \"acquire_locks L t n = (case L of None \\<Rightarrow> (case n of 0 \\<Rightarrow> None | Suc m \\<Rightarrow> \\<lfloor>(t, m)\\<rfloor>) | \\<lfloor>(t', m)\\<rfloor> \\<Rightarrow> \\<lfloor>(t', n + m)\\<rfloor>)\"", "lemma lock_lock_ls_Some:\n  \"\\<exists>t' n. lock_lock l t = \\<lfloor>(t', n)\\<rfloor>\"", "lemma unlock_lock_SomeD:\n  \"unlock_lock l = \\<lfloor>(t', n)\\<rfloor> \\<Longrightarrow> l = \\<lfloor>(t', Suc n)\\<rfloor>\"", "lemma has_locks_Suc_lock_lock_has_locks_Suc_Suc:\n  \"has_locks l t = Suc n \\<Longrightarrow> has_locks (lock_lock l t) t = Suc (Suc n)\"", "lemma has_locks_lock_lock_conv [simp]:\n  \"may_lock l t \\<Longrightarrow> has_locks (lock_lock l t) t = Suc (has_locks l t)\"", "lemma has_locks_release_all_conv [simp]:\n  \"has_locks (release_all l t) t = 0\"", "lemma may_lock_lock_lock_conv [simp]: \"may_lock (lock_lock l t) t = may_lock l t\"", "lemma has_locks_acquire_locks_conv [simp]:\n  \"may_lock l t \\<Longrightarrow> has_locks (acquire_locks l t n) t = has_locks l t + n\"", "lemma may_lock_unlock_lock_conv [simp]:\n  \"has_lock l t \\<Longrightarrow> may_lock (unlock_lock l) t = may_lock l t\"", "lemma may_lock_release_all_conv [simp]:\n  \"may_lock (release_all l t) t = may_lock l t\"", "lemma may_lock_t_may_lock_unlock_lock_t: \n  \"may_lock l t \\<Longrightarrow> may_lock (unlock_lock l) t\"", "lemma may_lock_has_locks_lock_lock_0: \n  \"\\<lbrakk>may_lock l t'; t \\<noteq> t'\\<rbrakk> \\<Longrightarrow> has_locks (lock_lock l t') t = 0\"", "lemma has_locks_unlock_lock_conv [simp]:\n  \"has_lock l t \\<Longrightarrow> has_locks (unlock_lock l) t = has_locks l t - 1\"", "lemma has_lock_lock_lock_unlock_lock_id [simp]:\n  \"has_lock l t \\<Longrightarrow> lock_lock (unlock_lock l) t = l\"", "lemma may_lock_unlock_lock_lock_lock_id [simp]:\n  \"may_lock l t \\<Longrightarrow> unlock_lock (lock_lock l t) = l\"", "lemma may_lock_has_locks_0:\n  \"\\<lbrakk> may_lock l t; t \\<noteq> t' \\<rbrakk> \\<Longrightarrow> has_locks l t' = 0\"", "lemma upd_locks_append [simp]:\n  \"upd_locks l t (Ls @ Ls') = upd_locks (upd_locks l t Ls) t Ls'\"", "lemma upd_lock_Some_thread_idD:\n  assumes ul: \"upd_lock l t L = \\<lfloor>(t', n)\\<rfloor>\"\n  and tt': \"t \\<noteq> t'\"\n  shows \"\\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>\"", "lemma has_lock_upd_lock_implies_has_lock:\n  \"\\<lbrakk> has_lock (upd_lock l t L) t'; t \\<noteq> t' \\<rbrakk> \\<Longrightarrow> has_lock l t'\"", "lemma has_lock_upd_locks_implies_has_lock:\n  \"\\<lbrakk> has_lock (upd_locks l t Ls) t'; t \\<noteq> t' \\<rbrakk> \\<Longrightarrow> has_lock l t'\"", "lemma lock_actions_ok_append [simp]:\n  \"lock_actions_ok l t (Ls @ Ls') \\<longleftrightarrow> lock_actions_ok l t Ls \\<and> lock_actions_ok (upd_locks l t Ls) t Ls'\"", "lemma not_lock_action_okE [consumes 1, case_names Lock Unlock UnlockFail]:\n  \"\\<lbrakk> \\<not> lock_action_ok l t L;\n     \\<lbrakk> L = Lock; \\<not> may_lock l t \\<rbrakk> \\<Longrightarrow> Q;\n     \\<lbrakk> L = Unlock; \\<not> has_lock l t \\<rbrakk> \\<Longrightarrow> Q;\n     \\<lbrakk> L = UnlockFail; has_lock l t \\<rbrakk> \\<Longrightarrow> Q\\<rbrakk>\n  \\<Longrightarrow> Q\"", "lemma may_lock_upd_lock_conv [simp]:\n  \"lock_action_ok l t L \\<Longrightarrow> may_lock (upd_lock l t L) t = may_lock l t\"", "lemma may_lock_upd_locks_conv [simp]:\n  \"lock_actions_ok l t Ls \\<Longrightarrow> may_lock (upd_locks l t Ls) t = may_lock l t\"", "lemma lock_actions_ok_Lock_may_lock:\n  \"\\<lbrakk> lock_actions_ok l t Ls; Lock \\<in> set Ls \\<rbrakk> \\<Longrightarrow> may_lock l t\"", "lemma has_locks_lock_lock_conv' [simp]:\n  \"\\<lbrakk> may_lock l t'; t \\<noteq> t' \\<rbrakk> \\<Longrightarrow> has_locks (lock_lock l t') t = has_locks l t\"", "lemma has_locks_unlock_lock_conv' [simp]:\n  \"\\<lbrakk> has_lock l t'; t \\<noteq> t' \\<rbrakk> \\<Longrightarrow> has_locks (unlock_lock l) t = has_locks l t\"", "lemma has_locks_release_all_conv' [simp]:\n  \"t \\<noteq> t' \\<Longrightarrow> has_locks (release_all l t') t = has_locks l t\"", "lemma has_locks_acquire_locks_conv' [simp]:\n  \"\\<lbrakk> may_lock l t; t \\<noteq> t' \\<rbrakk> \\<Longrightarrow> has_locks (acquire_locks l t n) t' = has_locks l t'\"", "lemma lock_action_ok_has_locks_upd_lock_eq_has_locks [simp]:\n  \"\\<lbrakk> lock_action_ok l t' L; t \\<noteq> t' \\<rbrakk> \\<Longrightarrow> has_locks (upd_lock l t' L) t = has_locks l t\"", "lemma lock_actions_ok_has_locks_upd_locks_eq_has_locks [simp]:\n  \"\\<lbrakk> lock_actions_ok l t' Ls; t \\<noteq> t' \\<rbrakk> \\<Longrightarrow> has_locks (upd_locks l t' Ls) t = has_locks l t\"", "lemma has_lock_acquire_locks_implies_has_lock:\n  \"\\<lbrakk> has_lock (acquire_locks l t n) t'; t \\<noteq> t' \\<rbrakk> \\<Longrightarrow> has_lock l t'\"", "lemma has_lock_has_lock_acquire_locks:\n  \"has_lock l T \\<Longrightarrow> has_lock (acquire_locks l t n) T\"", "lemma lock_actions_ok'_iff:\n  \"lock_actions_ok' l t las \\<longleftrightarrow> \n   lock_actions_ok l t las \\<or> (\\<exists>xs ys. las = xs @ Lock # ys \\<and> lock_actions_ok l t xs \\<and> \\<not> may_lock (upd_locks l t xs) t)\"", "lemma lock_actions_ok'E[consumes 1, case_names ok Lock]:\n  \"\\<lbrakk> lock_actions_ok' l t las;\n     lock_actions_ok l t las \\<Longrightarrow> P;\n     \\<And>xs ys. \\<lbrakk> las = xs @ Lock # ys; lock_actions_ok l t xs; \\<not> may_lock (upd_locks l t xs) t \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \n  \\<Longrightarrow> P\""], "translations": [["", "lemma has_locks_iff: \n  \"has_locks l t = n \\<longleftrightarrow>\n  (l = None \\<and> n = 0) \\<or> \n  (\\<exists>n'. l = \\<lfloor>(t, n')\\<rfloor> \\<and> Suc n' = n) \\<or> (\\<exists>t' n'. l = \\<lfloor>(t', n')\\<rfloor> \\<and> t' \\<noteq> t \\<and> n = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (has_locks l t = n) =\n    (l = None \\<and> n = 0 \\<or>\n     (\\<exists>n'. l = \\<lfloor>(t, n')\\<rfloor> \\<and> Suc n' = n) \\<or>\n     (\\<exists>t' n'.\n         l = \\<lfloor>(t', n')\\<rfloor> \\<and> t' \\<noteq> t \\<and> n = 0))", "by(cases l, auto)"], ["", "lemma has_locksE:\n  \"\\<lbrakk> has_locks l t = n;\n     \\<lbrakk> l = None; n = 0 \\<rbrakk> \\<Longrightarrow> P;\n     \\<And>n'. \\<lbrakk> l = \\<lfloor>(t, n')\\<rfloor>; Suc n' = n \\<rbrakk> \\<Longrightarrow> P;\n     \\<And>t' n'. \\<lbrakk> l = \\<lfloor>(t', n')\\<rfloor>; t' \\<noteq> t; n = 0 \\<rbrakk> \\<Longrightarrow> P \\<rbrakk>\n  \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_locks l t = n;\n     \\<lbrakk>l = None; n = 0\\<rbrakk> \\<Longrightarrow> P;\n     \\<And>n'.\n        \\<lbrakk>l = \\<lfloor>(t, n')\\<rfloor>; Suc n' = n\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>t' n'.\n        \\<lbrakk>l = \\<lfloor>(t', n')\\<rfloor>; t' \\<noteq> t;\n         n = 0\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by(auto simp add: has_locks_iff split: if_split_asm prod.split_asm)"], ["", "inductive may_lock :: \"'t lock \\<Rightarrow> 't \\<Rightarrow> bool\" where\n  \"may_lock None t\"\n| \"may_lock \\<lfloor>(t, n)\\<rfloor> t\""], ["", "lemma may_lock_iff [code]:\n  \"may_lock l t = (case l of None \\<Rightarrow> True | \\<lfloor>(t', n)\\<rfloor> \\<Rightarrow> t = t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. may_lock l t =\n    (case l of None \\<Rightarrow> True\n     | \\<lfloor>(t', n)\\<rfloor> \\<Rightarrow> t = t')", "by(auto intro: may_lock.intros elim: may_lock.cases)"], ["", "lemma may_lockI:\n  \"l = None \\<or> (\\<exists>n. l = \\<lfloor>(t, n)\\<rfloor>) \\<Longrightarrow> may_lock l t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l = None \\<or>\n    (\\<exists>n. l = \\<lfloor>(t, n)\\<rfloor>) \\<Longrightarrow>\n    may_lock l t", "by(cases l, auto intro: may_lock.intros)"], ["", "lemma may_lockE [consumes 1, case_names None Locked]:\n  \"\\<lbrakk> may_lock l t; l = None \\<Longrightarrow> P; \\<And>n. l = \\<lfloor>(t, n)\\<rfloor>  \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>may_lock l t; l = None \\<Longrightarrow> P;\n     \\<And>n. l = \\<lfloor>(t, n)\\<rfloor> \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by(auto elim: may_lock.cases)"], ["", "lemma may_lock_may_lock_t_eq:\n  \"\\<lbrakk> may_lock l t; may_lock l t' \\<rbrakk> \\<Longrightarrow> (l = None) \\<or> (t = t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>may_lock l t; may_lock l t'\\<rbrakk>\n    \\<Longrightarrow> l = None \\<or> t = t'", "by(auto elim!: may_lockE)"], ["", "abbreviation has_lock :: \"'t lock \\<Rightarrow> 't \\<Rightarrow> bool\"\nwhere \"has_lock l t \\<equiv> 0 < has_locks l t\""], ["", "lemma has_locks_Suc_has_lock:\n  \"has_locks l t = Suc n \\<Longrightarrow> has_lock l t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_locks l t = Suc n \\<Longrightarrow> has_lock l t", "by(auto)"], ["", "lemmas has_lock_has_locks_Suc = gr0_implies_Suc[where n = \"has_locks l t\"] for l t"], ["", "lemma has_lock_has_locks_conv:\n  \"has_lock l t \\<longleftrightarrow> (\\<exists>n. has_locks l t = (Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_lock l t = (\\<exists>n. has_locks l t = Suc n)", "by(auto intro: has_locks_Suc_has_lock has_lock_has_locks_Suc)"], ["", "lemma has_lock_may_lock:\n  \"has_lock l t \\<Longrightarrow> may_lock l t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_lock l t \\<Longrightarrow> may_lock l t", "by(cases l, auto intro: may_lockI)"], ["", "lemma has_lock_may_lock_t_eq:\n  \"\\<lbrakk> has_lock l t; may_lock l t' \\<rbrakk> \\<Longrightarrow> t = t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_lock l t; may_lock l t'\\<rbrakk> \\<Longrightarrow> t = t'", "by(auto elim!: may_lockE split: if_split_asm)"], ["", "lemma has_locks_has_locks_t_eq: \n  \"\\<lbrakk>has_locks l t = Suc n; has_locks l t' = Suc n'\\<rbrakk> \\<Longrightarrow> t = t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_locks l t = Suc n; has_locks l t' = Suc n'\\<rbrakk>\n    \\<Longrightarrow> t = t'", "by(auto elim: has_locksE)"], ["", "lemma has_lock_has_lock_t_eq:\n  \"\\<lbrakk> has_lock l t; has_lock l t' \\<rbrakk> \\<Longrightarrow> t = t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_lock l t; has_lock l t'\\<rbrakk> \\<Longrightarrow> t = t'", "unfolding has_lock_has_locks_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>n. has_locks l t = Suc n;\n     \\<exists>n. has_locks l t' = Suc n\\<rbrakk>\n    \\<Longrightarrow> t = t'", "by(auto intro: has_locks_has_locks_t_eq)"], ["", "lemma not_may_lock_conv:\n  \"\\<not> may_lock l t \\<longleftrightarrow> (\\<exists>t'. t' \\<noteq> t \\<and> has_lock l t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> may_lock l t) =\n    (\\<exists>t'. t' \\<noteq> t \\<and> has_lock l t')", "by(cases l, auto intro: may_lock.intros elim: may_lockE)"], ["", "(* State update functions for locking *)"], ["", "fun lock_lock :: \"'t lock \\<Rightarrow> 't \\<Rightarrow> 't lock\" where\n  \"lock_lock None t = \\<lfloor>(t, 0)\\<rfloor>\"\n| \"lock_lock \\<lfloor>(t', n)\\<rfloor> t = \\<lfloor>(t', Suc n)\\<rfloor>\""], ["", "fun unlock_lock :: \"'t lock \\<Rightarrow> 't lock\" where\n  \"unlock_lock None = None\"\n| \"unlock_lock \\<lfloor>(t, n)\\<rfloor> = (case n of 0 \\<Rightarrow> None | Suc n' \\<Rightarrow> \\<lfloor>(t, n')\\<rfloor>)\""], ["", "fun release_all :: \"'t lock \\<Rightarrow> 't \\<Rightarrow> 't lock\" where\n  \"release_all None t = None\"\n| \"release_all \\<lfloor>(t', n)\\<rfloor> t = (if t = t' then None else \\<lfloor>(t', n)\\<rfloor>)\""], ["", "fun acquire_locks :: \"'t lock \\<Rightarrow> 't \\<Rightarrow> nat \\<Rightarrow> 't lock\" where\n  \"acquire_locks L t 0 = L\"\n| \"acquire_locks L t (Suc m) = acquire_locks (lock_lock L t) t m\""], ["", "lemma acquire_locks_conv:\n  \"acquire_locks L t n = (case L of None \\<Rightarrow> (case n of 0 \\<Rightarrow> None | Suc m \\<Rightarrow> \\<lfloor>(t, m)\\<rfloor>) | \\<lfloor>(t', m)\\<rfloor> \\<Rightarrow> \\<lfloor>(t', n + m)\\<rfloor>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acquire_locks L t n =\n    (case L of\n     None \\<Rightarrow>\n       case n of 0 \\<Rightarrow> None\n       | Suc m \\<Rightarrow> \\<lfloor>(t, m)\\<rfloor>\n     | \\<lfloor>(t', m)\\<rfloor> \\<Rightarrow>\n         \\<lfloor>(t', n + m)\\<rfloor>)", "by(induct n arbitrary: L)(auto)"], ["", "lemma lock_lock_ls_Some:\n  \"\\<exists>t' n. lock_lock l t = \\<lfloor>(t', n)\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t' n. lock_lock l t = \\<lfloor>(t', n)\\<rfloor>", "by(cases l, auto)"], ["", "lemma unlock_lock_SomeD:\n  \"unlock_lock l = \\<lfloor>(t', n)\\<rfloor> \\<Longrightarrow> l = \\<lfloor>(t', Suc n)\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unlock_lock l = \\<lfloor>(t', n)\\<rfloor> \\<Longrightarrow>\n    l = \\<lfloor>(t', Suc n)\\<rfloor>", "by(cases l, auto split: nat.split_asm)"], ["", "lemma has_locks_Suc_lock_lock_has_locks_Suc_Suc:\n  \"has_locks l t = Suc n \\<Longrightarrow> has_locks (lock_lock l t) t = Suc (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_locks l t = Suc n \\<Longrightarrow>\n    has_locks (lock_lock l t) t = Suc (Suc n)", "by(auto elim!: has_locksE)"], ["", "lemma has_locks_lock_lock_conv [simp]:\n  \"may_lock l t \\<Longrightarrow> has_locks (lock_lock l t) t = Suc (has_locks l t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. may_lock l t \\<Longrightarrow>\n    has_locks (lock_lock l t) t = Suc (has_locks l t)", "by(auto elim: may_lockE)"], ["", "lemma has_locks_release_all_conv [simp]:\n  \"has_locks (release_all l t) t = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_locks (release_all l t) t = 0", "by(cases l, auto split: if_split_asm)"], ["", "lemma may_lock_lock_lock_conv [simp]: \"may_lock (lock_lock l t) t = may_lock l t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. may_lock (lock_lock l t) t = may_lock l t", "by(cases l, auto elim!: may_lock.cases intro: may_lock.intros)"], ["", "lemma has_locks_acquire_locks_conv [simp]:\n  \"may_lock l t \\<Longrightarrow> has_locks (acquire_locks l t n) t = has_locks l t + n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. may_lock l t \\<Longrightarrow>\n    has_locks (acquire_locks l t n) t = has_locks l t + n", "by(induct n arbitrary: l, auto)"], ["", "lemma may_lock_unlock_lock_conv [simp]:\n  \"has_lock l t \\<Longrightarrow> may_lock (unlock_lock l) t = may_lock l t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_lock l t \\<Longrightarrow> may_lock (unlock_lock l) t = may_lock l t", "by(cases l)(auto split: if_split_asm nat.splits elim!: may_lock.cases intro: may_lock.intros)"], ["", "lemma may_lock_release_all_conv [simp]:\n  \"may_lock (release_all l t) t = may_lock l t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. may_lock (release_all l t) t = may_lock l t", "by(cases l, auto split: if_split_asm intro!: may_lockI elim: may_lockE)"], ["", "lemma may_lock_t_may_lock_unlock_lock_t: \n  \"may_lock l t \\<Longrightarrow> may_lock (unlock_lock l) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. may_lock l t \\<Longrightarrow> may_lock (unlock_lock l) t", "by(auto intro: may_lock.intros elim!: may_lockE split: nat.split)"], ["", "lemma may_lock_has_locks_lock_lock_0: \n  \"\\<lbrakk>may_lock l t'; t \\<noteq> t'\\<rbrakk> \\<Longrightarrow> has_locks (lock_lock l t') t = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>may_lock l t'; t \\<noteq> t'\\<rbrakk>\n    \\<Longrightarrow> has_locks (lock_lock l t') t = 0", "by(auto elim!: may_lock.cases)"], ["", "lemma has_locks_unlock_lock_conv [simp]:\n  \"has_lock l t \\<Longrightarrow> has_locks (unlock_lock l) t = has_locks l t - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_lock l t \\<Longrightarrow>\n    has_locks (unlock_lock l) t = has_locks l t - 1", "by(cases l)(auto split: nat.split)"], ["", "lemma has_lock_lock_lock_unlock_lock_id [simp]:\n  \"has_lock l t \\<Longrightarrow> lock_lock (unlock_lock l) t = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_lock l t \\<Longrightarrow> lock_lock (unlock_lock l) t = l", "by(cases l)(auto split: if_split_asm nat.split)"], ["", "lemma may_lock_unlock_lock_lock_lock_id [simp]:\n  \"may_lock l t \\<Longrightarrow> unlock_lock (lock_lock l t) = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. may_lock l t \\<Longrightarrow> unlock_lock (lock_lock l t) = l", "by(cases l) auto"], ["", "lemma may_lock_has_locks_0:\n  \"\\<lbrakk> may_lock l t; t \\<noteq> t' \\<rbrakk> \\<Longrightarrow> has_locks l t' = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>may_lock l t; t \\<noteq> t'\\<rbrakk>\n    \\<Longrightarrow> has_locks l t' = 0", "by(auto elim!: may_lockE)"], ["", "fun upd_lock :: \"'t lock \\<Rightarrow> 't \\<Rightarrow> lock_action \\<Rightarrow> 't lock\"\nwhere\n  \"upd_lock l t Lock = lock_lock l t\"\n| \"upd_lock l t Unlock = unlock_lock l\"\n| \"upd_lock l t UnlockFail = l\"\n| \"upd_lock l t ReleaseAquire = release_all l t\""], ["", "fun upd_locks :: \"'t lock \\<Rightarrow> 't \\<Rightarrow> lock_action list \\<Rightarrow> 't lock\"\nwhere\n  \"upd_locks l t [] = l\"\n| \"upd_locks l t (L # Ls) = upd_locks (upd_lock l t L) t Ls\""], ["", "lemma upd_locks_append [simp]:\n  \"upd_locks l t (Ls @ Ls') = upd_locks (upd_locks l t Ls) t Ls'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_locks l t (Ls @ Ls') = upd_locks (upd_locks l t Ls) t Ls'", "by(induct Ls arbitrary: l, auto)"], ["", "lemma upd_lock_Some_thread_idD:\n  assumes ul: \"upd_lock l t L = \\<lfloor>(t', n)\\<rfloor>\"\n  and tt': \"t \\<noteq> t'\"\n  shows \"\\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>", "proof(cases L)"], ["proof (state)\ngoal (4 subgoals):\n 1. L = Lock \\<Longrightarrow> \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>\n 2. L = Unlock \\<Longrightarrow> \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>\n 3. L = UnlockFail \\<Longrightarrow>\n    \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>\n 4. L = ReleaseAcquire \\<Longrightarrow>\n    \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>", "case Lock"], ["proof (state)\nthis:\n  L = Lock\n\ngoal (4 subgoals):\n 1. L = Lock \\<Longrightarrow> \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>\n 2. L = Unlock \\<Longrightarrow> \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>\n 3. L = UnlockFail \\<Longrightarrow>\n    \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>\n 4. L = ReleaseAcquire \\<Longrightarrow>\n    \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>", "with ul tt'"], ["proof (chain)\npicking this:\n  upd_lock l t L = \\<lfloor>(t', n)\\<rfloor>\n  t \\<noteq> t'\n  L = Lock", "show ?thesis"], ["proof (prove)\nusing this:\n  upd_lock l t L = \\<lfloor>(t', n)\\<rfloor>\n  t \\<noteq> t'\n  L = Lock\n\ngoal (1 subgoal):\n 1. \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>", "by(cases l, auto)"], ["proof (state)\nthis:\n  \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>\n\ngoal (3 subgoals):\n 1. L = Unlock \\<Longrightarrow> \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>\n 2. L = UnlockFail \\<Longrightarrow>\n    \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>\n 3. L = ReleaseAcquire \\<Longrightarrow>\n    \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. L = Unlock \\<Longrightarrow> \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>\n 2. L = UnlockFail \\<Longrightarrow>\n    \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>\n 3. L = ReleaseAcquire \\<Longrightarrow>\n    \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>", "case Unlock"], ["proof (state)\nthis:\n  L = Unlock\n\ngoal (3 subgoals):\n 1. L = Unlock \\<Longrightarrow> \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>\n 2. L = UnlockFail \\<Longrightarrow>\n    \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>\n 3. L = ReleaseAcquire \\<Longrightarrow>\n    \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>", "with ul tt'"], ["proof (chain)\npicking this:\n  upd_lock l t L = \\<lfloor>(t', n)\\<rfloor>\n  t \\<noteq> t'\n  L = Unlock", "show ?thesis"], ["proof (prove)\nusing this:\n  upd_lock l t L = \\<lfloor>(t', n)\\<rfloor>\n  t \\<noteq> t'\n  L = Unlock\n\ngoal (1 subgoal):\n 1. \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>", "by(auto dest: unlock_lock_SomeD)"], ["proof (state)\nthis:\n  \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>\n\ngoal (2 subgoals):\n 1. L = UnlockFail \\<Longrightarrow>\n    \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>\n 2. L = ReleaseAcquire \\<Longrightarrow>\n    \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. L = UnlockFail \\<Longrightarrow>\n    \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>\n 2. L = ReleaseAcquire \\<Longrightarrow>\n    \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>", "case UnlockFail"], ["proof (state)\nthis:\n  L = UnlockFail\n\ngoal (2 subgoals):\n 1. L = UnlockFail \\<Longrightarrow>\n    \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>\n 2. L = ReleaseAcquire \\<Longrightarrow>\n    \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>", "with ul"], ["proof (chain)\npicking this:\n  upd_lock l t L = \\<lfloor>(t', n)\\<rfloor>\n  L = UnlockFail", "show ?thesis"], ["proof (prove)\nusing this:\n  upd_lock l t L = \\<lfloor>(t', n)\\<rfloor>\n  L = UnlockFail\n\ngoal (1 subgoal):\n 1. \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>", "by(simp)"], ["proof (state)\nthis:\n  \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>\n\ngoal (1 subgoal):\n 1. L = ReleaseAcquire \\<Longrightarrow>\n    \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. L = ReleaseAcquire \\<Longrightarrow>\n    \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>", "case ReleaseAcquire"], ["proof (state)\nthis:\n  L = ReleaseAcquire\n\ngoal (1 subgoal):\n 1. L = ReleaseAcquire \\<Longrightarrow>\n    \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>", "with ul"], ["proof (chain)\npicking this:\n  upd_lock l t L = \\<lfloor>(t', n)\\<rfloor>\n  L = ReleaseAcquire", "show ?thesis"], ["proof (prove)\nusing this:\n  upd_lock l t L = \\<lfloor>(t', n)\\<rfloor>\n  L = ReleaseAcquire\n\ngoal (1 subgoal):\n 1. \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>", "by(cases l, auto split: if_split_asm)"], ["proof (state)\nthis:\n  \\<exists>n. l = \\<lfloor>(t', n)\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma has_lock_upd_lock_implies_has_lock:\n  \"\\<lbrakk> has_lock (upd_lock l t L) t'; t \\<noteq> t' \\<rbrakk> \\<Longrightarrow> has_lock l t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_lock (upd_lock l t L) t'; t \\<noteq> t'\\<rbrakk>\n    \\<Longrightarrow> has_lock l t'", "by(cases l L rule: option.exhaust[case_product lock_action.exhaust])(auto split: if_split_asm nat.split_asm)"], ["", "lemma has_lock_upd_locks_implies_has_lock:\n  \"\\<lbrakk> has_lock (upd_locks l t Ls) t'; t \\<noteq> t' \\<rbrakk> \\<Longrightarrow> has_lock l t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_lock (upd_locks l t Ls) t'; t \\<noteq> t'\\<rbrakk>\n    \\<Longrightarrow> has_lock l t'", "by(induct l t Ls rule: upd_locks.induct)(auto intro: has_lock_upd_lock_implies_has_lock)"], ["", "(* Preconditions for lock actions *)"], ["", "fun lock_action_ok :: \"'t lock \\<Rightarrow> 't \\<Rightarrow> lock_action \\<Rightarrow> bool\" where\n  \"lock_action_ok l t Lock = may_lock l t\"\n| \"lock_action_ok l t Unlock = has_lock l t\"\n| \"lock_action_ok l t UnlockFail = (\\<not> has_lock l t)\"\n| \"lock_action_ok l t ReleaseAcquire = True\""], ["", "fun lock_actions_ok :: \"'t lock \\<Rightarrow> 't \\<Rightarrow> lock_action list \\<Rightarrow> bool\" where\n  \"lock_actions_ok l t [] = True\"\n| \"lock_actions_ok l t (L # Ls) = (lock_action_ok l t L \\<and> lock_actions_ok (upd_lock l t L) t Ls)\""], ["", "lemma lock_actions_ok_append [simp]:\n  \"lock_actions_ok l t (Ls @ Ls') \\<longleftrightarrow> lock_actions_ok l t Ls \\<and> lock_actions_ok (upd_locks l t Ls) t Ls'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lock_actions_ok l t (Ls @ Ls') =\n    (lock_actions_ok l t Ls \\<and> lock_actions_ok (upd_locks l t Ls) t Ls')", "by(induct Ls arbitrary: l) auto"], ["", "lemma not_lock_action_okE [consumes 1, case_names Lock Unlock UnlockFail]:\n  \"\\<lbrakk> \\<not> lock_action_ok l t L;\n     \\<lbrakk> L = Lock; \\<not> may_lock l t \\<rbrakk> \\<Longrightarrow> Q;\n     \\<lbrakk> L = Unlock; \\<not> has_lock l t \\<rbrakk> \\<Longrightarrow> Q;\n     \\<lbrakk> L = UnlockFail; has_lock l t \\<rbrakk> \\<Longrightarrow> Q\\<rbrakk>\n  \\<Longrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lock_action_ok l t L;\n     \\<lbrakk>L = Lock; \\<not> may_lock l t\\<rbrakk> \\<Longrightarrow> Q;\n     \\<lbrakk>L = Unlock; \\<not> has_lock l t\\<rbrakk> \\<Longrightarrow> Q;\n     \\<lbrakk>L = UnlockFail; has_lock l t\\<rbrakk>\n     \\<Longrightarrow> Q\\<rbrakk>\n    \\<Longrightarrow> Q", "by(cases L) auto"], ["", "lemma may_lock_upd_lock_conv [simp]:\n  \"lock_action_ok l t L \\<Longrightarrow> may_lock (upd_lock l t L) t = may_lock l t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lock_action_ok l t L \\<Longrightarrow>\n    may_lock (upd_lock l t L) t = may_lock l t", "by(cases L) auto"], ["", "lemma may_lock_upd_locks_conv [simp]:\n  \"lock_actions_ok l t Ls \\<Longrightarrow> may_lock (upd_locks l t Ls) t = may_lock l t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lock_actions_ok l t Ls \\<Longrightarrow>\n    may_lock (upd_locks l t Ls) t = may_lock l t", "by(induct l t Ls rule: upd_locks.induct) simp_all"], ["", "lemma lock_actions_ok_Lock_may_lock:\n  \"\\<lbrakk> lock_actions_ok l t Ls; Lock \\<in> set Ls \\<rbrakk> \\<Longrightarrow> may_lock l t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lock_actions_ok l t Ls; Lock \\<in> set Ls\\<rbrakk>\n    \\<Longrightarrow> may_lock l t", "by(induct l t Ls rule: lock_actions_ok.induct) auto"], ["", "lemma has_locks_lock_lock_conv' [simp]:\n  \"\\<lbrakk> may_lock l t'; t \\<noteq> t' \\<rbrakk> \\<Longrightarrow> has_locks (lock_lock l t') t = has_locks l t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>may_lock l t'; t \\<noteq> t'\\<rbrakk>\n    \\<Longrightarrow> has_locks (lock_lock l t') t = has_locks l t", "by(cases l)(auto elim: may_lock.cases)"], ["", "lemma has_locks_unlock_lock_conv' [simp]:\n  \"\\<lbrakk> has_lock l t'; t \\<noteq> t' \\<rbrakk> \\<Longrightarrow> has_locks (unlock_lock l) t = has_locks l t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_lock l t'; t \\<noteq> t'\\<rbrakk>\n    \\<Longrightarrow> has_locks (unlock_lock l) t = has_locks l t", "by(cases l)(auto split: if_split_asm nat.split)"], ["", "lemma has_locks_release_all_conv' [simp]:\n  \"t \\<noteq> t' \\<Longrightarrow> has_locks (release_all l t') t = has_locks l t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<noteq> t' \\<Longrightarrow>\n    has_locks (release_all l t') t = has_locks l t", "by(cases l) auto"], ["", "lemma has_locks_acquire_locks_conv' [simp]:\n  \"\\<lbrakk> may_lock l t; t \\<noteq> t' \\<rbrakk> \\<Longrightarrow> has_locks (acquire_locks l t n) t' = has_locks l t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>may_lock l t; t \\<noteq> t'\\<rbrakk>\n    \\<Longrightarrow> has_locks (acquire_locks l t n) t' = has_locks l t'", "by(induct l t n rule: acquire_locks.induct) simp_all"], ["", "lemma lock_action_ok_has_locks_upd_lock_eq_has_locks [simp]:\n  \"\\<lbrakk> lock_action_ok l t' L; t \\<noteq> t' \\<rbrakk> \\<Longrightarrow> has_locks (upd_lock l t' L) t = has_locks l t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lock_action_ok l t' L; t \\<noteq> t'\\<rbrakk>\n    \\<Longrightarrow> has_locks (upd_lock l t' L) t = has_locks l t", "by(cases L) auto"], ["", "lemma lock_actions_ok_has_locks_upd_locks_eq_has_locks [simp]:\n  \"\\<lbrakk> lock_actions_ok l t' Ls; t \\<noteq> t' \\<rbrakk> \\<Longrightarrow> has_locks (upd_locks l t' Ls) t = has_locks l t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lock_actions_ok l t' Ls; t \\<noteq> t'\\<rbrakk>\n    \\<Longrightarrow> has_locks (upd_locks l t' Ls) t = has_locks l t", "by(induct l t' Ls rule: upd_locks.induct) simp_all"], ["", "lemma has_lock_acquire_locks_implies_has_lock:\n  \"\\<lbrakk> has_lock (acquire_locks l t n) t'; t \\<noteq> t' \\<rbrakk> \\<Longrightarrow> has_lock l t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_lock (acquire_locks l t n) t'; t \\<noteq> t'\\<rbrakk>\n    \\<Longrightarrow> has_lock l t'", "unfolding acquire_locks_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_lock\n              (case l of\n               None \\<Rightarrow>\n                 case n of 0 \\<Rightarrow> None\n                 | Suc m \\<Rightarrow> \\<lfloor>(t, m)\\<rfloor>\n               | \\<lfloor>(t', m)\\<rfloor> \\<Rightarrow>\n                   \\<lfloor>(t', n + m)\\<rfloor>)\n              t';\n     t \\<noteq> t'\\<rbrakk>\n    \\<Longrightarrow> has_lock l t'", "by(cases n)(auto split: if_split_asm)"], ["", "lemma has_lock_has_lock_acquire_locks:\n  \"has_lock l T \\<Longrightarrow> has_lock (acquire_locks l t n) T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_lock l T \\<Longrightarrow> has_lock (acquire_locks l t n) T", "unfolding acquire_locks_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. has_lock l T \\<Longrightarrow>\n    has_lock\n     (case l of\n      None \\<Rightarrow>\n        case n of 0 \\<Rightarrow> None\n        | Suc m \\<Rightarrow> \\<lfloor>(t, m)\\<rfloor>\n      | \\<lfloor>(t', m)\\<rfloor> \\<Rightarrow>\n          \\<lfloor>(t', n + m)\\<rfloor>)\n     T", "by(auto)"], ["", "fun lock_actions_ok' :: \"'t lock \\<Rightarrow> 't \\<Rightarrow> lock_action list \\<Rightarrow> bool\" where\n  \"lock_actions_ok' l t [] = True\"\n| \"lock_actions_ok' l t (L#Ls) = ((L = Lock \\<and> \\<not> may_lock l t) \\<or>\n                                  lock_action_ok l t L \\<and> lock_actions_ok' (upd_lock l t L) t Ls)\""], ["", "lemma lock_actions_ok'_iff:\n  \"lock_actions_ok' l t las \\<longleftrightarrow> \n   lock_actions_ok l t las \\<or> (\\<exists>xs ys. las = xs @ Lock # ys \\<and> lock_actions_ok l t xs \\<and> \\<not> may_lock (upd_locks l t xs) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lock_actions_ok' l t las =\n    (lock_actions_ok l t las \\<or>\n     (\\<exists>xs ys.\n         las = xs @ Lock # ys \\<and>\n         lock_actions_ok l t xs \\<and>\n         \\<not> may_lock (upd_locks l t xs) t))", "proof(induct l t las rule: lock_actions_ok.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l t.\n       lock_actions_ok' l t [] =\n       (lock_actions_ok l t [] \\<or>\n        (\\<exists>xs ys.\n            [] = xs @ Lock # ys \\<and>\n            lock_actions_ok l t xs \\<and>\n            \\<not> may_lock (upd_locks l t xs) t))\n 2. \\<And>l t L Ls.\n       lock_actions_ok' (upd_lock l t L) t Ls =\n       (lock_actions_ok (upd_lock l t L) t Ls \\<or>\n        (\\<exists>xs ys.\n            Ls = xs @ Lock # ys \\<and>\n            lock_actions_ok (upd_lock l t L) t xs \\<and>\n            \\<not> may_lock (upd_locks (upd_lock l t L) t xs)\n                    t)) \\<Longrightarrow>\n       lock_actions_ok' l t (L # Ls) =\n       (lock_actions_ok l t (L # Ls) \\<or>\n        (\\<exists>xs ys.\n            L # Ls = xs @ Lock # ys \\<and>\n            lock_actions_ok l t xs \\<and>\n            \\<not> may_lock (upd_locks l t xs) t))", "case (2 L t LA LAS)"], ["proof (state)\nthis:\n  lock_actions_ok' (upd_lock L t LA) t LAS =\n  (lock_actions_ok (upd_lock L t LA) t LAS \\<or>\n   (\\<exists>xs ys.\n       LAS = xs @ Lock # ys \\<and>\n       lock_actions_ok (upd_lock L t LA) t xs \\<and>\n       \\<not> may_lock (upd_locks (upd_lock L t LA) t xs) t))\n\ngoal (2 subgoals):\n 1. \\<And>l t.\n       lock_actions_ok' l t [] =\n       (lock_actions_ok l t [] \\<or>\n        (\\<exists>xs ys.\n            [] = xs @ Lock # ys \\<and>\n            lock_actions_ok l t xs \\<and>\n            \\<not> may_lock (upd_locks l t xs) t))\n 2. \\<And>l t L Ls.\n       lock_actions_ok' (upd_lock l t L) t Ls =\n       (lock_actions_ok (upd_lock l t L) t Ls \\<or>\n        (\\<exists>xs ys.\n            Ls = xs @ Lock # ys \\<and>\n            lock_actions_ok (upd_lock l t L) t xs \\<and>\n            \\<not> may_lock (upd_locks (upd_lock l t L) t xs)\n                    t)) \\<Longrightarrow>\n       lock_actions_ok' l t (L # Ls) =\n       (lock_actions_ok l t (L # Ls) \\<or>\n        (\\<exists>xs ys.\n            L # Ls = xs @ Lock # ys \\<and>\n            lock_actions_ok l t xs \\<and>\n            \\<not> may_lock (upd_locks l t xs) t))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lock_actions_ok' L t (LA # LAS) =\n    (lock_actions_ok L t (LA # LAS) \\<or>\n     (\\<exists>xs ys.\n         LA # LAS = xs @ Lock # ys \\<and>\n         lock_actions_ok L t xs \\<and>\n         \\<not> may_lock (upd_locks L t xs) t))", "proof(cases \"LA = Lock \\<and> \\<not> may_lock L t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. LA = Lock \\<and> \\<not> may_lock L t \\<Longrightarrow>\n    lock_actions_ok' L t (LA # LAS) =\n    (lock_actions_ok L t (LA # LAS) \\<or>\n     (\\<exists>xs ys.\n         LA # LAS = xs @ Lock # ys \\<and>\n         lock_actions_ok L t xs \\<and>\n         \\<not> may_lock (upd_locks L t xs) t))\n 2. \\<not> (LA = Lock \\<and> \\<not> may_lock L t) \\<Longrightarrow>\n    lock_actions_ok' L t (LA # LAS) =\n    (lock_actions_ok L t (LA # LAS) \\<or>\n     (\\<exists>xs ys.\n         LA # LAS = xs @ Lock # ys \\<and>\n         lock_actions_ok L t xs \\<and>\n         \\<not> may_lock (upd_locks L t xs) t))", "case True"], ["proof (state)\nthis:\n  LA = Lock \\<and> \\<not> may_lock L t\n\ngoal (2 subgoals):\n 1. LA = Lock \\<and> \\<not> may_lock L t \\<Longrightarrow>\n    lock_actions_ok' L t (LA # LAS) =\n    (lock_actions_ok L t (LA # LAS) \\<or>\n     (\\<exists>xs ys.\n         LA # LAS = xs @ Lock # ys \\<and>\n         lock_actions_ok L t xs \\<and>\n         \\<not> may_lock (upd_locks L t xs) t))\n 2. \\<not> (LA = Lock \\<and> \\<not> may_lock L t) \\<Longrightarrow>\n    lock_actions_ok' L t (LA # LAS) =\n    (lock_actions_ok L t (LA # LAS) \\<or>\n     (\\<exists>xs ys.\n         LA # LAS = xs @ Lock # ys \\<and>\n         lock_actions_ok L t xs \\<and>\n         \\<not> may_lock (upd_locks L t xs) t))", "hence \"(\\<exists>ys. Lock # LAS = [] @ Lock # ys) \\<and> lock_actions_ok L t [] \\<and> \\<not> may_lock (upd_locks L t []) t\""], ["proof (prove)\nusing this:\n  LA = Lock \\<and> \\<not> may_lock L t\n\ngoal (1 subgoal):\n 1. (\\<exists>ys. Lock # LAS = [] @ Lock # ys) \\<and>\n    lock_actions_ok L t [] \\<and> \\<not> may_lock (upd_locks L t []) t", "by(simp)"], ["proof (state)\nthis:\n  (\\<exists>ys. Lock # LAS = [] @ Lock # ys) \\<and>\n  lock_actions_ok L t [] \\<and> \\<not> may_lock (upd_locks L t []) t\n\ngoal (2 subgoals):\n 1. LA = Lock \\<and> \\<not> may_lock L t \\<Longrightarrow>\n    lock_actions_ok' L t (LA # LAS) =\n    (lock_actions_ok L t (LA # LAS) \\<or>\n     (\\<exists>xs ys.\n         LA # LAS = xs @ Lock # ys \\<and>\n         lock_actions_ok L t xs \\<and>\n         \\<not> may_lock (upd_locks L t xs) t))\n 2. \\<not> (LA = Lock \\<and> \\<not> may_lock L t) \\<Longrightarrow>\n    lock_actions_ok' L t (LA # LAS) =\n    (lock_actions_ok L t (LA # LAS) \\<or>\n     (\\<exists>xs ys.\n         LA # LAS = xs @ Lock # ys \\<and>\n         lock_actions_ok L t xs \\<and>\n         \\<not> may_lock (upd_locks L t xs) t))", "with True"], ["proof (chain)\npicking this:\n  LA = Lock \\<and> \\<not> may_lock L t\n  (\\<exists>ys. Lock # LAS = [] @ Lock # ys) \\<and>\n  lock_actions_ok L t [] \\<and> \\<not> may_lock (upd_locks L t []) t", "show ?thesis"], ["proof (prove)\nusing this:\n  LA = Lock \\<and> \\<not> may_lock L t\n  (\\<exists>ys. Lock # LAS = [] @ Lock # ys) \\<and>\n  lock_actions_ok L t [] \\<and> \\<not> may_lock (upd_locks L t []) t\n\ngoal (1 subgoal):\n 1. lock_actions_ok' L t (LA # LAS) =\n    (lock_actions_ok L t (LA # LAS) \\<or>\n     (\\<exists>xs ys.\n         LA # LAS = xs @ Lock # ys \\<and>\n         lock_actions_ok L t xs \\<and>\n         \\<not> may_lock (upd_locks L t xs) t))", "by(simp (no_asm))(blast)"], ["proof (state)\nthis:\n  lock_actions_ok' L t (LA # LAS) =\n  (lock_actions_ok L t (LA # LAS) \\<or>\n   (\\<exists>xs ys.\n       LA # LAS = xs @ Lock # ys \\<and>\n       lock_actions_ok L t xs \\<and> \\<not> may_lock (upd_locks L t xs) t))\n\ngoal (1 subgoal):\n 1. \\<not> (LA = Lock \\<and> \\<not> may_lock L t) \\<Longrightarrow>\n    lock_actions_ok' L t (LA # LAS) =\n    (lock_actions_ok L t (LA # LAS) \\<or>\n     (\\<exists>xs ys.\n         LA # LAS = xs @ Lock # ys \\<and>\n         lock_actions_ok L t xs \\<and>\n         \\<not> may_lock (upd_locks L t xs) t))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (LA = Lock \\<and> \\<not> may_lock L t) \\<Longrightarrow>\n    lock_actions_ok' L t (LA # LAS) =\n    (lock_actions_ok L t (LA # LAS) \\<or>\n     (\\<exists>xs ys.\n         LA # LAS = xs @ Lock # ys \\<and>\n         lock_actions_ok L t xs \\<and>\n         \\<not> may_lock (upd_locks L t xs) t))", "case False"], ["proof (state)\nthis:\n  \\<not> (LA = Lock \\<and> \\<not> may_lock L t)\n\ngoal (1 subgoal):\n 1. \\<not> (LA = Lock \\<and> \\<not> may_lock L t) \\<Longrightarrow>\n    lock_actions_ok' L t (LA # LAS) =\n    (lock_actions_ok L t (LA # LAS) \\<or>\n     (\\<exists>xs ys.\n         LA # LAS = xs @ Lock # ys \\<and>\n         lock_actions_ok L t xs \\<and>\n         \\<not> may_lock (upd_locks L t xs) t))", "with 2"], ["proof (chain)\npicking this:\n  lock_actions_ok' (upd_lock L t LA) t LAS =\n  (lock_actions_ok (upd_lock L t LA) t LAS \\<or>\n   (\\<exists>xs ys.\n       LAS = xs @ Lock # ys \\<and>\n       lock_actions_ok (upd_lock L t LA) t xs \\<and>\n       \\<not> may_lock (upd_locks (upd_lock L t LA) t xs) t))\n  \\<not> (LA = Lock \\<and> \\<not> may_lock L t)", "show ?thesis"], ["proof (prove)\nusing this:\n  lock_actions_ok' (upd_lock L t LA) t LAS =\n  (lock_actions_ok (upd_lock L t LA) t LAS \\<or>\n   (\\<exists>xs ys.\n       LAS = xs @ Lock # ys \\<and>\n       lock_actions_ok (upd_lock L t LA) t xs \\<and>\n       \\<not> may_lock (upd_locks (upd_lock L t LA) t xs) t))\n  \\<not> (LA = Lock \\<and> \\<not> may_lock L t)\n\ngoal (1 subgoal):\n 1. lock_actions_ok' L t (LA # LAS) =\n    (lock_actions_ok L t (LA # LAS) \\<or>\n     (\\<exists>xs ys.\n         LA # LAS = xs @ Lock # ys \\<and>\n         lock_actions_ok L t xs \\<and>\n         \\<not> may_lock (upd_locks L t xs) t))", "by(fastforce simp add: Cons_eq_append_conv elim: allE[where x=\"LA # xs\" for xs])"], ["proof (state)\nthis:\n  lock_actions_ok' L t (LA # LAS) =\n  (lock_actions_ok L t (LA # LAS) \\<or>\n   (\\<exists>xs ys.\n       LA # LAS = xs @ Lock # ys \\<and>\n       lock_actions_ok L t xs \\<and> \\<not> may_lock (upd_locks L t xs) t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lock_actions_ok' L t (LA # LAS) =\n  (lock_actions_ok L t (LA # LAS) \\<or>\n   (\\<exists>xs ys.\n       LA # LAS = xs @ Lock # ys \\<and>\n       lock_actions_ok L t xs \\<and> \\<not> may_lock (upd_locks L t xs) t))\n\ngoal (1 subgoal):\n 1. \\<And>l t.\n       lock_actions_ok' l t [] =\n       (lock_actions_ok l t [] \\<or>\n        (\\<exists>xs ys.\n            [] = xs @ Lock # ys \\<and>\n            lock_actions_ok l t xs \\<and>\n            \\<not> may_lock (upd_locks l t xs) t))", "qed simp"], ["", "lemma lock_actions_ok'E[consumes 1, case_names ok Lock]:\n  \"\\<lbrakk> lock_actions_ok' l t las;\n     lock_actions_ok l t las \\<Longrightarrow> P;\n     \\<And>xs ys. \\<lbrakk> las = xs @ Lock # ys; lock_actions_ok l t xs; \\<not> may_lock (upd_locks l t xs) t \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \n  \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lock_actions_ok' l t las;\n     lock_actions_ok l t las \\<Longrightarrow> P;\n     \\<And>xs ys.\n        \\<lbrakk>las = xs @ Lock # ys; lock_actions_ok l t xs;\n         \\<not> may_lock (upd_locks l t xs) t\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by(auto simp add: lock_actions_ok'_iff)"], ["", "end"]]}