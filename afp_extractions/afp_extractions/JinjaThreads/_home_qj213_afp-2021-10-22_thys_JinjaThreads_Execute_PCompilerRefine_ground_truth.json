{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Execute/PCompilerRefine.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma compP_code_code [code abstract]:\n  \"impl_of (compP_code f P) = compP_code' f (impl_of P)\"", "lemma compP_program [code]:\n  \"compP f (program P) = program (compP_code f P)\""], "translations": [["", "lemma compP_code_code [code abstract]:\n  \"impl_of (compP_code f P) = compP_code' f (impl_of P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. impl_of (compP_code f P) = compP_code' f (impl_of P)", "apply(cases P)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>P = ProgRefine y; y \\<in> {P. wf_prog_impl' P}\\<rbrakk>\n       \\<Longrightarrow> impl_of (compP_code f P) =\n                         compP_code' f (impl_of P)", "apply(simp add: compP_code_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>P = ProgRefine y; wf_prog_impl' y\\<rbrakk>\n       \\<Longrightarrow> impl_of (ProgRefine (compP_code' f y)) =\n                         compP_code' f y", "apply(subst ProgRefine_inverse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>P = ProgRefine y; wf_prog_impl' y\\<rbrakk>\n       \\<Longrightarrow> compP_code' f y \\<in> Collect wf_prog_impl'\n 2. \\<And>y.\n       \\<lbrakk>P = ProgRefine y; wf_prog_impl' y\\<rbrakk>\n       \\<Longrightarrow> compP_code' f y = compP_code' f y", "apply(auto simp add: tabulate_subcls_def tabulate_sees_field_def Mapping_inject intro!: ext)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare compP.simps [simp] compP.simps[symmetric, simp del]"], ["", "lemma compP_program [code]:\n  \"compP f (program P) = program (compP_code f P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compP f (program P) = program (compP_code f P)", "by(cases P)(clarsimp simp add: program_def compP_code_code)"], ["", "text \\<open>Merge module names to avoid cycles in module dependency\\<close>"], ["", "code_identifier\n  code_module PCompiler \\<rightharpoonup>\n    (SML) PCompiler and (OCaml) PCompiler and (Haskell) PCompiler \n| code_module PCompilerRefine \\<rightharpoonup>\n    (SML) PCompiler and (OCaml) PCompiler and (Haskell) PCompiler"], ["", "ML_val \\<open>@{code compP}\\<close>"], ["", "end"]]}