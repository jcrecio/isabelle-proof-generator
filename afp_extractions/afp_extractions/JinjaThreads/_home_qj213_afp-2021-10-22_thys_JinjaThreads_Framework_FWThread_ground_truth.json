{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Framework/FWThread.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma free_thread_id_iff: \"free_thread_id ts t = (ts t = None)\"", "lemma redT_updTs_append [simp]:\n  \"redT_updTs ts (tas @ tas') = redT_updTs (redT_updTs ts tas) tas'\"", "lemma redT_updT_None: \n  \"redT_updT ts ta t = None \\<Longrightarrow> ts t = None\"", "lemma redT_updTs_None: \"redT_updTs ts tas t = None \\<Longrightarrow> ts t = None\"", "lemma redT_updT_Some1:\n  \"ts t = \\<lfloor>xw\\<rfloor> \\<Longrightarrow> \\<exists>xw. redT_updT ts ta t = \\<lfloor>xw\\<rfloor>\"", "lemma redT_updTs_Some1:\n  \"ts t = \\<lfloor>xw\\<rfloor> \\<Longrightarrow> \\<exists>xw. redT_updTs ts tas t = \\<lfloor>xw\\<rfloor>\"", "lemma redT_updT_finite_dom_inv:\n  \"finite (dom (redT_updT ts ta)) = finite (dom ts)\"", "lemma redT_updTs_finite_dom_inv:\n  \"finite (dom (redT_updTs ts tas)) = finite (dom ts)\"", "lemma redT_updT'_None: \n  \"redT_updT' ts ta t = None \\<Longrightarrow> ts t = None\"", "lemma thread_ok_ts_change:\n  \"(\\<And>t. ts t = None \\<longleftrightarrow> ts' t = None) \\<Longrightarrow> thread_ok ts ta \\<longleftrightarrow> thread_ok ts' ta\"", "lemma thread_oks_ts_change:\n  \"(\\<And>t. ts t = None \\<longleftrightarrow> ts' t = None) \\<Longrightarrow> thread_oks ts tas \\<longleftrightarrow> thread_oks ts' tas\"", "lemma redT_updT'_eq_None_conv: \n  \"(\\<And>t. ts t = None \\<longleftrightarrow> ts' t = None) \\<Longrightarrow> redT_updT' ts ta t = None \\<longleftrightarrow> redT_updT ts' ta t = None\"", "lemma redT_updTs'_eq_None_conv:\n  \"(\\<And>t. ts t = None \\<longleftrightarrow> ts' t = None) \\<Longrightarrow> redT_updTs' ts tas t = None \\<longleftrightarrow> redT_updTs ts' tas t = None\"", "lemma thread_oks_redT_updT_conv [simp]:\n  \"thread_oks (redT_updT' ts ta) tas = thread_oks (redT_updT ts ta) tas\"", "lemma thread_oks_append [simp]:\n  \"thread_oks ts (tas @ tas') = (thread_oks ts tas \\<and> thread_oks (redT_updTs' ts tas) tas')\"", "lemma thread_oks_redT_updTs_conv [simp]:\n  \"thread_oks (redT_updTs' ts ta) tas = thread_oks (redT_updTs ts ta) tas\"", "lemma redT_updT_Some:\n  \"\\<lbrakk> ts t = \\<lfloor>xw\\<rfloor>; thread_ok ts ta \\<rbrakk> \\<Longrightarrow> redT_updT ts ta t = \\<lfloor>xw\\<rfloor>\"", "lemma redT_updTs_Some:\n  \"\\<lbrakk> ts t = \\<lfloor>xw\\<rfloor>; thread_oks ts tas \\<rbrakk> \\<Longrightarrow> redT_updTs ts tas t = \\<lfloor>xw\\<rfloor>\"", "lemma redT_updT'_Some:\n  \"\\<lbrakk> ts t = \\<lfloor>xw\\<rfloor>; thread_ok ts ta \\<rbrakk> \\<Longrightarrow> redT_updT' ts ta t = \\<lfloor>xw\\<rfloor>\"", "lemma redT_updTs'_Some:\n  \"\\<lbrakk> ts t = \\<lfloor>xw\\<rfloor>; thread_oks ts tas \\<rbrakk> \\<Longrightarrow> redT_updTs' ts tas t = \\<lfloor>xw\\<rfloor>\"", "lemma thread_ok_new_thread:\n  \"thread_ok ts (NewThread t m' x) \\<Longrightarrow> ts t = None\"", "lemma thread_oks_new_thread:\n  \"\\<lbrakk> thread_oks ts tas; NewThread t x m \\<in> set tas \\<rbrakk> \\<Longrightarrow> ts t = None\"", "lemma redT_updT_new_thread_ts:\n  \"thread_ok ts (NewThread t x m) \\<Longrightarrow> redT_updT ts (NewThread t x m) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\"", "lemma redT_updTs_new_thread_ts:\n  \"\\<lbrakk> thread_oks ts tas; NewThread t x m \\<in> set tas \\<rbrakk> \\<Longrightarrow> redT_updTs ts tas t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\"", "lemma redT_updT_new_thread:\n  \"\\<lbrakk> redT_updT ts ta t = \\<lfloor>(x, w)\\<rfloor>; thread_ok ts ta; ts t = None \\<rbrakk> \\<Longrightarrow> \\<exists>m. ta = NewThread t x m \\<and> w = no_wait_locks\"", "lemma redT_updTs_new_thread:\n  \"\\<lbrakk> redT_updTs ts tas t = \\<lfloor>(x, w)\\<rfloor>; thread_oks ts tas; ts t = None \\<rbrakk> \n  \\<Longrightarrow> \\<exists>m .NewThread t x m \\<in> set tas \\<and> w = no_wait_locks\"", "lemma redT_updT_upd:\n  \"\\<lbrakk> ts t = \\<lfloor>xw\\<rfloor>; thread_ok ts ta \\<rbrakk> \\<Longrightarrow> redT_updT ts ta(t \\<mapsto> xw') = redT_updT (ts(t \\<mapsto> xw')) ta\"", "lemma redT_updTs_upd:\n  \"\\<lbrakk> ts t = \\<lfloor>xw\\<rfloor>; thread_oks ts tas \\<rbrakk> \\<Longrightarrow> redT_updTs ts tas(t \\<mapsto> xw') = redT_updTs (ts(t \\<mapsto> xw')) tas\"", "lemma thread_ok_upd:\n  \"ts t = \\<lfloor>xln\\<rfloor> \\<Longrightarrow> thread_ok (ts(t \\<mapsto> xln')) ta = thread_ok ts ta\"", "lemma thread_oks_upd:\n  \"ts t = \\<lfloor>xln\\<rfloor> \\<Longrightarrow> thread_oks (ts(t \\<mapsto> xln')) tas = thread_oks ts tas\"", "lemma thread_ok_convert_new_thread_action [simp]:\n  \"thread_ok ts (convert_new_thread_action f ta) = thread_ok ts ta\"", "lemma redT_updT'_convert_new_thread_action_eq_None:\n  \"redT_updT' ts (convert_new_thread_action f ta) t = None \\<longleftrightarrow> redT_updT' ts ta t = None\"", "lemma thread_oks_convert_new_thread_action [simp]:\n  \"thread_oks ts (map (convert_new_thread_action f) tas) = thread_oks ts tas\"", "lemma map_redT_updT:\n  \"map_option (map_prod f id) (redT_updT ts ta t) = \n  redT_updT (\\<lambda>t. map_option (map_prod f id) (ts t)) (convert_new_thread_action f ta) t\"", "lemma map_redT_updTs:\n  \"map_option (map_prod f id) (redT_updTs ts tas t) = \n  redT_updTs (\\<lambda>t. map_option (map_prod f id) (ts t)) (map (convert_new_thread_action f) tas) t\""], "translations": [["", "lemma free_thread_id_iff: \"free_thread_id ts t = (ts t = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. free_thread_id ts t = (ts t = None)", "by(auto elim: free_thread_id.cases intro: free_thread_id.intros)"], ["", "text\\<open>Update functions for the multithreaded state\\<close>"], ["", "fun redT_updT :: \"('l,'t,'x) thread_info \\<Rightarrow> ('t,'x,'m) new_thread_action \\<Rightarrow> ('l,'t,'x) thread_info\"\nwhere\n  \"redT_updT ts (NewThread t' x m) = ts(t' \\<mapsto> (x, no_wait_locks))\"\n| \"redT_updT ts _ = ts\""], ["", "fun redT_updTs :: \"('l,'t,'x) thread_info \\<Rightarrow> ('t,'x,'m) new_thread_action list \\<Rightarrow> ('l,'t,'x) thread_info\"\nwhere\n  \"redT_updTs ts [] = ts\"\n| \"redT_updTs ts (ta#tas) = redT_updTs (redT_updT ts ta) tas\""], ["", "lemma redT_updTs_append [simp]:\n  \"redT_updTs ts (tas @ tas') = redT_updTs (redT_updTs ts tas) tas'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redT_updTs ts (tas @ tas') = redT_updTs (redT_updTs ts tas) tas'", "by(induct ts tas rule: redT_updTs.induct) auto"], ["", "lemma redT_updT_None: \n  \"redT_updT ts ta t = None \\<Longrightarrow> ts t = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redT_updT ts ta t = None \\<Longrightarrow> ts t = None", "by(cases ta)(auto split: if_splits)"], ["", "lemma redT_updTs_None: \"redT_updTs ts tas t = None \\<Longrightarrow> ts t = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redT_updTs ts tas t = None \\<Longrightarrow> ts t = None", "by(induct ts tas rule: redT_updTs.induct)(auto intro: redT_updT_None)"], ["", "lemma redT_updT_Some1:\n  \"ts t = \\<lfloor>xw\\<rfloor> \\<Longrightarrow> \\<exists>xw. redT_updT ts ta t = \\<lfloor>xw\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts t = \\<lfloor>xw\\<rfloor> \\<Longrightarrow>\n    \\<exists>xw. redT_updT ts ta t = \\<lfloor>xw\\<rfloor>", "by(cases ta) auto"], ["", "lemma redT_updTs_Some1:\n  \"ts t = \\<lfloor>xw\\<rfloor> \\<Longrightarrow> \\<exists>xw. redT_updTs ts tas t = \\<lfloor>xw\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts t = \\<lfloor>xw\\<rfloor> \\<Longrightarrow>\n    \\<exists>xw. redT_updTs ts tas t = \\<lfloor>xw\\<rfloor>", "unfolding not_None_eq[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ts t = \\<lfloor>xw\\<rfloor> \\<Longrightarrow>\n    redT_updTs ts tas t \\<noteq> None", "by(induct ts tas arbitrary: xw rule: redT_updTs.induct)(simp_all del: split_paired_Ex, blast dest: redT_updT_Some1)"], ["", "lemma redT_updT_finite_dom_inv:\n  \"finite (dom (redT_updT ts ta)) = finite (dom ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom (redT_updT ts ta)) = finite (dom ts)", "by(cases ta) auto"], ["", "lemma redT_updTs_finite_dom_inv:\n  \"finite (dom (redT_updTs ts tas)) = finite (dom ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom (redT_updTs ts tas)) = finite (dom ts)", "by(induct ts tas rule: redT_updTs.induct)(simp_all add: redT_updT_finite_dom_inv)"], ["", "text\\<open>Preconditions for thread creation actions\\<close>"], ["", "text\\<open>These primed versions are for checking preconditions only. They allow the thread actions to have a type for thread-local information that is different than the thread info state itself.\\<close>"], ["", "fun redT_updT' :: \"('l,'t,'x) thread_info \\<Rightarrow> ('t,'x','m) new_thread_action \\<Rightarrow> ('l,'t,'x) thread_info\"\nwhere\n  \"redT_updT' ts (NewThread t' x m) = ts(t' \\<mapsto> (undefined, no_wait_locks))\"\n| \"redT_updT' ts _ = ts\""], ["", "fun redT_updTs' :: \"('l,'t,'x) thread_info \\<Rightarrow> ('t,'x','m) new_thread_action list \\<Rightarrow> ('l,'t,'x) thread_info\"\nwhere\n  \"redT_updTs' ts [] = ts\"\n| \"redT_updTs' ts (ta#tas) = redT_updTs' (redT_updT' ts ta) tas\""], ["", "lemma redT_updT'_None: \n  \"redT_updT' ts ta t = None \\<Longrightarrow> ts t = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redT_updT' ts ta t = None \\<Longrightarrow> ts t = None", "by(cases ta)(auto split: if_splits)"], ["", "primrec thread_ok :: \"('l,'t,'x) thread_info \\<Rightarrow> ('t,'x','m) new_thread_action \\<Rightarrow> bool\"\nwhere\n  \"thread_ok ts (NewThread t x m) = free_thread_id ts t\"\n| \"thread_ok ts (ThreadExists t b) = (b \\<noteq> free_thread_id ts t)\""], ["", "fun thread_oks :: \"('l,'t,'x) thread_info \\<Rightarrow> ('t,'x','m) new_thread_action list \\<Rightarrow> bool\"\nwhere\n  \"thread_oks ts [] = True\"\n| \"thread_oks ts (ta#tas) = (thread_ok ts ta \\<and> thread_oks (redT_updT' ts ta) tas)\""], ["", "lemma thread_ok_ts_change:\n  \"(\\<And>t. ts t = None \\<longleftrightarrow> ts' t = None) \\<Longrightarrow> thread_ok ts ta \\<longleftrightarrow> thread_ok ts' ta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t. (ts t = None) = (ts' t = None)) \\<Longrightarrow>\n    thread_ok ts ta = thread_ok ts' ta", "by(cases ta)(auto simp add: free_thread_id_iff)"], ["", "lemma thread_oks_ts_change:\n  \"(\\<And>t. ts t = None \\<longleftrightarrow> ts' t = None) \\<Longrightarrow> thread_oks ts tas \\<longleftrightarrow> thread_oks ts' tas\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t. (ts t = None) = (ts' t = None)) \\<Longrightarrow>\n    thread_oks ts tas = thread_oks ts' tas", "proof(induct tas arbitrary: ts ts')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ts ts'.\n       (\\<And>t. (ts t = None) = (ts' t = None)) \\<Longrightarrow>\n       thread_oks ts [] = thread_oks ts' []\n 2. \\<And>a tas ts ts'.\n       \\<lbrakk>\\<And>ts ts'.\n                   (\\<And>t.\n                       (ts t = None) = (ts' t = None)) \\<Longrightarrow>\n                   thread_oks ts tas = thread_oks ts' tas;\n        \\<And>t. (ts t = None) = (ts' t = None)\\<rbrakk>\n       \\<Longrightarrow> thread_oks ts (a # tas) = thread_oks ts' (a # tas)", "case Nil"], ["proof (state)\nthis:\n  (ts ?t = None) = (ts' ?t = None)\n\ngoal (2 subgoals):\n 1. \\<And>ts ts'.\n       (\\<And>t. (ts t = None) = (ts' t = None)) \\<Longrightarrow>\n       thread_oks ts [] = thread_oks ts' []\n 2. \\<And>a tas ts ts'.\n       \\<lbrakk>\\<And>ts ts'.\n                   (\\<And>t.\n                       (ts t = None) = (ts' t = None)) \\<Longrightarrow>\n                   thread_oks ts tas = thread_oks ts' tas;\n        \\<And>t. (ts t = None) = (ts' t = None)\\<rbrakk>\n       \\<Longrightarrow> thread_oks ts (a # tas) = thread_oks ts' (a # tas)", "thus ?case"], ["proof (prove)\nusing this:\n  (ts ?t = None) = (ts' ?t = None)\n\ngoal (1 subgoal):\n 1. thread_oks ts [] = thread_oks ts' []", "by simp"], ["proof (state)\nthis:\n  thread_oks ts [] = thread_oks ts' []\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts ts'.\n       \\<lbrakk>\\<And>ts ts'.\n                   (\\<And>t.\n                       (ts t = None) = (ts' t = None)) \\<Longrightarrow>\n                   thread_oks ts tas = thread_oks ts' tas;\n        \\<And>t. (ts t = None) = (ts' t = None)\\<rbrakk>\n       \\<Longrightarrow> thread_oks ts (a # tas) = thread_oks ts' (a # tas)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a tas ts ts'.\n       \\<lbrakk>\\<And>ts ts'.\n                   (\\<And>t.\n                       (ts t = None) = (ts' t = None)) \\<Longrightarrow>\n                   thread_oks ts tas = thread_oks ts' tas;\n        \\<And>t. (ts t = None) = (ts' t = None)\\<rbrakk>\n       \\<Longrightarrow> thread_oks ts (a # tas) = thread_oks ts' (a # tas)", "case (Cons ta tas ts ts')"], ["proof (state)\nthis:\n  (\\<And>t. (?ts t = None) = (?ts' t = None)) \\<Longrightarrow>\n  thread_oks ?ts tas = thread_oks ?ts' tas\n  (ts ?t = None) = (ts' ?t = None)\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts ts'.\n       \\<lbrakk>\\<And>ts ts'.\n                   (\\<And>t.\n                       (ts t = None) = (ts' t = None)) \\<Longrightarrow>\n                   thread_oks ts tas = thread_oks ts' tas;\n        \\<And>t. (ts t = None) = (ts' t = None)\\<rbrakk>\n       \\<Longrightarrow> thread_oks ts (a # tas) = thread_oks ts' (a # tas)", "note IH = \\<open>\\<And>ts ts'. (\\<And>t. (ts t = None) = (ts' t = None)) \\<Longrightarrow> thread_oks ts tas = thread_oks ts' tas\\<close>"], ["proof (state)\nthis:\n  (\\<And>t. (?ts t = None) = (?ts' t = None)) \\<Longrightarrow>\n  thread_oks ?ts tas = thread_oks ?ts' tas\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts ts'.\n       \\<lbrakk>\\<And>ts ts'.\n                   (\\<And>t.\n                       (ts t = None) = (ts' t = None)) \\<Longrightarrow>\n                   thread_oks ts tas = thread_oks ts' tas;\n        \\<And>t. (ts t = None) = (ts' t = None)\\<rbrakk>\n       \\<Longrightarrow> thread_oks ts (a # tas) = thread_oks ts' (a # tas)", "note eq = \\<open>\\<And>t. (ts t = None) = (ts' t = None)\\<close>"], ["proof (state)\nthis:\n  (ts ?t = None) = (ts' ?t = None)\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts ts'.\n       \\<lbrakk>\\<And>ts ts'.\n                   (\\<And>t.\n                       (ts t = None) = (ts' t = None)) \\<Longrightarrow>\n                   thread_oks ts tas = thread_oks ts' tas;\n        \\<And>t. (ts t = None) = (ts' t = None)\\<rbrakk>\n       \\<Longrightarrow> thread_oks ts (a # tas) = thread_oks ts' (a # tas)", "from eq"], ["proof (chain)\npicking this:\n  (ts ?t = None) = (ts' ?t = None)", "have \"thread_ok ts ta \\<longleftrightarrow> thread_ok ts' ta\""], ["proof (prove)\nusing this:\n  (ts ?t = None) = (ts' ?t = None)\n\ngoal (1 subgoal):\n 1. thread_ok ts ta = thread_ok ts' ta", "by(rule thread_ok_ts_change)"], ["proof (state)\nthis:\n  thread_ok ts ta = thread_ok ts' ta\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts ts'.\n       \\<lbrakk>\\<And>ts ts'.\n                   (\\<And>t.\n                       (ts t = None) = (ts' t = None)) \\<Longrightarrow>\n                   thread_oks ts tas = thread_oks ts' tas;\n        \\<And>t. (ts t = None) = (ts' t = None)\\<rbrakk>\n       \\<Longrightarrow> thread_oks ts (a # tas) = thread_oks ts' (a # tas)", "moreover"], ["proof (state)\nthis:\n  thread_ok ts ta = thread_ok ts' ta\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts ts'.\n       \\<lbrakk>\\<And>ts ts'.\n                   (\\<And>t.\n                       (ts t = None) = (ts' t = None)) \\<Longrightarrow>\n                   thread_oks ts tas = thread_oks ts' tas;\n        \\<And>t. (ts t = None) = (ts' t = None)\\<rbrakk>\n       \\<Longrightarrow> thread_oks ts (a # tas) = thread_oks ts' (a # tas)", "from eq"], ["proof (chain)\npicking this:\n  (ts ?t = None) = (ts' ?t = None)", "have \"\\<And>t. (redT_updT' ts ta t = None) = (redT_updT' ts' ta t = None)\""], ["proof (prove)\nusing this:\n  (ts ?t = None) = (ts' ?t = None)\n\ngoal (1 subgoal):\n 1. \\<And>t. (redT_updT' ts ta t = None) = (redT_updT' ts' ta t = None)", "by(cases ta)(auto)"], ["proof (state)\nthis:\n  (redT_updT' ts ta ?t = None) = (redT_updT' ts' ta ?t = None)\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts ts'.\n       \\<lbrakk>\\<And>ts ts'.\n                   (\\<And>t.\n                       (ts t = None) = (ts' t = None)) \\<Longrightarrow>\n                   thread_oks ts tas = thread_oks ts' tas;\n        \\<And>t. (ts t = None) = (ts' t = None)\\<rbrakk>\n       \\<Longrightarrow> thread_oks ts (a # tas) = thread_oks ts' (a # tas)", "hence \"thread_oks (redT_updT' ts ta) tas = thread_oks (redT_updT' ts' ta) tas\""], ["proof (prove)\nusing this:\n  (redT_updT' ts ta ?t = None) = (redT_updT' ts' ta ?t = None)\n\ngoal (1 subgoal):\n 1. thread_oks (redT_updT' ts ta) tas = thread_oks (redT_updT' ts' ta) tas", "by(rule IH)"], ["proof (state)\nthis:\n  thread_oks (redT_updT' ts ta) tas = thread_oks (redT_updT' ts' ta) tas\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts ts'.\n       \\<lbrakk>\\<And>ts ts'.\n                   (\\<And>t.\n                       (ts t = None) = (ts' t = None)) \\<Longrightarrow>\n                   thread_oks ts tas = thread_oks ts' tas;\n        \\<And>t. (ts t = None) = (ts' t = None)\\<rbrakk>\n       \\<Longrightarrow> thread_oks ts (a # tas) = thread_oks ts' (a # tas)", "ultimately"], ["proof (chain)\npicking this:\n  thread_ok ts ta = thread_ok ts' ta\n  thread_oks (redT_updT' ts ta) tas = thread_oks (redT_updT' ts' ta) tas", "show ?case"], ["proof (prove)\nusing this:\n  thread_ok ts ta = thread_ok ts' ta\n  thread_oks (redT_updT' ts ta) tas = thread_oks (redT_updT' ts' ta) tas\n\ngoal (1 subgoal):\n 1. thread_oks ts (ta # tas) = thread_oks ts' (ta # tas)", "by simp"], ["proof (state)\nthis:\n  thread_oks ts (ta # tas) = thread_oks ts' (ta # tas)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma redT_updT'_eq_None_conv: \n  \"(\\<And>t. ts t = None \\<longleftrightarrow> ts' t = None) \\<Longrightarrow> redT_updT' ts ta t = None \\<longleftrightarrow> redT_updT ts' ta t = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t. (ts t = None) = (ts' t = None)) \\<Longrightarrow>\n    (redT_updT' ts ta t = None) = (redT_updT ts' ta t = None)", "by(cases ta) simp_all"], ["", "lemma redT_updTs'_eq_None_conv:\n  \"(\\<And>t. ts t = None \\<longleftrightarrow> ts' t = None) \\<Longrightarrow> redT_updTs' ts tas t = None \\<longleftrightarrow> redT_updTs ts' tas t = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t. (ts t = None) = (ts' t = None)) \\<Longrightarrow>\n    (redT_updTs' ts tas t = None) = (redT_updTs ts' tas t = None)", "apply(induct tas arbitrary: ts ts')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ts ts'.\n       (\\<And>t. (ts t = None) = (ts' t = None)) \\<Longrightarrow>\n       (redT_updTs' ts [] t = None) = (redT_updTs ts' [] t = None)\n 2. \\<And>a tas ts ts'.\n       \\<lbrakk>\\<And>ts ts'.\n                   (\\<And>t.\n                       (ts t = None) = (ts' t = None)) \\<Longrightarrow>\n                   (redT_updTs' ts tas t = None) =\n                   (redT_updTs ts' tas t = None);\n        \\<And>t. (ts t = None) = (ts' t = None)\\<rbrakk>\n       \\<Longrightarrow> (redT_updTs' ts (a # tas) t = None) =\n                         (redT_updTs ts' (a # tas) t = None)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a tas ts ts'.\n       \\<lbrakk>\\<And>ts ts'.\n                   (\\<And>t.\n                       (ts t = None) = (ts' t = None)) \\<Longrightarrow>\n                   (redT_updTs' ts tas t = None) =\n                   (redT_updTs ts' tas t = None);\n        \\<And>t. (ts t = None) = (ts' t = None)\\<rbrakk>\n       \\<Longrightarrow> (redT_updTs' (redT_updT' ts a) tas t = None) =\n                         (redT_updTs (redT_updT ts' a) tas t = None)", "apply(blast intro: redT_updT'_eq_None_conv del: iffI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma thread_oks_redT_updT_conv [simp]:\n  \"thread_oks (redT_updT' ts ta) tas = thread_oks (redT_updT ts ta) tas\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thread_oks (redT_updT' ts ta) tas = thread_oks (redT_updT ts ta) tas", "by(rule thread_oks_ts_change)(rule redT_updT'_eq_None_conv refl)+"], ["", "lemma thread_oks_append [simp]:\n  \"thread_oks ts (tas @ tas') = (thread_oks ts tas \\<and> thread_oks (redT_updTs' ts tas) tas')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thread_oks ts (tas @ tas') =\n    (thread_oks ts tas \\<and> thread_oks (redT_updTs' ts tas) tas')", "by(induct tas arbitrary: ts, auto)"], ["", "lemma thread_oks_redT_updTs_conv [simp]:\n  \"thread_oks (redT_updTs' ts ta) tas = thread_oks (redT_updTs ts ta) tas\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thread_oks (redT_updTs' ts ta) tas = thread_oks (redT_updTs ts ta) tas", "by(rule thread_oks_ts_change)(rule redT_updTs'_eq_None_conv refl)+"], ["", "lemma redT_updT_Some:\n  \"\\<lbrakk> ts t = \\<lfloor>xw\\<rfloor>; thread_ok ts ta \\<rbrakk> \\<Longrightarrow> redT_updT ts ta t = \\<lfloor>xw\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ts t = \\<lfloor>xw\\<rfloor>; thread_ok ts ta\\<rbrakk>\n    \\<Longrightarrow> redT_updT ts ta t = \\<lfloor>xw\\<rfloor>", "by(cases ta) auto"], ["", "lemma redT_updTs_Some:\n  \"\\<lbrakk> ts t = \\<lfloor>xw\\<rfloor>; thread_oks ts tas \\<rbrakk> \\<Longrightarrow> redT_updTs ts tas t = \\<lfloor>xw\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ts t = \\<lfloor>xw\\<rfloor>; thread_oks ts tas\\<rbrakk>\n    \\<Longrightarrow> redT_updTs ts tas t = \\<lfloor>xw\\<rfloor>", "by(induct ts tas rule: redT_updTs.induct)(auto intro: redT_updT_Some)"], ["", "lemma redT_updT'_Some:\n  \"\\<lbrakk> ts t = \\<lfloor>xw\\<rfloor>; thread_ok ts ta \\<rbrakk> \\<Longrightarrow> redT_updT' ts ta t = \\<lfloor>xw\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ts t = \\<lfloor>xw\\<rfloor>; thread_ok ts ta\\<rbrakk>\n    \\<Longrightarrow> redT_updT' ts ta t = \\<lfloor>xw\\<rfloor>", "by(cases ta) auto"], ["", "lemma redT_updTs'_Some:\n  \"\\<lbrakk> ts t = \\<lfloor>xw\\<rfloor>; thread_oks ts tas \\<rbrakk> \\<Longrightarrow> redT_updTs' ts tas t = \\<lfloor>xw\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ts t = \\<lfloor>xw\\<rfloor>; thread_oks ts tas\\<rbrakk>\n    \\<Longrightarrow> redT_updTs' ts tas t = \\<lfloor>xw\\<rfloor>", "by(induct ts tas rule: redT_updTs'.induct)(auto intro: redT_updT'_Some)"], ["", "lemma thread_ok_new_thread:\n  \"thread_ok ts (NewThread t m' x) \\<Longrightarrow> ts t = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thread_ok ts (NewThread t m' x) \\<Longrightarrow> ts t = None", "by(auto)"], ["", "lemma thread_oks_new_thread:\n  \"\\<lbrakk> thread_oks ts tas; NewThread t x m \\<in> set tas \\<rbrakk> \\<Longrightarrow> ts t = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>thread_oks ts tas; NewThread t x m \\<in> set tas\\<rbrakk>\n    \\<Longrightarrow> ts t = None", "by(induct ts tas rule: thread_oks.induct)(auto intro: redT_updT'_None)"], ["", "lemma redT_updT_new_thread_ts:\n  \"thread_ok ts (NewThread t x m) \\<Longrightarrow> redT_updT ts (NewThread t x m) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thread_ok ts (NewThread t x m) \\<Longrightarrow>\n    redT_updT ts (NewThread t x m) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>", "by(simp)"], ["", "lemma redT_updTs_new_thread_ts:\n  \"\\<lbrakk> thread_oks ts tas; NewThread t x m \\<in> set tas \\<rbrakk> \\<Longrightarrow> redT_updTs ts tas t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>thread_oks ts tas; NewThread t x m \\<in> set tas\\<rbrakk>\n    \\<Longrightarrow> redT_updTs ts tas t =\n                      \\<lfloor>(x, no_wait_locks)\\<rfloor>", "by(induct ts tas rule: redT_updTs.induct)(auto intro: redT_updTs_Some)"], ["", "lemma redT_updT_new_thread:\n  \"\\<lbrakk> redT_updT ts ta t = \\<lfloor>(x, w)\\<rfloor>; thread_ok ts ta; ts t = None \\<rbrakk> \\<Longrightarrow> \\<exists>m. ta = NewThread t x m \\<and> w = no_wait_locks\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>redT_updT ts ta t = \\<lfloor>(x, w)\\<rfloor>; thread_ok ts ta;\n     ts t = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>m.\n                         ta = NewThread t x m \\<and> w = no_wait_locks", "by(cases ta)(auto split: if_split_asm)"], ["", "lemma redT_updTs_new_thread:\n  \"\\<lbrakk> redT_updTs ts tas t = \\<lfloor>(x, w)\\<rfloor>; thread_oks ts tas; ts t = None \\<rbrakk> \n  \\<Longrightarrow> \\<exists>m .NewThread t x m \\<in> set tas \\<and> w = no_wait_locks\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>redT_updTs ts tas t = \\<lfloor>(x, w)\\<rfloor>;\n     thread_oks ts tas; ts t = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>m.\n                         NewThread t x m \\<in> set tas \\<and>\n                         w = no_wait_locks", "proof(induct tas arbitrary: ts)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ts.\n       \\<lbrakk>redT_updTs ts [] t = \\<lfloor>(x, w)\\<rfloor>;\n        thread_oks ts []; ts t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            NewThread t x m \\<in> set [] \\<and>\n                            w = no_wait_locks\n 2. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>redT_updTs ts tas t = \\<lfloor>(x, w)\\<rfloor>;\n                    thread_oks ts tas; ts t = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>m.\n  NewThread t x m \\<in> set tas \\<and> w = no_wait_locks;\n        redT_updTs ts (a # tas) t = \\<lfloor>(x, w)\\<rfloor>;\n        thread_oks ts (a # tas); ts t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            NewThread t x m \\<in> set (a # tas) \\<and>\n                            w = no_wait_locks", "case Nil"], ["proof (state)\nthis:\n  redT_updTs ts [] t = \\<lfloor>(x, w)\\<rfloor>\n  thread_oks ts []\n  ts t = None\n\ngoal (2 subgoals):\n 1. \\<And>ts.\n       \\<lbrakk>redT_updTs ts [] t = \\<lfloor>(x, w)\\<rfloor>;\n        thread_oks ts []; ts t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            NewThread t x m \\<in> set [] \\<and>\n                            w = no_wait_locks\n 2. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>redT_updTs ts tas t = \\<lfloor>(x, w)\\<rfloor>;\n                    thread_oks ts tas; ts t = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>m.\n  NewThread t x m \\<in> set tas \\<and> w = no_wait_locks;\n        redT_updTs ts (a # tas) t = \\<lfloor>(x, w)\\<rfloor>;\n        thread_oks ts (a # tas); ts t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            NewThread t x m \\<in> set (a # tas) \\<and>\n                            w = no_wait_locks", "thus ?case"], ["proof (prove)\nusing this:\n  redT_updTs ts [] t = \\<lfloor>(x, w)\\<rfloor>\n  thread_oks ts []\n  ts t = None\n\ngoal (1 subgoal):\n 1. \\<exists>m. NewThread t x m \\<in> set [] \\<and> w = no_wait_locks", "by simp"], ["proof (state)\nthis:\n  \\<exists>m. NewThread t x m \\<in> set [] \\<and> w = no_wait_locks\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>redT_updTs ts tas t = \\<lfloor>(x, w)\\<rfloor>;\n                    thread_oks ts tas; ts t = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>m.\n  NewThread t x m \\<in> set tas \\<and> w = no_wait_locks;\n        redT_updTs ts (a # tas) t = \\<lfloor>(x, w)\\<rfloor>;\n        thread_oks ts (a # tas); ts t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            NewThread t x m \\<in> set (a # tas) \\<and>\n                            w = no_wait_locks", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>redT_updTs ts tas t = \\<lfloor>(x, w)\\<rfloor>;\n                    thread_oks ts tas; ts t = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>m.\n  NewThread t x m \\<in> set tas \\<and> w = no_wait_locks;\n        redT_updTs ts (a # tas) t = \\<lfloor>(x, w)\\<rfloor>;\n        thread_oks ts (a # tas); ts t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            NewThread t x m \\<in> set (a # tas) \\<and>\n                            w = no_wait_locks", "case (Cons TA TAS TS)"], ["proof (state)\nthis:\n  \\<lbrakk>redT_updTs ?ts TAS t = \\<lfloor>(x, w)\\<rfloor>;\n   thread_oks ?ts TAS; ?ts t = None\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m.\n                       NewThread t x m \\<in> set TAS \\<and>\n                       w = no_wait_locks\n  redT_updTs TS (TA # TAS) t = \\<lfloor>(x, w)\\<rfloor>\n  thread_oks TS (TA # TAS)\n  TS t = None\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>redT_updTs ts tas t = \\<lfloor>(x, w)\\<rfloor>;\n                    thread_oks ts tas; ts t = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>m.\n  NewThread t x m \\<in> set tas \\<and> w = no_wait_locks;\n        redT_updTs ts (a # tas) t = \\<lfloor>(x, w)\\<rfloor>;\n        thread_oks ts (a # tas); ts t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            NewThread t x m \\<in> set (a # tas) \\<and>\n                            w = no_wait_locks", "note IH = \\<open>\\<And>ts. \\<lbrakk>redT_updTs ts TAS t = \\<lfloor>(x, w)\\<rfloor>; thread_oks ts TAS; ts t = None\\<rbrakk> \\<Longrightarrow> \\<exists>m. NewThread t x m \\<in> set TAS \\<and> w = no_wait_locks\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>redT_updTs ?ts TAS t = \\<lfloor>(x, w)\\<rfloor>;\n   thread_oks ?ts TAS; ?ts t = None\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m.\n                       NewThread t x m \\<in> set TAS \\<and>\n                       w = no_wait_locks\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>redT_updTs ts tas t = \\<lfloor>(x, w)\\<rfloor>;\n                    thread_oks ts tas; ts t = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>m.\n  NewThread t x m \\<in> set tas \\<and> w = no_wait_locks;\n        redT_updTs ts (a # tas) t = \\<lfloor>(x, w)\\<rfloor>;\n        thread_oks ts (a # tas); ts t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            NewThread t x m \\<in> set (a # tas) \\<and>\n                            w = no_wait_locks", "note es't = \\<open>redT_updTs TS (TA # TAS) t = \\<lfloor>(x, w)\\<rfloor>\\<close>"], ["proof (state)\nthis:\n  redT_updTs TS (TA # TAS) t = \\<lfloor>(x, w)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>redT_updTs ts tas t = \\<lfloor>(x, w)\\<rfloor>;\n                    thread_oks ts tas; ts t = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>m.\n  NewThread t x m \\<in> set tas \\<and> w = no_wait_locks;\n        redT_updTs ts (a # tas) t = \\<lfloor>(x, w)\\<rfloor>;\n        thread_oks ts (a # tas); ts t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            NewThread t x m \\<in> set (a # tas) \\<and>\n                            w = no_wait_locks", "note cct = \\<open>thread_oks TS (TA # TAS)\\<close>"], ["proof (state)\nthis:\n  thread_oks TS (TA # TAS)\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>redT_updTs ts tas t = \\<lfloor>(x, w)\\<rfloor>;\n                    thread_oks ts tas; ts t = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>m.\n  NewThread t x m \\<in> set tas \\<and> w = no_wait_locks;\n        redT_updTs ts (a # tas) t = \\<lfloor>(x, w)\\<rfloor>;\n        thread_oks ts (a # tas); ts t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            NewThread t x m \\<in> set (a # tas) \\<and>\n                            w = no_wait_locks", "hence cctta: \"thread_ok TS TA\" and ccts: \"thread_oks (redT_updT TS TA) TAS\""], ["proof (prove)\nusing this:\n  thread_oks TS (TA # TAS)\n\ngoal (1 subgoal):\n 1. thread_ok TS TA &&& thread_oks (redT_updT TS TA) TAS", "by auto"], ["proof (state)\nthis:\n  thread_ok TS TA\n  thread_oks (redT_updT TS TA) TAS\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>redT_updTs ts tas t = \\<lfloor>(x, w)\\<rfloor>;\n                    thread_oks ts tas; ts t = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>m.\n  NewThread t x m \\<in> set tas \\<and> w = no_wait_locks;\n        redT_updTs ts (a # tas) t = \\<lfloor>(x, w)\\<rfloor>;\n        thread_oks ts (a # tas); ts t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            NewThread t x m \\<in> set (a # tas) \\<and>\n                            w = no_wait_locks", "note est = \\<open>TS t = None\\<close>"], ["proof (state)\nthis:\n  TS t = None\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>redT_updTs ts tas t = \\<lfloor>(x, w)\\<rfloor>;\n                    thread_oks ts tas; ts t = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>m.\n  NewThread t x m \\<in> set tas \\<and> w = no_wait_locks;\n        redT_updTs ts (a # tas) t = \\<lfloor>(x, w)\\<rfloor>;\n        thread_oks ts (a # tas); ts t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            NewThread t x m \\<in> set (a # tas) \\<and>\n                            w = no_wait_locks", "{"], ["proof (state)\nthis:\n  TS t = None\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>redT_updTs ts tas t = \\<lfloor>(x, w)\\<rfloor>;\n                    thread_oks ts tas; ts t = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>m.\n  NewThread t x m \\<in> set tas \\<and> w = no_wait_locks;\n        redT_updTs ts (a # tas) t = \\<lfloor>(x, w)\\<rfloor>;\n        thread_oks ts (a # tas); ts t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            NewThread t x m \\<in> set (a # tas) \\<and>\n                            w = no_wait_locks", "fix X W"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>redT_updTs ts tas t = \\<lfloor>(x, w)\\<rfloor>;\n                    thread_oks ts tas; ts t = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>m.\n  NewThread t x m \\<in> set tas \\<and> w = no_wait_locks;\n        redT_updTs ts (a # tas) t = \\<lfloor>(x, w)\\<rfloor>;\n        thread_oks ts (a # tas); ts t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            NewThread t x m \\<in> set (a # tas) \\<and>\n                            w = no_wait_locks", "assume rest: \"redT_updT TS TA t = \\<lfloor>(X, W)\\<rfloor>\""], ["proof (state)\nthis:\n  redT_updT TS TA t = \\<lfloor>(X, W)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>redT_updTs ts tas t = \\<lfloor>(x, w)\\<rfloor>;\n                    thread_oks ts tas; ts t = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>m.\n  NewThread t x m \\<in> set tas \\<and> w = no_wait_locks;\n        redT_updTs ts (a # tas) t = \\<lfloor>(x, w)\\<rfloor>;\n        thread_oks ts (a # tas); ts t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            NewThread t x m \\<in> set (a # tas) \\<and>\n                            w = no_wait_locks", "then"], ["proof (chain)\npicking this:\n  redT_updT TS TA t = \\<lfloor>(X, W)\\<rfloor>", "obtain m where \"TA = NewThread t X m \\<and> W = no_wait_locks\""], ["proof (prove)\nusing this:\n  redT_updT TS TA t = \\<lfloor>(X, W)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        TA = NewThread t X m \\<and> W = no_wait_locks \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using cctta est"], ["proof (prove)\nusing this:\n  redT_updT TS TA t = \\<lfloor>(X, W)\\<rfloor>\n  thread_ok TS TA\n  TS t = None\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        TA = NewThread t X m \\<and> W = no_wait_locks \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto dest!: redT_updT_new_thread)"], ["proof (state)\nthis:\n  TA = NewThread t X m \\<and> W = no_wait_locks\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>redT_updTs ts tas t = \\<lfloor>(x, w)\\<rfloor>;\n                    thread_oks ts tas; ts t = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>m.\n  NewThread t x m \\<in> set tas \\<and> w = no_wait_locks;\n        redT_updTs ts (a # tas) t = \\<lfloor>(x, w)\\<rfloor>;\n        thread_oks ts (a # tas); ts t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            NewThread t x m \\<in> set (a # tas) \\<and>\n                            w = no_wait_locks", "then"], ["proof (chain)\npicking this:\n  TA = NewThread t X m \\<and> W = no_wait_locks", "obtain \"TA = NewThread t X m\" \"W = no_wait_locks\""], ["proof (prove)\nusing this:\n  TA = NewThread t X m \\<and> W = no_wait_locks\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>TA = NewThread t X m; W = no_wait_locks\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  TA = NewThread t X m\n  W = no_wait_locks\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>redT_updTs ts tas t = \\<lfloor>(x, w)\\<rfloor>;\n                    thread_oks ts tas; ts t = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>m.\n  NewThread t x m \\<in> set tas \\<and> w = no_wait_locks;\n        redT_updTs ts (a # tas) t = \\<lfloor>(x, w)\\<rfloor>;\n        thread_oks ts (a # tas); ts t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            NewThread t x m \\<in> set (a # tas) \\<and>\n                            w = no_wait_locks", "moreover"], ["proof (state)\nthis:\n  TA = NewThread t X m\n  W = no_wait_locks\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>redT_updTs ts tas t = \\<lfloor>(x, w)\\<rfloor>;\n                    thread_oks ts tas; ts t = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>m.\n  NewThread t x m \\<in> set tas \\<and> w = no_wait_locks;\n        redT_updTs ts (a # tas) t = \\<lfloor>(x, w)\\<rfloor>;\n        thread_oks ts (a # tas); ts t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            NewThread t x m \\<in> set (a # tas) \\<and>\n                            w = no_wait_locks", "from rest ccts"], ["proof (chain)\npicking this:\n  redT_updT TS TA t = \\<lfloor>(X, W)\\<rfloor>\n  thread_oks (redT_updT TS TA) TAS", "have \"redT_updTs TS (TA # TAS) t = \\<lfloor>(X, W)\\<rfloor>\""], ["proof (prove)\nusing this:\n  redT_updT TS TA t = \\<lfloor>(X, W)\\<rfloor>\n  thread_oks (redT_updT TS TA) TAS\n\ngoal (1 subgoal):\n 1. redT_updTs TS (TA # TAS) t = \\<lfloor>(X, W)\\<rfloor>", "by(auto intro:redT_updTs_Some)"], ["proof (state)\nthis:\n  redT_updTs TS (TA # TAS) t = \\<lfloor>(X, W)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>redT_updTs ts tas t = \\<lfloor>(x, w)\\<rfloor>;\n                    thread_oks ts tas; ts t = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>m.\n  NewThread t x m \\<in> set tas \\<and> w = no_wait_locks;\n        redT_updTs ts (a # tas) t = \\<lfloor>(x, w)\\<rfloor>;\n        thread_oks ts (a # tas); ts t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            NewThread t x m \\<in> set (a # tas) \\<and>\n                            w = no_wait_locks", "with es't"], ["proof (chain)\npicking this:\n  redT_updTs TS (TA # TAS) t = \\<lfloor>(x, w)\\<rfloor>\n  redT_updTs TS (TA # TAS) t = \\<lfloor>(X, W)\\<rfloor>", "have \"X = x\" \"W = w\""], ["proof (prove)\nusing this:\n  redT_updTs TS (TA # TAS) t = \\<lfloor>(x, w)\\<rfloor>\n  redT_updTs TS (TA # TAS) t = \\<lfloor>(X, W)\\<rfloor>\n\ngoal (1 subgoal):\n 1. X = x &&& W = w", "by auto"], ["proof (state)\nthis:\n  X = x\n  W = w\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>redT_updTs ts tas t = \\<lfloor>(x, w)\\<rfloor>;\n                    thread_oks ts tas; ts t = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>m.\n  NewThread t x m \\<in> set tas \\<and> w = no_wait_locks;\n        redT_updTs ts (a # tas) t = \\<lfloor>(x, w)\\<rfloor>;\n        thread_oks ts (a # tas); ts t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            NewThread t x m \\<in> set (a # tas) \\<and>\n                            w = no_wait_locks", "ultimately"], ["proof (chain)\npicking this:\n  TA = NewThread t X m\n  W = no_wait_locks\n  X = x\n  W = w", "have ?case"], ["proof (prove)\nusing this:\n  TA = NewThread t X m\n  W = no_wait_locks\n  X = x\n  W = w\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       NewThread t x m \\<in> set (TA # TAS) \\<and> w = no_wait_locks", "by auto"], ["proof (state)\nthis:\n  \\<exists>m. NewThread t x m \\<in> set (TA # TAS) \\<and> w = no_wait_locks\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>redT_updTs ts tas t = \\<lfloor>(x, w)\\<rfloor>;\n                    thread_oks ts tas; ts t = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>m.\n  NewThread t x m \\<in> set tas \\<and> w = no_wait_locks;\n        redT_updTs ts (a # tas) t = \\<lfloor>(x, w)\\<rfloor>;\n        thread_oks ts (a # tas); ts t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            NewThread t x m \\<in> set (a # tas) \\<and>\n                            w = no_wait_locks", "}"], ["proof (state)\nthis:\n  redT_updT TS TA t = \\<lfloor>(?X2, ?W2)\\<rfloor> \\<Longrightarrow>\n  \\<exists>m. NewThread t x m \\<in> set (TA # TAS) \\<and> w = no_wait_locks\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>redT_updTs ts tas t = \\<lfloor>(x, w)\\<rfloor>;\n                    thread_oks ts tas; ts t = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>m.\n  NewThread t x m \\<in> set tas \\<and> w = no_wait_locks;\n        redT_updTs ts (a # tas) t = \\<lfloor>(x, w)\\<rfloor>;\n        thread_oks ts (a # tas); ts t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            NewThread t x m \\<in> set (a # tas) \\<and>\n                            w = no_wait_locks", "moreover"], ["proof (state)\nthis:\n  redT_updT TS TA t = \\<lfloor>(?X2, ?W2)\\<rfloor> \\<Longrightarrow>\n  \\<exists>m. NewThread t x m \\<in> set (TA # TAS) \\<and> w = no_wait_locks\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>redT_updTs ts tas t = \\<lfloor>(x, w)\\<rfloor>;\n                    thread_oks ts tas; ts t = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>m.\n  NewThread t x m \\<in> set tas \\<and> w = no_wait_locks;\n        redT_updTs ts (a # tas) t = \\<lfloor>(x, w)\\<rfloor>;\n        thread_oks ts (a # tas); ts t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            NewThread t x m \\<in> set (a # tas) \\<and>\n                            w = no_wait_locks", "{"], ["proof (state)\nthis:\n  redT_updT TS TA t = \\<lfloor>(?X2, ?W2)\\<rfloor> \\<Longrightarrow>\n  \\<exists>m. NewThread t x m \\<in> set (TA # TAS) \\<and> w = no_wait_locks\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>redT_updTs ts tas t = \\<lfloor>(x, w)\\<rfloor>;\n                    thread_oks ts tas; ts t = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>m.\n  NewThread t x m \\<in> set tas \\<and> w = no_wait_locks;\n        redT_updTs ts (a # tas) t = \\<lfloor>(x, w)\\<rfloor>;\n        thread_oks ts (a # tas); ts t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            NewThread t x m \\<in> set (a # tas) \\<and>\n                            w = no_wait_locks", "assume rest: \"redT_updT TS TA t = None\""], ["proof (state)\nthis:\n  redT_updT TS TA t = None\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>redT_updTs ts tas t = \\<lfloor>(x, w)\\<rfloor>;\n                    thread_oks ts tas; ts t = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>m.\n  NewThread t x m \\<in> set tas \\<and> w = no_wait_locks;\n        redT_updTs ts (a # tas) t = \\<lfloor>(x, w)\\<rfloor>;\n        thread_oks ts (a # tas); ts t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            NewThread t x m \\<in> set (a # tas) \\<and>\n                            w = no_wait_locks", "hence \"\\<And>m. TA \\<noteq> NewThread t x m\""], ["proof (prove)\nusing this:\n  redT_updT TS TA t = None\n\ngoal (1 subgoal):\n 1. \\<And>m. TA \\<noteq> NewThread t x m", "using est cct"], ["proof (prove)\nusing this:\n  redT_updT TS TA t = None\n  TS t = None\n  thread_oks TS (TA # TAS)\n\ngoal (1 subgoal):\n 1. \\<And>m. TA \\<noteq> NewThread t x m", "by(clarsimp)"], ["proof (state)\nthis:\n  TA \\<noteq> NewThread t x ?m\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>redT_updTs ts tas t = \\<lfloor>(x, w)\\<rfloor>;\n                    thread_oks ts tas; ts t = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>m.\n  NewThread t x m \\<in> set tas \\<and> w = no_wait_locks;\n        redT_updTs ts (a # tas) t = \\<lfloor>(x, w)\\<rfloor>;\n        thread_oks ts (a # tas); ts t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            NewThread t x m \\<in> set (a # tas) \\<and>\n                            w = no_wait_locks", "with rest ccts es't"], ["proof (chain)\npicking this:\n  redT_updT TS TA t = None\n  thread_oks (redT_updT TS TA) TAS\n  redT_updTs TS (TA # TAS) t = \\<lfloor>(x, w)\\<rfloor>\n  TA \\<noteq> NewThread t x ?m", "have ?case"], ["proof (prove)\nusing this:\n  redT_updT TS TA t = None\n  thread_oks (redT_updT TS TA) TAS\n  redT_updTs TS (TA # TAS) t = \\<lfloor>(x, w)\\<rfloor>\n  TA \\<noteq> NewThread t x ?m\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       NewThread t x m \\<in> set (TA # TAS) \\<and> w = no_wait_locks", "by(auto dest: IH)"], ["proof (state)\nthis:\n  \\<exists>m. NewThread t x m \\<in> set (TA # TAS) \\<and> w = no_wait_locks\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>redT_updTs ts tas t = \\<lfloor>(x, w)\\<rfloor>;\n                    thread_oks ts tas; ts t = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>m.\n  NewThread t x m \\<in> set tas \\<and> w = no_wait_locks;\n        redT_updTs ts (a # tas) t = \\<lfloor>(x, w)\\<rfloor>;\n        thread_oks ts (a # tas); ts t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            NewThread t x m \\<in> set (a # tas) \\<and>\n                            w = no_wait_locks", "}"], ["proof (state)\nthis:\n  redT_updT TS TA t = None \\<Longrightarrow>\n  \\<exists>m. NewThread t x m \\<in> set (TA # TAS) \\<and> w = no_wait_locks\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<lbrakk>redT_updTs ts tas t = \\<lfloor>(x, w)\\<rfloor>;\n                    thread_oks ts tas; ts t = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>m.\n  NewThread t x m \\<in> set tas \\<and> w = no_wait_locks;\n        redT_updTs ts (a # tas) t = \\<lfloor>(x, w)\\<rfloor>;\n        thread_oks ts (a # tas); ts t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            NewThread t x m \\<in> set (a # tas) \\<and>\n                            w = no_wait_locks", "ultimately"], ["proof (chain)\npicking this:\n  redT_updT TS TA t = \\<lfloor>(?X2, ?W2)\\<rfloor> \\<Longrightarrow>\n  \\<exists>m. NewThread t x m \\<in> set (TA # TAS) \\<and> w = no_wait_locks\n  redT_updT TS TA t = None \\<Longrightarrow>\n  \\<exists>m. NewThread t x m \\<in> set (TA # TAS) \\<and> w = no_wait_locks", "show ?case"], ["proof (prove)\nusing this:\n  redT_updT TS TA t = \\<lfloor>(?X2, ?W2)\\<rfloor> \\<Longrightarrow>\n  \\<exists>m. NewThread t x m \\<in> set (TA # TAS) \\<and> w = no_wait_locks\n  redT_updT TS TA t = None \\<Longrightarrow>\n  \\<exists>m. NewThread t x m \\<in> set (TA # TAS) \\<and> w = no_wait_locks\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       NewThread t x m \\<in> set (TA # TAS) \\<and> w = no_wait_locks", "by(cases \"redT_updT TS TA t\", auto)"], ["proof (state)\nthis:\n  \\<exists>m. NewThread t x m \\<in> set (TA # TAS) \\<and> w = no_wait_locks\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma redT_updT_upd:\n  \"\\<lbrakk> ts t = \\<lfloor>xw\\<rfloor>; thread_ok ts ta \\<rbrakk> \\<Longrightarrow> redT_updT ts ta(t \\<mapsto> xw') = redT_updT (ts(t \\<mapsto> xw')) ta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ts t = \\<lfloor>xw\\<rfloor>; thread_ok ts ta\\<rbrakk>\n    \\<Longrightarrow> redT_updT ts ta(t \\<mapsto> xw') =\n                      redT_updT (ts(t \\<mapsto> xw')) ta", "by(cases ta)(fastforce intro: fun_upd_twist)+"], ["", "lemma redT_updTs_upd:\n  \"\\<lbrakk> ts t = \\<lfloor>xw\\<rfloor>; thread_oks ts tas \\<rbrakk> \\<Longrightarrow> redT_updTs ts tas(t \\<mapsto> xw') = redT_updTs (ts(t \\<mapsto> xw')) tas\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ts t = \\<lfloor>xw\\<rfloor>; thread_oks ts tas\\<rbrakk>\n    \\<Longrightarrow> redT_updTs ts tas(t \\<mapsto> xw') =\n                      redT_updTs (ts(t \\<mapsto> xw')) tas", "by(induct ts tas rule: redT_updTs.induct)(auto simp del: fun_upd_apply simp add: redT_updT_upd dest: redT_updT_Some)"], ["", "lemma thread_ok_upd:\n  \"ts t = \\<lfloor>xln\\<rfloor> \\<Longrightarrow> thread_ok (ts(t \\<mapsto> xln')) ta = thread_ok ts ta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts t = \\<lfloor>xln\\<rfloor> \\<Longrightarrow>\n    thread_ok (ts(t \\<mapsto> xln')) ta = thread_ok ts ta", "by(rule thread_ok_ts_change) simp"], ["", "lemma thread_oks_upd:\n  \"ts t = \\<lfloor>xln\\<rfloor> \\<Longrightarrow> thread_oks (ts(t \\<mapsto> xln')) tas = thread_oks ts tas\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts t = \\<lfloor>xln\\<rfloor> \\<Longrightarrow>\n    thread_oks (ts(t \\<mapsto> xln')) tas = thread_oks ts tas", "by(rule thread_oks_ts_change) simp"], ["", "lemma thread_ok_convert_new_thread_action [simp]:\n  \"thread_ok ts (convert_new_thread_action f ta) = thread_ok ts ta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thread_ok ts (convert_new_thread_action f ta) = thread_ok ts ta", "by(cases ta) auto"], ["", "lemma redT_updT'_convert_new_thread_action_eq_None:\n  \"redT_updT' ts (convert_new_thread_action f ta) t = None \\<longleftrightarrow> redT_updT' ts ta t = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (redT_updT' ts (convert_new_thread_action f ta) t = None) =\n    (redT_updT' ts ta t = None)", "by(cases ta) auto"], ["", "lemma thread_oks_convert_new_thread_action [simp]:\n  \"thread_oks ts (map (convert_new_thread_action f) tas) = thread_oks ts tas\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thread_oks ts (map (convert_new_thread_action f) tas) =\n    thread_oks ts tas", "by(induct ts tas rule: thread_oks.induct)(simp_all add: thread_oks_ts_change[OF redT_updT'_convert_new_thread_action_eq_None])"], ["", "lemma map_redT_updT:\n  \"map_option (map_prod f id) (redT_updT ts ta t) = \n  redT_updT (\\<lambda>t. map_option (map_prod f id) (ts t)) (convert_new_thread_action f ta) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option (map_prod f id) (redT_updT ts ta t) =\n    redT_updT (\\<lambda>t. map_option (map_prod f id) (ts t))\n     (convert_new_thread_action f ta) t", "by(cases ta) auto"], ["", "lemma map_redT_updTs:\n  \"map_option (map_prod f id) (redT_updTs ts tas t) = \n  redT_updTs (\\<lambda>t. map_option (map_prod f id) (ts t)) (map (convert_new_thread_action f) tas) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option (map_prod f id) (redT_updTs ts tas t) =\n    redT_updTs (\\<lambda>t. map_option (map_prod f id) (ts t))\n     (map (convert_new_thread_action f) tas) t", "by(induct tas arbitrary: ts)(auto simp add: map_redT_updT)"], ["", "end"]]}