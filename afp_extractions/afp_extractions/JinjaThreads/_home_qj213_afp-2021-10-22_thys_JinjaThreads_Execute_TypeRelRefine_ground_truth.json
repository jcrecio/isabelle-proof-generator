{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Execute/TypeRelRefine.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma rtranclp_tranclpE:\n  assumes \"r^** x y\"\n  obtains (refl) \"x = y\"\n  | (trancl) \"r^++ x y\"", "lemma map_of_map2: \"map_of (map (\\<lambda>(k, v). (k, f k v)) xs) k = map_option (f k) (map_of xs k)\"", "lemma map_of_map_K: \"map_of (map (\\<lambda>k. (k, c)) xs) k = (if k \\<in> set xs then Some c else None)\"", "lemma map_values_Mapping [simp]: \n  \"map_values f (Mapping.Mapping m) = Mapping.Mapping (\\<lambda>k. map_option (f k) (m k))\"", "lemma map_Mapping: \"Mapping.map f g (Mapping.Mapping m) = Mapping.Mapping (map_option g \\<circ> m \\<circ> f)\"", "lemma impl_of_ProgImpl [simp]:\n  \"wf_prog_impl' Pfsm \\<Longrightarrow> impl_of (ProgRefine Pfsm) = Pfsm\"", "lemma prog_impl_eq_iff:\n  \"Pi = Pi' \\<longleftrightarrow> program Pi = program Pi'\" for Pi Pi'", "lemma wf_prog_impl'_impl_of [simp, intro!]:\n  \"wf_prog_impl' (impl_of Pi)\" for Pi", "lemma ProgImpl_impl_of [simp, code abstype]:\n  \"ProgRefine (impl_of Pi) = Pi\" for Pi", "lemma program_ProgRefine [simp]: \"wf_prog_impl' Psfm \\<Longrightarrow> program (ProgRefine Psfm) = Program (fst Psfm)\"", "lemma classes_program [code]: \"classes (program P) = fst (impl_of P)\"", "lemma class_program [code]: \"class (program Pi) = Mapping.lookup (fst (snd (impl_of Pi)))\" for Pi", "lemma subcls'_program [code]: \n  \"subcls' (program Pi) C D \\<longleftrightarrow> \n  C = D \\<or>\n  (case Mapping.lookup (fst (snd (snd (impl_of Pi)))) C of None \\<Rightarrow> False\n   | Some m \\<Rightarrow> D \\<in> m)\" for Pi", "lemma subcls'_i_i_i_program [code]:\n  \"subcls'_i_i_i P C D = (if subcls' P C D then Predicate.single () else bot)\"", "lemma subcls'_i_i_o_program [code]:\n  \"subcls'_i_i_o (program Pi) C = \n  sup (Predicate.single C) (case Mapping.lookup (fst (snd (snd (impl_of Pi)))) C of None \\<Rightarrow> bot | Some m \\<Rightarrow> pred_of_set m)\" for Pi", "lemma rtranclp_FioB_i_i_subcls1_i_i_o_code [code_unfold]:\n  \"rtranclp_FioB_i_i (subcls1_i_i_o P) = subcls'_i_i_i P\"", "lemma Method_program [code]:\n  \"program Pi \\<turnstile> C sees M:Ts\\<rightarrow>T=meth in D \\<longleftrightarrow> \n  (case Mapping.lookup (snd (snd (snd (snd (impl_of Pi))))) C of \n    None \\<Rightarrow> False\n  | Some m \\<Rightarrow> \n    (case Mapping.lookup m M of \n       None \\<Rightarrow> False\n     | Some (D', Ts', T', meth') \\<Rightarrow> Ts = Ts' \\<and> T = T' \\<and> meth = meth' \\<and> D = D'))\" for Pi", "lemma Method_i_i_i_o_o_o_o_program [code]:\n  \"Method_i_i_i_o_o_o_o (program Pi) C M = \n  (case Mapping.lookup (snd (snd (snd (snd (impl_of Pi))))) C of\n    None \\<Rightarrow> bot\n  | Some m \\<Rightarrow>\n    (case Mapping.lookup m M of\n      None \\<Rightarrow> bot\n    | Some (D, Ts, T, meth) \\<Rightarrow> Predicate.single (Ts, T, meth, D)))\" for Pi", "lemma Method_i_i_i_o_o_o_i_program [code]:\n  \"Method_i_i_i_o_o_o_i (program Pi) C M D = \n  (case Mapping.lookup (snd (snd (snd (snd (impl_of Pi))))) C of\n    None \\<Rightarrow> bot\n  | Some m \\<Rightarrow>\n    (case Mapping.lookup m M of\n      None \\<Rightarrow> bot\n    | Some (D', Ts, T, meth) \\<Rightarrow> if D = D' then Predicate.single (Ts, T, meth) else bot))\" for Pi", "lemma sees_field_program [code]:\n  \"program Pi \\<turnstile> C sees F:T (fd) in D \\<longleftrightarrow>\n  (case Mapping.lookup (fst (snd (snd (snd (impl_of Pi))))) C of\n    None \\<Rightarrow> False\n  | Some m \\<Rightarrow> \n    (case Mapping.lookup m F of \n       None \\<Rightarrow> False\n     | Some (D', T', fd') \\<Rightarrow> T = T' \\<and> fd = fd' \\<and> D = D'))\" for Pi", "lemma sees_field_i_i_i_o_o_o_program [code]:\n  \"sees_field_i_i_i_o_o_o (program Pi) C F =\n  (case Mapping.lookup (fst (snd (snd (snd (impl_of Pi))))) C of\n    None \\<Rightarrow> bot\n  | Some m \\<Rightarrow>\n    (case Mapping.lookup m F of\n       None \\<Rightarrow> bot\n    | Some (D, T, fd) \\<Rightarrow> Predicate.single(T, fd, D)))\" for Pi", "lemma sees_field_i_i_i_o_o_i_program [code]:\n  \"sees_field_i_i_i_o_o_i (program Pi) C F D =\n  (case Mapping.lookup (fst (snd (snd (snd (impl_of Pi))))) C of\n    None \\<Rightarrow> bot\n  | Some m \\<Rightarrow>\n    (case Mapping.lookup m F of\n       None \\<Rightarrow> bot\n    | Some (D', T, fd) \\<Rightarrow> if D = D' then Predicate.single(T, fd) else bot))\" for Pi", "lemma field_program [code]:\n  \"field (program Pi) C F = \n  (case Mapping.lookup (fst (snd (snd (snd (impl_of Pi))))) C of \n    None \\<Rightarrow> Code.abort (STR ''not_unique'') (\\<lambda>_. Predicate.the bot)\n  | Some m \\<Rightarrow> \n    (case Mapping.lookup m F of\n       None \\<Rightarrow> Code.abort (STR ''not_unique'') (\\<lambda>_. Predicate.the bot)\n     | Some (D', T, fd) \\<Rightarrow> (D', T, fd)))\" for Pi", "lemma impl_of_tabulate_program [code abstract]:\n  \"impl_of (tabulate_program P) = (P, tabulate_class P, tabulate_subcls P, tabulate_sees_field P, tabulate_Method P)\"", "lemma Program_code [code]:\n  \"Program = program \\<circ> tabulate_program\"", "lemma tabulate_class_code [code]:\n  \"tabulate_class = Mapping.of_alist\"", "lemma subcls1_into_subcls1':\n  assumes \"subcls1 (Program P) C D\"\n  shows \"subcls1' P C D\"", "lemma subcls1'_into_subcls1:\n  assumes \"subcls1' P C D\"\n  shows \"subcls1 (Program P) C D\"", "lemma subcls1_eq_subcls1':\n  \"subcls1 (Program P) = subcls1' P\"", "lemma subcls''_eq_subcls: \"subcls'' P = subcls (Program P)\"", "lemma subclst_snd_classD: \n  assumes \"subclst (Program P) C D\"\n  shows \"D \\<in> fst ` snd ` set P\"", "lemma check_acyclicity_code:\n  \"check_acyclicity mapping P =\n   (let _ = \n     map (\\<lambda>(C, D, _).\n       if C = Object then () \n       else\n         (case Mapping.lookup mapping D of \n            None \\<Rightarrow> ()\n          | Some Cs \\<Rightarrow> if C \\<in> Cs then cyclic_class_hierarchy else ()))\n       P\n    in ())\"", "lemma tablulate_subcls_code [code]:\n  \"tabulate_subcls P = \n  (let cnames = map fst P;\n       cnames' = map (fst \\<circ> snd) P;\n       mapping = Mapping.tabulate cnames (\\<lambda>C. set (C # [D \\<leftarrow> cnames'. subcls'' P C D]));\n       _ = check_acyclicity mapping P\n   in mapping\n  )\"", "lemma Fields'_into_Fields:\n  assumes \"Fields' P C FDTs\"\n  shows \"Program P \\<turnstile> C has_fields FDTs\"", "lemma Fields_into_Fields':\n  assumes \"Program P \\<turnstile> C has_fields FDTs\"\n  shows \"Fields' P C FDTs\"", "lemma Fields'_eq_Fields:\n  \"Fields' P = Fields (Program P)\"", "lemma eval_Fields'_conv:\n  \"Predicate.eval (Fields'_i_i_o P C) = Fields' P C\"", "lemma fields'_code [code]:\n  \"fields' P C = \n  (let FDTs = Fields'_i_i_o P C in if Predicate.holds (FDTs \\<bind> (\\<lambda>_. Predicate.single ())) then Predicate.the FDTs else [])\"", "lemma The_Fields [simp]:\n  \"P \\<turnstile> C has_fields FDTs \\<Longrightarrow> The (Fields P C) = FDTs\"", "lemma tabulate_sees_field_code [code]:\n  \"tabulate_sees_field P =\n   Mapping.tabulate (map fst P) (\\<lambda>C. Mapping.of_alist (map (\\<lambda>((F, D), Tfm). (F, (D, Tfm))) (fields' P C)))\"", "lemma Methods'_into_Methods:\n  assumes \"Methods' P C Mm\"\n  shows \"Program P \\<turnstile> C sees_methods (map_of Mm)\"", "lemma Methods_into_Methods':\n  assumes \"Program P \\<turnstile> C sees_methods Mm\"\n  shows \"\\<exists>Mm'. Methods' P C Mm' \\<and> Mm = map_of Mm'\"", "lemma methods'_code [code]:\n  \"methods' P C =\n  (let Mm = Methods'_i_i_o P C\n   in if Predicate.holds (Mm \\<bind> (\\<lambda>_. Predicate.single ())) then Predicate.the Mm else [])\"", "lemma Methods'_fun:\n  assumes \"Methods' P C Mm\"\n  shows \"Methods' P C Mm' \\<Longrightarrow> Mm = Mm'\"", "lemma The_Methods' [simp]: \"Methods' P C Mm \\<Longrightarrow> The (Methods' P C) = Mm\"", "lemma methods_def2 [simp]: \"Methods' P C Mm \\<Longrightarrow> methods' P C = Mm\"", "lemma tabulate_Method_code [code]:\n  \"tabulate_Method P =\n   Mapping.tabulate (map fst P) (\\<lambda>C. Mapping.of_alist (map (\\<lambda>(M, (rest, D)). (M, D, rest)) (methods' P C)))\""], "translations": [["", "lemma rtranclp_tranclpE:\n  assumes \"r^** x y\"\n  obtains (refl) \"x = y\"\n  | (trancl) \"r^++ x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = y \\<Longrightarrow> thesis;\n     r\\<^sup>+\\<^sup>+ x y \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  r\\<^sup>*\\<^sup>* x y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = y \\<Longrightarrow> thesis;\n     r\\<^sup>+\\<^sup>+ x y \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(cases)(blast dest: rtranclp_into_tranclp1)+"], ["", "lemma map_of_map2: \"map_of (map (\\<lambda>(k, v). (k, f k v)) xs) k = map_option (f k) (map_of xs k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>(k, v). (k, f k v)) xs) k =\n    map_option (f k) (map_of xs k)", "by(induct xs) auto"], ["", "lemma map_of_map_K: \"map_of (map (\\<lambda>k. (k, c)) xs) k = (if k \\<in> set xs then Some c else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>k. (k, c)) xs) k =\n    (if k \\<in> set xs then \\<lfloor>c\\<rfloor> else None)", "by(induct xs) auto"], ["", "lift_definition map_values :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'c) \\<Rightarrow> ('a, 'b) mapping \\<Rightarrow> ('a, 'c) mapping\"\nis \"\\<lambda>f m k. map_option (f k) (m k)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma map_values_Mapping [simp]: \n  \"map_values f (Mapping.Mapping m) = Mapping.Mapping (\\<lambda>k. map_option (f k) (m k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_values f (mapping.Mapping m) =\n    mapping.Mapping (\\<lambda>k. map_option (f k) (m k))", "by(rule map_values.abs_eq)"], ["", "lemma map_Mapping: \"Mapping.map f g (Mapping.Mapping m) = Mapping.Mapping (map_option g \\<circ> m \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.map f g (mapping.Mapping m) =\n    mapping.Mapping (map_option g \\<circ> m \\<circ> f)", "by(rule map.abs_eq)"], ["", "abbreviation subclst :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> cname \\<Rightarrow> bool\"\nwhere \"subclst P \\<equiv> (subcls1 P)^++\""], ["", "subsection \\<open>Representation type for tabulated lookup functions\\<close>"], ["", "type_synonym\n  'm prog_impl' = \n  \"'m cdecl list \\<times>\n   (cname, 'm class) mapping \\<times>\n   (cname, cname set) mapping \\<times> \n   (cname, (vname, cname \\<times> ty \\<times> fmod) mapping) mapping \\<times> \n   (cname, (mname, cname \\<times> ty list \\<times> ty \\<times> 'm option) mapping) mapping\""], ["", "lift_definition tabulate_class :: \"'m cdecl list \\<Rightarrow> (cname, 'm class) mapping\"\nis \"class \\<circ> Program\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition tabulate_subcls :: \"'m cdecl list \\<Rightarrow> (cname, cname set) mapping\"\nis \"\\<lambda>P C. if is_class (Program P) C then Some {D. Program P \\<turnstile> C \\<preceq>\\<^sup>* D} else None\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition tabulate_sees_field :: \"'m cdecl list \\<Rightarrow> (cname, (vname, cname \\<times> ty \\<times> fmod) mapping) mapping\"\nis \"\\<lambda>P C. if is_class (Program P) C then\n        Some (\\<lambda>F. if \\<exists>T fm D. Program P \\<turnstile> C sees F:T (fm) in D then Some (field (Program P) C F) else None)\n      else None\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition tabulate_Method :: \"'m cdecl list \\<Rightarrow> (cname, (mname, cname \\<times> ty list \\<times> ty \\<times> 'm option) mapping) mapping\"\nis \"\\<lambda>P C. if is_class (Program P) C then\n         Some (\\<lambda>M. if \\<exists>Ts T mthd D. Program P \\<turnstile> C sees M:Ts\\<rightarrow>T=mthd in D then Some (method (Program P) C M) else None)\n      else None\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "fun wf_prog_impl' :: \"'m prog_impl' \\<Rightarrow> bool\"\nwhere\n  \"wf_prog_impl' (P, c, s, f, m) \\<longleftrightarrow>\n  c = tabulate_class P \\<and>\n  s = tabulate_subcls P \\<and>\n  f = tabulate_sees_field P \\<and>\n  m = tabulate_Method P\""], ["", "subsection \\<open>Implementation type for tabulated lookup functions\\<close>"], ["", "typedef 'm prog_impl = \"{P :: 'm prog_impl'. wf_prog_impl' P}\"\n  morphisms impl_of ProgRefine"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {P. wf_prog_impl' P}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> {P. wf_prog_impl' P}", "show \"([], Mapping.empty, Mapping.empty, Mapping.empty, Mapping.empty) \\<in> ?prog_impl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([], Mapping.empty, Mapping.empty, Mapping.empty, Mapping.empty)\n    \\<in> {P. wf_prog_impl' P}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.empty = tabulate_class [] \\<and>\n    Mapping.empty = tabulate_subcls [] \\<and>\n    Mapping.empty = tabulate_sees_field [] \\<and>\n    Mapping.empty = tabulate_Method []", "by transfer (simp_all add: fun_eq_iff is_class_def rel_funI)"], ["proof (state)\nthis:\n  ([], Mapping.empty, Mapping.empty, Mapping.empty, Mapping.empty)\n  \\<in> {P. wf_prog_impl' P}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma impl_of_ProgImpl [simp]:\n  \"wf_prog_impl' Pfsm \\<Longrightarrow> impl_of (ProgRefine Pfsm) = Pfsm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog_impl' Pfsm \\<Longrightarrow> impl_of (ProgRefine Pfsm) = Pfsm", "by(simp add: ProgRefine_inverse)"], ["", "definition program :: \"'m prog_impl \\<Rightarrow> 'm prog\"\nwhere \"program = Program \\<circ> fst \\<circ> impl_of\""], ["", "code_datatype program"], ["", "lemma prog_impl_eq_iff:\n  \"Pi = Pi' \\<longleftrightarrow> program Pi = program Pi'\" for Pi Pi'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Pi = Pi') = (program Pi = program Pi')", "apply(cases Pi)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>Pi = ProgRefine y; y \\<in> {P. wf_prog_impl' P}\\<rbrakk>\n       \\<Longrightarrow> (Pi = Pi') = (program Pi = program Pi')", "apply(cases Pi')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y ya.\n       \\<lbrakk>Pi = ProgRefine y; y \\<in> {P. wf_prog_impl' P};\n        Pi' = ProgRefine ya; ya \\<in> {P. wf_prog_impl' P}\\<rbrakk>\n       \\<Longrightarrow> (Pi = Pi') = (program Pi = program Pi')", "apply(auto simp add: ProgRefine_inverse program_def ProgRefine_inject)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wf_prog_impl'_impl_of [simp, intro!]:\n  \"wf_prog_impl' (impl_of Pi)\" for Pi"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog_impl' (impl_of Pi)", "using impl_of[of Pi]"], ["proof (prove)\nusing this:\n  impl_of Pi \\<in> {P. wf_prog_impl' P}\n\ngoal (1 subgoal):\n 1. wf_prog_impl' (impl_of Pi)", "by simp"], ["", "lemma ProgImpl_impl_of [simp, code abstype]:\n  \"ProgRefine (impl_of Pi) = Pi\" for Pi"], ["proof (prove)\ngoal (1 subgoal):\n 1. ProgRefine (impl_of Pi) = Pi", "by(rule impl_of_inverse)"], ["", "lemma program_ProgRefine [simp]: \"wf_prog_impl' Psfm \\<Longrightarrow> program (ProgRefine Psfm) = Program (fst Psfm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog_impl' Psfm \\<Longrightarrow>\n    program (ProgRefine Psfm) = Program (fst Psfm)", "by(simp add: program_def)"], ["", "lemma classes_program [code]: \"classes (program P) = fst (impl_of P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. classes (program P) = fst (impl_of P)", "by(simp add: program_def)"], ["", "lemma class_program [code]: \"class (program Pi) = Mapping.lookup (fst (snd (impl_of Pi)))\" for Pi"], ["proof (prove)\ngoal (1 subgoal):\n 1. class (program Pi) = Mapping.lookup (fst (snd (impl_of Pi)))", "by(cases Pi)(clarsimp simp add: tabulate_class_def lookup.rep_eq Mapping_inverse)"], ["", "subsection \\<open>Refining sub class and lookup functions to use precomputed mappings\\<close>"], ["", "declare subcls'.equation [code del]"], ["", "lemma subcls'_program [code]: \n  \"subcls' (program Pi) C D \\<longleftrightarrow> \n  C = D \\<or>\n  (case Mapping.lookup (fst (snd (snd (impl_of Pi)))) C of None \\<Rightarrow> False\n   | Some m \\<Rightarrow> D \\<in> m)\" for Pi"], ["proof (prove)\ngoal (1 subgoal):\n 1. subcls' (program Pi) C D =\n    (C = D \\<or>\n     (case Mapping.lookup (fst (snd (snd (impl_of Pi)))) C of\n      None \\<Rightarrow> False\n      | \\<lfloor>m\\<rfloor> \\<Rightarrow> D \\<in> m))", "apply(cases Pi)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>Pi = ProgRefine y; y \\<in> {P. wf_prog_impl' P}\\<rbrakk>\n       \\<Longrightarrow> subcls' (program Pi) C D =\n                         (C = D \\<or>\n                          (case Mapping.lookup\n                                 (fst (snd (snd (impl_of Pi)))) C of\n                           None \\<Rightarrow> False\n                           | \\<lfloor>m\\<rfloor> \\<Rightarrow> D \\<in> m))", "apply(clarsimp simp add: subcls'_def tabulate_subcls_def lookup.rep_eq Mapping_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       Pi =\n       ProgRefine\n        (a, tabulate_class a,\n         mapping.Mapping\n          (\\<lambda>C.\n              if is_class (Program a) C\n              then \\<lfloor>Collect (subcls (Program (id a)) C)\\<rfloor>\n              else None),\n         tabulate_sees_field a, tabulate_Method a) \\<Longrightarrow>\n       (is_class (Program a) C \\<longrightarrow>\n        Program a \\<turnstile> C \\<preceq>\\<^sup>* D =\n        (C = D \\<or> Program a \\<turnstile> C \\<preceq>\\<^sup>* D)) \\<and>\n       (\\<not> is_class (Program a) C \\<longrightarrow>\n        Program a \\<turnstile> C \\<preceq>\\<^sup>* D = (C = D))", "apply(auto elim!: rtranclp_tranclpE dest: subcls_is_class intro: tranclp_into_rtranclp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma subcls'_i_i_i_program [code]:\n  \"subcls'_i_i_i P C D = (if subcls' P C D then Predicate.single () else bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subcls'_i_i_i P C D =\n    (if subcls' P C D then Predicate.single () else bot)", "by(rule pred_eqI)(auto elim: subcls'_i_i_iE intro: subcls'_i_i_iI)"], ["", "lemma subcls'_i_i_o_program [code]:\n  \"subcls'_i_i_o (program Pi) C = \n  sup (Predicate.single C) (case Mapping.lookup (fst (snd (snd (impl_of Pi)))) C of None \\<Rightarrow> bot | Some m \\<Rightarrow> pred_of_set m)\" for Pi"], ["proof (prove)\ngoal (1 subgoal):\n 1. subcls'_i_i_o (program Pi) C =\n    sup (Predicate.single C)\n     (case Mapping.lookup (fst (snd (snd (impl_of Pi)))) C of\n      None \\<Rightarrow> bot\n      | \\<lfloor>m\\<rfloor> \\<Rightarrow> pred_of_set m)", "by(cases Pi)(fastforce simp add: subcls'_i_i_o_def subcls'_def tabulate_subcls_def lookup.rep_eq Mapping_inverse intro!: pred_eqI split: if_split_asm elim: rtranclp_tranclpE dest: subcls_is_class intro: tranclp_into_rtranclp)"], ["", "lemma rtranclp_FioB_i_i_subcls1_i_i_o_code [code_unfold]:\n  \"rtranclp_FioB_i_i (subcls1_i_i_o P) = subcls'_i_i_i P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rtranclp_FioB_i_i (subcls1_i_i_o P) = subcls'_i_i_i P", "by(auto simp add: fun_eq_iff subcls1_i_i_o_def subcls'_def rtranclp_FioB_i_i_def subcls'_i_i_i_def)"], ["", "declare Method.equation[code del]"], ["", "lemma Method_program [code]:\n  \"program Pi \\<turnstile> C sees M:Ts\\<rightarrow>T=meth in D \\<longleftrightarrow> \n  (case Mapping.lookup (snd (snd (snd (snd (impl_of Pi))))) C of \n    None \\<Rightarrow> False\n  | Some m \\<Rightarrow> \n    (case Mapping.lookup m M of \n       None \\<Rightarrow> False\n     | Some (D', Ts', T', meth') \\<Rightarrow> Ts = Ts' \\<and> T = T' \\<and> meth = meth' \\<and> D = D'))\" for Pi"], ["proof (prove)\ngoal (1 subgoal):\n 1. (program Pi \\<turnstile> C sees M: Ts\\<rightarrow>T = meth in D) =\n    (case Mapping.lookup (snd (snd (snd (snd (impl_of Pi))))) C of\n     None \\<Rightarrow> False\n     | \\<lfloor>m\\<rfloor> \\<Rightarrow>\n         case Mapping.lookup m M of None \\<Rightarrow> False\n         | \\<lfloor>(D', Ts', T', meth')\\<rfloor> \\<Rightarrow>\n             Ts = Ts' \\<and> T = T' \\<and> meth = meth' \\<and> D = D')", "by(cases Pi)(auto split: if_split_asm dest: sees_method_is_class simp add: tabulate_Method_def lookup.rep_eq Mapping_inverse)"], ["", "lemma Method_i_i_i_o_o_o_o_program [code]:\n  \"Method_i_i_i_o_o_o_o (program Pi) C M = \n  (case Mapping.lookup (snd (snd (snd (snd (impl_of Pi))))) C of\n    None \\<Rightarrow> bot\n  | Some m \\<Rightarrow>\n    (case Mapping.lookup m M of\n      None \\<Rightarrow> bot\n    | Some (D, Ts, T, meth) \\<Rightarrow> Predicate.single (Ts, T, meth, D)))\" for Pi"], ["proof (prove)\ngoal (1 subgoal):\n 1. Method_i_i_i_o_o_o_o (program Pi) C M =\n    (case Mapping.lookup (snd (snd (snd (snd (impl_of Pi))))) C of\n     None \\<Rightarrow> bot\n     | \\<lfloor>m\\<rfloor> \\<Rightarrow>\n         case Mapping.lookup m M of None \\<Rightarrow> bot\n         | \\<lfloor>(D, Ts, T, meth)\\<rfloor> \\<Rightarrow>\n             Predicate.single (Ts, T, meth, D))", "by(auto simp add: Method_i_i_i_o_o_o_o_def Method_program intro!: pred_eqI)"], ["", "lemma Method_i_i_i_o_o_o_i_program [code]:\n  \"Method_i_i_i_o_o_o_i (program Pi) C M D = \n  (case Mapping.lookup (snd (snd (snd (snd (impl_of Pi))))) C of\n    None \\<Rightarrow> bot\n  | Some m \\<Rightarrow>\n    (case Mapping.lookup m M of\n      None \\<Rightarrow> bot\n    | Some (D', Ts, T, meth) \\<Rightarrow> if D = D' then Predicate.single (Ts, T, meth) else bot))\" for Pi"], ["proof (prove)\ngoal (1 subgoal):\n 1. Method_i_i_i_o_o_o_i (program Pi) C M D =\n    (case Mapping.lookup (snd (snd (snd (snd (impl_of Pi))))) C of\n     None \\<Rightarrow> bot\n     | \\<lfloor>m\\<rfloor> \\<Rightarrow>\n         case Mapping.lookup m M of None \\<Rightarrow> bot\n         | \\<lfloor>(D', Ts, T, meth)\\<rfloor> \\<Rightarrow>\n             if D = D' then Predicate.single (Ts, T, meth) else bot)", "by(auto simp add: Method_i_i_i_o_o_o_i_def Method_program intro!: pred_eqI)"], ["", "declare sees_field.equation[code del]"], ["", "lemma sees_field_program [code]:\n  \"program Pi \\<turnstile> C sees F:T (fd) in D \\<longleftrightarrow>\n  (case Mapping.lookup (fst (snd (snd (snd (impl_of Pi))))) C of\n    None \\<Rightarrow> False\n  | Some m \\<Rightarrow> \n    (case Mapping.lookup m F of \n       None \\<Rightarrow> False\n     | Some (D', T', fd') \\<Rightarrow> T = T' \\<and> fd = fd' \\<and> D = D'))\" for Pi"], ["proof (prove)\ngoal (1 subgoal):\n 1. (program Pi \\<turnstile> C sees F:T (fd) in D) =\n    (case Mapping.lookup (fst (snd (snd (snd (impl_of Pi))))) C of\n     None \\<Rightarrow> False\n     | \\<lfloor>m\\<rfloor> \\<Rightarrow>\n         case Mapping.lookup m F of None \\<Rightarrow> False\n         | \\<lfloor>(D', T', fd')\\<rfloor> \\<Rightarrow>\n             T = T' \\<and> fd = fd' \\<and> D = D')", "by(cases Pi)(auto split: if_split_asm dest: has_visible_field[THEN has_field_is_class] simp add: tabulate_sees_field_def lookup.rep_eq Mapping_inverse)"], ["", "lemma sees_field_i_i_i_o_o_o_program [code]:\n  \"sees_field_i_i_i_o_o_o (program Pi) C F =\n  (case Mapping.lookup (fst (snd (snd (snd (impl_of Pi))))) C of\n    None \\<Rightarrow> bot\n  | Some m \\<Rightarrow>\n    (case Mapping.lookup m F of\n       None \\<Rightarrow> bot\n    | Some (D, T, fd) \\<Rightarrow> Predicate.single(T, fd, D)))\" for Pi"], ["proof (prove)\ngoal (1 subgoal):\n 1. sees_field_i_i_i_o_o_o (program Pi) C F =\n    (case Mapping.lookup (fst (snd (snd (snd (impl_of Pi))))) C of\n     None \\<Rightarrow> bot\n     | \\<lfloor>m\\<rfloor> \\<Rightarrow>\n         case Mapping.lookup m F of None \\<Rightarrow> bot\n         | \\<lfloor>(D, T, fd)\\<rfloor> \\<Rightarrow>\n             Predicate.single (T, fd, D))", "by(auto simp add: sees_field_program sees_field_i_i_i_o_o_o_def intro: pred_eqI)"], ["", "lemma sees_field_i_i_i_o_o_i_program [code]:\n  \"sees_field_i_i_i_o_o_i (program Pi) C F D =\n  (case Mapping.lookup (fst (snd (snd (snd (impl_of Pi))))) C of\n    None \\<Rightarrow> bot\n  | Some m \\<Rightarrow>\n    (case Mapping.lookup m F of\n       None \\<Rightarrow> bot\n    | Some (D', T, fd) \\<Rightarrow> if D = D' then Predicate.single(T, fd) else bot))\" for Pi"], ["proof (prove)\ngoal (1 subgoal):\n 1. sees_field_i_i_i_o_o_i (program Pi) C F D =\n    (case Mapping.lookup (fst (snd (snd (snd (impl_of Pi))))) C of\n     None \\<Rightarrow> bot\n     | \\<lfloor>m\\<rfloor> \\<Rightarrow>\n         case Mapping.lookup m F of None \\<Rightarrow> bot\n         | \\<lfloor>(D', T, fd)\\<rfloor> \\<Rightarrow>\n             if D = D' then Predicate.single (T, fd) else bot)", "by(auto simp add: sees_field_program sees_field_i_i_i_o_o_i_def intro: pred_eqI)"], ["", "lemma field_program [code]:\n  \"field (program Pi) C F = \n  (case Mapping.lookup (fst (snd (snd (snd (impl_of Pi))))) C of \n    None \\<Rightarrow> Code.abort (STR ''not_unique'') (\\<lambda>_. Predicate.the bot)\n  | Some m \\<Rightarrow> \n    (case Mapping.lookup m F of\n       None \\<Rightarrow> Code.abort (STR ''not_unique'') (\\<lambda>_. Predicate.the bot)\n     | Some (D', T, fd) \\<Rightarrow> (D', T, fd)))\" for Pi"], ["proof (prove)\ngoal (1 subgoal):\n 1. field (program Pi) C F =\n    (case Mapping.lookup (fst (snd (snd (snd (impl_of Pi))))) C of\n     None \\<Rightarrow>\n       Code.abort STR ''not_unique'' (\\<lambda>_. Predicate.the bot)\n     | \\<lfloor>m\\<rfloor> \\<Rightarrow>\n         case Mapping.lookup m F of\n         None \\<Rightarrow>\n           Code.abort STR ''not_unique'' (\\<lambda>_. Predicate.the bot)\n         | \\<lfloor>(D', T, fd)\\<rfloor> \\<Rightarrow> (D', T, fd))", "unfolding field_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE (D, T, fm). program Pi \\<turnstile> C sees F:T (fm) in D) =\n    (case Mapping.lookup (fst (snd (snd (snd (impl_of Pi))))) C of\n     None \\<Rightarrow>\n       Code.abort STR ''not_unique'' (\\<lambda>_. Predicate.the bot)\n     | \\<lfloor>m\\<rfloor> \\<Rightarrow>\n         case Mapping.lookup m F of\n         None \\<Rightarrow>\n           Code.abort STR ''not_unique'' (\\<lambda>_. Predicate.the bot)\n         | \\<lfloor>(D', T, fd)\\<rfloor> \\<Rightarrow> (D', T, fd))", "by(cases Pi)(fastforce simp add: Predicate.the_def tabulate_sees_field_def lookup.rep_eq Mapping_inverse split: if_split_asm intro: arg_cong[where f=The] dest: has_visible_field[THEN has_field_is_class] sees_field_fun)"], ["", "subsection \\<open>Implementation for precomputing mappings\\<close>"], ["", "definition tabulate_program :: \"'m cdecl list \\<Rightarrow> 'm prog_impl\"\nwhere \"tabulate_program P = ProgRefine (P, tabulate_class P, tabulate_subcls P, tabulate_sees_field P, tabulate_Method P)\""], ["", "lemma impl_of_tabulate_program [code abstract]:\n  \"impl_of (tabulate_program P) = (P, tabulate_class P, tabulate_subcls P, tabulate_sees_field P, tabulate_Method P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. impl_of (tabulate_program P) =\n    (P, tabulate_class P, tabulate_subcls P, tabulate_sees_field P,\n     tabulate_Method P)", "by(simp add: tabulate_program_def)"], ["", "lemma Program_code [code]:\n  \"Program = program \\<circ> tabulate_program\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Program = program \\<circ> tabulate_program", "by(simp add: program_def fun_eq_iff tabulate_program_def)"], ["", "subsubsection \\<open>@{term \"class\" }\\<close>"], ["", "lemma tabulate_class_code [code]:\n  \"tabulate_class = Mapping.of_alist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tabulate_class = Mapping.of_alist", "by transfer (simp add: fun_eq_iff)"], ["", "subsubsection \\<open>@{term \"subcls\" }\\<close>"], ["", "inductive subcls1' :: \"'m cdecl list \\<Rightarrow> cname \\<Rightarrow> cname \\<Rightarrow> bool\"\nwhere \n  find: \"C \\<noteq> Object \\<Longrightarrow> subcls1' ((C, D, rest) # P) C D\"\n| step: \"\\<lbrakk> C \\<noteq> Object; C \\<noteq> C'; subcls1' P C D  \\<rbrakk> \\<Longrightarrow> subcls1' ((C', D', rest) # P) C D\""], ["", "code_pred\n  (modes: i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> bool)\n  subcls1'"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma subcls1_into_subcls1':\n  assumes \"subcls1 (Program P) C D\"\n  shows \"subcls1' P C D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subcls1' P C D", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. subcls1' P C D", "from assms"], ["proof (chain)\npicking this:\n  Program P \\<turnstile> C \\<prec>\\<^sup>1 D", "obtain rest where \"map_of P C = \\<lfloor>(D, rest)\\<rfloor>\" \"C \\<noteq> Object\""], ["proof (prove)\nusing this:\n  Program P \\<turnstile> C \\<prec>\\<^sup>1 D\n\ngoal (1 subgoal):\n 1. (\\<And>rest.\n        \\<lbrakk>map_of P C = \\<lfloor>(D, rest)\\<rfloor>;\n         C \\<noteq> Object\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases simp"], ["proof (state)\nthis:\n  map_of P C = \\<lfloor>(D, rest)\\<rfloor>\n  C \\<noteq> Object\n\ngoal (1 subgoal):\n 1. subcls1' P C D", "thus ?thesis"], ["proof (prove)\nusing this:\n  map_of P C = \\<lfloor>(D, rest)\\<rfloor>\n  C \\<noteq> Object\n\ngoal (1 subgoal):\n 1. subcls1' P C D", "by(induct P)(auto split: if_split_asm intro: subcls1'.intros)"], ["proof (state)\nthis:\n  subcls1' P C D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subcls1'_into_subcls1:\n  assumes \"subcls1' P C D\"\n  shows \"subcls1 (Program P) C D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Program P \\<turnstile> C \\<prec>\\<^sup>1 D", "using assms"], ["proof (prove)\nusing this:\n  subcls1' P C D\n\ngoal (1 subgoal):\n 1. Program P \\<turnstile> C \\<prec>\\<^sup>1 D", "proof(induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C D rest P.\n       C \\<noteq> Object \\<Longrightarrow>\n       Program ((C, D, rest) # P) \\<turnstile> C \\<prec>\\<^sup>1 D\n 2. \\<And>C C' P D D' rest.\n       \\<lbrakk>C \\<noteq> Object; C \\<noteq> C'; subcls1' P C D;\n        Program P \\<turnstile> C \\<prec>\\<^sup>1 D\\<rbrakk>\n       \\<Longrightarrow> Program\n                          ((C', D', rest) #\n                           P) \\<turnstile> C \\<prec>\\<^sup>1 D", "case find"], ["proof (state)\nthis:\n  C_ \\<noteq> Object\n\ngoal (2 subgoals):\n 1. \\<And>C D rest P.\n       C \\<noteq> Object \\<Longrightarrow>\n       Program ((C, D, rest) # P) \\<turnstile> C \\<prec>\\<^sup>1 D\n 2. \\<And>C C' P D D' rest.\n       \\<lbrakk>C \\<noteq> Object; C \\<noteq> C'; subcls1' P C D;\n        Program P \\<turnstile> C \\<prec>\\<^sup>1 D\\<rbrakk>\n       \\<Longrightarrow> Program\n                          ((C', D', rest) #\n                           P) \\<turnstile> C \\<prec>\\<^sup>1 D", "thus ?case"], ["proof (prove)\nusing this:\n  C_ \\<noteq> Object\n\ngoal (1 subgoal):\n 1. Program ((C_, D_, rest_) # P_) \\<turnstile> C_ \\<prec>\\<^sup>1 D_", "by(auto intro: subcls1.intros)"], ["proof (state)\nthis:\n  Program ((C_, D_, rest_) # P_) \\<turnstile> C_ \\<prec>\\<^sup>1 D_\n\ngoal (1 subgoal):\n 1. \\<And>C C' P D D' rest.\n       \\<lbrakk>C \\<noteq> Object; C \\<noteq> C'; subcls1' P C D;\n        Program P \\<turnstile> C \\<prec>\\<^sup>1 D\\<rbrakk>\n       \\<Longrightarrow> Program\n                          ((C', D', rest) #\n                           P) \\<turnstile> C \\<prec>\\<^sup>1 D", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C C' P D D' rest.\n       \\<lbrakk>C \\<noteq> Object; C \\<noteq> C'; subcls1' P C D;\n        Program P \\<turnstile> C \\<prec>\\<^sup>1 D\\<rbrakk>\n       \\<Longrightarrow> Program\n                          ((C', D', rest) #\n                           P) \\<turnstile> C \\<prec>\\<^sup>1 D", "case step"], ["proof (state)\nthis:\n  C_ \\<noteq> Object\n  C_ \\<noteq> C'_\n  subcls1' P_ C_ D_\n  Program P_ \\<turnstile> C_ \\<prec>\\<^sup>1 D_\n\ngoal (1 subgoal):\n 1. \\<And>C C' P D D' rest.\n       \\<lbrakk>C \\<noteq> Object; C \\<noteq> C'; subcls1' P C D;\n        Program P \\<turnstile> C \\<prec>\\<^sup>1 D\\<rbrakk>\n       \\<Longrightarrow> Program\n                          ((C', D', rest) #\n                           P) \\<turnstile> C \\<prec>\\<^sup>1 D", "thus ?case"], ["proof (prove)\nusing this:\n  C_ \\<noteq> Object\n  C_ \\<noteq> C'_\n  subcls1' P_ C_ D_\n  Program P_ \\<turnstile> C_ \\<prec>\\<^sup>1 D_\n\ngoal (1 subgoal):\n 1. Program ((C'_, D'_, rest_) # P_) \\<turnstile> C_ \\<prec>\\<^sup>1 D_", "by(auto elim!: subcls1.cases intro: subcls1.intros)"], ["proof (state)\nthis:\n  Program ((C'_, D'_, rest_) # P_) \\<turnstile> C_ \\<prec>\\<^sup>1 D_\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subcls1_eq_subcls1':\n  \"subcls1 (Program P) = subcls1' P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subcls1 (Program P) = subcls1' P", "by(auto simp add: fun_eq_iff intro: subcls1_into_subcls1' subcls1'_into_subcls1)"], ["", "definition subcls'' :: \"'m cdecl list \\<Rightarrow> cname \\<Rightarrow> cname \\<Rightarrow> bool\"\nwhere \"subcls'' P = (subcls1' P)^**\""], ["", "code_pred\n  (modes: i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> bool)\n  [inductify] \n  subcls''"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma subcls''_eq_subcls: \"subcls'' P = subcls (Program P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subcls'' P = subcls (Program P)", "by(simp add: subcls''_def subcls1_eq_subcls1')"], ["", "lemma subclst_snd_classD: \n  assumes \"subclst (Program P) C D\"\n  shows \"D \\<in> fst ` snd ` set P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<in> fst ` snd ` set P", "using assms"], ["proof (prove)\nusing this:\n  subclst (Program P) C D\n\ngoal (1 subgoal):\n 1. D \\<in> fst ` snd ` set P", "by(induct)(fastforce elim!: subcls1.cases dest!: map_of_SomeD intro: rev_image_eqI)+"], ["", "definition check_acyclicity :: \"(cname, cname set) mapping \\<Rightarrow> 'm cdecl list \\<Rightarrow> unit\"\nwhere \"check_acyclicity _ _ = ()\""], ["", "definition cyclic_class_hierarchy :: unit \nwhere [code del]: \"cyclic_class_hierarchy = ()\""], ["", "declare [[code abort: cyclic_class_hierarchy]]"], ["", "lemma check_acyclicity_code:\n  \"check_acyclicity mapping P =\n   (let _ = \n     map (\\<lambda>(C, D, _).\n       if C = Object then () \n       else\n         (case Mapping.lookup mapping D of \n            None \\<Rightarrow> ()\n          | Some Cs \\<Rightarrow> if C \\<in> Cs then cyclic_class_hierarchy else ()))\n       P\n    in ())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_acyclicity mapping P =\n    (let _ = map (\\<lambda>(C, D, uu_).\n                     if C = Object then ()\n                     else case Mapping.lookup mapping D of\n                          None \\<Rightarrow> ()\n                          | \\<lfloor>Cs\\<rfloor> \\<Rightarrow>\n                              if C \\<in> Cs then cyclic_class_hierarchy\n                              else ())\n              P\n     in ())", "by simp"], ["", "lemma tablulate_subcls_code [code]:\n  \"tabulate_subcls P = \n  (let cnames = map fst P;\n       cnames' = map (fst \\<circ> snd) P;\n       mapping = Mapping.tabulate cnames (\\<lambda>C. set (C # [D \\<leftarrow> cnames'. subcls'' P C D]));\n       _ = check_acyclicity mapping P\n   in mapping\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tabulate_subcls P =\n    (let cnames = map fst P; cnames' = map (fst \\<circ> snd) P;\n         mapping =\n           Mapping.tabulate cnames\n            (\\<lambda>C. set (C # filter (subcls'' P C) cnames'));\n         _ = check_acyclicity mapping P\n     in mapping)", "apply(auto simp add: tabulate_subcls_def Mapping.tabulate_def fun_eq_iff is_class_def o_def map_of_map2[simplified split_def] Mapping_inject)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a aa b.\n       map_of P x = \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       \\<lfloor>Collect (subcls (Program P) x)\\<rfloor> =\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  insert (fst x)\n                   {xa \\<in> (\\<lambda>x. fst (snd x)) ` set P.\n                    subcls'' P (fst x) xa}))\n          P)\n        x\n 2. \\<And>x.\n       \\<forall>a aa b.\n          map_of P x \\<noteq> \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       None =\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  insert (fst x)\n                   {xa \\<in> (\\<lambda>x. fst (snd x)) ` set P.\n                    subcls'' P (fst x) xa}))\n          P)\n        x", "apply(subst map_of_map2[simplified split_def])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a aa b.\n       map_of P x = \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       \\<lfloor>Collect (subcls (Program P) x)\\<rfloor> =\n       map_option\n        (\\<lambda>a.\n            insert x\n             {xa \\<in> (\\<lambda>x. fst (snd x)) ` set P. subcls'' P x xa})\n        (map_of P x)\n 2. \\<And>x.\n       \\<forall>a aa b.\n          map_of P x \\<noteq> \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       None =\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  insert (fst x)\n                   {xa \\<in> (\\<lambda>x. fst (snd x)) ` set P.\n                    subcls'' P (fst x) xa}))\n          P)\n        x", "apply(auto simp add: fun_eq_iff subcls''_eq_subcls map_of_map_K dest: subclst_snd_classD elim: rtranclp_tranclpE)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>a aa b.\n          map_of P x \\<noteq> \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       None =\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  insert (fst x)\n                   {xa \\<in> (\\<lambda>x. fst (snd x)) ` set P.\n                    subcls'' P (fst x) xa}))\n          P)\n        x", "apply(subst map_of_map2[simplified split_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>a aa b.\n          map_of P x \\<noteq> \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       None =\n       map_option\n        (\\<lambda>a.\n            insert x\n             {xa \\<in> (\\<lambda>x. fst (snd x)) ` set P. subcls'' P x xa})\n        (map_of P x)", "apply(rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>a aa b.\n          map_of P x \\<noteq> \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       map_option\n        (\\<lambda>a.\n            insert x\n             {xa \\<in> (\\<lambda>x. fst (snd x)) ` set P. subcls'' P x xa})\n        (map_of P x) =\n       None", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>a aa b.\n          map_of P x \\<noteq> \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       map_of P x = None", "apply(case_tac \"map_of P x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>a aa b.\n                   map_of P x \\<noteq> \\<lfloor>(a, aa, b)\\<rfloor>;\n        map_of P x = None\\<rbrakk>\n       \\<Longrightarrow> map_of P x = None\n 2. \\<And>x a.\n       \\<lbrakk>\\<forall>a aa b.\n                   map_of P x \\<noteq> \\<lfloor>(a, aa, b)\\<rfloor>;\n        map_of P x = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> map_of P x = None", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>@{term Fields}\\<close>"], ["", "text \\<open>\n  Problem: Does not terminate for cyclic class hierarchies!\n  This problem already occurs in Jinja's well-formedness checker: \n  \\<open>wf_cdecl\\<close> calls \\<open>wf_mdecl\\<close> before checking for acyclicity, \n  but \\<open>wf_J_mdecl\\<close> involves the type judgements, \n  which in turn requires @{term \"Fields\"} (via @{term sees_field}).\n  Checking acyclicity before executing @{term \"Fields'\"} for tabulation is difficult\n  because we would have to intertwine tabulation and well-formedness checking.\n  Possible (local) solution:\n  additional termination parameter (like memoisation for @{term \"rtranclp\"}) \n  and list option as error return parameter.\n\\<close>"], ["", "inductive\n  Fields' :: \"'m cdecl list \\<Rightarrow> cname \\<Rightarrow> ((vname \\<times> cname) \\<times> (ty \\<times> fmod)) list \\<Rightarrow> bool\"\nfor P :: \"'m cdecl list\"\nwhere \n  rec:\n  \"\\<lbrakk> map_of P C = Some(D,fs,ms); C \\<noteq> Object; Fields' P D FDTs;\n     FDTs' = map (\\<lambda>(F,Tm). ((F,C),Tm)) fs @ FDTs \\<rbrakk>\n  \\<Longrightarrow> Fields' P C FDTs'\"\n| Object:\n  \"\\<lbrakk> map_of P Object = Some(D,fs,ms); FDTs = map (\\<lambda>(F,T). ((F,Object),T)) fs \\<rbrakk>\n  \\<Longrightarrow> Fields' P Object FDTs\""], ["", "lemma Fields'_into_Fields:\n  assumes \"Fields' P C FDTs\"\n  shows \"Program P \\<turnstile> C has_fields FDTs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Program P \\<turnstile> C has_fields FDTs", "using assms"], ["proof (prove)\nusing this:\n  Fields' P C FDTs\n\ngoal (1 subgoal):\n 1. Program P \\<turnstile> C has_fields FDTs", "by induct(auto intro: Fields.intros)"], ["", "lemma Fields_into_Fields':\n  assumes \"Program P \\<turnstile> C has_fields FDTs\"\n  shows \"Fields' P C FDTs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fields' P C FDTs", "using assms"], ["proof (prove)\nusing this:\n  Program P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. Fields' P C FDTs", "by induct(auto intro: Fields'.intros)"], ["", "lemma Fields'_eq_Fields:\n  \"Fields' P = Fields (Program P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fields' P = Fields (Program P)", "by(auto simp add: fun_eq_iff intro: Fields'_into_Fields Fields_into_Fields')"], ["", "code_pred \n  (modes: i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> bool)\n  Fields'"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition fields' :: \"'m cdecl list \\<Rightarrow> cname \\<Rightarrow> ((vname \\<times> cname) \\<times> (ty \\<times> fmod)) list\"\nwhere \"fields' P C = (if \\<exists>FDTs. Fields' P C FDTs then THE FDTs. Fields' P C FDTs else [])\""], ["", "lemma eval_Fields'_conv:\n  \"Predicate.eval (Fields'_i_i_o P C) = Fields' P C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred.eval (Fields'_i_i_o P C) = Fields' P C", "by(auto intro: Fields'_i_i_oI elim: Fields'_i_i_oE intro!: ext)"], ["", "lemma fields'_code [code]:\n  \"fields' P C = \n  (let FDTs = Fields'_i_i_o P C in if Predicate.holds (FDTs \\<bind> (\\<lambda>_. Predicate.single ())) then Predicate.the FDTs else [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fields' P C =\n    (let FDTs = Fields'_i_i_o P C\n     in if Predicate.holds (FDTs \\<bind> (\\<lambda>_. Predicate.single ()))\n        then Predicate.the FDTs else [])", "by(auto simp add: fields'_def holds_eq Fields'_i_i_o_def intro: Fields'_i_i_oI Predicate.the_eqI[THEN sym])"], ["", "lemma The_Fields [simp]:\n  \"P \\<turnstile> C has_fields FDTs \\<Longrightarrow> The (Fields P C) = FDTs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    The (Fields P C) = FDTs", "by(auto dest: has_fields_fun)"], ["", "lemma tabulate_sees_field_code [code]:\n  \"tabulate_sees_field P =\n   Mapping.tabulate (map fst P) (\\<lambda>C. Mapping.of_alist (map (\\<lambda>((F, D), Tfm). (F, (D, Tfm))) (fields' P C)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tabulate_sees_field P =\n    Mapping.tabulate (map fst P)\n     (\\<lambda>C.\n         Mapping.of_alist\n          (map (\\<lambda>((F, D), Tfm). (F, D, Tfm)) (fields' P C)))", "apply(simp add: tabulate_sees_field_def tabulate_def is_class_def fields'_def Fields'_eq_Fields Mapping_inject)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_fun id (map_option mapping.Mapping)\n     (\\<lambda>C.\n         if \\<exists>a aa b. map_of P C = \\<lfloor>(a, aa, b)\\<rfloor>\n         then \\<lfloor>\\<lambda>F.\n                          if \\<exists>T fm.\n                                Ex (sees_field (Program (id P)) C F T fm)\n                          then \\<lfloor>field (Program (id P)) C F\\<rfloor>\n                          else None\\<rfloor>\n         else None) =\n    map_of\n     (map ((\\<lambda>k.\n               (k, Mapping.of_alist\n                    (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                      (if Ex (Fields (Program P) k) then The (Fields' P k)\n                       else [])))) \\<circ>\n           fst)\n       P)", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       map_fun id (map_option mapping.Mapping)\n        (\\<lambda>C.\n            if \\<exists>a aa b. map_of P C = \\<lfloor>(a, aa, b)\\<rfloor>\n            then \\<lfloor>\\<lambda>F.\n                             if \\<exists>T fm.\n                                   Ex (sees_field (Program (id P)) C F T fm)\n                             then \\<lfloor>field (Program (id P)) C\n      F\\<rfloor>\n                             else None\\<rfloor>\n            else None)\n        x =\n       map_of\n        (map ((\\<lambda>k.\n                  (k, Mapping.of_alist\n                       (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                         (if Ex (Fields (Program P) k)\n                          then The (Fields' P k) else [])))) \\<circ>\n              fst)\n          P)\n        x", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ((\\<exists>a aa b.\n            map_of P x = \\<lfloor>(a, aa, b)\\<rfloor>) \\<longrightarrow>\n        \\<lfloor>mapping.Mapping\n                  (\\<lambda>F.\n                      if \\<exists>T fm. Ex (sees_field (Program P) x F T fm)\n                      then \\<lfloor>field (Program (id P)) (id x) F\\<rfloor>\n                      else None)\\<rfloor> =\n        map_of\n         (map ((\\<lambda>k.\n                   (k, Mapping.of_alist\n                        (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                          (if Ex (Fields (Program P) k)\n                           then The (Fields' P k) else [])))) \\<circ>\n               fst)\n           P)\n         x) \\<and>\n       ((\\<forall>a aa b.\n            map_of P x \\<noteq>\n            \\<lfloor>(a, aa, b)\\<rfloor>) \\<longrightarrow>\n        None =\n        map_of\n         (map ((\\<lambda>k.\n                   (k, Mapping.of_alist\n                        (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                          (if Ex (Fields (Program P) k)\n                           then The (Fields' P k) else [])))) \\<circ>\n               fst)\n           P)\n         x)", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<exists>a aa b.\n           map_of P x = \\<lfloor>(a, aa, b)\\<rfloor>) \\<longrightarrow>\n       \\<lfloor>mapping.Mapping\n                 (\\<lambda>F.\n                     if \\<exists>T fm. Ex (sees_field (Program P) x F T fm)\n                     then \\<lfloor>field (Program (id P)) (id x) F\\<rfloor>\n                     else None)\\<rfloor> =\n       map_of\n        (map ((\\<lambda>k.\n                  (k, Mapping.of_alist\n                       (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                         (if Ex (Fields (Program P) k)\n                          then The (Fields' P k) else [])))) \\<circ>\n              fst)\n          P)\n        x\n 2. \\<And>x.\n       (\\<forall>a aa b.\n           map_of P x \\<noteq>\n           \\<lfloor>(a, aa, b)\\<rfloor>) \\<longrightarrow>\n       None =\n       map_of\n        (map ((\\<lambda>k.\n                  (k, Mapping.of_alist\n                       (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                         (if Ex (Fields (Program P) k)\n                          then The (Fields' P k) else [])))) \\<circ>\n              fst)\n          P)\n        x", "apply(clarsimp simp add: o_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a aa b.\n       map_of P x = \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       \\<lfloor>mapping.Mapping\n                 (\\<lambda>F.\n                     if \\<exists>T fm. Ex (sees_field (Program P) x F T fm)\n                     then \\<lfloor>field (Program (id P)) (id x) F\\<rfloor>\n                     else None)\\<rfloor> =\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  Mapping.of_alist\n                   (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                     (if Ex (Fields (Program P) (fst x))\n                      then The (Fields' P (fst x)) else []))))\n          P)\n        x\n 2. \\<And>x.\n       (\\<forall>a aa b.\n           map_of P x \\<noteq>\n           \\<lfloor>(a, aa, b)\\<rfloor>) \\<longrightarrow>\n       None =\n       map_of\n        (map ((\\<lambda>k.\n                  (k, Mapping.of_alist\n                       (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                         (if Ex (Fields (Program P) k)\n                          then The (Fields' P k) else [])))) \\<circ>\n              fst)\n          P)\n        x", "apply(subst map_of_map2[unfolded split_def])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a aa b.\n       map_of P x = \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       \\<lfloor>mapping.Mapping\n                 (\\<lambda>F.\n                     if \\<exists>T fm. Ex (sees_field (Program P) x F T fm)\n                     then \\<lfloor>field (Program (id P)) (id x) F\\<rfloor>\n                     else None)\\<rfloor> =\n       map_option\n        (\\<lambda>a.\n            Mapping.of_alist\n             (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n               (if Ex (Fields (Program P) x) then The (Fields' P x)\n                else [])))\n        (map_of P x)\n 2. \\<And>x.\n       (\\<forall>a aa b.\n           map_of P x \\<noteq>\n           \\<lfloor>(a, aa, b)\\<rfloor>) \\<longrightarrow>\n       None =\n       map_of\n        (map ((\\<lambda>k.\n                  (k, Mapping.of_alist\n                       (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                         (if Ex (Fields (Program P) k)\n                          then The (Fields' P k) else [])))) \\<circ>\n              fst)\n          P)\n        x", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a aa b.\n       map_of P x = \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       (Ex (Fields (Program P) x) \\<longrightarrow>\n        mapping.Mapping\n         (\\<lambda>F.\n             if \\<exists>T fm. Ex (sees_field (Program P) x F T fm)\n             then \\<lfloor>field (Program (id P)) (id x) F\\<rfloor>\n             else None) =\n        Mapping.of_alist\n         (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n           (The (Fields' P x)))) \\<and>\n       ((\\<forall>xa.\n            \\<not> Program P \\<turnstile> x has_fields xa) \\<longrightarrow>\n        mapping.Mapping\n         (\\<lambda>F.\n             if \\<exists>T fm. Ex (sees_field (Program P) x F T fm)\n             then \\<lfloor>field (Program (id P)) (id x) F\\<rfloor>\n             else None) =\n        Mapping.of_alist [])\n 2. \\<And>x.\n       (\\<forall>a aa b.\n           map_of P x \\<noteq>\n           \\<lfloor>(a, aa, b)\\<rfloor>) \\<longrightarrow>\n       None =\n       map_of\n        (map ((\\<lambda>k.\n                  (k, Mapping.of_alist\n                       (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                         (if Ex (Fields (Program P) k)\n                          then The (Fields' P k) else [])))) \\<circ>\n              fst)\n          P)\n        x", "apply transfer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a aa b P.\n       map_of P x = \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       (Ex (Fields (Program P) x) \\<longrightarrow>\n        (\\<lambda>F.\n            if \\<exists>T fm. Ex (sees_field (Program P) x F T fm)\n            then \\<lfloor>field (Program (id P)) (id x) F\\<rfloor>\n            else None) =\n        map_of\n         (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n           (The (Fields' P x)))) \\<and>\n       ((\\<forall>xa.\n            \\<not> Program P \\<turnstile> x has_fields xa) \\<longrightarrow>\n        (\\<lambda>F.\n            if \\<exists>T fm. Ex (sees_field (Program P) x F T fm)\n            then \\<lfloor>field (Program (id P)) (id x) F\\<rfloor>\n            else None) =\n        map_of [])\n 2. \\<And>x.\n       (\\<forall>a aa b.\n           map_of P x \\<noteq>\n           \\<lfloor>(a, aa, b)\\<rfloor>) \\<longrightarrow>\n       None =\n       map_of\n        (map ((\\<lambda>k.\n                  (k, Mapping.of_alist\n                       (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                         (if Ex (Fields (Program P) k)\n                          then The (Fields' P k) else [])))) \\<circ>\n              fst)\n          P)\n        x", "apply(rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x a aa b P.\n       map_of P x = \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       Ex (Fields (Program P) x) \\<longrightarrow>\n       (\\<lambda>F.\n           if \\<exists>T fm. Ex (sees_field (Program P) x F T fm)\n           then \\<lfloor>field (Program (id P)) (id x) F\\<rfloor>\n           else None) =\n       map_of\n        (map (\\<lambda>((F, D), Tfm). (F, D, Tfm)) (The (Fields' P x)))\n 2. \\<And>x a aa b P.\n       map_of P x = \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       (\\<forall>xa.\n           \\<not> Program P \\<turnstile> x has_fields xa) \\<longrightarrow>\n       (\\<lambda>F.\n           if \\<exists>T fm. Ex (sees_field (Program P) x F T fm)\n           then \\<lfloor>field (Program (id P)) (id x) F\\<rfloor>\n           else None) =\n       map_of []\n 3. \\<And>x.\n       (\\<forall>a aa b.\n           map_of P x \\<noteq>\n           \\<lfloor>(a, aa, b)\\<rfloor>) \\<longrightarrow>\n       None =\n       map_of\n        (map ((\\<lambda>k.\n                  (k, Mapping.of_alist\n                       (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                         (if Ex (Fields (Program P) k)\n                          then The (Fields' P k) else [])))) \\<circ>\n              fst)\n          P)\n        x", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x a aa b P xa.\n       \\<lbrakk>map_of P x = \\<lfloor>(a, aa, b)\\<rfloor>;\n        Program P \\<turnstile> x has_fields xa\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>F.\n                             if \\<exists>T fm.\n                                   Ex (sees_field (Program P) x F T fm)\n                             then \\<lfloor>field (Program (id P)) (id x)\n      F\\<rfloor>\n                             else None) =\n                         map_of\n                          (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                            (The (Fields' P x)))\n 2. \\<And>x a aa b P.\n       map_of P x = \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       (\\<forall>xa.\n           \\<not> Program P \\<turnstile> x has_fields xa) \\<longrightarrow>\n       (\\<lambda>F.\n           if \\<exists>T fm. Ex (sees_field (Program P) x F T fm)\n           then \\<lfloor>field (Program (id P)) (id x) F\\<rfloor>\n           else None) =\n       map_of []\n 3. \\<And>x.\n       (\\<forall>a aa b.\n           map_of P x \\<noteq>\n           \\<lfloor>(a, aa, b)\\<rfloor>) \\<longrightarrow>\n       None =\n       map_of\n        (map ((\\<lambda>k.\n                  (k, Mapping.of_alist\n                       (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                         (if Ex (Fields (Program P) k)\n                          then The (Fields' P k) else [])))) \\<circ>\n              fst)\n          P)\n        x", "apply(rule ext)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x a aa b P xa F.\n       \\<lbrakk>map_of P x = \\<lfloor>(a, aa, b)\\<rfloor>;\n        Program P \\<turnstile> x has_fields xa\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>T fm.\n                                Ex (sees_field (Program P) x F T fm)\n                          then \\<lfloor>field (Program (id P)) (id x)\n   F\\<rfloor>\n                          else None) =\n                         map_of\n                          (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                            (The (Fields' P x)))\n                          F\n 2. \\<And>x a aa b P.\n       map_of P x = \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       (\\<forall>xa.\n           \\<not> Program P \\<turnstile> x has_fields xa) \\<longrightarrow>\n       (\\<lambda>F.\n           if \\<exists>T fm. Ex (sees_field (Program P) x F T fm)\n           then \\<lfloor>field (Program (id P)) (id x) F\\<rfloor>\n           else None) =\n       map_of []\n 3. \\<And>x.\n       (\\<forall>a aa b.\n           map_of P x \\<noteq>\n           \\<lfloor>(a, aa, b)\\<rfloor>) \\<longrightarrow>\n       None =\n       map_of\n        (map ((\\<lambda>k.\n                  (k, Mapping.of_alist\n                       (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                         (if Ex (Fields (Program P) k)\n                          then The (Fields' P k) else [])))) \\<circ>\n              fst)\n          P)\n        x", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x a aa b P xa F.\n       \\<lbrakk>map_of P x = \\<lfloor>(a, aa, b)\\<rfloor>;\n        Program P \\<turnstile> x has_fields xa\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>T fm.\n                              Ex (sees_field (Program P) x F T\n                                   fm)) \\<longrightarrow>\n                          \\<lfloor>field (Program P) x F\\<rfloor> =\n                          map_of\n                           (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                             (The (Fields' P x)))\n                           F) \\<and>\n                         ((\\<forall>T fm xa.\n                              \\<not> Program\nP \\<turnstile> x sees F:T (fm) in xa) \\<longrightarrow>\n                          None =\n                          map_of\n                           (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                             (The (Fields' P x)))\n                           F)\n 2. \\<And>x a aa b P.\n       map_of P x = \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       (\\<forall>xa.\n           \\<not> Program P \\<turnstile> x has_fields xa) \\<longrightarrow>\n       (\\<lambda>F.\n           if \\<exists>T fm. Ex (sees_field (Program P) x F T fm)\n           then \\<lfloor>field (Program (id P)) (id x) F\\<rfloor>\n           else None) =\n       map_of []\n 3. \\<And>x.\n       (\\<forall>a aa b.\n           map_of P x \\<noteq>\n           \\<lfloor>(a, aa, b)\\<rfloor>) \\<longrightarrow>\n       None =\n       map_of\n        (map ((\\<lambda>k.\n                  (k, Mapping.of_alist\n                       (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                         (if Ex (Fields (Program P) k)\n                          then The (Fields' P k) else [])))) \\<circ>\n              fst)\n          P)\n        x", "apply(rule conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x a aa b P xa F.\n       \\<lbrakk>map_of P x = \\<lfloor>(a, aa, b)\\<rfloor>;\n        Program P \\<turnstile> x has_fields xa\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>T fm.\n                             Ex (sees_field (Program P) x F T\n                                  fm)) \\<longrightarrow>\n                         \\<lfloor>field (Program P) x F\\<rfloor> =\n                         map_of\n                          (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                            (The (Fields' P x)))\n                          F\n 2. \\<And>x a aa b P xa F.\n       \\<lbrakk>map_of P x = \\<lfloor>(a, aa, b)\\<rfloor>;\n        Program P \\<turnstile> x has_fields xa\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>T fm xa.\n                             \\<not> Program\n                                     P \\<turnstile> x sees F:T (fm) in xa) \\<longrightarrow>\n                         None =\n                         map_of\n                          (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                            (The (Fields' P x)))\n                          F\n 3. \\<And>x a aa b P.\n       map_of P x = \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       (\\<forall>xa.\n           \\<not> Program P \\<turnstile> x has_fields xa) \\<longrightarrow>\n       (\\<lambda>F.\n           if \\<exists>T fm. Ex (sees_field (Program P) x F T fm)\n           then \\<lfloor>field (Program (id P)) (id x) F\\<rfloor>\n           else None) =\n       map_of []\n 4. \\<And>x.\n       (\\<forall>a aa b.\n           map_of P x \\<noteq>\n           \\<lfloor>(a, aa, b)\\<rfloor>) \\<longrightarrow>\n       None =\n       map_of\n        (map ((\\<lambda>k.\n                  (k, Mapping.of_alist\n                       (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                         (if Ex (Fields (Program P) k)\n                          then The (Fields' P k) else [])))) \\<circ>\n              fst)\n          P)\n        x", "apply(clarsimp simp add: sees_field_def Fields'_eq_Fields)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x a aa b P xa F T fm xb FDTs.\n       \\<lbrakk>map_of P x = \\<lfloor>(a, aa, b)\\<rfloor>;\n        Program P \\<turnstile> x has_fields xa;\n        Program P \\<turnstile> x has_fields FDTs;\n        map_of (map (\\<lambda>((F, D), Tm). (F, D, Tm)) FDTs) F =\n        \\<lfloor>(xb, T, fm)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<lfloor>(xb, T, fm)\\<rfloor> =\n                         map_of\n                          (map (\\<lambda>((F, D), Tfm). (F, D, Tfm)) xa) F\n 2. \\<And>x a aa b P xa F.\n       \\<lbrakk>map_of P x = \\<lfloor>(a, aa, b)\\<rfloor>;\n        Program P \\<turnstile> x has_fields xa\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>T fm xa.\n                             \\<not> Program\n                                     P \\<turnstile> x sees F:T (fm) in xa) \\<longrightarrow>\n                         None =\n                         map_of\n                          (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                            (The (Fields' P x)))\n                          F\n 3. \\<And>x a aa b P.\n       map_of P x = \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       (\\<forall>xa.\n           \\<not> Program P \\<turnstile> x has_fields xa) \\<longrightarrow>\n       (\\<lambda>F.\n           if \\<exists>T fm. Ex (sees_field (Program P) x F T fm)\n           then \\<lfloor>field (Program (id P)) (id x) F\\<rfloor>\n           else None) =\n       map_of []\n 4. \\<And>x.\n       (\\<forall>a aa b.\n           map_of P x \\<noteq>\n           \\<lfloor>(a, aa, b)\\<rfloor>) \\<longrightarrow>\n       None =\n       map_of\n        (map ((\\<lambda>k.\n                  (k, Mapping.of_alist\n                       (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                         (if Ex (Fields (Program P) k)\n                          then The (Fields' P k) else [])))) \\<circ>\n              fst)\n          P)\n        x", "apply(drule (1) has_fields_fun, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x a aa b P xa F.\n       \\<lbrakk>map_of P x = \\<lfloor>(a, aa, b)\\<rfloor>;\n        Program P \\<turnstile> x has_fields xa\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>T fm xa.\n                             \\<not> Program\n                                     P \\<turnstile> x sees F:T (fm) in xa) \\<longrightarrow>\n                         None =\n                         map_of\n                          (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                            (The (Fields' P x)))\n                          F\n 2. \\<And>x a aa b P.\n       map_of P x = \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       (\\<forall>xa.\n           \\<not> Program P \\<turnstile> x has_fields xa) \\<longrightarrow>\n       (\\<lambda>F.\n           if \\<exists>T fm. Ex (sees_field (Program P) x F T fm)\n           then \\<lfloor>field (Program (id P)) (id x) F\\<rfloor>\n           else None) =\n       map_of []\n 3. \\<And>x.\n       (\\<forall>a aa b.\n           map_of P x \\<noteq>\n           \\<lfloor>(a, aa, b)\\<rfloor>) \\<longrightarrow>\n       None =\n       map_of\n        (map ((\\<lambda>k.\n                  (k, Mapping.of_alist\n                       (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                         (if Ex (Fields (Program P) k)\n                          then The (Fields' P k) else [])))) \\<circ>\n              fst)\n          P)\n        x", "apply clarify"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x a aa b P xa F.\n       \\<lbrakk>map_of P x = \\<lfloor>(a, aa, b)\\<rfloor>;\n        Program P \\<turnstile> x has_fields xa;\n        \\<forall>T fm xa.\n           \\<not> Program P \\<turnstile> x sees F:T (fm) in xa\\<rbrakk>\n       \\<Longrightarrow> None =\n                         map_of\n                          (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                            (The (Fields' P x)))\n                          F\n 2. \\<And>x a aa b P.\n       map_of P x = \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       (\\<forall>xa.\n           \\<not> Program P \\<turnstile> x has_fields xa) \\<longrightarrow>\n       (\\<lambda>F.\n           if \\<exists>T fm. Ex (sees_field (Program P) x F T fm)\n           then \\<lfloor>field (Program (id P)) (id x) F\\<rfloor>\n           else None) =\n       map_of []\n 3. \\<And>x.\n       (\\<forall>a aa b.\n           map_of P x \\<noteq>\n           \\<lfloor>(a, aa, b)\\<rfloor>) \\<longrightarrow>\n       None =\n       map_of\n        (map ((\\<lambda>k.\n                  (k, Mapping.of_alist\n                       (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                         (if Ex (Fields (Program P) k)\n                          then The (Fields' P k) else [])))) \\<circ>\n              fst)\n          P)\n        x", "apply(rule sym)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x a aa b P xa F.\n       \\<lbrakk>map_of P x = \\<lfloor>(a, aa, b)\\<rfloor>;\n        Program P \\<turnstile> x has_fields xa;\n        \\<forall>T fm xa.\n           \\<not> Program P \\<turnstile> x sees F:T (fm) in xa\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                            (The (Fields' P x)))\n                          F =\n                         None\n 2. \\<And>x a aa b P.\n       map_of P x = \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       (\\<forall>xa.\n           \\<not> Program P \\<turnstile> x has_fields xa) \\<longrightarrow>\n       (\\<lambda>F.\n           if \\<exists>T fm. Ex (sees_field (Program P) x F T fm)\n           then \\<lfloor>field (Program (id P)) (id x) F\\<rfloor>\n           else None) =\n       map_of []\n 3. \\<And>x.\n       (\\<forall>a aa b.\n           map_of P x \\<noteq>\n           \\<lfloor>(a, aa, b)\\<rfloor>) \\<longrightarrow>\n       None =\n       map_of\n        (map ((\\<lambda>k.\n                  (k, Mapping.of_alist\n                       (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                         (if Ex (Fields (Program P) k)\n                          then The (Fields' P k) else [])))) \\<circ>\n              fst)\n          P)\n        x", "apply(rule ccontr)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x a aa b P xa F.\n       \\<lbrakk>map_of P x = \\<lfloor>(a, aa, b)\\<rfloor>;\n        Program P \\<turnstile> x has_fields xa;\n        \\<forall>T fm xa.\n           \\<not> Program P \\<turnstile> x sees F:T (fm) in xa;\n        map_of\n         (map (\\<lambda>((F, D), Tfm). (F, D, Tfm)) (The (Fields' P x)))\n         F \\<noteq>\n        None\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x a aa b P.\n       map_of P x = \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       (\\<forall>xa.\n           \\<not> Program P \\<turnstile> x has_fields xa) \\<longrightarrow>\n       (\\<lambda>F.\n           if \\<exists>T fm. Ex (sees_field (Program P) x F T fm)\n           then \\<lfloor>field (Program (id P)) (id x) F\\<rfloor>\n           else None) =\n       map_of []\n 3. \\<And>x.\n       (\\<forall>a aa b.\n           map_of P x \\<noteq>\n           \\<lfloor>(a, aa, b)\\<rfloor>) \\<longrightarrow>\n       None =\n       map_of\n        (map ((\\<lambda>k.\n                  (k, Mapping.of_alist\n                       (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                         (if Ex (Fields (Program P) k)\n                          then The (Fields' P k) else [])))) \\<circ>\n              fst)\n          P)\n        x", "apply(clarsimp simp add: sees_field_def Fields'_eq_Fields)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a aa b P.\n       map_of P x = \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       (\\<forall>xa.\n           \\<not> Program P \\<turnstile> x has_fields xa) \\<longrightarrow>\n       (\\<lambda>F.\n           if \\<exists>T fm. Ex (sees_field (Program P) x F T fm)\n           then \\<lfloor>field (Program (id P)) (id x) F\\<rfloor>\n           else None) =\n       map_of []\n 2. \\<And>x.\n       (\\<forall>a aa b.\n           map_of P x \\<noteq>\n           \\<lfloor>(a, aa, b)\\<rfloor>) \\<longrightarrow>\n       None =\n       map_of\n        (map ((\\<lambda>k.\n                  (k, Mapping.of_alist\n                       (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                         (if Ex (Fields (Program P) k)\n                          then The (Fields' P k) else [])))) \\<circ>\n              fst)\n          P)\n        x", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a aa b P.\n       \\<lbrakk>map_of P x = \\<lfloor>(a, aa, b)\\<rfloor>;\n        \\<forall>xa. \\<not> Program P \\<turnstile> x has_fields xa\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>F.\n                             if \\<exists>T fm.\n                                   Ex (sees_field (Program P) x F T fm)\n                             then \\<lfloor>field (Program (id P)) (id x)\n      F\\<rfloor>\n                             else None) =\n                         Map.empty\n 2. \\<And>x.\n       (\\<forall>a aa b.\n           map_of P x \\<noteq>\n           \\<lfloor>(a, aa, b)\\<rfloor>) \\<longrightarrow>\n       None =\n       map_of\n        (map ((\\<lambda>k.\n                  (k, Mapping.of_alist\n                       (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                         (if Ex (Fields (Program P) k)\n                          then The (Fields' P k) else [])))) \\<circ>\n              fst)\n          P)\n        x", "apply(rule ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a aa b P F.\n       \\<lbrakk>map_of P x = \\<lfloor>(a, aa, b)\\<rfloor>;\n        \\<forall>xa. \\<not> Program P \\<turnstile> x has_fields xa\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>T fm.\n                                Ex (sees_field (Program P) x F T fm)\n                          then \\<lfloor>field (Program (id P)) (id x)\n   F\\<rfloor>\n                          else None) =\n                         None\n 2. \\<And>x.\n       (\\<forall>a aa b.\n           map_of P x \\<noteq>\n           \\<lfloor>(a, aa, b)\\<rfloor>) \\<longrightarrow>\n       None =\n       map_of\n        (map ((\\<lambda>k.\n                  (k, Mapping.of_alist\n                       (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                         (if Ex (Fields (Program P) k)\n                          then The (Fields' P k) else [])))) \\<circ>\n              fst)\n          P)\n        x", "apply(clarsimp simp add: sees_field_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<forall>a aa b.\n           map_of P x \\<noteq>\n           \\<lfloor>(a, aa, b)\\<rfloor>) \\<longrightarrow>\n       None =\n       map_of\n        (map ((\\<lambda>k.\n                  (k, Mapping.of_alist\n                       (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                         (if Ex (Fields (Program P) k)\n                          then The (Fields' P k) else [])))) \\<circ>\n              fst)\n          P)\n        x", "apply(clarsimp simp add: o_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>a aa b.\n          map_of P x \\<noteq> \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       None =\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  Mapping.of_alist\n                   (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n                     (if Ex (Fields (Program P) (fst x))\n                      then The (Fields' P (fst x)) else []))))\n          P)\n        x", "apply(subst map_of_map2[simplified split_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>a aa b.\n          map_of P x \\<noteq> \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       None =\n       map_option\n        (\\<lambda>a.\n            Mapping.of_alist\n             (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n               (if Ex (Fields (Program P) x) then The (Fields' P x)\n                else [])))\n        (map_of P x)", "apply(rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>a aa b.\n          map_of P x \\<noteq> \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       map_option\n        (\\<lambda>a.\n            Mapping.of_alist\n             (map (\\<lambda>((F, D), Tfm). (F, D, Tfm))\n               (if Ex (Fields (Program P) x) then The (Fields' P x)\n                else [])))\n        (map_of P x) =\n       None", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>a aa b.\n          map_of P x \\<noteq> \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       map_of P x = None", "apply(rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>a aa b.\n                   map_of P x \\<noteq> \\<lfloor>(a, aa, b)\\<rfloor>;\n        map_of P x \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>@{term \"Methods\" }\\<close>"], ["", "text \\<open>Same termination problem as for @{term Fields'}\\<close>"], ["", "inductive Methods' :: \"'m cdecl list \\<Rightarrow> cname \\<Rightarrow> (mname \\<times> (ty list \\<times> ty \\<times> 'm option) \\<times> cname) list \\<Rightarrow> bool\"\n  for P :: \"'m cdecl list\"\nwhere \n  \"\\<lbrakk> map_of P Object = Some(D,fs,ms); Mm = map (\\<lambda>(M, rest). (M, (rest, Object))) ms \\<rbrakk>\n   \\<Longrightarrow> Methods' P Object Mm\"\n| \"\\<lbrakk> map_of P C = Some(D,fs,ms); C \\<noteq> Object; Methods' P D Mm;\n     Mm' = map (\\<lambda>(M, rest). (M, (rest, C))) ms @ Mm \\<rbrakk>\n   \\<Longrightarrow> Methods' P C Mm'\""], ["", "lemma Methods'_into_Methods:\n  assumes \"Methods' P C Mm\"\n  shows \"Program P \\<turnstile> C sees_methods (map_of Mm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Program P \\<turnstile> C sees_methods map_of Mm", "using assms"], ["proof (prove)\nusing this:\n  Methods' P C Mm\n\ngoal (1 subgoal):\n 1. Program P \\<turnstile> C sees_methods map_of Mm", "apply induct"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm.\n       \\<lbrakk>map_of P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map (\\<lambda>(M, rest). (M, rest, Object)) ms\\<rbrakk>\n       \\<Longrightarrow> Program\n                          P \\<turnstile> Object sees_methods map_of Mm\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>map_of P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; Methods' P D Mm;\n        Program P \\<turnstile> D sees_methods map_of Mm;\n        Mm' = map (\\<lambda>(M, rest). (M, rest, C)) ms @ Mm\\<rbrakk>\n       \\<Longrightarrow> Program P \\<turnstile> C sees_methods map_of Mm'", "apply(clarsimp simp add: o_def split_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D fs ms.\n       map_of P Object = \\<lfloor>(D, fs, ms)\\<rfloor> \\<Longrightarrow>\n       Program\n        P \\<turnstile> Object sees_methods map_of\n      (map (\\<lambda>p. (fst p, snd p, Object)) ms)\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>map_of P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; Methods' P D Mm;\n        Program P \\<turnstile> D sees_methods map_of Mm;\n        Mm' = map (\\<lambda>(M, rest). (M, rest, C)) ms @ Mm\\<rbrakk>\n       \\<Longrightarrow> Program P \\<turnstile> C sees_methods map_of Mm'", "apply(rule sees_methods_Object)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>D fs ms.\n       map_of P Object = \\<lfloor>(D, fs, ms)\\<rfloor> \\<Longrightarrow>\n       class (Program P) Object =\n       \\<lfloor>(?D5 D fs ms, ?fs5 D fs ms, ?ms5 D fs ms)\\<rfloor>\n 2. \\<And>D fs ms.\n       map_of P Object = \\<lfloor>(D, fs, ms)\\<rfloor> \\<Longrightarrow>\n       map_of (map (\\<lambda>p. (fst p, snd p, Object)) ms) =\n       map_option (\\<lambda>m. (m, Object)) \\<circ> map_of (?ms5 D fs ms)\n 3. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>map_of P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; Methods' P D Mm;\n        Program P \\<turnstile> D sees_methods map_of Mm;\n        Mm' = map (\\<lambda>(M, rest). (M, rest, C)) ms @ Mm\\<rbrakk>\n       \\<Longrightarrow> Program P \\<turnstile> C sees_methods map_of Mm'", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D fs ms.\n       map_of P Object = \\<lfloor>(D, fs, ms)\\<rfloor> \\<Longrightarrow>\n       map_of (map (\\<lambda>p. (fst p, snd p, Object)) ms) =\n       map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>map_of P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; Methods' P D Mm;\n        Program P \\<turnstile> D sees_methods map_of Mm;\n        Mm' = map (\\<lambda>(M, rest). (M, rest, C)) ms @ Mm\\<rbrakk>\n       \\<Longrightarrow> Program P \\<turnstile> C sees_methods map_of Mm'", "apply(rule ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D fs ms x.\n       map_of P Object = \\<lfloor>(D, fs, ms)\\<rfloor> \\<Longrightarrow>\n       map_of (map (\\<lambda>p. (fst p, snd p, Object)) ms) x =\n       (map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms) x\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>map_of P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; Methods' P D Mm;\n        Program P \\<turnstile> D sees_methods map_of Mm;\n        Mm' = map (\\<lambda>(M, rest). (M, rest, C)) ms @ Mm\\<rbrakk>\n       \\<Longrightarrow> Program P \\<turnstile> C sees_methods map_of Mm'", "apply(subst map_of_map2[unfolded split_def])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D fs ms x.\n       map_of P Object = \\<lfloor>(D, fs, ms)\\<rfloor> \\<Longrightarrow>\n       map_option (\\<lambda>a. (a, Object)) (map_of ms x) =\n       (map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms) x\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>map_of P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; Methods' P D Mm;\n        Program P \\<turnstile> D sees_methods map_of Mm;\n        Mm' = map (\\<lambda>(M, rest). (M, rest, C)) ms @ Mm\\<rbrakk>\n       \\<Longrightarrow> Program P \\<turnstile> C sees_methods map_of Mm'", "apply(simp add: o_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>map_of P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; Methods' P D Mm;\n        Program P \\<turnstile> D sees_methods map_of Mm;\n        Mm' = map (\\<lambda>(M, rest). (M, rest, C)) ms @ Mm\\<rbrakk>\n       \\<Longrightarrow> Program P \\<turnstile> C sees_methods map_of Mm'", "apply(rule sees_methods_rec)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>map_of P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; Methods' P D Mm;\n        Program P \\<turnstile> D sees_methods map_of Mm;\n        Mm' = map (\\<lambda>(M, rest). (M, rest, C)) ms @ Mm\\<rbrakk>\n       \\<Longrightarrow> class (Program P) C =\n                         \\<lfloor>(?D20 C D fs ms Mm Mm',\n                                   ?fs20 C D fs ms Mm Mm',\n                                   ?ms20 C D fs ms Mm Mm')\\<rfloor>\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>map_of P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; Methods' P D Mm;\n        Program P \\<turnstile> D sees_methods map_of Mm;\n        Mm' = map (\\<lambda>(M, rest). (M, rest, C)) ms @ Mm\\<rbrakk>\n       \\<Longrightarrow> C \\<noteq> Object\n 3. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>map_of P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; Methods' P D Mm;\n        Program P \\<turnstile> D sees_methods map_of Mm;\n        Mm' = map (\\<lambda>(M, rest). (M, rest, C)) ms @ Mm\\<rbrakk>\n       \\<Longrightarrow> Program\n                          P \\<turnstile> ?D20 C D fs ms Mm\n    Mm' sees_methods ?Mm20 C D fs ms Mm Mm'\n 4. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>map_of P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; Methods' P D Mm;\n        Program P \\<turnstile> D sees_methods map_of Mm;\n        Mm' = map (\\<lambda>(M, rest). (M, rest, C)) ms @ Mm\\<rbrakk>\n       \\<Longrightarrow> map_of Mm' =\n                         ?Mm20 C D fs ms Mm Mm' ++\n                         (map_option (\\<lambda>m. (m, C)) \\<circ>\n                          map_of (?ms20 C D fs ms Mm Mm'))", "apply fastforce"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>map_of P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; Methods' P D Mm;\n        Program P \\<turnstile> D sees_methods map_of Mm;\n        Mm' = map (\\<lambda>(M, rest). (M, rest, C)) ms @ Mm\\<rbrakk>\n       \\<Longrightarrow> C \\<noteq> Object\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>map_of P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; Methods' P D Mm;\n        Program P \\<turnstile> D sees_methods map_of Mm;\n        Mm' = map (\\<lambda>(M, rest). (M, rest, C)) ms @ Mm\\<rbrakk>\n       \\<Longrightarrow> Program\n                          P \\<turnstile> D sees_methods ?Mm20 C D fs ms Mm\n                   Mm'\n 3. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>map_of P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; Methods' P D Mm;\n        Program P \\<turnstile> D sees_methods map_of Mm;\n        Mm' = map (\\<lambda>(M, rest). (M, rest, C)) ms @ Mm\\<rbrakk>\n       \\<Longrightarrow> map_of Mm' =\n                         ?Mm20 C D fs ms Mm Mm' ++\n                         (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>map_of P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; Methods' P D Mm;\n        Program P \\<turnstile> D sees_methods map_of Mm;\n        Mm' = map (\\<lambda>(M, rest). (M, rest, C)) ms @ Mm\\<rbrakk>\n       \\<Longrightarrow> Program\n                          P \\<turnstile> D sees_methods ?Mm20 C D fs ms Mm\n                   Mm'\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>map_of P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; Methods' P D Mm;\n        Program P \\<turnstile> D sees_methods map_of Mm;\n        Mm' = map (\\<lambda>(M, rest). (M, rest, C)) ms @ Mm\\<rbrakk>\n       \\<Longrightarrow> map_of Mm' =\n                         ?Mm20 C D fs ms Mm Mm' ++\n                         (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>map_of P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; Methods' P D Mm;\n        Program P \\<turnstile> D sees_methods map_of Mm;\n        Mm' = map (\\<lambda>(M, rest). (M, rest, C)) ms @ Mm\\<rbrakk>\n       \\<Longrightarrow> map_of Mm' =\n                         map_of Mm ++\n                         (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)", "apply(clarsimp simp add: map_add_def map_of_map2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Methods_into_Methods':\n  assumes \"Program P \\<turnstile> C sees_methods Mm\"\n  shows \"\\<exists>Mm'. Methods' P C Mm' \\<and> Mm = map_of Mm'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Mm'. Methods' P C Mm' \\<and> Mm = map_of Mm'", "using assms"], ["proof (prove)\nusing this:\n  Program P \\<turnstile> C sees_methods Mm\n\ngoal (1 subgoal):\n 1. \\<exists>Mm'. Methods' P C Mm' \\<and> Mm = map_of Mm'", "by induct(auto intro: Methods'.intros simp add: map_of_map2 map_add_def)"], ["", "code_pred \n  (modes: i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> bool)\n  Methods'"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition methods' :: \"'m cdecl list \\<Rightarrow> cname \\<Rightarrow> (mname \\<times> (ty list \\<times> ty \\<times> 'm option) \\<times> cname) list\"\nwhere \"methods' P C = (if \\<exists>Mm. Methods' P C Mm then THE Mm. Methods' P C Mm else [])\""], ["", "lemma methods'_code [code]:\n  \"methods' P C =\n  (let Mm = Methods'_i_i_o P C\n   in if Predicate.holds (Mm \\<bind> (\\<lambda>_. Predicate.single ())) then Predicate.the Mm else [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. methods' P C =\n    (let Mm = Methods'_i_i_o P C\n     in if Predicate.holds (Mm \\<bind> (\\<lambda>_. Predicate.single ()))\n        then Predicate.the Mm else [])", "unfolding methods'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Ex (Methods' P C) then The (Methods' P C) else []) =\n    (let Mm = Methods'_i_i_o P C\n     in if Predicate.holds (Mm \\<bind> (\\<lambda>_. Predicate.single ()))\n        then Predicate.the Mm else [])", "by(auto simp add: holds_eq Methods'_i_i_o_def Predicate.the_def)"], ["", "lemma Methods'_fun:\n  assumes \"Methods' P C Mm\"\n  shows \"Methods' P C Mm' \\<Longrightarrow> Mm = Mm'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Methods' P C Mm' \\<Longrightarrow> Mm = Mm'", "using assms"], ["proof (prove)\nusing this:\n  Methods' P C Mm\n\ngoal (1 subgoal):\n 1. Methods' P C Mm' \\<Longrightarrow> Mm = Mm'", "apply(induct arbitrary: Mm')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm Mm'.\n       \\<lbrakk>map_of P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map (\\<lambda>(M, rest). (M, rest, Object)) ms;\n        Methods' P Object Mm'\\<rbrakk>\n       \\<Longrightarrow> Mm = Mm'\n 2. \\<And>C D fs ms Mm Mm' Mm'a.\n       \\<lbrakk>map_of P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; Methods' P D Mm;\n        \\<And>Mm'. Methods' P D Mm' \\<Longrightarrow> Mm = Mm';\n        Mm' = map (\\<lambda>(M, rest). (M, rest, C)) ms @ Mm;\n        Methods' P C Mm'a\\<rbrakk>\n       \\<Longrightarrow> Mm' = Mm'a", "apply(fastforce elim: Methods'.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms Mm Mm' Mm'a.\n       \\<lbrakk>map_of P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; Methods' P D Mm;\n        \\<And>Mm'. Methods' P D Mm' \\<Longrightarrow> Mm = Mm';\n        Mm' = map (\\<lambda>(M, rest). (M, rest, C)) ms @ Mm;\n        Methods' P C Mm'a\\<rbrakk>\n       \\<Longrightarrow> Mm' = Mm'a", "apply(rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms Mm Mm' Mm'a.\n       \\<lbrakk>Methods' P C Mm'a;\n        map_of P C = \\<lfloor>(D, fs, ms)\\<rfloor>; C \\<noteq> Object;\n        Methods' P D Mm;\n        \\<And>Mm'. Methods' P D Mm' \\<Longrightarrow> Mm = Mm';\n        Mm' = map (\\<lambda>(M, rest). (M, rest, C)) ms @ Mm\\<rbrakk>\n       \\<Longrightarrow> Mm' = Mm'a", "apply(erule Methods'.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C D fs ms Mm Mm' Mm'a Da fsa msa Mma.\n       \\<lbrakk>map_of P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; Methods' P D Mm;\n        \\<And>Mm'. Methods' P D Mm' \\<Longrightarrow> Mm = Mm';\n        Mm' = map (\\<lambda>(M, rest). (M, rest, C)) ms @ Mm; C = Object;\n        Mm'a = Mma; map_of P Object = \\<lfloor>(Da, fsa, msa)\\<rfloor>;\n        Mma = map (\\<lambda>(M, rest). (M, rest, Object)) msa\\<rbrakk>\n       \\<Longrightarrow> Mm' = Mm'a\n 2. \\<And>C D fs ms Mm Mm' Mm'a Ca Da fsa msa Mma Mm'b.\n       \\<lbrakk>map_of P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; Methods' P D Mm;\n        \\<And>Mm'. Methods' P D Mm' \\<Longrightarrow> Mm = Mm';\n        Mm' = map (\\<lambda>(M, rest). (M, rest, C)) ms @ Mm; C = Ca;\n        Mm'a = Mm'b; map_of P Ca = \\<lfloor>(Da, fsa, msa)\\<rfloor>;\n        Ca \\<noteq> Object; Methods' P Da Mma;\n        Mm'b = map (\\<lambda>(M, rest). (M, rest, Ca)) msa @ Mma\\<rbrakk>\n       \\<Longrightarrow> Mm' = Mm'a", "apply(fastforce)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms Mm Mm' Mm'a Ca Da fsa msa Mma Mm'b.\n       \\<lbrakk>map_of P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; Methods' P D Mm;\n        \\<And>Mm'. Methods' P D Mm' \\<Longrightarrow> Mm = Mm';\n        Mm' = map (\\<lambda>(M, rest). (M, rest, C)) ms @ Mm; C = Ca;\n        Mm'a = Mm'b; map_of P Ca = \\<lfloor>(Da, fsa, msa)\\<rfloor>;\n        Ca \\<noteq> Object; Methods' P Da Mma;\n        Mm'b = map (\\<lambda>(M, rest). (M, rest, Ca)) msa @ Mma\\<rbrakk>\n       \\<Longrightarrow> Mm' = Mm'a", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms Mm Mm' Mm'a Ca Da fsa msa Mma Mm'b.\n       \\<lbrakk>map_of P Ca = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object; Methods' P D Mm;\n        \\<And>Mm'. Methods' P D Mm' \\<Longrightarrow> Mm = Mm';\n        map_of P Ca = \\<lfloor>(Da, fsa, msa)\\<rfloor>; Ca \\<noteq> Object;\n        Methods' P Da Mma\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>(M, rest). (M, rest, Ca)) ms @ Mm =\n                         map (\\<lambda>(M, rest). (M, rest, Ca)) msa @ Mma", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma The_Methods' [simp]: \"Methods' P C Mm \\<Longrightarrow> The (Methods' P C) = Mm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Methods' P C Mm \\<Longrightarrow> The (Methods' P C) = Mm", "by(auto dest: Methods'_fun)"], ["", "lemma methods_def2 [simp]: \"Methods' P C Mm \\<Longrightarrow> methods' P C = Mm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Methods' P C Mm \\<Longrightarrow> methods' P C = Mm", "by(auto simp add: methods'_def)"], ["", "lemma tabulate_Method_code [code]:\n  \"tabulate_Method P =\n   Mapping.tabulate (map fst P) (\\<lambda>C. Mapping.of_alist (map (\\<lambda>(M, (rest, D)). (M, D, rest)) (methods' P C)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tabulate_Method P =\n    Mapping.tabulate (map fst P)\n     (\\<lambda>C.\n         Mapping.of_alist\n          (map (\\<lambda>(M, rest, D). (M, D, rest)) (methods' P C)))", "apply(simp add: tabulate_Method_def tabulate_def o_def lookup.rep_eq Mapping_inject)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_fun id (map_option mapping.Mapping)\n     (\\<lambda>C.\n         if is_class (Program P) C\n         then \\<lfloor>\\<lambda>M.\n                          if \\<exists>Ts T mthd.\n                                Ex (Method (Program (id P)) C M Ts T mthd)\n                          then \\<lfloor>method (Program (id P)) C M\\<rfloor>\n                          else None\\<rfloor>\n         else None) =\n    map_of\n     (map (\\<lambda>x.\n              (fst x,\n               Mapping.of_alist\n                (map (\\<lambda>(M, rest, D). (M, D, rest))\n                  (methods' P (fst x)))))\n       P)", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       map_fun id (map_option mapping.Mapping)\n        (\\<lambda>C.\n            if is_class (Program P) C\n            then \\<lfloor>\\<lambda>M.\n                             if \\<exists>Ts T mthd.\n                                   Ex (Method (Program (id P)) C M Ts T\n  mthd)\n                             then \\<lfloor>method (Program (id P)) C\n      M\\<rfloor>\n                             else None\\<rfloor>\n            else None)\n        x =\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  Mapping.of_alist\n                   (map (\\<lambda>(M, rest, D). (M, D, rest))\n                     (methods' P (fst x)))))\n          P)\n        x", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (is_class (Program P) x \\<longrightarrow>\n        \\<lfloor>mapping.Mapping\n                  (\\<lambda>M.\n                      if \\<exists>Ts T mthd.\n                            Ex (Method (Program P) x M Ts T mthd)\n                      then \\<lfloor>method (Program (id P)) (id x)\n                                     M\\<rfloor>\n                      else None)\\<rfloor> =\n        map_of\n         (map (\\<lambda>x.\n                  (fst x,\n                   Mapping.of_alist\n                    (map (\\<lambda>(M, rest, D). (M, D, rest))\n                      (methods' P (fst x)))))\n           P)\n         x) \\<and>\n       (\\<not> is_class (Program P) x \\<longrightarrow>\n        None =\n        map_of\n         (map (\\<lambda>x.\n                  (fst x,\n                   Mapping.of_alist\n                    (map (\\<lambda>(M, rest, D). (M, D, rest))\n                      (methods' P (fst x)))))\n           P)\n         x)", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       is_class (Program P) x \\<longrightarrow>\n       \\<lfloor>mapping.Mapping\n                 (\\<lambda>M.\n                     if \\<exists>Ts T mthd.\n                           Ex (Method (Program P) x M Ts T mthd)\n                     then \\<lfloor>method (Program (id P)) (id x) M\\<rfloor>\n                     else None)\\<rfloor> =\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  Mapping.of_alist\n                   (map (\\<lambda>(M, rest, D). (M, D, rest))\n                     (methods' P (fst x)))))\n          P)\n        x\n 2. \\<And>x.\n       \\<not> is_class (Program P) x \\<longrightarrow>\n       None =\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  Mapping.of_alist\n                   (map (\\<lambda>(M, rest, D). (M, D, rest))\n                     (methods' P (fst x)))))\n          P)\n        x", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       is_class (Program P) x \\<Longrightarrow>\n       \\<lfloor>mapping.Mapping\n                 (\\<lambda>M.\n                     if \\<exists>Ts T mthd.\n                           Ex (Method (Program P) x M Ts T mthd)\n                     then \\<lfloor>method (Program (id P)) (id x) M\\<rfloor>\n                     else None)\\<rfloor> =\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  Mapping.of_alist\n                   (map (\\<lambda>(M, rest, D). (M, D, rest))\n                     (methods' P (fst x)))))\n          P)\n        x\n 2. \\<And>x.\n       \\<not> is_class (Program P) x \\<longrightarrow>\n       None =\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  Mapping.of_alist\n                   (map (\\<lambda>(M, rest, D). (M, D, rest))\n                     (methods' P (fst x)))))\n          P)\n        x", "apply(rule sym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       is_class (Program P) x \\<Longrightarrow>\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  Mapping.of_alist\n                   (map (\\<lambda>(M, rest, D). (M, D, rest))\n                     (methods' P (fst x)))))\n          P)\n        x =\n       \\<lfloor>mapping.Mapping\n                 (\\<lambda>M.\n                     if \\<exists>Ts T mthd.\n                           Ex (Method (Program P) x M Ts T mthd)\n                     then \\<lfloor>method (Program (id P)) (id x) M\\<rfloor>\n                     else None)\\<rfloor>\n 2. \\<And>x.\n       \\<not> is_class (Program P) x \\<longrightarrow>\n       None =\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  Mapping.of_alist\n                   (map (\\<lambda>(M, rest, D). (M, D, rest))\n                     (methods' P (fst x)))))\n          P)\n        x", "apply(subst map_of_map2[unfolded split_def])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       is_class (Program P) x \\<Longrightarrow>\n       map_option\n        (\\<lambda>a.\n            Mapping.of_alist\n             (map (\\<lambda>(M, rest, D). (M, D, rest)) (methods' P x)))\n        (map_of P x) =\n       \\<lfloor>mapping.Mapping\n                 (\\<lambda>M.\n                     if \\<exists>Ts T mthd.\n                           Ex (Method (Program P) x M Ts T mthd)\n                     then \\<lfloor>method (Program (id P)) (id x) M\\<rfloor>\n                     else None)\\<rfloor>\n 2. \\<And>x.\n       \\<not> is_class (Program P) x \\<longrightarrow>\n       None =\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  Mapping.of_alist\n                   (map (\\<lambda>(M, rest, D). (M, D, rest))\n                     (methods' P (fst x)))))\n          P)\n        x", "apply(simp add: is_class_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<exists>a aa b.\n          map_of P x = \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       Mapping.of_alist\n        (map (\\<lambda>(M, rest, D). (M, D, rest)) (methods' P x)) =\n       mapping.Mapping\n        (\\<lambda>M.\n            if \\<exists>Ts T mthd. Ex (Method (Program P) x M Ts T mthd)\n            then \\<lfloor>method (Program (id P)) (id x) M\\<rfloor>\n            else None)\n 2. \\<And>x.\n       \\<not> is_class (Program P) x \\<longrightarrow>\n       None =\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  Mapping.of_alist\n                   (map (\\<lambda>(M, rest, D). (M, D, rest))\n                     (methods' P (fst x)))))\n          P)\n        x", "apply transfer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x P.\n       \\<exists>a aa b.\n          map_of P x = \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       map_of (map (\\<lambda>(M, rest, D). (M, D, rest)) (methods' P x)) =\n       (\\<lambda>M.\n           if \\<exists>Ts T mthd. Ex (Method (Program P) x M Ts T mthd)\n           then \\<lfloor>method (Program (id P)) (id x) M\\<rfloor>\n           else None)\n 2. \\<And>x.\n       \\<not> is_class (Program P) x \\<longrightarrow>\n       None =\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  Mapping.of_alist\n                   (map (\\<lambda>(M, rest, D). (M, D, rest))\n                     (methods' P (fst x)))))\n          P)\n        x", "apply(rule ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x P M.\n       \\<exists>a aa b.\n          map_of P x = \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       map_of (map (\\<lambda>(M, rest, D). (M, D, rest)) (methods' P x)) M =\n       (if \\<exists>Ts T mthd. Ex (Method (Program P) x M Ts T mthd)\n        then \\<lfloor>method (Program (id P)) (id x) M\\<rfloor> else None)\n 2. \\<And>x.\n       \\<not> is_class (Program P) x \\<longrightarrow>\n       None =\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  Mapping.of_alist\n                   (map (\\<lambda>(M, rest, D). (M, D, rest))\n                     (methods' P (fst x)))))\n          P)\n        x", "apply(simp add: map_of_map2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x P M.\n       \\<exists>a aa b.\n          map_of P x = \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       ((\\<exists>Ts T mthd.\n            Ex (Method (Program P) x M Ts T mthd)) \\<longrightarrow>\n        map_of (map (\\<lambda>(M, rest, D). (M, D, rest)) (methods' P x))\n         M =\n        \\<lfloor>method (Program P) x M\\<rfloor>) \\<and>\n       ((\\<forall>Ts T mthd xa.\n            \\<not> Program\n                    P \\<turnstile> x sees M: Ts\\<rightarrow>T = mthd in xa) \\<longrightarrow>\n        map_of (map (\\<lambda>(M, rest, D). (M, D, rest)) (methods' P x))\n         M =\n        None)\n 2. \\<And>x.\n       \\<not> is_class (Program P) x \\<longrightarrow>\n       None =\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  Mapping.of_alist\n                   (map (\\<lambda>(M, rest, D). (M, D, rest))\n                     (methods' P (fst x)))))\n          P)\n        x", "apply(rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x P M.\n       \\<exists>a aa b.\n          map_of P x = \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       (\\<exists>Ts T mthd.\n           Ex (Method (Program P) x M Ts T mthd)) \\<longrightarrow>\n       map_of (map (\\<lambda>(M, rest, D). (M, D, rest)) (methods' P x)) M =\n       \\<lfloor>method (Program P) x M\\<rfloor>\n 2. \\<And>x P M.\n       \\<exists>a aa b.\n          map_of P x = \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       (\\<forall>Ts T mthd xa.\n           \\<not> Program\n                   P \\<turnstile> x sees M: Ts\\<rightarrow>T = mthd in xa) \\<longrightarrow>\n       map_of (map (\\<lambda>(M, rest, D). (M, D, rest)) (methods' P x)) M =\n       None\n 3. \\<And>x.\n       \\<not> is_class (Program P) x \\<longrightarrow>\n       None =\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  Mapping.of_alist\n                   (map (\\<lambda>(M, rest, D). (M, D, rest))\n                     (methods' P (fst x)))))\n          P)\n        x", "apply(clarsimp simp add: map_of_map2 Method_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x P M a aa b Ts T mthd xa Mm.\n       \\<lbrakk>map_of P x = \\<lfloor>(a, aa, b)\\<rfloor>;\n        Program P \\<turnstile> x sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, mthd), xa)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (map (\\<lambda>(M, rest, D). (M, D, rest))\n                            (methods' P x))\n                          M =\n                         \\<lfloor>(xa, Ts, T, mthd)\\<rfloor>\n 2. \\<And>x P M.\n       \\<exists>a aa b.\n          map_of P x = \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       (\\<forall>Ts T mthd xa.\n           \\<not> Program\n                   P \\<turnstile> x sees M: Ts\\<rightarrow>T = mthd in xa) \\<longrightarrow>\n       map_of (map (\\<lambda>(M, rest, D). (M, D, rest)) (methods' P x)) M =\n       None\n 3. \\<And>x.\n       \\<not> is_class (Program P) x \\<longrightarrow>\n       None =\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  Mapping.of_alist\n                   (map (\\<lambda>(M, rest, D). (M, D, rest))\n                     (methods' P (fst x)))))\n          P)\n        x", "apply(drule Methods_into_Methods')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x P M a aa b Ts T mthd xa Mm.\n       \\<lbrakk>map_of P x = \\<lfloor>(a, aa, b)\\<rfloor>;\n        Mm M = \\<lfloor>((Ts, T, mthd), xa)\\<rfloor>;\n        \\<exists>Mm'. Methods' P x Mm' \\<and> Mm = map_of Mm'\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (map (\\<lambda>(M, rest, D). (M, D, rest))\n                            (methods' P x))\n                          M =\n                         \\<lfloor>(xa, Ts, T, mthd)\\<rfloor>\n 2. \\<And>x P M.\n       \\<exists>a aa b.\n          map_of P x = \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       (\\<forall>Ts T mthd xa.\n           \\<not> Program\n                   P \\<turnstile> x sees M: Ts\\<rightarrow>T = mthd in xa) \\<longrightarrow>\n       map_of (map (\\<lambda>(M, rest, D). (M, D, rest)) (methods' P x)) M =\n       None\n 3. \\<And>x.\n       \\<not> is_class (Program P) x \\<longrightarrow>\n       None =\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  Mapping.of_alist\n                   (map (\\<lambda>(M, rest, D). (M, D, rest))\n                     (methods' P (fst x)))))\n          P)\n        x", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x P M a aa b Ts T mthd xa Mm'.\n       \\<lbrakk>map_of P x = \\<lfloor>(a, aa, b)\\<rfloor>;\n        map_of Mm' M = \\<lfloor>((Ts, T, mthd), xa)\\<rfloor>;\n        Methods' P x Mm'\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (map (\\<lambda>(M, rest, D). (M, D, rest)) Mm')\n                          M =\n                         \\<lfloor>(xa, Ts, T, mthd)\\<rfloor>\n 2. \\<And>x P M.\n       \\<exists>a aa b.\n          map_of P x = \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       (\\<forall>Ts T mthd xa.\n           \\<not> Program\n                   P \\<turnstile> x sees M: Ts\\<rightarrow>T = mthd in xa) \\<longrightarrow>\n       map_of (map (\\<lambda>(M, rest, D). (M, D, rest)) (methods' P x)) M =\n       None\n 3. \\<And>x.\n       \\<not> is_class (Program P) x \\<longrightarrow>\n       None =\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  Mapping.of_alist\n                   (map (\\<lambda>(M, rest, D). (M, D, rest))\n                     (methods' P (fst x)))))\n          P)\n        x", "apply(simp add: split_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x P M a aa b Ts T mthd xa Mm'.\n       \\<lbrakk>map_of P x = \\<lfloor>(a, aa, b)\\<rfloor>;\n        map_of Mm' M = \\<lfloor>((Ts, T, mthd), xa)\\<rfloor>;\n        Methods' P x Mm'\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (map (\\<lambda>p.\n                                   (fst p, snd (snd p), fst (snd p)))\n                            Mm')\n                          M =\n                         \\<lfloor>(xa, Ts, T, mthd)\\<rfloor>\n 2. \\<And>x P M.\n       \\<exists>a aa b.\n          map_of P x = \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       (\\<forall>Ts T mthd xa.\n           \\<not> Program\n                   P \\<turnstile> x sees M: Ts\\<rightarrow>T = mthd in xa) \\<longrightarrow>\n       map_of (map (\\<lambda>(M, rest, D). (M, D, rest)) (methods' P x)) M =\n       None\n 3. \\<And>x.\n       \\<not> is_class (Program P) x \\<longrightarrow>\n       None =\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  Mapping.of_alist\n                   (map (\\<lambda>(M, rest, D). (M, D, rest))\n                     (methods' P (fst x)))))\n          P)\n        x", "apply(subst map_of_map2[unfolded split_def])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x P M a aa b Ts T mthd xa Mm'.\n       \\<lbrakk>map_of P x = \\<lfloor>(a, aa, b)\\<rfloor>;\n        map_of Mm' M = \\<lfloor>((Ts, T, mthd), xa)\\<rfloor>;\n        Methods' P x Mm'\\<rbrakk>\n       \\<Longrightarrow> map_option (\\<lambda>a. (snd a, fst a))\n                          (map_of Mm' M) =\n                         \\<lfloor>(xa, Ts, T, mthd)\\<rfloor>\n 2. \\<And>x P M.\n       \\<exists>a aa b.\n          map_of P x = \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       (\\<forall>Ts T mthd xa.\n           \\<not> Program\n                   P \\<turnstile> x sees M: Ts\\<rightarrow>T = mthd in xa) \\<longrightarrow>\n       map_of (map (\\<lambda>(M, rest, D). (M, D, rest)) (methods' P x)) M =\n       None\n 3. \\<And>x.\n       \\<not> is_class (Program P) x \\<longrightarrow>\n       None =\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  Mapping.of_alist\n                   (map (\\<lambda>(M, rest, D). (M, D, rest))\n                     (methods' P (fst x)))))\n          P)\n        x", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x P M.\n       \\<exists>a aa b.\n          map_of P x = \\<lfloor>(a, aa, b)\\<rfloor> \\<Longrightarrow>\n       (\\<forall>Ts T mthd xa.\n           \\<not> Program\n                   P \\<turnstile> x sees M: Ts\\<rightarrow>T = mthd in xa) \\<longrightarrow>\n       map_of (map (\\<lambda>(M, rest, D). (M, D, rest)) (methods' P x)) M =\n       None\n 2. \\<And>x.\n       \\<not> is_class (Program P) x \\<longrightarrow>\n       None =\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  Mapping.of_alist\n                   (map (\\<lambda>(M, rest, D). (M, D, rest))\n                     (methods' P (fst x)))))\n          P)\n        x", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x P M a aa b.\n       \\<lbrakk>map_of P x = \\<lfloor>(a, aa, b)\\<rfloor>;\n        \\<forall>Ts T mthd xa.\n           \\<not> Program\n                   P \\<turnstile> x sees M: Ts\\<rightarrow>T = mthd in xa\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (map (\\<lambda>(M, rest, D). (M, D, rest))\n                            (methods' P x))\n                          M =\n                         None\n 2. \\<And>x.\n       \\<not> is_class (Program P) x \\<longrightarrow>\n       None =\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  Mapping.of_alist\n                   (map (\\<lambda>(M, rest, D). (M, D, rest))\n                     (methods' P (fst x)))))\n          P)\n        x", "apply(clarsimp simp add: methods'_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x P M a aa b xa.\n       \\<lbrakk>map_of P x = \\<lfloor>(a, aa, b)\\<rfloor>;\n        \\<forall>Ts T mthd xa.\n           \\<not> Program\n                   P \\<turnstile> x sees M: Ts\\<rightarrow>T = mthd in xa;\n        Methods' P x xa\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (map (\\<lambda>(M, rest, D). (M, D, rest)) xa) M =\n                         None\n 2. \\<And>x.\n       \\<not> is_class (Program P) x \\<longrightarrow>\n       None =\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  Mapping.of_alist\n                   (map (\\<lambda>(M, rest, D). (M, D, rest))\n                     (methods' P (fst x)))))\n          P)\n        x", "apply(frule Methods'_into_Methods)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x P M a aa b xa.\n       \\<lbrakk>map_of P x = \\<lfloor>(a, aa, b)\\<rfloor>;\n        \\<forall>Ts T mthd xa.\n           \\<not> Program\n                   P \\<turnstile> x sees M: Ts\\<rightarrow>T = mthd in xa;\n        Methods' P x xa;\n        Program P \\<turnstile> x sees_methods map_of xa\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (map (\\<lambda>(M, rest, D). (M, D, rest)) xa) M =\n                         None\n 2. \\<And>x.\n       \\<not> is_class (Program P) x \\<longrightarrow>\n       None =\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  Mapping.of_alist\n                   (map (\\<lambda>(M, rest, D). (M, D, rest))\n                     (methods' P (fst x)))))\n          P)\n        x", "apply(clarsimp simp add: Method_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x P M a aa b xa.\n       \\<lbrakk>map_of P x = \\<lfloor>(a, aa, b)\\<rfloor>;\n        \\<forall>Ts T mthd xa Mm.\n           Program P \\<turnstile> x sees_methods Mm \\<longrightarrow>\n           Mm M \\<noteq> \\<lfloor>((Ts, T, mthd), xa)\\<rfloor>;\n        Methods' P x xa;\n        Program P \\<turnstile> x sees_methods map_of xa\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (map (\\<lambda>(M, rest, D). (M, D, rest)) xa) M =\n                         None\n 2. \\<And>x.\n       \\<not> is_class (Program P) x \\<longrightarrow>\n       None =\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  Mapping.of_alist\n                   (map (\\<lambda>(M, rest, D). (M, D, rest))\n                     (methods' P (fst x)))))\n          P)\n        x", "apply(simp add: split_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x P M a aa b xa.\n       \\<lbrakk>map_of P x = \\<lfloor>(a, aa, b)\\<rfloor>;\n        \\<forall>Ts T mthd xa Mm.\n           Program P \\<turnstile> x sees_methods Mm \\<longrightarrow>\n           Mm M \\<noteq> \\<lfloor>((Ts, T, mthd), xa)\\<rfloor>;\n        Methods' P x xa;\n        Program P \\<turnstile> x sees_methods map_of xa\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (map (\\<lambda>p.\n                                   (fst p, snd (snd p), fst (snd p)))\n                            xa)\n                          M =\n                         None\n 2. \\<And>x.\n       \\<not> is_class (Program P) x \\<longrightarrow>\n       None =\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  Mapping.of_alist\n                   (map (\\<lambda>(M, rest, D). (M, D, rest))\n                     (methods' P (fst x)))))\n          P)\n        x", "apply(subst map_of_map2[unfolded split_def])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x P M a aa b xa.\n       \\<lbrakk>map_of P x = \\<lfloor>(a, aa, b)\\<rfloor>;\n        \\<forall>Ts T mthd xa Mm.\n           Program P \\<turnstile> x sees_methods Mm \\<longrightarrow>\n           Mm M \\<noteq> \\<lfloor>((Ts, T, mthd), xa)\\<rfloor>;\n        Methods' P x xa;\n        Program P \\<turnstile> x sees_methods map_of xa\\<rbrakk>\n       \\<Longrightarrow> map_option (\\<lambda>a. (snd a, fst a))\n                          (map_of xa M) =\n                         None\n 2. \\<And>x.\n       \\<not> is_class (Program P) x \\<longrightarrow>\n       None =\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  Mapping.of_alist\n                   (map (\\<lambda>(M, rest, D). (M, D, rest))\n                     (methods' P (fst x)))))\n          P)\n        x", "apply(fastforce intro: ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<not> is_class (Program P) x \\<longrightarrow>\n       None =\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  Mapping.of_alist\n                   (map (\\<lambda>(M, rest, D). (M, D, rest))\n                     (methods' P (fst x)))))\n          P)\n        x", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<not> is_class (Program P) x \\<Longrightarrow>\n       None =\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  Mapping.of_alist\n                   (map (\\<lambda>(M, rest, D). (M, D, rest))\n                     (methods' P (fst x)))))\n          P)\n        x", "apply(rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<not> is_class (Program P) x \\<Longrightarrow>\n       map_of\n        (map (\\<lambda>x.\n                 (fst x,\n                  Mapping.of_alist\n                   (map (\\<lambda>(M, rest, D). (M, D, rest))\n                     (methods' P (fst x)))))\n          P)\n        x =\n       None", "apply(simp add: map_of_eq_None_iff is_class_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> fst ` set P \\<Longrightarrow>\n       x \\<notin> fst `\n                  (\\<lambda>x.\n                      (fst x,\n                       Mapping.of_alist\n                        (map (\\<lambda>(M, rest, D). (M, D, rest))\n                          (methods' P (fst x))))) `\n                  set P", "apply(simp only: set_map[symmetric] map_map o_def fst_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<notin> set (map fst P) \\<Longrightarrow> \\<not> False", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Merge modules TypeRel, Decl and TypeRelRefine to avoid cyclic modules\\<close>"], ["", "code_identifier\n  code_module TypeRel \\<rightharpoonup>\n    (SML) TypeRel and (Haskell) TypeRel and (OCaml) TypeRel\n| code_module TypeRelRefine \\<rightharpoonup>\n    (SML) TypeRel and (Haskell) TypeRel and (OCaml) TypeRel\n| code_module Decl \\<rightharpoonup>\n    (SML) TypeRel and (Haskell) TypeRel and (OCaml) TypeRel"], ["", "ML_val \\<open>@{code Program}\\<close>"], ["", "end"]]}