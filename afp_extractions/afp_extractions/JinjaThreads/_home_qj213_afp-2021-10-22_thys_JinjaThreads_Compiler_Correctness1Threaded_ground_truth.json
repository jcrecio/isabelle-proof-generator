{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Compiler/Correctness1Threaded.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma el_loc_okI: \"\\<lbrakk> \\<not> contains_insync e; syncvars e; \\<B> e n \\<rbrakk> \\<Longrightarrow> el_loc_ok e xs\"\n  and els_loc_okI: \"\\<lbrakk> \\<not> contains_insyncs es; syncvarss es; \\<B>s es n \\<rbrakk> \\<Longrightarrow> els_loc_ok es xs\"", "lemma el_loc_ok_compE1: \"\\<lbrakk> \\<not> contains_insync e; fv e \\<subseteq> set Vs \\<rbrakk> \\<Longrightarrow> el_loc_ok (compE1 Vs e) xs\"\n  and els_loc_ok_compEs1: \"\\<lbrakk> \\<not> contains_insyncs es; fvs es \\<subseteq> set Vs \\<rbrakk> \\<Longrightarrow> els_loc_ok (compEs1 Vs es) xs\"", "lemma shows el_loc_ok_not_contains_insync_local_change:\n  \"\\<lbrakk> \\<not> contains_insync e; el_loc_ok e xs \\<rbrakk> \\<Longrightarrow> el_loc_ok e xs'\"\n  and els_loc_ok_not_contains_insyncs_local_change:\n  \"\\<lbrakk> \\<not> contains_insyncs es; els_loc_ok es xs \\<rbrakk> \\<Longrightarrow> els_loc_ok es xs'\"", "lemma el_loc_ok_update: \"\\<lbrakk> \\<B> e n; V < n \\<rbrakk> \\<Longrightarrow> el_loc_ok e (xs[V := v]) = el_loc_ok e xs\"\n  and els_loc_ok_update: \"\\<lbrakk> \\<B>s es n; V < n \\<rbrakk> \\<Longrightarrow> els_loc_ok es (xs[V := v]) = els_loc_ok es xs\"", "lemma els_loc_ok_map_Val [simp]:\n  \"els_loc_ok (map Val vs) xs\"", "lemma els_loc_ok_map_Val_append [simp]:\n  \"els_loc_ok (map Val vs @ es) xs = els_loc_ok es xs\"", "lemma el_loc_ok_extRet2J [simp]:\n  \"el_loc_ok e xs \\<Longrightarrow> el_loc_ok (extRet2J e va) xs\"", "lemma el_loc_ok1_simps:\n  \"el_loc_ok1 ((e, xs), exs) = (el_loc_ok e xs \\<and> sync_ok e \\<and> (\\<forall>(e,xs)\\<in>set exs. el_loc_ok e xs \\<and> sync_ok e))\"", "lemma el_loc_ok_blocks1 [simp]:\n   \"el_loc_ok (blocks1 n Ts body) xs = el_loc_ok body xs\"", "lemma sync_oks_blocks1 [simp]: \"sync_ok (blocks1 n Ts e) = sync_ok e\"", "lemma assumes fin: \"final e'\"\n  shows el_loc_ok_inline_call: \"el_loc_ok e xs \\<Longrightarrow> el_loc_ok (inline_call e' e) xs\"\n  and els_loc_ok_inline_calls: \"els_loc_ok es xs \\<Longrightarrow> els_loc_ok (inline_calls e' es) xs\"", "lemma assumes \"sync_ok e'\"\n  shows sync_ok_inline_call: \"sync_ok e \\<Longrightarrow> sync_ok (inline_call e' e)\"\n  and sync_oks_inline_calls: \"sync_oks es \\<Longrightarrow> sync_oks (inline_calls e' es)\"", "lemma bisim_sync_ok:\n  \"bisim Vs e e' xs \\<Longrightarrow> sync_ok e\"\n  \"bisim Vs e e' xs \\<Longrightarrow> sync_ok e'\"\n\n  and bisims_sync_oks:\n  \"bisims Vs es es' xs \\<Longrightarrow> sync_oks es\"\n  \"bisims Vs es es' xs \\<Longrightarrow> sync_oks es'\"", "lemma assumes \"final e'\"\n  shows expr_locks_inline_call_final:\n  \"expr_locks (inline_call e' e) = expr_locks e\"\n  and expr_lockss_inline_calls_final:\n  \"expr_lockss (inline_calls e' es) = expr_lockss es\"", "lemma lock_oks1I:\n  \"\\<lbrakk> \\<And>t l. ts t = None \\<Longrightarrow> has_locks (ls $ l) t = 0;\n     \\<And>t e x exs ln l. ts t = \\<lfloor>(((e, x), exs), ln)\\<rfloor> \\<Longrightarrow> has_locks (ls $ l) t + ln $ l= expr_locks e l + expr_lockss (map fst exs) l \\<rbrakk>\n  \\<Longrightarrow> lock_oks1 ls ts\"", "lemma lock_oks1E:\n  \"\\<lbrakk> lock_oks1 ls ts;\n     \\<forall>t. ts t = None \\<longrightarrow> (\\<forall>l. has_locks (ls $ l) t = 0) \\<Longrightarrow> Q;\n     \\<forall>t e x exs ln. ts t = \\<lfloor>(((e, x), exs), ln)\\<rfloor> \\<longrightarrow> (\\<forall>l. has_locks (ls $ l) t + ln $ l = expr_locks e l + expr_lockss (map fst exs) l) \\<Longrightarrow> Q \\<rbrakk>\n  \\<Longrightarrow> Q\"", "lemma lock_oks1D1:\n  \"\\<lbrakk> lock_oks1 ls ts; ts t = None \\<rbrakk> \\<Longrightarrow> \\<forall>l. has_locks (ls $ l) t = 0\"", "lemma lock_oks1D2:\n  \"\\<And>ln. \\<lbrakk> lock_oks1 ls ts; ts t = \\<lfloor>(((e, x), exs), ln)\\<rfloor> \\<rbrakk> \n  \\<Longrightarrow> \\<forall>l. has_locks (ls $ l) t + ln $ l = expr_locks e l + expr_lockss (map fst exs) l\"", "lemma lock_oks1_thr_updI:\n  \"\\<And>ln. \\<lbrakk> lock_oks1 ls ts; ts t = \\<lfloor>(((e, xs), exs), ln)\\<rfloor>;\n     \\<forall>l. expr_locks e l + expr_lockss (map fst exs) l = expr_locks e' l + expr_lockss (map fst exs') l \\<rbrakk>\n  \\<Longrightarrow> lock_oks1 ls (ts(t \\<mapsto> (((e', xs'), exs'), ln)))\"", "lemma sync_ok_blocks:\n  \"\\<lbrakk> length vs = length pns; length Ts = length pns\\<rbrakk>\n  \\<Longrightarrow> sync_ok (blocks pns Ts vs body) = sync_ok body\"", "lemma red1_True_into_red1_False:\n  \"\\<lbrakk> True,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; el_loc_ok e (lcl s) \\<rbrakk> \n  \\<Longrightarrow> False,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle> \\<or> (\\<exists>l. ta = \\<lbrace>UnlockFail\\<rightarrow>l\\<rbrace> \\<and> expr_locks e l > 0)\"\n  and reds1_True_into_reds1_False:\n  \"\\<lbrakk> True,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; els_loc_ok es (lcl s) \\<rbrakk>\n  \\<Longrightarrow> False,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle> \\<or> (\\<exists>l. ta = \\<lbrace>UnlockFail\\<rightarrow>l\\<rbrace> \\<and> expr_lockss es l > 0)\"", "lemma Red1_True_into_Red1_False:\n  assumes \"True,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow> \\<langle>ex'/exs',m'\\<rangle>\"\n  and \"el_loc_ok1 (ex, exs)\"\n  shows \"False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow> \\<langle>ex'/exs',m'\\<rangle> \\<or> \n         (\\<exists>l. ta = \\<lbrace>UnlockFail\\<rightarrow>l\\<rbrace> \\<and> expr_lockss (fst ex # map fst exs) l > 0)\"", "lemma shows red1_preserves_el_loc_ok:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; sync_ok e; el_loc_ok e (lcl s) \\<rbrakk> \\<Longrightarrow> el_loc_ok e' (lcl s')\"\n\n  and reds1_preserves_els_loc_ok:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; sync_oks es; els_loc_ok es (lcl s) \\<rbrakk> \\<Longrightarrow> els_loc_ok es' (lcl s')\"", "lemma red1_preserves_sync_ok: \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; sync_ok e \\<rbrakk> \\<Longrightarrow> sync_ok e'\"\n  and reds1_preserves_sync_oks: \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; sync_oks es \\<rbrakk> \\<Longrightarrow> sync_oks es'\"", "lemma Red1_preserves_el_loc_ok1:\n  assumes wf: \"wf_J1_prog P\"\n  shows \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>ex/exs,m\\<rangle> -ta\\<rightarrow> \\<langle>ex'/exs',m'\\<rangle>; el_loc_ok1 (ex, exs) \\<rbrakk>  \\<Longrightarrow> el_loc_ok1 (ex', exs')\"", "lemma assumes wf: \"wf_J1_prog P\"\n  shows red1_el_loc_ok1_new_thread:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; NewThread t' (C, M, a) h \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> el_loc_ok1 (({0:Class (fst (method P C M))=None; the (snd (snd (snd (method P C M))))}, xs), [])\"\n\n  and reds1_el_loc_ok1_new_thread:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; NewThread t' (C, M, a) h \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> el_loc_ok1 (({0:Class (fst (method P C M))=None; the (snd (snd (snd (method P C M))))}, xs), [])\"", "lemma Red1_el_loc_ok1_new_thread:\n  assumes wf: \"wf_J1_prog P\"\n  shows \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>ex/exs,m\\<rangle> -ta\\<rightarrow> \\<langle>ex'/exs',m'\\<rangle>; NewThread t' exexs m' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n         \\<Longrightarrow> el_loc_ok1 exexs\"", "lemma Red1_el_loc_ok: \n  assumes wf: \"wf_J1_prog P\"\n  shows \"lifting_wf final_expr1 (mred1g uf P) (\\<lambda>t exexs h. el_loc_ok1 exexs)\"", "lemma mred1_eq_mred1':\n  assumes lok: \"lock_oks1 (locks s) (thr s)\"\n  and elo: \"ts_ok (\\<lambda>t exexs h. el_loc_ok1 exexs) (thr s) (shr s)\"\n  and tst: \"thr s t = \\<lfloor>(exexs, no_wait_locks)\\<rfloor>\"\n  and aoe: \"Red1_mthr.actions_ok s t ta\"\n  shows \"mred1 P t (exexs, shr s) ta = mred1' P t (exexs, shr s) ta\"", "lemma Red1_mthr_eq_Red1_mthr':\n  assumes lok: \"lock_oks1 (locks s) (thr s)\"\n  and elo: \"ts_ok (\\<lambda>t exexs h. el_loc_ok1 exexs) (thr s) (shr s)\"\n  shows \"Red1_mthr.redT True P s = Red1_mthr.redT False P s\"", "lemma assumes wf: \"wf_J1_prog P\"\n  shows expr_locks_new_thread1:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -TA\\<rightarrow> \\<langle>e',s'\\<rangle>; NewThread t' (ex, exs) h \\<in> set (map (convert_new_thread_action (extNTA2J1 P)) \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>) \\<rbrakk>\n  \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\"\n  and expr_lockss_new_thread1:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es,s\\<rangle> [-TA\\<rightarrow>] \\<langle>es',s'\\<rangle>; NewThread t' (ex, exs) h \\<in> set (map (convert_new_thread_action (extNTA2J1 P)) \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>) \\<rbrakk>\n  \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\"", "lemma assumes wf: \"wf_J1_prog P\"\n  shows red1_update_expr_locks:\n  \"\\<lbrakk> False,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; sync_ok e; el_loc_ok e (lcl s) \\<rbrakk>\n  \\<Longrightarrow> upd_expr_locks (int o expr_locks e) \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = int o expr_locks e'\"\n\n  and reds1_update_expr_lockss:\n  \"\\<lbrakk> False,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; sync_oks es; els_loc_ok es (lcl s) \\<rbrakk>\n  \\<Longrightarrow> upd_expr_locks (int o expr_lockss es) \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = int o expr_lockss es'\"", "lemma Red1'_preserves_lock_oks:\n  assumes wf: \"wf_J1_prog P\"\n  and Red: \"Red1_mthr.redT False P s1 ta1 s1'\"\n  and loks: \"lock_oks1 (locks s1) (thr s1)\"\n  and sync: \"ts_ok (\\<lambda>t exexs h. el_loc_ok1 exexs) (thr s1) (shr s1)\"\n  shows \"lock_oks1 (locks s1') (thr s1')\"", "lemma Red1'_Red1_bisimulation:\n  assumes wf: \"wf_J1_prog P\"\n  shows \"bisimulation (Red1_mthr.redT False P) (Red1_mthr.redT True P) mbisim_Red1'_Red1 (=)\"", "lemma Red1'_Red1_bisimulation_final:\n  \"wf_J1_prog P \n  \\<Longrightarrow> bisimulation_final (Red1_mthr.redT False P) (Red1_mthr.redT True P) \n       mbisim_Red1'_Red1 (=) Red1_mthr.mfinal Red1_mthr.mfinal\"", "lemma bisim_J1_J1_start:\n  assumes wf: \"wf_J1_prog P\"\n  and wf_start: \"wf_start_state P C M vs\"\n  shows \"mbisim_Red1'_Red1 (J1_start_state P C M vs) (J1_start_state P C M vs)\"", "lemma Red1'_Red1_bisim_into_weak:\n  assumes wf: \"wf_J1_prog P\"\n  shows \"bisimulation_into_delay (Red1_mthr.redT False P) (Red1_mthr.redT True P) mbisim_Red1'_Red1 (=) (Red1_mthr.m\\<tau>move P) (Red1_mthr.m\\<tau>move P)\"", "lemma if_mbisim_Red1'_Red1_imp_mbisim_Red1'_Red1:\n  \"if_mbisim_Red1'_Red1 s1 s2 \\<Longrightarrow> mbisim_Red1'_Red1 (init_fin_descend_state s1) (init_fin_descend_state s2)\"", "lemma if_Red1_mthr_imp_if_Red1_mthr':\n  assumes lok: \"if_lock_oks1 (locks s) (thr s)\"\n  and elo: \"ts_ok (init_fin_lift (\\<lambda>t exexs h. el_loc_ok1 exexs)) (thr s) (shr s)\"\n  and Red: \"Red1_mthr.if.redT uf P s tta s'\"\n  shows \"Red1_mthr.if.redT (\\<not> uf) P s tta s'\"", "lemma if_Red1_mthr_eq_if_Red1_mthr':\n  assumes lok: \"if_lock_oks1 (locks s) (thr s)\"\n  and elo: \"ts_ok (init_fin_lift (\\<lambda>t exexs h. el_loc_ok1 exexs)) (thr s) (shr s)\"\n  shows \"Red1_mthr.if.redT True P s = Red1_mthr.if.redT False P s\"", "lemma if_Red1_el_loc_ok: \n  assumes wf: \"wf_J1_prog P\"\n  shows \"lifting_wf Red1_mthr.init_fin_final (Red1_mthr.init_fin uf P) (init_fin_lift (\\<lambda>t exexs h. el_loc_ok1 exexs))\"", "lemma if_Red1'_preserves_if_lock_oks:\n  assumes wf: \"wf_J1_prog P\"\n  and Red: \"Red1_mthr.if.redT False P s1 ta1 s1'\"\n  and loks: \"if_lock_oks1 (locks s1) (thr s1)\"\n  and sync: \"ts_ok (init_fin_lift (\\<lambda>t exexs h. el_loc_ok1 exexs)) (thr s1) (shr s1)\"\n  shows \"if_lock_oks1 (locks s1') (thr s1')\"", "lemma Red1'_Red1_if_bisimulation:\n  assumes wf: \"wf_J1_prog P\"\n  shows \"bisimulation (Red1_mthr.if.redT False P) (Red1_mthr.if.redT True P) if_mbisim_Red1'_Red1 (=)\"", "lemma if_bisim_J1_J1_start:\n  assumes wf: \"wf_J1_prog P\"\n  and wf_start: \"wf_start_state P C M vs\"\n  shows \"if_mbisim_Red1'_Red1 (init_fin_lift_state status (J1_start_state P C M vs)) (init_fin_lift_state status (J1_start_state P C M vs))\"", "lemma if_Red1'_Red1_bisim_into_weak:\n  assumes wf: \"wf_J1_prog P\"\n  shows \"bisimulation_into_delay (Red1_mthr.if.redT False P) (Red1_mthr.if.redT True P) if_mbisim_Red1'_Red1 (=) (Red1_mthr.if.m\\<tau>move P) (Red1_mthr.if.m\\<tau>move P)\"", "lemma if_Red1'_Red1_bisimulation_final:\n  \"wf_J1_prog P \n  \\<Longrightarrow> bisimulation_final (Red1_mthr.if.redT False P) (Red1_mthr.if.redT True P) \n       if_mbisim_Red1'_Red1 (=) Red1_mthr.if.mfinal Red1_mthr.if.mfinal\""], "translations": [["", "lemma el_loc_okI: \"\\<lbrakk> \\<not> contains_insync e; syncvars e; \\<B> e n \\<rbrakk> \\<Longrightarrow> el_loc_ok e xs\"\n  and els_loc_okI: \"\\<lbrakk> \\<not> contains_insyncs es; syncvarss es; \\<B>s es n \\<rbrakk> \\<Longrightarrow> els_loc_ok es xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<not> contains_insync e; syncvars e; \\<B> e n\\<rbrakk>\n     \\<Longrightarrow> el_loc_ok e xs) &&&\n    (\\<lbrakk>\\<not> contains_insyncs es; syncvarss es; \\<B>s es n\\<rbrakk>\n     \\<Longrightarrow> els_loc_ok es xs)", "by(induct e and es arbitrary: xs n and xs n rule: el_loc_ok.induct els_loc_ok.induct)(auto intro: fv_B_unmod)"], ["", "lemma el_loc_ok_compE1: \"\\<lbrakk> \\<not> contains_insync e; fv e \\<subseteq> set Vs \\<rbrakk> \\<Longrightarrow> el_loc_ok (compE1 Vs e) xs\"\n  and els_loc_ok_compEs1: \"\\<lbrakk> \\<not> contains_insyncs es; fvs es \\<subseteq> set Vs \\<rbrakk> \\<Longrightarrow> els_loc_ok (compEs1 Vs es) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<not> contains_insync e; fv e \\<subseteq> set Vs\\<rbrakk>\n     \\<Longrightarrow> el_loc_ok (compE1 Vs e) xs) &&&\n    (\\<lbrakk>\\<not> contains_insyncs es; fvs es \\<subseteq> set Vs\\<rbrakk>\n     \\<Longrightarrow> els_loc_ok (compEs1 Vs es) xs)", "by(auto intro: el_loc_okI els_loc_okI syncvars_compE1 syncvarss_compEs1 \\<B> \\<B>s simp del: compEs1_conv_map)"], ["", "lemma shows el_loc_ok_not_contains_insync_local_change:\n  \"\\<lbrakk> \\<not> contains_insync e; el_loc_ok e xs \\<rbrakk> \\<Longrightarrow> el_loc_ok e xs'\"\n  and els_loc_ok_not_contains_insyncs_local_change:\n  \"\\<lbrakk> \\<not> contains_insyncs es; els_loc_ok es xs \\<rbrakk> \\<Longrightarrow> els_loc_ok es xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<not> contains_insync e; el_loc_ok e xs\\<rbrakk>\n     \\<Longrightarrow> el_loc_ok e xs') &&&\n    (\\<lbrakk>\\<not> contains_insyncs es; els_loc_ok es xs\\<rbrakk>\n     \\<Longrightarrow> els_loc_ok es xs')", "by(induct e and es arbitrary: xs xs' and xs xs' rule: el_loc_ok.induct els_loc_ok.induct)(fastforce)+"], ["", "lemma el_loc_ok_update: \"\\<lbrakk> \\<B> e n; V < n \\<rbrakk> \\<Longrightarrow> el_loc_ok e (xs[V := v]) = el_loc_ok e xs\"\n  and els_loc_ok_update: \"\\<lbrakk> \\<B>s es n; V < n \\<rbrakk> \\<Longrightarrow> els_loc_ok es (xs[V := v]) = els_loc_ok es xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<B> e n; V < n\\<rbrakk>\n     \\<Longrightarrow> el_loc_ok e (xs[V := v]) = el_loc_ok e xs) &&&\n    (\\<lbrakk>\\<B>s es n; V < n\\<rbrakk>\n     \\<Longrightarrow> els_loc_ok es (xs[V := v]) = els_loc_ok es xs)", "apply(induct e and es arbitrary: n xs and n xs rule: el_loc_ok.induct els_loc_ok.induct)"], ["proof (prove)\ngoal (25 subgoals):\n 1. \\<And>x n xs.\n       \\<lbrakk>\\<B> (new x) n; V < n\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (new x) (xs[V := v]) =\n                         el_loc_ok (new x) xs\n 2. \\<And>x1 x2 n xs.\n       \\<lbrakk>\\<And>n xs.\n                   \\<lbrakk>\\<B> x2 n; V < n\\<rbrakk>\n                   \\<Longrightarrow> el_loc_ok x2 (xs[V := v]) =\n                                     el_loc_ok x2 xs;\n        \\<B> (newA x1\\<lfloor>x2\\<rceil>) n; V < n\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (newA x1\\<lfloor>x2\\<rceil>)\n                          (xs[V := v]) =\n                         el_loc_ok (newA x1\\<lfloor>x2\\<rceil>) xs\n 3. \\<And>x1 x2 n xs.\n       \\<lbrakk>\\<And>n xs.\n                   \\<lbrakk>\\<B> x2 n; V < n\\<rbrakk>\n                   \\<Longrightarrow> el_loc_ok x2 (xs[V := v]) =\n                                     el_loc_ok x2 xs;\n        \\<B> (Cast x1 x2) n; V < n\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Cast x1 x2) (xs[V := v]) =\n                         el_loc_ok (Cast x1 x2) xs\n 4. \\<And>x1 x2 n xs.\n       \\<lbrakk>\\<And>n xs.\n                   \\<lbrakk>\\<B> x1 n; V < n\\<rbrakk>\n                   \\<Longrightarrow> el_loc_ok x1 (xs[V := v]) =\n                                     el_loc_ok x1 xs;\n        \\<B> (x1 instanceof x2) n; V < n\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (x1 instanceof x2) (xs[V := v]) =\n                         el_loc_ok (x1 instanceof x2) xs\n 5. \\<And>x n xs.\n       \\<lbrakk>\\<B> (Val x) n; V < n\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Val x) (xs[V := v]) =\n                         el_loc_ok (Val x) xs\n 6. \\<And>x1 x2 x3 n xs.\n       \\<lbrakk>\\<And>n xs.\n                   \\<lbrakk>\\<B> x1 n; V < n\\<rbrakk>\n                   \\<Longrightarrow> el_loc_ok x1 (xs[V := v]) =\n                                     el_loc_ok x1 xs;\n        \\<And>n xs.\n           \\<lbrakk>\\<B> x3 n; V < n\\<rbrakk>\n           \\<Longrightarrow> el_loc_ok x3 (xs[V := v]) = el_loc_ok x3 xs;\n        \\<B> (x1 \\<guillemotleft>x2\\<guillemotright> x3) n; V < n\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok\n                          (x1 \\<guillemotleft>x2\\<guillemotright> x3)\n                          (xs[V := v]) =\n                         el_loc_ok\n                          (x1 \\<guillemotleft>x2\\<guillemotright> x3) xs\n 7. \\<And>x n xs.\n       \\<lbrakk>\\<B> (Var x) n; V < n\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Var x) (xs[V := v]) =\n                         el_loc_ok (Var x) xs\n 8. \\<And>x1 x2 n xs.\n       \\<lbrakk>\\<And>n xs.\n                   \\<lbrakk>\\<B> x2 n; V < n\\<rbrakk>\n                   \\<Longrightarrow> el_loc_ok x2 (xs[V := v]) =\n                                     el_loc_ok x2 xs;\n        \\<B> (x1:=x2) n; V < n\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (x1:=x2) (xs[V := v]) =\n                         el_loc_ok (x1:=x2) xs\n 9. \\<And>x1 x2 n xs.\n       \\<lbrakk>\\<And>n xs.\n                   \\<lbrakk>\\<B> x1 n; V < n\\<rbrakk>\n                   \\<Longrightarrow> el_loc_ok x1 (xs[V := v]) =\n                                     el_loc_ok x1 xs;\n        \\<And>n xs.\n           \\<lbrakk>\\<B> x2 n; V < n\\<rbrakk>\n           \\<Longrightarrow> el_loc_ok x2 (xs[V := v]) = el_loc_ok x2 xs;\n        \\<B> (x1\\<lfloor>x2\\<rceil>) n; V < n\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (x1\\<lfloor>x2\\<rceil>) (xs[V := v]) =\n                         el_loc_ok (x1\\<lfloor>x2\\<rceil>) xs\n 10. \\<And>x1 x2 x3 n xs.\n        \\<lbrakk>\\<And>n xs.\n                    \\<lbrakk>\\<B> x1 n; V < n\\<rbrakk>\n                    \\<Longrightarrow> el_loc_ok x1 (xs[V := v]) =\nel_loc_ok x1 xs;\n         \\<And>n xs.\n            \\<lbrakk>\\<B> x2 n; V < n\\<rbrakk>\n            \\<Longrightarrow> el_loc_ok x2 (xs[V := v]) = el_loc_ok x2 xs;\n         \\<And>n xs.\n            \\<lbrakk>\\<B> x3 n; V < n\\<rbrakk>\n            \\<Longrightarrow> el_loc_ok x3 (xs[V := v]) = el_loc_ok x3 xs;\n         \\<B> (x1\\<lfloor>x2\\<rceil> := x3) n; V < n\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok (x1\\<lfloor>x2\\<rceil> := x3)\n                           (xs[V := v]) =\n                          el_loc_ok (x1\\<lfloor>x2\\<rceil> := x3) xs\nA total of 25 subgoals...", "apply(auto simp add: list_update_swap)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma els_loc_ok_map_Val [simp]:\n  \"els_loc_ok (map Val vs) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. els_loc_ok (map Val vs) xs", "by(induct vs) auto"], ["", "lemma els_loc_ok_map_Val_append [simp]:\n  \"els_loc_ok (map Val vs @ es) xs = els_loc_ok es xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. els_loc_ok (map Val vs @ es) xs = els_loc_ok es xs", "by(induct vs) auto"], ["", "lemma el_loc_ok_extRet2J [simp]:\n  \"el_loc_ok e xs \\<Longrightarrow> el_loc_ok (extRet2J e va) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. el_loc_ok e xs \\<Longrightarrow> el_loc_ok (extRet2J e va) xs", "by(cases va) auto"], ["", "definition el_loc_ok1 :: \"((nat, nat, 'addr) exp \\<times> 'addr locals1) \\<times> ((nat, nat, 'addr) exp \\<times> 'addr locals1) list \\<Rightarrow> bool\"\n  where \"el_loc_ok1 = (\\<lambda>((e, xs), exs). el_loc_ok e xs \\<and> sync_ok e \\<and> (\\<forall>(e,xs)\\<in>set exs. el_loc_ok e xs \\<and> sync_ok e))\""], ["", "lemma el_loc_ok1_simps:\n  \"el_loc_ok1 ((e, xs), exs) = (el_loc_ok e xs \\<and> sync_ok e \\<and> (\\<forall>(e,xs)\\<in>set exs. el_loc_ok e xs \\<and> sync_ok e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. el_loc_ok1 ((e, xs), exs) =\n    (el_loc_ok e xs \\<and>\n     sync_ok e \\<and>\n     (\\<forall>(e, xs)\\<in>set exs. el_loc_ok e xs \\<and> sync_ok e))", "by(simp add: el_loc_ok1_def)"], ["", "lemma el_loc_ok_blocks1 [simp]:\n   \"el_loc_ok (blocks1 n Ts body) xs = el_loc_ok body xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. el_loc_ok (blocks1 n Ts body) xs = el_loc_ok body xs", "by(induct n Ts body rule: blocks1.induct) auto"], ["", "lemma sync_oks_blocks1 [simp]: \"sync_ok (blocks1 n Ts e) = sync_ok e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sync_ok (blocks1 n Ts e) = sync_ok e", "by(induct n Ts e rule: blocks1.induct) auto"], ["", "lemma assumes fin: \"final e'\"\n  shows el_loc_ok_inline_call: \"el_loc_ok e xs \\<Longrightarrow> el_loc_ok (inline_call e' e) xs\"\n  and els_loc_ok_inline_calls: \"els_loc_ok es xs \\<Longrightarrow> els_loc_ok (inline_calls e' es) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (el_loc_ok e xs \\<Longrightarrow> el_loc_ok (inline_call e' e) xs) &&&\n    (els_loc_ok es xs \\<Longrightarrow> els_loc_ok (inline_calls e' es) xs)", "apply(induct e and es arbitrary: xs and xs rule: el_loc_ok.induct els_loc_ok.induct)"], ["proof (prove)\ngoal (25 subgoals):\n 1. \\<And>x xs.\n       el_loc_ok (new x) xs \\<Longrightarrow>\n       el_loc_ok (inline_call e' (new x)) xs\n 2. \\<And>x1 x2 xs.\n       \\<lbrakk>\\<And>xs.\n                   el_loc_ok x2 xs \\<Longrightarrow>\n                   el_loc_ok (inline_call e' x2) xs;\n        el_loc_ok (newA x1\\<lfloor>x2\\<rceil>) xs\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok\n                          (inline_call e' (newA x1\\<lfloor>x2\\<rceil>)) xs\n 3. \\<And>x1 x2 xs.\n       \\<lbrakk>\\<And>xs.\n                   el_loc_ok x2 xs \\<Longrightarrow>\n                   el_loc_ok (inline_call e' x2) xs;\n        el_loc_ok (Cast x1 x2) xs\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (inline_call e' (Cast x1 x2)) xs\n 4. \\<And>x1 x2 xs.\n       \\<lbrakk>\\<And>xs.\n                   el_loc_ok x1 xs \\<Longrightarrow>\n                   el_loc_ok (inline_call e' x1) xs;\n        el_loc_ok (x1 instanceof x2) xs\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (inline_call e' (x1 instanceof x2)) xs\n 5. \\<And>x xs.\n       el_loc_ok (Val x) xs \\<Longrightarrow>\n       el_loc_ok (inline_call e' (Val x)) xs\n 6. \\<And>x1 x2 x3 xs.\n       \\<lbrakk>\\<And>xs.\n                   el_loc_ok x1 xs \\<Longrightarrow>\n                   el_loc_ok (inline_call e' x1) xs;\n        \\<And>xs.\n           el_loc_ok x3 xs \\<Longrightarrow>\n           el_loc_ok (inline_call e' x3) xs;\n        el_loc_ok (x1 \\<guillemotleft>x2\\<guillemotright> x3) xs\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok\n                          (inline_call e'\n                            (x1 \\<guillemotleft>x2\\<guillemotright> x3))\n                          xs\n 7. \\<And>x xs.\n       el_loc_ok (Var x) xs \\<Longrightarrow>\n       el_loc_ok (inline_call e' (Var x)) xs\n 8. \\<And>x1 x2 xs.\n       \\<lbrakk>\\<And>xs.\n                   el_loc_ok x2 xs \\<Longrightarrow>\n                   el_loc_ok (inline_call e' x2) xs;\n        el_loc_ok (x1:=x2) xs\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (inline_call e' (x1:=x2)) xs\n 9. \\<And>x1 x2 xs.\n       \\<lbrakk>\\<And>xs.\n                   el_loc_ok x1 xs \\<Longrightarrow>\n                   el_loc_ok (inline_call e' x1) xs;\n        \\<And>xs.\n           el_loc_ok x2 xs \\<Longrightarrow>\n           el_loc_ok (inline_call e' x2) xs;\n        el_loc_ok (x1\\<lfloor>x2\\<rceil>) xs\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (inline_call e' (x1\\<lfloor>x2\\<rceil>))\n                          xs\n 10. \\<And>x1 x2 x3 xs.\n        \\<lbrakk>\\<And>xs.\n                    el_loc_ok x1 xs \\<Longrightarrow>\n                    el_loc_ok (inline_call e' x1) xs;\n         \\<And>xs.\n            el_loc_ok x2 xs \\<Longrightarrow>\n            el_loc_ok (inline_call e' x2) xs;\n         \\<And>xs.\n            el_loc_ok x3 xs \\<Longrightarrow>\n            el_loc_ok (inline_call e' x3) xs;\n         el_loc_ok (x1\\<lfloor>x2\\<rceil> := x3) xs\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok\n                           (inline_call e' (x1\\<lfloor>x2\\<rceil> := x3)) xs\nA total of 25 subgoals...", "apply(insert fin)"], ["proof (prove)\ngoal (25 subgoals):\n 1. \\<And>x xs.\n       \\<lbrakk>el_loc_ok (new x) xs; final e'\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (inline_call e' (new x)) xs\n 2. \\<And>x1 x2 xs.\n       \\<lbrakk>\\<And>xs.\n                   el_loc_ok x2 xs \\<Longrightarrow>\n                   el_loc_ok (inline_call e' x2) xs;\n        el_loc_ok (newA x1\\<lfloor>x2\\<rceil>) xs; final e'\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok\n                          (inline_call e' (newA x1\\<lfloor>x2\\<rceil>)) xs\n 3. \\<And>x1 x2 xs.\n       \\<lbrakk>\\<And>xs.\n                   el_loc_ok x2 xs \\<Longrightarrow>\n                   el_loc_ok (inline_call e' x2) xs;\n        el_loc_ok (Cast x1 x2) xs; final e'\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (inline_call e' (Cast x1 x2)) xs\n 4. \\<And>x1 x2 xs.\n       \\<lbrakk>\\<And>xs.\n                   el_loc_ok x1 xs \\<Longrightarrow>\n                   el_loc_ok (inline_call e' x1) xs;\n        el_loc_ok (x1 instanceof x2) xs; final e'\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (inline_call e' (x1 instanceof x2)) xs\n 5. \\<And>x xs.\n       \\<lbrakk>el_loc_ok (Val x) xs; final e'\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (inline_call e' (Val x)) xs\n 6. \\<And>x1 x2 x3 xs.\n       \\<lbrakk>\\<And>xs.\n                   el_loc_ok x1 xs \\<Longrightarrow>\n                   el_loc_ok (inline_call e' x1) xs;\n        \\<And>xs.\n           el_loc_ok x3 xs \\<Longrightarrow>\n           el_loc_ok (inline_call e' x3) xs;\n        el_loc_ok (x1 \\<guillemotleft>x2\\<guillemotright> x3) xs;\n        final e'\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok\n                          (inline_call e'\n                            (x1 \\<guillemotleft>x2\\<guillemotright> x3))\n                          xs\n 7. \\<And>x xs.\n       \\<lbrakk>el_loc_ok (Var x) xs; final e'\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (inline_call e' (Var x)) xs\n 8. \\<And>x1 x2 xs.\n       \\<lbrakk>\\<And>xs.\n                   el_loc_ok x2 xs \\<Longrightarrow>\n                   el_loc_ok (inline_call e' x2) xs;\n        el_loc_ok (x1:=x2) xs; final e'\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (inline_call e' (x1:=x2)) xs\n 9. \\<And>x1 x2 xs.\n       \\<lbrakk>\\<And>xs.\n                   el_loc_ok x1 xs \\<Longrightarrow>\n                   el_loc_ok (inline_call e' x1) xs;\n        \\<And>xs.\n           el_loc_ok x2 xs \\<Longrightarrow>\n           el_loc_ok (inline_call e' x2) xs;\n        el_loc_ok (x1\\<lfloor>x2\\<rceil>) xs; final e'\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (inline_call e' (x1\\<lfloor>x2\\<rceil>))\n                          xs\n 10. \\<And>x1 x2 x3 xs.\n        \\<lbrakk>\\<And>xs.\n                    el_loc_ok x1 xs \\<Longrightarrow>\n                    el_loc_ok (inline_call e' x1) xs;\n         \\<And>xs.\n            el_loc_ok x2 xs \\<Longrightarrow>\n            el_loc_ok (inline_call e' x2) xs;\n         \\<And>xs.\n            el_loc_ok x3 xs \\<Longrightarrow>\n            el_loc_ok (inline_call e' x3) xs;\n         el_loc_ok (x1\\<lfloor>x2\\<rceil> := x3) xs; final e'\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok\n                           (inline_call e' (x1\\<lfloor>x2\\<rceil> := x3)) xs\nA total of 25 subgoals...", "apply(auto simp add: unmod_inline_call)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma assumes \"sync_ok e'\"\n  shows sync_ok_inline_call: \"sync_ok e \\<Longrightarrow> sync_ok (inline_call e' e)\"\n  and sync_oks_inline_calls: \"sync_oks es \\<Longrightarrow> sync_oks (inline_calls e' es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sync_ok e \\<Longrightarrow> sync_ok (inline_call e' e)) &&&\n    (sync_oks es \\<Longrightarrow> sync_oks (inline_calls e' es))", "apply(induct e and es rule: sync_ok.induct sync_oks.induct)"], ["proof (prove)\ngoal (25 subgoals):\n 1. \\<And>x.\n       sync_ok (new x) \\<Longrightarrow> sync_ok (inline_call e' (new x))\n 2. \\<And>x1 x2.\n       \\<lbrakk>sync_ok x2 \\<Longrightarrow> sync_ok (inline_call e' x2);\n        sync_ok (newA x1\\<lfloor>x2\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> sync_ok\n                          (inline_call e' (newA x1\\<lfloor>x2\\<rceil>))\n 3. \\<And>x1 x2.\n       \\<lbrakk>sync_ok x2 \\<Longrightarrow> sync_ok (inline_call e' x2);\n        sync_ok (Cast x1 x2)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (inline_call e' (Cast x1 x2))\n 4. \\<And>x1 x2.\n       \\<lbrakk>sync_ok x1 \\<Longrightarrow> sync_ok (inline_call e' x1);\n        sync_ok (x1 instanceof x2)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (inline_call e' (x1 instanceof x2))\n 5. \\<And>x.\n       sync_ok (Val x) \\<Longrightarrow> sync_ok (inline_call e' (Val x))\n 6. \\<And>x1 x2 x3.\n       \\<lbrakk>sync_ok x1 \\<Longrightarrow> sync_ok (inline_call e' x1);\n        sync_ok x3 \\<Longrightarrow> sync_ok (inline_call e' x3);\n        sync_ok (x1 \\<guillemotleft>x2\\<guillemotright> x3)\\<rbrakk>\n       \\<Longrightarrow> sync_ok\n                          (inline_call e'\n                            (x1 \\<guillemotleft>x2\\<guillemotright> x3))\n 7. \\<And>x.\n       sync_ok (Var x) \\<Longrightarrow> sync_ok (inline_call e' (Var x))\n 8. \\<And>x1 x2.\n       \\<lbrakk>sync_ok x2 \\<Longrightarrow> sync_ok (inline_call e' x2);\n        sync_ok (x1:=x2)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (inline_call e' (x1:=x2))\n 9. \\<And>x1 x2.\n       \\<lbrakk>sync_ok x1 \\<Longrightarrow> sync_ok (inline_call e' x1);\n        sync_ok x2 \\<Longrightarrow> sync_ok (inline_call e' x2);\n        sync_ok (x1\\<lfloor>x2\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> sync_ok (inline_call e' (x1\\<lfloor>x2\\<rceil>))\n 10. \\<And>x1 x2 x3.\n        \\<lbrakk>sync_ok x1 \\<Longrightarrow> sync_ok (inline_call e' x1);\n         sync_ok x2 \\<Longrightarrow> sync_ok (inline_call e' x2);\n         sync_ok x3 \\<Longrightarrow> sync_ok (inline_call e' x3);\n         sync_ok (x1\\<lfloor>x2\\<rceil> := x3)\\<rbrakk>\n        \\<Longrightarrow> sync_ok\n                           (inline_call e' (x1\\<lfloor>x2\\<rceil> := x3))\nA total of 25 subgoals...", "apply(insert \\<open>sync_ok e'\\<close>)"], ["proof (prove)\ngoal (25 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sync_ok (new x); sync_ok e'\\<rbrakk>\n       \\<Longrightarrow> sync_ok (inline_call e' (new x))\n 2. \\<And>x1 x2.\n       \\<lbrakk>sync_ok x2 \\<Longrightarrow> sync_ok (inline_call e' x2);\n        sync_ok (newA x1\\<lfloor>x2\\<rceil>); sync_ok e'\\<rbrakk>\n       \\<Longrightarrow> sync_ok\n                          (inline_call e' (newA x1\\<lfloor>x2\\<rceil>))\n 3. \\<And>x1 x2.\n       \\<lbrakk>sync_ok x2 \\<Longrightarrow> sync_ok (inline_call e' x2);\n        sync_ok (Cast x1 x2); sync_ok e'\\<rbrakk>\n       \\<Longrightarrow> sync_ok (inline_call e' (Cast x1 x2))\n 4. \\<And>x1 x2.\n       \\<lbrakk>sync_ok x1 \\<Longrightarrow> sync_ok (inline_call e' x1);\n        sync_ok (x1 instanceof x2); sync_ok e'\\<rbrakk>\n       \\<Longrightarrow> sync_ok (inline_call e' (x1 instanceof x2))\n 5. \\<And>x.\n       \\<lbrakk>sync_ok (Val x); sync_ok e'\\<rbrakk>\n       \\<Longrightarrow> sync_ok (inline_call e' (Val x))\n 6. \\<And>x1 x2 x3.\n       \\<lbrakk>sync_ok x1 \\<Longrightarrow> sync_ok (inline_call e' x1);\n        sync_ok x3 \\<Longrightarrow> sync_ok (inline_call e' x3);\n        sync_ok (x1 \\<guillemotleft>x2\\<guillemotright> x3);\n        sync_ok e'\\<rbrakk>\n       \\<Longrightarrow> sync_ok\n                          (inline_call e'\n                            (x1 \\<guillemotleft>x2\\<guillemotright> x3))\n 7. \\<And>x.\n       \\<lbrakk>sync_ok (Var x); sync_ok e'\\<rbrakk>\n       \\<Longrightarrow> sync_ok (inline_call e' (Var x))\n 8. \\<And>x1 x2.\n       \\<lbrakk>sync_ok x2 \\<Longrightarrow> sync_ok (inline_call e' x2);\n        sync_ok (x1:=x2); sync_ok e'\\<rbrakk>\n       \\<Longrightarrow> sync_ok (inline_call e' (x1:=x2))\n 9. \\<And>x1 x2.\n       \\<lbrakk>sync_ok x1 \\<Longrightarrow> sync_ok (inline_call e' x1);\n        sync_ok x2 \\<Longrightarrow> sync_ok (inline_call e' x2);\n        sync_ok (x1\\<lfloor>x2\\<rceil>); sync_ok e'\\<rbrakk>\n       \\<Longrightarrow> sync_ok (inline_call e' (x1\\<lfloor>x2\\<rceil>))\n 10. \\<And>x1 x2 x3.\n        \\<lbrakk>sync_ok x1 \\<Longrightarrow> sync_ok (inline_call e' x1);\n         sync_ok x2 \\<Longrightarrow> sync_ok (inline_call e' x2);\n         sync_ok x3 \\<Longrightarrow> sync_ok (inline_call e' x3);\n         sync_ok (x1\\<lfloor>x2\\<rceil> := x3); sync_ok e'\\<rbrakk>\n        \\<Longrightarrow> sync_ok\n                           (inline_call e' (x1\\<lfloor>x2\\<rceil> := x3))\nA total of 25 subgoals...", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bisim_sync_ok:\n  \"bisim Vs e e' xs \\<Longrightarrow> sync_ok e\"\n  \"bisim Vs e e' xs \\<Longrightarrow> sync_ok e'\"\n\n  and bisims_sync_oks:\n  \"bisims Vs es es' xs \\<Longrightarrow> sync_oks es\"\n  \"bisims Vs es es' xs \\<Longrightarrow> sync_oks es'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((bisim Vs e e' xs \\<Longrightarrow> sync_ok e) &&&\n     (bisim Vs e e' xs \\<Longrightarrow> sync_ok e')) &&&\n    (bisims Vs es es' xs \\<Longrightarrow> sync_oks es) &&&\n    (bisims Vs es es' xs \\<Longrightarrow> sync_oks es')", "apply(induct rule: bisim_bisims.inducts)"], ["proof (prove)\ngoal (72 subgoals):\n 1. \\<And>Vs C xs. sync_ok (new C)\n 2. \\<And>Vs C xs. sync_ok (new C)\n 3. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs; sync_ok e; sync_ok e'\\<rbrakk>\n       \\<Longrightarrow> sync_ok (newA T\\<lfloor>e\\<rceil>)\n 4. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs; sync_ok e; sync_ok e'\\<rbrakk>\n       \\<Longrightarrow> sync_ok (newA T\\<lfloor>e'\\<rceil>)\n 5. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs; sync_ok e; sync_ok e'\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Cast T e)\n 6. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs; sync_ok e; sync_ok e'\\<rbrakk>\n       \\<Longrightarrow> sync_ok (Cast T e')\n 7. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs; sync_ok e; sync_ok e'\\<rbrakk>\n       \\<Longrightarrow> sync_ok (e instanceof T)\n 8. \\<And>Vs e e' xs T.\n       \\<lbrakk>bisim Vs e e' xs; sync_ok e; sync_ok e'\\<rbrakk>\n       \\<Longrightarrow> sync_ok (e' instanceof T)\n 9. \\<And>Vs v xs. sync_ok (Val v)\n 10. \\<And>Vs v xs. sync_ok (Val v)\nA total of 72 subgoals...", "apply(auto intro: not_contains_insync_sync_ok not_contains_insyncs_sync_oks simp del: compEs1_conv_map)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma assumes \"final e'\"\n  shows expr_locks_inline_call_final:\n  \"expr_locks (inline_call e' e) = expr_locks e\"\n  and expr_lockss_inline_calls_final:\n  \"expr_lockss (inline_calls e' es) = expr_lockss es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expr_locks (inline_call e' e) = expr_locks e &&&\n    expr_lockss (inline_calls e' es) = expr_lockss es", "apply(induct e and es rule: expr_locks.induct expr_lockss.induct)"], ["proof (prove)\ngoal (25 subgoals):\n 1. \\<And>x. expr_locks (inline_call e' (new x)) = expr_locks (new x)\n 2. \\<And>x1 x2.\n       expr_locks (inline_call e' x2) = expr_locks x2 \\<Longrightarrow>\n       expr_locks (inline_call e' (newA x1\\<lfloor>x2\\<rceil>)) =\n       expr_locks (newA x1\\<lfloor>x2\\<rceil>)\n 3. \\<And>x1 x2.\n       expr_locks (inline_call e' x2) = expr_locks x2 \\<Longrightarrow>\n       expr_locks (inline_call e' (Cast x1 x2)) = expr_locks (Cast x1 x2)\n 4. \\<And>x1 x2.\n       expr_locks (inline_call e' x1) = expr_locks x1 \\<Longrightarrow>\n       expr_locks (inline_call e' (x1 instanceof x2)) =\n       expr_locks (x1 instanceof x2)\n 5. \\<And>x. expr_locks (inline_call e' (Val x)) = expr_locks (Val x)\n 6. \\<And>x1 x2 x3.\n       \\<lbrakk>expr_locks (inline_call e' x1) = expr_locks x1;\n        expr_locks (inline_call e' x3) = expr_locks x3\\<rbrakk>\n       \\<Longrightarrow> expr_locks\n                          (inline_call e'\n                            (x1 \\<guillemotleft>x2\\<guillemotright> x3)) =\n                         expr_locks\n                          (x1 \\<guillemotleft>x2\\<guillemotright> x3)\n 7. \\<And>x. expr_locks (inline_call e' (Var x)) = expr_locks (Var x)\n 8. \\<And>x1 x2.\n       expr_locks (inline_call e' x2) = expr_locks x2 \\<Longrightarrow>\n       expr_locks (inline_call e' (x1:=x2)) = expr_locks (x1:=x2)\n 9. \\<And>x1 x2.\n       \\<lbrakk>expr_locks (inline_call e' x1) = expr_locks x1;\n        expr_locks (inline_call e' x2) = expr_locks x2\\<rbrakk>\n       \\<Longrightarrow> expr_locks\n                          (inline_call e' (x1\\<lfloor>x2\\<rceil>)) =\n                         expr_locks (x1\\<lfloor>x2\\<rceil>)\n 10. \\<And>x1 x2 x3.\n        \\<lbrakk>expr_locks (inline_call e' x1) = expr_locks x1;\n         expr_locks (inline_call e' x2) = expr_locks x2;\n         expr_locks (inline_call e' x3) = expr_locks x3\\<rbrakk>\n        \\<Longrightarrow> expr_locks\n                           (inline_call e' (x1\\<lfloor>x2\\<rceil> := x3)) =\n                          expr_locks (x1\\<lfloor>x2\\<rceil> := x3)\nA total of 25 subgoals...", "apply(insert \\<open>final e'\\<close>)"], ["proof (prove)\ngoal (25 subgoals):\n 1. \\<And>x.\n       final e' \\<Longrightarrow>\n       expr_locks (inline_call e' (new x)) = expr_locks (new x)\n 2. \\<And>x1 x2.\n       \\<lbrakk>expr_locks (inline_call e' x2) = expr_locks x2;\n        final e'\\<rbrakk>\n       \\<Longrightarrow> expr_locks\n                          (inline_call e' (newA x1\\<lfloor>x2\\<rceil>)) =\n                         expr_locks (newA x1\\<lfloor>x2\\<rceil>)\n 3. \\<And>x1 x2.\n       \\<lbrakk>expr_locks (inline_call e' x2) = expr_locks x2;\n        final e'\\<rbrakk>\n       \\<Longrightarrow> expr_locks (inline_call e' (Cast x1 x2)) =\n                         expr_locks (Cast x1 x2)\n 4. \\<And>x1 x2.\n       \\<lbrakk>expr_locks (inline_call e' x1) = expr_locks x1;\n        final e'\\<rbrakk>\n       \\<Longrightarrow> expr_locks (inline_call e' (x1 instanceof x2)) =\n                         expr_locks (x1 instanceof x2)\n 5. \\<And>x.\n       final e' \\<Longrightarrow>\n       expr_locks (inline_call e' (Val x)) = expr_locks (Val x)\n 6. \\<And>x1 x2 x3.\n       \\<lbrakk>expr_locks (inline_call e' x1) = expr_locks x1;\n        expr_locks (inline_call e' x3) = expr_locks x3; final e'\\<rbrakk>\n       \\<Longrightarrow> expr_locks\n                          (inline_call e'\n                            (x1 \\<guillemotleft>x2\\<guillemotright> x3)) =\n                         expr_locks\n                          (x1 \\<guillemotleft>x2\\<guillemotright> x3)\n 7. \\<And>x.\n       final e' \\<Longrightarrow>\n       expr_locks (inline_call e' (Var x)) = expr_locks (Var x)\n 8. \\<And>x1 x2.\n       \\<lbrakk>expr_locks (inline_call e' x2) = expr_locks x2;\n        final e'\\<rbrakk>\n       \\<Longrightarrow> expr_locks (inline_call e' (x1:=x2)) =\n                         expr_locks (x1:=x2)\n 9. \\<And>x1 x2.\n       \\<lbrakk>expr_locks (inline_call e' x1) = expr_locks x1;\n        expr_locks (inline_call e' x2) = expr_locks x2; final e'\\<rbrakk>\n       \\<Longrightarrow> expr_locks\n                          (inline_call e' (x1\\<lfloor>x2\\<rceil>)) =\n                         expr_locks (x1\\<lfloor>x2\\<rceil>)\n 10. \\<And>x1 x2 x3.\n        \\<lbrakk>expr_locks (inline_call e' x1) = expr_locks x1;\n         expr_locks (inline_call e' x2) = expr_locks x2;\n         expr_locks (inline_call e' x3) = expr_locks x3; final e'\\<rbrakk>\n        \\<Longrightarrow> expr_locks\n                           (inline_call e' (x1\\<lfloor>x2\\<rceil> := x3)) =\n                          expr_locks (x1\\<lfloor>x2\\<rceil> := x3)\nA total of 25 subgoals...", "apply(auto simp add: is_vals_conv intro: ext)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lock_oks1I:\n  \"\\<lbrakk> \\<And>t l. ts t = None \\<Longrightarrow> has_locks (ls $ l) t = 0;\n     \\<And>t e x exs ln l. ts t = \\<lfloor>(((e, x), exs), ln)\\<rfloor> \\<Longrightarrow> has_locks (ls $ l) t + ln $ l= expr_locks e l + expr_lockss (map fst exs) l \\<rbrakk>\n  \\<Longrightarrow> lock_oks1 ls ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t l.\n                ts t = None \\<Longrightarrow> has_locks (ls $ l) t = 0;\n     \\<And>t e x exs ln l.\n        ts t = \\<lfloor>(((e, x), exs), ln)\\<rfloor> \\<Longrightarrow>\n        has_locks (ls $ l) t + ln $ l =\n        expr_locks e l + expr_lockss (map fst exs) l\\<rbrakk>\n    \\<Longrightarrow> lock_oks1 ls ts", "apply(fastforce simp add: lock_oks1_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lock_oks1E:\n  \"\\<lbrakk> lock_oks1 ls ts;\n     \\<forall>t. ts t = None \\<longrightarrow> (\\<forall>l. has_locks (ls $ l) t = 0) \\<Longrightarrow> Q;\n     \\<forall>t e x exs ln. ts t = \\<lfloor>(((e, x), exs), ln)\\<rfloor> \\<longrightarrow> (\\<forall>l. has_locks (ls $ l) t + ln $ l = expr_locks e l + expr_lockss (map fst exs) l) \\<Longrightarrow> Q \\<rbrakk>\n  \\<Longrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lock_oks1 ls ts;\n     \\<forall>t.\n        ts t = None \\<longrightarrow>\n        (\\<forall>l. has_locks (ls $ l) t = 0) \\<Longrightarrow>\n     Q;\n     \\<forall>t e x exs ln.\n        ts t = \\<lfloor>(((e, x), exs), ln)\\<rfloor> \\<longrightarrow>\n        (\\<forall>l.\n            has_locks (ls $ l) t + ln $ l =\n            expr_locks e l + expr_lockss (map fst exs) l) \\<Longrightarrow>\n     Q\\<rbrakk>\n    \\<Longrightarrow> Q", "by(fastforce simp add: lock_oks1_def)"], ["", "lemma lock_oks1D1:\n  \"\\<lbrakk> lock_oks1 ls ts; ts t = None \\<rbrakk> \\<Longrightarrow> \\<forall>l. has_locks (ls $ l) t = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lock_oks1 ls ts; ts t = None\\<rbrakk>\n    \\<Longrightarrow> \\<forall>l. has_locks (ls $ l) t = 0", "apply(simp add: lock_oks1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t.\n                ((\\<exists>a b ba bb.\n                     ts t = \\<lfloor>(((a, b), ba), bb)\\<rfloor>) \\<or>\n                 (\\<forall>l. has_locks (ls $ l) t = 0)) \\<and>\n                (\\<forall>a b ba bb.\n                    ts t =\n                    \\<lfloor>(((a, b), ba), bb)\\<rfloor> \\<longrightarrow>\n                    (\\<forall>l.\n                        has_locks (ls $ l) t + bb $ l =\n                        expr_locks a l + expr_lockss (map fst ba) l));\n     ts t = None\\<rbrakk>\n    \\<Longrightarrow> \\<forall>l. has_locks (ls $ l) t = 0", "apply(erule_tac x=\"t\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ts t = None;\n     ((\\<exists>a b ba bb.\n          ts t = \\<lfloor>(((a, b), ba), bb)\\<rfloor>) \\<or>\n      (\\<forall>l. has_locks (ls $ l) t = 0)) \\<and>\n     (\\<forall>a b ba bb.\n         ts t = \\<lfloor>(((a, b), ba), bb)\\<rfloor> \\<longrightarrow>\n         (\\<forall>l.\n             has_locks (ls $ l) t + bb $ l =\n             expr_locks a l + expr_lockss (map fst ba) l))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>l. has_locks (ls $ l) t = 0", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lock_oks1D2:\n  \"\\<And>ln. \\<lbrakk> lock_oks1 ls ts; ts t = \\<lfloor>(((e, x), exs), ln)\\<rfloor> \\<rbrakk> \n  \\<Longrightarrow> \\<forall>l. has_locks (ls $ l) t + ln $ l = expr_locks e l + expr_lockss (map fst exs) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln.\n       \\<lbrakk>lock_oks1 ls ts;\n        ts t = \\<lfloor>(((e, x), exs), ln)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>l.\n                            has_locks (ls $ l) t + ln $ l =\n                            expr_locks e l + expr_lockss (map fst exs) l", "apply(fastforce simp add: lock_oks1_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lock_oks1_thr_updI:\n  \"\\<And>ln. \\<lbrakk> lock_oks1 ls ts; ts t = \\<lfloor>(((e, xs), exs), ln)\\<rfloor>;\n     \\<forall>l. expr_locks e l + expr_lockss (map fst exs) l = expr_locks e' l + expr_lockss (map fst exs') l \\<rbrakk>\n  \\<Longrightarrow> lock_oks1 ls (ts(t \\<mapsto> (((e', xs'), exs'), ln)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln.\n       \\<lbrakk>lock_oks1 ls ts;\n        ts t = \\<lfloor>(((e, xs), exs), ln)\\<rfloor>;\n        \\<forall>l.\n           expr_locks e l + expr_lockss (map fst exs) l =\n           expr_locks e' l + expr_lockss (map fst exs') l\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 ls\n                          (ts(t \\<mapsto> (((e', xs'), exs'), ln)))", "by(rule lock_oks1I)(auto split: if_split_asm dest: lock_oks1D2 lock_oks1D1)"], ["", "definition mbisim_Red1'_Red1 ::\n  \"(('addr,'thread_id,('addr expr1 \\<times> 'addr locals1) \\<times> ('addr expr1 \\<times> 'addr locals1) list,'heap,'addr) state, \n    ('addr,'thread_id,('addr expr1 \\<times> 'addr locals1) \\<times> ('addr expr1 \\<times> 'addr locals1) list,'heap,'addr) state) bisim\"\nwhere\n  \"mbisim_Red1'_Red1 s1 s2 = \n  (s1 = s2 \\<and> lock_oks1 (locks s1) (thr s1) \\<and> ts_ok (\\<lambda>t exexs h. el_loc_ok1 exexs) (thr s1) (shr s1))\""], ["", "lemma sync_ok_blocks:\n  \"\\<lbrakk> length vs = length pns; length Ts = length pns\\<rbrakk>\n  \\<Longrightarrow> sync_ok (blocks pns Ts vs body) = sync_ok body\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length vs = length pns; length Ts = length pns\\<rbrakk>\n    \\<Longrightarrow> sync_ok (blocks pns Ts vs body) = sync_ok body", "by(induct pns Ts vs body rule: blocks.induct) auto"], ["", "context J1_heap_base begin"], ["", "lemma red1_True_into_red1_False:\n  \"\\<lbrakk> True,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; el_loc_ok e (lcl s) \\<rbrakk> \n  \\<Longrightarrow> False,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle> \\<or> (\\<exists>l. ta = \\<lbrace>UnlockFail\\<rightarrow>l\\<rbrace> \\<and> expr_locks e l > 0)\"\n  and reds1_True_into_reds1_False:\n  \"\\<lbrakk> True,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; els_loc_ok es (lcl s) \\<rbrakk>\n  \\<Longrightarrow> False,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle> \\<or> (\\<exists>l. ta = \\<lbrace>UnlockFail\\<rightarrow>l\\<rbrace> \\<and> expr_lockss es l > 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n      el_loc_ok e (lcl s)\\<rbrakk>\n     \\<Longrightarrow> False,P,t \\<turnstile>1 \\<langle>e,\n          s\\<rangle> -ta\\<rightarrow>\n         \\<langle>e',s'\\<rangle> \\<or>\n                       (\\<exists>l.\n                           ta = \\<lbrace>(UnlockFail, l)\\<rbrace> \\<and>\n                           0 < expr_locks e l)) &&&\n    (\\<lbrakk>True,P,t \\<turnstile>1 \\<langle>es,\ns\\<rangle> [-ta\\<rightarrow>]\n                                     \\<langle>es',s'\\<rangle>;\n      els_loc_ok es (lcl s)\\<rbrakk>\n     \\<Longrightarrow> False,P,t \\<turnstile>1 \\<langle>es,\n          s\\<rangle> [-ta\\<rightarrow>]\n         \\<langle>es',s'\\<rangle> \\<or>\n                       (\\<exists>l.\n                           ta = \\<lbrace>(UnlockFail, l)\\<rbrace> \\<and>\n                           0 < expr_lockss es l))", "apply(induct rule: red1_reds1.inducts)"], ["proof (prove)\ngoal (102 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        el_loc_ok (new C) (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> False,P,t \\<turnstile>1 \\<langle>new C,\n            (h, l)\\<rangle> -\\<lbrace>NewHeapElem a\n (Class_type C)\\<rbrace>\\<rightarrow>\n           \\<langle>addr a,(h', l)\\<rangle> \\<or>\n                         (\\<exists>l.\n                             \\<lbrace>NewHeapElem a\n (Class_type C)\\<rbrace> =\n                             \\<lbrace>(UnlockFail, l)\\<rbrace> \\<and>\n                             0 < expr_locks (new C) l)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        el_loc_ok (new C) (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> False,P,t \\<turnstile>1 \\<langle>new C,\n            (h, l)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n           \\<langle>Throw (addr_of_sys_xcpt OutOfMemory),\n            (h, l)\\<rangle> \\<or>\n                         (\\<exists>l.\n                             \\<lbrace>\\<rbrace> =\n                             \\<lbrace>(UnlockFail, l)\\<rbrace> \\<and>\n                             0 < expr_locks (new C) l)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        el_loc_ok e (lcl s) \\<Longrightarrow>\n        False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                \\<langle>e',s'\\<rangle> \\<or>\n        (\\<exists>l.\n            ta = \\<lbrace>(UnlockFail, l)\\<rbrace> \\<and>\n            0 < expr_locks e l);\n        el_loc_ok (newA T\\<lfloor>e\\<rceil>) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>e\\<rceil>,\n            s\\<rangle> -ta\\<rightarrow>\n           \\<langle>newA T\\<lfloor>e'\\<rceil>,s'\\<rangle> \\<or>\n                         (\\<exists>l.\n                             ta = \\<lbrace>(UnlockFail, l)\\<rbrace> \\<and>\n                             0 < expr_locks (newA T\\<lfloor>e\\<rceil>) l)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n         (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n                                    (Intg i)\\<rceil>,\n            (h, l)\\<rangle> -\\<lbrace>NewHeapElem a\n (Array_type T (nat (sint i)))\\<rbrace>\\<rightarrow>\n           \\<langle>addr a,(h', l)\\<rangle> \\<or>\n                         (\\<exists>l.\n                             \\<lbrace>NewHeapElem a\n (Array_type T (nat (sint i)))\\<rbrace> =\n                             \\<lbrace>(UnlockFail, l)\\<rbrace> \\<and>\n                             0 < expr_locks\n                                  (newA T\\<lfloor>Val (Intg i)\\<rceil>) l)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n                                    (Intg i)\\<rceil>,\n            s\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n           \\<langle>Throw (addr_of_sys_xcpt NegativeArraySize),\n            s\\<rangle> \\<or>\n                         (\\<exists>l.\n                             \\<lbrace>\\<rbrace> =\n                             \\<lbrace>(UnlockFail, l)\\<rbrace> \\<and>\n                             0 < expr_locks\n                                  (newA T\\<lfloor>Val (Intg i)\\<rceil>) l)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n         (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n                                    (Intg i)\\<rceil>,\n            (h, l)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n           \\<langle>Throw (addr_of_sys_xcpt OutOfMemory),\n            (h, l)\\<rangle> \\<or>\n                         (\\<exists>l.\n                             \\<lbrace>\\<rbrace> =\n                             \\<lbrace>(UnlockFail, l)\\<rbrace> \\<and>\n                             0 < expr_locks\n                                  (newA T\\<lfloor>Val (Intg i)\\<rceil>) l)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        el_loc_ok e (lcl s) \\<Longrightarrow>\n        False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                \\<langle>e',s'\\<rangle> \\<or>\n        (\\<exists>l.\n            ta = \\<lbrace>(UnlockFail, l)\\<rbrace> \\<and>\n            0 < expr_locks e l);\n        el_loc_ok (Cast C e) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> False,P,t \\<turnstile>1 \\<langle>Cast C e,\n            s\\<rangle> -ta\\<rightarrow>\n           \\<langle>Cast C e',s'\\<rangle> \\<or>\n                         (\\<exists>l.\n                             ta = \\<lbrace>(UnlockFail, l)\\<rbrace> \\<and>\n                             0 < expr_locks (Cast C e) l)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        el_loc_ok (Cast T (Val v)) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n            s\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n           \\<langle>Val v,s\\<rangle> \\<or>\n                         (\\<exists>l.\n                             \\<lbrace>\\<rbrace> =\n                             \\<lbrace>(UnlockFail, l)\\<rbrace> \\<and>\n                             0 < expr_locks (Cast T (Val v)) l)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        el_loc_ok (Cast T (Val v)) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n            s\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n           \\<langle>Throw (addr_of_sys_xcpt ClassCast),s\\<rangle> \\<or>\n                         (\\<exists>l.\n                             \\<lbrace>\\<rbrace> =\n                             \\<lbrace>(UnlockFail, l)\\<rbrace> \\<and>\n                             0 < expr_locks (Cast T (Val v)) l)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         el_loc_ok e (lcl s) \\<Longrightarrow>\n         False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                 \\<langle>e',s'\\<rangle> \\<or>\n         (\\<exists>l.\n             ta = \\<lbrace>(UnlockFail, l)\\<rbrace> \\<and>\n             0 < expr_locks e l);\n         el_loc_ok (e instanceof T) (lcl s)\\<rbrakk>\n        \\<Longrightarrow> False,P,t \\<turnstile>1 \\<langle>e instanceof T,\n             s\\<rangle> -ta\\<rightarrow>\n            \\<langle>e' instanceof T,s'\\<rangle> \\<or>\n                          (\\<exists>l.\n                              ta = \\<lbrace>(UnlockFail, l)\\<rbrace> \\<and>\n                              0 < expr_locks (e instanceof T) l)\nA total of 102 subgoals...", "apply(auto intro: red1_reds1.intros split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Red1_True_into_Red1_False:\n  assumes \"True,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow> \\<langle>ex'/exs',m'\\<rangle>\"\n  and \"el_loc_ok1 (ex, exs)\"\n  shows \"False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow> \\<langle>ex'/exs',m'\\<rangle> \\<or> \n         (\\<exists>l. ta = \\<lbrace>UnlockFail\\<rightarrow>l\\<rbrace> \\<and> expr_lockss (fst ex # map fst exs) l > 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                            \\<langle>ex'/exs',m'\\<rangle> \\<or>\n    (\\<exists>l.\n        ta = \\<lbrace>(UnlockFail, l)\\<rbrace> \\<and>\n        0 < expr_lockss (fst ex # map fst exs) l)", "using assms"], ["proof (prove)\nusing this:\n  True,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                         \\<langle>ex'/exs',m'\\<rangle>\n  el_loc_ok1 (ex, exs)\n\ngoal (1 subgoal):\n 1. False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                            \\<langle>ex'/exs',m'\\<rangle> \\<or>\n    (\\<exists>l.\n        ta = \\<lbrace>(UnlockFail, l)\\<rbrace> \\<and>\n        0 < expr_lockss (fst ex # map fst exs) l)", "by(cases)(auto dest: Red1.intros red1_True_into_red1_False simp add: el_loc_ok1_def ta_upd_simps)"], ["", "lemma shows red1_preserves_el_loc_ok:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; sync_ok e; el_loc_ok e (lcl s) \\<rbrakk> \\<Longrightarrow> el_loc_ok e' (lcl s')\"\n\n  and reds1_preserves_els_loc_ok:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; sync_oks es; els_loc_ok es (lcl s) \\<rbrakk> \\<Longrightarrow> els_loc_ok es' (lcl s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle>;\n      sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n     \\<Longrightarrow> el_loc_ok e' (lcl s')) &&&\n    (\\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>es,s\\<rangle> [-ta\\<rightarrow>]\n                                   \\<langle>es',s'\\<rangle>;\n      sync_oks es; els_loc_ok es (lcl s)\\<rbrakk>\n     \\<Longrightarrow> els_loc_ok es' (lcl s'))", "proof(induct rule: red1_reds1.inducts)"], ["proof (state)\ngoal (102 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C); sync_ok (new C);\n        el_loc_ok (new C) (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (addr a) (lcl (h', l))\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {}; sync_ok (new C);\n        el_loc_ok (new C) (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n                          (lcl (h, l))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok e' (lcl s');\n        sync_ok (newA T\\<lfloor>e\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>e\\<rceil>) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (newA T\\<lfloor>e'\\<rceil>) (lcl s')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n         (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (addr a) (lcl (h', l))\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0; sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok\n                          (Throw (addr_of_sys_xcpt NegativeArraySize))\n                          (lcl s)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n         (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n                          (lcl (h, l))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok e' (lcl s');\n        sync_ok (Cast C e); el_loc_ok (Cast C e) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Cast C e') (lcl s')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v));\n        el_loc_ok (Cast T (Val v)) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Val v) (lcl s)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v));\n        el_loc_ok (Cast T (Val v)) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Throw (addr_of_sys_xcpt ClassCast))\n                          (lcl s)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n         \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n         \\<Longrightarrow> el_loc_ok e' (lcl s');\n         sync_ok (e instanceof T);\n         el_loc_ok (e instanceof T) (lcl s)\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok (e' instanceof T) (lcl s')\nA total of 102 subgoals...", "case (Synchronized1Red2 e s ta e' s' V a)"], ["proof (state)\nthis:\n  uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                       \\<langle>e',s'\\<rangle>\n  \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n  \\<Longrightarrow> el_loc_ok e' (lcl s')\n  sync_ok (insync\\<^bsub>V\\<^esub> (a) e)\n  el_loc_ok (insync\\<^bsub>V\\<^esub> (a) e) (lcl s)\n\ngoal (102 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C); sync_ok (new C);\n        el_loc_ok (new C) (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (addr a) (lcl (h', l))\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {}; sync_ok (new C);\n        el_loc_ok (new C) (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n                          (lcl (h, l))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok e' (lcl s');\n        sync_ok (newA T\\<lfloor>e\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>e\\<rceil>) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (newA T\\<lfloor>e'\\<rceil>) (lcl s')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n         (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (addr a) (lcl (h', l))\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0; sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok\n                          (Throw (addr_of_sys_xcpt NegativeArraySize))\n                          (lcl s)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n         (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n                          (lcl (h, l))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok e' (lcl s');\n        sync_ok (Cast C e); el_loc_ok (Cast C e) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Cast C e') (lcl s')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v));\n        el_loc_ok (Cast T (Val v)) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Val v) (lcl s)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v));\n        el_loc_ok (Cast T (Val v)) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Throw (addr_of_sys_xcpt ClassCast))\n                          (lcl s)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n         \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n         \\<Longrightarrow> el_loc_ok e' (lcl s');\n         sync_ok (e instanceof T);\n         el_loc_ok (e instanceof T) (lcl s)\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok (e' instanceof T) (lcl s')\nA total of 102 subgoals...", "from \\<open>el_loc_ok (insync\\<^bsub>V\\<^esub> (a) e) (lcl s)\\<close>"], ["proof (chain)\npicking this:\n  el_loc_ok (insync\\<^bsub>V\\<^esub> (a) e) (lcl s)", "have \"el_loc_ok e (lcl s)\" \"unmod e V\" \"lcl s ! V = Addr a\""], ["proof (prove)\nusing this:\n  el_loc_ok (insync\\<^bsub>V\\<^esub> (a) e) (lcl s)\n\ngoal (1 subgoal):\n 1. el_loc_ok e (lcl s) &&& unmod e V &&& lcl s ! V = Addr a", "by auto"], ["proof (state)\nthis:\n  el_loc_ok e (lcl s)\n  unmod e V\n  lcl s ! V = Addr a\n\ngoal (102 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C); sync_ok (new C);\n        el_loc_ok (new C) (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (addr a) (lcl (h', l))\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {}; sync_ok (new C);\n        el_loc_ok (new C) (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n                          (lcl (h, l))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok e' (lcl s');\n        sync_ok (newA T\\<lfloor>e\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>e\\<rceil>) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (newA T\\<lfloor>e'\\<rceil>) (lcl s')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n         (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (addr a) (lcl (h', l))\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0; sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok\n                          (Throw (addr_of_sys_xcpt NegativeArraySize))\n                          (lcl s)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n         (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n                          (lcl (h, l))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok e' (lcl s');\n        sync_ok (Cast C e); el_loc_ok (Cast C e) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Cast C e') (lcl s')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v));\n        el_loc_ok (Cast T (Val v)) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Val v) (lcl s)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v));\n        el_loc_ok (Cast T (Val v)) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Throw (addr_of_sys_xcpt ClassCast))\n                          (lcl s)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n         \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n         \\<Longrightarrow> el_loc_ok e' (lcl s');\n         sync_ok (e instanceof T);\n         el_loc_ok (e instanceof T) (lcl s)\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok (e' instanceof T) (lcl s')\nA total of 102 subgoals...", "from \\<open>sync_ok (insync\\<^bsub>V\\<^esub> (a) e)\\<close>"], ["proof (chain)\npicking this:\n  sync_ok (insync\\<^bsub>V\\<^esub> (a) e)", "have \"sync_ok e\""], ["proof (prove)\nusing this:\n  sync_ok (insync\\<^bsub>V\\<^esub> (a) e)\n\ngoal (1 subgoal):\n 1. sync_ok e", "by simp"], ["proof (state)\nthis:\n  sync_ok e\n\ngoal (102 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C); sync_ok (new C);\n        el_loc_ok (new C) (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (addr a) (lcl (h', l))\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {}; sync_ok (new C);\n        el_loc_ok (new C) (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n                          (lcl (h, l))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok e' (lcl s');\n        sync_ok (newA T\\<lfloor>e\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>e\\<rceil>) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (newA T\\<lfloor>e'\\<rceil>) (lcl s')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n         (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (addr a) (lcl (h', l))\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0; sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok\n                          (Throw (addr_of_sys_xcpt NegativeArraySize))\n                          (lcl s)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n         (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n                          (lcl (h, l))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok e' (lcl s');\n        sync_ok (Cast C e); el_loc_ok (Cast C e) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Cast C e') (lcl s')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v));\n        el_loc_ok (Cast T (Val v)) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Val v) (lcl s)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v));\n        el_loc_ok (Cast T (Val v)) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Throw (addr_of_sys_xcpt ClassCast))\n                          (lcl s)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n         \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n         \\<Longrightarrow> el_loc_ok e' (lcl s');\n         sync_ok (e instanceof T);\n         el_loc_ok (e instanceof T) (lcl s)\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok (e' instanceof T) (lcl s')\nA total of 102 subgoals...", "hence \"el_loc_ok e' (lcl s')\""], ["proof (prove)\nusing this:\n  sync_ok e\n\ngoal (1 subgoal):\n 1. el_loc_ok e' (lcl s')", "using \\<open>el_loc_ok e (lcl s)\\<close>"], ["proof (prove)\nusing this:\n  sync_ok e\n  el_loc_ok e (lcl s)\n\ngoal (1 subgoal):\n 1. el_loc_ok e' (lcl s')", "by(rule Synchronized1Red2)"], ["proof (state)\nthis:\n  el_loc_ok e' (lcl s')\n\ngoal (102 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C); sync_ok (new C);\n        el_loc_ok (new C) (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (addr a) (lcl (h', l))\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {}; sync_ok (new C);\n        el_loc_ok (new C) (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n                          (lcl (h, l))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok e' (lcl s');\n        sync_ok (newA T\\<lfloor>e\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>e\\<rceil>) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (newA T\\<lfloor>e'\\<rceil>) (lcl s')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n         (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (addr a) (lcl (h', l))\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0; sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok\n                          (Throw (addr_of_sys_xcpt NegativeArraySize))\n                          (lcl s)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n         (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n                          (lcl (h, l))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok e' (lcl s');\n        sync_ok (Cast C e); el_loc_ok (Cast C e) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Cast C e') (lcl s')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v));\n        el_loc_ok (Cast T (Val v)) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Val v) (lcl s)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v));\n        el_loc_ok (Cast T (Val v)) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Throw (addr_of_sys_xcpt ClassCast))\n                          (lcl s)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n         \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n         \\<Longrightarrow> el_loc_ok e' (lcl s');\n         sync_ok (e instanceof T);\n         el_loc_ok (e instanceof T) (lcl s)\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok (e' instanceof T) (lcl s')\nA total of 102 subgoals...", "moreover"], ["proof (state)\nthis:\n  el_loc_ok e' (lcl s')\n\ngoal (102 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C); sync_ok (new C);\n        el_loc_ok (new C) (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (addr a) (lcl (h', l))\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {}; sync_ok (new C);\n        el_loc_ok (new C) (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n                          (lcl (h, l))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok e' (lcl s');\n        sync_ok (newA T\\<lfloor>e\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>e\\<rceil>) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (newA T\\<lfloor>e'\\<rceil>) (lcl s')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n         (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (addr a) (lcl (h', l))\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0; sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok\n                          (Throw (addr_of_sys_xcpt NegativeArraySize))\n                          (lcl s)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n         (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n                          (lcl (h, l))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok e' (lcl s');\n        sync_ok (Cast C e); el_loc_ok (Cast C e) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Cast C e') (lcl s')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v));\n        el_loc_ok (Cast T (Val v)) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Val v) (lcl s)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v));\n        el_loc_ok (Cast T (Val v)) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Throw (addr_of_sys_xcpt ClassCast))\n                          (lcl s)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n         \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n         \\<Longrightarrow> el_loc_ok e' (lcl s');\n         sync_ok (e instanceof T);\n         el_loc_ok (e instanceof T) (lcl s)\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok (e' instanceof T) (lcl s')\nA total of 102 subgoals...", "from \\<open>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow> \\<langle>e',s'\\<rangle>\\<close> \\<open>unmod e V\\<close>"], ["proof (chain)\npicking this:\n  uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                       \\<langle>e',s'\\<rangle>\n  unmod e V", "have \"unmod e' V\""], ["proof (prove)\nusing this:\n  uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                       \\<langle>e',s'\\<rangle>\n  unmod e V\n\ngoal (1 subgoal):\n 1. unmod e' V", "by(rule red1_unmod_preserved)"], ["proof (state)\nthis:\n  unmod e' V\n\ngoal (102 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C); sync_ok (new C);\n        el_loc_ok (new C) (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (addr a) (lcl (h', l))\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {}; sync_ok (new C);\n        el_loc_ok (new C) (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n                          (lcl (h, l))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok e' (lcl s');\n        sync_ok (newA T\\<lfloor>e\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>e\\<rceil>) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (newA T\\<lfloor>e'\\<rceil>) (lcl s')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n         (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (addr a) (lcl (h', l))\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0; sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok\n                          (Throw (addr_of_sys_xcpt NegativeArraySize))\n                          (lcl s)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n         (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n                          (lcl (h, l))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok e' (lcl s');\n        sync_ok (Cast C e); el_loc_ok (Cast C e) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Cast C e') (lcl s')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v));\n        el_loc_ok (Cast T (Val v)) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Val v) (lcl s)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v));\n        el_loc_ok (Cast T (Val v)) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Throw (addr_of_sys_xcpt ClassCast))\n                          (lcl s)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n         \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n         \\<Longrightarrow> el_loc_ok e' (lcl s');\n         sync_ok (e instanceof T);\n         el_loc_ok (e instanceof T) (lcl s)\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok (e' instanceof T) (lcl s')\nA total of 102 subgoals...", "moreover"], ["proof (state)\nthis:\n  unmod e' V\n\ngoal (102 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C); sync_ok (new C);\n        el_loc_ok (new C) (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (addr a) (lcl (h', l))\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {}; sync_ok (new C);\n        el_loc_ok (new C) (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n                          (lcl (h, l))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok e' (lcl s');\n        sync_ok (newA T\\<lfloor>e\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>e\\<rceil>) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (newA T\\<lfloor>e'\\<rceil>) (lcl s')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n         (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (addr a) (lcl (h', l))\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0; sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok\n                          (Throw (addr_of_sys_xcpt NegativeArraySize))\n                          (lcl s)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n         (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n                          (lcl (h, l))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok e' (lcl s');\n        sync_ok (Cast C e); el_loc_ok (Cast C e) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Cast C e') (lcl s')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v));\n        el_loc_ok (Cast T (Val v)) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Val v) (lcl s)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v));\n        el_loc_ok (Cast T (Val v)) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Throw (addr_of_sys_xcpt ClassCast))\n                          (lcl s)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n         \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n         \\<Longrightarrow> el_loc_ok e' (lcl s');\n         sync_ok (e instanceof T);\n         el_loc_ok (e instanceof T) (lcl s)\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok (e' instanceof T) (lcl s')\nA total of 102 subgoals...", "from red1_preserves_unmod[OF \\<open>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow> \\<langle>e',s'\\<rangle>\\<close> \\<open>unmod e V\\<close>] \\<open>lcl s ! V = Addr a\\<close>"], ["proof (chain)\npicking this:\n  lcl s' ! V = lcl s ! V\n  lcl s ! V = Addr a", "have \"lcl s' ! V = Addr a\""], ["proof (prove)\nusing this:\n  lcl s' ! V = lcl s ! V\n  lcl s ! V = Addr a\n\ngoal (1 subgoal):\n 1. lcl s' ! V = Addr a", "by simp"], ["proof (state)\nthis:\n  lcl s' ! V = Addr a\n\ngoal (102 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C); sync_ok (new C);\n        el_loc_ok (new C) (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (addr a) (lcl (h', l))\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {}; sync_ok (new C);\n        el_loc_ok (new C) (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n                          (lcl (h, l))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok e' (lcl s');\n        sync_ok (newA T\\<lfloor>e\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>e\\<rceil>) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (newA T\\<lfloor>e'\\<rceil>) (lcl s')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n         (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (addr a) (lcl (h', l))\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0; sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok\n                          (Throw (addr_of_sys_xcpt NegativeArraySize))\n                          (lcl s)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n         (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n                          (lcl (h, l))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok e' (lcl s');\n        sync_ok (Cast C e); el_loc_ok (Cast C e) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Cast C e') (lcl s')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v));\n        el_loc_ok (Cast T (Val v)) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Val v) (lcl s)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v));\n        el_loc_ok (Cast T (Val v)) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Throw (addr_of_sys_xcpt ClassCast))\n                          (lcl s)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n         \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n         \\<Longrightarrow> el_loc_ok e' (lcl s');\n         sync_ok (e instanceof T);\n         el_loc_ok (e instanceof T) (lcl s)\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok (e' instanceof T) (lcl s')\nA total of 102 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  el_loc_ok e' (lcl s')\n  unmod e' V\n  lcl s' ! V = Addr a", "show ?case"], ["proof (prove)\nusing this:\n  el_loc_ok e' (lcl s')\n  unmod e' V\n  lcl s' ! V = Addr a\n\ngoal (1 subgoal):\n 1. el_loc_ok (insync\\<^bsub>V\\<^esub> (a) e') (lcl s')", "by auto"], ["proof (state)\nthis:\n  el_loc_ok (insync\\<^bsub>V\\<^esub> (a) e') (lcl s')\n\ngoal (101 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C); sync_ok (new C);\n        el_loc_ok (new C) (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (addr a) (lcl (h', l))\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {}; sync_ok (new C);\n        el_loc_ok (new C) (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n                          (lcl (h, l))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok e' (lcl s');\n        sync_ok (newA T\\<lfloor>e\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>e\\<rceil>) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (newA T\\<lfloor>e'\\<rceil>) (lcl s')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n         (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (addr a) (lcl (h', l))\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0; sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok\n                          (Throw (addr_of_sys_xcpt NegativeArraySize))\n                          (lcl s)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n         (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Throw (addr_of_sys_xcpt OutOfMemory))\n                          (lcl (h, l))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok e' (lcl s');\n        sync_ok (Cast C e); el_loc_ok (Cast C e) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Cast C e') (lcl s')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v));\n        el_loc_ok (Cast T (Val v)) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Val v) (lcl s)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v));\n        el_loc_ok (Cast T (Val v)) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok (Throw (addr_of_sys_xcpt ClassCast))\n                          (lcl s)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n         \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n         \\<Longrightarrow> el_loc_ok e' (lcl s');\n         sync_ok (e instanceof T);\n         el_loc_ok (e instanceof T) (lcl s)\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok (e' instanceof T) (lcl s')\nA total of 101 subgoals...", "qed(auto elim: el_loc_ok_not_contains_insync_local_change els_loc_ok_not_contains_insyncs_local_change)"], ["", "lemma red1_preserves_sync_ok: \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; sync_ok e \\<rbrakk> \\<Longrightarrow> sync_ok e'\"\n  and reds1_preserves_sync_oks: \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; sync_oks es \\<rbrakk> \\<Longrightarrow> sync_oks es'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle>;\n      sync_ok e\\<rbrakk>\n     \\<Longrightarrow> sync_ok e') &&&\n    (\\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>es,s\\<rangle> [-ta\\<rightarrow>]\n                                   \\<langle>es',s'\\<rangle>;\n      sync_oks es\\<rbrakk>\n     \\<Longrightarrow> sync_oks es')", "by(induct rule: red1_reds1.inducts)(auto elim: not_contains_insync_sync_ok)"], ["", "lemma Red1_preserves_el_loc_ok1:\n  assumes wf: \"wf_J1_prog P\"\n  shows \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>ex/exs,m\\<rangle> -ta\\<rightarrow> \\<langle>ex'/exs',m'\\<rangle>; el_loc_ok1 (ex, exs) \\<rbrakk>  \\<Longrightarrow> el_loc_ok1 (ex', exs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>ex/exs,\n                                   m\\<rangle> -ta\\<rightarrow>\n                                  \\<langle>ex'/exs',m'\\<rangle>;\n     el_loc_ok1 (ex, exs)\\<rbrakk>\n    \\<Longrightarrow> el_loc_ok1 (ex', exs')", "apply(erule Red1.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e h x taa e' h' x' exsa.\n       \\<lbrakk>el_loc_ok1 (ex, exs); ex = (e, x); exs = exsa; m = h;\n        ta = extTA2J1 P taa; ex' = (e', x'); exs' = exsa; m' = h';\n        uf,P,t \\<turnstile>1 \\<langle>e,(h, x)\\<rangle> -taa\\<rightarrow>\n                             \\<langle>e',(h', x')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok1 (ex', exs')\n 2. \\<And>e a M vs h U Ts T body D x exsa.\n       \\<lbrakk>el_loc_ok1 (ex, exs); ex = (e, x); exs = exsa; m = h;\n        ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exsa; m' = h;\n        call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr h a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok1 (ex', exs')\n 3. \\<And>e' x' e x exsa h.\n       \\<lbrakk>el_loc_ok1 (ex, exs); ex = (e', x'); exs = (e, x) # exsa;\n        m = h; ta = \\<lbrace>\\<rbrace>; ex' = (inline_call e' e, x);\n        exs' = exsa; m' = h; final e'\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok1 (ex', exs')", "apply(auto simp add: el_loc_ok1_def dest: red1_preserves_el_loc_ok red1_preserves_sync_ok intro: el_loc_ok_inline_call sync_ok_inline_call)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        ({0:Class D=None; blocks1 (Suc 0) Ts body},\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = m; call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr m a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts; el_loc_ok e x; sync_ok e;\n        \\<forall>x\\<in>set exs.\n           case x of\n           (e, xs) \\<Rightarrow> el_loc_ok e xs \\<and> sync_ok e\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok body\n                          (Addr a #\n                           vs @ replicate (max_vars body) undefined_value)\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        ({0:Class D=None; blocks1 (Suc 0) Ts body},\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = m; call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr m a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts; el_loc_ok e x; sync_ok e;\n        \\<forall>x\\<in>set exs.\n           case x of\n           (e, xs) \\<Rightarrow> el_loc_ok e xs \\<and> sync_ok e\\<rbrakk>\n       \\<Longrightarrow> sync_ok body", "apply(fastforce dest!: sees_wf_mdecl[OF wf] simp add: wf_mdecl_def intro!: el_loc_okI dest: WT1_not_contains_insync intro: not_contains_insync_sync_ok)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma assumes wf: \"wf_J1_prog P\"\n  shows red1_el_loc_ok1_new_thread:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; NewThread t' (C, M, a) h \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> el_loc_ok1 (({0:Class (fst (method P C M))=None; the (snd (snd (snd (method P C M))))}, xs), [])\"\n\n  and reds1_el_loc_ok1_new_thread:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; NewThread t' (C, M, a) h \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> el_loc_ok1 (({0:Class (fst (method P C M))=None; the (snd (snd (snd (method P C M))))}, xs), [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle>;\n      NewThread t' (C, M, a) h\n      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n     \\<Longrightarrow> el_loc_ok1\n                        (({0:Class\n                              (fst (method P C\n                                     M))=None; the\n          (snd (snd (snd (method P C M))))},\n                          xs),\n                         [])) &&&\n    (\\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>es,s\\<rangle> [-ta\\<rightarrow>]\n                                   \\<langle>es',s'\\<rangle>;\n      NewThread t' (C, M, a) h\n      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n     \\<Longrightarrow> el_loc_ok1\n                        (({0:Class\n                              (fst (method P C\n                                     M))=None; the\n          (snd (snd (snd (method P C M))))},\n                          xs),\n                         []))", "proof(induct rule: red1_reds1.inducts)"], ["proof (state)\ngoal (102 subgoals):\n 1. \\<And>h' aa ha Ca l.\n       \\<lbrakk>(h', aa) \\<in> allocate ha (Class_type Ca);\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem aa\n                                     (Class_type\n Ca)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok1\n                          (({0:Class\n                                (fst (method P C\n M))=None; the (snd (snd (snd (method P C M))))},\n                            xs),\n                           [])\n 2. \\<And>ha Ca l.\n       \\<lbrakk>allocate ha (Class_type Ca) = {};\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok1\n                          (({0:Class\n                                (fst (method P C\n M))=None; the (snd (snd (snd (method P C M))))},\n                            xs),\n                           [])\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        el_loc_ok1\n         (({0:Class\n               (fst (method P C\n                      M))=None; the (snd (snd (snd (method P C M))))},\n           xs),\n          []);\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok1\n                          (({0:Class\n                                (fst (method P C\n M))=None; the (snd (snd (snd (method P C M))))},\n                            xs),\n                           [])\n 4. \\<And>i h' aa ha T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', aa) \\<in> allocate ha (Array_type T (nat (sint i)));\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem aa\n                                     (Array_type T\n (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok1\n                          (({0:Class\n                                (fst (method P C\n M))=None; the (snd (snd (snd (method P C M))))},\n                            xs),\n                           [])\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok1\n                          (({0:Class\n                                (fst (method P C\n M))=None; the (snd (snd (snd (method P C M))))},\n                            xs),\n                           [])\n 6. \\<And>i ha T l.\n       \\<lbrakk>0 \\<le>s i; allocate ha (Array_type T (nat (sint i))) = {};\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok1\n                          (({0:Class\n                                (fst (method P C\n M))=None; the (snd (snd (snd (method P C M))))},\n                            xs),\n                           [])\n 7. \\<And>e s ta e' s' Ca.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        el_loc_ok1\n         (({0:Class\n               (fst (method P C\n                      M))=None; the (snd (snd (snd (method P C M))))},\n           xs),\n          []);\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok1\n                          (({0:Class\n                                (fst (method P C\n M))=None; the (snd (snd (snd (method P C M))))},\n                            xs),\n                           [])\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok1\n                          (({0:Class\n                                (fst (method P C\n M))=None; the (snd (snd (snd (method P C M))))},\n                            xs),\n                           [])\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok1\n                          (({0:Class\n                                (fst (method P C\n M))=None; the (snd (snd (snd (method P C M))))},\n                            xs),\n                           [])\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n         NewThread t' (C, M, a) h\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n         el_loc_ok1\n          (({0:Class\n                (fst (method P C\n                       M))=None; the (snd (snd (snd (method P C M))))},\n            xs),\n           []);\n         NewThread t' (C, M, a) h\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok1\n                           (({0:Class\n                                 (fst (method P C\n  M))=None; the (snd (snd (snd (method P C M))))},\n                             xs),\n                            [])\nA total of 102 subgoals...", "case Red1CallExternal"], ["proof (state)\nthis:\n  typeof_addr (hp s_) a_ = \\<lfloor>T_\\<rfloor>\n  P \\<turnstile> class_type_of\n                  T_ sees M_: Ts_\\<rightarrow>Tr_ = Native in D_\n  P,t \\<turnstile> \\<langle>a_\\<bullet>M_(vs_),\n                   hp s_\\<rangle> -ta_\\<rightarrow>ext \\<langle>va_,\n                 h'_\\<rangle>\n  e'_ = extRet2J (addr a_\\<bullet>M_(map Val vs_)) va_\n  s'_ = (h'_, lcl s_)\n  NewThread t' (C, M, a) h \\<in> set \\<lbrace>ta_\\<rbrace>\\<^bsub>t\\<^esub>\n\ngoal (102 subgoals):\n 1. \\<And>h' aa ha Ca l.\n       \\<lbrakk>(h', aa) \\<in> allocate ha (Class_type Ca);\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem aa\n                                     (Class_type\n Ca)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok1\n                          (({0:Class\n                                (fst (method P C\n M))=None; the (snd (snd (snd (method P C M))))},\n                            xs),\n                           [])\n 2. \\<And>ha Ca l.\n       \\<lbrakk>allocate ha (Class_type Ca) = {};\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok1\n                          (({0:Class\n                                (fst (method P C\n M))=None; the (snd (snd (snd (method P C M))))},\n                            xs),\n                           [])\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        el_loc_ok1\n         (({0:Class\n               (fst (method P C\n                      M))=None; the (snd (snd (snd (method P C M))))},\n           xs),\n          []);\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok1\n                          (({0:Class\n                                (fst (method P C\n M))=None; the (snd (snd (snd (method P C M))))},\n                            xs),\n                           [])\n 4. \\<And>i h' aa ha T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', aa) \\<in> allocate ha (Array_type T (nat (sint i)));\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem aa\n                                     (Array_type T\n (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok1\n                          (({0:Class\n                                (fst (method P C\n M))=None; the (snd (snd (snd (method P C M))))},\n                            xs),\n                           [])\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok1\n                          (({0:Class\n                                (fst (method P C\n M))=None; the (snd (snd (snd (method P C M))))},\n                            xs),\n                           [])\n 6. \\<And>i ha T l.\n       \\<lbrakk>0 \\<le>s i; allocate ha (Array_type T (nat (sint i))) = {};\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok1\n                          (({0:Class\n                                (fst (method P C\n M))=None; the (snd (snd (snd (method P C M))))},\n                            xs),\n                           [])\n 7. \\<And>e s ta e' s' Ca.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        el_loc_ok1\n         (({0:Class\n               (fst (method P C\n                      M))=None; the (snd (snd (snd (method P C M))))},\n           xs),\n          []);\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok1\n                          (({0:Class\n                                (fst (method P C\n M))=None; the (snd (snd (snd (method P C M))))},\n                            xs),\n                           [])\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok1\n                          (({0:Class\n                                (fst (method P C\n M))=None; the (snd (snd (snd (method P C M))))},\n                            xs),\n                           [])\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok1\n                          (({0:Class\n                                (fst (method P C\n M))=None; the (snd (snd (snd (method P C M))))},\n                            xs),\n                           [])\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n         NewThread t' (C, M, a) h\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n         el_loc_ok1\n          (({0:Class\n                (fst (method P C\n                       M))=None; the (snd (snd (snd (method P C M))))},\n            xs),\n           []);\n         NewThread t' (C, M, a) h\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok1\n                           (({0:Class\n                                 (fst (method P C\n  M))=None; the (snd (snd (snd (method P C M))))},\n                             xs),\n                            [])\nA total of 102 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  typeof_addr (hp s_) a_ = \\<lfloor>T_\\<rfloor>\n  P \\<turnstile> class_type_of\n                  T_ sees M_: Ts_\\<rightarrow>Tr_ = Native in D_\n  P,t \\<turnstile> \\<langle>a_\\<bullet>M_(vs_),\n                   hp s_\\<rangle> -ta_\\<rightarrow>ext \\<langle>va_,\n                 h'_\\<rangle>\n  e'_ = extRet2J (addr a_\\<bullet>M_(map Val vs_)) va_\n  s'_ = (h'_, lcl s_)\n  NewThread t' (C, M, a) h \\<in> set \\<lbrace>ta_\\<rbrace>\\<^bsub>t\\<^esub>\n\ngoal (1 subgoal):\n 1. el_loc_ok1\n     (({0:Class\n           (fst (method P C M))=None; the (snd (snd (snd (method P C M))))},\n       xs),\n      [])", "apply(auto dest!: red_external_new_thread_sees[OF wf] simp add: el_loc_ok1_simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Ta meth Da.\n       \\<lbrakk>typeof_addr (hp s_) a_ = \\<lfloor>T_\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        T_ sees M_: Ts_\\<rightarrow>Tr_ = Native in D_;\n        e'_ = extRet2J (addr a_\\<bullet>M_(map Val vs_)) va_;\n        s'_ = (h'_, lcl s_);\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>ta_\\<rbrace>\\<^bsub>t\\<^esub>;\n        typeof_addr h'_ a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C sees M: []\\<rightarrow>Ta = \\<lfloor>meth\\<rfloor> in Da\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok meth xs\n 2. \\<And>Ta meth Da.\n       \\<lbrakk>typeof_addr (hp s_) a_ = \\<lfloor>T_\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        T_ sees M_: Ts_\\<rightarrow>Tr_ = Native in D_;\n        e'_ = extRet2J (addr a_\\<bullet>M_(map Val vs_)) va_;\n        s'_ = (h'_, lcl s_);\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>ta_\\<rbrace>\\<^bsub>t\\<^esub>;\n        typeof_addr h'_ a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C sees M: []\\<rightarrow>Ta = \\<lfloor>meth\\<rfloor> in Da\\<rbrakk>\n       \\<Longrightarrow> sync_ok meth", "apply(auto dest!: sees_wf_mdecl[OF wf] WT1_not_contains_insync simp add: wf_mdecl_def intro!: el_loc_okI not_contains_insync_sync_ok)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  el_loc_ok1\n   (({0:Class\n         (fst (method P C M))=None; the (snd (snd (snd (method P C M))))},\n     xs),\n    [])\n\ngoal (101 subgoals):\n 1. \\<And>h' aa ha Ca l.\n       \\<lbrakk>(h', aa) \\<in> allocate ha (Class_type Ca);\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem aa\n                                     (Class_type\n Ca)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok1\n                          (({0:Class\n                                (fst (method P C\n M))=None; the (snd (snd (snd (method P C M))))},\n                            xs),\n                           [])\n 2. \\<And>ha Ca l.\n       \\<lbrakk>allocate ha (Class_type Ca) = {};\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok1\n                          (({0:Class\n                                (fst (method P C\n M))=None; the (snd (snd (snd (method P C M))))},\n                            xs),\n                           [])\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        el_loc_ok1\n         (({0:Class\n               (fst (method P C\n                      M))=None; the (snd (snd (snd (method P C M))))},\n           xs),\n          []);\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok1\n                          (({0:Class\n                                (fst (method P C\n M))=None; the (snd (snd (snd (method P C M))))},\n                            xs),\n                           [])\n 4. \\<And>i h' aa ha T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', aa) \\<in> allocate ha (Array_type T (nat (sint i)));\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem aa\n                                     (Array_type T\n (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok1\n                          (({0:Class\n                                (fst (method P C\n M))=None; the (snd (snd (snd (method P C M))))},\n                            xs),\n                           [])\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok1\n                          (({0:Class\n                                (fst (method P C\n M))=None; the (snd (snd (snd (method P C M))))},\n                            xs),\n                           [])\n 6. \\<And>i ha T l.\n       \\<lbrakk>0 \\<le>s i; allocate ha (Array_type T (nat (sint i))) = {};\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok1\n                          (({0:Class\n                                (fst (method P C\n M))=None; the (snd (snd (snd (method P C M))))},\n                            xs),\n                           [])\n 7. \\<And>e s ta e' s' Ca.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        el_loc_ok1\n         (({0:Class\n               (fst (method P C\n                      M))=None; the (snd (snd (snd (method P C M))))},\n           xs),\n          []);\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok1\n                          (({0:Class\n                                (fst (method P C\n M))=None; the (snd (snd (snd (method P C M))))},\n                            xs),\n                           [])\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok1\n                          (({0:Class\n                                (fst (method P C\n M))=None; the (snd (snd (snd (method P C M))))},\n                            xs),\n                           [])\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        NewThread t' (C, M, a) h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> el_loc_ok1\n                          (({0:Class\n                                (fst (method P C\n M))=None; the (snd (snd (snd (method P C M))))},\n                            xs),\n                           [])\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n         NewThread t' (C, M, a) h\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n         el_loc_ok1\n          (({0:Class\n                (fst (method P C\n                       M))=None; the (snd (snd (snd (method P C M))))},\n            xs),\n           []);\n         NewThread t' (C, M, a) h\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> el_loc_ok1\n                           (({0:Class\n                                 (fst (method P C\n  M))=None; the (snd (snd (snd (method P C M))))},\n                             xs),\n                            [])\nA total of 101 subgoals...", "qed auto"], ["", "lemma Red1_el_loc_ok1_new_thread:\n  assumes wf: \"wf_J1_prog P\"\n  shows \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>ex/exs,m\\<rangle> -ta\\<rightarrow> \\<langle>ex'/exs',m'\\<rangle>; NewThread t' exexs m' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n         \\<Longrightarrow> el_loc_ok1 exexs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>ex/exs,\n                                   m\\<rangle> -ta\\<rightarrow>\n                                  \\<langle>ex'/exs',m'\\<rangle>;\n     NewThread t' exexs m'\n     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> el_loc_ok1 exexs", "by(erule Red1.cases)(fastforce elim: red1_el_loc_ok1_new_thread[OF wf] simp add: ta_upd_simps)+"], ["", "lemma Red1_el_loc_ok: \n  assumes wf: \"wf_J1_prog P\"\n  shows \"lifting_wf final_expr1 (mred1g uf P) (\\<lambda>t exexs h. el_loc_ok1 exexs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lifting_wf final_expr1 (mred1g uf P)\n     (\\<lambda>t exexs h. el_loc_ok1 exexs)", "by(unfold_locales)(auto elim: Red1_preserves_el_loc_ok1[OF wf] Red1_el_loc_ok1_new_thread[OF wf])"], ["", "lemma mred1_eq_mred1':\n  assumes lok: \"lock_oks1 (locks s) (thr s)\"\n  and elo: \"ts_ok (\\<lambda>t exexs h. el_loc_ok1 exexs) (thr s) (shr s)\"\n  and tst: \"thr s t = \\<lfloor>(exexs, no_wait_locks)\\<rfloor>\"\n  and aoe: \"Red1_mthr.actions_ok s t ta\"\n  shows \"mred1 P t (exexs, shr s) ta = mred1' P t (exexs, shr s) ta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mred1 P t (exexs, shr s) ta = mred1' P t (exexs, shr s) ta", "proof(intro ext iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       mred1 P t (exexs, shr s) ta x \\<Longrightarrow>\n       mred1' P t (exexs, shr s) ta x\n 2. \\<And>x.\n       mred1' P t (exexs, shr s) ta x \\<Longrightarrow>\n       mred1 P t (exexs, shr s) ta x", "fix xm'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       mred1 P t (exexs, shr s) ta x \\<Longrightarrow>\n       mred1' P t (exexs, shr s) ta x\n 2. \\<And>x.\n       mred1' P t (exexs, shr s) ta x \\<Longrightarrow>\n       mred1 P t (exexs, shr s) ta x", "assume \"mred1 P t (exexs, shr s) ta xm'\""], ["proof (state)\nthis:\n  mred1 P t (exexs, shr s) ta xm'\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       mred1 P t (exexs, shr s) ta x \\<Longrightarrow>\n       mred1' P t (exexs, shr s) ta x\n 2. \\<And>x.\n       mred1' P t (exexs, shr s) ta x \\<Longrightarrow>\n       mred1 P t (exexs, shr s) ta x", "moreover"], ["proof (state)\nthis:\n  mred1 P t (exexs, shr s) ta xm'\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       mred1 P t (exexs, shr s) ta x \\<Longrightarrow>\n       mred1' P t (exexs, shr s) ta x\n 2. \\<And>x.\n       mred1' P t (exexs, shr s) ta x \\<Longrightarrow>\n       mred1 P t (exexs, shr s) ta x", "obtain ex exs where exexs [simp]: \"exexs = (ex, exs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ex exs.\n        exexs = (ex, exs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases exexs)"], ["proof (state)\nthis:\n  exexs = (ex, exs)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       mred1 P t (exexs, shr s) ta x \\<Longrightarrow>\n       mred1' P t (exexs, shr s) ta x\n 2. \\<And>x.\n       mred1' P t (exexs, shr s) ta x \\<Longrightarrow>\n       mred1 P t (exexs, shr s) ta x", "moreover"], ["proof (state)\nthis:\n  exexs = (ex, exs)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       mred1 P t (exexs, shr s) ta x \\<Longrightarrow>\n       mred1' P t (exexs, shr s) ta x\n 2. \\<And>x.\n       mred1' P t (exexs, shr s) ta x \\<Longrightarrow>\n       mred1 P t (exexs, shr s) ta x", "obtain ex' exs' m' where xm' [simp]: \"xm' = ((ex', exs'), m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ex' exs' m'.\n        xm' = ((ex', exs'), m') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases xm') auto"], ["proof (state)\nthis:\n  xm' = ((ex', exs'), m')\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       mred1 P t (exexs, shr s) ta x \\<Longrightarrow>\n       mred1' P t (exexs, shr s) ta x\n 2. \\<And>x.\n       mred1' P t (exexs, shr s) ta x \\<Longrightarrow>\n       mred1 P t (exexs, shr s) ta x", "ultimately"], ["proof (chain)\npicking this:\n  mred1 P t (exexs, shr s) ta xm'\n  exexs = (ex, exs)\n  xm' = ((ex', exs'), m')", "have red: \"True,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow> \\<langle>ex'/exs',m'\\<rangle>\""], ["proof (prove)\nusing this:\n  mred1 P t (exexs, shr s) ta xm'\n  exexs = (ex, exs)\n  xm' = ((ex', exs'), m')\n\ngoal (1 subgoal):\n 1. True,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                           \\<langle>ex'/exs',m'\\<rangle>", "by simp"], ["proof (state)\nthis:\n  True,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                         \\<langle>ex'/exs',m'\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       mred1 P t (exexs, shr s) ta x \\<Longrightarrow>\n       mred1' P t (exexs, shr s) ta x\n 2. \\<And>x.\n       mred1' P t (exexs, shr s) ta x \\<Longrightarrow>\n       mred1 P t (exexs, shr s) ta x", "from elo tst"], ["proof (chain)\npicking this:\n  ts_ok (\\<lambda>t exexs h. el_loc_ok1 exexs) (thr s) (shr s)\n  thr s t = \\<lfloor>(exexs, no_wait_locks)\\<rfloor>", "have \"el_loc_ok1 (ex, exs)\""], ["proof (prove)\nusing this:\n  ts_ok (\\<lambda>t exexs h. el_loc_ok1 exexs) (thr s) (shr s)\n  thr s t = \\<lfloor>(exexs, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. el_loc_ok1 (ex, exs)", "by(auto dest: ts_okD)"], ["proof (state)\nthis:\n  el_loc_ok1 (ex, exs)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       mred1 P t (exexs, shr s) ta x \\<Longrightarrow>\n       mred1' P t (exexs, shr s) ta x\n 2. \\<And>x.\n       mred1' P t (exexs, shr s) ta x \\<Longrightarrow>\n       mred1 P t (exexs, shr s) ta x", "from Red1_True_into_Red1_False[OF red this]"], ["proof (chain)\npicking this:\n  False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                          \\<langle>ex'/exs',m'\\<rangle> \\<or>\n  (\\<exists>l.\n      ta = \\<lbrace>(UnlockFail, l)\\<rbrace> \\<and>\n      0 < expr_lockss (fst ex # map fst exs) l)", "have \"False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow> \\<langle>ex'/exs',m'\\<rangle>\""], ["proof (prove)\nusing this:\n  False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                          \\<langle>ex'/exs',m'\\<rangle> \\<or>\n  (\\<exists>l.\n      ta = \\<lbrace>(UnlockFail, l)\\<rbrace> \\<and>\n      0 < expr_lockss (fst ex # map fst exs) l)\n\ngoal (1 subgoal):\n 1. False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                            \\<langle>ex'/exs',m'\\<rangle>", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                            \\<langle>ex'/exs',m'\\<rangle> \\<Longrightarrow>\n    False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                            \\<langle>ex'/exs',m'\\<rangle>\n 2. \\<exists>l.\n       ta = \\<lbrace>(UnlockFail, l)\\<rbrace> \\<and>\n       0 < expr_lockss (fst ex # map fst exs) l \\<Longrightarrow>\n    False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                            \\<langle>ex'/exs',m'\\<rangle>", "assume \"\\<exists>l. ta = \\<lbrace>UnlockFail\\<rightarrow>l\\<rbrace> \\<and> 0 < expr_lockss (fst ex # map fst exs) l\""], ["proof (state)\nthis:\n  \\<exists>l.\n     ta = \\<lbrace>(UnlockFail, l)\\<rbrace> \\<and>\n     0 < expr_lockss (fst ex # map fst exs) l\n\ngoal (2 subgoals):\n 1. False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                            \\<langle>ex'/exs',m'\\<rangle> \\<Longrightarrow>\n    False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                            \\<langle>ex'/exs',m'\\<rangle>\n 2. \\<exists>l.\n       ta = \\<lbrace>(UnlockFail, l)\\<rbrace> \\<and>\n       0 < expr_lockss (fst ex # map fst exs) l \\<Longrightarrow>\n    False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                            \\<langle>ex'/exs',m'\\<rangle>", "then"], ["proof (chain)\npicking this:\n  \\<exists>l.\n     ta = \\<lbrace>(UnlockFail, l)\\<rbrace> \\<and>\n     0 < expr_lockss (fst ex # map fst exs) l", "obtain l where ta: \"ta = \\<lbrace>UnlockFail\\<rightarrow>l\\<rbrace>\" \n      and el: \"expr_lockss (fst ex # map fst exs) l > 0\""], ["proof (prove)\nusing this:\n  \\<exists>l.\n     ta = \\<lbrace>(UnlockFail, l)\\<rbrace> \\<and>\n     0 < expr_lockss (fst ex # map fst exs) l\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>ta = \\<lbrace>(UnlockFail, l)\\<rbrace>;\n         0 < expr_lockss (fst ex # map fst exs) l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ta = \\<lbrace>(UnlockFail, l)\\<rbrace>\n  0 < expr_lockss (fst ex # map fst exs) l\n\ngoal (2 subgoals):\n 1. False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                            \\<langle>ex'/exs',m'\\<rangle> \\<Longrightarrow>\n    False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                            \\<langle>ex'/exs',m'\\<rangle>\n 2. \\<exists>l.\n       ta = \\<lbrace>(UnlockFail, l)\\<rbrace> \\<and>\n       0 < expr_lockss (fst ex # map fst exs) l \\<Longrightarrow>\n    False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                            \\<langle>ex'/exs',m'\\<rangle>", "from aoe"], ["proof (chain)\npicking this:\n  Red1_mthr.actions_ok s t ta", "have \"lock_actions_ok (locks s $ l) t (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\""], ["proof (prove)\nusing this:\n  Red1_mthr.actions_ok s t ta\n\ngoal (1 subgoal):\n 1. lock_actions_ok (locks s $ l) t\n     (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)", "by(auto simp add: lock_ok_las_def)"], ["proof (state)\nthis:\n  lock_actions_ok (locks s $ l) t\n   (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n\ngoal (2 subgoals):\n 1. False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                            \\<langle>ex'/exs',m'\\<rangle> \\<Longrightarrow>\n    False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                            \\<langle>ex'/exs',m'\\<rangle>\n 2. \\<exists>l.\n       ta = \\<lbrace>(UnlockFail, l)\\<rbrace> \\<and>\n       0 < expr_lockss (fst ex # map fst exs) l \\<Longrightarrow>\n    False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                            \\<langle>ex'/exs',m'\\<rangle>", "with ta"], ["proof (chain)\npicking this:\n  ta = \\<lbrace>(UnlockFail, l)\\<rbrace>\n  lock_actions_ok (locks s $ l) t\n   (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)", "have \"has_locks (locks s $ l) t = 0\""], ["proof (prove)\nusing this:\n  ta = \\<lbrace>(UnlockFail, l)\\<rbrace>\n  lock_actions_ok (locks s $ l) t\n   (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n\ngoal (1 subgoal):\n 1. has_locks (locks s $ l) t = 0", "by simp"], ["proof (state)\nthis:\n  has_locks (locks s $ l) t = 0\n\ngoal (2 subgoals):\n 1. False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                            \\<langle>ex'/exs',m'\\<rangle> \\<Longrightarrow>\n    False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                            \\<langle>ex'/exs',m'\\<rangle>\n 2. \\<exists>l.\n       ta = \\<lbrace>(UnlockFail, l)\\<rbrace> \\<and>\n       0 < expr_lockss (fst ex # map fst exs) l \\<Longrightarrow>\n    False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                            \\<langle>ex'/exs',m'\\<rangle>", "with lok tst"], ["proof (chain)\npicking this:\n  lock_oks1 (locks s) (thr s)\n  thr s t = \\<lfloor>(exexs, no_wait_locks)\\<rfloor>\n  has_locks (locks s $ l) t = 0", "have \"expr_lockss (map fst (ex # exs)) l = 0\""], ["proof (prove)\nusing this:\n  lock_oks1 (locks s) (thr s)\n  thr s t = \\<lfloor>(exexs, no_wait_locks)\\<rfloor>\n  has_locks (locks s $ l) t = 0\n\ngoal (1 subgoal):\n 1. expr_lockss (map fst (ex # exs)) l = 0", "by(cases ex)(auto 4 6 simp add: lock_oks1_def)"], ["proof (state)\nthis:\n  expr_lockss (map fst (ex # exs)) l = 0\n\ngoal (2 subgoals):\n 1. False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                            \\<langle>ex'/exs',m'\\<rangle> \\<Longrightarrow>\n    False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                            \\<langle>ex'/exs',m'\\<rangle>\n 2. \\<exists>l.\n       ta = \\<lbrace>(UnlockFail, l)\\<rbrace> \\<and>\n       0 < expr_lockss (fst ex # map fst exs) l \\<Longrightarrow>\n    False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                            \\<langle>ex'/exs',m'\\<rangle>", "with el"], ["proof (chain)\npicking this:\n  0 < expr_lockss (fst ex # map fst exs) l\n  expr_lockss (map fst (ex # exs)) l = 0", "have False"], ["proof (prove)\nusing this:\n  0 < expr_lockss (fst ex # map fst exs) l\n  expr_lockss (map fst (ex # exs)) l = 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                            \\<langle>ex'/exs',m'\\<rangle> \\<Longrightarrow>\n    False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                            \\<langle>ex'/exs',m'\\<rangle>\n 2. \\<exists>l.\n       ta = \\<lbrace>(UnlockFail, l)\\<rbrace> \\<and>\n       0 < expr_lockss (fst ex # map fst exs) l \\<Longrightarrow>\n    False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                            \\<langle>ex'/exs',m'\\<rangle>", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                            \\<langle>ex'/exs',m'\\<rangle>", ".."], ["proof (state)\nthis:\n  False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                          \\<langle>ex'/exs',m'\\<rangle>\n\ngoal (1 subgoal):\n 1. False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                            \\<langle>ex'/exs',m'\\<rangle> \\<Longrightarrow>\n    False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                            \\<langle>ex'/exs',m'\\<rangle>", "qed"], ["proof (state)\nthis:\n  False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                          \\<langle>ex'/exs',m'\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       mred1 P t (exexs, shr s) ta x \\<Longrightarrow>\n       mred1' P t (exexs, shr s) ta x\n 2. \\<And>x.\n       mred1' P t (exexs, shr s) ta x \\<Longrightarrow>\n       mred1 P t (exexs, shr s) ta x", "thus \"mred1' P t (exexs, shr s) ta xm'\""], ["proof (prove)\nusing this:\n  False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                          \\<langle>ex'/exs',m'\\<rangle>\n\ngoal (1 subgoal):\n 1. mred1' P t (exexs, shr s) ta xm'", "by simp"], ["proof (state)\nthis:\n  mred1' P t (exexs, shr s) ta xm'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       mred1' P t (exexs, shr s) ta x \\<Longrightarrow>\n       mred1 P t (exexs, shr s) ta x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       mred1' P t (exexs, shr s) ta x \\<Longrightarrow>\n       mred1 P t (exexs, shr s) ta x", "fix xm'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       mred1' P t (exexs, shr s) ta x \\<Longrightarrow>\n       mred1 P t (exexs, shr s) ta x", "assume \"mred1' P t (exexs, shr s) ta xm'\""], ["proof (state)\nthis:\n  mred1' P t (exexs, shr s) ta xm'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       mred1' P t (exexs, shr s) ta x \\<Longrightarrow>\n       mred1 P t (exexs, shr s) ta x", "thus \"mred1 P t (exexs, shr s) ta xm'\""], ["proof (prove)\nusing this:\n  mred1' P t (exexs, shr s) ta xm'\n\ngoal (1 subgoal):\n 1. mred1 P t (exexs, shr s) ta xm'", "by(cases xm')(auto simp add: split_beta intro: Red1_False_into_Red1_True)"], ["proof (state)\nthis:\n  mred1 P t (exexs, shr s) ta xm'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Red1_mthr_eq_Red1_mthr':\n  assumes lok: \"lock_oks1 (locks s) (thr s)\"\n  and elo: \"ts_ok (\\<lambda>t exexs h. el_loc_ok1 exexs) (thr s) (shr s)\"\n  shows \"Red1_mthr.redT True P s = Red1_mthr.redT False P s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Red1_mthr.redT True P s = Red1_mthr.redT False P s", "proof(intro ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. Red1_mthr.redT True P s x xa = Red1_mthr.redT False P s x xa", "fix tta s'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. Red1_mthr.redT True P s x xa = Red1_mthr.redT False P s x xa", "show \"Red1_mthr.redT True P s tta s' = Red1_mthr.redT False P s tta s'\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Red1_mthr.redT True P s tta s' = Red1_mthr.redT False P s tta s'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. Red1_mthr.redT True P s tta s' \\<Longrightarrow>\n    Red1_mthr.redT False P s tta s'\n 2. Red1_mthr.redT False P s tta s' \\<Longrightarrow>\n    Red1_mthr.redT True P s tta s'", "assume \"?lhs\""], ["proof (state)\nthis:\n  Red1_mthr.redT True P s tta s'\n\ngoal (2 subgoals):\n 1. Red1_mthr.redT True P s tta s' \\<Longrightarrow>\n    Red1_mthr.redT False P s tta s'\n 2. Red1_mthr.redT False P s tta s' \\<Longrightarrow>\n    Red1_mthr.redT True P s tta s'", "thus ?rhs"], ["proof (prove)\nusing this:\n  Red1_mthr.redT True P s tta s'\n\ngoal (1 subgoal):\n 1. Red1_mthr.redT False P s tta s'", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>tta = (t, ta);\n        Red1_mthr.r_syntax True P t x (shr s) ta x' m';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.actions_ok s t ta; redT_upd s t ta x' m' s'\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.redT False P s tta s'\n 2. \\<And>t x n ln.\n       \\<lbrakk>tta = (t, K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.redT False P s tta s'", "case (redT_normal t x ta x' m')"], ["proof (state)\nthis:\n  tta = (t, ta)\n  Red1_mthr.r_syntax True P t x (shr s) ta x' m'\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  Red1_mthr.actions_ok s t ta\n  redT_upd s t ta x' m' s'\n\ngoal (2 subgoals):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>tta = (t, ta);\n        Red1_mthr.r_syntax True P t x (shr s) ta x' m';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.actions_ok s t ta; redT_upd s t ta x' m' s'\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.redT False P s tta s'\n 2. \\<And>t x n ln.\n       \\<lbrakk>tta = (t, K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.redT False P s tta s'", "from \\<open>mred1 P t (x, shr s) ta (x', m')\\<close>"], ["proof (chain)\npicking this:\n  Red1_mthr.r_syntax True P t x (shr s) ta x' m'", "have \"mred1' P t (x, shr s) ta (x', m')\""], ["proof (prove)\nusing this:\n  Red1_mthr.r_syntax True P t x (shr s) ta x' m'\n\ngoal (1 subgoal):\n 1. Red1_mthr.r_syntax False P t x (shr s) ta x' m'", "unfolding mred1_eq_mred1'[OF lok elo \\<open>thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<close> \\<open>Red1_mthr.actions_ok s t ta\\<close>]"], ["proof (prove)\nusing this:\n  Red1_mthr.r_syntax False P t x (shr s) ta x' m'\n\ngoal (1 subgoal):\n 1. Red1_mthr.r_syntax False P t x (shr s) ta x' m'", "."], ["proof (state)\nthis:\n  Red1_mthr.r_syntax False P t x (shr s) ta x' m'\n\ngoal (2 subgoals):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>tta = (t, ta);\n        Red1_mthr.r_syntax True P t x (shr s) ta x' m';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.actions_ok s t ta; redT_upd s t ta x' m' s'\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.redT False P s tta s'\n 2. \\<And>t x n ln.\n       \\<lbrakk>tta = (t, K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.redT False P s tta s'", "thus ?thesis"], ["proof (prove)\nusing this:\n  Red1_mthr.r_syntax False P t x (shr s) ta x' m'\n\ngoal (1 subgoal):\n 1. Red1_mthr.redT False P s tta s'", "using redT_normal(3-)"], ["proof (prove)\nusing this:\n  Red1_mthr.r_syntax False P t x (shr s) ta x' m'\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  Red1_mthr.actions_ok s t ta\n  redT_upd s t ta x' m' s'\n\ngoal (1 subgoal):\n 1. Red1_mthr.redT False P s tta s'", "unfolding \\<open>tta = (t, ta)\\<close>"], ["proof (prove)\nusing this:\n  Red1_mthr.r_syntax False P t x (shr s) ta x' m'\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  Red1_mthr.actions_ok s t ta\n  redT_upd s t ta x' m' s'\n\ngoal (1 subgoal):\n 1. Red1_mthr.redT_syntax1 False P s t ta s'", ".."], ["proof (state)\nthis:\n  Red1_mthr.redT False P s tta s'\n\ngoal (1 subgoal):\n 1. \\<And>t x n ln.\n       \\<lbrakk>tta = (t, K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.redT False P s tta s'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t x n ln.\n       \\<lbrakk>tta = (t, K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.redT False P s tta s'", "case (redT_acquire t x ln n)"], ["proof (state)\nthis:\n  tta = (t, K$ [], [], [], [], [], convert_RA n)\n  thr s t = \\<lfloor>(x, n)\\<rfloor>\n  \\<not> waiting (wset s t)\n  may_acquire_all (locks s) t n\n  0 < n $ ln\n  s' =\n  (acquire_all (locks s) t n,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)\n\ngoal (1 subgoal):\n 1. \\<And>t x n ln.\n       \\<lbrakk>tta = (t, K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.redT False P s tta s'", "from this(2-)"], ["proof (chain)\npicking this:\n  thr s t = \\<lfloor>(x, n)\\<rfloor>\n  \\<not> waiting (wset s t)\n  may_acquire_all (locks s) t n\n  0 < n $ ln\n  s' =\n  (acquire_all (locks s) t n,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)", "show ?thesis"], ["proof (prove)\nusing this:\n  thr s t = \\<lfloor>(x, n)\\<rfloor>\n  \\<not> waiting (wset s t)\n  may_acquire_all (locks s) t n\n  0 < n $ ln\n  s' =\n  (acquire_all (locks s) t n,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)\n\ngoal (1 subgoal):\n 1. Red1_mthr.redT False P s tta s'", "unfolding redT_acquire(1)"], ["proof (prove)\nusing this:\n  thr s t = \\<lfloor>(x, n)\\<rfloor>\n  \\<not> waiting (wset s t)\n  may_acquire_all (locks s) t n\n  0 < n $ ln\n  s' =\n  (acquire_all (locks s) t n,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)\n\ngoal (1 subgoal):\n 1. Red1_mthr.redT_syntax1 False P s t (K$ [], [], [], [], [], convert_RA n)\n     s'", ".."], ["proof (state)\nthis:\n  Red1_mthr.redT False P s tta s'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Red1_mthr.redT False P s tta s'\n\ngoal (1 subgoal):\n 1. Red1_mthr.redT False P s tta s' \\<Longrightarrow>\n    Red1_mthr.redT True P s tta s'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Red1_mthr.redT False P s tta s' \\<Longrightarrow>\n    Red1_mthr.redT True P s tta s'", "assume ?rhs"], ["proof (state)\nthis:\n  Red1_mthr.redT False P s tta s'\n\ngoal (1 subgoal):\n 1. Red1_mthr.redT False P s tta s' \\<Longrightarrow>\n    Red1_mthr.redT True P s tta s'", "thus ?lhs"], ["proof (prove)\nusing this:\n  Red1_mthr.redT False P s tta s'\n\ngoal (1 subgoal):\n 1. Red1_mthr.redT True P s tta s'", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>tta = (t, ta);\n        Red1_mthr.r_syntax False P t x (shr s) ta x' m';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.actions_ok s t ta; redT_upd s t ta x' m' s'\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.redT True P s tta s'\n 2. \\<And>t x n ln.\n       \\<lbrakk>tta = (t, K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.redT True P s tta s'", "case (redT_normal t x ta x' m')"], ["proof (state)\nthis:\n  tta = (t, ta)\n  Red1_mthr.r_syntax False P t x (shr s) ta x' m'\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  Red1_mthr.actions_ok s t ta\n  redT_upd s t ta x' m' s'\n\ngoal (2 subgoals):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>tta = (t, ta);\n        Red1_mthr.r_syntax False P t x (shr s) ta x' m';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.actions_ok s t ta; redT_upd s t ta x' m' s'\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.redT True P s tta s'\n 2. \\<And>t x n ln.\n       \\<lbrakk>tta = (t, K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.redT True P s tta s'", "from \\<open>mred1' P t (x, shr s) ta (x', m')\\<close>"], ["proof (chain)\npicking this:\n  Red1_mthr.r_syntax False P t x (shr s) ta x' m'", "have \"mred1 P t (x, shr s) ta (x', m')\""], ["proof (prove)\nusing this:\n  Red1_mthr.r_syntax False P t x (shr s) ta x' m'\n\ngoal (1 subgoal):\n 1. Red1_mthr.r_syntax True P t x (shr s) ta x' m'", "unfolding mred1_eq_mred1'[OF lok elo \\<open>thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<close> \\<open>Red1_mthr.actions_ok s t ta\\<close>]"], ["proof (prove)\nusing this:\n  Red1_mthr.r_syntax False P t x (shr s) ta x' m'\n\ngoal (1 subgoal):\n 1. Red1_mthr.r_syntax False P t x (shr s) ta x' m'", "."], ["proof (state)\nthis:\n  Red1_mthr.r_syntax True P t x (shr s) ta x' m'\n\ngoal (2 subgoals):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>tta = (t, ta);\n        Red1_mthr.r_syntax False P t x (shr s) ta x' m';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.actions_ok s t ta; redT_upd s t ta x' m' s'\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.redT True P s tta s'\n 2. \\<And>t x n ln.\n       \\<lbrakk>tta = (t, K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.redT True P s tta s'", "thus ?thesis"], ["proof (prove)\nusing this:\n  Red1_mthr.r_syntax True P t x (shr s) ta x' m'\n\ngoal (1 subgoal):\n 1. Red1_mthr.redT True P s tta s'", "using redT_normal(3-)"], ["proof (prove)\nusing this:\n  Red1_mthr.r_syntax True P t x (shr s) ta x' m'\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  Red1_mthr.actions_ok s t ta\n  redT_upd s t ta x' m' s'\n\ngoal (1 subgoal):\n 1. Red1_mthr.redT True P s tta s'", "unfolding \\<open>tta = (t, ta)\\<close>"], ["proof (prove)\nusing this:\n  Red1_mthr.r_syntax True P t x (shr s) ta x' m'\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  Red1_mthr.actions_ok s t ta\n  redT_upd s t ta x' m' s'\n\ngoal (1 subgoal):\n 1. Red1_mthr.redT_syntax1 True P s t ta s'", ".."], ["proof (state)\nthis:\n  Red1_mthr.redT True P s tta s'\n\ngoal (1 subgoal):\n 1. \\<And>t x n ln.\n       \\<lbrakk>tta = (t, K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.redT True P s tta s'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t x n ln.\n       \\<lbrakk>tta = (t, K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.redT True P s tta s'", "case (redT_acquire t x ln n)"], ["proof (state)\nthis:\n  tta = (t, K$ [], [], [], [], [], convert_RA n)\n  thr s t = \\<lfloor>(x, n)\\<rfloor>\n  \\<not> waiting (wset s t)\n  may_acquire_all (locks s) t n\n  0 < n $ ln\n  s' =\n  (acquire_all (locks s) t n,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)\n\ngoal (1 subgoal):\n 1. \\<And>t x n ln.\n       \\<lbrakk>tta = (t, K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.redT True P s tta s'", "from this(2-)"], ["proof (chain)\npicking this:\n  thr s t = \\<lfloor>(x, n)\\<rfloor>\n  \\<not> waiting (wset s t)\n  may_acquire_all (locks s) t n\n  0 < n $ ln\n  s' =\n  (acquire_all (locks s) t n,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)", "show ?thesis"], ["proof (prove)\nusing this:\n  thr s t = \\<lfloor>(x, n)\\<rfloor>\n  \\<not> waiting (wset s t)\n  may_acquire_all (locks s) t n\n  0 < n $ ln\n  s' =\n  (acquire_all (locks s) t n,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)\n\ngoal (1 subgoal):\n 1. Red1_mthr.redT True P s tta s'", "unfolding redT_acquire(1)"], ["proof (prove)\nusing this:\n  thr s t = \\<lfloor>(x, n)\\<rfloor>\n  \\<not> waiting (wset s t)\n  may_acquire_all (locks s) t n\n  0 < n $ ln\n  s' =\n  (acquire_all (locks s) t n,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)\n\ngoal (1 subgoal):\n 1. Red1_mthr.redT_syntax1 True P s t (K$ [], [], [], [], [], convert_RA n)\n     s'", ".."], ["proof (state)\nthis:\n  Red1_mthr.redT True P s tta s'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Red1_mthr.redT True P s tta s'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Red1_mthr.redT True P s tta s' = Red1_mthr.redT False P s tta s'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma assumes wf: \"wf_J1_prog P\"\n  shows expr_locks_new_thread1:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -TA\\<rightarrow> \\<langle>e',s'\\<rangle>; NewThread t' (ex, exs) h \\<in> set (map (convert_new_thread_action (extNTA2J1 P)) \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>) \\<rbrakk>\n  \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\"\n  and expr_lockss_new_thread1:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es,s\\<rangle> [-TA\\<rightarrow>] \\<langle>es',s'\\<rangle>; NewThread t' (ex, exs) h \\<in> set (map (convert_new_thread_action (extNTA2J1 P)) \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>) \\<rbrakk>\n  \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -TA\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle>;\n      NewThread t' (ex, exs) h\n      \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                  \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n     \\<Longrightarrow> expr_lockss (map fst (ex # exs)) =\n                       (\\<lambda>ad. 0)) &&&\n    (\\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>es,s\\<rangle> [-TA\\<rightarrow>]\n                                   \\<langle>es',s'\\<rangle>;\n      NewThread t' (ex, exs) h\n      \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                  \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n     \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0))", "proof(induct rule: red1_reds1.inducts)"], ["proof (state)\ngoal (102 subgoals):\n 1. \\<And>h' a ha C l.\n       \\<lbrakk>(h', a) \\<in> allocate ha (Class_type C);\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>NewHeapElem a\n (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 2. \\<And>ha C l.\n       \\<lbrakk>allocate ha (Class_type C) = {};\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) \\<Longrightarrow>\n        expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0);\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 4. \\<And>i h' a ha T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate ha (Array_type T (nat (sint i)));\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>NewHeapElem a\n (Array_type T (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 6. \\<And>i ha T l.\n       \\<lbrakk>0 \\<le>s i; allocate ha (Array_type T (nat (sint i))) = {};\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) \\<Longrightarrow>\n        expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0);\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n         NewThread t' (ex, exs) h\n         \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) \\<Longrightarrow>\n         expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0);\n         NewThread t' (ex, exs) h\n         \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n        \\<Longrightarrow> expr_lockss (map fst (ex # exs)) =\n                          (\\<lambda>ad. 0)\nA total of 102 subgoals...", "case (Red1CallExternal s a T M vs ta va h' e' s')"], ["proof (state)\nthis:\n  typeof_addr (hp s) a = \\<lfloor>T\\<rfloor>\n  P \\<turnstile> class_type_of T sees M: vs\\<rightarrow>ta = Native in va\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(h'),\n                   hp s\\<rangle> -e'\\<rightarrow>ext \\<langle>s',\n               h'_\\<rangle>\n  e'_ = extRet2J (addr a\\<bullet>M(map Val h')) s'\n  s'_ = (h'_, lcl s)\n  NewThread t' (ex, exs) h\n  \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n              \\<lbrace>e'\\<rbrace>\\<^bsub>t\\<^esub>)\n\ngoal (102 subgoals):\n 1. \\<And>h' a ha C l.\n       \\<lbrakk>(h', a) \\<in> allocate ha (Class_type C);\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>NewHeapElem a\n (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 2. \\<And>ha C l.\n       \\<lbrakk>allocate ha (Class_type C) = {};\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) \\<Longrightarrow>\n        expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0);\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 4. \\<And>i h' a ha T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate ha (Array_type T (nat (sint i)));\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>NewHeapElem a\n (Array_type T (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 6. \\<And>i ha T l.\n       \\<lbrakk>0 \\<le>s i; allocate ha (Array_type T (nat (sint i))) = {};\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) \\<Longrightarrow>\n        expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0);\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n         NewThread t' (ex, exs) h\n         \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) \\<Longrightarrow>\n         expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0);\n         NewThread t' (ex, exs) h\n         \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n        \\<Longrightarrow> expr_lockss (map fst (ex # exs)) =\n                          (\\<lambda>ad. 0)\nA total of 102 subgoals...", "then"], ["proof (chain)\npicking this:\n  typeof_addr (hp s) a = \\<lfloor>T\\<rfloor>\n  P \\<turnstile> class_type_of T sees M: vs\\<rightarrow>ta = Native in va\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(h'),\n                   hp s\\<rangle> -e'\\<rightarrow>ext \\<langle>s',\n               h'_\\<rangle>\n  e'_ = extRet2J (addr a\\<bullet>M(map Val h')) s'\n  s'_ = (h'_, lcl s)\n  NewThread t' (ex, exs) h\n  \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n              \\<lbrace>e'\\<rbrace>\\<^bsub>t\\<^esub>)", "obtain C fs ad where subThread: \"P \\<turnstile> C \\<preceq>\\<^sup>* Thread\" and ext: \"extNTA2J1 P (C, run, ad) = (ex, exs)\""], ["proof (prove)\nusing this:\n  typeof_addr (hp s) a = \\<lfloor>T\\<rfloor>\n  P \\<turnstile> class_type_of T sees M: vs\\<rightarrow>ta = Native in va\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(h'),\n                   hp s\\<rangle> -e'\\<rightarrow>ext \\<langle>s',\n               h'_\\<rangle>\n  e'_ = extRet2J (addr a\\<bullet>M(map Val h')) s'\n  s'_ = (h'_, lcl s)\n  NewThread t' (ex, exs) h\n  \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n              \\<lbrace>e'\\<rbrace>\\<^bsub>t\\<^esub>)\n\ngoal (1 subgoal):\n 1. (\\<And>C ad.\n        \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* Thread;\n         extNTA2J1 P (C, run, ad) = (ex, exs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest: red_external_new_thread_sub_thread)"], ["proof (state)\nthis:\n  P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n  extNTA2J1 P (C, run, ad) = (ex, exs)\n\ngoal (102 subgoals):\n 1. \\<And>h' a ha C l.\n       \\<lbrakk>(h', a) \\<in> allocate ha (Class_type C);\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>NewHeapElem a\n (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 2. \\<And>ha C l.\n       \\<lbrakk>allocate ha (Class_type C) = {};\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) \\<Longrightarrow>\n        expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0);\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 4. \\<And>i h' a ha T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate ha (Array_type T (nat (sint i)));\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>NewHeapElem a\n (Array_type T (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 6. \\<And>i ha T l.\n       \\<lbrakk>0 \\<le>s i; allocate ha (Array_type T (nat (sint i))) = {};\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) \\<Longrightarrow>\n        expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0);\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n         NewThread t' (ex, exs) h\n         \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) \\<Longrightarrow>\n         expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0);\n         NewThread t' (ex, exs) h\n         \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n        \\<Longrightarrow> expr_lockss (map fst (ex # exs)) =\n                          (\\<lambda>ad. 0)\nA total of 102 subgoals...", "from sub_Thread_sees_run[OF wf subThread]"], ["proof (chain)\npicking this:\n  \\<exists>D mthd.\n     P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>mthd\\<rfloor> in D", "obtain D body\n    where sees: \"P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>body\\<rfloor> in D\""], ["proof (prove)\nusing this:\n  \\<exists>D mthd.\n     P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>mthd\\<rfloor> in D\n\ngoal (1 subgoal):\n 1. (\\<And>body D.\n        P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>body\\<rfloor> in D \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>body\\<rfloor> in D\n\ngoal (102 subgoals):\n 1. \\<And>h' a ha C l.\n       \\<lbrakk>(h', a) \\<in> allocate ha (Class_type C);\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>NewHeapElem a\n (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 2. \\<And>ha C l.\n       \\<lbrakk>allocate ha (Class_type C) = {};\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) \\<Longrightarrow>\n        expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0);\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 4. \\<And>i h' a ha T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate ha (Array_type T (nat (sint i)));\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>NewHeapElem a\n (Array_type T (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 6. \\<And>i ha T l.\n       \\<lbrakk>0 \\<le>s i; allocate ha (Array_type T (nat (sint i))) = {};\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) \\<Longrightarrow>\n        expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0);\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n         NewThread t' (ex, exs) h\n         \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) \\<Longrightarrow>\n         expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0);\n         NewThread t' (ex, exs) h\n         \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n        \\<Longrightarrow> expr_lockss (map fst (ex # exs)) =\n                          (\\<lambda>ad. 0)\nA total of 102 subgoals...", "from sees_wf_mdecl[OF wf this]"], ["proof (chain)\npicking this:\n  wf_mdecl wf_J1_mdecl P D (run, [], Void, \\<lfloor>body\\<rfloor>)", "obtain T where \"P,[Class D] \\<turnstile>1 body :: T\""], ["proof (prove)\nusing this:\n  wf_mdecl wf_J1_mdecl P D (run, [], Void, \\<lfloor>body\\<rfloor>)\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        P,[Class D] \\<turnstile>1 body :: T \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: wf_mdecl_def)"], ["proof (state)\nthis:\n  P,[Class D] \\<turnstile>1 body :: T\n\ngoal (102 subgoals):\n 1. \\<And>h' a ha C l.\n       \\<lbrakk>(h', a) \\<in> allocate ha (Class_type C);\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>NewHeapElem a\n (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 2. \\<And>ha C l.\n       \\<lbrakk>allocate ha (Class_type C) = {};\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) \\<Longrightarrow>\n        expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0);\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 4. \\<And>i h' a ha T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate ha (Array_type T (nat (sint i)));\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>NewHeapElem a\n (Array_type T (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 6. \\<And>i ha T l.\n       \\<lbrakk>0 \\<le>s i; allocate ha (Array_type T (nat (sint i))) = {};\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) \\<Longrightarrow>\n        expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0);\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n         NewThread t' (ex, exs) h\n         \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) \\<Longrightarrow>\n         expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0);\n         NewThread t' (ex, exs) h\n         \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n        \\<Longrightarrow> expr_lockss (map fst (ex # exs)) =\n                          (\\<lambda>ad. 0)\nA total of 102 subgoals...", "hence \"\\<not> contains_insync body\""], ["proof (prove)\nusing this:\n  P,[Class D] \\<turnstile>1 body :: T\n\ngoal (1 subgoal):\n 1. \\<not> contains_insync body", "by(rule WT1_not_contains_insync)"], ["proof (state)\nthis:\n  \\<not> contains_insync body\n\ngoal (102 subgoals):\n 1. \\<And>h' a ha C l.\n       \\<lbrakk>(h', a) \\<in> allocate ha (Class_type C);\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>NewHeapElem a\n (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 2. \\<And>ha C l.\n       \\<lbrakk>allocate ha (Class_type C) = {};\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) \\<Longrightarrow>\n        expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0);\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 4. \\<And>i h' a ha T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate ha (Array_type T (nat (sint i)));\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>NewHeapElem a\n (Array_type T (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 6. \\<And>i ha T l.\n       \\<lbrakk>0 \\<le>s i; allocate ha (Array_type T (nat (sint i))) = {};\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) \\<Longrightarrow>\n        expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0);\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n         NewThread t' (ex, exs) h\n         \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) \\<Longrightarrow>\n         expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0);\n         NewThread t' (ex, exs) h\n         \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n        \\<Longrightarrow> expr_lockss (map fst (ex # exs)) =\n                          (\\<lambda>ad. 0)\nA total of 102 subgoals...", "hence \"expr_locks body = (\\<lambda>ad. 0)\""], ["proof (prove)\nusing this:\n  \\<not> contains_insync body\n\ngoal (1 subgoal):\n 1. expr_locks body = (\\<lambda>ad. 0)", "by(auto simp add: contains_insync_conv fun_eq_iff)"], ["proof (state)\nthis:\n  expr_locks body = (\\<lambda>ad. 0)\n\ngoal (102 subgoals):\n 1. \\<And>h' a ha C l.\n       \\<lbrakk>(h', a) \\<in> allocate ha (Class_type C);\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>NewHeapElem a\n (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 2. \\<And>ha C l.\n       \\<lbrakk>allocate ha (Class_type C) = {};\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) \\<Longrightarrow>\n        expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0);\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 4. \\<And>i h' a ha T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate ha (Array_type T (nat (sint i)));\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>NewHeapElem a\n (Array_type T (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 6. \\<And>i ha T l.\n       \\<lbrakk>0 \\<le>s i; allocate ha (Array_type T (nat (sint i))) = {};\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) \\<Longrightarrow>\n        expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0);\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n         NewThread t' (ex, exs) h\n         \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) \\<Longrightarrow>\n         expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0);\n         NewThread t' (ex, exs) h\n         \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n        \\<Longrightarrow> expr_lockss (map fst (ex # exs)) =\n                          (\\<lambda>ad. 0)\nA total of 102 subgoals...", "with sees ext"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>body\\<rfloor> in D\n  extNTA2J1 P (C, run, ad) = (ex, exs)\n  expr_locks body = (\\<lambda>ad. 0)", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>body\\<rfloor> in D\n  extNTA2J1 P (C, run, ad) = (ex, exs)\n  expr_locks body = (\\<lambda>ad. 0)\n\ngoal (1 subgoal):\n 1. expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)", "by(auto)"], ["proof (state)\nthis:\n  expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n\ngoal (101 subgoals):\n 1. \\<And>h' a ha C l.\n       \\<lbrakk>(h', a) \\<in> allocate ha (Class_type C);\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>NewHeapElem a\n (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 2. \\<And>ha C l.\n       \\<lbrakk>allocate ha (Class_type C) = {};\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) \\<Longrightarrow>\n        expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0);\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 4. \\<And>i h' a ha T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate ha (Array_type T (nat (sint i)));\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>NewHeapElem a\n (Array_type T (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 6. \\<And>i ha T l.\n       \\<lbrakk>0 \\<le>s i; allocate ha (Array_type T (nat (sint i))) = {};\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) \\<Longrightarrow>\n        expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0);\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        NewThread t' (ex, exs) h\n        \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n         NewThread t' (ex, exs) h\n         \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) \\<Longrightarrow>\n         expr_lockss (map fst (ex # exs)) = (\\<lambda>ad. 0);\n         NewThread t' (ex, exs) h\n         \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>)\\<rbrakk>\n        \\<Longrightarrow> expr_lockss (map fst (ex # exs)) =\n                          (\\<lambda>ad. 0)\nA total of 101 subgoals...", "qed auto"], ["", "lemma assumes wf: \"wf_J1_prog P\"\n  shows red1_update_expr_locks:\n  \"\\<lbrakk> False,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; sync_ok e; el_loc_ok e (lcl s) \\<rbrakk>\n  \\<Longrightarrow> upd_expr_locks (int o expr_locks e) \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = int o expr_locks e'\"\n\n  and reds1_update_expr_lockss:\n  \"\\<lbrakk> False,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; sync_oks es; els_loc_ok es (lcl s) \\<rbrakk>\n  \\<Longrightarrow> upd_expr_locks (int o expr_lockss es) \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = int o expr_lockss es'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n      sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n     \\<Longrightarrow> upd_expr_locks (int \\<circ> expr_locks e)\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                       int \\<circ> expr_locks e') &&&\n    (\\<lbrakk>False,P,t \\<turnstile>1 \\<langle>es,\n s\\<rangle> [-ta\\<rightarrow>]\n\\<langle>es',s'\\<rangle>;\n      sync_oks es; els_loc_ok es (lcl s)\\<rbrakk>\n     \\<Longrightarrow> upd_expr_locks (int \\<circ> expr_lockss es)\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                       int \\<circ> expr_lockss es')", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n     sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n    \\<Longrightarrow> upd_expr_locks (int \\<circ> expr_locks e)\n                       \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                      int \\<circ> expr_locks e'\n 2. \\<lbrakk>False,P,t \\<turnstile>1 \\<langle>es,\ns\\<rangle> [-ta\\<rightarrow>]\n                                     \\<langle>es',s'\\<rangle>;\n     sync_oks es; els_loc_ok es (lcl s)\\<rbrakk>\n    \\<Longrightarrow> upd_expr_locks (int \\<circ> expr_lockss es)\n                       \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                      int \\<circ> expr_lockss es'", "have \"\\<lbrakk> False,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; sync_ok e; el_loc_ok e (lcl s) \\<rbrakk> \n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0) \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = (\\<lambda>ad. (int o expr_locks e') ad - (int o expr_locks e) ad)\"\n    and \"\\<lbrakk> False,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; sync_oks es; els_loc_ok es (lcl s) \\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0) \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = (\\<lambda>ad. (int o expr_lockss es') ad - (int o expr_lockss es) ad)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n      sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n     \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                       (\\<lambda>ad.\n                           (int \\<circ> expr_locks e') ad -\n                           (int \\<circ> expr_locks e) ad)) &&&\n    (\\<lbrakk>False,P,t \\<turnstile>1 \\<langle>es,\n s\\<rangle> [-ta\\<rightarrow>]\n\\<langle>es',s'\\<rangle>;\n      sync_oks es; els_loc_ok es (lcl s)\\<rbrakk>\n     \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                       (\\<lambda>ad.\n                           (int \\<circ> expr_lockss es') ad -\n                           (int \\<circ> expr_lockss es) ad))", "proof(induct rule: red1_reds1.inducts)"], ["proof (state)\ngoal (102 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C); sync_ok (new C);\n        el_loc_ok (new C) (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (addr a)) ad -\n                             (int \\<circ> expr_locks (new C)) ad)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {}; sync_ok (new C);\n        el_loc_ok (new C) (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt OutOfMemory)))\n                              ad -\n                             (int \\<circ> expr_locks (new C)) ad)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>False,P,t \\<turnstile>1 \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n        \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                          (\\<lambda>ad.\n                              (int \\<circ> expr_locks e') ad -\n                              (int \\<circ> expr_locks e) ad);\n        sync_ok (newA T\\<lfloor>e\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>e\\<rceil>) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks (newA T\\<lfloor>e'\\<rceil>))\n                              ad -\n                             (int \\<circ>\n                              expr_locks (newA T\\<lfloor>e\\<rceil>))\n                              ad)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n         (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>NewHeapElem a\n       (Array_type T (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (addr a)) ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0; sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt NegativeArraySize)))\n                              ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n         (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt OutOfMemory)))\n                              ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>False,P,t \\<turnstile>1 \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n        \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                          (\\<lambda>ad.\n                              (int \\<circ> expr_locks e') ad -\n                              (int \\<circ> expr_locks e) ad);\n        sync_ok (Cast C e); el_loc_ok (Cast C e) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (Cast C e')) ad -\n                             (int \\<circ> expr_locks (Cast C e)) ad)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v));\n        el_loc_ok (Cast T (Val v)) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (Val v)) ad -\n                             (int \\<circ> expr_locks (Cast T (Val v))) ad)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v));\n        el_loc_ok (Cast T (Val v)) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt ClassCast)))\n                              ad -\n                             (int \\<circ> expr_locks (Cast T (Val v))) ad)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>False,P,t \\<turnstile>1 \\<langle>e,\n    s\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n         \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                            \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                           (\\<lambda>ad.\n                               (int \\<circ> expr_locks e') ad -\n                               (int \\<circ> expr_locks e) ad);\n         sync_ok (e instanceof T);\n         el_loc_ok (e instanceof T) (lcl s)\\<rbrakk>\n        \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                          (\\<lambda>ad.\n                              (int \\<circ> expr_locks (e' instanceof T))\n                               ad -\n                              (int \\<circ> expr_locks (e instanceof T)) ad)\nA total of 102 subgoals...", "case Red1CallExternal"], ["proof (state)\nthis:\n  typeof_addr (hp s_) a_ = \\<lfloor>T_\\<rfloor>\n  P \\<turnstile> class_type_of\n                  T_ sees M_: Ts_\\<rightarrow>Tr_ = Native in D_\n  P,t \\<turnstile> \\<langle>a_\\<bullet>M_(vs_),\n                   hp s_\\<rangle> -ta_\\<rightarrow>ext \\<langle>va_,\n                 h'_\\<rangle>\n  e'_ = extRet2J (addr a_\\<bullet>M_(map Val vs_)) va_\n  s'_ = (h'_, lcl s_)\n  sync_ok (addr a_\\<bullet>M_(map Val vs_))\n  el_loc_ok (addr a_\\<bullet>M_(map Val vs_)) (lcl s_)\n\ngoal (102 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C); sync_ok (new C);\n        el_loc_ok (new C) (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (addr a)) ad -\n                             (int \\<circ> expr_locks (new C)) ad)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {}; sync_ok (new C);\n        el_loc_ok (new C) (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt OutOfMemory)))\n                              ad -\n                             (int \\<circ> expr_locks (new C)) ad)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>False,P,t \\<turnstile>1 \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n        \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                          (\\<lambda>ad.\n                              (int \\<circ> expr_locks e') ad -\n                              (int \\<circ> expr_locks e) ad);\n        sync_ok (newA T\\<lfloor>e\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>e\\<rceil>) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks (newA T\\<lfloor>e'\\<rceil>))\n                              ad -\n                             (int \\<circ>\n                              expr_locks (newA T\\<lfloor>e\\<rceil>))\n                              ad)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n         (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>NewHeapElem a\n       (Array_type T (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (addr a)) ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0; sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt NegativeArraySize)))\n                              ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n         (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt OutOfMemory)))\n                              ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>False,P,t \\<turnstile>1 \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n        \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                          (\\<lambda>ad.\n                              (int \\<circ> expr_locks e') ad -\n                              (int \\<circ> expr_locks e) ad);\n        sync_ok (Cast C e); el_loc_ok (Cast C e) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (Cast C e')) ad -\n                             (int \\<circ> expr_locks (Cast C e)) ad)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v));\n        el_loc_ok (Cast T (Val v)) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (Val v)) ad -\n                             (int \\<circ> expr_locks (Cast T (Val v))) ad)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v));\n        el_loc_ok (Cast T (Val v)) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt ClassCast)))\n                              ad -\n                             (int \\<circ> expr_locks (Cast T (Val v))) ad)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>False,P,t \\<turnstile>1 \\<langle>e,\n    s\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n         \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                            \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                           (\\<lambda>ad.\n                               (int \\<circ> expr_locks e') ad -\n                               (int \\<circ> expr_locks e) ad);\n         sync_ok (e instanceof T);\n         el_loc_ok (e instanceof T) (lcl s)\\<rbrakk>\n        \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                          (\\<lambda>ad.\n                              (int \\<circ> expr_locks (e' instanceof T))\n                               ad -\n                              (int \\<circ> expr_locks (e instanceof T)) ad)\nA total of 102 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  typeof_addr (hp s_) a_ = \\<lfloor>T_\\<rfloor>\n  P \\<turnstile> class_type_of\n                  T_ sees M_: Ts_\\<rightarrow>Tr_ = Native in D_\n  P,t \\<turnstile> \\<langle>a_\\<bullet>M_(vs_),\n                   hp s_\\<rangle> -ta_\\<rightarrow>ext \\<langle>va_,\n                 h'_\\<rangle>\n  e'_ = extRet2J (addr a_\\<bullet>M_(map Val vs_)) va_\n  s'_ = (h'_, lcl s_)\n  sync_ok (addr a_\\<bullet>M_(map Val vs_))\n  el_loc_ok (addr a_\\<bullet>M_(map Val vs_)) (lcl s_)\n\ngoal (1 subgoal):\n 1. upd_expr_locks (\\<lambda>ad. 0) \\<lbrace>ta_\\<rbrace>\\<^bsub>l\\<^esub> =\n    (\\<lambda>ad.\n        (int \\<circ> expr_locks e'_) ad -\n        (int \\<circ> expr_locks (addr a_\\<bullet>M_(map Val vs_))) ad)", "by(auto simp add: fun_eq_iff contains_insync_conv contains_insyncs_conv finfun_upd_apply elim!: red_external.cases)"], ["proof (state)\nthis:\n  upd_expr_locks (\\<lambda>ad. 0) \\<lbrace>ta_\\<rbrace>\\<^bsub>l\\<^esub> =\n  (\\<lambda>ad.\n      (int \\<circ> expr_locks e'_) ad -\n      (int \\<circ> expr_locks (addr a_\\<bullet>M_(map Val vs_))) ad)\n\ngoal (101 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C); sync_ok (new C);\n        el_loc_ok (new C) (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (addr a)) ad -\n                             (int \\<circ> expr_locks (new C)) ad)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {}; sync_ok (new C);\n        el_loc_ok (new C) (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt OutOfMemory)))\n                              ad -\n                             (int \\<circ> expr_locks (new C)) ad)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>False,P,t \\<turnstile>1 \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n        \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                          (\\<lambda>ad.\n                              (int \\<circ> expr_locks e') ad -\n                              (int \\<circ> expr_locks e) ad);\n        sync_ok (newA T\\<lfloor>e\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>e\\<rceil>) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks (newA T\\<lfloor>e'\\<rceil>))\n                              ad -\n                             (int \\<circ>\n                              expr_locks (newA T\\<lfloor>e\\<rceil>))\n                              ad)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n         (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>NewHeapElem a\n       (Array_type T (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (addr a)) ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0; sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt NegativeArraySize)))\n                              ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        sync_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>);\n        el_loc_ok (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n         (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt OutOfMemory)))\n                              ad -\n                             (int \\<circ>\n                              expr_locks\n                               (newA T\\<lfloor>Val (Intg i)\\<rceil>))\n                              ad)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>False,P,t \\<turnstile>1 \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n        \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                          (\\<lambda>ad.\n                              (int \\<circ> expr_locks e') ad -\n                              (int \\<circ> expr_locks e) ad);\n        sync_ok (Cast C e); el_loc_ok (Cast C e) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (Cast C e')) ad -\n                             (int \\<circ> expr_locks (Cast C e)) ad)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v));\n        el_loc_ok (Cast T (Val v)) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ> expr_locks (Val v)) ad -\n                             (int \\<circ> expr_locks (Cast T (Val v))) ad)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T; sync_ok (Cast T (Val v));\n        el_loc_ok (Cast T (Val v)) (lcl s)\\<rbrakk>\n       \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> =\n                         (\\<lambda>ad.\n                             (int \\<circ>\n                              expr_locks\n                               (Throw (addr_of_sys_xcpt ClassCast)))\n                              ad -\n                             (int \\<circ> expr_locks (Cast T (Val v))) ad)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>False,P,t \\<turnstile>1 \\<langle>e,\n    s\\<rangle> -ta\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n         \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                            \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                           (\\<lambda>ad.\n                               (int \\<circ> expr_locks e') ad -\n                               (int \\<circ> expr_locks e) ad);\n         sync_ok (e instanceof T);\n         el_loc_ok (e instanceof T) (lcl s)\\<rbrakk>\n        \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                          (\\<lambda>ad.\n                              (int \\<circ> expr_locks (e' instanceof T))\n                               ad -\n                              (int \\<circ> expr_locks (e instanceof T)) ad)\nA total of 101 subgoals...", "qed(fastforce simp add: fun_eq_iff contains_insync_conv contains_insyncs_conv finfun_upd_apply)+"], ["proof (state)\nthis:\n  \\<lbrakk>False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle>;\n   sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n  \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                    (\\<lambda>ad.\n                        (int \\<circ> expr_locks e') ad -\n                        (int \\<circ> expr_locks e) ad)\n  \\<lbrakk>False,P,t \\<turnstile>1 \\<langle>es,s\\<rangle> [-ta\\<rightarrow>]\n                                   \\<langle>es',s'\\<rangle>;\n   sync_oks es; els_loc_ok es (lcl s)\\<rbrakk>\n  \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                    (\\<lambda>ad.\n                        (int \\<circ> expr_lockss es') ad -\n                        (int \\<circ> expr_lockss es) ad)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n     sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n    \\<Longrightarrow> upd_expr_locks (int \\<circ> expr_locks e)\n                       \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                      int \\<circ> expr_locks e'\n 2. \\<lbrakk>False,P,t \\<turnstile>1 \\<langle>es,\ns\\<rangle> [-ta\\<rightarrow>]\n                                     \\<langle>es',s'\\<rangle>;\n     sync_oks es; els_loc_ok es (lcl s)\\<rbrakk>\n    \\<Longrightarrow> upd_expr_locks (int \\<circ> expr_lockss es)\n                       \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                      int \\<circ> expr_lockss es'", "hence \"\\<lbrakk> False,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; sync_ok e; el_loc_ok e (lcl s) \\<rbrakk>\n        \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0 + (int \\<circ> expr_locks e) ad) \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = int \\<circ> expr_locks e'\"\n    and \"\\<lbrakk> False,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; sync_oks es; els_loc_ok es (lcl s) \\<rbrakk>\n        \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0 + (int \\<circ> expr_lockss es) ad) \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = int \\<circ> expr_lockss es'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle>;\n   sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n  \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                    (\\<lambda>ad.\n                        (int \\<circ> expr_locks e') ad -\n                        (int \\<circ> expr_locks e) ad)\n  \\<lbrakk>False,P,t \\<turnstile>1 \\<langle>es,s\\<rangle> [-ta\\<rightarrow>]\n                                   \\<langle>es',s'\\<rangle>;\n   sync_oks es; els_loc_ok es (lcl s)\\<rbrakk>\n  \\<Longrightarrow> upd_expr_locks (\\<lambda>ad. 0)\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                    (\\<lambda>ad.\n                        (int \\<circ> expr_lockss es') ad -\n                        (int \\<circ> expr_lockss es) ad)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n      sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n     \\<Longrightarrow> upd_expr_locks\n                        (\\<lambda>ad. 0 + (int \\<circ> expr_locks e) ad)\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                       int \\<circ> expr_locks e') &&&\n    (\\<lbrakk>False,P,t \\<turnstile>1 \\<langle>es,\n s\\<rangle> [-ta\\<rightarrow>]\n\\<langle>es',s'\\<rangle>;\n      sync_oks es; els_loc_ok es (lcl s)\\<rbrakk>\n     \\<Longrightarrow> upd_expr_locks\n                        (\\<lambda>ad. 0 + (int \\<circ> expr_lockss es) ad)\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                       int \\<circ> expr_lockss es')", "by(fastforce simp only: upd_expr_locks_add)+"], ["proof (state)\nthis:\n  \\<lbrakk>False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle>;\n   sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n  \\<Longrightarrow> upd_expr_locks\n                     (\\<lambda>ad. 0 + (int \\<circ> expr_locks e) ad)\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                    int \\<circ> expr_locks e'\n  \\<lbrakk>False,P,t \\<turnstile>1 \\<langle>es,s\\<rangle> [-ta\\<rightarrow>]\n                                   \\<langle>es',s'\\<rangle>;\n   sync_oks es; els_loc_ok es (lcl s)\\<rbrakk>\n  \\<Longrightarrow> upd_expr_locks\n                     (\\<lambda>ad. 0 + (int \\<circ> expr_lockss es) ad)\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                    int \\<circ> expr_lockss es'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n     sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n    \\<Longrightarrow> upd_expr_locks (int \\<circ> expr_locks e)\n                       \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                      int \\<circ> expr_locks e'\n 2. \\<lbrakk>False,P,t \\<turnstile>1 \\<langle>es,\ns\\<rangle> [-ta\\<rightarrow>]\n                                     \\<langle>es',s'\\<rangle>;\n     sync_oks es; els_loc_ok es (lcl s)\\<rbrakk>\n    \\<Longrightarrow> upd_expr_locks (int \\<circ> expr_lockss es)\n                       \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                      int \\<circ> expr_lockss es'", "thus \"\\<lbrakk> False,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; sync_ok e; el_loc_ok e (lcl s) \\<rbrakk>\n        \\<Longrightarrow> upd_expr_locks (int o expr_locks e) \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = int o expr_locks e'\"\n    and \"\\<lbrakk> False,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; sync_oks es; els_loc_ok es (lcl s) \\<rbrakk>\n        \\<Longrightarrow> upd_expr_locks (int o expr_lockss es) \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = int o expr_lockss es'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle>;\n   sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n  \\<Longrightarrow> upd_expr_locks\n                     (\\<lambda>ad. 0 + (int \\<circ> expr_locks e) ad)\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                    int \\<circ> expr_locks e'\n  \\<lbrakk>False,P,t \\<turnstile>1 \\<langle>es,s\\<rangle> [-ta\\<rightarrow>]\n                                   \\<langle>es',s'\\<rangle>;\n   sync_oks es; els_loc_ok es (lcl s)\\<rbrakk>\n  \\<Longrightarrow> upd_expr_locks\n                     (\\<lambda>ad. 0 + (int \\<circ> expr_lockss es) ad)\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                    int \\<circ> expr_lockss es'\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n      sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n     \\<Longrightarrow> upd_expr_locks (int \\<circ> expr_locks e)\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                       int \\<circ> expr_locks e') &&&\n    (\\<lbrakk>False,P,t \\<turnstile>1 \\<langle>es,\n s\\<rangle> [-ta\\<rightarrow>]\n\\<langle>es',s'\\<rangle>;\n      sync_oks es; els_loc_ok es (lcl s)\\<rbrakk>\n     \\<Longrightarrow> upd_expr_locks (int \\<circ> expr_lockss es)\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                       int \\<circ> expr_lockss es')", "by(auto simp add: o_def)"], ["proof (state)\nthis:\n  \\<lbrakk>False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle>;\n   sync_ok e; el_loc_ok e (lcl s)\\<rbrakk>\n  \\<Longrightarrow> upd_expr_locks (int \\<circ> expr_locks e)\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                    int \\<circ> expr_locks e'\n  \\<lbrakk>False,P,t \\<turnstile>1 \\<langle>es,s\\<rangle> [-ta\\<rightarrow>]\n                                   \\<langle>es',s'\\<rangle>;\n   sync_oks es; els_loc_ok es (lcl s)\\<rbrakk>\n  \\<Longrightarrow> upd_expr_locks (int \\<circ> expr_lockss es)\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                    int \\<circ> expr_lockss es'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Red1'_preserves_lock_oks:\n  assumes wf: \"wf_J1_prog P\"\n  and Red: \"Red1_mthr.redT False P s1 ta1 s1'\"\n  and loks: \"lock_oks1 (locks s1) (thr s1)\"\n  and sync: \"ts_ok (\\<lambda>t exexs h. el_loc_ok1 exexs) (thr s1) (shr s1)\"\n  shows \"lock_oks1 (locks s1') (thr s1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lock_oks1 (locks s1') (thr s1')", "using Red"], ["proof (prove)\nusing this:\n  Red1_mthr.redT False P s1 ta1 s1'\n\ngoal (1 subgoal):\n 1. lock_oks1 (locks s1') (thr s1')", "proof(cases rule: Red1_mthr.redT.cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>ta1 = (t, ta);\n        Red1_mthr.r_syntax False P t x (shr s1) ta x' m';\n        thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.actions_ok s1 t ta; redT_upd s1 t ta x' m' s1'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>t x n ln.\n       \\<lbrakk>ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        thr s1 t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s1 t);\n        may_acquire_all (locks s1) t ln; 0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (x, no_wait_locks)), shr s1), wset s1,\n         interrupts s1)\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "case (redT_normal t x ta x' m')"], ["proof (state)\nthis:\n  ta1 = (t, ta)\n  Red1_mthr.r_syntax False P t x (shr s1) ta x' m'\n  thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  Red1_mthr.actions_ok s1 t ta\n  redT_upd s1 t ta x' m' s1'\n\ngoal (2 subgoals):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>ta1 = (t, ta);\n        Red1_mthr.r_syntax False P t x (shr s1) ta x' m';\n        thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.actions_ok s1 t ta; redT_upd s1 t ta x' m' s1'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>t x n ln.\n       \\<lbrakk>ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        thr s1 t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s1 t);\n        may_acquire_all (locks s1) t ln; 0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (x, no_wait_locks)), shr s1), wset s1,\n         interrupts s1)\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "note [simp] = \\<open>ta1 = (t, ta)\\<close>"], ["proof (state)\nthis:\n  ta1 = (t, ta)\n\ngoal (2 subgoals):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>ta1 = (t, ta);\n        Red1_mthr.r_syntax False P t x (shr s1) ta x' m';\n        thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.actions_ok s1 t ta; redT_upd s1 t ta x' m' s1'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>t x n ln.\n       \\<lbrakk>ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        thr s1 t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s1 t);\n        may_acquire_all (locks s1) t ln; 0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (x, no_wait_locks)), shr s1), wset s1,\n         interrupts s1)\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "obtain ex exs where x: \"x = (ex, exs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ex exs. x = (ex, exs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases x)"], ["proof (state)\nthis:\n  x = (ex, exs)\n\ngoal (2 subgoals):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>ta1 = (t, ta);\n        Red1_mthr.r_syntax False P t x (shr s1) ta x' m';\n        thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.actions_ok s1 t ta; redT_upd s1 t ta x' m' s1'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>t x n ln.\n       \\<lbrakk>ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        thr s1 t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s1 t);\n        may_acquire_all (locks s1) t ln; 0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (x, no_wait_locks)), shr s1), wset s1,\n         interrupts s1)\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "obtain ex' exs' where x': \"x' = (ex', exs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ex' exs'.\n        x' = (ex', exs') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases x')"], ["proof (state)\nthis:\n  x' = (ex', exs')\n\ngoal (2 subgoals):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>ta1 = (t, ta);\n        Red1_mthr.r_syntax False P t x (shr s1) ta x' m';\n        thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.actions_ok s1 t ta; redT_upd s1 t ta x' m' s1'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>t x n ln.\n       \\<lbrakk>ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        thr s1 t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s1 t);\n        may_acquire_all (locks s1) t ln; 0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (x, no_wait_locks)), shr s1), wset s1,\n         interrupts s1)\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "note thrst = \\<open>thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<close>"], ["proof (state)\nthis:\n  thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>ta1 = (t, ta);\n        Red1_mthr.r_syntax False P t x (shr s1) ta x' m';\n        thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.actions_ok s1 t ta; redT_upd s1 t ta x' m' s1'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>t x n ln.\n       \\<lbrakk>ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        thr s1 t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s1 t);\n        may_acquire_all (locks s1) t ln; 0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (x, no_wait_locks)), shr s1), wset s1,\n         interrupts s1)\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "note aoe = \\<open>Red1_mthr.actions_ok s1 t ta\\<close>"], ["proof (state)\nthis:\n  Red1_mthr.actions_ok s1 t ta\n\ngoal (2 subgoals):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>ta1 = (t, ta);\n        Red1_mthr.r_syntax False P t x (shr s1) ta x' m';\n        thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.actions_ok s1 t ta; redT_upd s1 t ta x' m' s1'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>t x n ln.\n       \\<lbrakk>ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        thr s1 t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s1 t);\n        may_acquire_all (locks s1) t ln; 0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (x, no_wait_locks)), shr s1), wset s1,\n         interrupts s1)\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "from \\<open>mred1' P t (x, shr s1) ta (x', m')\\<close>"], ["proof (chain)\npicking this:\n  Red1_mthr.r_syntax False P t x (shr s1) ta x' m'", "have red: \"False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s1\\<rangle> -ta\\<rightarrow> \\<langle>ex'/exs',m'\\<rangle>\""], ["proof (prove)\nusing this:\n  Red1_mthr.r_syntax False P t x (shr s1) ta x' m'\n\ngoal (1 subgoal):\n 1. False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s1\\<rangle> -ta\\<rightarrow>\n                            \\<langle>ex'/exs',m'\\<rangle>", "unfolding x x'"], ["proof (prove)\nusing this:\n  Red1_mthr.r_syntax False P t (ex, exs) (shr s1) ta (ex', exs') m'\n\ngoal (1 subgoal):\n 1. False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s1\\<rangle> -ta\\<rightarrow>\n                            \\<langle>ex'/exs',m'\\<rangle>", "by simp_all"], ["proof (state)\nthis:\n  False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s1\\<rangle> -ta\\<rightarrow>\n                          \\<langle>ex'/exs',m'\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>ta1 = (t, ta);\n        Red1_mthr.r_syntax False P t x (shr s1) ta x' m';\n        thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.actions_ok s1 t ta; redT_upd s1 t ta x' m' s1'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>t x n ln.\n       \\<lbrakk>ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        thr s1 t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s1 t);\n        may_acquire_all (locks s1) t ln; 0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (x, no_wait_locks)), shr s1), wset s1,\n         interrupts s1)\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "note s1' = \\<open>redT_upd s1 t ta x' m' s1'\\<close>"], ["proof (state)\nthis:\n  redT_upd s1 t ta x' m' s1'\n\ngoal (2 subgoals):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>ta1 = (t, ta);\n        Red1_mthr.r_syntax False P t x (shr s1) ta x' m';\n        thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.actions_ok s1 t ta; redT_upd s1 t ta x' m' s1'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>t x n ln.\n       \\<lbrakk>ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        thr s1 t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s1 t);\n        may_acquire_all (locks s1) t ln; 0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (x, no_wait_locks)), shr s1), wset s1,\n         interrupts s1)\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "moreover"], ["proof (state)\nthis:\n  redT_upd s1 t ta x' m' s1'\n\ngoal (2 subgoals):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>ta1 = (t, ta);\n        Red1_mthr.r_syntax False P t x (shr s1) ta x' m';\n        thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.actions_ok s1 t ta; redT_upd s1 t ta x' m' s1'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>t x n ln.\n       \\<lbrakk>ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        thr s1 t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s1 t);\n        may_acquire_all (locks s1) t ln; 0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (x, no_wait_locks)), shr s1), wset s1,\n         interrupts s1)\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "from red"], ["proof (chain)\npicking this:\n  False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s1\\<rangle> -ta\\<rightarrow>\n                          \\<langle>ex'/exs',m'\\<rangle>", "have \"lock_oks1 (locks s1') (thr s1')\""], ["proof (prove)\nusing this:\n  False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s1\\<rangle> -ta\\<rightarrow>\n                          \\<langle>ex'/exs',m'\\<rangle>\n\ngoal (1 subgoal):\n 1. lock_oks1 (locks s1') (thr s1')", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e x taa e' x'.\n       \\<lbrakk>ex = (e, x); ta = extTA2J1 P taa; ex' = (e', x');\n        exs' = exs;\n        False,P,t \\<turnstile>1 \\<langle>e,\n                                 (shr s1, x)\\<rangle> -taa\\<rightarrow>\n                                \\<langle>e',(m', x')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = shr s1;\n        call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 3. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "case (red1Red e x TA e' x')"], ["proof (state)\nthis:\n  ex = (e, x)\n  ta = extTA2J1 P TA\n  ex' = (e', x')\n  exs' = exs\n  False,P,t \\<turnstile>1 \\<langle>e,(shr s1, x)\\<rangle> -TA\\<rightarrow>\n                          \\<langle>e',(m', x')\\<rangle>\n\ngoal (3 subgoals):\n 1. \\<And>e x taa e' x'.\n       \\<lbrakk>ex = (e, x); ta = extTA2J1 P taa; ex' = (e', x');\n        exs' = exs;\n        False,P,t \\<turnstile>1 \\<langle>e,\n                                 (shr s1, x)\\<rangle> -taa\\<rightarrow>\n                                \\<langle>e',(m', x')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = shr s1;\n        call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 3. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "note [simp] = \\<open>ex = (e, x)\\<close> \\<open>ta = extTA2J1 P TA\\<close> \\<open>ex' = (e', x')\\<close> \\<open>exs' = exs\\<close>\n      and red = \\<open>False,P,t \\<turnstile>1 \\<langle>e,(shr s1, x)\\<rangle> -TA\\<rightarrow> \\<langle>e',(m', x')\\<rangle>\\<close>"], ["proof (state)\nthis:\n  ex = (e, x)\n  ta = extTA2J1 P TA\n  ex' = (e', x')\n  exs' = exs\n  False,P,t \\<turnstile>1 \\<langle>e,(shr s1, x)\\<rangle> -TA\\<rightarrow>\n                          \\<langle>e',(m', x')\\<rangle>\n\ngoal (3 subgoals):\n 1. \\<And>e x taa e' x'.\n       \\<lbrakk>ex = (e, x); ta = extTA2J1 P taa; ex' = (e', x');\n        exs' = exs;\n        False,P,t \\<turnstile>1 \\<langle>e,\n                                 (shr s1, x)\\<rangle> -taa\\<rightarrow>\n                                \\<langle>e',(m', x')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = shr s1;\n        call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 3. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "{"], ["proof (state)\nthis:\n  ex = (e, x)\n  ta = extTA2J1 P TA\n  ex' = (e', x')\n  exs' = exs\n  False,P,t \\<turnstile>1 \\<langle>e,(shr s1, x)\\<rangle> -TA\\<rightarrow>\n                          \\<langle>e',(m', x')\\<rangle>\n\ngoal (3 subgoals):\n 1. \\<And>e x taa e' x'.\n       \\<lbrakk>ex = (e, x); ta = extTA2J1 P taa; ex' = (e', x');\n        exs' = exs;\n        False,P,t \\<turnstile>1 \\<langle>e,\n                                 (shr s1, x)\\<rangle> -taa\\<rightarrow>\n                                \\<langle>e',(m', x')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = shr s1;\n        call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 3. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "fix t'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e x taa e' x'.\n       \\<lbrakk>ex = (e, x); ta = extTA2J1 P taa; ex' = (e', x');\n        exs' = exs;\n        False,P,t \\<turnstile>1 \\<langle>e,\n                                 (shr s1, x)\\<rangle> -taa\\<rightarrow>\n                                \\<langle>e',(m', x')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = shr s1;\n        call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 3. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "assume None: \"(redT_updTs (thr s1) (map (convert_new_thread_action (extNTA2J1 P)) \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>)(t \\<mapsto> (((e', x'), exs), redT_updLns (locks s1) t (snd (the (thr s1 t))) \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub>))) t' = None\""], ["proof (state)\nthis:\n  (redT_updTs (thr s1)\n    (map (convert_new_thread_action (extNTA2J1 P))\n      \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>)\n   (t \\<mapsto>\n   (((e', x'), exs),\n    redT_updLns (locks s1) t (snd (the (thr s1 t)))\n     \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub>)))\n   t' =\n  None\n\ngoal (3 subgoals):\n 1. \\<And>e x taa e' x'.\n       \\<lbrakk>ex = (e, x); ta = extTA2J1 P taa; ex' = (e', x');\n        exs' = exs;\n        False,P,t \\<turnstile>1 \\<langle>e,\n                                 (shr s1, x)\\<rangle> -taa\\<rightarrow>\n                                \\<langle>e',(m', x')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = shr s1;\n        call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 3. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "{"], ["proof (state)\nthis:\n  (redT_updTs (thr s1)\n    (map (convert_new_thread_action (extNTA2J1 P))\n      \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>)\n   (t \\<mapsto>\n   (((e', x'), exs),\n    redT_updLns (locks s1) t (snd (the (thr s1 t)))\n     \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub>)))\n   t' =\n  None\n\ngoal (3 subgoals):\n 1. \\<And>e x taa e' x'.\n       \\<lbrakk>ex = (e, x); ta = extTA2J1 P taa; ex' = (e', x');\n        exs' = exs;\n        False,P,t \\<turnstile>1 \\<langle>e,\n                                 (shr s1, x)\\<rangle> -taa\\<rightarrow>\n                                \\<langle>e',(m', x')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = shr s1;\n        call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 3. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "fix l"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e x taa e' x'.\n       \\<lbrakk>ex = (e, x); ta = extTA2J1 P taa; ex' = (e', x');\n        exs' = exs;\n        False,P,t \\<turnstile>1 \\<langle>e,\n                                 (shr s1, x)\\<rangle> -taa\\<rightarrow>\n                                \\<langle>e',(m', x')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = shr s1;\n        call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 3. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "from aoe"], ["proof (chain)\npicking this:\n  Red1_mthr.actions_ok s1 t ta", "have \"lock_actions_ok (locks s1 $ l) t (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\""], ["proof (prove)\nusing this:\n  Red1_mthr.actions_ok s1 t ta\n\ngoal (1 subgoal):\n 1. lock_actions_ok (locks s1 $ l) t\n     (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)", "by(auto simp add: lock_ok_las_def)"], ["proof (state)\nthis:\n  lock_actions_ok (locks s1 $ l) t\n   (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n\ngoal (3 subgoals):\n 1. \\<And>e x taa e' x'.\n       \\<lbrakk>ex = (e, x); ta = extTA2J1 P taa; ex' = (e', x');\n        exs' = exs;\n        False,P,t \\<turnstile>1 \\<langle>e,\n                                 (shr s1, x)\\<rangle> -taa\\<rightarrow>\n                                \\<langle>e',(m', x')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = shr s1;\n        call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 3. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "with None"], ["proof (chain)\npicking this:\n  (redT_updTs (thr s1)\n    (map (convert_new_thread_action (extNTA2J1 P))\n      \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>)\n   (t \\<mapsto>\n   (((e', x'), exs),\n    redT_updLns (locks s1) t (snd (the (thr s1 t)))\n     \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub>)))\n   t' =\n  None\n  lock_actions_ok (locks s1 $ l) t\n   (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)", "have \"has_locks ((redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>) $ l) t' = has_locks (locks s1 $ l) t'\""], ["proof (prove)\nusing this:\n  (redT_updTs (thr s1)\n    (map (convert_new_thread_action (extNTA2J1 P))\n      \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>)\n   (t \\<mapsto>\n   (((e', x'), exs),\n    redT_updLns (locks s1) t (snd (the (thr s1 t)))\n     \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub>)))\n   t' =\n  None\n  lock_actions_ok (locks s1 $ l) t\n   (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n\ngoal (1 subgoal):\n 1. has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' =\n    has_locks (locks s1 $ l) t'", "by(auto split: if_split_asm)"], ["proof (state)\nthis:\n  has_locks\n   (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l) t' =\n  has_locks (locks s1 $ l) t'\n\ngoal (3 subgoals):\n 1. \\<And>e x taa e' x'.\n       \\<lbrakk>ex = (e, x); ta = extTA2J1 P taa; ex' = (e', x');\n        exs' = exs;\n        False,P,t \\<turnstile>1 \\<langle>e,\n                                 (shr s1, x)\\<rangle> -taa\\<rightarrow>\n                                \\<langle>e',(m', x')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = shr s1;\n        call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 3. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "also"], ["proof (state)\nthis:\n  has_locks\n   (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l) t' =\n  has_locks (locks s1 $ l) t'\n\ngoal (3 subgoals):\n 1. \\<And>e x taa e' x'.\n       \\<lbrakk>ex = (e, x); ta = extTA2J1 P taa; ex' = (e', x');\n        exs' = exs;\n        False,P,t \\<turnstile>1 \\<langle>e,\n                                 (shr s1, x)\\<rangle> -taa\\<rightarrow>\n                                \\<langle>e',(m', x')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = shr s1;\n        call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 3. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "from loks None"], ["proof (chain)\npicking this:\n  lock_oks1 (locks s1) (thr s1)\n  (redT_updTs (thr s1)\n    (map (convert_new_thread_action (extNTA2J1 P))\n      \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>)\n   (t \\<mapsto>\n   (((e', x'), exs),\n    redT_updLns (locks s1) t (snd (the (thr s1 t)))\n     \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub>)))\n   t' =\n  None", "have \"has_locks (locks s1 $ l) t' = 0\""], ["proof (prove)\nusing this:\n  lock_oks1 (locks s1) (thr s1)\n  (redT_updTs (thr s1)\n    (map (convert_new_thread_action (extNTA2J1 P))\n      \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>)\n   (t \\<mapsto>\n   (((e', x'), exs),\n    redT_updLns (locks s1) t (snd (the (thr s1 t)))\n     \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub>)))\n   t' =\n  None\n\ngoal (1 subgoal):\n 1. has_locks (locks s1 $ l) t' = 0", "unfolding lock_oks1_def"], ["proof (prove)\nusing this:\n  \\<forall>t.\n     case thr s1 t of\n     None \\<Rightarrow> \\<forall>l. has_locks (locks s1 $ l) t = 0\n     | \\<lfloor>((ex, exs), ln)\\<rfloor> \\<Rightarrow>\n         \\<forall>l.\n            has_locks (locks s1 $ l) t + ln $ l =\n            expr_lockss (map fst (ex # exs)) l\n  (redT_updTs (thr s1)\n    (map (convert_new_thread_action (extNTA2J1 P))\n      \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>)\n   (t \\<mapsto>\n   (((e', x'), exs),\n    redT_updLns (locks s1) t (snd (the (thr s1 t)))\n     \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub>)))\n   t' =\n  None\n\ngoal (1 subgoal):\n 1. has_locks (locks s1 $ l) t' = 0", "by(force split: if_split_asm dest!: redT_updTs_None)"], ["proof (state)\nthis:\n  has_locks (locks s1 $ l) t' = 0\n\ngoal (3 subgoals):\n 1. \\<And>e x taa e' x'.\n       \\<lbrakk>ex = (e, x); ta = extTA2J1 P taa; ex' = (e', x');\n        exs' = exs;\n        False,P,t \\<turnstile>1 \\<langle>e,\n                                 (shr s1, x)\\<rangle> -taa\\<rightarrow>\n                                \\<langle>e',(m', x')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = shr s1;\n        call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 3. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "finally"], ["proof (chain)\npicking this:\n  has_locks\n   (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l) t' =\n  0", "have \"has_locks (upd_locks (locks s1 $ l) t (\\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub> $ l)) t' = 0\""], ["proof (prove)\nusing this:\n  has_locks\n   (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l) t' =\n  0\n\ngoal (1 subgoal):\n 1. has_locks\n     (upd_locks (locks s1 $ l) t\n       (\\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub> $ l))\n     t' =\n    0", "by simp"], ["proof (state)\nthis:\n  has_locks\n   (upd_locks (locks s1 $ l) t (\\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub> $ l))\n   t' =\n  0\n\ngoal (3 subgoals):\n 1. \\<And>e x taa e' x'.\n       \\<lbrakk>ex = (e, x); ta = extTA2J1 P taa; ex' = (e', x');\n        exs' = exs;\n        False,P,t \\<turnstile>1 \\<langle>e,\n                                 (shr s1, x)\\<rangle> -taa\\<rightarrow>\n                                \\<langle>e',(m', x')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = shr s1;\n        call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 3. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "}"], ["proof (state)\nthis:\n  has_locks\n   (upd_locks (locks s1 $ ?l26) t\n     (\\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub> $ ?l26))\n   t' =\n  0\n\ngoal (3 subgoals):\n 1. \\<And>e x taa e' x'.\n       \\<lbrakk>ex = (e, x); ta = extTA2J1 P taa; ex' = (e', x');\n        exs' = exs;\n        False,P,t \\<turnstile>1 \\<langle>e,\n                                 (shr s1, x)\\<rangle> -taa\\<rightarrow>\n                                \\<langle>e',(m', x')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = shr s1;\n        call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 3. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "hence \"\\<forall>l. has_locks (upd_locks (locks s1 $ l) t (\\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub> $ l)) t' = 0\""], ["proof (prove)\nusing this:\n  has_locks\n   (upd_locks (locks s1 $ ?l26) t\n     (\\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub> $ ?l26))\n   t' =\n  0\n\ngoal (1 subgoal):\n 1. \\<forall>l.\n       has_locks\n        (upd_locks (locks s1 $ l) t\n          (\\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub> $ l))\n        t' =\n       0", ".."], ["proof (state)\nthis:\n  \\<forall>l.\n     has_locks\n      (upd_locks (locks s1 $ l) t\n        (\\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub> $ l))\n      t' =\n     0\n\ngoal (3 subgoals):\n 1. \\<And>e x taa e' x'.\n       \\<lbrakk>ex = (e, x); ta = extTA2J1 P taa; ex' = (e', x');\n        exs' = exs;\n        False,P,t \\<turnstile>1 \\<langle>e,\n                                 (shr s1, x)\\<rangle> -taa\\<rightarrow>\n                                \\<langle>e',(m', x')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = shr s1;\n        call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 3. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "}"], ["proof (state)\nthis:\n  (redT_updTs (thr s1)\n    (map (convert_new_thread_action (extNTA2J1 P))\n      \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>)\n   (t \\<mapsto>\n   (((e', x'), exs),\n    redT_updLns (locks s1) t (snd (the (thr s1 t)))\n     \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub>)))\n   ?t'26 =\n  None \\<Longrightarrow>\n  \\<forall>l.\n     has_locks\n      (upd_locks (locks s1 $ l) t\n        (\\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub> $ l))\n      ?t'26 =\n     0\n\ngoal (3 subgoals):\n 1. \\<And>e x taa e' x'.\n       \\<lbrakk>ex = (e, x); ta = extTA2J1 P taa; ex' = (e', x');\n        exs' = exs;\n        False,P,t \\<turnstile>1 \\<langle>e,\n                                 (shr s1, x)\\<rangle> -taa\\<rightarrow>\n                                \\<langle>e',(m', x')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = shr s1;\n        call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 3. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "moreover"], ["proof (state)\nthis:\n  (redT_updTs (thr s1)\n    (map (convert_new_thread_action (extNTA2J1 P))\n      \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>)\n   (t \\<mapsto>\n   (((e', x'), exs),\n    redT_updLns (locks s1) t (snd (the (thr s1 t)))\n     \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub>)))\n   ?t'26 =\n  None \\<Longrightarrow>\n  \\<forall>l.\n     has_locks\n      (upd_locks (locks s1 $ l) t\n        (\\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub> $ l))\n      ?t'26 =\n     0\n\ngoal (3 subgoals):\n 1. \\<And>e x taa e' x'.\n       \\<lbrakk>ex = (e, x); ta = extTA2J1 P taa; ex' = (e', x');\n        exs' = exs;\n        False,P,t \\<turnstile>1 \\<langle>e,\n                                 (shr s1, x)\\<rangle> -taa\\<rightarrow>\n                                \\<langle>e',(m', x')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = shr s1;\n        call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 3. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "{"], ["proof (state)\nthis:\n  (redT_updTs (thr s1)\n    (map (convert_new_thread_action (extNTA2J1 P))\n      \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>)\n   (t \\<mapsto>\n   (((e', x'), exs),\n    redT_updLns (locks s1) t (snd (the (thr s1 t)))\n     \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub>)))\n   ?t'26 =\n  None \\<Longrightarrow>\n  \\<forall>l.\n     has_locks\n      (upd_locks (locks s1 $ l) t\n        (\\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub> $ l))\n      ?t'26 =\n     0\n\ngoal (3 subgoals):\n 1. \\<And>e x taa e' x'.\n       \\<lbrakk>ex = (e, x); ta = extTA2J1 P taa; ex' = (e', x');\n        exs' = exs;\n        False,P,t \\<turnstile>1 \\<langle>e,\n                                 (shr s1, x)\\<rangle> -taa\\<rightarrow>\n                                \\<langle>e',(m', x')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = shr s1;\n        call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 3. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "fix t' eX eXS LN"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e x taa e' x'.\n       \\<lbrakk>ex = (e, x); ta = extTA2J1 P taa; ex' = (e', x');\n        exs' = exs;\n        False,P,t \\<turnstile>1 \\<langle>e,\n                                 (shr s1, x)\\<rangle> -taa\\<rightarrow>\n                                \\<langle>e',(m', x')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = shr s1;\n        call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 3. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "assume Some: \"(redT_updTs (thr s1) (map (convert_new_thread_action (extNTA2J1 P)) \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>)(t \\<mapsto> (((e', x'), exs), redT_updLns (locks s1) t (snd (the (thr s1 t))) \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub>))) t' = \\<lfloor>((eX, eXS), LN)\\<rfloor>\""], ["proof (state)\nthis:\n  (redT_updTs (thr s1)\n    (map (convert_new_thread_action (extNTA2J1 P))\n      \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>)\n   (t \\<mapsto>\n   (((e', x'), exs),\n    redT_updLns (locks s1) t (snd (the (thr s1 t)))\n     \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub>)))\n   t' =\n  \\<lfloor>((eX, eXS), LN)\\<rfloor>\n\ngoal (3 subgoals):\n 1. \\<And>e x taa e' x'.\n       \\<lbrakk>ex = (e, x); ta = extTA2J1 P taa; ex' = (e', x');\n        exs' = exs;\n        False,P,t \\<turnstile>1 \\<langle>e,\n                                 (shr s1, x)\\<rangle> -taa\\<rightarrow>\n                                \\<langle>e',(m', x')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = shr s1;\n        call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 3. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "{"], ["proof (state)\nthis:\n  (redT_updTs (thr s1)\n    (map (convert_new_thread_action (extNTA2J1 P))\n      \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>)\n   (t \\<mapsto>\n   (((e', x'), exs),\n    redT_updLns (locks s1) t (snd (the (thr s1 t)))\n     \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub>)))\n   t' =\n  \\<lfloor>((eX, eXS), LN)\\<rfloor>\n\ngoal (3 subgoals):\n 1. \\<And>e x taa e' x'.\n       \\<lbrakk>ex = (e, x); ta = extTA2J1 P taa; ex' = (e', x');\n        exs' = exs;\n        False,P,t \\<turnstile>1 \\<langle>e,\n                                 (shr s1, x)\\<rangle> -taa\\<rightarrow>\n                                \\<langle>e',(m', x')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = shr s1;\n        call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 3. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "fix l"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e x taa e' x'.\n       \\<lbrakk>ex = (e, x); ta = extTA2J1 P taa; ex' = (e', x');\n        exs' = exs;\n        False,P,t \\<turnstile>1 \\<langle>e,\n                                 (shr s1, x)\\<rangle> -taa\\<rightarrow>\n                                \\<langle>e',(m', x')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = shr s1;\n        call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 3. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "from aoe"], ["proof (chain)\npicking this:\n  Red1_mthr.actions_ok s1 t ta", "have lao: \"lock_actions_ok (locks s1 $ l) t (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\""], ["proof (prove)\nusing this:\n  Red1_mthr.actions_ok s1 t ta\n\ngoal (1 subgoal):\n 1. lock_actions_ok (locks s1 $ l) t\n     (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)", "by(auto simp add: lock_ok_las_def)"], ["proof (state)\nthis:\n  lock_actions_ok (locks s1 $ l) t\n   (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n\ngoal (3 subgoals):\n 1. \\<And>e x taa e' x'.\n       \\<lbrakk>ex = (e, x); ta = extTA2J1 P taa; ex' = (e', x');\n        exs' = exs;\n        False,P,t \\<turnstile>1 \\<langle>e,\n                                 (shr s1, x)\\<rangle> -taa\\<rightarrow>\n                                \\<langle>e',(m', x')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = shr s1;\n        call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 3. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "have \"has_locks ((redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>) $ l) t' + LN $ l = expr_lockss (map fst (eX # eXS)) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l", "proof(cases \"t = t'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t = t' \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l\n 2. t \\<noteq> t' \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l", "case True"], ["proof (state)\nthis:\n  t = t'\n\ngoal (2 subgoals):\n 1. t = t' \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l\n 2. t \\<noteq> t' \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l", "from loks thrst x"], ["proof (chain)\npicking this:\n  lock_oks1 (locks s1) (thr s1)\n  thr s1 t = \\<lfloor>(x__, no_wait_locks)\\<rfloor>\n  x__ = (ex, exs)", "have \"has_locks (locks s1 $ l) t = expr_locks e l + expr_lockss (map fst exs) l\""], ["proof (prove)\nusing this:\n  lock_oks1 (locks s1) (thr s1)\n  thr s1 t = \\<lfloor>(x__, no_wait_locks)\\<rfloor>\n  x__ = (ex, exs)\n\ngoal (1 subgoal):\n 1. has_locks (locks s1 $ l) t =\n    expr_locks e l + expr_lockss (map fst exs) l", "by(force simp add: lock_oks1_def)"], ["proof (state)\nthis:\n  has_locks (locks s1 $ l) t = expr_locks e l + expr_lockss (map fst exs) l\n\ngoal (2 subgoals):\n 1. t = t' \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l\n 2. t \\<noteq> t' \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l", "hence \"lock_expr_locks_ok (locks s1 $ l) t 0 (int (expr_locks e l + expr_lockss (map fst exs) l))\""], ["proof (prove)\nusing this:\n  has_locks (locks s1 $ l) t = expr_locks e l + expr_lockss (map fst exs) l\n\ngoal (1 subgoal):\n 1. lock_expr_locks_ok (locks s1 $ l) t 0\n     (int (expr_locks e l + expr_lockss (map fst exs) l))", "by(simp add: lock_expr_locks_ok_def)"], ["proof (state)\nthis:\n  lock_expr_locks_ok (locks s1 $ l) t 0\n   (int (expr_locks e l + expr_lockss (map fst exs) l))\n\ngoal (2 subgoals):\n 1. t = t' \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l\n 2. t \\<noteq> t' \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l", "with lao"], ["proof (chain)\npicking this:\n  lock_actions_ok (locks s1 $ l) t\n   (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n  lock_expr_locks_ok (locks s1 $ l) t 0\n   (int (expr_locks e l + expr_lockss (map fst exs) l))", "have \"lock_expr_locks_ok (upd_locks (locks s1 $ l) t (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)) t (upd_threadRs 0 (locks s1 $ l) t (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l))\n (upd_expr_lock_actions (int (expr_locks e l + expr_lockss (map fst exs) l)) (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l))\""], ["proof (prove)\nusing this:\n  lock_actions_ok (locks s1 $ l) t\n   (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n  lock_expr_locks_ok (locks s1 $ l) t 0\n   (int (expr_locks e l + expr_lockss (map fst exs) l))\n\ngoal (1 subgoal):\n 1. lock_expr_locks_ok\n     (upd_locks (locks s1 $ l) t\n       (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l))\n     t (upd_threadRs 0 (locks s1 $ l) t\n         (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l))\n     (upd_expr_lock_actions\n       (int (expr_locks e l + expr_lockss (map fst exs) l))\n       (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l))", "by(rule upd_locks_upd_expr_lock_preserve_lock_expr_locks_ok)"], ["proof (state)\nthis:\n  lock_expr_locks_ok\n   (upd_locks (locks s1 $ l) t (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l))\n   t (upd_threadRs 0 (locks s1 $ l) t\n       (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l))\n   (upd_expr_lock_actions\n     (int (expr_locks e l + expr_lockss (map fst exs) l))\n     (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l))\n\ngoal (2 subgoals):\n 1. t = t' \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l\n 2. t \\<noteq> t' \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l", "moreover"], ["proof (state)\nthis:\n  lock_expr_locks_ok\n   (upd_locks (locks s1 $ l) t (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l))\n   t (upd_threadRs 0 (locks s1 $ l) t\n       (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l))\n   (upd_expr_lock_actions\n     (int (expr_locks e l + expr_lockss (map fst exs) l))\n     (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l))\n\ngoal (2 subgoals):\n 1. t = t' \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l\n 2. t \\<noteq> t' \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l", "from sync thrst x"], ["proof (chain)\npicking this:\n  ts_ok (\\<lambda>t exexs h. el_loc_ok1 exexs) (thr s1) (shr s1)\n  thr s1 t = \\<lfloor>(x__, no_wait_locks)\\<rfloor>\n  x__ = (ex, exs)", "have \"sync_ok e\" \"el_loc_ok e x\""], ["proof (prove)\nusing this:\n  ts_ok (\\<lambda>t exexs h. el_loc_ok1 exexs) (thr s1) (shr s1)\n  thr s1 t = \\<lfloor>(x__, no_wait_locks)\\<rfloor>\n  x__ = (ex, exs)\n\ngoal (1 subgoal):\n 1. sync_ok e &&& el_loc_ok e x", "unfolding el_loc_ok1_def"], ["proof (prove)\nusing this:\n  ts_ok\n   (\\<lambda>t exexs h.\n       case exexs of\n       (x, xa) \\<Rightarrow>\n         (case x of\n          (e, xs) \\<Rightarrow>\n            \\<lambda>exs.\n               el_loc_ok e xs \\<and>\n               sync_ok e \\<and>\n               (\\<forall>(e, xs)\\<in>set exs.\n                   el_loc_ok e xs \\<and> sync_ok e))\n          xa)\n   (thr s1) (shr s1)\n  thr s1 t = \\<lfloor>(x__, no_wait_locks)\\<rfloor>\n  x__ = (ex, exs)\n\ngoal (1 subgoal):\n 1. sync_ok e &&& el_loc_ok e x", "by(auto dest: ts_okD)"], ["proof (state)\nthis:\n  sync_ok e\n  el_loc_ok e x\n\ngoal (2 subgoals):\n 1. t = t' \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l\n 2. t \\<noteq> t' \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l", "with red1_update_expr_locks[OF wf red]"], ["proof (chain)\npicking this:\n  \\<lbrakk>sync_ok e; el_loc_ok e (lcl (shr s1, x))\\<rbrakk>\n  \\<Longrightarrow> upd_expr_locks (int \\<circ> expr_locks e)\n                     \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub> =\n                    int \\<circ> expr_locks e'\n  sync_ok e\n  el_loc_ok e x", "have \"upd_expr_locks (int \\<circ> expr_locks e) \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub> = int \\<circ> expr_locks e'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>sync_ok e; el_loc_ok e (lcl (shr s1, x))\\<rbrakk>\n  \\<Longrightarrow> upd_expr_locks (int \\<circ> expr_locks e)\n                     \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub> =\n                    int \\<circ> expr_locks e'\n  sync_ok e\n  el_loc_ok e x\n\ngoal (1 subgoal):\n 1. upd_expr_locks (int \\<circ> expr_locks e)\n     \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub> =\n    int \\<circ> expr_locks e'", "by(simp)"], ["proof (state)\nthis:\n  upd_expr_locks (int \\<circ> expr_locks e)\n   \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub> =\n  int \\<circ> expr_locks e'\n\ngoal (2 subgoals):\n 1. t = t' \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l\n 2. t \\<noteq> t' \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l", "hence \"upd_expr_lock_actions (int (expr_locks e l)) (\\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub> $ l) = int (expr_locks e' l)\""], ["proof (prove)\nusing this:\n  upd_expr_locks (int \\<circ> expr_locks e)\n   \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub> =\n  int \\<circ> expr_locks e'\n\ngoal (1 subgoal):\n 1. upd_expr_lock_actions (int (expr_locks e l))\n     (\\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub> $ l) =\n    int (expr_locks e' l)", "by(simp add: upd_expr_locks_def fun_eq_iff)"], ["proof (state)\nthis:\n  upd_expr_lock_actions (int (expr_locks e l))\n   (\\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub> $ l) =\n  int (expr_locks e' l)\n\ngoal (2 subgoals):\n 1. t = t' \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l\n 2. t \\<noteq> t' \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l", "ultimately"], ["proof (chain)\npicking this:\n  lock_expr_locks_ok\n   (upd_locks (locks s1 $ l) t (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l))\n   t (upd_threadRs 0 (locks s1 $ l) t\n       (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l))\n   (upd_expr_lock_actions\n     (int (expr_locks e l + expr_lockss (map fst exs) l))\n     (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l))\n  upd_expr_lock_actions (int (expr_locks e l))\n   (\\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub> $ l) =\n  int (expr_locks e' l)", "show ?thesis"], ["proof (prove)\nusing this:\n  lock_expr_locks_ok\n   (upd_locks (locks s1 $ l) t (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l))\n   t (upd_threadRs 0 (locks s1 $ l) t\n       (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l))\n   (upd_expr_lock_actions\n     (int (expr_locks e l + expr_lockss (map fst exs) l))\n     (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l))\n  upd_expr_lock_actions (int (expr_locks e l))\n   (\\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub> $ l) =\n  int (expr_locks e' l)\n\ngoal (1 subgoal):\n 1. has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l", "using lao Some thrst x True"], ["proof (prove)\nusing this:\n  lock_expr_locks_ok\n   (upd_locks (locks s1 $ l) t (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l))\n   t (upd_threadRs 0 (locks s1 $ l) t\n       (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l))\n   (upd_expr_lock_actions\n     (int (expr_locks e l + expr_lockss (map fst exs) l))\n     (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l))\n  upd_expr_lock_actions (int (expr_locks e l))\n   (\\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub> $ l) =\n  int (expr_locks e' l)\n  lock_actions_ok (locks s1 $ l) t\n   (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n  (redT_updTs (thr s1)\n    (map (convert_new_thread_action (extNTA2J1 P))\n      \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>)\n   (t \\<mapsto>\n   (((e', x'), exs),\n    redT_updLns (locks s1) t (snd (the (thr s1 t)))\n     \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub>)))\n   t' =\n  \\<lfloor>((eX, eXS), LN)\\<rfloor>\n  thr s1 t = \\<lfloor>(x__, no_wait_locks)\\<rfloor>\n  x__ = (ex, exs)\n  t = t'\n\ngoal (1 subgoal):\n 1. has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l", "by(auto simp add: lock_expr_locks_ok_def upd_expr_locks_def)"], ["proof (state)\nthis:\n  has_locks\n   (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l) t' +\n  LN $ l =\n  expr_lockss (map fst (eX # eXS)) l\n\ngoal (1 subgoal):\n 1. t \\<noteq> t' \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<noteq> t' \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l", "case False"], ["proof (state)\nthis:\n  t \\<noteq> t'\n\ngoal (1 subgoal):\n 1. t \\<noteq> t' \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l", "from aoe"], ["proof (chain)\npicking this:\n  Red1_mthr.actions_ok s1 t ta", "have tok: \"thread_oks (thr s1) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\""], ["proof (prove)\nusing this:\n  Red1_mthr.actions_ok s1 t ta\n\ngoal (1 subgoal):\n 1. thread_oks (thr s1) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>", "by auto"], ["proof (state)\nthis:\n  thread_oks (thr s1) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n\ngoal (1 subgoal):\n 1. t \\<noteq> t' \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l", "proof(cases \"thr s1 t' = None\")"], ["proof (state)\ngoal (2 subgoals):\n 1. thr s1 t' = None \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l\n 2. thr s1 t' \\<noteq> None \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l", "case True"], ["proof (state)\nthis:\n  thr s1 t' = None\n\ngoal (2 subgoals):\n 1. thr s1 t' = None \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l\n 2. thr s1 t' \\<noteq> None \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l", "with Some tok False"], ["proof (chain)\npicking this:\n  (redT_updTs (thr s1)\n    (map (convert_new_thread_action (extNTA2J1 P))\n      \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>)\n   (t \\<mapsto>\n   (((e', x'), exs),\n    redT_updLns (locks s1) t (snd (the (thr s1 t)))\n     \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub>)))\n   t' =\n  \\<lfloor>((eX, eXS), LN)\\<rfloor>\n  thread_oks (thr s1) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n  t \\<noteq> t'\n  thr s1 t' = None", "obtain m \n              where nt: \"NewThread t' (eX, eXS) m \\<in> set (map (convert_new_thread_action (extNTA2J1 P)) \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>)\"\n              and [simp]: \"LN = no_wait_locks\""], ["proof (prove)\nusing this:\n  (redT_updTs (thr s1)\n    (map (convert_new_thread_action (extNTA2J1 P))\n      \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>)\n   (t \\<mapsto>\n   (((e', x'), exs),\n    redT_updLns (locks s1) t (snd (the (thr s1 t)))\n     \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub>)))\n   t' =\n  \\<lfloor>((eX, eXS), LN)\\<rfloor>\n  thread_oks (thr s1) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n  t \\<noteq> t'\n  thr s1 t' = None\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>NewThread t' (eX, eXS) m\n                 \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n                             \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>);\n         LN = no_wait_locks\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: redT_updTs_new_thread)"], ["proof (state)\nthis:\n  NewThread t' (eX, eXS) m\n  \\<in> set (map (convert_new_thread_action (extNTA2J1 P))\n              \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>)\n  LN = no_wait_locks\n\ngoal (2 subgoals):\n 1. thr s1 t' = None \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l\n 2. thr s1 t' \\<noteq> None \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l", "note expr_locks_new_thread1[OF wf red nt]"], ["proof (state)\nthis:\n  expr_lockss (map fst (eX # eXS)) = (\\<lambda>ad. 0)\n\ngoal (2 subgoals):\n 1. thr s1 t' = None \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l\n 2. thr s1 t' \\<noteq> None \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l", "moreover"], ["proof (state)\nthis:\n  expr_lockss (map fst (eX # eXS)) = (\\<lambda>ad. 0)\n\ngoal (2 subgoals):\n 1. thr s1 t' = None \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l\n 2. thr s1 t' \\<noteq> None \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l", "from loks True"], ["proof (chain)\npicking this:\n  lock_oks1 (locks s1) (thr s1)\n  thr s1 t' = None", "have \"has_locks (locks s1 $ l) t' = 0\""], ["proof (prove)\nusing this:\n  lock_oks1 (locks s1) (thr s1)\n  thr s1 t' = None\n\ngoal (1 subgoal):\n 1. has_locks (locks s1 $ l) t' = 0", "by(force simp add: lock_oks1_def)"], ["proof (state)\nthis:\n  has_locks (locks s1 $ l) t' = 0\n\ngoal (2 subgoals):\n 1. thr s1 t' = None \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l\n 2. thr s1 t' \\<noteq> None \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l", "ultimately"], ["proof (chain)\npicking this:\n  expr_lockss (map fst (eX # eXS)) = (\\<lambda>ad. 0)\n  has_locks (locks s1 $ l) t' = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  expr_lockss (map fst (eX # eXS)) = (\\<lambda>ad. 0)\n  has_locks (locks s1 $ l) t' = 0\n\ngoal (1 subgoal):\n 1. has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l", "using lao False"], ["proof (prove)\nusing this:\n  expr_lockss (map fst (eX # eXS)) = (\\<lambda>ad. 0)\n  has_locks (locks s1 $ l) t' = 0\n  lock_actions_ok (locks s1 $ l) t\n   (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n  t \\<noteq> t'\n\ngoal (1 subgoal):\n 1. has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l", "by simp"], ["proof (state)\nthis:\n  has_locks\n   (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l) t' +\n  LN $ l =\n  expr_lockss (map fst (eX # eXS)) l\n\ngoal (1 subgoal):\n 1. thr s1 t' \\<noteq> None \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. thr s1 t' \\<noteq> None \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l", "case False"], ["proof (state)\nthis:\n  thr s1 t' \\<noteq> None\n\ngoal (1 subgoal):\n 1. thr s1 t' \\<noteq> None \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l", "with Some \\<open>t \\<noteq> t'\\<close> tok"], ["proof (chain)\npicking this:\n  (redT_updTs (thr s1)\n    (map (convert_new_thread_action (extNTA2J1 P))\n      \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>)\n   (t \\<mapsto>\n   (((e', x'), exs),\n    redT_updLns (locks s1) t (snd (the (thr s1 t)))\n     \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub>)))\n   t' =\n  \\<lfloor>((eX, eXS), LN)\\<rfloor>\n  t \\<noteq> t'\n  thread_oks (thr s1) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n  thr s1 t' \\<noteq> None", "have \"thr s1 t' = \\<lfloor>((eX, eXS), LN)\\<rfloor>\""], ["proof (prove)\nusing this:\n  (redT_updTs (thr s1)\n    (map (convert_new_thread_action (extNTA2J1 P))\n      \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>)\n   (t \\<mapsto>\n   (((e', x'), exs),\n    redT_updLns (locks s1) t (snd (the (thr s1 t)))\n     \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub>)))\n   t' =\n  \\<lfloor>((eX, eXS), LN)\\<rfloor>\n  t \\<noteq> t'\n  thread_oks (thr s1) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n  thr s1 t' \\<noteq> None\n\ngoal (1 subgoal):\n 1. thr s1 t' = \\<lfloor>((eX, eXS), LN)\\<rfloor>", "by(fastforce dest: redT_updTs_Some[OF _ tok])"], ["proof (state)\nthis:\n  thr s1 t' = \\<lfloor>((eX, eXS), LN)\\<rfloor>\n\ngoal (1 subgoal):\n 1. thr s1 t' \\<noteq> None \\<Longrightarrow>\n    has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l", "with loks tok lao \\<open>t \\<noteq> t'\\<close>"], ["proof (chain)\npicking this:\n  lock_oks1 (locks s1) (thr s1)\n  thread_oks (thr s1) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n  lock_actions_ok (locks s1 $ l) t\n   (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n  t \\<noteq> t'\n  thr s1 t' = \\<lfloor>((eX, eXS), LN)\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  lock_oks1 (locks s1) (thr s1)\n  thread_oks (thr s1) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\n  lock_actions_ok (locks s1 $ l) t\n   (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n  t \\<noteq> t'\n  thr s1 t' = \\<lfloor>((eX, eXS), LN)\\<rfloor>\n\ngoal (1 subgoal):\n 1. has_locks\n     (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n     t' +\n    LN $ l =\n    expr_lockss (map fst (eX # eXS)) l", "by(cases eX)(auto simp add: lock_oks1_def)"], ["proof (state)\nthis:\n  has_locks\n   (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l) t' +\n  LN $ l =\n  expr_lockss (map fst (eX # eXS)) l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  has_locks\n   (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l) t' +\n  LN $ l =\n  expr_lockss (map fst (eX # eXS)) l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  has_locks\n   (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l) t' +\n  LN $ l =\n  expr_lockss (map fst (eX # eXS)) l\n\ngoal (3 subgoals):\n 1. \\<And>e x taa e' x'.\n       \\<lbrakk>ex = (e, x); ta = extTA2J1 P taa; ex' = (e', x');\n        exs' = exs;\n        False,P,t \\<turnstile>1 \\<langle>e,\n                                 (shr s1, x)\\<rangle> -taa\\<rightarrow>\n                                \\<langle>e',(m', x')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = shr s1;\n        call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 3. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "}"], ["proof (state)\nthis:\n  has_locks\n   (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ ?l26)\n   t' +\n  LN $ ?l26 =\n  expr_lockss (map fst (eX # eXS)) ?l26\n\ngoal (3 subgoals):\n 1. \\<And>e x taa e' x'.\n       \\<lbrakk>ex = (e, x); ta = extTA2J1 P taa; ex' = (e', x');\n        exs' = exs;\n        False,P,t \\<turnstile>1 \\<langle>e,\n                                 (shr s1, x)\\<rangle> -taa\\<rightarrow>\n                                \\<langle>e',(m', x')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = shr s1;\n        call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 3. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "hence \"\\<forall>l. has_locks ((redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>) $ l) t' + LN $ l = expr_lockss (map fst (eX # eXS)) l\""], ["proof (prove)\nusing this:\n  has_locks\n   (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ ?l26)\n   t' +\n  LN $ ?l26 =\n  expr_lockss (map fst (eX # eXS)) ?l26\n\ngoal (1 subgoal):\n 1. \\<forall>l.\n       has_locks\n        (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n        t' +\n       LN $ l =\n       expr_lockss (map fst (eX # eXS)) l", ".."], ["proof (state)\nthis:\n  \\<forall>l.\n     has_locks\n      (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n      t' +\n     LN $ l =\n     expr_lockss (map fst (eX # eXS)) l\n\ngoal (3 subgoals):\n 1. \\<And>e x taa e' x'.\n       \\<lbrakk>ex = (e, x); ta = extTA2J1 P taa; ex' = (e', x');\n        exs' = exs;\n        False,P,t \\<turnstile>1 \\<langle>e,\n                                 (shr s1, x)\\<rangle> -taa\\<rightarrow>\n                                \\<langle>e',(m', x')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = shr s1;\n        call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 3. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "}"], ["proof (state)\nthis:\n  (redT_updTs (thr s1)\n    (map (convert_new_thread_action (extNTA2J1 P))\n      \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>)\n   (t \\<mapsto>\n   (((e', x'), exs),\n    redT_updLns (locks s1) t (snd (the (thr s1 t)))\n     \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub>)))\n   ?t'26 =\n  \\<lfloor>((?eX26, ?eXS26), ?LN26)\\<rfloor> \\<Longrightarrow>\n  \\<forall>l.\n     has_locks\n      (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n      ?t'26 +\n     ?LN26 $ l =\n     expr_lockss (map fst (?eX26 # ?eXS26)) l\n\ngoal (3 subgoals):\n 1. \\<And>e x taa e' x'.\n       \\<lbrakk>ex = (e, x); ta = extTA2J1 P taa; ex' = (e', x');\n        exs' = exs;\n        False,P,t \\<turnstile>1 \\<langle>e,\n                                 (shr s1, x)\\<rangle> -taa\\<rightarrow>\n                                \\<langle>e',(m', x')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = shr s1;\n        call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 3. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "ultimately"], ["proof (chain)\npicking this:\n  (redT_updTs (thr s1)\n    (map (convert_new_thread_action (extNTA2J1 P))\n      \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>)\n   (t \\<mapsto>\n   (((e', x'), exs),\n    redT_updLns (locks s1) t (snd (the (thr s1 t)))\n     \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub>)))\n   ?t'26 =\n  None \\<Longrightarrow>\n  \\<forall>l.\n     has_locks\n      (upd_locks (locks s1 $ l) t\n        (\\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub> $ l))\n      ?t'26 =\n     0\n  (redT_updTs (thr s1)\n    (map (convert_new_thread_action (extNTA2J1 P))\n      \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>)\n   (t \\<mapsto>\n   (((e', x'), exs),\n    redT_updLns (locks s1) t (snd (the (thr s1 t)))\n     \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub>)))\n   ?t'26 =\n  \\<lfloor>((?eX26, ?eXS26), ?LN26)\\<rfloor> \\<Longrightarrow>\n  \\<forall>l.\n     has_locks\n      (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n      ?t'26 +\n     ?LN26 $ l =\n     expr_lockss (map fst (?eX26 # ?eXS26)) l", "show ?thesis"], ["proof (prove)\nusing this:\n  (redT_updTs (thr s1)\n    (map (convert_new_thread_action (extNTA2J1 P))\n      \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>)\n   (t \\<mapsto>\n   (((e', x'), exs),\n    redT_updLns (locks s1) t (snd (the (thr s1 t)))\n     \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub>)))\n   ?t'26 =\n  None \\<Longrightarrow>\n  \\<forall>l.\n     has_locks\n      (upd_locks (locks s1 $ l) t\n        (\\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub> $ l))\n      ?t'26 =\n     0\n  (redT_updTs (thr s1)\n    (map (convert_new_thread_action (extNTA2J1 P))\n      \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>)\n   (t \\<mapsto>\n   (((e', x'), exs),\n    redT_updLns (locks s1) t (snd (the (thr s1 t)))\n     \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub>)))\n   ?t'26 =\n  \\<lfloor>((?eX26, ?eXS26), ?LN26)\\<rfloor> \\<Longrightarrow>\n  \\<forall>l.\n     has_locks\n      (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n      ?t'26 +\n     ?LN26 $ l =\n     expr_lockss (map fst (?eX26 # ?eXS26)) l\n\ngoal (1 subgoal):\n 1. lock_oks1 (locks s1') (thr s1')", "using s1'"], ["proof (prove)\nusing this:\n  (redT_updTs (thr s1)\n    (map (convert_new_thread_action (extNTA2J1 P))\n      \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>)\n   (t \\<mapsto>\n   (((e', x'), exs),\n    redT_updLns (locks s1) t (snd (the (thr s1 t)))\n     \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub>)))\n   ?t'26 =\n  None \\<Longrightarrow>\n  \\<forall>l.\n     has_locks\n      (upd_locks (locks s1 $ l) t\n        (\\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub> $ l))\n      ?t'26 =\n     0\n  (redT_updTs (thr s1)\n    (map (convert_new_thread_action (extNTA2J1 P))\n      \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>)\n   (t \\<mapsto>\n   (((e', x'), exs),\n    redT_updLns (locks s1) t (snd (the (thr s1 t)))\n     \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub>)))\n   ?t'26 =\n  \\<lfloor>((?eX26, ?eXS26), ?LN26)\\<rfloor> \\<Longrightarrow>\n  \\<forall>l.\n     has_locks\n      (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n      ?t'26 +\n     ?LN26 $ l =\n     expr_lockss (map fst (?eX26 # ?eXS26)) l\n  redT_upd s1 t ta x'__ m' s1'\n\ngoal (1 subgoal):\n 1. lock_oks1 (locks s1') (thr s1')", "unfolding lock_oks1_def x'"], ["proof (prove)\nusing this:\n  (redT_updTs (thr s1)\n    (map (convert_new_thread_action (extNTA2J1 P))\n      \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>)\n   (t \\<mapsto>\n   (((e', x'), exs),\n    redT_updLns (locks s1) t (snd (the (thr s1 t)))\n     \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub>)))\n   ?t'26 =\n  None \\<Longrightarrow>\n  \\<forall>l.\n     has_locks\n      (upd_locks (locks s1 $ l) t\n        (\\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub> $ l))\n      ?t'26 =\n     0\n  (redT_updTs (thr s1)\n    (map (convert_new_thread_action (extNTA2J1 P))\n      \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>)\n   (t \\<mapsto>\n   (((e', x'), exs),\n    redT_updLns (locks s1) t (snd (the (thr s1 t)))\n     \\<lbrace>TA\\<rbrace>\\<^bsub>l\\<^esub>)))\n   ?t'26 =\n  \\<lfloor>((?eX26, ?eXS26), ?LN26)\\<rfloor> \\<Longrightarrow>\n  \\<forall>l.\n     has_locks\n      (redT_updLs (locks s1) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n      ?t'26 +\n     ?LN26 $ l =\n     expr_lockss (map fst (?eX26 # ?eXS26)) l\n  redT_upd s1 t ta (ex', exs') m' s1'\n\ngoal (1 subgoal):\n 1. \\<forall>t.\n       case thr s1' t of\n       None \\<Rightarrow> \\<forall>l. has_locks (locks s1' $ l) t = 0\n       | \\<lfloor>((ex, exs), ln)\\<rfloor> \\<Rightarrow>\n           \\<forall>l.\n              has_locks (locks s1' $ l) t + ln $ l =\n              expr_lockss (map fst (ex # exs)) l", "by(clarsimp simp del: fun_upd_apply)"], ["proof (state)\nthis:\n  lock_oks1 (locks s1') (thr s1')\n\ngoal (2 subgoals):\n 1. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = shr s1;\n        call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = shr s1;\n        call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "case (red1Call e a M vs U Ts T body D x)"], ["proof (state)\nthis:\n  ex = (e, x)\n  ta = \\<lbrace>\\<rbrace>\n  ex' =\n  (blocks1 0 (Class D # Ts) body,\n   Addr a # vs @ replicate (max_vars body) undefined_value)\n  exs' = (e, x) # exs\n  m' = shr s1\n  call1 e = \\<lfloor>(a, M, vs)\\<rfloor>\n  typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>\n  P \\<turnstile> class_type_of\n                  U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\n  length vs = length Ts\n\ngoal (2 subgoals):\n 1. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = shr s1;\n        call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "from wf \\<open>P \\<turnstile> class_type_of U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\\<close>"], ["proof (chain)\npicking this:\n  wf_J1_prog P\n  P \\<turnstile> class_type_of\n                  U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D", "obtain T' where \"P,Class D # Ts \\<turnstile>1 body :: T'\""], ["proof (prove)\nusing this:\n  wf_J1_prog P\n  P \\<turnstile> class_type_of\n                  U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\n\ngoal (1 subgoal):\n 1. (\\<And>T'.\n        P,Class D # Ts \\<turnstile>1 body :: T' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: wf_mdecl_def dest!: sees_wf_mdecl)"], ["proof (state)\nthis:\n  P,Class D # Ts \\<turnstile>1 body :: T'\n\ngoal (2 subgoals):\n 1. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = shr s1;\n        call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "hence \"expr_locks (blocks1 0 (Class D#Ts) body) = (\\<lambda>l. 0)\""], ["proof (prove)\nusing this:\n  P,Class D # Ts \\<turnstile>1 body :: T'\n\ngoal (1 subgoal):\n 1. expr_locks (blocks1 0 (Class D # Ts) body) = (\\<lambda>l. 0)", "by(auto simp add: expr_locks_blocks1 contains_insync_conv fun_eq_iff dest!: WT1_not_contains_insync)"], ["proof (state)\nthis:\n  expr_locks (blocks1 0 (Class D # Ts) body) = (\\<lambda>l. 0)\n\ngoal (2 subgoals):\n 1. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; m' = shr s1;\n        call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "thus ?thesis"], ["proof (prove)\nusing this:\n  expr_locks (blocks1 0 (Class D # Ts) body) = (\\<lambda>l. 0)\n\ngoal (1 subgoal):\n 1. lock_oks1 (locks s1') (thr s1')", "using red1Call thrst loks s1'"], ["proof (prove)\nusing this:\n  expr_locks (blocks1 0 (Class D # Ts) body) = (\\<lambda>l. 0)\n  ex = (e, x)\n  ta = \\<lbrace>\\<rbrace>\n  ex' =\n  (blocks1 0 (Class D # Ts) body,\n   Addr a # vs @ replicate (max_vars body) undefined_value)\n  exs' = (e, x) # exs\n  m' = shr s1\n  call1 e = \\<lfloor>(a, M, vs)\\<rfloor>\n  typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>\n  P \\<turnstile> class_type_of\n                  U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\n  length vs = length Ts\n  thr s1 t = \\<lfloor>(x__, no_wait_locks)\\<rfloor>\n  lock_oks1 (locks s1) (thr s1)\n  redT_upd s1 t ta x' m' s1'\n\ngoal (1 subgoal):\n 1. lock_oks1 (locks s1') (thr s1')", "unfolding lock_oks1_def x' x"], ["proof (prove)\nusing this:\n  expr_locks (blocks1 0 (Class D # Ts) body) = (\\<lambda>l. 0)\n  ex = (e, x)\n  ta = \\<lbrace>\\<rbrace>\n  ex' =\n  (blocks1 0 (Class D # Ts) body,\n   Addr a # vs @ replicate (max_vars body) undefined_value)\n  exs' = (e, x) # exs\n  m' = shr s1\n  call1 e = \\<lfloor>(a, M, vs)\\<rfloor>\n  typeof_addr (shr s1) a = \\<lfloor>U\\<rfloor>\n  P \\<turnstile> class_type_of\n                  U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\n  length vs = length Ts\n  thr s1 t = \\<lfloor>((ex, exs), no_wait_locks)\\<rfloor>\n  \\<forall>t.\n     case thr s1 t of\n     None \\<Rightarrow> \\<forall>l. has_locks (locks s1 $ l) t = 0\n     | \\<lfloor>((ex, exs), ln)\\<rfloor> \\<Rightarrow>\n         \\<forall>l.\n            has_locks (locks s1 $ l) t + ln $ l =\n            expr_lockss (map fst (ex # exs)) l\n  redT_upd s1 t ta (ex', exs') m' s1'\n\ngoal (1 subgoal):\n 1. \\<forall>t.\n       case thr s1' t of\n       None \\<Rightarrow> \\<forall>l. has_locks (locks s1' $ l) t = 0\n       | \\<lfloor>((ex, exs), ln)\\<rfloor> \\<Rightarrow>\n           \\<forall>l.\n              has_locks (locks s1' $ l) t + ln $ l =\n              expr_lockss (map fst (ex # exs)) l", "by auto force+"], ["proof (state)\nthis:\n  lock_oks1 (locks s1') (thr s1')\n\ngoal (1 subgoal):\n 1. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "case (red1Return e' x' e x)"], ["proof (state)\nthis:\n  ex = (e', x')\n  exs = (e, x) # exs'\n  ta = \\<lbrace>\\<rbrace>\n  ex' = (inline_call e' e, x)\n  m' = shr s1\n  final e'\n\ngoal (1 subgoal):\n 1. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "thus ?thesis"], ["proof (prove)\nusing this:\n  ex = (e', x')\n  exs = (e, x) # exs'\n  ta = \\<lbrace>\\<rbrace>\n  ex' = (inline_call e' e, x)\n  m' = shr s1\n  final e'\n\ngoal (1 subgoal):\n 1. lock_oks1 (locks s1') (thr s1')", "using thrst loks s1'"], ["proof (prove)\nusing this:\n  ex = (e', x')\n  exs = (e, x) # exs'\n  ta = \\<lbrace>\\<rbrace>\n  ex' = (inline_call e' e, x)\n  m' = shr s1\n  final e'\n  thr s1 t = \\<lfloor>(x__, no_wait_locks)\\<rfloor>\n  lock_oks1 (locks s1) (thr s1)\n  redT_upd s1 t ta x'__ m' s1'\n\ngoal (1 subgoal):\n 1. lock_oks1 (locks s1') (thr s1')", "unfolding lock_oks1_def x' x"], ["proof (prove)\nusing this:\n  ex = (e', x')\n  exs = (e, x) # exs'\n  ta = \\<lbrace>\\<rbrace>\n  ex' = (inline_call e' e, x)\n  m' = shr s1\n  final e'\n  thr s1 t = \\<lfloor>((ex, exs), no_wait_locks)\\<rfloor>\n  \\<forall>t.\n     case thr s1 t of\n     None \\<Rightarrow> \\<forall>l. has_locks (locks s1 $ l) t = 0\n     | \\<lfloor>((ex, exs), ln)\\<rfloor> \\<Rightarrow>\n         \\<forall>l.\n            has_locks (locks s1 $ l) t + ln $ l =\n            expr_lockss (map fst (ex # exs)) l\n  redT_upd s1 t ta (ex', exs') m' s1'\n\ngoal (1 subgoal):\n 1. \\<forall>t.\n       case thr s1' t of\n       None \\<Rightarrow> \\<forall>l. has_locks (locks s1' $ l) t = 0\n       | \\<lfloor>((ex, exs), ln)\\<rfloor> \\<Rightarrow>\n           \\<forall>l.\n              has_locks (locks s1' $ l) t + ln $ l =\n              expr_lockss (map fst (ex # exs)) l", "apply(auto simp add: redT_updWs_def elim!: rtrancl3p_cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>\\<forall>t.\n                   ((\\<exists>a b ba bb.\n                        thr s1 t =\n                        \\<lfloor>(((a, b), ba), bb)\\<rfloor>) \\<or>\n                    (\\<forall>l. has_locks (locks s1 $ l) t = 0)) \\<and>\n                   (\\<forall>a b ba bb.\n                       thr s1 t =\n                       \\<lfloor>(((a, b), ba),\n                                 bb)\\<rfloor> \\<longrightarrow>\n                       (\\<forall>l.\n                           has_locks (locks s1 $ l) t + bb $ l =\n                           expr_locks a l + expr_lockss (map fst ba) l));\n        ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e';\n        thr s1 t =\n        \\<lfloor>(((e', x'), (e, x) # exs'), no_wait_locks)\\<rfloor>;\n        s1' =\n        (locks s1,\n         (thr s1(t \\<mapsto>\n          (((inline_call e' e, x), exs'),\n           redT_updLns (locks s1) t no_wait_locks (K$ []))),\n          shr s1),\n         wset s1, interrupts s1)\\<rbrakk>\n       \\<Longrightarrow> has_locks (locks s1 $ l) t =\n                         expr_locks (inline_call e' e) l +\n                         expr_lockss (map fst exs') l\n 2. \\<And>tb l.\n       \\<lbrakk>\\<forall>t.\n                   ((\\<exists>a b ba bb.\n                        thr s1 t =\n                        \\<lfloor>(((a, b), ba), bb)\\<rfloor>) \\<or>\n                    (\\<forall>l. has_locks (locks s1 $ l) t = 0)) \\<and>\n                   (\\<forall>a b ba bb.\n                       thr s1 t =\n                       \\<lfloor>(((a, b), ba),\n                                 bb)\\<rfloor> \\<longrightarrow>\n                       (\\<forall>l.\n                           has_locks (locks s1 $ l) t + bb $ l =\n                           expr_locks a l + expr_lockss (map fst ba) l));\n        ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e';\n        thr s1 t =\n        \\<lfloor>(((e', x'), (e, x) # exs'), no_wait_locks)\\<rfloor>;\n        s1' =\n        (locks s1,\n         (thr s1(t \\<mapsto>\n          (((inline_call e' e, x), exs'),\n           redT_updLns (locks s1) t no_wait_locks (K$ []))),\n          shr s1),\n         wset s1, interrupts s1);\n        tb \\<noteq> t; thr s1 tb = None\\<rbrakk>\n       \\<Longrightarrow> has_locks (locks s1 $ l) tb = 0", "apply(erule_tac x=t in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e';\n        thr s1 t =\n        \\<lfloor>(((e', x'), (e, x) # exs'), no_wait_locks)\\<rfloor>;\n        s1' =\n        (locks s1,\n         (thr s1(t \\<mapsto>\n          (((inline_call e' e, x), exs'),\n           redT_updLns (locks s1) t no_wait_locks (K$ []))),\n          shr s1),\n         wset s1, interrupts s1);\n        ((\\<exists>a b ba bb.\n             thr s1 t = \\<lfloor>(((a, b), ba), bb)\\<rfloor>) \\<or>\n         (\\<forall>l. has_locks (locks s1 $ l) t = 0)) \\<and>\n        (\\<forall>a b ba bb.\n            thr s1 t =\n            \\<lfloor>(((a, b), ba), bb)\\<rfloor> \\<longrightarrow>\n            (\\<forall>l.\n                has_locks (locks s1 $ l) t + bb $ l =\n                expr_locks a l + expr_lockss (map fst ba) l))\\<rbrakk>\n       \\<Longrightarrow> has_locks (locks s1 $ l) t =\n                         expr_locks (inline_call e' e) l +\n                         expr_lockss (map fst exs') l\n 2. \\<And>tb l.\n       \\<lbrakk>\\<forall>t.\n                   ((\\<exists>a b ba bb.\n                        thr s1 t =\n                        \\<lfloor>(((a, b), ba), bb)\\<rfloor>) \\<or>\n                    (\\<forall>l. has_locks (locks s1 $ l) t = 0)) \\<and>\n                   (\\<forall>a b ba bb.\n                       thr s1 t =\n                       \\<lfloor>(((a, b), ba),\n                                 bb)\\<rfloor> \\<longrightarrow>\n                       (\\<forall>l.\n                           has_locks (locks s1 $ l) t + bb $ l =\n                           expr_locks a l + expr_lockss (map fst ba) l));\n        ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e';\n        thr s1 t =\n        \\<lfloor>(((e', x'), (e, x) # exs'), no_wait_locks)\\<rfloor>;\n        s1' =\n        (locks s1,\n         (thr s1(t \\<mapsto>\n          (((inline_call e' e, x), exs'),\n           redT_updLns (locks s1) t no_wait_locks (K$ []))),\n          shr s1),\n         wset s1, interrupts s1);\n        tb \\<noteq> t; thr s1 tb = None\\<rbrakk>\n       \\<Longrightarrow> has_locks (locks s1 $ l) tb = 0", "apply(erule conjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e';\n        thr s1 t =\n        \\<lfloor>(((e', x'), (e, x) # exs'), no_wait_locks)\\<rfloor>;\n        s1' =\n        (locks s1,\n         (thr s1(t \\<mapsto>\n          (((inline_call e' e, x), exs'),\n           redT_updLns (locks s1) t no_wait_locks (K$ []))),\n          shr s1),\n         wset s1, interrupts s1);\n        (\\<exists>a b ba bb.\n            thr s1 t = \\<lfloor>(((a, b), ba), bb)\\<rfloor>) \\<or>\n        (\\<forall>l. has_locks (locks s1 $ l) t = 0);\n        \\<forall>a b ba bb.\n           thr s1 t = \\<lfloor>(((a, b), ba), bb)\\<rfloor> \\<longrightarrow>\n           (\\<forall>l.\n               has_locks (locks s1 $ l) t + bb $ l =\n               expr_locks a l + expr_lockss (map fst ba) l)\\<rbrakk>\n       \\<Longrightarrow> has_locks (locks s1 $ l) t =\n                         expr_locks (inline_call e' e) l +\n                         expr_lockss (map fst exs') l\n 2. \\<And>tb l.\n       \\<lbrakk>\\<forall>t.\n                   ((\\<exists>a b ba bb.\n                        thr s1 t =\n                        \\<lfloor>(((a, b), ba), bb)\\<rfloor>) \\<or>\n                    (\\<forall>l. has_locks (locks s1 $ l) t = 0)) \\<and>\n                   (\\<forall>a b ba bb.\n                       thr s1 t =\n                       \\<lfloor>(((a, b), ba),\n                                 bb)\\<rfloor> \\<longrightarrow>\n                       (\\<forall>l.\n                           has_locks (locks s1 $ l) t + bb $ l =\n                           expr_locks a l + expr_lockss (map fst ba) l));\n        ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e';\n        thr s1 t =\n        \\<lfloor>(((e', x'), (e, x) # exs'), no_wait_locks)\\<rfloor>;\n        s1' =\n        (locks s1,\n         (thr s1(t \\<mapsto>\n          (((inline_call e' e, x), exs'),\n           redT_updLns (locks s1) t no_wait_locks (K$ []))),\n          shr s1),\n         wset s1, interrupts s1);\n        tb \\<noteq> t; thr s1 tb = None\\<rbrakk>\n       \\<Longrightarrow> has_locks (locks s1 $ l) tb = 0", "apply(erule disjE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e';\n        thr s1 t =\n        \\<lfloor>(((e', x'), (e, x) # exs'), no_wait_locks)\\<rfloor>;\n        s1' =\n        (locks s1,\n         (thr s1(t \\<mapsto>\n          (((inline_call e' e, x), exs'),\n           redT_updLns (locks s1) t no_wait_locks (K$ []))),\n          shr s1),\n         wset s1, interrupts s1);\n        \\<forall>a b ba bb.\n           thr s1 t = \\<lfloor>(((a, b), ba), bb)\\<rfloor> \\<longrightarrow>\n           (\\<forall>l.\n               has_locks (locks s1 $ l) t + bb $ l =\n               expr_locks a l + expr_lockss (map fst ba) l);\n        \\<exists>a b ba bb.\n           thr s1 t = \\<lfloor>(((a, b), ba), bb)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> has_locks (locks s1 $ l) t =\n                         expr_locks (inline_call e' e) l +\n                         expr_lockss (map fst exs') l\n 2. \\<And>l.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e';\n        thr s1 t =\n        \\<lfloor>(((e', x'), (e, x) # exs'), no_wait_locks)\\<rfloor>;\n        s1' =\n        (locks s1,\n         (thr s1(t \\<mapsto>\n          (((inline_call e' e, x), exs'),\n           redT_updLns (locks s1) t no_wait_locks (K$ []))),\n          shr s1),\n         wset s1, interrupts s1);\n        \\<forall>a b ba bb.\n           thr s1 t = \\<lfloor>(((a, b), ba), bb)\\<rfloor> \\<longrightarrow>\n           (\\<forall>l.\n               has_locks (locks s1 $ l) t + bb $ l =\n               expr_locks a l + expr_lockss (map fst ba) l);\n        \\<forall>l. has_locks (locks s1 $ l) t = 0\\<rbrakk>\n       \\<Longrightarrow> has_locks (locks s1 $ l) t =\n                         expr_locks (inline_call e' e) l +\n                         expr_lockss (map fst exs') l\n 3. \\<And>tb l.\n       \\<lbrakk>\\<forall>t.\n                   ((\\<exists>a b ba bb.\n                        thr s1 t =\n                        \\<lfloor>(((a, b), ba), bb)\\<rfloor>) \\<or>\n                    (\\<forall>l. has_locks (locks s1 $ l) t = 0)) \\<and>\n                   (\\<forall>a b ba bb.\n                       thr s1 t =\n                       \\<lfloor>(((a, b), ba),\n                                 bb)\\<rfloor> \\<longrightarrow>\n                       (\\<forall>l.\n                           has_locks (locks s1 $ l) t + bb $ l =\n                           expr_locks a l + expr_lockss (map fst ba) l));\n        ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e';\n        thr s1 t =\n        \\<lfloor>(((e', x'), (e, x) # exs'), no_wait_locks)\\<rfloor>;\n        s1' =\n        (locks s1,\n         (thr s1(t \\<mapsto>\n          (((inline_call e' e, x), exs'),\n           redT_updLns (locks s1) t no_wait_locks (K$ []))),\n          shr s1),\n         wset s1, interrupts s1);\n        tb \\<noteq> t; thr s1 tb = None\\<rbrakk>\n       \\<Longrightarrow> has_locks (locks s1 $ l) tb = 0", "apply(force simp add: expr_locks_inline_call_final ac_simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e';\n        thr s1 t =\n        \\<lfloor>(((e', x'), (e, x) # exs'), no_wait_locks)\\<rfloor>;\n        s1' =\n        (locks s1,\n         (thr s1(t \\<mapsto>\n          (((inline_call e' e, x), exs'),\n           redT_updLns (locks s1) t no_wait_locks (K$ []))),\n          shr s1),\n         wset s1, interrupts s1);\n        \\<forall>a b ba bb.\n           thr s1 t = \\<lfloor>(((a, b), ba), bb)\\<rfloor> \\<longrightarrow>\n           (\\<forall>l.\n               has_locks (locks s1 $ l) t + bb $ l =\n               expr_locks a l + expr_lockss (map fst ba) l);\n        \\<forall>l. has_locks (locks s1 $ l) t = 0\\<rbrakk>\n       \\<Longrightarrow> has_locks (locks s1 $ l) t =\n                         expr_locks (inline_call e' e) l +\n                         expr_lockss (map fst exs') l\n 2. \\<And>tb l.\n       \\<lbrakk>\\<forall>t.\n                   ((\\<exists>a b ba bb.\n                        thr s1 t =\n                        \\<lfloor>(((a, b), ba), bb)\\<rfloor>) \\<or>\n                    (\\<forall>l. has_locks (locks s1 $ l) t = 0)) \\<and>\n                   (\\<forall>a b ba bb.\n                       thr s1 t =\n                       \\<lfloor>(((a, b), ba),\n                                 bb)\\<rfloor> \\<longrightarrow>\n                       (\\<forall>l.\n                           has_locks (locks s1 $ l) t + bb $ l =\n                           expr_locks a l + expr_lockss (map fst ba) l));\n        ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e';\n        thr s1 t =\n        \\<lfloor>(((e', x'), (e, x) # exs'), no_wait_locks)\\<rfloor>;\n        s1' =\n        (locks s1,\n         (thr s1(t \\<mapsto>\n          (((inline_call e' e, x), exs'),\n           redT_updLns (locks s1) t no_wait_locks (K$ []))),\n          shr s1),\n         wset s1, interrupts s1);\n        tb \\<noteq> t; thr s1 tb = None\\<rbrakk>\n       \\<Longrightarrow> has_locks (locks s1 $ l) tb = 0", "apply(fastforce simp add: expr_locks_inline_call_final)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tb l.\n       \\<lbrakk>\\<forall>t.\n                   ((\\<exists>a b ba bb.\n                        thr s1 t =\n                        \\<lfloor>(((a, b), ba), bb)\\<rfloor>) \\<or>\n                    (\\<forall>l. has_locks (locks s1 $ l) t = 0)) \\<and>\n                   (\\<forall>a b ba bb.\n                       thr s1 t =\n                       \\<lfloor>(((a, b), ba),\n                                 bb)\\<rfloor> \\<longrightarrow>\n                       (\\<forall>l.\n                           has_locks (locks s1 $ l) t + bb $ l =\n                           expr_locks a l + expr_lockss (map fst ba) l));\n        ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); m' = shr s1; final e';\n        thr s1 t =\n        \\<lfloor>(((e', x'), (e, x) # exs'), no_wait_locks)\\<rfloor>;\n        s1' =\n        (locks s1,\n         (thr s1(t \\<mapsto>\n          (((inline_call e' e, x), exs'),\n           redT_updLns (locks s1) t no_wait_locks (K$ []))),\n          shr s1),\n         wset s1, interrupts s1);\n        tb \\<noteq> t; thr s1 tb = None\\<rbrakk>\n       \\<Longrightarrow> has_locks (locks s1 $ l) tb = 0", "apply hypsubst_thin"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ta l.\n       \\<lbrakk>\\<forall>t.\n                   ((\\<exists>a b ba bb.\n                        thr s1 t =\n                        \\<lfloor>(((a, b), ba), bb)\\<rfloor>) \\<or>\n                    (\\<forall>l. has_locks (locks s1 $ l) t = 0)) \\<and>\n                   (\\<forall>a b ba bb.\n                       thr s1 t =\n                       \\<lfloor>(((a, b), ba),\n                                 bb)\\<rfloor> \\<longrightarrow>\n                       (\\<forall>l.\n                           has_locks (locks s1 $ l) t + bb $ l =\n                           expr_locks a l + expr_lockss (map fst ba) l));\n        final e';\n        thr s1 t =\n        \\<lfloor>(((e', x'), (e, x) # exs'), no_wait_locks)\\<rfloor>;\n        ta \\<noteq> t; thr s1 ta = None\\<rbrakk>\n       \\<Longrightarrow> has_locks (locks s1 $ l) ta = 0", "apply(erule_tac x=ta in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ta l.\n       \\<lbrakk>final e';\n        thr s1 t =\n        \\<lfloor>(((e', x'), (e, x) # exs'), no_wait_locks)\\<rfloor>;\n        ta \\<noteq> t; thr s1 ta = None;\n        ((\\<exists>a b ba bb.\n             thr s1 ta = \\<lfloor>(((a, b), ba), bb)\\<rfloor>) \\<or>\n         (\\<forall>l. has_locks (locks s1 $ l) ta = 0)) \\<and>\n        (\\<forall>a b ba bb.\n            thr s1 ta =\n            \\<lfloor>(((a, b), ba), bb)\\<rfloor> \\<longrightarrow>\n            (\\<forall>l.\n                has_locks (locks s1 $ l) ta + bb $ l =\n                expr_locks a l + expr_lockss (map fst ba) l))\\<rbrakk>\n       \\<Longrightarrow> has_locks (locks s1 $ l) ta = 0", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  lock_oks1 (locks s1') (thr s1')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lock_oks1 (locks s1') (thr s1')\n\ngoal (2 subgoals):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>ta1 = (t, ta);\n        Red1_mthr.r_syntax False P t x (shr s1) ta x' m';\n        thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.actions_ok s1 t ta; redT_upd s1 t ta x' m' s1'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>t x n ln.\n       \\<lbrakk>ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        thr s1 t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s1 t);\n        may_acquire_all (locks s1) t ln; 0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (x, no_wait_locks)), shr s1), wset s1,\n         interrupts s1)\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "moreover"], ["proof (state)\nthis:\n  lock_oks1 (locks s1') (thr s1')\n\ngoal (2 subgoals):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>ta1 = (t, ta);\n        Red1_mthr.r_syntax False P t x (shr s1) ta x' m';\n        thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.actions_ok s1 t ta; redT_upd s1 t ta x' m' s1'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>t x n ln.\n       \\<lbrakk>ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        thr s1 t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s1 t);\n        may_acquire_all (locks s1) t ln; 0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (x, no_wait_locks)), shr s1), wset s1,\n         interrupts s1)\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "from sync \\<open>mred1' P t (x, shr s1) ta (x', m')\\<close> thrst aoe s1'"], ["proof (chain)\npicking this:\n  ts_ok (\\<lambda>t exexs h. el_loc_ok1 exexs) (thr s1) (shr s1)\n  Red1_mthr.r_syntax False P t x (shr s1) ta x' m'\n  thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  Red1_mthr.actions_ok s1 t ta\n  redT_upd s1 t ta x' m' s1'", "have \"ts_ok (\\<lambda>t exexs h. el_loc_ok1 exexs) (thr s1') (shr s1')\""], ["proof (prove)\nusing this:\n  ts_ok (\\<lambda>t exexs h. el_loc_ok1 exexs) (thr s1) (shr s1)\n  Red1_mthr.r_syntax False P t x (shr s1) ta x' m'\n  thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  Red1_mthr.actions_ok s1 t ta\n  redT_upd s1 t ta x' m' s1'\n\ngoal (1 subgoal):\n 1. ts_ok (\\<lambda>t exexs h. el_loc_ok1 exexs) (thr s1') (shr s1')", "by(auto intro: lifting_wf.redT_updTs_preserves[OF Red1_el_loc_ok[OF wf]])"], ["proof (state)\nthis:\n  ts_ok (\\<lambda>t exexs h. el_loc_ok1 exexs) (thr s1') (shr s1')\n\ngoal (2 subgoals):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>ta1 = (t, ta);\n        Red1_mthr.r_syntax False P t x (shr s1) ta x' m';\n        thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.actions_ok s1 t ta; redT_upd s1 t ta x' m' s1'\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')\n 2. \\<And>t x n ln.\n       \\<lbrakk>ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        thr s1 t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s1 t);\n        may_acquire_all (locks s1) t ln; 0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (x, no_wait_locks)), shr s1), wset s1,\n         interrupts s1)\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "ultimately"], ["proof (chain)\npicking this:\n  redT_upd s1 t ta x' m' s1'\n  lock_oks1 (locks s1') (thr s1')\n  ts_ok (\\<lambda>t exexs h. el_loc_ok1 exexs) (thr s1') (shr s1')", "show ?thesis"], ["proof (prove)\nusing this:\n  redT_upd s1 t ta x' m' s1'\n  lock_oks1 (locks s1') (thr s1')\n  ts_ok (\\<lambda>t exexs h. el_loc_ok1 exexs) (thr s1') (shr s1')\n\ngoal (1 subgoal):\n 1. lock_oks1 (locks s1') (thr s1')", "by simp"], ["proof (state)\nthis:\n  lock_oks1 (locks s1') (thr s1')\n\ngoal (1 subgoal):\n 1. \\<And>t x n ln.\n       \\<lbrakk>ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        thr s1 t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s1 t);\n        may_acquire_all (locks s1) t ln; 0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (x, no_wait_locks)), shr s1), wset s1,\n         interrupts s1)\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t x n ln.\n       \\<lbrakk>ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        thr s1 t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s1 t);\n        may_acquire_all (locks s1) t ln; 0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (x, no_wait_locks)), shr s1), wset s1,\n         interrupts s1)\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "case (redT_acquire t x n ln)"], ["proof (state)\nthis:\n  ta1 = (t, K$ [], [], [], [], [], convert_RA ln)\n  thr s1 t = \\<lfloor>(x, ln)\\<rfloor>\n  \\<not> waiting (wset s1 t)\n  may_acquire_all (locks s1) t ln\n  0 < ln $ n\n  s1' =\n  (acquire_all (locks s1) t ln,\n   (thr s1(t \\<mapsto> (x, no_wait_locks)), shr s1), wset s1, interrupts s1)\n\ngoal (1 subgoal):\n 1. \\<And>t x n ln.\n       \\<lbrakk>ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        thr s1 t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s1 t);\n        may_acquire_all (locks s1) t ln; 0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (x, no_wait_locks)), shr s1), wset s1,\n         interrupts s1)\\<rbrakk>\n       \\<Longrightarrow> lock_oks1 (locks s1') (thr s1')", "thus ?thesis"], ["proof (prove)\nusing this:\n  ta1 = (t, K$ [], [], [], [], [], convert_RA ln)\n  thr s1 t = \\<lfloor>(x, ln)\\<rfloor>\n  \\<not> waiting (wset s1 t)\n  may_acquire_all (locks s1) t ln\n  0 < ln $ n\n  s1' =\n  (acquire_all (locks s1) t ln,\n   (thr s1(t \\<mapsto> (x, no_wait_locks)), shr s1), wset s1, interrupts s1)\n\ngoal (1 subgoal):\n 1. lock_oks1 (locks s1') (thr s1')", "using loks"], ["proof (prove)\nusing this:\n  ta1 = (t, K$ [], [], [], [], [], convert_RA ln)\n  thr s1 t = \\<lfloor>(x, ln)\\<rfloor>\n  \\<not> waiting (wset s1 t)\n  may_acquire_all (locks s1) t ln\n  0 < ln $ n\n  s1' =\n  (acquire_all (locks s1) t ln,\n   (thr s1(t \\<mapsto> (x, no_wait_locks)), shr s1), wset s1, interrupts s1)\n  lock_oks1 (locks s1) (thr s1)\n\ngoal (1 subgoal):\n 1. lock_oks1 (locks s1') (thr s1')", "unfolding lock_oks1_def"], ["proof (prove)\nusing this:\n  ta1 = (t, K$ [], [], [], [], [], convert_RA ln)\n  thr s1 t = \\<lfloor>(x, ln)\\<rfloor>\n  \\<not> waiting (wset s1 t)\n  may_acquire_all (locks s1) t ln\n  0 < ln $ n\n  s1' =\n  (acquire_all (locks s1) t ln,\n   (thr s1(t \\<mapsto> (x, no_wait_locks)), shr s1), wset s1, interrupts s1)\n  \\<forall>t.\n     case thr s1 t of\n     None \\<Rightarrow> \\<forall>l. has_locks (locks s1 $ l) t = 0\n     | \\<lfloor>((ex, exs), ln)\\<rfloor> \\<Rightarrow>\n         \\<forall>l.\n            has_locks (locks s1 $ l) t + ln $ l =\n            expr_lockss (map fst (ex # exs)) l\n\ngoal (1 subgoal):\n 1. \\<forall>t.\n       case thr s1' t of\n       None \\<Rightarrow> \\<forall>l. has_locks (locks s1' $ l) t = 0\n       | \\<lfloor>((ex, exs), ln)\\<rfloor> \\<Rightarrow>\n           \\<forall>l.\n              has_locks (locks s1' $ l) t + ln $ l =\n              expr_lockss (map fst (ex # exs)) l", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ta l.\n       \\<lbrakk>\\<forall>t.\n                   ((\\<exists>a b ba bb.\n                        thr s1 t =\n                        \\<lfloor>(((a, b), ba), bb)\\<rfloor>) \\<or>\n                    (\\<forall>l. has_locks (locks s1 $ l) t = 0)) \\<and>\n                   (\\<forall>a b ba bb.\n                       thr s1 t =\n                       \\<lfloor>(((a, b), ba),\n                                 bb)\\<rfloor> \\<longrightarrow>\n                       (\\<forall>l.\n                           has_locks (locks s1 $ l) t + bb $ l =\n                           expr_locks a l + expr_lockss (map fst ba) l));\n        ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        thr s1 t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s1 t);\n        may_acquire_all (locks s1) t ln; 0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (x, no_wait_locks)), shr s1), wset s1,\n         interrupts s1);\n        thr s1 ta = None; ta \\<noteq> t\\<rbrakk>\n       \\<Longrightarrow> has_locks (locks s1 $ l) ta = 0\n 2. \\<And>a b ba l.\n       \\<lbrakk>\\<forall>t.\n                   ((\\<exists>a b ba bb.\n                        thr s1 t =\n                        \\<lfloor>(((a, b), ba), bb)\\<rfloor>) \\<or>\n                    (\\<forall>l. has_locks (locks s1 $ l) t = 0)) \\<and>\n                   (\\<forall>a b ba bb.\n                       thr s1 t =\n                       \\<lfloor>(((a, b), ba),\n                                 bb)\\<rfloor> \\<longrightarrow>\n                       (\\<forall>l.\n                           has_locks (locks s1 $ l) t + bb $ l =\n                           expr_locks a l + expr_lockss (map fst ba) l));\n        ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset s1 t); may_acquire_all (locks s1) t ln;\n        0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (((a, b), ba), no_wait_locks)), shr s1),\n         wset s1, interrupts s1);\n        thr s1 t = \\<lfloor>(((a, b), ba), ln)\\<rfloor>;\n        x = ((a, b), ba)\\<rbrakk>\n       \\<Longrightarrow> has_locks (acquire_locks (locks s1 $ l) t (ln $ l))\n                          t =\n                         expr_locks a l + expr_lockss (map fst ba) l", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba l.\n       \\<lbrakk>\\<forall>t.\n                   ((\\<exists>a b ba bb.\n                        thr s1 t =\n                        \\<lfloor>(((a, b), ba), bb)\\<rfloor>) \\<or>\n                    (\\<forall>l. has_locks (locks s1 $ l) t = 0)) \\<and>\n                   (\\<forall>a b ba bb.\n                       thr s1 t =\n                       \\<lfloor>(((a, b), ba),\n                                 bb)\\<rfloor> \\<longrightarrow>\n                       (\\<forall>l.\n                           has_locks (locks s1 $ l) t + bb $ l =\n                           expr_locks a l + expr_lockss (map fst ba) l));\n        ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset s1 t); may_acquire_all (locks s1) t ln;\n        0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (((a, b), ba), no_wait_locks)), shr s1),\n         wset s1, interrupts s1);\n        thr s1 t = \\<lfloor>(((a, b), ba), ln)\\<rfloor>;\n        x = ((a, b), ba)\\<rbrakk>\n       \\<Longrightarrow> has_locks (acquire_locks (locks s1 $ l) t (ln $ l))\n                          t =\n                         expr_locks a l + expr_lockss (map fst ba) l", "apply(case_tac \"ln $ l::nat\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b ba l.\n       \\<lbrakk>\\<forall>t.\n                   ((\\<exists>a b ba bb.\n                        thr s1 t =\n                        \\<lfloor>(((a, b), ba), bb)\\<rfloor>) \\<or>\n                    (\\<forall>l. has_locks (locks s1 $ l) t = 0)) \\<and>\n                   (\\<forall>a b ba bb.\n                       thr s1 t =\n                       \\<lfloor>(((a, b), ba),\n                                 bb)\\<rfloor> \\<longrightarrow>\n                       (\\<forall>l.\n                           has_locks (locks s1 $ l) t + bb $ l =\n                           expr_locks a l + expr_lockss (map fst ba) l));\n        ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset s1 t); may_acquire_all (locks s1) t ln;\n        0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (((a, b), ba), no_wait_locks)), shr s1),\n         wset s1, interrupts s1);\n        thr s1 t = \\<lfloor>(((a, b), ba), ln)\\<rfloor>; x = ((a, b), ba);\n        ln $ l = 0\\<rbrakk>\n       \\<Longrightarrow> has_locks (acquire_locks (locks s1 $ l) t (ln $ l))\n                          t =\n                         expr_locks a l + expr_lockss (map fst ba) l\n 2. \\<And>a b ba l nat.\n       \\<lbrakk>\\<forall>t.\n                   ((\\<exists>a b ba bb.\n                        thr s1 t =\n                        \\<lfloor>(((a, b), ba), bb)\\<rfloor>) \\<or>\n                    (\\<forall>l. has_locks (locks s1 $ l) t = 0)) \\<and>\n                   (\\<forall>a b ba bb.\n                       thr s1 t =\n                       \\<lfloor>(((a, b), ba),\n                                 bb)\\<rfloor> \\<longrightarrow>\n                       (\\<forall>l.\n                           has_locks (locks s1 $ l) t + bb $ l =\n                           expr_locks a l + expr_lockss (map fst ba) l));\n        ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset s1 t); may_acquire_all (locks s1) t ln;\n        0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (((a, b), ba), no_wait_locks)), shr s1),\n         wset s1, interrupts s1);\n        thr s1 t = \\<lfloor>(((a, b), ba), ln)\\<rfloor>; x = ((a, b), ba);\n        ln $ l = Suc nat\\<rbrakk>\n       \\<Longrightarrow> has_locks (acquire_locks (locks s1 $ l) t (ln $ l))\n                          t =\n                         expr_locks a l + expr_lockss (map fst ba) l", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b ba l.\n       \\<lbrakk>\\<forall>t.\n                   ((\\<exists>a b ba bb.\n                        thr s1 t =\n                        \\<lfloor>(((a, b), ba), bb)\\<rfloor>) \\<or>\n                    (\\<forall>l. has_locks (locks s1 $ l) t = 0)) \\<and>\n                   (\\<forall>a b ba bb.\n                       thr s1 t =\n                       \\<lfloor>(((a, b), ba),\n                                 bb)\\<rfloor> \\<longrightarrow>\n                       (\\<forall>l.\n                           has_locks (locks s1 $ l) t + bb $ l =\n                           expr_locks a l + expr_lockss (map fst ba) l));\n        ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset s1 t); may_acquire_all (locks s1) t ln;\n        0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (((a, b), ba), no_wait_locks)), shr s1),\n         wset s1, interrupts s1);\n        thr s1 t = \\<lfloor>(((a, b), ba), ln)\\<rfloor>; x = ((a, b), ba);\n        ln $ l = 0\\<rbrakk>\n       \\<Longrightarrow> has_locks (locks s1 $ l) t =\n                         expr_locks a l + expr_lockss (map fst ba) l\n 2. \\<And>a b ba l nat.\n       \\<lbrakk>\\<forall>t.\n                   ((\\<exists>a b ba bb.\n                        thr s1 t =\n                        \\<lfloor>(((a, b), ba), bb)\\<rfloor>) \\<or>\n                    (\\<forall>l. has_locks (locks s1 $ l) t = 0)) \\<and>\n                   (\\<forall>a b ba bb.\n                       thr s1 t =\n                       \\<lfloor>(((a, b), ba),\n                                 bb)\\<rfloor> \\<longrightarrow>\n                       (\\<forall>l.\n                           has_locks (locks s1 $ l) t + bb $ l =\n                           expr_locks a l + expr_lockss (map fst ba) l));\n        ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset s1 t); may_acquire_all (locks s1) t ln;\n        0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (((a, b), ba), no_wait_locks)), shr s1),\n         wset s1, interrupts s1);\n        thr s1 t = \\<lfloor>(((a, b), ba), ln)\\<rfloor>; x = ((a, b), ba);\n        ln $ l = Suc nat\\<rbrakk>\n       \\<Longrightarrow> has_locks (acquire_locks (locks s1 $ l) t (ln $ l))\n                          t =\n                         expr_locks a l + expr_lockss (map fst ba) l", "apply(erule allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b ba l.\n       \\<lbrakk>ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset s1 t); may_acquire_all (locks s1) t ln;\n        0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (((a, b), ba), no_wait_locks)), shr s1),\n         wset s1, interrupts s1);\n        thr s1 t = \\<lfloor>(((a, b), ba), ln)\\<rfloor>; x = ((a, b), ba);\n        ln $ l = 0;\n        ((\\<exists>aa bb bc bd.\n             thr s1 (?t109 a b ba l) =\n             \\<lfloor>(((aa, bb), bc), bd)\\<rfloor>) \\<or>\n         (\\<forall>la.\n             has_locks (locks s1 $ la) (?t109 a b ba l) = 0)) \\<and>\n        (\\<forall>aa bb bc bd.\n            thr s1 (?t109 a b ba l) =\n            \\<lfloor>(((aa, bb), bc), bd)\\<rfloor> \\<longrightarrow>\n            (\\<forall>la.\n                has_locks (locks s1 $ la) (?t109 a b ba l) + bd $ la =\n                expr_locks aa la + expr_lockss (map fst bc) la))\\<rbrakk>\n       \\<Longrightarrow> has_locks (locks s1 $ l) t =\n                         expr_locks a l + expr_lockss (map fst ba) l\n 2. \\<And>a b ba l nat.\n       \\<lbrakk>\\<forall>t.\n                   ((\\<exists>a b ba bb.\n                        thr s1 t =\n                        \\<lfloor>(((a, b), ba), bb)\\<rfloor>) \\<or>\n                    (\\<forall>l. has_locks (locks s1 $ l) t = 0)) \\<and>\n                   (\\<forall>a b ba bb.\n                       thr s1 t =\n                       \\<lfloor>(((a, b), ba),\n                                 bb)\\<rfloor> \\<longrightarrow>\n                       (\\<forall>l.\n                           has_locks (locks s1 $ l) t + bb $ l =\n                           expr_locks a l + expr_lockss (map fst ba) l));\n        ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset s1 t); may_acquire_all (locks s1) t ln;\n        0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (((a, b), ba), no_wait_locks)), shr s1),\n         wset s1, interrupts s1);\n        thr s1 t = \\<lfloor>(((a, b), ba), ln)\\<rfloor>; x = ((a, b), ba);\n        ln $ l = Suc nat\\<rbrakk>\n       \\<Longrightarrow> has_locks (acquire_locks (locks s1 $ l) t (ln $ l))\n                          t =\n                         expr_locks a l + expr_lockss (map fst ba) l", "apply(erule conjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b ba l.\n       \\<lbrakk>ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset s1 t); may_acquire_all (locks s1) t ln;\n        0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (((a, b), ba), no_wait_locks)), shr s1),\n         wset s1, interrupts s1);\n        thr s1 t = \\<lfloor>(((a, b), ba), ln)\\<rfloor>; x = ((a, b), ba);\n        ln $ l = 0;\n        (\\<exists>aa bb bc bd.\n            thr s1 (?t109 a b ba l) =\n            \\<lfloor>(((aa, bb), bc), bd)\\<rfloor>) \\<or>\n        (\\<forall>la. has_locks (locks s1 $ la) (?t109 a b ba l) = 0);\n        \\<forall>aa bb bc bd.\n           thr s1 (?t109 a b ba l) =\n           \\<lfloor>(((aa, bb), bc), bd)\\<rfloor> \\<longrightarrow>\n           (\\<forall>la.\n               has_locks (locks s1 $ la) (?t109 a b ba l) + bd $ la =\n               expr_locks aa la + expr_lockss (map fst bc) la)\\<rbrakk>\n       \\<Longrightarrow> has_locks (locks s1 $ l) t =\n                         expr_locks a l + expr_lockss (map fst ba) l\n 2. \\<And>a b ba l nat.\n       \\<lbrakk>\\<forall>t.\n                   ((\\<exists>a b ba bb.\n                        thr s1 t =\n                        \\<lfloor>(((a, b), ba), bb)\\<rfloor>) \\<or>\n                    (\\<forall>l. has_locks (locks s1 $ l) t = 0)) \\<and>\n                   (\\<forall>a b ba bb.\n                       thr s1 t =\n                       \\<lfloor>(((a, b), ba),\n                                 bb)\\<rfloor> \\<longrightarrow>\n                       (\\<forall>l.\n                           has_locks (locks s1 $ l) t + bb $ l =\n                           expr_locks a l + expr_lockss (map fst ba) l));\n        ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset s1 t); may_acquire_all (locks s1) t ln;\n        0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (((a, b), ba), no_wait_locks)), shr s1),\n         wset s1, interrupts s1);\n        thr s1 t = \\<lfloor>(((a, b), ba), ln)\\<rfloor>; x = ((a, b), ba);\n        ln $ l = Suc nat\\<rbrakk>\n       \\<Longrightarrow> has_locks (acquire_locks (locks s1 $ l) t (ln $ l))\n                          t =\n                         expr_locks a l + expr_lockss (map fst ba) l", "apply(erule allE)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b ba l.\n       \\<lbrakk>ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset s1 t); may_acquire_all (locks s1) t ln;\n        0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (((a, b), ba), no_wait_locks)), shr s1),\n         wset s1, interrupts s1);\n        thr s1 t = \\<lfloor>(((a, b), ba), ln)\\<rfloor>; x = ((a, b), ba);\n        ln $ l = 0;\n        (\\<exists>aa bb bc bd.\n            thr s1 (?t109 a b ba l) =\n            \\<lfloor>(((aa, bb), bc), bd)\\<rfloor>) \\<or>\n        (\\<forall>la. has_locks (locks s1 $ la) (?t109 a b ba l) = 0);\n        thr s1 (?t109 a b ba l) =\n        \\<lfloor>(((?a113 a b ba l, ?b115 a b ba l), ?b117 a b ba l),\n                  ?b119 a b ba l)\\<rfloor> \\<longrightarrow>\n        (\\<forall>la.\n            has_locks (locks s1 $ la) (?t109 a b ba l) +\n            ?b119 a b ba l $ la =\n            expr_locks (?a113 a b ba l) la +\n            expr_lockss (map fst (?b117 a b ba l)) la)\\<rbrakk>\n       \\<Longrightarrow> has_locks (locks s1 $ l) t =\n                         expr_locks a l + expr_lockss (map fst ba) l\n 2. \\<And>a b ba l nat.\n       \\<lbrakk>\\<forall>t.\n                   ((\\<exists>a b ba bb.\n                        thr s1 t =\n                        \\<lfloor>(((a, b), ba), bb)\\<rfloor>) \\<or>\n                    (\\<forall>l. has_locks (locks s1 $ l) t = 0)) \\<and>\n                   (\\<forall>a b ba bb.\n                       thr s1 t =\n                       \\<lfloor>(((a, b), ba),\n                                 bb)\\<rfloor> \\<longrightarrow>\n                       (\\<forall>l.\n                           has_locks (locks s1 $ l) t + bb $ l =\n                           expr_locks a l + expr_lockss (map fst ba) l));\n        ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset s1 t); may_acquire_all (locks s1) t ln;\n        0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (((a, b), ba), no_wait_locks)), shr s1),\n         wset s1, interrupts s1);\n        thr s1 t = \\<lfloor>(((a, b), ba), ln)\\<rfloor>; x = ((a, b), ba);\n        ln $ l = Suc nat\\<rbrakk>\n       \\<Longrightarrow> has_locks (acquire_locks (locks s1 $ l) t (ln $ l))\n                          t =\n                         expr_locks a l + expr_lockss (map fst ba) l", "apply(erule (1) impE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b ba l.\n       \\<lbrakk>ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset s1 t); may_acquire_all (locks s1) t ln;\n        0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (((a, b), ba), no_wait_locks)), shr s1),\n         wset s1, interrupts s1);\n        thr s1 t = \\<lfloor>(((a, b), ba), ln)\\<rfloor>; x = ((a, b), ba);\n        ln $ l = 0;\n        (\\<exists>a b ba bb.\n            thr s1 t = \\<lfloor>(((a, b), ba), bb)\\<rfloor>) \\<or>\n        (\\<forall>l. has_locks (locks s1 $ l) t = 0);\n        \\<forall>l.\n           has_locks (locks s1 $ l) t + ln $ l =\n           expr_locks a l + expr_lockss (map fst ba) l\\<rbrakk>\n       \\<Longrightarrow> has_locks (locks s1 $ l) t =\n                         expr_locks a l + expr_lockss (map fst ba) l\n 2. \\<And>a b ba l nat.\n       \\<lbrakk>\\<forall>t.\n                   ((\\<exists>a b ba bb.\n                        thr s1 t =\n                        \\<lfloor>(((a, b), ba), bb)\\<rfloor>) \\<or>\n                    (\\<forall>l. has_locks (locks s1 $ l) t = 0)) \\<and>\n                   (\\<forall>a b ba bb.\n                       thr s1 t =\n                       \\<lfloor>(((a, b), ba),\n                                 bb)\\<rfloor> \\<longrightarrow>\n                       (\\<forall>l.\n                           has_locks (locks s1 $ l) t + bb $ l =\n                           expr_locks a l + expr_lockss (map fst ba) l));\n        ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset s1 t); may_acquire_all (locks s1) t ln;\n        0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (((a, b), ba), no_wait_locks)), shr s1),\n         wset s1, interrupts s1);\n        thr s1 t = \\<lfloor>(((a, b), ba), ln)\\<rfloor>; x = ((a, b), ba);\n        ln $ l = Suc nat\\<rbrakk>\n       \\<Longrightarrow> has_locks (acquire_locks (locks s1 $ l) t (ln $ l))\n                          t =\n                         expr_locks a l + expr_lockss (map fst ba) l", "apply(erule_tac x=l in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b ba l.\n       \\<lbrakk>ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset s1 t); may_acquire_all (locks s1) t ln;\n        0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (((a, b), ba), no_wait_locks)), shr s1),\n         wset s1, interrupts s1);\n        thr s1 t = \\<lfloor>(((a, b), ba), ln)\\<rfloor>; x = ((a, b), ba);\n        ln $ l = 0;\n        (\\<exists>a b ba bb.\n            thr s1 t = \\<lfloor>(((a, b), ba), bb)\\<rfloor>) \\<or>\n        (\\<forall>l. has_locks (locks s1 $ l) t = 0);\n        has_locks (locks s1 $ l) t + ln $ l =\n        expr_locks a l + expr_lockss (map fst ba) l\\<rbrakk>\n       \\<Longrightarrow> has_locks (locks s1 $ l) t =\n                         expr_locks a l + expr_lockss (map fst ba) l\n 2. \\<And>a b ba l nat.\n       \\<lbrakk>\\<forall>t.\n                   ((\\<exists>a b ba bb.\n                        thr s1 t =\n                        \\<lfloor>(((a, b), ba), bb)\\<rfloor>) \\<or>\n                    (\\<forall>l. has_locks (locks s1 $ l) t = 0)) \\<and>\n                   (\\<forall>a b ba bb.\n                       thr s1 t =\n                       \\<lfloor>(((a, b), ba),\n                                 bb)\\<rfloor> \\<longrightarrow>\n                       (\\<forall>l.\n                           has_locks (locks s1 $ l) t + bb $ l =\n                           expr_locks a l + expr_lockss (map fst ba) l));\n        ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset s1 t); may_acquire_all (locks s1) t ln;\n        0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (((a, b), ba), no_wait_locks)), shr s1),\n         wset s1, interrupts s1);\n        thr s1 t = \\<lfloor>(((a, b), ba), ln)\\<rfloor>; x = ((a, b), ba);\n        ln $ l = Suc nat\\<rbrakk>\n       \\<Longrightarrow> has_locks (acquire_locks (locks s1 $ l) t (ln $ l))\n                          t =\n                         expr_locks a l + expr_lockss (map fst ba) l", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba l nat.\n       \\<lbrakk>\\<forall>t.\n                   ((\\<exists>a b ba bb.\n                        thr s1 t =\n                        \\<lfloor>(((a, b), ba), bb)\\<rfloor>) \\<or>\n                    (\\<forall>l. has_locks (locks s1 $ l) t = 0)) \\<and>\n                   (\\<forall>a b ba bb.\n                       thr s1 t =\n                       \\<lfloor>(((a, b), ba),\n                                 bb)\\<rfloor> \\<longrightarrow>\n                       (\\<forall>l.\n                           has_locks (locks s1 $ l) t + bb $ l =\n                           expr_locks a l + expr_lockss (map fst ba) l));\n        ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset s1 t); may_acquire_all (locks s1) t ln;\n        0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (((a, b), ba), no_wait_locks)), shr s1),\n         wset s1, interrupts s1);\n        thr s1 t = \\<lfloor>(((a, b), ba), ln)\\<rfloor>; x = ((a, b), ba);\n        ln $ l = Suc nat\\<rbrakk>\n       \\<Longrightarrow> has_locks (acquire_locks (locks s1 $ l) t (ln $ l))\n                          t =\n                         expr_locks a l + expr_lockss (map fst ba) l", "apply(erule may_acquire_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba l nat.\n       \\<lbrakk>\\<forall>t.\n                   ((\\<exists>a b ba bb.\n                        thr s1 t =\n                        \\<lfloor>(((a, b), ba), bb)\\<rfloor>) \\<or>\n                    (\\<forall>l. has_locks (locks s1 $ l) t = 0)) \\<and>\n                   (\\<forall>a b ba bb.\n                       thr s1 t =\n                       \\<lfloor>(((a, b), ba),\n                                 bb)\\<rfloor> \\<longrightarrow>\n                       (\\<forall>l.\n                           has_locks (locks s1 $ l) t + bb $ l =\n                           expr_locks a l + expr_lockss (map fst ba) l));\n        ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset s1 t); 0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (((a, b), ba), no_wait_locks)), shr s1),\n         wset s1, interrupts s1);\n        thr s1 t = \\<lfloor>(((a, b), ba), ln)\\<rfloor>; x = ((a, b), ba);\n        ln $ l = Suc nat;\n        \\<forall>l.\n           0 < ln $ l \\<longrightarrow> may_lock (locks s1 $ l) t\\<rbrakk>\n       \\<Longrightarrow> has_locks (acquire_locks (locks s1 $ l) t (ln $ l))\n                          t =\n                         expr_locks a l + expr_lockss (map fst ba) l", "apply(erule allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba l nat.\n       \\<lbrakk>ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset s1 t); 0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (((a, b), ba), no_wait_locks)), shr s1),\n         wset s1, interrupts s1);\n        thr s1 t = \\<lfloor>(((a, b), ba), ln)\\<rfloor>; x = ((a, b), ba);\n        ln $ l = Suc nat;\n        \\<forall>l. 0 < ln $ l \\<longrightarrow> may_lock (locks s1 $ l) t;\n        ((\\<exists>aa bb bc bd.\n             thr s1 (?t134 a b ba l nat) =\n             \\<lfloor>(((aa, bb), bc), bd)\\<rfloor>) \\<or>\n         (\\<forall>la.\n             has_locks (locks s1 $ la) (?t134 a b ba l nat) = 0)) \\<and>\n        (\\<forall>aa bb bc bd.\n            thr s1 (?t134 a b ba l nat) =\n            \\<lfloor>(((aa, bb), bc), bd)\\<rfloor> \\<longrightarrow>\n            (\\<forall>la.\n                has_locks (locks s1 $ la) (?t134 a b ba l nat) + bd $ la =\n                expr_locks aa la + expr_lockss (map fst bc) la))\\<rbrakk>\n       \\<Longrightarrow> has_locks (acquire_locks (locks s1 $ l) t (ln $ l))\n                          t =\n                         expr_locks a l + expr_lockss (map fst ba) l", "apply(erule_tac x=l in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba l nat.\n       \\<lbrakk>ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset s1 t); 0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (((a, b), ba), no_wait_locks)), shr s1),\n         wset s1, interrupts s1);\n        thr s1 t = \\<lfloor>(((a, b), ba), ln)\\<rfloor>; x = ((a, b), ba);\n        ln $ l = Suc nat;\n        ((\\<exists>aa bb bc bd.\n             thr s1 (?t134 a b ba l nat) =\n             \\<lfloor>(((aa, bb), bc), bd)\\<rfloor>) \\<or>\n         (\\<forall>la.\n             has_locks (locks s1 $ la) (?t134 a b ba l nat) = 0)) \\<and>\n        (\\<forall>aa bb bc bd.\n            thr s1 (?t134 a b ba l nat) =\n            \\<lfloor>(((aa, bb), bc), bd)\\<rfloor> \\<longrightarrow>\n            (\\<forall>la.\n                has_locks (locks s1 $ la) (?t134 a b ba l nat) + bd $ la =\n                expr_locks aa la + expr_lockss (map fst bc) la));\n        0 < ln $ l \\<longrightarrow> may_lock (locks s1 $ l) t\\<rbrakk>\n       \\<Longrightarrow> has_locks (acquire_locks (locks s1 $ l) t (ln $ l))\n                          t =\n                         expr_locks a l + expr_lockss (map fst ba) l", "apply(erule impE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b ba l nat.\n       \\<lbrakk>ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset s1 t); 0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (((a, b), ba), no_wait_locks)), shr s1),\n         wset s1, interrupts s1);\n        thr s1 t = \\<lfloor>(((a, b), ba), ln)\\<rfloor>; x = ((a, b), ba);\n        ln $ l = Suc nat;\n        ((\\<exists>aa bb bc bd.\n             thr s1 (?t134 a b ba l nat) =\n             \\<lfloor>(((aa, bb), bc), bd)\\<rfloor>) \\<or>\n         (\\<forall>la.\n             has_locks (locks s1 $ la) (?t134 a b ba l nat) = 0)) \\<and>\n        (\\<forall>aa bb bc bd.\n            thr s1 (?t134 a b ba l nat) =\n            \\<lfloor>(((aa, bb), bc), bd)\\<rfloor> \\<longrightarrow>\n            (\\<forall>la.\n                has_locks (locks s1 $ la) (?t134 a b ba l nat) + bd $ la =\n                expr_locks aa la + expr_lockss (map fst bc) la))\\<rbrakk>\n       \\<Longrightarrow> 0 < ln $ l\n 2. \\<And>a b ba l nat.\n       \\<lbrakk>ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset s1 t); 0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (((a, b), ba), no_wait_locks)), shr s1),\n         wset s1, interrupts s1);\n        thr s1 t = \\<lfloor>(((a, b), ba), ln)\\<rfloor>; x = ((a, b), ba);\n        ln $ l = Suc nat;\n        ((\\<exists>aa bb bc bd.\n             thr s1 (?t134 a b ba l nat) =\n             \\<lfloor>(((aa, bb), bc), bd)\\<rfloor>) \\<or>\n         (\\<forall>la.\n             has_locks (locks s1 $ la) (?t134 a b ba l nat) = 0)) \\<and>\n        (\\<forall>aa bb bc bd.\n            thr s1 (?t134 a b ba l nat) =\n            \\<lfloor>(((aa, bb), bc), bd)\\<rfloor> \\<longrightarrow>\n            (\\<forall>la.\n                has_locks (locks s1 $ la) (?t134 a b ba l nat) + bd $ la =\n                expr_locks aa la + expr_lockss (map fst bc) la));\n        may_lock (locks s1 $ l) t\\<rbrakk>\n       \\<Longrightarrow> has_locks (acquire_locks (locks s1 $ l) t (ln $ l))\n                          t =\n                         expr_locks a l + expr_lockss (map fst ba) l", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba l nat.\n       \\<lbrakk>ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset s1 t); 0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (((a, b), ba), no_wait_locks)), shr s1),\n         wset s1, interrupts s1);\n        thr s1 t = \\<lfloor>(((a, b), ba), ln)\\<rfloor>; x = ((a, b), ba);\n        ln $ l = Suc nat;\n        ((\\<exists>aa bb bc bd.\n             thr s1 (?t134 a b ba l nat) =\n             \\<lfloor>(((aa, bb), bc), bd)\\<rfloor>) \\<or>\n         (\\<forall>la.\n             has_locks (locks s1 $ la) (?t134 a b ba l nat) = 0)) \\<and>\n        (\\<forall>aa bb bc bd.\n            thr s1 (?t134 a b ba l nat) =\n            \\<lfloor>(((aa, bb), bc), bd)\\<rfloor> \\<longrightarrow>\n            (\\<forall>la.\n                has_locks (locks s1 $ la) (?t134 a b ba l nat) + bd $ la =\n                expr_locks aa la + expr_lockss (map fst bc) la));\n        may_lock (locks s1 $ l) t\\<rbrakk>\n       \\<Longrightarrow> has_locks (acquire_locks (locks s1 $ l) t (ln $ l))\n                          t =\n                         expr_locks a l + expr_lockss (map fst ba) l", "apply(simp only: has_locks_acquire_locks_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba l nat.\n       \\<lbrakk>ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset s1 t); 0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (((a, b), ba), no_wait_locks)), shr s1),\n         wset s1, interrupts s1);\n        thr s1 t = \\<lfloor>(((a, b), ba), ln)\\<rfloor>; x = ((a, b), ba);\n        ln $ l = Suc nat;\n        ((\\<exists>aa bb bc bd.\n             thr s1 (?t134 a b ba l nat) =\n             \\<lfloor>(((aa, bb), bc), bd)\\<rfloor>) \\<or>\n         (\\<forall>la.\n             has_locks (locks s1 $ la) (?t134 a b ba l nat) = 0)) \\<and>\n        (\\<forall>aa bb bc bd.\n            thr s1 (?t134 a b ba l nat) =\n            \\<lfloor>(((aa, bb), bc), bd)\\<rfloor> \\<longrightarrow>\n            (\\<forall>la.\n                has_locks (locks s1 $ la) (?t134 a b ba l nat) + bd $ la =\n                expr_locks aa la + expr_lockss (map fst bc) la));\n        may_lock (locks s1 $ l) t\\<rbrakk>\n       \\<Longrightarrow> has_locks (locks s1 $ l) t + Suc nat =\n                         expr_locks a l + expr_lockss (map fst ba) l", "apply(erule conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba l nat.\n       \\<lbrakk>ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset s1 t); 0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (((a, b), ba), no_wait_locks)), shr s1),\n         wset s1, interrupts s1);\n        thr s1 t = \\<lfloor>(((a, b), ba), ln)\\<rfloor>; x = ((a, b), ba);\n        ln $ l = Suc nat; may_lock (locks s1 $ l) t;\n        (\\<exists>aa bb bc bd.\n            thr s1 (?t134 a b ba l nat) =\n            \\<lfloor>(((aa, bb), bc), bd)\\<rfloor>) \\<or>\n        (\\<forall>la. has_locks (locks s1 $ la) (?t134 a b ba l nat) = 0);\n        \\<forall>aa bb bc bd.\n           thr s1 (?t134 a b ba l nat) =\n           \\<lfloor>(((aa, bb), bc), bd)\\<rfloor> \\<longrightarrow>\n           (\\<forall>la.\n               has_locks (locks s1 $ la) (?t134 a b ba l nat) + bd $ la =\n               expr_locks aa la + expr_lockss (map fst bc) la)\\<rbrakk>\n       \\<Longrightarrow> has_locks (locks s1 $ l) t + Suc nat =\n                         expr_locks a l + expr_lockss (map fst ba) l", "apply(erule allE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba l nat.\n       \\<lbrakk>ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset s1 t); 0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (((a, b), ba), no_wait_locks)), shr s1),\n         wset s1, interrupts s1);\n        thr s1 t = \\<lfloor>(((a, b), ba), ln)\\<rfloor>; x = ((a, b), ba);\n        ln $ l = Suc nat; may_lock (locks s1 $ l) t;\n        (\\<exists>aa bb bc bd.\n            thr s1 (?t134 a b ba l nat) =\n            \\<lfloor>(((aa, bb), bc), bd)\\<rfloor>) \\<or>\n        (\\<forall>la. has_locks (locks s1 $ la) (?t134 a b ba l nat) = 0);\n        thr s1 (?t134 a b ba l nat) =\n        \\<lfloor>(((?a142 a b ba l nat, ?b144 a b ba l nat),\n                   ?b146 a b ba l nat),\n                  ?b148 a b ba l nat)\\<rfloor> \\<longrightarrow>\n        (\\<forall>la.\n            has_locks (locks s1 $ la) (?t134 a b ba l nat) +\n            ?b148 a b ba l nat $ la =\n            expr_locks (?a142 a b ba l nat) la +\n            expr_lockss (map fst (?b146 a b ba l nat)) la)\\<rbrakk>\n       \\<Longrightarrow> has_locks (locks s1 $ l) t + Suc nat =\n                         expr_locks a l + expr_lockss (map fst ba) l", "apply(erule (1) impE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba l nat.\n       \\<lbrakk>ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset s1 t); 0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (((a, b), ba), no_wait_locks)), shr s1),\n         wset s1, interrupts s1);\n        thr s1 t = \\<lfloor>(((a, b), ba), ln)\\<rfloor>; x = ((a, b), ba);\n        ln $ l = Suc nat; may_lock (locks s1 $ l) t;\n        (\\<exists>a b ba bb.\n            thr s1 t = \\<lfloor>(((a, b), ba), bb)\\<rfloor>) \\<or>\n        (\\<forall>l. has_locks (locks s1 $ l) t = 0);\n        \\<forall>l.\n           has_locks (locks s1 $ l) t + ln $ l =\n           expr_locks a l + expr_lockss (map fst ba) l\\<rbrakk>\n       \\<Longrightarrow> has_locks (locks s1 $ l) t + Suc nat =\n                         expr_locks a l + expr_lockss (map fst ba) l", "apply(erule_tac x=l in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba l nat.\n       \\<lbrakk>ta1 = (t, K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset s1 t); 0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (((a, b), ba), no_wait_locks)), shr s1),\n         wset s1, interrupts s1);\n        thr s1 t = \\<lfloor>(((a, b), ba), ln)\\<rfloor>; x = ((a, b), ba);\n        ln $ l = Suc nat; may_lock (locks s1 $ l) t;\n        (\\<exists>a b ba bb.\n            thr s1 t = \\<lfloor>(((a, b), ba), bb)\\<rfloor>) \\<or>\n        (\\<forall>l. has_locks (locks s1 $ l) t = 0);\n        has_locks (locks s1 $ l) t + ln $ l =\n        expr_locks a l + expr_lockss (map fst ba) l\\<rbrakk>\n       \\<Longrightarrow> has_locks (locks s1 $ l) t + Suc nat =\n                         expr_locks a l + expr_lockss (map fst ba) l", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  lock_oks1 (locks s1') (thr s1')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Red1'_Red1_bisimulation:\n  assumes wf: \"wf_J1_prog P\"\n  shows \"bisimulation (Red1_mthr.redT False P) (Red1_mthr.redT True P) mbisim_Red1'_Red1 (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisimulation (Red1_mthr.redT False P) (Red1_mthr.redT True P)\n     mbisim_Red1'_Red1 (=)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>mbisim_Red1'_Red1 s1 s2;\n        Red1_mthr.redT False P s1 tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' tl2.\n                            Red1_mthr.redT True P s2 tl2 s2' \\<and>\n                            mbisim_Red1'_Red1 s1' s2' \\<and> tl1 = tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>mbisim_Red1'_Red1 s1 s2;\n        Red1_mthr.redT True P s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' tl1.\n                            Red1_mthr.redT False P s1 tl1 s1' \\<and>\n                            mbisim_Red1'_Red1 s1' s2' \\<and> tl1 = tl2", "fix s1 s2 tl1 s1'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>mbisim_Red1'_Red1 s1 s2;\n        Red1_mthr.redT False P s1 tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' tl2.\n                            Red1_mthr.redT True P s2 tl2 s2' \\<and>\n                            mbisim_Red1'_Red1 s1' s2' \\<and> tl1 = tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>mbisim_Red1'_Red1 s1 s2;\n        Red1_mthr.redT True P s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' tl1.\n                            Red1_mthr.redT False P s1 tl1 s1' \\<and>\n                            mbisim_Red1'_Red1 s1' s2' \\<and> tl1 = tl2", "assume \"mbisim_Red1'_Red1 s1 s2\" and \"Red1_mthr.redT False P s1 tl1 s1'\""], ["proof (state)\nthis:\n  mbisim_Red1'_Red1 s1 s2\n  Red1_mthr.redT False P s1 tl1 s1'\n\ngoal (2 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>mbisim_Red1'_Red1 s1 s2;\n        Red1_mthr.redT False P s1 tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' tl2.\n                            Red1_mthr.redT True P s2 tl2 s2' \\<and>\n                            mbisim_Red1'_Red1 s1' s2' \\<and> tl1 = tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>mbisim_Red1'_Red1 s1 s2;\n        Red1_mthr.redT True P s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' tl1.\n                            Red1_mthr.redT False P s1 tl1 s1' \\<and>\n                            mbisim_Red1'_Red1 s1' s2' \\<and> tl1 = tl2", "thus \"\\<exists>s2' tl2. Red1_mthr.redT True P s2 tl2 s2' \\<and> mbisim_Red1'_Red1 s1' s2' \\<and> tl1 = tl2\""], ["proof (prove)\nusing this:\n  mbisim_Red1'_Red1 s1 s2\n  Red1_mthr.redT False P s1 tl1 s1'\n\ngoal (1 subgoal):\n 1. \\<exists>s2' tl2.\n       Red1_mthr.redT True P s2 tl2 s2' \\<and>\n       mbisim_Red1'_Red1 s1' s2' \\<and> tl1 = tl2", "by(cases tl1)(auto simp add: mbisim_Red1'_Red1_def Red1_mthr_eq_Red1_mthr' simp del: split_paired_Ex elim: Red1'_preserves_lock_oks[OF wf] lifting_wf.redT_preserves[OF Red1_el_loc_ok, OF wf])"], ["proof (state)\nthis:\n  \\<exists>s2' tl2.\n     Red1_mthr.redT True P s2 tl2 s2' \\<and>\n     mbisim_Red1'_Red1 s1' s2' \\<and> tl1 = tl2\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>mbisim_Red1'_Red1 s1 s2;\n        Red1_mthr.redT True P s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' tl1.\n                            Red1_mthr.redT False P s1 tl1 s1' \\<and>\n                            mbisim_Red1'_Red1 s1' s2' \\<and> tl1 = tl2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>mbisim_Red1'_Red1 s1 s2;\n        Red1_mthr.redT True P s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' tl1.\n                            Red1_mthr.redT False P s1 tl1 s1' \\<and>\n                            mbisim_Red1'_Red1 s1' s2' \\<and> tl1 = tl2", "fix s1 s2 tl2 s2'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>mbisim_Red1'_Red1 s1 s2;\n        Red1_mthr.redT True P s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' tl1.\n                            Red1_mthr.redT False P s1 tl1 s1' \\<and>\n                            mbisim_Red1'_Red1 s1' s2' \\<and> tl1 = tl2", "assume \"mbisim_Red1'_Red1 s1 s2\" \"Red1_mthr.redT True P s2 tl2 s2'\""], ["proof (state)\nthis:\n  mbisim_Red1'_Red1 s1 s2\n  Red1_mthr.redT True P s2 tl2 s2'\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>mbisim_Red1'_Red1 s1 s2;\n        Red1_mthr.redT True P s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' tl1.\n                            Red1_mthr.redT False P s1 tl1 s1' \\<and>\n                            mbisim_Red1'_Red1 s1' s2' \\<and> tl1 = tl2", "thus \"\\<exists>s1' tl1. Red1_mthr.redT False P s1 tl1 s1' \\<and> mbisim_Red1'_Red1 s1' s2' \\<and> tl1 = tl2\""], ["proof (prove)\nusing this:\n  mbisim_Red1'_Red1 s1 s2\n  Red1_mthr.redT True P s2 tl2 s2'\n\ngoal (1 subgoal):\n 1. \\<exists>s1' tl1.\n       Red1_mthr.redT False P s1 tl1 s1' \\<and>\n       mbisim_Red1'_Red1 s1' s2' \\<and> tl1 = tl2", "by(cases tl2)(auto simp add: mbisim_Red1'_Red1_def Red1_mthr_eq_Red1_mthr' simp del: split_paired_Ex elim: Red1'_preserves_lock_oks[OF wf] lifting_wf.redT_preserves[OF Red1_el_loc_ok, OF wf])"], ["proof (state)\nthis:\n  \\<exists>s1' tl1.\n     Red1_mthr.redT False P s1 tl1 s1' \\<and>\n     mbisim_Red1'_Red1 s1' s2' \\<and> tl1 = tl2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Red1'_Red1_bisimulation_final:\n  \"wf_J1_prog P \n  \\<Longrightarrow> bisimulation_final (Red1_mthr.redT False P) (Red1_mthr.redT True P) \n       mbisim_Red1'_Red1 (=) Red1_mthr.mfinal Red1_mthr.mfinal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_J1_prog P \\<Longrightarrow>\n    bisimulation_final (Red1_mthr.redT False P) (Red1_mthr.redT True P)\n     mbisim_Red1'_Red1 (=) Red1_mthr.mfinal Red1_mthr.mfinal", "apply(intro_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf_J1_prog P \\<Longrightarrow>\n    bisimulation (Red1_mthr.redT False P) (Red1_mthr.redT True P)\n     mbisim_Red1'_Red1 (=)\n 2. wf_J1_prog P \\<Longrightarrow>\n    bisimulation_final_axioms mbisim_Red1'_Red1 Red1_mthr.mfinal\n     Red1_mthr.mfinal", "apply(erule Red1'_Red1_bisimulation)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_J1_prog P \\<Longrightarrow>\n    bisimulation_final_axioms mbisim_Red1'_Red1 Red1_mthr.mfinal\n     Red1_mthr.mfinal", "apply(unfold_locales)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       \\<lbrakk>wf_J1_prog P; mbisim_Red1'_Red1 s1 s2\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.mfinal s1 = Red1_mthr.mfinal s2", "apply(auto simp add: mbisim_Red1'_Red1_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bisim_J1_J1_start:\n  assumes wf: \"wf_J1_prog P\"\n  and wf_start: \"wf_start_state P C M vs\"\n  shows \"mbisim_Red1'_Red1 (J1_start_state P C M vs) (J1_start_state P C M vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mbisim_Red1'_Red1 (J1_start_state P C M vs) (J1_start_state P C M vs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mbisim_Red1'_Red1 (J1_start_state P C M vs) (J1_start_state P C M vs)", "from wf_start"], ["proof (chain)\npicking this:\n  wf_start_state P C M vs", "obtain Ts T body D \n    where sees: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>body\\<rfloor> in D\"\n    and conf: \"P,start_heap \\<turnstile> vs [:\\<le>] Ts\""], ["proof (prove)\nusing this:\n  wf_start_state P C M vs\n\ngoal (1 subgoal):\n 1. (\\<And>Ts T body D.\n        \\<lbrakk>P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n         P,start_heap \\<turnstile> vs [:\\<le>] Ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases"], ["proof (state)\nthis:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\n  P,start_heap \\<turnstile> vs [:\\<le>] Ts\n\ngoal (1 subgoal):\n 1. mbisim_Red1'_Red1 (J1_start_state P C M vs) (J1_start_state P C M vs)", "let ?e = \"blocks1 0 (Class C#Ts) body\""], ["proof (state)\ngoal (1 subgoal):\n 1. mbisim_Red1'_Red1 (J1_start_state P C M vs) (J1_start_state P C M vs)", "let ?xs = \"Null # vs @ replicate (max_vars body) undefined_value\""], ["proof (state)\ngoal (1 subgoal):\n 1. mbisim_Red1'_Red1 (J1_start_state P C M vs) (J1_start_state P C M vs)", "from sees_wf_mdecl[OF wf sees]"], ["proof (chain)\npicking this:\n  wf_mdecl wf_J1_mdecl P D (M, Ts, T, \\<lfloor>body\\<rfloor>)", "obtain T'\n    where B: \"\\<B> body (Suc (length Ts))\"\n    and wt: \"P,Class D # Ts \\<turnstile>1 body :: T'\"\n    and da: \"\\<D> body \\<lfloor>{..length Ts}\\<rfloor>\"\n    and sv: \"syncvars body\""], ["proof (prove)\nusing this:\n  wf_mdecl wf_J1_mdecl P D (M, Ts, T, \\<lfloor>body\\<rfloor>)\n\ngoal (1 subgoal):\n 1. (\\<And>T'.\n        \\<lbrakk>\\<B> body (Suc (length Ts));\n         P,Class D # Ts \\<turnstile>1 body :: T';\n         \\<D> body \\<lfloor>{..length Ts}\\<rfloor>; syncvars body\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: wf_mdecl_def)"], ["proof (state)\nthis:\n  \\<B> body (Suc (length Ts))\n  P,Class D # Ts \\<turnstile>1 body :: T'\n  \\<D> body \\<lfloor>{..length Ts}\\<rfloor>\n  syncvars body\n\ngoal (1 subgoal):\n 1. mbisim_Red1'_Red1 (J1_start_state P C M vs) (J1_start_state P C M vs)", "from wt"], ["proof (chain)\npicking this:\n  P,Class D # Ts \\<turnstile>1 body :: T'", "have \"expr_locks ?e = (\\<lambda>_. 0)\""], ["proof (prove)\nusing this:\n  P,Class D # Ts \\<turnstile>1 body :: T'\n\ngoal (1 subgoal):\n 1. expr_locks (blocks1 0 (Class C # Ts) body) = (\\<lambda>_. 0)", "by(auto intro: WT1_expr_locks)"], ["proof (state)\nthis:\n  expr_locks (blocks1 0 (Class C # Ts) body) = (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. mbisim_Red1'_Red1 (J1_start_state P C M vs) (J1_start_state P C M vs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  expr_locks (blocks1 0 (Class C # Ts) body) = (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. mbisim_Red1'_Red1 (J1_start_state P C M vs) (J1_start_state P C M vs)", "using da sees sv B"], ["proof (prove)\nusing this:\n  expr_locks (blocks1 0 (Class C # Ts) body) = (\\<lambda>_. 0)\n  \\<D> body \\<lfloor>{..length Ts}\\<rfloor>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\n  syncvars body\n  \\<B> body (Suc (length Ts))\n\ngoal (1 subgoal):\n 1. mbisim_Red1'_Red1 (J1_start_state P C M vs) (J1_start_state P C M vs)", "unfolding start_state_def"], ["proof (prove)\nusing this:\n  expr_locks (blocks1 0 (Class C # Ts) body) = (\\<lambda>_. 0)\n  \\<D> body \\<lfloor>{..length Ts}\\<rfloor>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\n  syncvars body\n  \\<B> body (Suc (length Ts))\n\ngoal (1 subgoal):\n 1. mbisim_Red1'_Red1\n     (let (D, Ts, T, m) = method P C M\n      in (K$ None,\n          ([start_tid \\<mapsto>\n            (((blocks1 0 (Class D # Ts) (the m),\n               Null # vs @ replicate (max_vars (the m)) undefined_value),\n              []),\n             no_wait_locks)],\n           start_heap),\n          Map.empty, {}))\n     (let (D, Ts, T, m) = method P C M\n      in (K$ None,\n          ([start_tid \\<mapsto>\n            (((blocks1 0 (Class D # Ts) (the m),\n               Null # vs @ replicate (max_vars (the m)) undefined_value),\n              []),\n             no_wait_locks)],\n           start_heap),\n          Map.empty, {}))", "by(fastforce simp add: mbisim_Red1'_Red1_def lock_oks1_def el_loc_ok1_def contains_insync_conv intro!: ts_okI expr_locks_sync_ok split: if_split_asm intro: el_loc_okI)"], ["proof (state)\nthis:\n  mbisim_Red1'_Red1 (J1_start_state P C M vs) (J1_start_state P C M vs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Red1'_Red1_bisim_into_weak:\n  assumes wf: \"wf_J1_prog P\"\n  shows \"bisimulation_into_delay (Red1_mthr.redT False P) (Red1_mthr.redT True P) mbisim_Red1'_Red1 (=) (Red1_mthr.m\\<tau>move P) (Red1_mthr.m\\<tau>move P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisimulation_into_delay (Red1_mthr.redT False P) (Red1_mthr.redT True P)\n     mbisim_Red1'_Red1 (=) (Red1_mthr.m\\<tau>move P)\n     (Red1_mthr.m\\<tau>move P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bisimulation_into_delay (Red1_mthr.redT False P) (Red1_mthr.redT True P)\n     mbisim_Red1'_Red1 (=) (Red1_mthr.m\\<tau>move P)\n     (Red1_mthr.m\\<tau>move P)", "interpret b: bisimulation \"Red1_mthr.redT False P\" \"Red1_mthr.redT True P\" \"mbisim_Red1'_Red1\" \"(=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisimulation (Red1_mthr.redT False P) (Red1_mthr.redT True P)\n     mbisim_Red1'_Red1 (=)", "by(rule Red1'_Red1_bisimulation[OF wf])"], ["proof (state)\ngoal (1 subgoal):\n 1. bisimulation_into_delay (Red1_mthr.redT False P) (Red1_mthr.redT True P)\n     mbisim_Red1'_Red1 (=) (Red1_mthr.m\\<tau>move P)\n     (Red1_mthr.m\\<tau>move P)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. bisimulation_into_delay (Red1_mthr.redT False P) (Red1_mthr.redT True P)\n     mbisim_Red1'_Red1 (=) (Red1_mthr.m\\<tau>move P)\n     (Red1_mthr.m\\<tau>move P)", "by(unfold_locales)(simp add: mbisim_Red1'_Red1_def)"], ["proof (state)\nthis:\n  bisimulation_into_delay (Red1_mthr.redT False P) (Red1_mthr.redT True P)\n   mbisim_Red1'_Red1 (=) (Red1_mthr.m\\<tau>move P) (Red1_mthr.m\\<tau>move P)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "sublocale J1_heap_base < Red1_mthr:\n  if_\\<tau>multithreaded_wf\n    final_expr1\n    \"mred1g uf P\"\n    convert_RA\n    \"\\<tau>MOVE1 P\"\n  for uf P"], ["proof (prove)\ngoal (1 subgoal):\n 1. if_\\<tau>multithreaded_wf final_expr1 (mred1g uf P)\n     (\\<lambda>(exexs, h) ta s.\n         \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)", "by(unfold_locales)"], ["", "context J1_heap_base begin"], ["", "abbreviation if_lock_oks1 ::\n  \"('addr,'thread_id) locks \n  \\<Rightarrow> ('addr,'thread_id,(status \\<times> (('a,'b,'addr) exp \\<times> 'c) \\<times> (('a,'b,'addr) exp \\<times> 'c) list)) thread_info\n  \\<Rightarrow> bool\" \nwhere\n  \"if_lock_oks1 ls ts \\<equiv> lock_oks1 ls (init_fin_descend_thr ts)\""], ["", "definition if_mbisim_Red1'_Red1 ::\n  \"(('addr,'thread_id,status \\<times> (('addr expr1 \\<times> 'addr locals1) \\<times> ('addr expr1 \\<times> 'addr locals1) list),'heap,'addr) state, \n    ('addr,'thread_id,status \\<times> (('addr expr1 \\<times> 'addr locals1) \\<times> ('addr expr1 \\<times> 'addr locals1) list),'heap,'addr) state) bisim\"\nwhere\n  \"if_mbisim_Red1'_Red1 s1 s2 \\<longleftrightarrow>\n  s1 = s2 \\<and> if_lock_oks1 (locks s1) (thr s1) \\<and> ts_ok (init_fin_lift (\\<lambda>t exexs h. el_loc_ok1 exexs)) (thr s1) (shr s1)\""], ["", "lemma if_mbisim_Red1'_Red1_imp_mbisim_Red1'_Red1:\n  \"if_mbisim_Red1'_Red1 s1 s2 \\<Longrightarrow> mbisim_Red1'_Red1 (init_fin_descend_state s1) (init_fin_descend_state s2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if_mbisim_Red1'_Red1 s1 s2 \\<Longrightarrow>\n    mbisim_Red1'_Red1 (init_fin_descend_state s1)\n     (init_fin_descend_state s2)", "by(auto simp add: mbisim_Red1'_Red1_def if_mbisim_Red1'_Red1_def ts_ok_init_fin_descend_state)"], ["", "lemma if_Red1_mthr_imp_if_Red1_mthr':\n  assumes lok: \"if_lock_oks1 (locks s) (thr s)\"\n  and elo: \"ts_ok (init_fin_lift (\\<lambda>t exexs h. el_loc_ok1 exexs)) (thr s) (shr s)\"\n  and Red: \"Red1_mthr.if.redT uf P s tta s'\"\n  shows \"Red1_mthr.if.redT (\\<not> uf) P s tta s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Red1_mthr.if.redT (\\<not> uf) P s tta s'", "using Red"], ["proof (prove)\nusing this:\n  Red1_mthr.if.redT uf P s tta s'\n\ngoal (1 subgoal):\n 1. Red1_mthr.if.redT (\\<not> uf) P s tta s'", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>tta = (t, ta);\n        Red1_mthr.if.r_syntax uf P t x (shr s) ta x' m';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.if.actions_ok s t ta; redT_upd s t ta x' m' s'\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.redT (\\<not> uf) P s tta s'\n 2. \\<And>t x n ln.\n       \\<lbrakk>tta =\n                (t, K$ [], [], [], [], [],\n                 (map NormalAction \\<circ> convert_RA) ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.redT (\\<not> uf) P s tta s'", "case (redT_acquire t x ln n)"], ["proof (state)\nthis:\n  tta = (t, K$ [], [], [], [], [], (map NormalAction \\<circ> convert_RA) n)\n  thr s t = \\<lfloor>(x, n)\\<rfloor>\n  \\<not> waiting (wset s t)\n  may_acquire_all (locks s) t n\n  0 < n $ ln\n  s' =\n  (acquire_all (locks s) t n,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)\n\ngoal (2 subgoals):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>tta = (t, ta);\n        Red1_mthr.if.r_syntax uf P t x (shr s) ta x' m';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.if.actions_ok s t ta; redT_upd s t ta x' m' s'\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.redT (\\<not> uf) P s tta s'\n 2. \\<And>t x n ln.\n       \\<lbrakk>tta =\n                (t, K$ [], [], [], [], [],\n                 (map NormalAction \\<circ> convert_RA) ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.redT (\\<not> uf) P s tta s'", "from this(2-)"], ["proof (chain)\npicking this:\n  thr s t = \\<lfloor>(x, n)\\<rfloor>\n  \\<not> waiting (wset s t)\n  may_acquire_all (locks s) t n\n  0 < n $ ln\n  s' =\n  (acquire_all (locks s) t n,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)", "show ?thesis"], ["proof (prove)\nusing this:\n  thr s t = \\<lfloor>(x, n)\\<rfloor>\n  \\<not> waiting (wset s t)\n  may_acquire_all (locks s) t n\n  0 < n $ ln\n  s' =\n  (acquire_all (locks s) t n,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)\n\ngoal (1 subgoal):\n 1. Red1_mthr.if.redT (\\<not> uf) P s tta s'", "unfolding redT_acquire(1)"], ["proof (prove)\nusing this:\n  thr s t = \\<lfloor>(x, n)\\<rfloor>\n  \\<not> waiting (wset s t)\n  may_acquire_all (locks s) t n\n  0 < n $ ln\n  s' =\n  (acquire_all (locks s) t n,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)\n\ngoal (1 subgoal):\n 1. Red1_mthr.if.redT_syntax1 (\\<not> uf) P s t\n     (K$ [], [], [], [], [], (map NormalAction \\<circ> convert_RA) n) s'", ".."], ["proof (state)\nthis:\n  Red1_mthr.if.redT (\\<not> uf) P s tta s'\n\ngoal (1 subgoal):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>tta = (t, ta);\n        Red1_mthr.if.r_syntax uf P t x (shr s) ta x' m';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.if.actions_ok s t ta; redT_upd s t ta x' m' s'\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.redT (\\<not> uf) P s tta s'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>tta = (t, ta);\n        Red1_mthr.if.r_syntax uf P t x (shr s) ta x' m';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.if.actions_ok s t ta; redT_upd s t ta x' m' s'\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.redT (\\<not> uf) P s tta s'", "case (redT_normal t x ta x' m')"], ["proof (state)\nthis:\n  tta = (t, ta)\n  Red1_mthr.if.r_syntax uf P t x (shr s) ta x' m'\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  Red1_mthr.if.actions_ok s t ta\n  redT_upd s t ta x' m' s'\n\ngoal (1 subgoal):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>tta = (t, ta);\n        Red1_mthr.if.r_syntax uf P t x (shr s) ta x' m';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.if.actions_ok s t ta; redT_upd s t ta x' m' s'\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.redT (\\<not> uf) P s tta s'", "note aok = \\<open>Red1_mthr.if.actions_ok s t ta\\<close>\n    and tst = \\<open>thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<close>"], ["proof (state)\nthis:\n  Red1_mthr.if.actions_ok s t ta\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>tta = (t, ta);\n        Red1_mthr.if.r_syntax uf P t x (shr s) ta x' m';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.if.actions_ok s t ta; redT_upd s t ta x' m' s'\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.redT (\\<not> uf) P s tta s'", "from \\<open>Red1_mthr.init_fin uf P t (x, shr s) ta (x', m')\\<close>"], ["proof (chain)\npicking this:\n  Red1_mthr.if.r_syntax uf P t x (shr s) ta x' m'", "have \"Red1_mthr.init_fin (\\<not> uf) P t (x, shr s) ta (x', m')\""], ["proof (prove)\nusing this:\n  Red1_mthr.if.r_syntax uf P t x (shr s) ta x' m'\n\ngoal (1 subgoal):\n 1. Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta x' m'", "proof(cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xa taa x'a.\n       \\<lbrakk>x = (Running, xa);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        x' = (Running, x'a);\n        Red1_mthr.r_syntax uf P t xa (shr s) taa x'a m'\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta\n                          x' m'\n 2. \\<And>xa.\n       \\<lbrakk>x = (PreStart, xa);\n        ta = \\<lbrace>InitialThreadAction\\<rbrace>; x' = (Running, xa);\n        m' = shr s\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta\n                          x' m'\n 3. \\<And>xa.\n       \\<lbrakk>x = (Running, xa);\n        ta = \\<lbrace>ThreadFinishAction\\<rbrace>; x' = (Finished, xa);\n        m' = shr s; final_expr1 xa\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta\n                          x' m'", "case InitialThreadAction"], ["proof (state)\nthis:\n  x = (PreStart, x_)\n  ta = \\<lbrace>InitialThreadAction\\<rbrace>\n  x' = (Running, x_)\n  m' = shr s\n\ngoal (3 subgoals):\n 1. \\<And>xa taa x'a.\n       \\<lbrakk>x = (Running, xa);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        x' = (Running, x'a);\n        Red1_mthr.r_syntax uf P t xa (shr s) taa x'a m'\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta\n                          x' m'\n 2. \\<And>xa.\n       \\<lbrakk>x = (PreStart, xa);\n        ta = \\<lbrace>InitialThreadAction\\<rbrace>; x' = (Running, xa);\n        m' = shr s\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta\n                          x' m'\n 3. \\<And>xa.\n       \\<lbrakk>x = (Running, xa);\n        ta = \\<lbrace>ThreadFinishAction\\<rbrace>; x' = (Finished, xa);\n        m' = shr s; final_expr1 xa\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta\n                          x' m'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta x' m'", "unfolding InitialThreadAction"], ["proof (prove)\ngoal (1 subgoal):\n 1. Red1_mthr.if.r_syntax (\\<not> uf) P t (PreStart, x_) (shr s)\n     \\<lbrace>InitialThreadAction\\<rbrace> (Running, x_) (shr s)", ".."], ["proof (state)\nthis:\n  Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta x' m'\n\ngoal (2 subgoals):\n 1. \\<And>xa taa x'a.\n       \\<lbrakk>x = (Running, xa);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        x' = (Running, x'a);\n        Red1_mthr.r_syntax uf P t xa (shr s) taa x'a m'\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta\n                          x' m'\n 2. \\<And>xa.\n       \\<lbrakk>x = (Running, xa);\n        ta = \\<lbrace>ThreadFinishAction\\<rbrace>; x' = (Finished, xa);\n        m' = shr s; final_expr1 xa\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta\n                          x' m'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa taa x'a.\n       \\<lbrakk>x = (Running, xa);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        x' = (Running, x'a);\n        Red1_mthr.r_syntax uf P t xa (shr s) taa x'a m'\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta\n                          x' m'\n 2. \\<And>xa.\n       \\<lbrakk>x = (Running, xa);\n        ta = \\<lbrace>ThreadFinishAction\\<rbrace>; x' = (Finished, xa);\n        m' = shr s; final_expr1 xa\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta\n                          x' m'", "case (ThreadFinishAction exexs)"], ["proof (state)\nthis:\n  x = (Running, exexs)\n  ta = \\<lbrace>ThreadFinishAction\\<rbrace>\n  x' = (Finished, exexs)\n  m' = shr s\n  final_expr1 exexs\n\ngoal (2 subgoals):\n 1. \\<And>xa taa x'a.\n       \\<lbrakk>x = (Running, xa);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        x' = (Running, x'a);\n        Red1_mthr.r_syntax uf P t xa (shr s) taa x'a m'\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta\n                          x' m'\n 2. \\<And>xa.\n       \\<lbrakk>x = (Running, xa);\n        ta = \\<lbrace>ThreadFinishAction\\<rbrace>; x' = (Finished, xa);\n        m' = shr s; final_expr1 xa\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta\n                          x' m'", "from \\<open>final_expr1 exexs\\<close>"], ["proof (chain)\npicking this:\n  final_expr1 exexs", "show ?thesis"], ["proof (prove)\nusing this:\n  final_expr1 exexs\n\ngoal (1 subgoal):\n 1. Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta x' m'", "unfolding ThreadFinishAction"], ["proof (prove)\nusing this:\n  final_expr1 exexs\n\ngoal (1 subgoal):\n 1. Red1_mthr.if.r_syntax (\\<not> uf) P t (Running, exexs) (shr s)\n     \\<lbrace>ThreadFinishAction\\<rbrace> (Finished, exexs) (shr s)", ".."], ["proof (state)\nthis:\n  Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta x' m'\n\ngoal (1 subgoal):\n 1. \\<And>xa taa x'a.\n       \\<lbrakk>x = (Running, xa);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        x' = (Running, x'a);\n        Red1_mthr.r_syntax uf P t xa (shr s) taa x'a m'\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta\n                          x' m'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa taa x'a.\n       \\<lbrakk>x = (Running, xa);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        x' = (Running, x'a);\n        Red1_mthr.r_syntax uf P t xa (shr s) taa x'a m'\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta\n                          x' m'", "case (NormalAction exexs ta' exexs')"], ["proof (state)\nthis:\n  x = (Running, exexs)\n  ta = convert_TA_initial (convert_obs_initial ta')\n  x' = (Running, exexs')\n  Red1_mthr.r_syntax uf P t exexs (shr s) ta' exexs' m'\n\ngoal (1 subgoal):\n 1. \\<And>xa taa x'a.\n       \\<lbrakk>x = (Running, xa);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        x' = (Running, x'a);\n        Red1_mthr.r_syntax uf P t xa (shr s) taa x'a m'\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta\n                          x' m'", "let ?s = \"init_fin_descend_state s\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa taa x'a.\n       \\<lbrakk>x = (Running, xa);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        x' = (Running, x'a);\n        Red1_mthr.r_syntax uf P t xa (shr s) taa x'a m'\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta\n                          x' m'", "from lok"], ["proof (chain)\npicking this:\n  if_lock_oks1 (locks s) (thr s)", "have \"lock_oks1 (locks ?s) (thr ?s)\""], ["proof (prove)\nusing this:\n  if_lock_oks1 (locks s) (thr s)\n\ngoal (1 subgoal):\n 1. lock_oks1 (locks (init_fin_descend_state s))\n     (thr (init_fin_descend_state s))", "by(simp)"], ["proof (state)\nthis:\n  lock_oks1 (locks (init_fin_descend_state s))\n   (thr (init_fin_descend_state s))\n\ngoal (1 subgoal):\n 1. \\<And>xa taa x'a.\n       \\<lbrakk>x = (Running, xa);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        x' = (Running, x'a);\n        Red1_mthr.r_syntax uf P t xa (shr s) taa x'a m'\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta\n                          x' m'", "moreover"], ["proof (state)\nthis:\n  lock_oks1 (locks (init_fin_descend_state s))\n   (thr (init_fin_descend_state s))\n\ngoal (1 subgoal):\n 1. \\<And>xa taa x'a.\n       \\<lbrakk>x = (Running, xa);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        x' = (Running, x'a);\n        Red1_mthr.r_syntax uf P t xa (shr s) taa x'a m'\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta\n                          x' m'", "from elo"], ["proof (chain)\npicking this:\n  ts_ok (init_fin_lift (\\<lambda>t exexs h. el_loc_ok1 exexs)) (thr s)\n   (shr s)", "have elo: \"ts_ok (\\<lambda>t exexs h. el_loc_ok1 exexs) (thr ?s) (shr ?s)\""], ["proof (prove)\nusing this:\n  ts_ok (init_fin_lift (\\<lambda>t exexs h. el_loc_ok1 exexs)) (thr s)\n   (shr s)\n\ngoal (1 subgoal):\n 1. ts_ok (\\<lambda>t exexs h. el_loc_ok1 exexs)\n     (thr (init_fin_descend_state s)) (shr (init_fin_descend_state s))", "by(simp add: ts_ok_init_fin_descend_state)"], ["proof (state)\nthis:\n  ts_ok (\\<lambda>t exexs h. el_loc_ok1 exexs)\n   (thr (init_fin_descend_state s)) (shr (init_fin_descend_state s))\n\ngoal (1 subgoal):\n 1. \\<And>xa taa x'a.\n       \\<lbrakk>x = (Running, xa);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        x' = (Running, x'a);\n        Red1_mthr.r_syntax uf P t xa (shr s) taa x'a m'\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta\n                          x' m'", "moreover"], ["proof (state)\nthis:\n  ts_ok (\\<lambda>t exexs h. el_loc_ok1 exexs)\n   (thr (init_fin_descend_state s)) (shr (init_fin_descend_state s))\n\ngoal (1 subgoal):\n 1. \\<And>xa taa x'a.\n       \\<lbrakk>x = (Running, xa);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        x' = (Running, x'a);\n        Red1_mthr.r_syntax uf P t xa (shr s) taa x'a m'\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta\n                          x' m'", "from tst \\<open>x = (Running, exexs)\\<close>"], ["proof (chain)\npicking this:\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  x = (Running, exexs)", "have \"thr ?s t = \\<lfloor>(exexs, no_wait_locks)\\<rfloor>\""], ["proof (prove)\nusing this:\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  x = (Running, exexs)\n\ngoal (1 subgoal):\n 1. thr (init_fin_descend_state s) t =\n    \\<lfloor>(exexs, no_wait_locks)\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  thr (init_fin_descend_state s) t =\n  \\<lfloor>(exexs, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>xa taa x'a.\n       \\<lbrakk>x = (Running, xa);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        x' = (Running, x'a);\n        Red1_mthr.r_syntax uf P t xa (shr s) taa x'a m'\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta\n                          x' m'", "moreover"], ["proof (state)\nthis:\n  thr (init_fin_descend_state s) t =\n  \\<lfloor>(exexs, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>xa taa x'a.\n       \\<lbrakk>x = (Running, xa);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        x' = (Running, x'a);\n        Red1_mthr.r_syntax uf P t xa (shr s) taa x'a m'\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta\n                          x' m'", "from aok"], ["proof (chain)\npicking this:\n  Red1_mthr.if.actions_ok s t ta", "have \"Red1_mthr.actions_ok ?s t ta'\""], ["proof (prove)\nusing this:\n  Red1_mthr.if.actions_ok s t ta\n\ngoal (1 subgoal):\n 1. Red1_mthr.actions_ok (init_fin_descend_state s) t ta'", "using \\<open>ta = convert_TA_initial (convert_obs_initial ta')\\<close>"], ["proof (prove)\nusing this:\n  Red1_mthr.if.actions_ok s t ta\n  ta = convert_TA_initial (convert_obs_initial ta')\n\ngoal (1 subgoal):\n 1. Red1_mthr.actions_ok (init_fin_descend_state s) t ta'", "by auto"], ["proof (state)\nthis:\n  Red1_mthr.actions_ok (init_fin_descend_state s) t ta'\n\ngoal (1 subgoal):\n 1. \\<And>xa taa x'a.\n       \\<lbrakk>x = (Running, xa);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        x' = (Running, x'a);\n        Red1_mthr.r_syntax uf P t xa (shr s) taa x'a m'\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta\n                          x' m'", "ultimately"], ["proof (chain)\npicking this:\n  lock_oks1 (locks (init_fin_descend_state s))\n   (thr (init_fin_descend_state s))\n  ts_ok (\\<lambda>t exexs h. el_loc_ok1 exexs)\n   (thr (init_fin_descend_state s)) (shr (init_fin_descend_state s))\n  thr (init_fin_descend_state s) t =\n  \\<lfloor>(exexs, no_wait_locks)\\<rfloor>\n  Red1_mthr.actions_ok (init_fin_descend_state s) t ta'", "have \"mred1 P t (exexs, shr ?s) ta' = mred1' P t (exexs, shr ?s) ta'\""], ["proof (prove)\nusing this:\n  lock_oks1 (locks (init_fin_descend_state s))\n   (thr (init_fin_descend_state s))\n  ts_ok (\\<lambda>t exexs h. el_loc_ok1 exexs)\n   (thr (init_fin_descend_state s)) (shr (init_fin_descend_state s))\n  thr (init_fin_descend_state s) t =\n  \\<lfloor>(exexs, no_wait_locks)\\<rfloor>\n  Red1_mthr.actions_ok (init_fin_descend_state s) t ta'\n\ngoal (1 subgoal):\n 1. mred1 P t (exexs, shr (init_fin_descend_state s)) ta' =\n    mred1' P t (exexs, shr (init_fin_descend_state s)) ta'", "by(rule mred1_eq_mred1')"], ["proof (state)\nthis:\n  mred1 P t (exexs, shr (init_fin_descend_state s)) ta' =\n  mred1' P t (exexs, shr (init_fin_descend_state s)) ta'\n\ngoal (1 subgoal):\n 1. \\<And>xa taa x'a.\n       \\<lbrakk>x = (Running, xa);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        x' = (Running, x'a);\n        Red1_mthr.r_syntax uf P t xa (shr s) taa x'a m'\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta\n                          x' m'", "with \\<open>mred1g uf P t (exexs, shr s) ta' (exexs', m')\\<close>"], ["proof (chain)\npicking this:\n  Red1_mthr.r_syntax uf P t exexs (shr s) ta' exexs' m'\n  mred1 P t (exexs, shr (init_fin_descend_state s)) ta' =\n  mred1' P t (exexs, shr (init_fin_descend_state s)) ta'", "have \"mred1g (\\<not> uf) P t (exexs, shr s) ta' (exexs', m')\""], ["proof (prove)\nusing this:\n  Red1_mthr.r_syntax uf P t exexs (shr s) ta' exexs' m'\n  mred1 P t (exexs, shr (init_fin_descend_state s)) ta' =\n  mred1' P t (exexs, shr (init_fin_descend_state s)) ta'\n\ngoal (1 subgoal):\n 1. Red1_mthr.r_syntax (\\<not> uf) P t exexs (shr s) ta' exexs' m'", "by(cases uf) simp_all"], ["proof (state)\nthis:\n  Red1_mthr.r_syntax (\\<not> uf) P t exexs (shr s) ta' exexs' m'\n\ngoal (1 subgoal):\n 1. \\<And>xa taa x'a.\n       \\<lbrakk>x = (Running, xa);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        x' = (Running, x'a);\n        Red1_mthr.r_syntax uf P t xa (shr s) taa x'a m'\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta\n                          x' m'", "thus ?thesis"], ["proof (prove)\nusing this:\n  Red1_mthr.r_syntax (\\<not> uf) P t exexs (shr s) ta' exexs' m'\n\ngoal (1 subgoal):\n 1. Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta x' m'", "unfolding NormalAction(1-3)"], ["proof (prove)\nusing this:\n  Red1_mthr.r_syntax (\\<not> uf) P t exexs (shr s) ta' exexs' m'\n\ngoal (1 subgoal):\n 1. Red1_mthr.if.r_syntax (\\<not> uf) P t (Running, exexs) (shr s)\n     (convert_TA_initial (convert_obs_initial ta')) (Running, exexs') m'", "by(rule Red1_mthr.init_fin.NormalAction)"], ["proof (state)\nthis:\n  Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta x' m'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta x' m'\n\ngoal (1 subgoal):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>tta = (t, ta);\n        Red1_mthr.if.r_syntax uf P t x (shr s) ta x' m';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.if.actions_ok s t ta; redT_upd s t ta x' m' s'\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.redT (\\<not> uf) P s tta s'", "thus ?thesis"], ["proof (prove)\nusing this:\n  Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta x' m'\n\ngoal (1 subgoal):\n 1. Red1_mthr.if.redT (\\<not> uf) P s tta s'", "using tst aok \\<open>redT_upd s t ta x' m' s'\\<close>"], ["proof (prove)\nusing this:\n  Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta x' m'\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  Red1_mthr.if.actions_ok s t ta\n  redT_upd s t ta x' m' s'\n\ngoal (1 subgoal):\n 1. Red1_mthr.if.redT (\\<not> uf) P s tta s'", "unfolding \\<open>tta = (t, ta)\\<close>"], ["proof (prove)\nusing this:\n  Red1_mthr.if.r_syntax (\\<not> uf) P t x (shr s) ta x' m'\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  Red1_mthr.if.actions_ok s t ta\n  redT_upd s t ta x' m' s'\n\ngoal (1 subgoal):\n 1. Red1_mthr.if.redT_syntax1 (\\<not> uf) P s t ta s'", ".."], ["proof (state)\nthis:\n  Red1_mthr.if.redT (\\<not> uf) P s tta s'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma if_Red1_mthr_eq_if_Red1_mthr':\n  assumes lok: \"if_lock_oks1 (locks s) (thr s)\"\n  and elo: \"ts_ok (init_fin_lift (\\<lambda>t exexs h. el_loc_ok1 exexs)) (thr s) (shr s)\"\n  shows \"Red1_mthr.if.redT True P s = Red1_mthr.if.redT False P s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Red1_mthr.if.redT True P s = Red1_mthr.if.redT False P s", "using if_Red1_mthr_imp_if_Red1_mthr'[OF assms, of True P, simplified]\n  if_Red1_mthr_imp_if_Red1_mthr'[OF assms, of False P, simplified]"], ["proof (prove)\nusing this:\n  Red1_mthr.if.redT True P s ?tta ?s' \\<Longrightarrow>\n  Red1_mthr.if.redT False P s ?tta ?s'\n  Red1_mthr.if.redT False P s ?tta ?s' \\<Longrightarrow>\n  Red1_mthr.if.redT True P s ?tta ?s'\n\ngoal (1 subgoal):\n 1. Red1_mthr.if.redT True P s = Red1_mthr.if.redT False P s", "by(blast del: equalityI)"], ["", "lemma if_Red1_el_loc_ok: \n  assumes wf: \"wf_J1_prog P\"\n  shows \"lifting_wf Red1_mthr.init_fin_final (Red1_mthr.init_fin uf P) (init_fin_lift (\\<lambda>t exexs h. el_loc_ok1 exexs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lifting_wf Red1_mthr.init_fin_final (Red1_mthr.init_fin uf P)\n     (init_fin_lift (\\<lambda>t exexs h. el_loc_ok1 exexs))", "by(rule lifting_wf.lifting_wf_init_fin_lift)(rule Red1_el_loc_ok[OF wf])"], ["", "lemma if_Red1'_preserves_if_lock_oks:\n  assumes wf: \"wf_J1_prog P\"\n  and Red: \"Red1_mthr.if.redT False P s1 ta1 s1'\"\n  and loks: \"if_lock_oks1 (locks s1) (thr s1)\"\n  and sync: \"ts_ok (init_fin_lift (\\<lambda>t exexs h. el_loc_ok1 exexs)) (thr s1) (shr s1)\"\n  shows \"if_lock_oks1 (locks s1') (thr s1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if_lock_oks1 (locks s1') (thr s1')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. if_lock_oks1 (locks s1') (thr s1')", "let ?s1 = \"init_fin_descend_state s1\""], ["proof (state)\ngoal (1 subgoal):\n 1. if_lock_oks1 (locks s1') (thr s1')", "let ?s1' = \"init_fin_descend_state s1'\""], ["proof (state)\ngoal (1 subgoal):\n 1. if_lock_oks1 (locks s1') (thr s1')", "from loks"], ["proof (chain)\npicking this:\n  if_lock_oks1 (locks s1) (thr s1)", "have loks': \"lock_oks1 (locks ?s1) (thr ?s1)\""], ["proof (prove)\nusing this:\n  if_lock_oks1 (locks s1) (thr s1)\n\ngoal (1 subgoal):\n 1. lock_oks1 (locks (init_fin_descend_state s1))\n     (thr (init_fin_descend_state s1))", "by simp"], ["proof (state)\nthis:\n  lock_oks1 (locks (init_fin_descend_state s1))\n   (thr (init_fin_descend_state s1))\n\ngoal (1 subgoal):\n 1. if_lock_oks1 (locks s1') (thr s1')", "from sync"], ["proof (chain)\npicking this:\n  ts_ok (init_fin_lift (\\<lambda>t exexs h. el_loc_ok1 exexs)) (thr s1)\n   (shr s1)", "have sync': \"ts_ok (\\<lambda>t exexs h. el_loc_ok1 exexs) (thr ?s1) (shr ?s1)\""], ["proof (prove)\nusing this:\n  ts_ok (init_fin_lift (\\<lambda>t exexs h. el_loc_ok1 exexs)) (thr s1)\n   (shr s1)\n\ngoal (1 subgoal):\n 1. ts_ok (\\<lambda>t exexs h. el_loc_ok1 exexs)\n     (thr (init_fin_descend_state s1)) (shr (init_fin_descend_state s1))", "by(simp add: ts_ok_init_fin_descend_state)"], ["proof (state)\nthis:\n  ts_ok (\\<lambda>t exexs h. el_loc_ok1 exexs)\n   (thr (init_fin_descend_state s1)) (shr (init_fin_descend_state s1))\n\ngoal (1 subgoal):\n 1. if_lock_oks1 (locks s1') (thr s1')", "from Red"], ["proof (chain)\npicking this:\n  Red1_mthr.if.redT False P s1 ta1 s1'", "show ?thesis"], ["proof (prove)\nusing this:\n  Red1_mthr.if.redT False P s1 ta1 s1'\n\ngoal (1 subgoal):\n 1. if_lock_oks1 (locks s1') (thr s1')", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>ta1 = (t, ta);\n        Red1_mthr.if.r_syntax False P t x (shr s1) ta x' m';\n        thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.if.actions_ok s1 t ta; redT_upd s1 t ta x' m' s1'\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')\n 2. \\<And>t x n ln.\n       \\<lbrakk>ta1 =\n                (t, K$ [], [], [], [], [],\n                 (map NormalAction \\<circ> convert_RA) ln);\n        thr s1 t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s1 t);\n        may_acquire_all (locks s1) t ln; 0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (x, no_wait_locks)), shr s1), wset s1,\n         interrupts s1)\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')", "case (redT_acquire t x n ln)"], ["proof (state)\nthis:\n  ta1 = (t, K$ [], [], [], [], [], (map NormalAction \\<circ> convert_RA) ln)\n  thr s1 t = \\<lfloor>(x, ln)\\<rfloor>\n  \\<not> waiting (wset s1 t)\n  may_acquire_all (locks s1) t ln\n  0 < ln $ n\n  s1' =\n  (acquire_all (locks s1) t ln,\n   (thr s1(t \\<mapsto> (x, no_wait_locks)), shr s1), wset s1, interrupts s1)\n\ngoal (2 subgoals):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>ta1 = (t, ta);\n        Red1_mthr.if.r_syntax False P t x (shr s1) ta x' m';\n        thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.if.actions_ok s1 t ta; redT_upd s1 t ta x' m' s1'\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')\n 2. \\<And>t x n ln.\n       \\<lbrakk>ta1 =\n                (t, K$ [], [], [], [], [],\n                 (map NormalAction \\<circ> convert_RA) ln);\n        thr s1 t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s1 t);\n        may_acquire_all (locks s1) t ln; 0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (x, no_wait_locks)), shr s1), wset s1,\n         interrupts s1)\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')", "hence \"Red1_mthr.redT False P ?s1 (t, K$ [], [], [], [], [], convert_RA ln) ?s1'\""], ["proof (prove)\nusing this:\n  ta1 = (t, K$ [], [], [], [], [], (map NormalAction \\<circ> convert_RA) ln)\n  thr s1 t = \\<lfloor>(x, ln)\\<rfloor>\n  \\<not> waiting (wset s1 t)\n  may_acquire_all (locks s1) t ln\n  0 < ln $ n\n  s1' =\n  (acquire_all (locks s1) t ln,\n   (thr s1(t \\<mapsto> (x, no_wait_locks)), shr s1), wset s1, interrupts s1)\n\ngoal (1 subgoal):\n 1. Red1_mthr.redT_syntax1 False P (init_fin_descend_state s1) t\n     (K$ [], [], [], [], [], convert_RA ln) (init_fin_descend_state s1')", "by(cases x)(auto intro!: Red1_mthr.redT.redT_acquire simp add: init_fin_descend_thr_def)"], ["proof (state)\nthis:\n  Red1_mthr.redT_syntax1 False P (init_fin_descend_state s1) t\n   (K$ [], [], [], [], [], convert_RA ln) (init_fin_descend_state s1')\n\ngoal (2 subgoals):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>ta1 = (t, ta);\n        Red1_mthr.if.r_syntax False P t x (shr s1) ta x' m';\n        thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.if.actions_ok s1 t ta; redT_upd s1 t ta x' m' s1'\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')\n 2. \\<And>t x n ln.\n       \\<lbrakk>ta1 =\n                (t, K$ [], [], [], [], [],\n                 (map NormalAction \\<circ> convert_RA) ln);\n        thr s1 t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s1 t);\n        may_acquire_all (locks s1) t ln; 0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (x, no_wait_locks)), shr s1), wset s1,\n         interrupts s1)\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')", "with wf"], ["proof (chain)\npicking this:\n  wf_J1_prog P\n  Red1_mthr.redT_syntax1 False P (init_fin_descend_state s1) t\n   (K$ [], [], [], [], [], convert_RA ln) (init_fin_descend_state s1')", "have \"lock_oks1 (locks ?s1') (thr ?s1')\""], ["proof (prove)\nusing this:\n  wf_J1_prog P\n  Red1_mthr.redT_syntax1 False P (init_fin_descend_state s1) t\n   (K$ [], [], [], [], [], convert_RA ln) (init_fin_descend_state s1')\n\ngoal (1 subgoal):\n 1. lock_oks1 (locks (init_fin_descend_state s1'))\n     (thr (init_fin_descend_state s1'))", "using loks' sync'"], ["proof (prove)\nusing this:\n  wf_J1_prog P\n  Red1_mthr.redT_syntax1 False P (init_fin_descend_state s1) t\n   (K$ [], [], [], [], [], convert_RA ln) (init_fin_descend_state s1')\n  lock_oks1 (locks (init_fin_descend_state s1))\n   (thr (init_fin_descend_state s1))\n  ts_ok (\\<lambda>t exexs h. el_loc_ok1 exexs)\n   (thr (init_fin_descend_state s1)) (shr (init_fin_descend_state s1))\n\ngoal (1 subgoal):\n 1. lock_oks1 (locks (init_fin_descend_state s1'))\n     (thr (init_fin_descend_state s1'))", "by(rule Red1'_preserves_lock_oks)"], ["proof (state)\nthis:\n  lock_oks1 (locks (init_fin_descend_state s1'))\n   (thr (init_fin_descend_state s1'))\n\ngoal (2 subgoals):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>ta1 = (t, ta);\n        Red1_mthr.if.r_syntax False P t x (shr s1) ta x' m';\n        thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.if.actions_ok s1 t ta; redT_upd s1 t ta x' m' s1'\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')\n 2. \\<And>t x n ln.\n       \\<lbrakk>ta1 =\n                (t, K$ [], [], [], [], [],\n                 (map NormalAction \\<circ> convert_RA) ln);\n        thr s1 t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s1 t);\n        may_acquire_all (locks s1) t ln; 0 < ln $ n;\n        s1' =\n        (acquire_all (locks s1) t ln,\n         (thr s1(t \\<mapsto> (x, no_wait_locks)), shr s1), wset s1,\n         interrupts s1)\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')", "thus ?thesis"], ["proof (prove)\nusing this:\n  lock_oks1 (locks (init_fin_descend_state s1'))\n   (thr (init_fin_descend_state s1'))\n\ngoal (1 subgoal):\n 1. if_lock_oks1 (locks s1') (thr s1')", "by simp"], ["proof (state)\nthis:\n  if_lock_oks1 (locks s1') (thr s1')\n\ngoal (1 subgoal):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>ta1 = (t, ta);\n        Red1_mthr.if.r_syntax False P t x (shr s1) ta x' m';\n        thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.if.actions_ok s1 t ta; redT_upd s1 t ta x' m' s1'\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>ta1 = (t, ta);\n        Red1_mthr.if.r_syntax False P t x (shr s1) ta x' m';\n        thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.if.actions_ok s1 t ta; redT_upd s1 t ta x' m' s1'\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')", "case (redT_normal t sx ta sx' m')"], ["proof (state)\nthis:\n  ta1 = (t, ta)\n  Red1_mthr.if.r_syntax False P t sx (shr s1) ta sx' m'\n  thr s1 t = \\<lfloor>(sx, no_wait_locks)\\<rfloor>\n  Red1_mthr.if.actions_ok s1 t ta\n  redT_upd s1 t ta sx' m' s1'\n\ngoal (1 subgoal):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>ta1 = (t, ta);\n        Red1_mthr.if.r_syntax False P t x (shr s1) ta x' m';\n        thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.if.actions_ok s1 t ta; redT_upd s1 t ta x' m' s1'\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')", "note tst = \\<open>thr s1 t = \\<lfloor>(sx, no_wait_locks)\\<rfloor>\\<close>"], ["proof (state)\nthis:\n  thr s1 t = \\<lfloor>(sx, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>t x ta x' m'.\n       \\<lbrakk>ta1 = (t, ta);\n        Red1_mthr.if.r_syntax False P t x (shr s1) ta x' m';\n        thr s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        Red1_mthr.if.actions_ok s1 t ta; redT_upd s1 t ta x' m' s1'\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')", "from \\<open>Red1_mthr.init_fin False P t (sx, shr s1) ta (sx', m')\\<close>"], ["proof (chain)\npicking this:\n  Red1_mthr.if.r_syntax False P t sx (shr s1) ta sx' m'", "show ?thesis"], ["proof (prove)\nusing this:\n  Red1_mthr.if.r_syntax False P t sx (shr s1) ta sx' m'\n\ngoal (1 subgoal):\n 1. if_lock_oks1 (locks s1') (thr s1')", "proof(cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x taa x'.\n       \\<lbrakk>sx = (Running, x);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        sx' = (Running, x');\n        Red1_mthr.r_syntax False P t x (shr s1) taa x' m'\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')\n 2. \\<And>x.\n       \\<lbrakk>sx = (PreStart, x);\n        ta = \\<lbrace>InitialThreadAction\\<rbrace>; sx' = (Running, x);\n        m' = shr s1\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')\n 3. \\<And>x.\n       \\<lbrakk>sx = (Running, x);\n        ta = \\<lbrace>ThreadFinishAction\\<rbrace>; sx' = (Finished, x);\n        m' = shr s1; final_expr1 x\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')", "case (InitialThreadAction x)"], ["proof (state)\nthis:\n  sx = (PreStart, x)\n  ta = \\<lbrace>InitialThreadAction\\<rbrace>\n  sx' = (Running, x)\n  m' = shr s1\n\ngoal (3 subgoals):\n 1. \\<And>x taa x'.\n       \\<lbrakk>sx = (Running, x);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        sx' = (Running, x');\n        Red1_mthr.r_syntax False P t x (shr s1) taa x' m'\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')\n 2. \\<And>x.\n       \\<lbrakk>sx = (PreStart, x);\n        ta = \\<lbrace>InitialThreadAction\\<rbrace>; sx' = (Running, x);\n        m' = shr s1\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')\n 3. \\<And>x.\n       \\<lbrakk>sx = (Running, x);\n        ta = \\<lbrace>ThreadFinishAction\\<rbrace>; sx' = (Finished, x);\n        m' = shr s1; final_expr1 x\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')", "thus ?thesis"], ["proof (prove)\nusing this:\n  sx = (PreStart, x)\n  ta = \\<lbrace>InitialThreadAction\\<rbrace>\n  sx' = (Running, x)\n  m' = shr s1\n\ngoal (1 subgoal):\n 1. if_lock_oks1 (locks s1') (thr s1')", "using redT_normal loks"], ["proof (prove)\nusing this:\n  sx = (PreStart, x)\n  ta = \\<lbrace>InitialThreadAction\\<rbrace>\n  sx' = (Running, x)\n  m' = shr s1\n  ta1 = (t, ta)\n  Red1_mthr.if.r_syntax False P t sx (shr s1) ta sx' m'\n  thr s1 t = \\<lfloor>(sx, no_wait_locks)\\<rfloor>\n  Red1_mthr.if.actions_ok s1 t ta\n  redT_upd s1 t ta sx' m' s1'\n  if_lock_oks1 (locks s1) (thr s1)\n\ngoal (1 subgoal):\n 1. if_lock_oks1 (locks s1') (thr s1')", "by(cases x)(auto 4 3 simp add: init_fin_descend_thr_def redT_updLns_def expand_finfun_eq fun_eq_iff intro: lock_oks1_thr_updI)"], ["proof (state)\nthis:\n  if_lock_oks1 (locks s1') (thr s1')\n\ngoal (2 subgoals):\n 1. \\<And>x taa x'.\n       \\<lbrakk>sx = (Running, x);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        sx' = (Running, x');\n        Red1_mthr.r_syntax False P t x (shr s1) taa x' m'\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')\n 2. \\<And>x.\n       \\<lbrakk>sx = (Running, x);\n        ta = \\<lbrace>ThreadFinishAction\\<rbrace>; sx' = (Finished, x);\n        m' = shr s1; final_expr1 x\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x taa x'.\n       \\<lbrakk>sx = (Running, x);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        sx' = (Running, x');\n        Red1_mthr.r_syntax False P t x (shr s1) taa x' m'\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')\n 2. \\<And>x.\n       \\<lbrakk>sx = (Running, x);\n        ta = \\<lbrace>ThreadFinishAction\\<rbrace>; sx' = (Finished, x);\n        m' = shr s1; final_expr1 x\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')", "case (ThreadFinishAction x)"], ["proof (state)\nthis:\n  sx = (Running, x)\n  ta = \\<lbrace>ThreadFinishAction\\<rbrace>\n  sx' = (Finished, x)\n  m' = shr s1\n  final_expr1 x\n\ngoal (2 subgoals):\n 1. \\<And>x taa x'.\n       \\<lbrakk>sx = (Running, x);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        sx' = (Running, x');\n        Red1_mthr.r_syntax False P t x (shr s1) taa x' m'\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')\n 2. \\<And>x.\n       \\<lbrakk>sx = (Running, x);\n        ta = \\<lbrace>ThreadFinishAction\\<rbrace>; sx' = (Finished, x);\n        m' = shr s1; final_expr1 x\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')", "thus ?thesis"], ["proof (prove)\nusing this:\n  sx = (Running, x)\n  ta = \\<lbrace>ThreadFinishAction\\<rbrace>\n  sx' = (Finished, x)\n  m' = shr s1\n  final_expr1 x\n\ngoal (1 subgoal):\n 1. if_lock_oks1 (locks s1') (thr s1')", "using redT_normal loks"], ["proof (prove)\nusing this:\n  sx = (Running, x)\n  ta = \\<lbrace>ThreadFinishAction\\<rbrace>\n  sx' = (Finished, x)\n  m' = shr s1\n  final_expr1 x\n  ta1 = (t, ta)\n  Red1_mthr.if.r_syntax False P t sx (shr s1) ta sx' m'\n  thr s1 t = \\<lfloor>(sx, no_wait_locks)\\<rfloor>\n  Red1_mthr.if.actions_ok s1 t ta\n  redT_upd s1 t ta sx' m' s1'\n  if_lock_oks1 (locks s1) (thr s1)\n\ngoal (1 subgoal):\n 1. if_lock_oks1 (locks s1') (thr s1')", "by(cases x)(auto 4 3 simp add: init_fin_descend_thr_def redT_updLns_def expand_finfun_eq fun_eq_iff intro: lock_oks1_thr_updI)"], ["proof (state)\nthis:\n  if_lock_oks1 (locks s1') (thr s1')\n\ngoal (1 subgoal):\n 1. \\<And>x taa x'.\n       \\<lbrakk>sx = (Running, x);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        sx' = (Running, x');\n        Red1_mthr.r_syntax False P t x (shr s1) taa x' m'\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x taa x'.\n       \\<lbrakk>sx = (Running, x);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        sx' = (Running, x');\n        Red1_mthr.r_syntax False P t x (shr s1) taa x' m'\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')", "case (NormalAction x ta' x')"], ["proof (state)\nthis:\n  sx = (Running, x)\n  ta = convert_TA_initial (convert_obs_initial ta')\n  sx' = (Running, x')\n  Red1_mthr.r_syntax False P t x (shr s1) ta' x' m'\n\ngoal (1 subgoal):\n 1. \\<And>x taa x'.\n       \\<lbrakk>sx = (Running, x);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        sx' = (Running, x');\n        Red1_mthr.r_syntax False P t x (shr s1) taa x' m'\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')", "note ta = \\<open>ta = convert_TA_initial (convert_obs_initial ta')\\<close>"], ["proof (state)\nthis:\n  ta = convert_TA_initial (convert_obs_initial ta')\n\ngoal (1 subgoal):\n 1. \\<And>x taa x'.\n       \\<lbrakk>sx = (Running, x);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        sx' = (Running, x');\n        Red1_mthr.r_syntax False P t x (shr s1) taa x' m'\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')", "from \\<open>mred1' P t (x, shr s1) ta' (x', m')\\<close>"], ["proof (chain)\npicking this:\n  Red1_mthr.r_syntax False P t x (shr s1) ta' x' m'", "have \"mred1' P t (x, shr ?s1) ta' (x', m')\""], ["proof (prove)\nusing this:\n  Red1_mthr.r_syntax False P t x (shr s1) ta' x' m'\n\ngoal (1 subgoal):\n 1. Red1_mthr.r_syntax False P t x (shr (init_fin_descend_state s1)) ta' x'\n     m'", "by simp"], ["proof (state)\nthis:\n  Red1_mthr.r_syntax False P t x (shr (init_fin_descend_state s1)) ta' x' m'\n\ngoal (1 subgoal):\n 1. \\<And>x taa x'.\n       \\<lbrakk>sx = (Running, x);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        sx' = (Running, x');\n        Red1_mthr.r_syntax False P t x (shr s1) taa x' m'\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')", "moreover"], ["proof (state)\nthis:\n  Red1_mthr.r_syntax False P t x (shr (init_fin_descend_state s1)) ta' x' m'\n\ngoal (1 subgoal):\n 1. \\<And>x taa x'.\n       \\<lbrakk>sx = (Running, x);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        sx' = (Running, x');\n        Red1_mthr.r_syntax False P t x (shr s1) taa x' m'\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')", "have tst': \"thr ?s1 t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thr (init_fin_descend_state s1) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>", "using tst \\<open>sx = (Running, x)\\<close>"], ["proof (prove)\nusing this:\n  thr s1 t = \\<lfloor>(sx, no_wait_locks)\\<rfloor>\n  sx = (Running, x)\n\ngoal (1 subgoal):\n 1. thr (init_fin_descend_state s1) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  thr (init_fin_descend_state s1) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x taa x'.\n       \\<lbrakk>sx = (Running, x);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        sx' = (Running, x');\n        Red1_mthr.r_syntax False P t x (shr s1) taa x' m'\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')", "moreover"], ["proof (state)\nthis:\n  thr (init_fin_descend_state s1) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x taa x'.\n       \\<lbrakk>sx = (Running, x);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        sx' = (Running, x');\n        Red1_mthr.r_syntax False P t x (shr s1) taa x' m'\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')", "have \"Red1_mthr.actions_ok ?s1 t ta'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Red1_mthr.actions_ok (init_fin_descend_state s1) t ta'", "using ta \\<open>Red1_mthr.if.actions_ok s1 t ta\\<close>"], ["proof (prove)\nusing this:\n  ta = convert_TA_initial (convert_obs_initial ta')\n  Red1_mthr.if.actions_ok s1 t ta\n\ngoal (1 subgoal):\n 1. Red1_mthr.actions_ok (init_fin_descend_state s1) t ta'", "by simp"], ["proof (state)\nthis:\n  Red1_mthr.actions_ok (init_fin_descend_state s1) t ta'\n\ngoal (1 subgoal):\n 1. \\<And>x taa x'.\n       \\<lbrakk>sx = (Running, x);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        sx' = (Running, x');\n        Red1_mthr.r_syntax False P t x (shr s1) taa x' m'\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')", "moreover"], ["proof (state)\nthis:\n  Red1_mthr.actions_ok (init_fin_descend_state s1) t ta'\n\ngoal (1 subgoal):\n 1. \\<And>x taa x'.\n       \\<lbrakk>sx = (Running, x);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        sx' = (Running, x');\n        Red1_mthr.r_syntax False P t x (shr s1) taa x' m'\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')", "from \\<open>redT_upd s1 t ta sx' m' s1'\\<close> tst tst' ta \\<open>sx' = (Running, x')\\<close>"], ["proof (chain)\npicking this:\n  redT_upd s1 t ta sx' m' s1'\n  thr s1 t = \\<lfloor>(sx, no_wait_locks)\\<rfloor>\n  thr (init_fin_descend_state s1) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  ta = convert_TA_initial (convert_obs_initial ta')\n  sx' = (Running, x')", "have \"redT_upd ?s1 t ta' x' m' ?s1'\""], ["proof (prove)\nusing this:\n  redT_upd s1 t ta sx' m' s1'\n  thr s1 t = \\<lfloor>(sx, no_wait_locks)\\<rfloor>\n  thr (init_fin_descend_state s1) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  ta = convert_TA_initial (convert_obs_initial ta')\n  sx' = (Running, x')\n\ngoal (1 subgoal):\n 1. redT_upd (init_fin_descend_state s1) t ta' x' m'\n     (init_fin_descend_state s1')", "by auto"], ["proof (state)\nthis:\n  redT_upd (init_fin_descend_state s1) t ta' x' m'\n   (init_fin_descend_state s1')\n\ngoal (1 subgoal):\n 1. \\<And>x taa x'.\n       \\<lbrakk>sx = (Running, x);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        sx' = (Running, x');\n        Red1_mthr.r_syntax False P t x (shr s1) taa x' m'\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')", "ultimately"], ["proof (chain)\npicking this:\n  Red1_mthr.r_syntax False P t x (shr (init_fin_descend_state s1)) ta' x' m'\n  thr (init_fin_descend_state s1) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  Red1_mthr.actions_ok (init_fin_descend_state s1) t ta'\n  redT_upd (init_fin_descend_state s1) t ta' x' m'\n   (init_fin_descend_state s1')", "have \"Red1_mthr.redT False P ?s1 (t, ta') ?s1'\""], ["proof (prove)\nusing this:\n  Red1_mthr.r_syntax False P t x (shr (init_fin_descend_state s1)) ta' x' m'\n  thr (init_fin_descend_state s1) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  Red1_mthr.actions_ok (init_fin_descend_state s1) t ta'\n  redT_upd (init_fin_descend_state s1) t ta' x' m'\n   (init_fin_descend_state s1')\n\ngoal (1 subgoal):\n 1. Red1_mthr.redT_syntax1 False P (init_fin_descend_state s1) t ta'\n     (init_fin_descend_state s1')", ".."], ["proof (state)\nthis:\n  Red1_mthr.redT_syntax1 False P (init_fin_descend_state s1) t ta'\n   (init_fin_descend_state s1')\n\ngoal (1 subgoal):\n 1. \\<And>x taa x'.\n       \\<lbrakk>sx = (Running, x);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        sx' = (Running, x');\n        Red1_mthr.r_syntax False P t x (shr s1) taa x' m'\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')", "with wf"], ["proof (chain)\npicking this:\n  wf_J1_prog P\n  Red1_mthr.redT_syntax1 False P (init_fin_descend_state s1) t ta'\n   (init_fin_descend_state s1')", "have \"lock_oks1 (locks ?s1') (thr ?s1')\""], ["proof (prove)\nusing this:\n  wf_J1_prog P\n  Red1_mthr.redT_syntax1 False P (init_fin_descend_state s1) t ta'\n   (init_fin_descend_state s1')\n\ngoal (1 subgoal):\n 1. lock_oks1 (locks (init_fin_descend_state s1'))\n     (thr (init_fin_descend_state s1'))", "using loks' sync'"], ["proof (prove)\nusing this:\n  wf_J1_prog P\n  Red1_mthr.redT_syntax1 False P (init_fin_descend_state s1) t ta'\n   (init_fin_descend_state s1')\n  lock_oks1 (locks (init_fin_descend_state s1))\n   (thr (init_fin_descend_state s1))\n  ts_ok (\\<lambda>t exexs h. el_loc_ok1 exexs)\n   (thr (init_fin_descend_state s1)) (shr (init_fin_descend_state s1))\n\ngoal (1 subgoal):\n 1. lock_oks1 (locks (init_fin_descend_state s1'))\n     (thr (init_fin_descend_state s1'))", "by(rule Red1'_preserves_lock_oks)"], ["proof (state)\nthis:\n  lock_oks1 (locks (init_fin_descend_state s1'))\n   (thr (init_fin_descend_state s1'))\n\ngoal (1 subgoal):\n 1. \\<And>x taa x'.\n       \\<lbrakk>sx = (Running, x);\n        ta = convert_TA_initial (convert_obs_initial taa);\n        sx' = (Running, x');\n        Red1_mthr.r_syntax False P t x (shr s1) taa x' m'\\<rbrakk>\n       \\<Longrightarrow> if_lock_oks1 (locks s1') (thr s1')", "thus ?thesis"], ["proof (prove)\nusing this:\n  lock_oks1 (locks (init_fin_descend_state s1'))\n   (thr (init_fin_descend_state s1'))\n\ngoal (1 subgoal):\n 1. if_lock_oks1 (locks s1') (thr s1')", "by simp"], ["proof (state)\nthis:\n  if_lock_oks1 (locks s1') (thr s1')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  if_lock_oks1 (locks s1') (thr s1')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  if_lock_oks1 (locks s1') (thr s1')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Red1'_Red1_if_bisimulation:\n  assumes wf: \"wf_J1_prog P\"\n  shows \"bisimulation (Red1_mthr.if.redT False P) (Red1_mthr.if.redT True P) if_mbisim_Red1'_Red1 (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisimulation (Red1_mthr.if.redT False P) (Red1_mthr.if.redT True P)\n     if_mbisim_Red1'_Red1 (=)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>if_mbisim_Red1'_Red1 s1 s2;\n        Red1_mthr.if.redT False P s1 tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' tl2.\n                            Red1_mthr.if.redT True P s2 tl2 s2' \\<and>\n                            if_mbisim_Red1'_Red1 s1' s2' \\<and> tl1 = tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>if_mbisim_Red1'_Red1 s1 s2;\n        Red1_mthr.if.redT True P s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' tl1.\n                            Red1_mthr.if.redT False P s1 tl1 s1' \\<and>\n                            if_mbisim_Red1'_Red1 s1' s2' \\<and> tl1 = tl2", "fix s1 s2 tl1 s1'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>if_mbisim_Red1'_Red1 s1 s2;\n        Red1_mthr.if.redT False P s1 tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' tl2.\n                            Red1_mthr.if.redT True P s2 tl2 s2' \\<and>\n                            if_mbisim_Red1'_Red1 s1' s2' \\<and> tl1 = tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>if_mbisim_Red1'_Red1 s1 s2;\n        Red1_mthr.if.redT True P s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' tl1.\n                            Red1_mthr.if.redT False P s1 tl1 s1' \\<and>\n                            if_mbisim_Red1'_Red1 s1' s2' \\<and> tl1 = tl2", "assume \"if_mbisim_Red1'_Red1 s1 s2\" and \"Red1_mthr.if.redT False P s1 tl1 s1'\""], ["proof (state)\nthis:\n  if_mbisim_Red1'_Red1 s1 s2\n  Red1_mthr.if.redT False P s1 tl1 s1'\n\ngoal (2 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>if_mbisim_Red1'_Red1 s1 s2;\n        Red1_mthr.if.redT False P s1 tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' tl2.\n                            Red1_mthr.if.redT True P s2 tl2 s2' \\<and>\n                            if_mbisim_Red1'_Red1 s1' s2' \\<and> tl1 = tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>if_mbisim_Red1'_Red1 s1 s2;\n        Red1_mthr.if.redT True P s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' tl1.\n                            Red1_mthr.if.redT False P s1 tl1 s1' \\<and>\n                            if_mbisim_Red1'_Red1 s1' s2' \\<and> tl1 = tl2", "thus \"\\<exists>s2' tl2. Red1_mthr.if.redT True P s2 tl2 s2' \\<and> if_mbisim_Red1'_Red1 s1' s2' \\<and> tl1 = tl2\""], ["proof (prove)\nusing this:\n  if_mbisim_Red1'_Red1 s1 s2\n  Red1_mthr.if.redT False P s1 tl1 s1'\n\ngoal (1 subgoal):\n 1. \\<exists>s2' tl2.\n       Red1_mthr.if.redT True P s2 tl2 s2' \\<and>\n       if_mbisim_Red1'_Red1 s1' s2' \\<and> tl1 = tl2", "by(cases tl1)(auto simp add: if_mbisim_Red1'_Red1_def if_Red1_mthr_eq_if_Red1_mthr' simp del: split_paired_Ex elim: if_Red1'_preserves_if_lock_oks[OF wf] lifting_wf.redT_preserves[OF if_Red1_el_loc_ok, OF wf])"], ["proof (state)\nthis:\n  \\<exists>s2' tl2.\n     Red1_mthr.if.redT True P s2 tl2 s2' \\<and>\n     if_mbisim_Red1'_Red1 s1' s2' \\<and> tl1 = tl2\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>if_mbisim_Red1'_Red1 s1 s2;\n        Red1_mthr.if.redT True P s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' tl1.\n                            Red1_mthr.if.redT False P s1 tl1 s1' \\<and>\n                            if_mbisim_Red1'_Red1 s1' s2' \\<and> tl1 = tl2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>if_mbisim_Red1'_Red1 s1 s2;\n        Red1_mthr.if.redT True P s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' tl1.\n                            Red1_mthr.if.redT False P s1 tl1 s1' \\<and>\n                            if_mbisim_Red1'_Red1 s1' s2' \\<and> tl1 = tl2", "fix s1 s2 tl2 s2'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>if_mbisim_Red1'_Red1 s1 s2;\n        Red1_mthr.if.redT True P s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' tl1.\n                            Red1_mthr.if.redT False P s1 tl1 s1' \\<and>\n                            if_mbisim_Red1'_Red1 s1' s2' \\<and> tl1 = tl2", "assume \"if_mbisim_Red1'_Red1 s1 s2\" \"Red1_mthr.if.redT True P s2 tl2 s2'\""], ["proof (state)\nthis:\n  if_mbisim_Red1'_Red1 s1 s2\n  Red1_mthr.if.redT True P s2 tl2 s2'\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>if_mbisim_Red1'_Red1 s1 s2;\n        Red1_mthr.if.redT True P s2 tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' tl1.\n                            Red1_mthr.if.redT False P s1 tl1 s1' \\<and>\n                            if_mbisim_Red1'_Red1 s1' s2' \\<and> tl1 = tl2", "thus \"\\<exists>s1' tl1. Red1_mthr.if.redT False P s1 tl1 s1' \\<and> if_mbisim_Red1'_Red1 s1' s2' \\<and> tl1 = tl2\""], ["proof (prove)\nusing this:\n  if_mbisim_Red1'_Red1 s1 s2\n  Red1_mthr.if.redT True P s2 tl2 s2'\n\ngoal (1 subgoal):\n 1. \\<exists>s1' tl1.\n       Red1_mthr.if.redT False P s1 tl1 s1' \\<and>\n       if_mbisim_Red1'_Red1 s1' s2' \\<and> tl1 = tl2", "by(cases tl2)(auto simp add: if_mbisim_Red1'_Red1_def if_Red1_mthr_eq_if_Red1_mthr' simp del: split_paired_Ex elim: if_Red1'_preserves_if_lock_oks[OF wf] lifting_wf.redT_preserves[OF if_Red1_el_loc_ok, OF wf])"], ["proof (state)\nthis:\n  \\<exists>s1' tl1.\n     Red1_mthr.if.redT False P s1 tl1 s1' \\<and>\n     if_mbisim_Red1'_Red1 s1' s2' \\<and> tl1 = tl2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma if_bisim_J1_J1_start:\n  assumes wf: \"wf_J1_prog P\"\n  and wf_start: \"wf_start_state P C M vs\"\n  shows \"if_mbisim_Red1'_Red1 (init_fin_lift_state status (J1_start_state P C M vs)) (init_fin_lift_state status (J1_start_state P C M vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if_mbisim_Red1'_Red1\n     (init_fin_lift_state status (J1_start_state P C M vs))\n     (init_fin_lift_state status (J1_start_state P C M vs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. if_mbisim_Red1'_Red1\n     (init_fin_lift_state status (J1_start_state P C M vs))\n     (init_fin_lift_state status (J1_start_state P C M vs))", "from assms"], ["proof (chain)\npicking this:\n  wf_J1_prog P\n  wf_start_state P C M vs", "have \"mbisim_Red1'_Red1 (J1_start_state P C M vs) (J1_start_state P C M vs)\""], ["proof (prove)\nusing this:\n  wf_J1_prog P\n  wf_start_state P C M vs\n\ngoal (1 subgoal):\n 1. mbisim_Red1'_Red1 (J1_start_state P C M vs) (J1_start_state P C M vs)", "by(rule bisim_J1_J1_start)"], ["proof (state)\nthis:\n  mbisim_Red1'_Red1 (J1_start_state P C M vs) (J1_start_state P C M vs)\n\ngoal (1 subgoal):\n 1. if_mbisim_Red1'_Red1\n     (init_fin_lift_state status (J1_start_state P C M vs))\n     (init_fin_lift_state status (J1_start_state P C M vs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  mbisim_Red1'_Red1 (J1_start_state P C M vs) (J1_start_state P C M vs)\n\ngoal (1 subgoal):\n 1. if_mbisim_Red1'_Red1\n     (init_fin_lift_state status (J1_start_state P C M vs))\n     (init_fin_lift_state status (J1_start_state P C M vs))", "by(simp add: if_mbisim_Red1'_Red1_def mbisim_Red1'_Red1_def)(simp add: init_fin_lift_state_conv_simps init_fin_descend_thr_def thr_init_fin_list_state' o_def map_option.compositionality map_option.identity split_beta)"], ["proof (state)\nthis:\n  if_mbisim_Red1'_Red1\n   (init_fin_lift_state status (J1_start_state P C M vs))\n   (init_fin_lift_state status (J1_start_state P C M vs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma if_Red1'_Red1_bisim_into_weak:\n  assumes wf: \"wf_J1_prog P\"\n  shows \"bisimulation_into_delay (Red1_mthr.if.redT False P) (Red1_mthr.if.redT True P) if_mbisim_Red1'_Red1 (=) (Red1_mthr.if.m\\<tau>move P) (Red1_mthr.if.m\\<tau>move P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisimulation_into_delay (Red1_mthr.if.redT False P)\n     (Red1_mthr.if.redT True P) if_mbisim_Red1'_Red1 (=)\n     (Red1_mthr.if.m\\<tau>move P) (Red1_mthr.if.m\\<tau>move P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bisimulation_into_delay (Red1_mthr.if.redT False P)\n     (Red1_mthr.if.redT True P) if_mbisim_Red1'_Red1 (=)\n     (Red1_mthr.if.m\\<tau>move P) (Red1_mthr.if.m\\<tau>move P)", "interpret b: bisimulation \"Red1_mthr.if.redT False P\" \"Red1_mthr.if.redT True P\" \"if_mbisim_Red1'_Red1\" \"(=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisimulation (Red1_mthr.if.redT False P) (Red1_mthr.if.redT True P)\n     if_mbisim_Red1'_Red1 (=)", "by(rule Red1'_Red1_if_bisimulation[OF wf])"], ["proof (state)\ngoal (1 subgoal):\n 1. bisimulation_into_delay (Red1_mthr.if.redT False P)\n     (Red1_mthr.if.redT True P) if_mbisim_Red1'_Red1 (=)\n     (Red1_mthr.if.m\\<tau>move P) (Red1_mthr.if.m\\<tau>move P)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. bisimulation_into_delay (Red1_mthr.if.redT False P)\n     (Red1_mthr.if.redT True P) if_mbisim_Red1'_Red1 (=)\n     (Red1_mthr.if.m\\<tau>move P) (Red1_mthr.if.m\\<tau>move P)", "by(unfold_locales)(simp add: if_mbisim_Red1'_Red1_def)"], ["proof (state)\nthis:\n  bisimulation_into_delay (Red1_mthr.if.redT False P)\n   (Red1_mthr.if.redT True P) if_mbisim_Red1'_Red1 (=)\n   (Red1_mthr.if.m\\<tau>move P) (Red1_mthr.if.m\\<tau>move P)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma if_Red1'_Red1_bisimulation_final:\n  \"wf_J1_prog P \n  \\<Longrightarrow> bisimulation_final (Red1_mthr.if.redT False P) (Red1_mthr.if.redT True P) \n       if_mbisim_Red1'_Red1 (=) Red1_mthr.if.mfinal Red1_mthr.if.mfinal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_J1_prog P \\<Longrightarrow>\n    bisimulation_final (Red1_mthr.if.redT False P)\n     (Red1_mthr.if.redT True P) if_mbisim_Red1'_Red1 (=) Red1_mthr.if.mfinal\n     Red1_mthr.if.mfinal", "apply(intro_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf_J1_prog P \\<Longrightarrow>\n    bisimulation (Red1_mthr.if.redT False P) (Red1_mthr.if.redT True P)\n     if_mbisim_Red1'_Red1 (=)\n 2. wf_J1_prog P \\<Longrightarrow>\n    bisimulation_final_axioms if_mbisim_Red1'_Red1 Red1_mthr.if.mfinal\n     Red1_mthr.if.mfinal", "apply(erule Red1'_Red1_if_bisimulation)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_J1_prog P \\<Longrightarrow>\n    bisimulation_final_axioms if_mbisim_Red1'_Red1 Red1_mthr.if.mfinal\n     Red1_mthr.if.mfinal", "apply(unfold_locales)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       \\<lbrakk>wf_J1_prog P; if_mbisim_Red1'_Red1 s1 s2\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.if.mfinal s1 = Red1_mthr.if.mfinal s2", "apply(auto simp add: if_mbisim_Red1'_Red1_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"]]}