{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/J/JWellForm.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma wf_J_mdecl[simp]:\n  \"wf_J_mdecl P C (M,Ts,T,pns,body) \\<equiv>\n  (length Ts = length pns \\<and>\n  distinct pns \\<and>\n  this \\<notin> set pns \\<and>\n  (\\<exists>T'. P,[this\\<mapsto>Class C,pns[\\<mapsto>]Ts] \\<turnstile> body :: T' \\<and> P \\<turnstile> T' \\<le> T) \\<and>\n  \\<D> body \\<lfloor>{this} \\<union> set pns\\<rfloor>)\"", "lemma wf_mdecl_wwf_mdecl: \"wf_J_mdecl P C Md \\<Longrightarrow> wwf_J_mdecl P C Md\"", "lemma wf_prog_wwf_prog: \"wf_J_prog P \\<Longrightarrow> wwf_J_prog P\"", "lemma wf_J_prog_wf_J_prog':\n  \"wf_J_prog P \\<Longrightarrow> wf_J_prog' P\"", "lemma wf_J_prog'_wf_J_prog:\n  \"wf_J_prog' P \\<Longrightarrow> wf_J_prog P\"", "lemma wf_J_prog_eq_wf_J_prog' [code_unfold]:\n  \"wf_J_prog = wf_J_prog'\""], "translations": [["", "lemma wf_J_mdecl[simp]:\n  \"wf_J_mdecl P C (M,Ts,T,pns,body) \\<equiv>\n  (length Ts = length pns \\<and>\n  distinct pns \\<and>\n  this \\<notin> set pns \\<and>\n  (\\<exists>T'. P,[this\\<mapsto>Class C,pns[\\<mapsto>]Ts] \\<turnstile> body :: T' \\<and> P \\<turnstile> T' \\<le> T) \\<and>\n  \\<D> body \\<lfloor>{this} \\<union> set pns\\<rfloor>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_J_mdecl P C (M, Ts, T, pns, body) \\<equiv>\n    length Ts = length pns \\<and>\n    distinct pns \\<and>\n    this \\<notin> set pns \\<and>\n    (\\<exists>T'.\n        P,[this \\<mapsto> Class C, pns [\\<mapsto>]\n           Ts] \\<turnstile> body :: T' \\<and>\n        P \\<turnstile> T' \\<le> T) \\<and>\n    \\<D> body \\<lfloor>{this} \\<union> set pns\\<rfloor>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_J_mdecl P C (M, Ts, T, pns, body) \\<equiv>\n    length Ts = length pns \\<and>\n    distinct pns \\<and>\n    this \\<notin> set pns \\<and>\n    (\\<exists>T'.\n        P,[this \\<mapsto> Class C, pns [\\<mapsto>]\n           Ts] \\<turnstile> body :: T' \\<and>\n        P \\<turnstile> T' \\<le> T) \\<and>\n    \\<D> body \\<lfloor>{this} \\<union> set pns\\<rfloor>", "by(simp add:wf_J_mdecl_def)"], ["", "(*>*)"], ["", "abbreviation wf_J_prog :: \"'addr J_prog \\<Rightarrow> bool\"\nwhere \"wf_J_prog == wf_prog wf_J_mdecl\""], ["", "lemma wf_mdecl_wwf_mdecl: \"wf_J_mdecl P C Md \\<Longrightarrow> wwf_J_mdecl P C Md\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_J_mdecl P C Md \\<Longrightarrow> wwf_J_mdecl P C Md", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_J_mdecl P C Md \\<Longrightarrow> wwf_J_mdecl P C Md", "apply(clarsimp simp add: wwf_J_mdecl_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M a aa ab b x T'.\n       \\<lbrakk>Md = (M, a, aa, ab, b); x \\<in> fv b; x \\<notin> set ab;\n        length a = length ab; distinct ab; this \\<notin> set ab;\n        \\<D> b \\<lfloor>insert this (set ab)\\<rfloor>;\n        P,[ab [\\<mapsto>] a, this \\<mapsto> Class C] \\<turnstile> b :: T';\n        P \\<turnstile> T' \\<le> aa\\<rbrakk>\n       \\<Longrightarrow> x = this", "apply(frule WT_fv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M a aa ab b x T'.\n       \\<lbrakk>Md = (M, a, aa, ab, b); x \\<in> fv b; x \\<notin> set ab;\n        length a = length ab; distinct ab; this \\<notin> set ab;\n        \\<D> b \\<lfloor>insert this (set ab)\\<rfloor>;\n        P,[ab [\\<mapsto>] a, this \\<mapsto> Class C] \\<turnstile> b :: T';\n        P \\<turnstile> T' \\<le> aa;\n        fv b\n        \\<subseteq> dom [ab [\\<mapsto>] a, this \\<mapsto> Class C]\\<rbrakk>\n       \\<Longrightarrow> x = this", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wf_prog_wwf_prog: \"wf_J_prog P \\<Longrightarrow> wwf_J_prog P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_J_prog P \\<Longrightarrow> wwf_J_prog P", "by(erule wf_prog_lift)(erule wf_mdecl_wwf_mdecl)"], ["", "subsection \\<open>Code generation\\<close>"], ["", "definition typeable_with :: \"'addr J_prog \\<Rightarrow> env \\<Rightarrow> 'addr expr \\<Rightarrow> ty \\<Rightarrow> bool\"\nwhere [simp]: \"typeable_with P E e T \\<longleftrightarrow> (\\<exists>T'. P,E \\<turnstile> e ::' T' \\<and> P \\<turnstile> T' \\<le> T)\""], ["", "definition wf_J_mdecl' :: \"'addr J_prog \\<Rightarrow> cname \\<Rightarrow> 'addr J_mb mdecl \\<Rightarrow> bool\"\nwhere\n  \"wf_J_mdecl' P C  \\<equiv>  \\<lambda>(M,Ts,T,(pns,body)).\n  length Ts = length pns \\<and>\n  distinct pns \\<and>\n  this \\<notin> set pns \\<and>\n  typeable_with P [this\\<mapsto>Class C,pns[\\<mapsto>]Ts] body T \\<and>\n  \\<D> body \\<lfloor>{this} \\<union> set pns\\<rfloor>\""], ["", "definition wf_J_prog' :: \"'addr J_prog \\<Rightarrow> bool\"\nwhere \"wf_J_prog' = wf_prog wf_J_mdecl'\""], ["", "lemma wf_J_prog_wf_J_prog':\n  \"wf_J_prog P \\<Longrightarrow> wf_J_prog' P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_J_prog P \\<Longrightarrow> wf_J_prog' P", "unfolding wf_J_prog'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_J_prog P \\<Longrightarrow> wf_prog wf_J_mdecl' P", "apply(erule wf_prog_lift)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>wf_md C M Ts Ca T m.\n       \\<lbrakk>wf_prog wf_md P;\n        P \\<turnstile> Ca sees M: Ts\\<rightarrow>T = \\<lfloor>m\\<rfloor> in Ca;\n        is_class P Ca; set Ts \\<subseteq> types P;\n        wf_J_mdecl P Ca (M, Ts, T, m)\\<rbrakk>\n       \\<Longrightarrow> wf_J_mdecl' P Ca (M, Ts, T, m)", "apply(clarsimp simp add: wf_J_mdecl'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>wf_md M Ts Ca T a b T'.\n       \\<lbrakk>wf_prog wf_md P;\n        P \\<turnstile> Ca sees M: Ts\\<rightarrow>T = \\<lfloor>(a,\n                         b)\\<rfloor> in Ca;\n        is_class P Ca; set Ts \\<subseteq> types P; length Ts = length a;\n        distinct a; this \\<notin> set a;\n        \\<D> b \\<lfloor>insert this (set a)\\<rfloor>;\n        P,[a [\\<mapsto>] Ts, this \\<mapsto> Class Ca] \\<turnstile> b :: T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T'.\n                            P,[a [\\<mapsto>] Ts, this \\<mapsto>\n                               Class Ca] \\<turnstile> b ::' T' \\<and>\n                            P \\<turnstile> T' \\<le> T", "apply(drule (1) WT_into_WT_code)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>wf_md M Ts Ca T a b T'.\n       \\<lbrakk>P \\<turnstile> Ca sees M: Ts\\<rightarrow>T = \\<lfloor>(a,\n                                 b)\\<rfloor> in Ca;\n        is_class P Ca; set Ts \\<subseteq> types P; length Ts = length a;\n        distinct a; this \\<notin> set a;\n        \\<D> b \\<lfloor>insert this (set a)\\<rfloor>;\n        P,[a [\\<mapsto>] Ts, this \\<mapsto> Class Ca] \\<turnstile> b :: T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> ran [a [\\<mapsto>] Ts, this \\<mapsto> Class Ca]\n                         \\<subseteq> types P\n 2. \\<And>wf_md M Ts Ca T a b T'.\n       \\<lbrakk>P \\<turnstile> Ca sees M: Ts\\<rightarrow>T = \\<lfloor>(a,\n                                 b)\\<rfloor> in Ca;\n        is_class P Ca; set Ts \\<subseteq> types P; length Ts = length a;\n        distinct a; this \\<notin> set a;\n        \\<D> b \\<lfloor>insert this (set a)\\<rfloor>;\n        P,[a [\\<mapsto>] Ts, this \\<mapsto> Class Ca] \\<turnstile> b :: T';\n        P \\<turnstile> T' \\<le> T;\n        P,[a [\\<mapsto>] Ts, this \\<mapsto>\n           Class Ca] \\<turnstile> b ::' T'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T'.\n                            P,[a [\\<mapsto>] Ts, this \\<mapsto>\n                               Class Ca] \\<turnstile> b ::' T' \\<and>\n                            P \\<turnstile> T' \\<le> T", "apply(auto simp add: ran_def map_upds_def dest!: map_of_SomeD set_zip_rightD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wf_J_prog'_wf_J_prog:\n  \"wf_J_prog' P \\<Longrightarrow> wf_J_prog P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_J_prog' P \\<Longrightarrow> wf_J_prog P", "unfolding wf_J_prog'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_J_mdecl' P \\<Longrightarrow> wf_J_prog P", "apply(erule wf_prog_lift)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>wf_md C M Ts Ca T m.\n       \\<lbrakk>wf_prog wf_md P;\n        P \\<turnstile> Ca sees M: Ts\\<rightarrow>T = \\<lfloor>m\\<rfloor> in Ca;\n        is_class P Ca; set Ts \\<subseteq> types P;\n        wf_J_mdecl' P Ca (M, Ts, T, m)\\<rbrakk>\n       \\<Longrightarrow> wf_J_mdecl P Ca (M, Ts, T, m)", "apply(clarsimp simp add: wf_J_mdecl'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>wf_md M Ts Ca T a b T'.\n       \\<lbrakk>wf_prog wf_md P;\n        P \\<turnstile> Ca sees M: Ts\\<rightarrow>T = \\<lfloor>(a,\n                         b)\\<rfloor> in Ca;\n        is_class P Ca; set Ts \\<subseteq> types P; length Ts = length a;\n        distinct a; this \\<notin> set a;\n        \\<D> b \\<lfloor>insert this (set a)\\<rfloor>;\n        P,[a [\\<mapsto>] Ts, this \\<mapsto> Class Ca] \\<turnstile> b ::' T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T'.\n                            P,[a [\\<mapsto>] Ts, this \\<mapsto>\n                               Class Ca] \\<turnstile> b :: T' \\<and>\n                            P \\<turnstile> T' \\<le> T", "apply(drule (1) WT_code_into_WT)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>wf_md M Ts Ca T a b T'.\n       \\<lbrakk>P \\<turnstile> Ca sees M: Ts\\<rightarrow>T = \\<lfloor>(a,\n                                 b)\\<rfloor> in Ca;\n        is_class P Ca; set Ts \\<subseteq> types P; length Ts = length a;\n        distinct a; this \\<notin> set a;\n        \\<D> b \\<lfloor>insert this (set a)\\<rfloor>;\n        P,[a [\\<mapsto>] Ts, this \\<mapsto> Class Ca] \\<turnstile> b ::' T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> ran [a [\\<mapsto>] Ts, this \\<mapsto> Class Ca]\n                         \\<subseteq> types P\n 2. \\<And>wf_md M Ts Ca T a b T'.\n       \\<lbrakk>P \\<turnstile> Ca sees M: Ts\\<rightarrow>T = \\<lfloor>(a,\n                                 b)\\<rfloor> in Ca;\n        is_class P Ca; set Ts \\<subseteq> types P; length Ts = length a;\n        distinct a; this \\<notin> set a;\n        \\<D> b \\<lfloor>insert this (set a)\\<rfloor>;\n        P,[a [\\<mapsto>] Ts, this \\<mapsto> Class Ca] \\<turnstile> b ::' T';\n        P \\<turnstile> T' \\<le> T;\n        P,[a [\\<mapsto>] Ts, this \\<mapsto>\n           Class Ca] \\<turnstile> b :: T'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T'.\n                            P,[a [\\<mapsto>] Ts, this \\<mapsto>\n                               Class Ca] \\<turnstile> b :: T' \\<and>\n                            P \\<turnstile> T' \\<le> T", "apply(auto simp add: ran_def map_upds_def dest!: map_of_SomeD set_zip_rightD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wf_J_prog_eq_wf_J_prog' [code_unfold]:\n  \"wf_J_prog = wf_J_prog'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_J_prog = wf_J_prog'", "by(blast intro: ext wf_J_prog'_wf_J_prog wf_J_prog_wf_J_prog' del: equalityI)"], ["", "code_pred \n  (modes: i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> bool)\n  [inductify]\n  typeable_with"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text \\<open>Formal code generation test\\<close>"], ["", "ML_val \\<open>@{code wf_J_prog'}\\<close>"], ["", "end"]]}