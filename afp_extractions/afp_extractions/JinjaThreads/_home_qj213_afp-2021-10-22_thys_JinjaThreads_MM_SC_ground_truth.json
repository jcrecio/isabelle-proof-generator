{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/MM/SC.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma rec_heapobj [simp]: \"rec_heapobj = case_heapobj\"", "lemma is_Arr_conv:\n  \"is_Arr arrobj = (\\<exists>T f el. arrobj = Arr T f el)\"", "lemma is_ArrE:\n  \"\\<lbrakk> is_Arr arrobj; \\<And>T f el. arrobj = Arr T f el \\<Longrightarrow> thesis \\<rbrakk> \\<Longrightarrow> thesis\"\n  \"\\<lbrakk> \\<not> is_Arr arrobj; \\<And>C fs. arrobj = Obj C fs \\<Longrightarrow> thesis \\<rbrakk> \\<Longrightarrow> thesis\"", "lemma obj_ty_blank [iff]: \n  \"obj_ty (blank P hT) = hT\"", "lemma sc_start_heap_ok: \"sc_start_heap_ok P\"", "lemma sc_wf_start_state_iff:\n  \"sc_wf_start_state P C M vs \\<longleftrightarrow> (\\<exists>Ts T meth D. P \\<turnstile> C sees M:Ts\\<rightarrow>T = \\<lfloor>meth\\<rfloor> in D \\<and> P,sc_start_heap P \\<turnstile>sc vs [:\\<le>] Ts)\"", "lemma sc_heap:\n  \"heap addr2thread_id thread_id2addr (sc_allocate P) sc_typeof_addr sc_heap_write P\"", "lemma sc_hext_new:\n  \"h a = None \\<Longrightarrow> h \\<unlhd>sc h(a \\<mapsto> arrobj)\"", "lemma sc_hext_upd_obj: \"h a = Some (Obj C fs) \\<Longrightarrow> h \\<unlhd>sc h(a\\<mapsto>(Obj C fs'))\"", "lemma sc_hext_upd_arr: \"\\<lbrakk> h a = Some (Arr T f e); length e = length e' \\<rbrakk> \\<Longrightarrow> h \\<unlhd>sc h(a\\<mapsto>(Arr T f' e'))\"", "lemma sc_conf_upd_obj: \"h a = Some(Obj C fs) \\<Longrightarrow> (P,h(a\\<mapsto>(Obj C fs')) \\<turnstile>sc x :\\<le> T) = (P,h \\<turnstile>sc x :\\<le> T)\"", "lemma sc_conf_upd_arr: \"h a = Some(Arr T f el) \\<Longrightarrow> (P,h(a\\<mapsto>(Arr T f' el')) \\<turnstile>sc x :\\<le> T') = (P,h \\<turnstile>sc x :\\<le> T')\"", "lemma sc_oconf_hext: \"P,h \\<turnstile>sc obj \\<surd> \\<Longrightarrow> h \\<unlhd>sc h' \\<Longrightarrow> P,h' \\<turnstile>sc obj \\<surd>\"", "lemma sc_oconf_init_fields:\n  assumes \"P \\<turnstile> C has_fields FDTs\"\n  shows \"P,h \\<turnstile>sc (Obj C (init_fields FDTs)) \\<surd>\"", "lemma sc_oconf_init:\n \"is_htype P hT \\<Longrightarrow> P,h \\<turnstile>sc blank P hT \\<surd>\"", "lemma sc_oconf_fupd [intro?]:\n  \"\\<lbrakk> P \\<turnstile> C has F:T (fm) in D; P,h \\<turnstile>sc v :\\<le> T; P,h \\<turnstile>sc (Obj C fs) \\<surd> \\<rbrakk> \n  \\<Longrightarrow> P,h \\<turnstile>sc (Obj C (fs((F,D)\\<mapsto>v))) \\<surd>\"", "lemma sc_oconf_fupd_arr [intro?]:\n  \"\\<lbrakk> P,h \\<turnstile>sc v :\\<le> T; P,h \\<turnstile>sc (Arr T f el) \\<surd> \\<rbrakk>\n  \\<Longrightarrow> P,h \\<turnstile>sc (Arr T f (el[i := v])) \\<surd>\"", "lemma sc_oconf_fupd_arr_fields:\n  \"\\<lbrakk> P \\<turnstile> Object has F:T (fm) in Object; P,h \\<turnstile>sc v :\\<le> T; P,h \\<turnstile>sc (Arr T' f el) \\<surd> \\<rbrakk>\n  \\<Longrightarrow> P,h \\<turnstile>sc (Arr T' (f((F, Object) \\<mapsto> v)) el) \\<surd>\"", "lemma sc_oconf_new: \"\\<lbrakk> P,h \\<turnstile>sc obj \\<surd>; h a = None \\<rbrakk> \\<Longrightarrow> P,h(a \\<mapsto> arrobj) \\<turnstile>sc obj \\<surd>\"", "lemmas sc_oconf_upd_obj = sc_oconf_hext [OF _ sc_hext_upd_obj]", "lemma sc_oconf_upd_arr:\n  assumes \"P,h \\<turnstile>sc obj \\<surd>\"\n  and ha: \"h a = \\<lfloor>Arr T f el\\<rfloor>\"\n  shows \"P,h(a \\<mapsto> Arr T f' el') \\<turnstile>sc obj \\<surd>\"", "lemma sc_hconfD: \"\\<lbrakk> P \\<turnstile>sc h \\<surd>; h a = Some obj \\<rbrakk> \\<Longrightarrow> P,h \\<turnstile>sc obj \\<surd>\"", "lemmas sc_preallocated_new = sc.preallocated_hext[OF _ sc_hext_new]", "lemmas sc_preallocated_upd_obj = sc.preallocated_hext [OF _ sc_hext_upd_obj]", "lemmas sc_preallocated_upd_arr = sc.preallocated_hext [OF _ sc_hext_upd_arr]", "lemma sc_hconf_new: \"\\<lbrakk> P \\<turnstile>sc h \\<surd>; h a = None; P,h \\<turnstile>sc obj \\<surd> \\<rbrakk> \\<Longrightarrow> P \\<turnstile>sc h(a\\<mapsto>obj) \\<surd>\"", "lemma sc_hconf_upd_obj: \"\\<lbrakk> P \\<turnstile>sc h \\<surd>; h a = Some (Obj C fs); P,h \\<turnstile>sc (Obj C fs') \\<surd> \\<rbrakk> \\<Longrightarrow> P \\<turnstile>sc h(a\\<mapsto>(Obj C fs')) \\<surd>\"", "lemma sc_hconf_upd_arr: \"\\<lbrakk> P \\<turnstile>sc h \\<surd>; h a = Some(Arr T f el); P,h \\<turnstile>sc (Arr T f' el') \\<surd> \\<rbrakk> \\<Longrightarrow> P \\<turnstile>sc h(a\\<mapsto>(Arr T f' el')) \\<surd>\"", "lemma sc_heap_conf: \n  \"heap_conf addr2thread_id thread_id2addr sc_empty (sc_allocate P) sc_typeof_addr sc_heap_write (sc_hconf P) P\"", "lemma sc_heap_progress:\n  \"heap_progress addr2thread_id thread_id2addr sc_empty (sc_allocate P) sc_typeof_addr sc_heap_read sc_heap_write (sc_hconf P) P\"", "lemma sc_heap_conf_read:\n  \"heap_conf_read addr2thread_id thread_id2addr sc_empty (sc_allocate P) sc_typeof_addr sc_heap_read sc_heap_write (sc_hconf P) P\"", "lemma sc_deterministic_heap_ops: \"\\<not> sc_spurious_wakeups \\<Longrightarrow> sc_deterministic_heap_ops P\"", "lemma eval_sc_heap_read_i_i_i_o:\n  \"Predicate.eval (sc_heap_read_i_i_i_o h ad al) = sc_heap_read h ad al\"", "lemma eval_sc_heap_write_i_i_i_i_o:\n  \"Predicate.eval (sc_heap_write_i_i_i_i_o h ad al v) = sc_heap_write h ad al v\""], "translations": [["", "lemma rec_heapobj [simp]: \"rec_heapobj = case_heapobj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_heapobj = case_heapobj", "by(auto intro!: ext split: heapobj.split)"], ["", "primrec obj_ty  :: \"heapobj \\<Rightarrow> htype\"\nwhere\n  \"obj_ty (Obj C f)     = Class_type C\"\n| \"obj_ty (Arr T fs cs) = Array_type T (length cs)\""], ["", "fun is_Arr :: \"heapobj \\<Rightarrow> bool\" where\n  \"is_Arr (Obj C fs)   = False\"\n| \"is_Arr (Arr T f el) = True\""], ["", "lemma is_Arr_conv:\n  \"is_Arr arrobj = (\\<exists>T f el. arrobj = Arr T f el)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_Arr arrobj = (\\<exists>T f el. arrobj = Arr T f el)", "by(cases arrobj, auto)"], ["", "lemma is_ArrE:\n  \"\\<lbrakk> is_Arr arrobj; \\<And>T f el. arrobj = Arr T f el \\<Longrightarrow> thesis \\<rbrakk> \\<Longrightarrow> thesis\"\n  \"\\<lbrakk> \\<not> is_Arr arrobj; \\<And>C fs. arrobj = Obj C fs \\<Longrightarrow> thesis \\<rbrakk> \\<Longrightarrow> thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>is_Arr arrobj;\n      \\<And>T f el. arrobj = Arr T f el \\<Longrightarrow> thesis\\<rbrakk>\n     \\<Longrightarrow> thesis) &&&\n    (\\<lbrakk>\\<not> is_Arr arrobj;\n      \\<And>C fs. arrobj = Obj C fs \\<Longrightarrow> thesis\\<rbrakk>\n     \\<Longrightarrow> thesis)", "by(cases arrobj, auto)+"], ["", "definition init_fields :: \"('field_name \\<times> (ty \\<times> fmod)) list \\<Rightarrow> 'field_name \\<rightharpoonup> addr val\"\nwhere \"init_fields \\<equiv> map_of \\<circ> map (\\<lambda>(FD,(T, fm)). (FD,default_val T))\""], ["", "primrec\n  \\<comment> \\<open>a new, blank object with default values in all fields:\\<close>\n  blank :: \"'m prog \\<Rightarrow> htype \\<Rightarrow> heapobj\"\nwhere\n  \"blank P (Class_type C)   = Obj C (init_fields (fields P C))\"\n| \"blank P (Array_type T n) = Arr T (init_fields (fields P Object)) (replicate n (default_val T))\""], ["", "lemma obj_ty_blank [iff]: \n  \"obj_ty (blank P hT) = hT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obj_ty (blank P hT) = hT", "by(cases hT)(simp_all)"], ["", "subsection\\<open>Heap\\<close>"], ["", "type_synonym heap = \"addr \\<rightharpoonup> heapobj\""], ["", "translations\n  (type) \"heap\" <= (type) \"nat \\<Rightarrow> heapobj option\""], ["", "abbreviation sc_empty :: heap\nwhere \"sc_empty \\<equiv> Map.empty\""], ["", "fun the_obj :: \"heapobj \\<Rightarrow> cname \\<times> fields\" where\n  \"the_obj (Obj C fs) = (C, fs)\""], ["", "fun the_arr :: \"heapobj \\<Rightarrow> ty \\<times> fields \\<times> cells\" where\n  \"the_arr (Arr T f el) = (T, f, el)\""], ["", "abbreviation\n  cname_of :: \"heap \\<Rightarrow> addr \\<Rightarrow> cname\" where\n  \"cname_of hp a == fst (the_obj (the (hp a)))\""], ["", "definition sc_allocate :: \"'m prog \\<Rightarrow> heap \\<Rightarrow> htype \\<Rightarrow> (heap \\<times> addr) set\"\nwhere\n  \"sc_allocate P h hT = \n   (case new_Addr h of None \\<Rightarrow> {}\n                   | Some a \\<Rightarrow> {(h(a \\<mapsto> blank P hT), a)})\""], ["", "definition sc_typeof_addr :: \"heap \\<Rightarrow> addr \\<Rightarrow> htype option\"\nwhere \"sc_typeof_addr h a = map_option obj_ty (h a)\""], ["", "inductive sc_heap_read :: \"heap \\<Rightarrow> addr \\<Rightarrow> addr_loc \\<Rightarrow> addr val \\<Rightarrow> bool\"\nfor h :: heap and a :: addr\nwhere\n  Obj: \"\\<lbrakk> h a = \\<lfloor>Obj C fs\\<rfloor>; fs (F, D) = \\<lfloor>v\\<rfloor> \\<rbrakk> \\<Longrightarrow> sc_heap_read h a (CField D F) v\"\n| Arr: \"\\<lbrakk> h a = \\<lfloor>Arr T f el\\<rfloor>; n < length el \\<rbrakk> \\<Longrightarrow> sc_heap_read h a (ACell n) (el ! n)\"\n| ArrObj: \"\\<lbrakk> h a = \\<lfloor>Arr T f el\\<rfloor>; f (F, Object) = \\<lfloor>v\\<rfloor> \\<rbrakk> \\<Longrightarrow> sc_heap_read h a (CField Object F) v\""], ["", "hide_fact (open) Obj Arr ArrObj"], ["", "inductive_cases sc_heap_read_cases [elim!]:\n  \"sc_heap_read h a (CField C F) v\"\n  \"sc_heap_read h a (ACell n) v\""], ["", "inductive sc_heap_write :: \"heap \\<Rightarrow> addr \\<Rightarrow> addr_loc \\<Rightarrow> addr val \\<Rightarrow> heap \\<Rightarrow> bool\"\nfor h :: heap and a :: addr\nwhere\n  Obj: \"\\<lbrakk> h a = \\<lfloor>Obj C fs\\<rfloor>; h' = h(a \\<mapsto> Obj C (fs((F, D) \\<mapsto> v))) \\<rbrakk> \\<Longrightarrow> sc_heap_write h a (CField D F) v h'\"\n| Arr: \"\\<lbrakk> h a = \\<lfloor>Arr T f el\\<rfloor>; h' = h(a \\<mapsto> Arr T f (el[n := v])) \\<rbrakk> \\<Longrightarrow> sc_heap_write h a (ACell n) v h'\"\n| ArrObj: \"\\<lbrakk> h a = \\<lfloor>Arr T f el\\<rfloor>; h' = h(a \\<mapsto> Arr T (f((F, Object) \\<mapsto> v)) el) \\<rbrakk> \\<Longrightarrow> sc_heap_write h a (CField Object F) v h'\""], ["", "hide_fact (open) Obj Arr ArrObj"], ["", "inductive_cases sc_heap_write_cases [elim!]:\n  \"sc_heap_write h a (CField C F) v h'\"\n  \"sc_heap_write h a (ACell n) v h'\""], ["", "consts sc_spurious_wakeups :: bool"], ["", "interpretation sc: \n  heap_base\n    \"addr2thread_id\"\n    \"thread_id2addr\"\n    \"sc_spurious_wakeups\"\n    \"sc_empty\"\n    \"sc_allocate P\"\n    \"sc_typeof_addr\"\n    \"sc_heap_read\"\n    \"sc_heap_write\"\n  for P"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text \\<open>Translate notation from \\<open>heap_base\\<close>\\<close>"], ["", "(* FIXME! Why does sc.preallocated need the type token?? *)"], ["", "abbreviation sc_preallocated :: \"'m prog \\<Rightarrow> heap \\<Rightarrow> bool\"\nwhere \"sc_preallocated == sc.preallocated TYPE('m)\""], ["", "abbreviation sc_start_tid :: \"'md prog \\<Rightarrow> thread_id\"\nwhere \"sc_start_tid \\<equiv> sc.start_tid TYPE('md)\""], ["", "abbreviation sc_start_heap_ok :: \"'m prog \\<Rightarrow> bool\"\nwhere \"sc_start_heap_ok \\<equiv> sc.start_heap_ok TYPE('m)\""], ["", "abbreviation sc_start_heap :: \"'m prog \\<Rightarrow> heap\"\nwhere \"sc_start_heap \\<equiv> sc.start_heap TYPE('m)\""], ["", "abbreviation sc_start_state :: \n  \"(cname \\<Rightarrow> mname \\<Rightarrow> ty list \\<Rightarrow> ty \\<Rightarrow> 'm \\<Rightarrow> addr val list \\<Rightarrow> 'x)\n  \\<Rightarrow> 'm prog \\<Rightarrow> cname \\<Rightarrow> mname \\<Rightarrow> addr val list \\<Rightarrow> (addr, thread_id, 'x, heap, addr) state\"\nwhere\n  \"sc_start_state f P \\<equiv> sc.start_state TYPE('m) P f P\""], ["", "abbreviation sc_wf_start_state :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> mname \\<Rightarrow> addr val list \\<Rightarrow> bool\"\nwhere \"sc_wf_start_state P \\<equiv> sc.wf_start_state TYPE('m) P P\""], ["", "notation sc.conf (\"_,_ \\<turnstile>sc _ :\\<le> _\"  [51,51,51,51] 50)"], ["", "notation sc.confs (\"_,_ \\<turnstile>sc _ [:\\<le>] _\" [51,51,51,51] 50)"], ["", "notation sc.hext (\"_ \\<unlhd>sc _\" [51,51] 50)"], ["", "lemma sc_start_heap_ok: \"sc_start_heap_ok P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sc_start_heap_ok P", "apply(simp add: sc.start_heap_ok_def sc.start_heap_data_def initialization_list_def sc.create_initial_object_simps sc_allocate_def sys_xcpts_list_def case_option_conv_if new_Addr_SomeI del: blank.simps split del: option.split if_split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sc_wf_start_state_iff:\n  \"sc_wf_start_state P C M vs \\<longleftrightarrow> (\\<exists>Ts T meth D. P \\<turnstile> C sees M:Ts\\<rightarrow>T = \\<lfloor>meth\\<rfloor> in D \\<and> P,sc_start_heap P \\<turnstile>sc vs [:\\<le>] Ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sc_wf_start_state P C M vs =\n    (\\<exists>Ts T meth D.\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>meth\\<rfloor> in D \\<and>\n        P,sc_start_heap P \\<turnstile>sc vs [:\\<le>] Ts)", "by(simp add: sc.wf_start_state.simps sc_start_heap_ok)"], ["", "lemma sc_heap:\n  \"heap addr2thread_id thread_id2addr (sc_allocate P) sc_typeof_addr sc_heap_write P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap (\\<lambda>x. x) (\\<lambda>x. x) (sc_allocate P) sc_typeof_addr\n     sc_heap_write P", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h' a h hT.\n       \\<lbrakk>(h', a) \\<in> sc_allocate P h hT; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> sc_typeof_addr h' a = \\<lfloor>hT\\<rfloor>\n 3. \\<And>h' h hT a.\n       (h', a) \\<in> sc_allocate P h hT \\<Longrightarrow> h \\<unlhd>sc h'\n 4. \\<And>h a al v h'.\n       sc_heap_write h a al v h' \\<Longrightarrow> h \\<unlhd>sc h'", "fix h' a h hT"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h' a h hT.\n       \\<lbrakk>(h', a) \\<in> sc_allocate P h hT; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> sc_typeof_addr h' a = \\<lfloor>hT\\<rfloor>\n 3. \\<And>h' h hT a.\n       (h', a) \\<in> sc_allocate P h hT \\<Longrightarrow> h \\<unlhd>sc h'\n 4. \\<And>h a al v h'.\n       sc_heap_write h a al v h' \\<Longrightarrow> h \\<unlhd>sc h'", "assume \"(h', a) \\<in> sc_allocate P h hT\""], ["proof (state)\nthis:\n  (h', a) \\<in> sc_allocate P h hT\n\ngoal (4 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h' a h hT.\n       \\<lbrakk>(h', a) \\<in> sc_allocate P h hT; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> sc_typeof_addr h' a = \\<lfloor>hT\\<rfloor>\n 3. \\<And>h' h hT a.\n       (h', a) \\<in> sc_allocate P h hT \\<Longrightarrow> h \\<unlhd>sc h'\n 4. \\<And>h a al v h'.\n       sc_heap_write h a al v h' \\<Longrightarrow> h \\<unlhd>sc h'", "thus \"sc_typeof_addr h' a = \\<lfloor>hT\\<rfloor>\""], ["proof (prove)\nusing this:\n  (h', a) \\<in> sc_allocate P h hT\n\ngoal (1 subgoal):\n 1. sc_typeof_addr h' a = \\<lfloor>hT\\<rfloor>", "by(auto simp add: sc_allocate_def sc_typeof_addr_def dest: new_Addr_SomeD split: if_split_asm)"], ["proof (state)\nthis:\n  sc_typeof_addr h' a = \\<lfloor>hT\\<rfloor>\n\ngoal (3 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h' h hT a.\n       (h', a) \\<in> sc_allocate P h hT \\<Longrightarrow> h \\<unlhd>sc h'\n 3. \\<And>h a al v h'.\n       sc_heap_write h a al v h' \\<Longrightarrow> h \\<unlhd>sc h'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h' h hT a.\n       (h', a) \\<in> sc_allocate P h hT \\<Longrightarrow> h \\<unlhd>sc h'\n 3. \\<And>h a al v h'.\n       sc_heap_write h a al v h' \\<Longrightarrow> h \\<unlhd>sc h'", "fix h' h hT a"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h' h hT a.\n       (h', a) \\<in> sc_allocate P h hT \\<Longrightarrow> h \\<unlhd>sc h'\n 3. \\<And>h a al v h'.\n       sc_heap_write h a al v h' \\<Longrightarrow> h \\<unlhd>sc h'", "assume \"(h', a) \\<in> sc_allocate P h hT\""], ["proof (state)\nthis:\n  (h', a) \\<in> sc_allocate P h hT\n\ngoal (3 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h' h hT a.\n       (h', a) \\<in> sc_allocate P h hT \\<Longrightarrow> h \\<unlhd>sc h'\n 3. \\<And>h a al v h'.\n       sc_heap_write h a al v h' \\<Longrightarrow> h \\<unlhd>sc h'", "from this[symmetric]"], ["proof (chain)\npicking this:\n  (a, h') \\<in> (sc_allocate P h hT)\\<inverse>", "show \"h \\<unlhd>sc h'\""], ["proof (prove)\nusing this:\n  (a, h') \\<in> (sc_allocate P h hT)\\<inverse>\n\ngoal (1 subgoal):\n 1. h \\<unlhd>sc h'", "by(fastforce simp add: sc_allocate_def sc_typeof_addr_def sc.hext_def dest: new_Addr_SomeD intro!: map_leI)"], ["proof (state)\nthis:\n  h \\<unlhd>sc h'\n\ngoal (2 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h a al v h'.\n       sc_heap_write h a al v h' \\<Longrightarrow> h \\<unlhd>sc h'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h a al v h'.\n       sc_heap_write h a al v h' \\<Longrightarrow> h \\<unlhd>sc h'", "fix h a al v h'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h a al v h'.\n       sc_heap_write h a al v h' \\<Longrightarrow> h \\<unlhd>sc h'", "assume \"sc_heap_write h a al v h'\""], ["proof (state)\nthis:\n  sc_heap_write h a al v h'\n\ngoal (2 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h a al v h'.\n       sc_heap_write h a al v h' \\<Longrightarrow> h \\<unlhd>sc h'", "thus \"h \\<unlhd>sc h'\""], ["proof (prove)\nusing this:\n  sc_heap_write h a al v h'\n\ngoal (1 subgoal):\n 1. h \\<unlhd>sc h'", "by(cases al)(auto intro!: sc.hextI simp add: sc_typeof_addr_def)"], ["proof (state)\nthis:\n  h \\<unlhd>sc h'\n\ngoal (1 subgoal):\n 1. \\<And>h a C.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a", "qed simp"], ["", "interpretation sc: \n  heap \n    \"addr2thread_id\"\n    \"thread_id2addr\"\n    \"sc_spurious_wakeups\"\n    \"sc_empty\"\n    \"sc_allocate P\"\n    \"sc_typeof_addr\"\n    \"sc_heap_read\"\n    \"sc_heap_write\"\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap (\\<lambda>x. x) (\\<lambda>x. x) (sc_allocate P) sc_typeof_addr\n     sc_heap_write P", "by(rule sc_heap)"], ["", "lemma sc_hext_new:\n  \"h a = None \\<Longrightarrow> h \\<unlhd>sc h(a \\<mapsto> arrobj)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h a = None \\<Longrightarrow> h \\<unlhd>sc h(a \\<mapsto> arrobj)", "by(rule sc.hextI)(auto simp add: sc_typeof_addr_def dest!: new_Addr_SomeD)"], ["", "lemma sc_hext_upd_obj: \"h a = Some (Obj C fs) \\<Longrightarrow> h \\<unlhd>sc h(a\\<mapsto>(Obj C fs'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h a = \\<lfloor>Obj C fs\\<rfloor> \\<Longrightarrow>\n    h \\<unlhd>sc h(a \\<mapsto> Obj C fs')", "by(rule sc.hextI)(auto simp:fun_upd_apply sc_typeof_addr_def)"], ["", "lemma sc_hext_upd_arr: \"\\<lbrakk> h a = Some (Arr T f e); length e = length e' \\<rbrakk> \\<Longrightarrow> h \\<unlhd>sc h(a\\<mapsto>(Arr T f' e'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h a = \\<lfloor>Arr T f e\\<rfloor>;\n     length e = length e'\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd>sc h(a \\<mapsto> Arr T f' e')", "by(rule sc.hextI)(auto simp:fun_upd_apply sc_typeof_addr_def)"], ["", "subsection \\<open>Conformance\\<close>"], ["", "definition sc_fconf :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> heap \\<Rightarrow> fields \\<Rightarrow> bool\" (\"_,_,_ \\<turnstile>sc _ \\<surd>\" [51,51,51,51] 50)\nwhere \"P,C,h \\<turnstile>sc fs \\<surd> = (\\<forall>F D T fm. P \\<turnstile> C has F:T (fm) in D \\<longrightarrow> (\\<exists>v. fs(F,D) = Some v \\<and> P,h \\<turnstile>sc v :\\<le> T))\""], ["", "primrec sc_oconf :: \"'m prog \\<Rightarrow> heap \\<Rightarrow> heapobj \\<Rightarrow> bool\"   (\"_,_ \\<turnstile>sc _ \\<surd>\" [51,51,51] 50)\nwhere\n  \"P,h \\<turnstile>sc Obj C fs \\<surd> \\<longleftrightarrow> is_class P C \\<and> P,C,h \\<turnstile>sc fs \\<surd>\"\n| \"P,h \\<turnstile>sc Arr T fs el \\<surd> \\<longleftrightarrow> is_type P (T\\<lfloor>\\<rceil>) \\<and> P,Object,h \\<turnstile>sc fs \\<surd> \\<and> (\\<forall>v \\<in> set el. P,h \\<turnstile>sc v :\\<le> T)\""], ["", "definition sc_hconf :: \"'m prog \\<Rightarrow> heap \\<Rightarrow> bool\"  (\"_ \\<turnstile>sc _ \\<surd>\" [51,51] 50)\nwhere \"P \\<turnstile>sc h \\<surd> \\<longleftrightarrow> (\\<forall>a obj. h a = Some obj \\<longrightarrow> P,h \\<turnstile>sc obj \\<surd>)\""], ["", "interpretation sc: heap_conf_base  \n  \"addr2thread_id\"\n  \"thread_id2addr\"\n  \"sc_spurious_wakeups\"\n  \"sc_empty\"\n  \"sc_allocate P\"\n  \"sc_typeof_addr\"\n  \"sc_heap_read\"\n  \"sc_heap_write\"\n  \"sc_hconf P\"\n  \"P\"\nfor P"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "declare sc.typeof_addr_thread_id2_addr_addr2thread_id [simp del]"], ["", "lemma sc_conf_upd_obj: \"h a = Some(Obj C fs) \\<Longrightarrow> (P,h(a\\<mapsto>(Obj C fs')) \\<turnstile>sc x :\\<le> T) = (P,h \\<turnstile>sc x :\\<le> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h a = \\<lfloor>Obj C fs\\<rfloor> \\<Longrightarrow>\n    (P,h(a \\<mapsto> Obj C fs') \\<turnstile>sc x :\\<le> T) =\n    (P,h \\<turnstile>sc x :\\<le> T)", "apply (unfold sc.conf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. h a = \\<lfloor>Obj C fs\\<rfloor> \\<Longrightarrow>\n    (\\<exists>T'.\n        sc.typeof_h (h(a \\<mapsto> Obj C fs')) x =\n        \\<lfloor>T'\\<rfloor> \\<and>\n        P \\<turnstile> T' \\<le> T) =\n    (\\<exists>T'.\n        sc.typeof_h h x = \\<lfloor>T'\\<rfloor> \\<and>\n        P \\<turnstile> T' \\<le> T)", "apply (rule val.induct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. h a = \\<lfloor>Obj C fs\\<rfloor> \\<Longrightarrow>\n    (\\<exists>T'.\n        sc.typeof_h (h(a \\<mapsto> Obj C fs')) Unit =\n        \\<lfloor>T'\\<rfloor> \\<and>\n        P \\<turnstile> T' \\<le> T) =\n    (\\<exists>T'.\n        sc.typeof_h h Unit = \\<lfloor>T'\\<rfloor> \\<and>\n        P \\<turnstile> T' \\<le> T)\n 2. h a = \\<lfloor>Obj C fs\\<rfloor> \\<Longrightarrow>\n    (\\<exists>T'.\n        sc.typeof_h (h(a \\<mapsto> Obj C fs')) Null =\n        \\<lfloor>T'\\<rfloor> \\<and>\n        P \\<turnstile> T' \\<le> T) =\n    (\\<exists>T'.\n        sc.typeof_h h Null = \\<lfloor>T'\\<rfloor> \\<and>\n        P \\<turnstile> T' \\<le> T)\n 3. \\<And>x.\n       h a = \\<lfloor>Obj C fs\\<rfloor> \\<Longrightarrow>\n       (\\<exists>T'.\n           sc.typeof_h (h(a \\<mapsto> Obj C fs')) (Bool x) =\n           \\<lfloor>T'\\<rfloor> \\<and>\n           P \\<turnstile> T' \\<le> T) =\n       (\\<exists>T'.\n           sc.typeof_h h (Bool x) = \\<lfloor>T'\\<rfloor> \\<and>\n           P \\<turnstile> T' \\<le> T)\n 4. \\<And>x.\n       h a = \\<lfloor>Obj C fs\\<rfloor> \\<Longrightarrow>\n       (\\<exists>T'.\n           sc.typeof_h (h(a \\<mapsto> Obj C fs')) (Intg x) =\n           \\<lfloor>T'\\<rfloor> \\<and>\n           P \\<turnstile> T' \\<le> T) =\n       (\\<exists>T'.\n           sc.typeof_h h (Intg x) = \\<lfloor>T'\\<rfloor> \\<and>\n           P \\<turnstile> T' \\<le> T)\n 5. \\<And>x.\n       h a = \\<lfloor>Obj C fs\\<rfloor> \\<Longrightarrow>\n       (\\<exists>T'.\n           sc.typeof_h (h(a \\<mapsto> Obj C fs')) (Addr x) =\n           \\<lfloor>T'\\<rfloor> \\<and>\n           P \\<turnstile> T' \\<le> T) =\n       (\\<exists>T'.\n           sc.typeof_h h (Addr x) = \\<lfloor>T'\\<rfloor> \\<and>\n           P \\<turnstile> T' \\<le> T)", "apply (auto simp:fun_upd_apply)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x z.\n       \\<lbrakk>h a = \\<lfloor>Obj C fs\\<rfloor>;\n        P \\<turnstile> ty_of_htype z \\<le> T;\n        sc_typeof_addr\n         (\\<lambda>b. if b = a then \\<lfloor>Obj C fs'\\<rfloor> else h b)\n         x =\n        \\<lfloor>z\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T'.\n                            (\\<exists>z.\n                                sc_typeof_addr h x =\n                                \\<lfloor>z\\<rfloor> \\<and>\n                                ty_of_htype z = T') \\<and>\n                            P \\<turnstile> T' \\<le> T\n 2. \\<And>x z.\n       \\<lbrakk>h a = \\<lfloor>Obj C fs\\<rfloor>;\n        P \\<turnstile> ty_of_htype z \\<le> T;\n        sc_typeof_addr h x = \\<lfloor>z\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T'.\n                            (\\<exists>z.\n                                sc_typeof_addr\n                                 (\\<lambda>b.\n                                     if b = a\n                                     then \\<lfloor>Obj C fs'\\<rfloor>\n                                     else h b)\n                                 x =\n                                \\<lfloor>z\\<rfloor> \\<and>\n                                ty_of_htype z = T') \\<and>\n                            P \\<turnstile> T' \\<le> T", "apply (auto simp add: sc_typeof_addr_def split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sc_conf_upd_arr: \"h a = Some(Arr T f el) \\<Longrightarrow> (P,h(a\\<mapsto>(Arr T f' el')) \\<turnstile>sc x :\\<le> T') = (P,h \\<turnstile>sc x :\\<le> T')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h a = \\<lfloor>Arr T f el\\<rfloor> \\<Longrightarrow>\n    (P,h(a \\<mapsto> Arr T f' el') \\<turnstile>sc x :\\<le> T') =\n    (P,h \\<turnstile>sc x :\\<le> T')", "apply(unfold sc.conf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. h a = \\<lfloor>Arr T f el\\<rfloor> \\<Longrightarrow>\n    (\\<exists>T'a.\n        sc.typeof_h (h(a \\<mapsto> Arr T f' el')) x =\n        \\<lfloor>T'a\\<rfloor> \\<and>\n        P \\<turnstile> T'a \\<le> T') =\n    (\\<exists>T'a.\n        sc.typeof_h h x = \\<lfloor>T'a\\<rfloor> \\<and>\n        P \\<turnstile> T'a \\<le> T')", "apply (rule val.induct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. h a = \\<lfloor>Arr T f el\\<rfloor> \\<Longrightarrow>\n    (\\<exists>T'a.\n        sc.typeof_h (h(a \\<mapsto> Arr T f' el')) Unit =\n        \\<lfloor>T'a\\<rfloor> \\<and>\n        P \\<turnstile> T'a \\<le> T') =\n    (\\<exists>T'a.\n        sc.typeof_h h Unit = \\<lfloor>T'a\\<rfloor> \\<and>\n        P \\<turnstile> T'a \\<le> T')\n 2. h a = \\<lfloor>Arr T f el\\<rfloor> \\<Longrightarrow>\n    (\\<exists>T'a.\n        sc.typeof_h (h(a \\<mapsto> Arr T f' el')) Null =\n        \\<lfloor>T'a\\<rfloor> \\<and>\n        P \\<turnstile> T'a \\<le> T') =\n    (\\<exists>T'a.\n        sc.typeof_h h Null = \\<lfloor>T'a\\<rfloor> \\<and>\n        P \\<turnstile> T'a \\<le> T')\n 3. \\<And>x.\n       h a = \\<lfloor>Arr T f el\\<rfloor> \\<Longrightarrow>\n       (\\<exists>T'a.\n           sc.typeof_h (h(a \\<mapsto> Arr T f' el')) (Bool x) =\n           \\<lfloor>T'a\\<rfloor> \\<and>\n           P \\<turnstile> T'a \\<le> T') =\n       (\\<exists>T'a.\n           sc.typeof_h h (Bool x) = \\<lfloor>T'a\\<rfloor> \\<and>\n           P \\<turnstile> T'a \\<le> T')\n 4. \\<And>x.\n       h a = \\<lfloor>Arr T f el\\<rfloor> \\<Longrightarrow>\n       (\\<exists>T'a.\n           sc.typeof_h (h(a \\<mapsto> Arr T f' el')) (Intg x) =\n           \\<lfloor>T'a\\<rfloor> \\<and>\n           P \\<turnstile> T'a \\<le> T') =\n       (\\<exists>T'a.\n           sc.typeof_h h (Intg x) = \\<lfloor>T'a\\<rfloor> \\<and>\n           P \\<turnstile> T'a \\<le> T')\n 5. \\<And>x.\n       h a = \\<lfloor>Arr T f el\\<rfloor> \\<Longrightarrow>\n       (\\<exists>T'a.\n           sc.typeof_h (h(a \\<mapsto> Arr T f' el')) (Addr x) =\n           \\<lfloor>T'a\\<rfloor> \\<and>\n           P \\<turnstile> T'a \\<le> T') =\n       (\\<exists>T'a.\n           sc.typeof_h h (Addr x) = \\<lfloor>T'a\\<rfloor> \\<and>\n           P \\<turnstile> T'a \\<le> T')", "apply (auto simp:fun_upd_apply)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x z.\n       \\<lbrakk>h a = \\<lfloor>Arr T f el\\<rfloor>;\n        P \\<turnstile> ty_of_htype z \\<le> T';\n        sc_typeof_addr\n         (\\<lambda>b. if b = a then \\<lfloor>Arr T f' el'\\<rfloor> else h b)\n         x =\n        \\<lfloor>z\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T'a.\n                            (\\<exists>z.\n                                sc_typeof_addr h x =\n                                \\<lfloor>z\\<rfloor> \\<and>\n                                ty_of_htype z = T'a) \\<and>\n                            P \\<turnstile> T'a \\<le> T'\n 2. \\<And>x z.\n       \\<lbrakk>h a = \\<lfloor>Arr T f el\\<rfloor>;\n        P \\<turnstile> ty_of_htype z \\<le> T';\n        sc_typeof_addr h x = \\<lfloor>z\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T'a.\n                            (\\<exists>z.\n                                sc_typeof_addr\n                                 (\\<lambda>b.\n                                     if b = a\n                                     then \\<lfloor>Arr T f' el'\\<rfloor>\n                                     else h b)\n                                 x =\n                                \\<lfloor>z\\<rfloor> \\<and>\n                                ty_of_htype z = T'a) \\<and>\n                            P \\<turnstile> T'a \\<le> T'", "apply(auto simp add: sc_typeof_addr_def split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sc_oconf_hext: \"P,h \\<turnstile>sc obj \\<surd> \\<Longrightarrow> h \\<unlhd>sc h' \\<Longrightarrow> P,h' \\<turnstile>sc obj \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile>sc obj \\<surd>; h \\<unlhd>sc h'\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile>sc obj \\<surd>", "by(cases obj)(fastforce elim: sc.conf_hext simp add: sc_fconf_def)+"], ["", "lemma sc_oconf_init_fields:\n  assumes \"P \\<turnstile> C has_fields FDTs\"\n  shows \"P,h \\<turnstile>sc (Obj C (init_fields FDTs)) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc Obj C (init_fields FDTs) \\<surd>", "using assms has_fields_is_class[OF assms]"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n  is_class P C\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc Obj C (init_fields FDTs) \\<surd>", "by(auto simp add: has_field_def init_fields_def sc_fconf_def split_def o_def map_of_map[simplified split_def, where f=\"\\<lambda>p. default_val (fst p)\"] dest: has_fields_fun)"], ["", "lemma sc_oconf_init:\n \"is_htype P hT \\<Longrightarrow> P,h \\<turnstile>sc blank P hT \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_htype P hT \\<Longrightarrow> P,h \\<turnstile>sc blank P hT \\<surd>", "by(cases hT)(auto simp add: sc_fconf_def has_field_def init_fields_def split_def o_def map_of_map[simplified split_def, where f=\"\\<lambda>p. default_val (fst p)\"] dest: has_fields_fun)"], ["", "lemma sc_oconf_fupd [intro?]:\n  \"\\<lbrakk> P \\<turnstile> C has F:T (fm) in D; P,h \\<turnstile>sc v :\\<le> T; P,h \\<turnstile>sc (Obj C fs) \\<surd> \\<rbrakk> \n  \\<Longrightarrow> P,h \\<turnstile>sc (Obj C (fs((F,D)\\<mapsto>v))) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C has F:T (fm) in D;\n     P,h \\<turnstile>sc v :\\<le> T;\n     P,h \\<turnstile>sc Obj C fs \\<surd>\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile>sc Obj C\n    (fs((F, D) \\<mapsto> v)) \\<surd>", "unfolding has_field_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>FDTs.\n                P \\<turnstile> C has_fields FDTs \\<and>\n                map_of FDTs (F, D) = \\<lfloor>(T, fm)\\<rfloor>;\n     P,h \\<turnstile>sc v :\\<le> T;\n     P,h \\<turnstile>sc Obj C fs \\<surd>\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile>sc Obj C\n    (fs((F, D) \\<mapsto> v)) \\<surd>", "by(auto simp add: sc_fconf_def has_field_def dest: has_fields_fun)"], ["", "lemma sc_oconf_fupd_arr [intro?]:\n  \"\\<lbrakk> P,h \\<turnstile>sc v :\\<le> T; P,h \\<turnstile>sc (Arr T f el) \\<surd> \\<rbrakk>\n  \\<Longrightarrow> P,h \\<turnstile>sc (Arr T f (el[i := v])) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile>sc v :\\<le> T;\n     P,h \\<turnstile>sc Arr T f el \\<surd>\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile>sc Arr T f (el[i := v]) \\<surd>", "by(auto dest: subsetD[OF set_update_subset_insert])"], ["", "lemma sc_oconf_fupd_arr_fields:\n  \"\\<lbrakk> P \\<turnstile> Object has F:T (fm) in Object; P,h \\<turnstile>sc v :\\<le> T; P,h \\<turnstile>sc (Arr T' f el) \\<surd> \\<rbrakk>\n  \\<Longrightarrow> P,h \\<turnstile>sc (Arr T' (f((F, Object) \\<mapsto> v)) el) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> Object has F:T (fm) in Object;\n     P,h \\<turnstile>sc v :\\<le> T;\n     P,h \\<turnstile>sc Arr T' f el \\<surd>\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile>sc Arr T' (f((F, Object) \\<mapsto> v))\n    el \\<surd>", "by(auto dest: has_fields_fun simp add: sc_fconf_def has_field_def)"], ["", "lemma sc_oconf_new: \"\\<lbrakk> P,h \\<turnstile>sc obj \\<surd>; h a = None \\<rbrakk> \\<Longrightarrow> P,h(a \\<mapsto> arrobj) \\<turnstile>sc obj \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile>sc obj \\<surd>; h a = None\\<rbrakk>\n    \\<Longrightarrow> P,h(a \\<mapsto> arrobj) \\<turnstile>sc obj \\<surd>", "by(erule sc_oconf_hext)(rule sc_hext_new)"], ["", "lemmas sc_oconf_upd_obj = sc_oconf_hext [OF _ sc_hext_upd_obj]"], ["", "lemma sc_oconf_upd_arr:\n  assumes \"P,h \\<turnstile>sc obj \\<surd>\"\n  and ha: \"h a = \\<lfloor>Arr T f el\\<rfloor>\"\n  shows \"P,h(a \\<mapsto> Arr T f' el') \\<turnstile>sc obj \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h(a \\<mapsto> Arr T f' el') \\<turnstile>sc obj \\<surd>", "using assms"], ["proof (prove)\nusing this:\n  P,h \\<turnstile>sc obj \\<surd>\n  h a = \\<lfloor>Arr T f el\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,h(a \\<mapsto> Arr T f' el') \\<turnstile>sc obj \\<surd>", "by(cases obj)(auto simp add: sc_conf_upd_arr[where h=h, OF ha] sc_fconf_def)"], ["", "lemma sc_hconfD: \"\\<lbrakk> P \\<turnstile>sc h \\<surd>; h a = Some obj \\<rbrakk> \\<Longrightarrow> P,h \\<turnstile>sc obj \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile>sc h \\<surd>;\n     h a = \\<lfloor>obj\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile>sc obj \\<surd>", "unfolding sc_hconf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a obj.\n                h a = \\<lfloor>obj\\<rfloor> \\<longrightarrow>\n                P,h \\<turnstile>sc obj \\<surd>;\n     h a = \\<lfloor>obj\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile>sc obj \\<surd>", "by blast"], ["", "lemmas sc_preallocated_new = sc.preallocated_hext[OF _ sc_hext_new]"], ["", "lemmas sc_preallocated_upd_obj = sc.preallocated_hext [OF _ sc_hext_upd_obj]"], ["", "lemmas sc_preallocated_upd_arr = sc.preallocated_hext [OF _ sc_hext_upd_arr]"], ["", "lemma sc_hconf_new: \"\\<lbrakk> P \\<turnstile>sc h \\<surd>; h a = None; P,h \\<turnstile>sc obj \\<surd> \\<rbrakk> \\<Longrightarrow> P \\<turnstile>sc h(a\\<mapsto>obj) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile>sc h \\<surd>; h a = None;\n     P,h \\<turnstile>sc obj \\<surd>\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile>sc h(a \\<mapsto> obj) \\<surd>", "unfolding sc_hconf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a obj.\n                h a = \\<lfloor>obj\\<rfloor> \\<longrightarrow>\n                P,h \\<turnstile>sc obj \\<surd>;\n     h a = None; P,h \\<turnstile>sc obj \\<surd>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>aa obja.\n                         (h(a \\<mapsto> obj)) aa =\n                         \\<lfloor>obja\\<rfloor> \\<longrightarrow>\n                         P,h(a \\<mapsto> obj) \\<turnstile>sc obja \\<surd>", "by(auto intro: sc_oconf_new)"], ["", "lemma sc_hconf_upd_obj: \"\\<lbrakk> P \\<turnstile>sc h \\<surd>; h a = Some (Obj C fs); P,h \\<turnstile>sc (Obj C fs') \\<surd> \\<rbrakk> \\<Longrightarrow> P \\<turnstile>sc h(a\\<mapsto>(Obj C fs')) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile>sc h \\<surd>; h a = \\<lfloor>Obj C fs\\<rfloor>;\n     P,h \\<turnstile>sc Obj C fs' \\<surd>\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile>sc h(a \\<mapsto> Obj C fs') \\<surd>", "unfolding sc_hconf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a obj.\n                h a = \\<lfloor>obj\\<rfloor> \\<longrightarrow>\n                P,h \\<turnstile>sc obj \\<surd>;\n     h a = \\<lfloor>Obj C fs\\<rfloor>;\n     P,h \\<turnstile>sc Obj C fs' \\<surd>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>aa obj.\n                         (h(a \\<mapsto> Obj C fs')) aa =\n                         \\<lfloor>obj\\<rfloor> \\<longrightarrow>\n                         P,h(a \\<mapsto>\n                         Obj C fs') \\<turnstile>sc obj \\<surd>", "by(auto intro: sc_oconf_upd_obj simp del: sc_oconf.simps)"], ["", "lemma sc_hconf_upd_arr: \"\\<lbrakk> P \\<turnstile>sc h \\<surd>; h a = Some(Arr T f el); P,h \\<turnstile>sc (Arr T f' el') \\<surd> \\<rbrakk> \\<Longrightarrow> P \\<turnstile>sc h(a\\<mapsto>(Arr T f' el')) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile>sc h \\<surd>; h a = \\<lfloor>Arr T f el\\<rfloor>;\n     P,h \\<turnstile>sc Arr T f' el' \\<surd>\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile>sc h(a \\<mapsto> Arr T f' el') \\<surd>", "unfolding sc_hconf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a obj.\n                h a = \\<lfloor>obj\\<rfloor> \\<longrightarrow>\n                P,h \\<turnstile>sc obj \\<surd>;\n     h a = \\<lfloor>Arr T f el\\<rfloor>;\n     P,h \\<turnstile>sc Arr T f' el' \\<surd>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>aa obj.\n                         (h(a \\<mapsto> Arr T f' el')) aa =\n                         \\<lfloor>obj\\<rfloor> \\<longrightarrow>\n                         P,h(a \\<mapsto>\n                         Arr T f' el') \\<turnstile>sc obj \\<surd>", "by(auto intro: sc_oconf_upd_arr simp del: sc_oconf.simps)"], ["", "lemma sc_heap_conf: \n  \"heap_conf addr2thread_id thread_id2addr sc_empty (sc_allocate P) sc_typeof_addr sc_heap_write (sc_hconf P) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_conf (\\<lambda>x. x) (\\<lambda>x. x) sc_empty (sc_allocate P)\n     sc_typeof_addr sc_heap_write (sc_hconf P) P", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. P \\<turnstile>sc sc_empty \\<surd>\n 2. \\<And>h a hT.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        P \\<turnstile>sc h \\<surd>\\<rbrakk>\n       \\<Longrightarrow> is_htype P hT\n 3. \\<And>h' h hT a.\n       \\<lbrakk>(h', a) \\<in> sc_allocate P h hT;\n        P \\<turnstile>sc h \\<surd>; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>\n 4. \\<And>h a al v h' T.\n       \\<lbrakk>sc_heap_write h a al v h'; P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T; P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>", "show \"P \\<turnstile>sc sc_empty \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile>sc sc_empty \\<surd>", "by(simp add: sc_hconf_def)"], ["proof (state)\nthis:\n  P \\<turnstile>sc sc_empty \\<surd>\n\ngoal (3 subgoals):\n 1. \\<And>h a hT.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        P \\<turnstile>sc h \\<surd>\\<rbrakk>\n       \\<Longrightarrow> is_htype P hT\n 2. \\<And>h' h hT a.\n       \\<lbrakk>(h', a) \\<in> sc_allocate P h hT;\n        P \\<turnstile>sc h \\<surd>; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>\n 3. \\<And>h a al v h' T.\n       \\<lbrakk>sc_heap_write h a al v h'; P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T; P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>h a hT.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        P \\<turnstile>sc h \\<surd>\\<rbrakk>\n       \\<Longrightarrow> is_htype P hT\n 2. \\<And>h' h hT a.\n       \\<lbrakk>(h', a) \\<in> sc_allocate P h hT;\n        P \\<turnstile>sc h \\<surd>; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>\n 3. \\<And>h a al v h' T.\n       \\<lbrakk>sc_heap_write h a al v h'; P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T; P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>", "fix h a hT"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>h a hT.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        P \\<turnstile>sc h \\<surd>\\<rbrakk>\n       \\<Longrightarrow> is_htype P hT\n 2. \\<And>h' h hT a.\n       \\<lbrakk>(h', a) \\<in> sc_allocate P h hT;\n        P \\<turnstile>sc h \\<surd>; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>\n 3. \\<And>h a al v h' T.\n       \\<lbrakk>sc_heap_write h a al v h'; P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T; P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>", "assume \"sc_typeof_addr h a = \\<lfloor>hT\\<rfloor>\" \"P \\<turnstile>sc h \\<surd>\""], ["proof (state)\nthis:\n  sc_typeof_addr h a = \\<lfloor>hT\\<rfloor>\n  P \\<turnstile>sc h \\<surd>\n\ngoal (3 subgoals):\n 1. \\<And>h a hT.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        P \\<turnstile>sc h \\<surd>\\<rbrakk>\n       \\<Longrightarrow> is_htype P hT\n 2. \\<And>h' h hT a.\n       \\<lbrakk>(h', a) \\<in> sc_allocate P h hT;\n        P \\<turnstile>sc h \\<surd>; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>\n 3. \\<And>h a al v h' T.\n       \\<lbrakk>sc_heap_write h a al v h'; P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T; P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>", "thus \"is_htype P hT\""], ["proof (prove)\nusing this:\n  sc_typeof_addr h a = \\<lfloor>hT\\<rfloor>\n  P \\<turnstile>sc h \\<surd>\n\ngoal (1 subgoal):\n 1. is_htype P hT", "by(auto simp add: sc_typeof_addr_def sc_oconf_def dest!: sc_hconfD split: heapobj.split_asm)"], ["proof (state)\nthis:\n  is_htype P hT\n\ngoal (2 subgoals):\n 1. \\<And>h' h hT a.\n       \\<lbrakk>(h', a) \\<in> sc_allocate P h hT;\n        P \\<turnstile>sc h \\<surd>; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>\n 2. \\<And>h a al v h' T.\n       \\<lbrakk>sc_heap_write h a al v h'; P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T; P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h' h hT a.\n       \\<lbrakk>(h', a) \\<in> sc_allocate P h hT;\n        P \\<turnstile>sc h \\<surd>; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>\n 2. \\<And>h a al v h' T.\n       \\<lbrakk>sc_heap_write h a al v h'; P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T; P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>", "fix h h' hT a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h' h hT a.\n       \\<lbrakk>(h', a) \\<in> sc_allocate P h hT;\n        P \\<turnstile>sc h \\<surd>; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>\n 2. \\<And>h a al v h' T.\n       \\<lbrakk>sc_heap_write h a al v h'; P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T; P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>", "assume \"P \\<turnstile>sc h \\<surd>\" \"(h', a) \\<in> sc_allocate P h hT\" \"is_htype P hT\""], ["proof (state)\nthis:\n  P \\<turnstile>sc h \\<surd>\n  (h', a) \\<in> sc_allocate P h hT\n  is_htype P hT\n\ngoal (2 subgoals):\n 1. \\<And>h' h hT a.\n       \\<lbrakk>(h', a) \\<in> sc_allocate P h hT;\n        P \\<turnstile>sc h \\<surd>; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>\n 2. \\<And>h a al v h' T.\n       \\<lbrakk>sc_heap_write h a al v h'; P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T; P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>", "thus \"P \\<turnstile>sc h' \\<surd>\""], ["proof (prove)\nusing this:\n  P \\<turnstile>sc h \\<surd>\n  (h', a) \\<in> sc_allocate P h hT\n  is_htype P hT\n\ngoal (1 subgoal):\n 1. P \\<turnstile>sc h' \\<surd>", "by(auto simp add: sc_allocate_def dest!: new_Addr_SomeD intro: sc_hconf_new sc_oconf_init split: if_split_asm)"], ["proof (state)\nthis:\n  P \\<turnstile>sc h' \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>h a al v h' T.\n       \\<lbrakk>sc_heap_write h a al v h'; P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T; P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h a al v h' T.\n       \\<lbrakk>sc_heap_write h a al v h'; P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T; P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>", "fix h a al T v h'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h a al v h' T.\n       \\<lbrakk>sc_heap_write h a al v h'; P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T; P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>", "assume \"P \\<turnstile>sc h \\<surd>\"\n    and \"sc.addr_loc_type P h a al T\"\n    and \"P,h \\<turnstile>sc v :\\<le> T\"\n    and \"sc_heap_write h a al v h'\""], ["proof (state)\nthis:\n  P \\<turnstile>sc h \\<surd>\n  sc.addr_loc_type P h a al T\n  P,h \\<turnstile>sc v :\\<le> T\n  sc_heap_write h a al v h'\n\ngoal (1 subgoal):\n 1. \\<And>h a al v h' T.\n       \\<lbrakk>sc_heap_write h a al v h'; P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T; P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>", "thus \"P \\<turnstile>sc h' \\<surd>\""], ["proof (prove)\nusing this:\n  P \\<turnstile>sc h \\<surd>\n  sc.addr_loc_type P h a al T\n  P,h \\<turnstile>sc v :\\<le> T\n  sc_heap_write h a al v h'\n\ngoal (1 subgoal):\n 1. P \\<turnstile>sc h' \\<surd>", "by(cases al)(fastforce elim!: sc.addr_loc_type.cases simp add: sc_typeof_addr_def intro: sc_hconf_upd_obj sc_oconf_fupd sc_hconfD sc_hconf_upd_arr sc_oconf_fupd_arr sc_oconf_fupd_arr_fields)+"], ["proof (state)\nthis:\n  P \\<turnstile>sc h' \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation sc: heap_conf\n  \"addr2thread_id\"\n  \"thread_id2addr\"\n  \"sc_spurious_wakeups\"\n  \"sc_empty\"\n  \"sc_allocate P\"\n  \"sc_typeof_addr\"\n  \"sc_heap_read\"\n  \"sc_heap_write\"\n  \"sc_hconf P\"\n  \"P\"\nfor P"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_conf (\\<lambda>x. x) (\\<lambda>x. x) sc_empty (sc_allocate P)\n     sc_typeof_addr sc_heap_write (sc_hconf P) P", "by(rule sc_heap_conf)"], ["", "lemma sc_heap_progress:\n  \"heap_progress addr2thread_id thread_id2addr sc_empty (sc_allocate P) sc_typeof_addr sc_heap_read sc_heap_write (sc_hconf P) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_progress (\\<lambda>x. x) (\\<lambda>x. x) sc_empty (sc_allocate P)\n     sc_typeof_addr sc_heap_read sc_heap_write (sc_hconf P) P", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h a al T.\n       \\<lbrakk>P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T\n 2. \\<And>h a al T v.\n       \\<lbrakk>P \\<turnstile>sc h \\<surd>; sc.addr_loc_type P h a al T;\n        P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. sc_heap_write h a al v h'", "fix h a al T"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h a al T.\n       \\<lbrakk>P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T\n 2. \\<And>h a al T v.\n       \\<lbrakk>P \\<turnstile>sc h \\<surd>; sc.addr_loc_type P h a al T;\n        P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. sc_heap_write h a al v h'", "assume hconf: \"P \\<turnstile>sc h \\<surd>\"\n    and alt: \"sc.addr_loc_type P h a al T\""], ["proof (state)\nthis:\n  P \\<turnstile>sc h \\<surd>\n  sc.addr_loc_type P h a al T\n\ngoal (2 subgoals):\n 1. \\<And>h a al T.\n       \\<lbrakk>P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T\n 2. \\<And>h a al T v.\n       \\<lbrakk>P \\<turnstile>sc h \\<surd>; sc.addr_loc_type P h a al T;\n        P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. sc_heap_write h a al v h'", "from alt"], ["proof (chain)\npicking this:\n  sc.addr_loc_type P h a al T", "obtain arrobj where arrobj: \"h a = \\<lfloor>arrobj\\<rfloor>\""], ["proof (prove)\nusing this:\n  sc.addr_loc_type P h a al T\n\ngoal (1 subgoal):\n 1. (\\<And>arrobj.\n        h a = \\<lfloor>arrobj\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto elim!: sc.addr_loc_type.cases simp add: sc_typeof_addr_def)"], ["proof (state)\nthis:\n  h a = \\<lfloor>arrobj\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>h a al T.\n       \\<lbrakk>P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T\n 2. \\<And>h a al T v.\n       \\<lbrakk>P \\<turnstile>sc h \\<surd>; sc.addr_loc_type P h a al T;\n        P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. sc_heap_write h a al v h'", "from alt"], ["proof (chain)\npicking this:\n  sc.addr_loc_type P h a al T", "show \"\\<exists>v. sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T\""], ["proof (prove)\nusing this:\n  sc.addr_loc_type P h a al T\n\ngoal (1 subgoal):\n 1. \\<exists>v. sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>U F fm D.\n       \\<lbrakk>al = CField D F; sc_typeof_addr h a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of U has F:T (fm) in D\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T\n 2. \\<And>n' n.\n       \\<lbrakk>al = ACell n;\n        sc_typeof_addr h a = \\<lfloor>Array_type T n'\\<rfloor>;\n        n < n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T", "case (addr_loc_type_field U F fm D)"], ["proof (state)\nthis:\n  al = CField D F\n  sc_typeof_addr h a = \\<lfloor>U\\<rfloor>\n  P \\<turnstile> class_type_of U has F:T (fm) in D\n\ngoal (2 subgoals):\n 1. \\<And>U F fm D.\n       \\<lbrakk>al = CField D F; sc_typeof_addr h a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of U has F:T (fm) in D\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T\n 2. \\<And>n' n.\n       \\<lbrakk>al = ACell n;\n        sc_typeof_addr h a = \\<lfloor>Array_type T n'\\<rfloor>;\n        n < n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T", "note [simp] = \\<open>al = CField D F\\<close>"], ["proof (state)\nthis:\n  al = CField D F\n\ngoal (2 subgoals):\n 1. \\<And>U F fm D.\n       \\<lbrakk>al = CField D F; sc_typeof_addr h a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of U has F:T (fm) in D\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T\n 2. \\<And>n' n.\n       \\<lbrakk>al = ACell n;\n        sc_typeof_addr h a = \\<lfloor>Array_type T n'\\<rfloor>;\n        n < n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v. sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "proof(cases \"arrobj\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       arrobj = Obj x11 x12 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T\n 2. \\<And>x21 x22 x23.\n       arrobj = Arr x21 x22 x23 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "case (Obj C' fs)"], ["proof (state)\nthis:\n  arrobj = Obj C' fs\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       arrobj = Obj x11 x12 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T\n 2. \\<And>x21 x22 x23.\n       arrobj = Arr x21 x22 x23 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "with \\<open>sc_typeof_addr h a = \\<lfloor>U\\<rfloor>\\<close> arrobj"], ["proof (chain)\npicking this:\n  sc_typeof_addr h a = \\<lfloor>U\\<rfloor>\n  h a = \\<lfloor>arrobj\\<rfloor>\n  arrobj = Obj C' fs", "have [simp]: \"C' = class_type_of U\""], ["proof (prove)\nusing this:\n  sc_typeof_addr h a = \\<lfloor>U\\<rfloor>\n  h a = \\<lfloor>arrobj\\<rfloor>\n  arrobj = Obj C' fs\n\ngoal (1 subgoal):\n 1. C' = class_type_of U", "by(auto simp add: sc_typeof_addr_def)"], ["proof (state)\nthis:\n  C' = class_type_of U\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       arrobj = Obj x11 x12 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T\n 2. \\<And>x21 x22 x23.\n       arrobj = Arr x21 x22 x23 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "from hconf arrobj Obj"], ["proof (chain)\npicking this:\n  P \\<turnstile>sc h \\<surd>\n  h a = \\<lfloor>arrobj\\<rfloor>\n  arrobj = Obj C' fs", "have \"P,h \\<turnstile>sc Obj (class_type_of U) fs \\<surd>\""], ["proof (prove)\nusing this:\n  P \\<turnstile>sc h \\<surd>\n  h a = \\<lfloor>arrobj\\<rfloor>\n  arrobj = Obj C' fs\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc Obj (class_type_of U) fs \\<surd>", "by(auto dest: sc_hconfD)"], ["proof (state)\nthis:\n  P,h \\<turnstile>sc Obj (class_type_of U) fs \\<surd>\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       arrobj = Obj x11 x12 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T\n 2. \\<And>x21 x22 x23.\n       arrobj = Arr x21 x22 x23 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "with \\<open>P \\<turnstile> class_type_of U has F:T (fm) in D\\<close>"], ["proof (chain)\npicking this:\n  P \\<turnstile> class_type_of U has F:T (fm) in D\n  P,h \\<turnstile>sc Obj (class_type_of U) fs \\<surd>", "obtain v \n        where \"fs (F, D) = \\<lfloor>v\\<rfloor>\" \"P,h \\<turnstile>sc v :\\<le> T\""], ["proof (prove)\nusing this:\n  P \\<turnstile> class_type_of U has F:T (fm) in D\n  P,h \\<turnstile>sc Obj (class_type_of U) fs \\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>fs (F, D) = \\<lfloor>v\\<rfloor>;\n         P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp add: sc_fconf_def)"], ["proof (state)\nthis:\n  fs (F, D) = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile>sc v :\\<le> T\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       arrobj = Obj x11 x12 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T\n 2. \\<And>x21 x22 x23.\n       arrobj = Arr x21 x22 x23 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "thus ?thesis"], ["proof (prove)\nusing this:\n  fs (F, D) = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile>sc v :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<exists>v. sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "using Obj arrobj"], ["proof (prove)\nusing this:\n  fs (F, D) = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile>sc v :\\<le> T\n  arrobj = Obj C' fs\n  h a = \\<lfloor>arrobj\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>v. sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "by(auto intro: sc_heap_read.intros)"], ["proof (state)\nthis:\n  \\<exists>v. sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       arrobj = Arr x21 x22 x23 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       arrobj = Arr x21 x22 x23 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "case (Arr T' f el)"], ["proof (state)\nthis:\n  arrobj = Arr T' f el\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       arrobj = Arr x21 x22 x23 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "with \\<open>sc_typeof_addr h a = \\<lfloor>U\\<rfloor>\\<close> arrobj"], ["proof (chain)\npicking this:\n  sc_typeof_addr h a = \\<lfloor>U\\<rfloor>\n  h a = \\<lfloor>arrobj\\<rfloor>\n  arrobj = Arr T' f el", "have [simp]: \"U = Array_type T' (length el)\""], ["proof (prove)\nusing this:\n  sc_typeof_addr h a = \\<lfloor>U\\<rfloor>\n  h a = \\<lfloor>arrobj\\<rfloor>\n  arrobj = Arr T' f el\n\ngoal (1 subgoal):\n 1. U = Array_type T' (length el)", "by(auto simp add: sc_typeof_addr_def)"], ["proof (state)\nthis:\n  U = Array_type T' (length el)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       arrobj = Arr x21 x22 x23 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "from hconf arrobj Arr"], ["proof (chain)\npicking this:\n  P \\<turnstile>sc h \\<surd>\n  h a = \\<lfloor>arrobj\\<rfloor>\n  arrobj = Arr T' f el", "have \"P,h \\<turnstile>sc Arr T' f el \\<surd>\""], ["proof (prove)\nusing this:\n  P \\<turnstile>sc h \\<surd>\n  h a = \\<lfloor>arrobj\\<rfloor>\n  arrobj = Arr T' f el\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc Arr T' f el \\<surd>", "by(auto dest: sc_hconfD)"], ["proof (state)\nthis:\n  P,h \\<turnstile>sc Arr T' f el \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       arrobj = Arr x21 x22 x23 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "from \\<open>P \\<turnstile> class_type_of U has F:T (fm) in D\\<close>"], ["proof (chain)\npicking this:\n  P \\<turnstile> class_type_of U has F:T (fm) in D", "have [simp]: \"D = Object\""], ["proof (prove)\nusing this:\n  P \\<turnstile> class_type_of U has F:T (fm) in D\n\ngoal (1 subgoal):\n 1. D = Object", "by(auto dest: has_field_decl_above)"], ["proof (state)\nthis:\n  D = Object\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       arrobj = Arr x21 x22 x23 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "with \\<open>P,h \\<turnstile>sc Arr T' f el \\<surd>\\<close> \\<open>P \\<turnstile> class_type_of U has F:T (fm) in D\\<close>"], ["proof (chain)\npicking this:\n  P,h \\<turnstile>sc Arr T' f el \\<surd>\n  P \\<turnstile> class_type_of U has F:T (fm) in D\n  D = Object", "obtain v where \"f (F, Object) = \\<lfloor>v\\<rfloor>\" \"P,h \\<turnstile>sc v :\\<le> T\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile>sc Arr T' f el \\<surd>\n  P \\<turnstile> class_type_of U has F:T (fm) in D\n  D = Object\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>f (F, Object) = \\<lfloor>v\\<rfloor>;\n         P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp add: sc_fconf_def)"], ["proof (state)\nthis:\n  f (F, Object) = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile>sc v :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       arrobj = Arr x21 x22 x23 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "thus ?thesis"], ["proof (prove)\nusing this:\n  f (F, Object) = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile>sc v :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<exists>v. sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "using Arr arrobj"], ["proof (prove)\nusing this:\n  f (F, Object) = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile>sc v :\\<le> T\n  arrobj = Arr T' f el\n  h a = \\<lfloor>arrobj\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>v. sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "by(auto intro: sc_heap_read.intros)"], ["proof (state)\nthis:\n  \\<exists>v. sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>v. sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>n' n.\n       \\<lbrakk>al = ACell n;\n        sc_typeof_addr h a = \\<lfloor>Array_type T n'\\<rfloor>;\n        n < n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n' n.\n       \\<lbrakk>al = ACell n;\n        sc_typeof_addr h a = \\<lfloor>Array_type T n'\\<rfloor>;\n        n < n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T", "case (addr_loc_type_cell n' n)"], ["proof (state)\nthis:\n  al = ACell n\n  sc_typeof_addr h a = \\<lfloor>Array_type T n'\\<rfloor>\n  n < n'\n\ngoal (1 subgoal):\n 1. \\<And>n' n.\n       \\<lbrakk>al = ACell n;\n        sc_typeof_addr h a = \\<lfloor>Array_type T n'\\<rfloor>;\n        n < n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T", "with arrobj"], ["proof (chain)\npicking this:\n  h a = \\<lfloor>arrobj\\<rfloor>\n  al = ACell n\n  sc_typeof_addr h a = \\<lfloor>Array_type T n'\\<rfloor>\n  n < n'", "obtain f el\n      where [simp]: \"arrobj = Arr T f el\""], ["proof (prove)\nusing this:\n  h a = \\<lfloor>arrobj\\<rfloor>\n  al = ACell n\n  sc_typeof_addr h a = \\<lfloor>Array_type T n'\\<rfloor>\n  n < n'\n\ngoal (1 subgoal):\n 1. (\\<And>f el.\n        arrobj = Arr T f el \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases arrobj)(auto simp add: sc_typeof_addr_def)"], ["proof (state)\nthis:\n  arrobj = Arr T f el\n\ngoal (1 subgoal):\n 1. \\<And>n' n.\n       \\<lbrakk>al = ACell n;\n        sc_typeof_addr h a = \\<lfloor>Array_type T n'\\<rfloor>;\n        n < n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T", "from addr_loc_type_cell arrobj"], ["proof (chain)\npicking this:\n  al = ACell n\n  sc_typeof_addr h a = \\<lfloor>Array_type T n'\\<rfloor>\n  n < n'\n  h a = \\<lfloor>arrobj\\<rfloor>", "have [simp]: \"al = ACell n\" \"n < length el\""], ["proof (prove)\nusing this:\n  al = ACell n\n  sc_typeof_addr h a = \\<lfloor>Array_type T n'\\<rfloor>\n  n < n'\n  h a = \\<lfloor>arrobj\\<rfloor>\n\ngoal (1 subgoal):\n 1. al = ACell n &&& n < length el", "by(auto simp add: sc_typeof_addr_def)"], ["proof (state)\nthis:\n  al = ACell n\n  n < length el\n\ngoal (1 subgoal):\n 1. \\<And>n' n.\n       \\<lbrakk>al = ACell n;\n        sc_typeof_addr h a = \\<lfloor>Array_type T n'\\<rfloor>;\n        n < n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T", "from hconf arrobj"], ["proof (chain)\npicking this:\n  P \\<turnstile>sc h \\<surd>\n  h a = \\<lfloor>arrobj\\<rfloor>", "have \"P,h \\<turnstile>sc Arr T f el \\<surd>\""], ["proof (prove)\nusing this:\n  P \\<turnstile>sc h \\<surd>\n  h a = \\<lfloor>arrobj\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc Arr T f el \\<surd>", "by(auto dest: sc_hconfD)"], ["proof (state)\nthis:\n  P,h \\<turnstile>sc Arr T f el \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>n' n.\n       \\<lbrakk>al = ACell n;\n        sc_typeof_addr h a = \\<lfloor>Array_type T n'\\<rfloor>;\n        n < n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T", "hence \"P,h \\<turnstile>sc el ! n :\\<le> T\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile>sc Arr T f el \\<surd>\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc el ! n :\\<le> T", "by(fastforce)"], ["proof (state)\nthis:\n  P,h \\<turnstile>sc el ! n :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>n' n.\n       \\<lbrakk>al = ACell n;\n        sc_typeof_addr h a = \\<lfloor>Array_type T n'\\<rfloor>;\n        n < n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T", "thus ?thesis"], ["proof (prove)\nusing this:\n  P,h \\<turnstile>sc el ! n :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<exists>v. sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "using arrobj"], ["proof (prove)\nusing this:\n  P,h \\<turnstile>sc el ! n :\\<le> T\n  h a = \\<lfloor>arrobj\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>v. sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "by(fastforce intro: sc_heap_read.intros)"], ["proof (state)\nthis:\n  \\<exists>v. sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>v. sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>h a al T v.\n       \\<lbrakk>P \\<turnstile>sc h \\<surd>; sc.addr_loc_type P h a al T;\n        P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. sc_heap_write h a al v h'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h a al T v.\n       \\<lbrakk>P \\<turnstile>sc h \\<surd>; sc.addr_loc_type P h a al T;\n        P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. sc_heap_write h a al v h'", "fix h a al T v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h a al T v.\n       \\<lbrakk>P \\<turnstile>sc h \\<surd>; sc.addr_loc_type P h a al T;\n        P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. sc_heap_write h a al v h'", "assume alt: \"sc.addr_loc_type P h a al T\""], ["proof (state)\nthis:\n  sc.addr_loc_type P h a al T\n\ngoal (1 subgoal):\n 1. \\<And>h a al T v.\n       \\<lbrakk>P \\<turnstile>sc h \\<surd>; sc.addr_loc_type P h a al T;\n        P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. sc_heap_write h a al v h'", "from alt"], ["proof (chain)\npicking this:\n  sc.addr_loc_type P h a al T", "obtain arrobj where arrobj: \"h a = \\<lfloor>arrobj\\<rfloor>\""], ["proof (prove)\nusing this:\n  sc.addr_loc_type P h a al T\n\ngoal (1 subgoal):\n 1. (\\<And>arrobj.\n        h a = \\<lfloor>arrobj\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto elim!: sc.addr_loc_type.cases simp add: sc_typeof_addr_def)"], ["proof (state)\nthis:\n  h a = \\<lfloor>arrobj\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>h a al T v.\n       \\<lbrakk>P \\<turnstile>sc h \\<surd>; sc.addr_loc_type P h a al T;\n        P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. sc_heap_write h a al v h'", "thus \"\\<exists>h'. sc_heap_write h a al v h'\""], ["proof (prove)\nusing this:\n  h a = \\<lfloor>arrobj\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>h'. sc_heap_write h a al v h'", "using alt"], ["proof (prove)\nusing this:\n  h a = \\<lfloor>arrobj\\<rfloor>\n  sc.addr_loc_type P h a al T\n\ngoal (1 subgoal):\n 1. \\<exists>h'. sc_heap_write h a al v h'", "by(cases arrobj)(fastforce intro: sc_heap_write.intros elim!: sc.addr_loc_type.cases simp add: sc_typeof_addr_def dest: has_field_decl_above)+"], ["proof (state)\nthis:\n  \\<exists>h'. sc_heap_write h a al v h'\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation sc: heap_progress\n  \"addr2thread_id\"\n  \"thread_id2addr\"\n  \"sc_spurious_wakeups\"\n  \"sc_empty\"\n  \"sc_allocate P\"\n  \"sc_typeof_addr\"\n  \"sc_heap_read\"\n  \"sc_heap_write\"\n  \"sc_hconf P\"\n  \"P\"\nfor P"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_progress (\\<lambda>x. x) (\\<lambda>x. x) sc_empty (sc_allocate P)\n     sc_typeof_addr sc_heap_read sc_heap_write (sc_hconf P) P", "by(rule sc_heap_progress)"], ["", "lemma sc_heap_conf_read:\n  \"heap_conf_read addr2thread_id thread_id2addr sc_empty (sc_allocate P) sc_typeof_addr sc_heap_read sc_heap_write (sc_hconf P) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_conf_read (\\<lambda>x. x) (\\<lambda>x. x) sc_empty (sc_allocate P)\n     sc_typeof_addr sc_heap_read sc_heap_write (sc_hconf P) P", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h a al v T.\n       \\<lbrakk>sc_heap_read h a al v; sc.addr_loc_type P h a al T;\n        P \\<turnstile>sc h \\<surd>\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile>sc v :\\<le> T", "fix h a al v T"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h a al v T.\n       \\<lbrakk>sc_heap_read h a al v; sc.addr_loc_type P h a al T;\n        P \\<turnstile>sc h \\<surd>\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile>sc v :\\<le> T", "assume read: \"sc_heap_read h a al v\"\n    and alt: \"sc.addr_loc_type P h a al T\"\n    and hconf: \"P \\<turnstile>sc h \\<surd>\""], ["proof (state)\nthis:\n  sc_heap_read h a al v\n  sc.addr_loc_type P h a al T\n  P \\<turnstile>sc h \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>h a al v T.\n       \\<lbrakk>sc_heap_read h a al v; sc.addr_loc_type P h a al T;\n        P \\<turnstile>sc h \\<surd>\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile>sc v :\\<le> T", "thus \"P,h \\<turnstile>sc v :\\<le> T\""], ["proof (prove)\nusing this:\n  sc_heap_read h a al v\n  sc.addr_loc_type P h a al T\n  P \\<turnstile>sc h \\<surd>\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc v :\\<le> T", "by(auto elim!: sc_heap_read.cases sc.addr_loc_type.cases simp add: sc_typeof_addr_def)(fastforce dest!: sc_hconfD simp add: sc_fconf_def)+"], ["proof (state)\nthis:\n  P,h \\<turnstile>sc v :\\<le> T\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation sc: heap_conf_read\n  \"addr2thread_id\"\n  \"thread_id2addr\"\n  \"sc_spurious_wakeups\"\n  \"sc_empty\"\n  \"sc_allocate P\"\n  \"sc_typeof_addr\"\n  \"sc_heap_read\"\n  \"sc_heap_write\"\n  \"sc_hconf P\"\n  \"P\"\nfor P"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_conf_read (\\<lambda>x. x) (\\<lambda>x. x) sc_empty (sc_allocate P)\n     sc_typeof_addr sc_heap_read sc_heap_write (sc_hconf P) P", "by(rule sc_heap_conf_read)"], ["", "abbreviation sc_deterministic_heap_ops :: \"'m prog \\<Rightarrow> bool\"\nwhere \"sc_deterministic_heap_ops \\<equiv> sc.deterministic_heap_ops TYPE('m)\""], ["", "lemma sc_deterministic_heap_ops: \"\\<not> sc_spurious_wakeups \\<Longrightarrow> sc_deterministic_heap_ops P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> sc_spurious_wakeups \\<Longrightarrow> sc_deterministic_heap_ops P", "by(rule sc.deterministic_heap_opsI)(auto elim: sc_heap_read.cases sc_heap_write.cases simp add: sc_allocate_def)"], ["", "subsection \\<open>Code generation\\<close>"], ["", "code_pred \n  (modes: i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> bool, i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> bool)\n  sc_heap_read"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "code_pred \n  (modes: i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> bool, i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> bool)\n  sc_heap_write"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma eval_sc_heap_read_i_i_i_o:\n  \"Predicate.eval (sc_heap_read_i_i_i_o h ad al) = sc_heap_read h ad al\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred.eval (sc_heap_read_i_i_i_o h ad al) = sc_heap_read h ad al", "by(auto elim: sc_heap_read_i_i_i_oE intro: sc_heap_read_i_i_i_oI intro!: ext)"], ["", "lemma eval_sc_heap_write_i_i_i_i_o:\n  \"Predicate.eval (sc_heap_write_i_i_i_i_o h ad al v) = sc_heap_write h ad al v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred.eval (sc_heap_write_i_i_i_i_o h ad al v) = sc_heap_write h ad al v", "by(auto elim: sc_heap_write_i_i_i_i_oE intro: sc_heap_write_i_i_i_i_oI intro!: ext)"], ["", "end"]]}