{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Execute/JVMExec_Execute.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma exec_instr_code [code]:\n  \"exec_instr (Load n) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs = \n   {(\\<epsilon>, (None, h, ((loc ! n) # stk, loc, C\\<^sub>0, M\\<^sub>0, pc+1)#frs))}\"\n  \"exec_instr (Store n) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs = \n   {(\\<epsilon>, (None, h, (tl stk, loc[n:=hd stk], C\\<^sub>0, M\\<^sub>0, pc+1)#frs))}\"\n  \"exec_instr (Push v) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs = \n   {(\\<epsilon>, (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, pc+1)#frs))}\"\n  \"exec_instr (New C) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs = \n   (let HA = allocate h (Class_type C) in\n    if HA = {} then {(\\<epsilon>, \\<lfloor>execute.addr_of_sys_xcpt OutOfMemory\\<rfloor>, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc) # frs)}\n    else do { (h', a) \\<leftarrow> HA; {(\\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>, None, h', (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, pc + 1)#frs)} })\"\n  \"exec_instr (NewArray T) P t h stk loc C0 M0 pc frs =\n   (let si = the_Intg (hd stk);\n        i = nat (sint si)\n    in if si <s 0\n       then {(\\<epsilon>, \\<lfloor>execute.addr_of_sys_xcpt NegativeArraySize\\<rfloor>, h, (stk, loc, C0, M0, pc) # frs)}\n       else let HA = allocate h (Array_type T i) in\n         if HA = {} then {(\\<epsilon>, \\<lfloor>execute.addr_of_sys_xcpt OutOfMemory\\<rfloor>, h, (stk, loc, C0, M0, pc) # frs)}\n         else do { (h', a) \\<leftarrow> HA; {(\\<lbrace>NewHeapElem a (Array_type T i)\\<rbrace>, None, h', (Addr a # tl stk, loc, C0, M0, pc + 1) # frs)}})\"\n  \"exec_instr ALoad P t h stk loc C0 M0 pc frs =\n   (let va = hd (tl stk)\n    in (if va = Null then {(\\<epsilon>, \\<lfloor>execute.addr_of_sys_xcpt NullPointer\\<rfloor>, h, (stk, loc, C0, M0, pc) # frs)}\n        else \n          let i = the_Intg (hd stk);\n              a = the_Addr va;\n              len = alen_of_htype (the (typeof_addr h a))\n          in if i <s 0 \\<or> int len \\<le> sint i then\n               {(\\<epsilon>, \\<lfloor>execute.addr_of_sys_xcpt ArrayIndexOutOfBounds\\<rfloor>, h, (stk, loc, C0, M0, pc) # frs)}\n             else do {\n                 v \\<leftarrow> heap_read h a (ACell (nat (sint i)));\n                 {(\\<lbrace>ReadMem a (ACell (nat (sint i))) v\\<rbrace>, None, h, (v # tl (tl stk), loc, C0, M0, pc + 1) # frs)}\n               }))\"\n  \"exec_instr AStore P t h stk loc C0 M0 pc frs =\n  (let ve = hd stk;\n       vi = hd (tl stk);\n       va = hd (tl (tl stk))\n   in (if va = Null then {(\\<epsilon>, \\<lfloor>execute.addr_of_sys_xcpt NullPointer\\<rfloor>, h, (stk, loc, C0, M0, pc) # frs)}\n       else (let i = the_Intg vi;\n                 idx = nat (sint i);\n                 a = the_Addr va;\n                 hT = the (typeof_addr h a);\n                 T = ty_of_htype hT;\n                 len = alen_of_htype hT;\n                 U = the (execute.typeof_h h ve)\n             in (if i <s 0 \\<or> int len \\<le> sint i then\n                      {(\\<epsilon>, \\<lfloor>execute.addr_of_sys_xcpt ArrayIndexOutOfBounds\\<rfloor>, h, (stk, loc, C0, M0, pc) # frs)}\n                 else if P \\<turnstile> U \\<le> the_Array T then \n                      do {\n                         h' \\<leftarrow> heap_write h a (ACell idx) ve;\n                         {(\\<lbrace>WriteMem a (ACell idx) ve\\<rbrace>, None, h', (tl (tl (tl stk)), loc, C0, M0, pc+1) # frs)}\n                      }\n                 else {(\\<epsilon>, (\\<lfloor>execute.addr_of_sys_xcpt ArrayStore\\<rfloor>, h, (stk, loc, C0, M0, pc) # frs))}))))\"\n  \"exec_instr ALength P t h stk loc C0 M0 pc frs =\n   {(\\<epsilon>, (let va = hd stk\n         in if va = Null\n            then (\\<lfloor>execute.addr_of_sys_xcpt NullPointer\\<rfloor>, h, (stk, loc, C0, M0, pc) # frs)\n            else (None, h, (Intg (word_of_int (int (alen_of_htype (the (typeof_addr h (the_Addr va)))))) # tl stk, loc, C0, M0, pc+1) # frs)))}\"\n  \"exec_instr (Getfield F C) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs = \n   (let v = hd stk\n    in if v = Null then {(\\<epsilon>, \\<lfloor>execute.addr_of_sys_xcpt NullPointer\\<rfloor>, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc) # frs)}\n       else let a = the_Addr v\n            in do {\n               v' \\<leftarrow> heap_read h a (CField C F);\n               {(\\<lbrace>ReadMem a (CField C F) v'\\<rbrace>, None, h, (v' # (tl stk), loc, C\\<^sub>0, M\\<^sub>0, pc + 1) # frs)}\n            })\"\n  \"exec_instr (Putfield F C) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs = \n  (let v = hd stk;\n       r = hd (tl stk)\n   in if r = Null then {(\\<epsilon>, \\<lfloor>execute.addr_of_sys_xcpt NullPointer\\<rfloor>, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc) # frs)}\n      else let a = the_Addr r\n           in do {\n                h' \\<leftarrow> heap_write h a (CField C F) v;\n                {(\\<lbrace>WriteMem a (CField C F) v\\<rbrace>, None, h', (tl (tl stk), loc, C\\<^sub>0, M\\<^sub>0, pc + 1) # frs)}\n              })\"\n \"exec_instr (Checkcast T) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n  {(\\<epsilon>, let U = the (typeof\\<^bsub>h\\<^esub> (hd stk))\n       in if P \\<turnstile> U \\<le> T then (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc + 1) # frs)\n          else (\\<lfloor>execute.addr_of_sys_xcpt ClassCast\\<rfloor>, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc) # frs))}\"\n  \"exec_instr (Instanceof T) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n   {(\\<epsilon>, None, h, (Bool (hd stk \\<noteq> Null \\<and> P \\<turnstile> the (typeof\\<^bsub>h\\<^esub> (hd stk)) \\<le> T) # tl stk, loc, C\\<^sub>0, M\\<^sub>0, pc + 1) # frs)}\"\n  \"exec_instr (Invoke M n) P t h stk loc C0 M0 pc frs =\n   (let r = stk ! n\n    in (if r = Null then {(\\<epsilon>, \\<lfloor>execute.addr_of_sys_xcpt NullPointer\\<rfloor>, h, (stk, loc, C0, M0, pc) # frs)}\n        else (let ps = rev (take n stk);\n                  a = the_Addr r;\n                  T = the (typeof_addr h a);\n                  (D,M',Ts,meth)= method P (class_type_of T) M\n         in case meth of \n               Native \\<Rightarrow>\n                      do {\n                        (ta, va, h') \\<leftarrow> red_external_aggr P t a M ps h;\n                        {(extTA2JVM P ta, extRet2JVM n h' stk loc C0 M0 pc frs va)}\n                      }\n            | \\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> \\<Rightarrow>\n              let f' = ([],[r]@ps@(replicate mxl\\<^sub>0 undefined_value),D,M,0)\n              in {(\\<epsilon>, None, h, f' # (stk, loc, C0, M0, pc) # frs)})))\"\n  \"exec_instr Return P t h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 M\\<^sub>0 pc frs =\n   {(\\<epsilon>, (if frs=[] then (None, h, []) \n         else \n           let v = hd stk\\<^sub>0; \n               (stk,loc,C,m,pc) = hd frs;\n                n = length (fst (snd (method P C\\<^sub>0 M\\<^sub>0)))\n           in (None, h, (v#(drop (n+1) stk),loc,C,m,pc+1)#tl frs)))}\"\n  \"exec_instr Pop P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs = {(\\<epsilon>, (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, pc+1)#frs))}\"\n  \"exec_instr Dup P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs = {(\\<epsilon>, (None, h, (hd stk # stk, loc, C\\<^sub>0, M\\<^sub>0, pc+1)#frs))}\"\n  \"exec_instr Swap P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs = {(\\<epsilon>, (None, h, (hd (tl stk) # hd stk # tl (tl stk), loc, C\\<^sub>0, M\\<^sub>0, pc+1)#frs))}\"\n  \"exec_instr (BinOpInstr bop) P t h stk loc C0 M0 pc frs =\n   {(\\<epsilon>, \n     case the (execute.binop bop (hd (tl stk)) (hd stk)) of\n       Inl v \\<Rightarrow> (None, h, (v # tl (tl stk), loc, C0, M0, pc + 1) # frs)\n     | Inr a \\<Rightarrow> (Some a, h, (stk, loc, C0, M0, pc) # frs))}\"\n  \"exec_instr (IfFalse i) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n   {(\\<epsilon>, (let pc' = if hd stk = Bool False then nat(int pc+i) else pc+1\n         in (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, pc')#frs)))}\"\n  \"exec_instr (Goto i) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs = {(\\<epsilon>, (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, nat(int pc+i))#frs))}\"\n  \"exec_instr ThrowExc P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n   {(\\<epsilon>, (let xp' = if hd stk = Null then \\<lfloor>execute.addr_of_sys_xcpt NullPointer\\<rfloor> else \\<lfloor>the_Addr(hd stk)\\<rfloor>\n         in (xp', h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc)#frs)))}\"\n  \"exec_instr MEnter P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n   {(let v = hd stk\n     in if v = Null\n        then (\\<epsilon>, \\<lfloor>execute.addr_of_sys_xcpt NullPointer\\<rfloor>, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc) # frs)\n        else (\\<lbrace>Lock\\<rightarrow>the_Addr v, SyncLock (the_Addr v)\\<rbrace>, None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, pc + 1) # frs))}\"\n  \"exec_instr MExit P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n   (let v = hd stk\n    in if v = Null\n       then {(\\<epsilon>, \\<lfloor>execute.addr_of_sys_xcpt NullPointer\\<rfloor>, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc) # frs)}\n       else {(\\<lbrace>Unlock\\<rightarrow>the_Addr v, SyncUnlock (the_Addr v)\\<rbrace>, None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, pc + 1) # frs),\n             (\\<lbrace>UnlockFail\\<rightarrow>the_Addr v\\<rbrace>, \\<lfloor>execute.addr_of_sys_xcpt IllegalMonitorState\\<rfloor>, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc) # frs)})\"", "lemma exec_code:\n  \"exec P t (xcp, h, []) = {}\"\n  \"exec P t (None, h, (stk, loc, C, M, pc) # frs) = exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs\"\n  \"exec P t (\\<lfloor>a\\<rfloor>, h, fr # frs) = {(\\<epsilon>, execute.exception_step P a h fr frs)}\"", "lemma exec_1I: \"execute.exec_1 P t \\<sigma> ta \\<sigma>' \\<Longrightarrow> Predicate.eval (exec_1 P t \\<sigma>) (ta, \\<sigma>')\"", "lemma exec_1E:\n  assumes \"Predicate.eval (exec_1 P t \\<sigma>) (ta, \\<sigma>')\"\n  obtains \"execute.exec_1 P t \\<sigma> ta \\<sigma>'\"", "lemma exec_1_eq [simp]:\n  \"Predicate.eval (exec_1 P t \\<sigma>) (ta, \\<sigma>') \\<longleftrightarrow> execute.exec_1 P t \\<sigma> ta \\<sigma>'\"", "lemma exec_1_eq':\n  \"Predicate.eval (exec_1 P t \\<sigma>) = (\\<lambda>(ta, \\<sigma>'). execute.exec_1 P t \\<sigma> ta \\<sigma>')\"", "lemmas [code] = \n  JVM_heap_execute.exec_instr_code\n  JVM_heap_base.exception_step.simps\n  JVM_heap_execute.exec_code\n  JVM_heap_execute.exec_1_def"], "translations": [["", "lemma exec_instr_code [code]:\n  \"exec_instr (Load n) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs = \n   {(\\<epsilon>, (None, h, ((loc ! n) # stk, loc, C\\<^sub>0, M\\<^sub>0, pc+1)#frs))}\"\n  \"exec_instr (Store n) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs = \n   {(\\<epsilon>, (None, h, (tl stk, loc[n:=hd stk], C\\<^sub>0, M\\<^sub>0, pc+1)#frs))}\"\n  \"exec_instr (Push v) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs = \n   {(\\<epsilon>, (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, pc+1)#frs))}\"\n  \"exec_instr (New C) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs = \n   (let HA = allocate h (Class_type C) in\n    if HA = {} then {(\\<epsilon>, \\<lfloor>execute.addr_of_sys_xcpt OutOfMemory\\<rfloor>, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc) # frs)}\n    else do { (h', a) \\<leftarrow> HA; {(\\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>, None, h', (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, pc + 1)#frs)} })\"\n  \"exec_instr (NewArray T) P t h stk loc C0 M0 pc frs =\n   (let si = the_Intg (hd stk);\n        i = nat (sint si)\n    in if si <s 0\n       then {(\\<epsilon>, \\<lfloor>execute.addr_of_sys_xcpt NegativeArraySize\\<rfloor>, h, (stk, loc, C0, M0, pc) # frs)}\n       else let HA = allocate h (Array_type T i) in\n         if HA = {} then {(\\<epsilon>, \\<lfloor>execute.addr_of_sys_xcpt OutOfMemory\\<rfloor>, h, (stk, loc, C0, M0, pc) # frs)}\n         else do { (h', a) \\<leftarrow> HA; {(\\<lbrace>NewHeapElem a (Array_type T i)\\<rbrace>, None, h', (Addr a # tl stk, loc, C0, M0, pc + 1) # frs)}})\"\n  \"exec_instr ALoad P t h stk loc C0 M0 pc frs =\n   (let va = hd (tl stk)\n    in (if va = Null then {(\\<epsilon>, \\<lfloor>execute.addr_of_sys_xcpt NullPointer\\<rfloor>, h, (stk, loc, C0, M0, pc) # frs)}\n        else \n          let i = the_Intg (hd stk);\n              a = the_Addr va;\n              len = alen_of_htype (the (typeof_addr h a))\n          in if i <s 0 \\<or> int len \\<le> sint i then\n               {(\\<epsilon>, \\<lfloor>execute.addr_of_sys_xcpt ArrayIndexOutOfBounds\\<rfloor>, h, (stk, loc, C0, M0, pc) # frs)}\n             else do {\n                 v \\<leftarrow> heap_read h a (ACell (nat (sint i)));\n                 {(\\<lbrace>ReadMem a (ACell (nat (sint i))) v\\<rbrace>, None, h, (v # tl (tl stk), loc, C0, M0, pc + 1) # frs)}\n               }))\"\n  \"exec_instr AStore P t h stk loc C0 M0 pc frs =\n  (let ve = hd stk;\n       vi = hd (tl stk);\n       va = hd (tl (tl stk))\n   in (if va = Null then {(\\<epsilon>, \\<lfloor>execute.addr_of_sys_xcpt NullPointer\\<rfloor>, h, (stk, loc, C0, M0, pc) # frs)}\n       else (let i = the_Intg vi;\n                 idx = nat (sint i);\n                 a = the_Addr va;\n                 hT = the (typeof_addr h a);\n                 T = ty_of_htype hT;\n                 len = alen_of_htype hT;\n                 U = the (execute.typeof_h h ve)\n             in (if i <s 0 \\<or> int len \\<le> sint i then\n                      {(\\<epsilon>, \\<lfloor>execute.addr_of_sys_xcpt ArrayIndexOutOfBounds\\<rfloor>, h, (stk, loc, C0, M0, pc) # frs)}\n                 else if P \\<turnstile> U \\<le> the_Array T then \n                      do {\n                         h' \\<leftarrow> heap_write h a (ACell idx) ve;\n                         {(\\<lbrace>WriteMem a (ACell idx) ve\\<rbrace>, None, h', (tl (tl (tl stk)), loc, C0, M0, pc+1) # frs)}\n                      }\n                 else {(\\<epsilon>, (\\<lfloor>execute.addr_of_sys_xcpt ArrayStore\\<rfloor>, h, (stk, loc, C0, M0, pc) # frs))}))))\"\n  \"exec_instr ALength P t h stk loc C0 M0 pc frs =\n   {(\\<epsilon>, (let va = hd stk\n         in if va = Null\n            then (\\<lfloor>execute.addr_of_sys_xcpt NullPointer\\<rfloor>, h, (stk, loc, C0, M0, pc) # frs)\n            else (None, h, (Intg (word_of_int (int (alen_of_htype (the (typeof_addr h (the_Addr va)))))) # tl stk, loc, C0, M0, pc+1) # frs)))}\"\n  \"exec_instr (Getfield F C) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs = \n   (let v = hd stk\n    in if v = Null then {(\\<epsilon>, \\<lfloor>execute.addr_of_sys_xcpt NullPointer\\<rfloor>, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc) # frs)}\n       else let a = the_Addr v\n            in do {\n               v' \\<leftarrow> heap_read h a (CField C F);\n               {(\\<lbrace>ReadMem a (CField C F) v'\\<rbrace>, None, h, (v' # (tl stk), loc, C\\<^sub>0, M\\<^sub>0, pc + 1) # frs)}\n            })\"\n  \"exec_instr (Putfield F C) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs = \n  (let v = hd stk;\n       r = hd (tl stk)\n   in if r = Null then {(\\<epsilon>, \\<lfloor>execute.addr_of_sys_xcpt NullPointer\\<rfloor>, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc) # frs)}\n      else let a = the_Addr r\n           in do {\n                h' \\<leftarrow> heap_write h a (CField C F) v;\n                {(\\<lbrace>WriteMem a (CField C F) v\\<rbrace>, None, h', (tl (tl stk), loc, C\\<^sub>0, M\\<^sub>0, pc + 1) # frs)}\n              })\"\n \"exec_instr (Checkcast T) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n  {(\\<epsilon>, let U = the (typeof\\<^bsub>h\\<^esub> (hd stk))\n       in if P \\<turnstile> U \\<le> T then (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc + 1) # frs)\n          else (\\<lfloor>execute.addr_of_sys_xcpt ClassCast\\<rfloor>, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc) # frs))}\"\n  \"exec_instr (Instanceof T) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n   {(\\<epsilon>, None, h, (Bool (hd stk \\<noteq> Null \\<and> P \\<turnstile> the (typeof\\<^bsub>h\\<^esub> (hd stk)) \\<le> T) # tl stk, loc, C\\<^sub>0, M\\<^sub>0, pc + 1) # frs)}\"\n  \"exec_instr (Invoke M n) P t h stk loc C0 M0 pc frs =\n   (let r = stk ! n\n    in (if r = Null then {(\\<epsilon>, \\<lfloor>execute.addr_of_sys_xcpt NullPointer\\<rfloor>, h, (stk, loc, C0, M0, pc) # frs)}\n        else (let ps = rev (take n stk);\n                  a = the_Addr r;\n                  T = the (typeof_addr h a);\n                  (D,M',Ts,meth)= method P (class_type_of T) M\n         in case meth of \n               Native \\<Rightarrow>\n                      do {\n                        (ta, va, h') \\<leftarrow> red_external_aggr P t a M ps h;\n                        {(extTA2JVM P ta, extRet2JVM n h' stk loc C0 M0 pc frs va)}\n                      }\n            | \\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> \\<Rightarrow>\n              let f' = ([],[r]@ps@(replicate mxl\\<^sub>0 undefined_value),D,M,0)\n              in {(\\<epsilon>, None, h, f' # (stk, loc, C0, M0, pc) # frs)})))\"\n  \"exec_instr Return P t h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 M\\<^sub>0 pc frs =\n   {(\\<epsilon>, (if frs=[] then (None, h, []) \n         else \n           let v = hd stk\\<^sub>0; \n               (stk,loc,C,m,pc) = hd frs;\n                n = length (fst (snd (method P C\\<^sub>0 M\\<^sub>0)))\n           in (None, h, (v#(drop (n+1) stk),loc,C,m,pc+1)#tl frs)))}\"\n  \"exec_instr Pop P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs = {(\\<epsilon>, (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, pc+1)#frs))}\"\n  \"exec_instr Dup P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs = {(\\<epsilon>, (None, h, (hd stk # stk, loc, C\\<^sub>0, M\\<^sub>0, pc+1)#frs))}\"\n  \"exec_instr Swap P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs = {(\\<epsilon>, (None, h, (hd (tl stk) # hd stk # tl (tl stk), loc, C\\<^sub>0, M\\<^sub>0, pc+1)#frs))}\"\n  \"exec_instr (BinOpInstr bop) P t h stk loc C0 M0 pc frs =\n   {(\\<epsilon>, \n     case the (execute.binop bop (hd (tl stk)) (hd stk)) of\n       Inl v \\<Rightarrow> (None, h, (v # tl (tl stk), loc, C0, M0, pc + 1) # frs)\n     | Inr a \\<Rightarrow> (Some a, h, (stk, loc, C0, M0, pc) # frs))}\"\n  \"exec_instr (IfFalse i) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n   {(\\<epsilon>, (let pc' = if hd stk = Bool False then nat(int pc+i) else pc+1\n         in (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, pc')#frs)))}\"\n  \"exec_instr (Goto i) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs = {(\\<epsilon>, (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, nat(int pc+i))#frs))}\"\n  \"exec_instr ThrowExc P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n   {(\\<epsilon>, (let xp' = if hd stk = Null then \\<lfloor>execute.addr_of_sys_xcpt NullPointer\\<rfloor> else \\<lfloor>the_Addr(hd stk)\\<rfloor>\n         in (xp', h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc)#frs)))}\"\n  \"exec_instr MEnter P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n   {(let v = hd stk\n     in if v = Null\n        then (\\<epsilon>, \\<lfloor>execute.addr_of_sys_xcpt NullPointer\\<rfloor>, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc) # frs)\n        else (\\<lbrace>Lock\\<rightarrow>the_Addr v, SyncLock (the_Addr v)\\<rbrace>, None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, pc + 1) # frs))}\"\n  \"exec_instr MExit P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n   (let v = hd stk\n    in if v = Null\n       then {(\\<epsilon>, \\<lfloor>execute.addr_of_sys_xcpt NullPointer\\<rfloor>, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc) # frs)}\n       else {(\\<lbrace>Unlock\\<rightarrow>the_Addr v, SyncUnlock (the_Addr v)\\<rbrace>, None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, pc + 1) # frs),\n             (\\<lbrace>UnlockFail\\<rightarrow>the_Addr v\\<rbrace>, \\<lfloor>execute.addr_of_sys_xcpt IllegalMonitorState\\<rfloor>, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc) # frs)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((exec_instr (Load n) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n       {(\\<lbrace>\\<rbrace>, None, h,\n         (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, pc + 1) # frs)} &&&\n       exec_instr (Store n) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n       {(\\<lbrace>\\<rbrace>, None, h,\n         (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, pc + 1) #\n         frs)}) &&&\n      exec_instr (Push v) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n      {(\\<lbrace>\\<rbrace>, None, h,\n        (v # stk, loc, C\\<^sub>0, M\\<^sub>0, pc + 1) # frs)} &&&\n      exec_instr (New C) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n      (let HA = allocate h (Class_type C)\n       in if HA = {}\n          then {(\\<lbrace>\\<rbrace>,\n                 \\<lfloor>execute.addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                 (stk, loc, C\\<^sub>0, M\\<^sub>0, pc) # frs)}\n          else HA \\<bind>\n               (\\<lambda>(h', a).\n                   {(\\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>, None,\n                     h',\n                     (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, pc + 1) #\n                     frs)})) &&&\n      exec_instr (NewArray T) P t h stk loc C0 M0 pc frs =\n      (let si = the_Intg (hd stk); i = nat (sint si)\n       in if si <s 0\n          then {(\\<lbrace>\\<rbrace>,\n                 \\<lfloor>execute.addr_of_sys_xcpt\n                           NegativeArraySize\\<rfloor>,\n                 h, (stk, loc, C0, M0, pc) # frs)}\n          else let HA = allocate h (Array_type T i)\n               in if HA = {}\n                  then {(\\<lbrace>\\<rbrace>,\n                         \\<lfloor>execute.addr_of_sys_xcpt\n                                   OutOfMemory\\<rfloor>,\n                         h, (stk, loc, C0, M0, pc) # frs)}\n                  else HA \\<bind>\n                       (\\<lambda>(h', a).\n                           {(\\<lbrace>NewHeapElem a\n (Array_type T i)\\<rbrace>,\n                             None, h',\n                             (Addr a # tl stk, loc, C0, M0, pc + 1) #\n                             frs)}))) &&&\n     (exec_instr ALoad P t h stk loc C0 M0 pc frs =\n      (let va = hd (tl stk)\n       in if va = Null\n          then {(\\<lbrace>\\<rbrace>,\n                 \\<lfloor>execute.addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                 (stk, loc, C0, M0, pc) # frs)}\n          else let i = the_Intg (hd stk); a = the_Addr va;\n                   len = alen_of_htype (the (typeof_addr h a))\n               in if i <s 0 \\<or> int len \\<le> sint i\n                  then {(\\<lbrace>\\<rbrace>,\n                         \\<lfloor>execute.addr_of_sys_xcpt\n                                   ArrayIndexOutOfBounds\\<rfloor>,\n                         h, (stk, loc, C0, M0, pc) # frs)}\n                  else heap_read h a (ACell (nat (sint i))) \\<bind>\n                       (\\<lambda>v.\n                           {(\\<lbrace>ReadMem a (ACell (nat (sint i)))\n v\\<rbrace>,\n                             None, h,\n                             (v # tl (tl stk), loc, C0, M0, pc + 1) #\n                             frs)})) &&&\n      exec_instr AStore P t h stk loc C0 M0 pc frs =\n      (let ve = hd stk; vi = hd (tl stk); va = hd (tl (tl stk))\n       in if va = Null\n          then {(\\<lbrace>\\<rbrace>,\n                 \\<lfloor>execute.addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                 (stk, loc, C0, M0, pc) # frs)}\n          else let i = the_Intg vi; idx = nat (sint i); a = the_Addr va;\n                   hT = the (typeof_addr h a); T = ty_of_htype hT;\n                   len = alen_of_htype hT;\n                   U = the (typeof\\<^bsub>h\\<^esub> ve)\n               in if i <s 0 \\<or> int len \\<le> sint i\n                  then {(\\<lbrace>\\<rbrace>,\n                         \\<lfloor>execute.addr_of_sys_xcpt\n                                   ArrayIndexOutOfBounds\\<rfloor>,\n                         h, (stk, loc, C0, M0, pc) # frs)}\n                  else if P \\<turnstile> U \\<le> the_Array T\n                       then heap_write h a (ACell idx) ve \\<bind>\n                            (\\<lambda>h'.\n                                {(\\<lbrace>WriteMem a (ACell idx)\n      ve\\<rbrace>,\n                                  None, h',\n                                  (tl (tl (tl stk)), loc, C0, M0, pc + 1) #\n                                  frs)})\n                       else {(\\<lbrace>\\<rbrace>,\n                              \\<lfloor>execute.addr_of_sys_xcpt\n  ArrayStore\\<rfloor>,\n                              h, (stk, loc, C0, M0, pc) # frs)}) &&&\n      exec_instr ALength P t h stk loc C0 M0 pc frs =\n      {(\\<lbrace>\\<rbrace>,\n        let va = hd stk\n        in if va = Null\n           then (\\<lfloor>execute.addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                 (stk, loc, C0, M0, pc) # frs)\n           else (None, h,\n                 (Intg\n                   (word_of_int\n                     (int (alen_of_htype\n                            (the (typeof_addr h (the_Addr va)))))) #\n                  tl stk,\n                  loc, C0, M0, pc + 1) #\n                 frs))}) &&&\n     exec_instr (Getfield F C) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n     (let v = hd stk\n      in if v = Null\n         then {(\\<lbrace>\\<rbrace>,\n                \\<lfloor>execute.addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                (stk, loc, C\\<^sub>0, M\\<^sub>0, pc) # frs)}\n         else let a = the_Addr v\n              in heap_read h a (CField C F) \\<bind>\n                 (\\<lambda>v'.\n                     {(\\<lbrace>ReadMem a (CField C F) v'\\<rbrace>, None, h,\n                       (v' # tl stk, loc, C\\<^sub>0, M\\<^sub>0, pc + 1) #\n                       frs)})) &&&\n     exec_instr (Putfield F C) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n     (let v = hd stk; r = hd (tl stk)\n      in if r = Null\n         then {(\\<lbrace>\\<rbrace>,\n                \\<lfloor>execute.addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                (stk, loc, C\\<^sub>0, M\\<^sub>0, pc) # frs)}\n         else let a = the_Addr r\n              in heap_write h a (CField C F) v \\<bind>\n                 (\\<lambda>h'.\n                     {(\\<lbrace>WriteMem a (CField C F) v\\<rbrace>, None,\n                       h',\n                       (tl (tl stk), loc, C\\<^sub>0, M\\<^sub>0, pc + 1) #\n                       frs)})) &&&\n     exec_instr (Checkcast T) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n     {(\\<lbrace>\\<rbrace>,\n       let U = the (typeof\\<^bsub>h\\<^esub> (hd stk))\n       in if P \\<turnstile> U \\<le> T\n          then (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc + 1) # frs)\n          else (\\<lfloor>execute.addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n                (stk, loc, C\\<^sub>0, M\\<^sub>0, pc) # frs))}) &&&\n    ((exec_instr (Instanceof T) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n      {(\\<lbrace>\\<rbrace>, None, h,\n        (Bool\n          (hd stk \\<noteq> Null \\<and>\n           P \\<turnstile> the (typeof\\<^bsub>h\\<^esub> (hd stk)) \\<le> T) #\n         tl stk,\n         loc, C\\<^sub>0, M\\<^sub>0, pc + 1) #\n        frs)} &&&\n      exec_instr (Invoke M n) P t h stk loc C0 M0 pc frs =\n      (let r = stk ! n\n       in if r = Null\n          then {(\\<lbrace>\\<rbrace>,\n                 \\<lfloor>execute.addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                 (stk, loc, C0, M0, pc) # frs)}\n          else let ps = rev (take n stk); a = the_Addr r;\n                   T = the (typeof_addr h a);\n                   (D, M', Ts, meth) = method P (class_type_of T) M\n               in case meth of\n                  None \\<Rightarrow>\n                    red_external_aggr P t a M ps h \\<bind>\n                    (\\<lambda>(ta, va, h').\n                        {(extTA2JVM P ta,\n                          extRet2JVM n h' stk loc C0 M0 pc frs va)})\n                  | \\<lfloor>(mxs, mxl\\<^sub>0, ins,\n                              xt)\\<rfloor> \\<Rightarrow>\n                      let f' = ([],\n                                [r] @\n                                ps @ replicate mxl\\<^sub>0 undefined_value,\n                                D, M, 0)\n                      in {(\\<lbrace>\\<rbrace>, None, h,\n                           f' # (stk, loc, C0, M0, pc) # frs)}) &&&\n      exec_instr Return P t h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 M\\<^sub>0 pc\n       frs =\n      {(\\<lbrace>\\<rbrace>,\n        if frs = [] then (None, h, [])\n        else let v = hd stk\\<^sub>0; (stk, loc, C, m, pc) = hd frs;\n                 n = length (fst (snd (method P C\\<^sub>0 M\\<^sub>0)))\n             in (None, h,\n                 (v # drop (n + 1) stk, loc, C, m, pc + 1) # tl frs))}) &&&\n     exec_instr Pop P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n     {(\\<lbrace>\\<rbrace>, None, h,\n       (tl stk, loc, C\\<^sub>0, M\\<^sub>0, pc + 1) # frs)} &&&\n     exec_instr Dup P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n     {(\\<lbrace>\\<rbrace>, None, h,\n       (hd stk # stk, loc, C\\<^sub>0, M\\<^sub>0, pc + 1) # frs)} &&&\n     exec_instr Swap P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n     {(\\<lbrace>\\<rbrace>, None, h,\n       (hd (tl stk) # hd stk # tl (tl stk), loc, C\\<^sub>0, M\\<^sub>0,\n        pc + 1) #\n       frs)}) &&&\n    (exec_instr (BinOpInstr bop) P t h stk loc C0 M0 pc frs =\n     {(\\<lbrace>\\<rbrace>,\n       case the (execute.binop bop (hd (tl stk)) (hd stk)) of\n       Inl v \\<Rightarrow>\n         (None, h, (v # tl (tl stk), loc, C0, M0, pc + 1) # frs)\n       | Inr a \\<Rightarrow>\n           (\\<lfloor>a\\<rfloor>, h, (stk, loc, C0, M0, pc) # frs))} &&&\n     exec_instr (IfFalse i) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n     {(\\<lbrace>\\<rbrace>,\n       let pc' = if hd stk = Bool False then nat (int pc + i) else pc + 1\n       in (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, pc') # frs))} &&&\n     exec_instr (Goto i) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n     {(\\<lbrace>\\<rbrace>, None, h,\n       (stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i)) # frs)}) &&&\n    exec_instr ThrowExc P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n    {(\\<lbrace>\\<rbrace>,\n      let xp' =\n            if hd stk = Null\n            then \\<lfloor>execute.addr_of_sys_xcpt NullPointer\\<rfloor>\n            else \\<lfloor>the_Addr (hd stk)\\<rfloor>\n      in (xp', h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc) # frs))} &&&\n    exec_instr MEnter P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n    {let v = hd stk\n     in if v = Null\n        then (\\<lbrace>\\<rbrace>,\n              \\<lfloor>execute.addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n              (stk, loc, C\\<^sub>0, M\\<^sub>0, pc) # frs)\n        else (\\<lbrace>(Lock, the_Addr v), SyncLock (the_Addr v)\\<rbrace>,\n              None, h,\n              (tl stk, loc, C\\<^sub>0, M\\<^sub>0, pc + 1) # frs)} &&&\n    exec_instr MExit P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n    (let v = hd stk\n     in if v = Null\n        then {(\\<lbrace>\\<rbrace>,\n               \\<lfloor>execute.addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n               (stk, loc, C\\<^sub>0, M\\<^sub>0, pc) # frs)}\n        else {(\\<lbrace>(Unlock, the_Addr v),\n               SyncUnlock (the_Addr v)\\<rbrace>, None, h,\n               (tl stk, loc, C\\<^sub>0, M\\<^sub>0, pc + 1) # frs),\n              (\\<lbrace>(UnlockFail, the_Addr v)\\<rbrace>,\n               \\<lfloor>execute.addr_of_sys_xcpt\n                         IllegalMonitorState\\<rfloor>,\n               h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc) # frs)})", "by(auto 4 4 intro: rev_bexI)"], ["", "definition exec :: \"'addr jvm_prog \\<Rightarrow> 'thread_id \\<Rightarrow> ('addr, 'heap) jvm_state \\<Rightarrow> ('addr, 'thread_id, 'heap) jvm_ta_state set\"\nwhere \"exec = execute.exec\""], ["", "lemma exec_code:\n  \"exec P t (xcp, h, []) = {}\"\n  \"exec P t (None, h, (stk, loc, C, M, pc) # frs) = exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs\"\n  \"exec P t (\\<lfloor>a\\<rfloor>, h, fr # frs) = {(\\<epsilon>, execute.exception_step P a h fr frs)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec P t (xcp, h, []) = {} &&&\n    exec P t (None, h, (stk, loc, C, M, pc) # frs) =\n    exec_instr (instrs_of P C M ! pc) P t h stk loc C M pc frs &&&\n    exec P t (\\<lfloor>a\\<rfloor>, h, fr # frs) =\n    {(\\<lbrace>\\<rbrace>, execute.exception_step P a h fr frs)}", "by(simp_all add: exec_def)"], ["", "definition exec_1 ::\n  \"'addr jvm_prog \\<Rightarrow> 'thread_id \\<Rightarrow> ('addr, 'heap) jvm_state\n   \\<Rightarrow> (('addr, 'thread_id, 'heap) jvm_thread_action \\<times> ('addr, 'heap) jvm_state) Predicate.pred\"\nwhere \"exec_1 P t \\<sigma> = pred_of_set (exec P t \\<sigma>)\""], ["", "lemma exec_1I: \"execute.exec_1 P t \\<sigma> ta \\<sigma>' \\<Longrightarrow> Predicate.eval (exec_1 P t \\<sigma>) (ta, \\<sigma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute.exec_1 P t \\<sigma> ta \\<sigma>' \\<Longrightarrow>\n    pred.eval (exec_1 P t \\<sigma>) (ta, \\<sigma>')", "by(erule execute.exec_1.cases)(simp add: exec_1_def exec_def)"], ["", "lemma exec_1E:\n  assumes \"Predicate.eval (exec_1 P t \\<sigma>) (ta, \\<sigma>')\"\n  obtains \"execute.exec_1 P t \\<sigma> ta \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (execute.exec_1 P t \\<sigma> ta \\<sigma>' \\<Longrightarrow>\n     thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  pred.eval (exec_1 P t \\<sigma>) (ta, \\<sigma>')\n\ngoal (1 subgoal):\n 1. (execute.exec_1 P t \\<sigma> ta \\<sigma>' \\<Longrightarrow>\n     thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: exec_1_def exec_def intro: execute.exec_1.intros)"], ["", "lemma exec_1_eq [simp]:\n  \"Predicate.eval (exec_1 P t \\<sigma>) (ta, \\<sigma>') \\<longleftrightarrow> execute.exec_1 P t \\<sigma> ta \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred.eval (exec_1 P t \\<sigma>) (ta, \\<sigma>') =\n    execute.exec_1 P t \\<sigma> ta \\<sigma>'", "by(auto intro: exec_1I elim: exec_1E)"], ["", "lemma exec_1_eq':\n  \"Predicate.eval (exec_1 P t \\<sigma>) = (\\<lambda>(ta, \\<sigma>'). execute.exec_1 P t \\<sigma> ta \\<sigma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred.eval (exec_1 P t \\<sigma>) =\n    (\\<lambda>(ta, \\<sigma>'). execute.exec_1 P t \\<sigma> ta \\<sigma>')", "by(rule ext)(simp split: prod.split)"], ["", "end"], ["", "lemmas [code] = \n  JVM_heap_execute.exec_instr_code\n  JVM_heap_base.exception_step.simps\n  JVM_heap_execute.exec_code\n  JVM_heap_execute.exec_1_def"], ["", "end"]]}