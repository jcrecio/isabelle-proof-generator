{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/BV/BVConform.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma conf_f_def2:\n  \"conf_f P h (ST,LT) is (stk,loc,C,M,pc) \\<equiv>\n  P,h \\<turnstile> stk [:\\<le>] ST \\<and> P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT \\<and> pc < size is\"", "lemma confT_Err [iff]: \"P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> Err\"", "lemma confT_OK [iff]:  \"P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> OK T = (P,h \\<turnstile> x :\\<le> T)\"", "lemma confT_cases:\n  \"P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> X = (X = Err \\<or> (\\<exists>T. X = OK T \\<and> P,h \\<turnstile> x :\\<le> T))\"", "lemma confT_widen [intro?, trans]:\n  \"\\<lbrakk> P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> T; P \\<turnstile> T \\<le>\\<^sub>\\<top> T' \\<rbrakk> \\<Longrightarrow> P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> T'\"", "lemma confT_hext [intro?, trans]:\n  \"\\<lbrakk> P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> T; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow> P,h' \\<turnstile> x :\\<le>\\<^sub>\\<top> T\"", "lemma confTs_Cons1 [iff]:\n  \"P,h \\<turnstile> x # xs [:\\<le>\\<^sub>\\<top>] Ts = (\\<exists>z zs. Ts = z # zs \\<and> P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> z \\<and> list_all2 (confT P h) xs zs)\"", "lemma confTs_confT_sup:\n  \"\\<lbrakk> P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; n < size LT; LT!n = OK T; P \\<turnstile> T \\<le> T' \\<rbrakk> \n  \\<Longrightarrow> P,h \\<turnstile> (loc!n) :\\<le> T'\"", "lemma confTs_widen [intro?, trans]:\n  \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT \\<Longrightarrow> P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT' \\<Longrightarrow> P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\"", "lemma confTs_map [iff]:\n  \"(P,h \\<turnstile> vs [:\\<le>\\<^sub>\\<top>] map OK Ts) = (P,h \\<turnstile> vs [:\\<le>] Ts)\"", "lemma (in -) reg_widen_Err:\n  \"(P \\<turnstile> replicate n Err [\\<le>\\<^sub>\\<top>] LT) = (LT = replicate n Err)\"", "lemma confTs_Err [iff]:\n  \"P,h \\<turnstile> replicate n v [:\\<le>\\<^sub>\\<top>] replicate n Err\"", "lemma confTs_hext [intro?]:\n  \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT \\<Longrightarrow> h \\<unlhd> h' \\<Longrightarrow> P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\"", "lemma conf_f_hext:\n  \"\\<lbrakk> conf_f P h \\<Phi> M f; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow> conf_f P h' \\<Phi> M f\"", "lemma conf_fs_hext:\n  \"\\<lbrakk> conf_fs P h \\<Phi> M n T\\<^sub>r frs; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow> conf_fs P h' \\<Phi> M n T\\<^sub>r frs\"", "lemma conf_xcp_hext:\n  \"\\<lbrakk> conf_xcp P h xcp i; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow> conf_xcp P h' xcp i\"", "lemmas defs1 = correct_state_def conf_f_def wt_instr_def eff_def norm_eff_def app_def xcpt_app_def", "lemma correct_state_impl_Some_method:\n  \"\\<Phi> \\<turnstile> t: (None, h, (stk,loc,C,M,pc)#frs)\\<surd> \n  \\<Longrightarrow> \\<exists>m Ts T. P \\<turnstile> C sees M:Ts\\<rightarrow>T = \\<lfloor>m\\<rfloor> in C\"", "lemma correct_state_hext_mono:\n  \"\\<lbrakk> \\<Phi> \\<turnstile> t: (xcp, h, frs) \\<surd>; h \\<unlhd> h'; hconf h' \\<rbrakk> \\<Longrightarrow> \\<Phi> \\<turnstile> t: (xcp, h', frs) \\<surd>\""], "translations": [["", "lemma conf_f_def2:\n  \"conf_f P h (ST,LT) is (stk,loc,C,M,pc) \\<equiv>\n  P,h \\<turnstile> stk [:\\<le>] ST \\<and> P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT \\<and> pc < size is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_f P h (ST, LT) is (stk, loc, C, M, pc) \\<equiv>\n    P,h \\<turnstile> stk [:\\<le>] ST \\<and>\n    P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT \\<and> pc < length is", "by (simp add: conf_f_def)"], ["", "subsection \\<open>Values and \\<open>\\<top>\\<close>\\<close>"], ["", "lemma confT_Err [iff]: \"P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> Err\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> Err", "by (simp add: confT_def)"], ["", "lemma confT_OK [iff]:  \"P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> OK T = (P,h \\<turnstile> x :\\<le> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> OK T) =\n    (P,h \\<turnstile> x :\\<le> T)", "by (simp add: confT_def)"], ["", "lemma confT_cases:\n  \"P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> X = (X = Err \\<or> (\\<exists>T. X = OK T \\<and> P,h \\<turnstile> x :\\<le> T))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> X) =\n    (X = Err \\<or>\n     (\\<exists>T. X = OK T \\<and> P,h \\<turnstile> x :\\<le> T))", "by (cases X) auto"], ["", "lemma confT_widen [intro?, trans]:\n  \"\\<lbrakk> P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> T; P \\<turnstile> T \\<le>\\<^sub>\\<top> T' \\<rbrakk> \\<Longrightarrow> P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> T;\n     P \\<turnstile> T \\<le>\\<^sub>\\<top> T'\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> T'", "by (cases T', auto intro: conf_widen)"], ["", "end"], ["", "context JVM_heap begin"], ["", "lemma confT_hext [intro?, trans]:\n  \"\\<lbrakk> P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> T; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow> P,h' \\<turnstile> x :\\<le>\\<^sub>\\<top> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> T;\n     h \\<unlhd> h'\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile> x :\\<le>\\<^sub>\\<top> T", "by (cases T) (blast intro: conf_hext)+"], ["", "end"], ["", "subsection \\<open>Stack and Registers\\<close>"], ["", "context JVM_heap_base begin"], ["", "lemma confTs_Cons1 [iff]:\n  \"P,h \\<turnstile> x # xs [:\\<le>\\<^sub>\\<top>] Ts = (\\<exists>z zs. Ts = z # zs \\<and> P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> z \\<and> list_all2 (confT P h) xs zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,h \\<turnstile> x # xs [:\\<le>\\<^sub>\\<top>] Ts) =\n    (\\<exists>z zs.\n        Ts = z # zs \\<and>\n        P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> z \\<and>\n        P,h \\<turnstile> xs [:\\<le>\\<^sub>\\<top>] zs)", "by(rule list_all2_Cons1)"], ["", "lemma confTs_confT_sup:\n  \"\\<lbrakk> P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; n < size LT; LT!n = OK T; P \\<turnstile> T \\<le> T' \\<rbrakk> \n  \\<Longrightarrow> P,h \\<turnstile> (loc!n) :\\<le> T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; n < length LT;\n     LT ! n = OK T; P \\<turnstile> T \\<le> T'\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> loc ! n :\\<le> T'", "apply (frule list_all2_lengthD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; n < length LT;\n     LT ! n = OK T; P \\<turnstile> T \\<le> T';\n     length loc = length LT\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> loc ! n :\\<le> T'", "apply (drule list_all2_nthD, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length LT; LT ! n = OK T; P \\<turnstile> T \\<le> T';\n     length loc = length LT;\n     P,h \\<turnstile> loc ! n :\\<le>\\<^sub>\\<top> LT ! n\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> loc ! n :\\<le> T'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length LT; LT ! n = OK T; P \\<turnstile> T \\<le> T';\n     length loc = length LT; P,h \\<turnstile> loc ! n :\\<le> T\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> loc ! n :\\<le> T'", "apply (erule conf_widen, assumption+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma confTs_widen [intro?, trans]:\n  \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT \\<Longrightarrow> P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT' \\<Longrightarrow> P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT;\n     P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'", "by (rule list_all2_trans, rule confT_widen)"], ["", "lemma confTs_map [iff]:\n  \"(P,h \\<turnstile> vs [:\\<le>\\<^sub>\\<top>] map OK Ts) = (P,h \\<turnstile> vs [:\\<le>] Ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,h \\<turnstile> vs [:\\<le>\\<^sub>\\<top>] map OK Ts) =\n    (P,h \\<turnstile> vs [:\\<le>] Ts)", "by (induct Ts arbitrary: vs) (auto simp add: list_all2_Cons2)"], ["", "lemma (in -) reg_widen_Err:\n  \"(P \\<turnstile> replicate n Err [\\<le>\\<^sub>\\<top>] LT) = (LT = replicate n Err)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> replicate n Err [\\<le>\\<^sub>\\<top>] LT =\n    (LT = replicate n Err)", "by (induct n arbitrary: LT) (auto simp add: list_all2_Cons1)"], ["", "declare reg_widen_Err [iff]"], ["", "lemma confTs_Err [iff]:\n  \"P,h \\<turnstile> replicate n v [:\\<le>\\<^sub>\\<top>] replicate n Err\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h \\<turnstile> replicate n v [:\\<le>\\<^sub>\\<top>] replicate n Err", "by (induct n) auto"], ["", "end"], ["", "context JVM_heap begin"], ["", "lemma confTs_hext [intro?]:\n  \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT \\<Longrightarrow> h \\<unlhd> h' \\<Longrightarrow> P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT;\n     h \\<unlhd> h'\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT", "by (fast elim: list_all2_mono confT_hext)"], ["", "subsection \\<open>correct-frames\\<close>"], ["", "declare fun_upd_apply[simp del]"], ["", "lemma conf_f_hext:\n  \"\\<lbrakk> conf_f P h \\<Phi> M f; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow> conf_f P h' \\<Phi> M f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>conf_f P h \\<Phi> M f; h \\<unlhd> h'\\<rbrakk>\n    \\<Longrightarrow> conf_f P h' \\<Phi> M f", "by(cases f, cases \\<Phi>, auto simp add: conf_f_def intro: confs_hext confTs_hext)"], ["", "lemma conf_fs_hext:\n  \"\\<lbrakk> conf_fs P h \\<Phi> M n T\\<^sub>r frs; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow> conf_fs P h' \\<Phi> M n T\\<^sub>r frs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>conf_fs P h \\<Phi> M n T\\<^sub>r frs; h \\<unlhd> h'\\<rbrakk>\n    \\<Longrightarrow> conf_fs P h' \\<Phi> M n T\\<^sub>r frs", "apply (induct frs arbitrary: M n T\\<^sub>r)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>M n T\\<^sub>r.\n       \\<lbrakk>conf_fs P h \\<Phi> M n T\\<^sub>r []; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h' \\<Phi> M n T\\<^sub>r []\n 2. \\<And>a frs M n T\\<^sub>r.\n       \\<lbrakk>\\<And>M n T\\<^sub>r.\n                   \\<lbrakk>conf_fs P h \\<Phi> M n T\\<^sub>r frs;\n                    h \\<unlhd> h'\\<rbrakk>\n                   \\<Longrightarrow> conf_fs P h' \\<Phi> M n T\\<^sub>r frs;\n        conf_fs P h \\<Phi> M n T\\<^sub>r (a # frs); h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h' \\<Phi> M n T\\<^sub>r (a # frs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a frs M n T\\<^sub>r.\n       \\<lbrakk>\\<And>M n T\\<^sub>r.\n                   \\<lbrakk>conf_fs P h \\<Phi> M n T\\<^sub>r frs;\n                    h \\<unlhd> h'\\<rbrakk>\n                   \\<Longrightarrow> conf_fs P h' \\<Phi> M n T\\<^sub>r frs;\n        conf_fs P h \\<Phi> M n T\\<^sub>r (a # frs); h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h' \\<Phi> M n T\\<^sub>r (a # frs)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac b frs M n T\\<^sub>r.\n       \\<lbrakk>\\<And>M n T\\<^sub>r.\n                   \\<lbrakk>conf_fs P h \\<Phi> M n T\\<^sub>r frs;\n                    h \\<unlhd> h'\\<rbrakk>\n                   \\<Longrightarrow> conf_fs P h' \\<Phi> M n T\\<^sub>r frs;\n        conf_fs P h \\<Phi> M n T\\<^sub>r ((a, aa, ab, ac, b) # frs);\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h' \\<Phi> M n T\\<^sub>r\n                          ((a, aa, ab, ac, b) # frs)", "apply (simp (no_asm_use))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac b frs M n T\\<^sub>r.\n       \\<lbrakk>\\<And>M n T\\<^sub>r.\n                   \\<lbrakk>conf_fs P h \\<Phi> M n T\\<^sub>r frs;\n                    h \\<unlhd> h'\\<rbrakk>\n                   \\<Longrightarrow> conf_fs P h' \\<Phi> M n T\\<^sub>r frs;\n        \\<exists>ST LT.\n           \\<Phi> ab ac ! b = \\<lfloor>(ST, LT)\\<rfloor> \\<and>\n           (\\<exists>Ts T mxs mxl\\<^sub>0 is.\n               (\\<exists>xt.\n                   P \\<turnstile> ab sees ac: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                                     mxl\\<^sub>0, is,\n                                     xt)\\<rfloor> in ab) \\<and>\n               is ! b = Invoke M n \\<and>\n               (\\<exists>Ts' T' D.\n                   class_type_of' (ST ! n) = \\<lfloor>D\\<rfloor> \\<and>\n                   (\\<exists>m. Ex (Method P D M Ts' T' m)) \\<and>\n                   P \\<turnstile> T\\<^sub>r \\<le> T') \\<and>\n               conf_f P h (ST, LT) is (a, aa, ab, ac, b) \\<and>\n               conf_fs P h \\<Phi> ac (length Ts) T frs);\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ST LT.\n                            \\<Phi> ab ac ! b =\n                            \\<lfloor>(ST, LT)\\<rfloor> \\<and>\n                            (\\<exists>Ts T mxs mxl\\<^sub>0 is.\n                                (\\<exists>xt.\n                                    P \\<turnstile> ab sees ac: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                mxl\\<^sub>0, is, xt)\\<rfloor> in ab) \\<and>\n                                is ! b = Invoke M n \\<and>\n                                (\\<exists>Ts' T' D.\n                                    class_type_of' (ST ! n) =\n                                    \\<lfloor>D\\<rfloor> \\<and>\n                                    (\\<exists>m.\n  Ex (Method P D M Ts' T' m)) \\<and>\n                                    P \\<turnstile> T\\<^sub>r \\<le> T') \\<and>\n                                conf_f P h' (ST, LT) is\n                                 (a, aa, ab, ac, b) \\<and>\n                                conf_fs P h' \\<Phi> ac (length Ts) T frs)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac b frs M n T\\<^sub>r ST LT Ts T mxs mxl\\<^sub>0 is xt\n       Ts' T' D m x.\n       \\<lbrakk>\\<And>M n T\\<^sub>r.\n                   \\<lbrakk>conf_fs P h \\<Phi> M n T\\<^sub>r frs;\n                    h \\<unlhd> h'\\<rbrakk>\n                   \\<Longrightarrow> conf_fs P h' \\<Phi> M n T\\<^sub>r frs;\n        h \\<unlhd> h'; \\<Phi> ab ac ! b = \\<lfloor>(ST, LT)\\<rfloor>;\n        P \\<turnstile> ab sees ac: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                          mxl\\<^sub>0, is, xt)\\<rfloor> in ab;\n        is ! b = Invoke M n; conf_f P h (ST, LT) is (a, aa, ab, ac, b);\n        conf_fs P h \\<Phi> ac (length Ts) T frs;\n        class_type_of' (ST ! n) = \\<lfloor>D\\<rfloor>;\n        P \\<turnstile> T\\<^sub>r \\<le> T';\n        P \\<turnstile> D sees M: Ts'\\<rightarrow>T' = m in x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ST LT.\n                            \\<Phi> ab ac ! b =\n                            \\<lfloor>(ST, LT)\\<rfloor> \\<and>\n                            (\\<exists>Ts T mxs mxl\\<^sub>0 is.\n                                (\\<exists>xt.\n                                    P \\<turnstile> ab sees ac: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                mxl\\<^sub>0, is, xt)\\<rfloor> in ab) \\<and>\n                                is ! b = Invoke M n \\<and>\n                                (\\<exists>Ts' T' D.\n                                    class_type_of' (ST ! n) =\n                                    \\<lfloor>D\\<rfloor> \\<and>\n                                    (\\<exists>m.\n  Ex (Method P D M Ts' T' m)) \\<and>\n                                    P \\<turnstile> T\\<^sub>r \\<le> T') \\<and>\n                                conf_f P h' (ST, LT) is\n                                 (a, aa, ab, ac, b) \\<and>\n                                conf_fs P h' \\<Phi> ac (length Ts) T frs)", "apply (unfold conf_f_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac b frs M n T\\<^sub>r ST LT Ts T mxs mxl\\<^sub>0 is xt\n       Ts' T' D m x.\n       \\<lbrakk>\\<And>M n T\\<^sub>r.\n                   \\<lbrakk>conf_fs P h \\<Phi> M n T\\<^sub>r frs;\n                    h \\<unlhd> h'\\<rbrakk>\n                   \\<Longrightarrow> conf_fs P h' \\<Phi> M n T\\<^sub>r frs;\n        h \\<unlhd> h'; \\<Phi> ab ac ! b = \\<lfloor>(ST, LT)\\<rfloor>;\n        P \\<turnstile> ab sees ac: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                          mxl\\<^sub>0, is, xt)\\<rfloor> in ab;\n        is ! b = Invoke M n;\n        (case (ST, LT) of\n         (ST, LT) \\<Rightarrow>\n           \\<lambda>is (stk, loc, C, M, pc).\n              P,h \\<turnstile> stk [:\\<le>] ST \\<and>\n              P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT \\<and>\n              pc < length is)\n         is (a, aa, ab, ac, b);\n        conf_fs P h \\<Phi> ac (length Ts) T frs;\n        class_type_of' (ST ! n) = \\<lfloor>D\\<rfloor>;\n        P \\<turnstile> T\\<^sub>r \\<le> T';\n        P \\<turnstile> D sees M: Ts'\\<rightarrow>T' = m in x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ST LT.\n                            \\<Phi> ab ac ! b =\n                            \\<lfloor>(ST, LT)\\<rfloor> \\<and>\n                            (\\<exists>Ts T mxs mxl\\<^sub>0 is.\n                                (\\<exists>xt.\n                                    P \\<turnstile> ab sees ac: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                mxl\\<^sub>0, is, xt)\\<rfloor> in ab) \\<and>\n                                is ! b = Invoke M n \\<and>\n                                (\\<exists>Ts' T' D.\n                                    class_type_of' (ST ! n) =\n                                    \\<lfloor>D\\<rfloor> \\<and>\n                                    (\\<exists>m.\n  Ex (Method P D M Ts' T' m)) \\<and>\n                                    P \\<turnstile> T\\<^sub>r \\<le> T') \\<and>\n                                (case (ST, LT) of\n                                 (ST, LT) \\<Rightarrow>\n                                   \\<lambda>is (stk, loc, C, M, pc).\nP,h' \\<turnstile> stk [:\\<le>] ST \\<and>\nP,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT \\<and> pc < length is)\n                                 is (a, aa, ab, ac, b) \\<and>\n                                conf_fs P h' \\<Phi> ac (length Ts) T frs)", "apply (simp (no_asm_use) split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac b frs M n T\\<^sub>r ST LT Ts T mxs mxl\\<^sub>0 is xt\n       Ts' T' D m x.\n       \\<lbrakk>\\<And>M n T\\<^sub>r.\n                   \\<lbrakk>conf_fs P h \\<Phi> M n T\\<^sub>r frs;\n                    h \\<unlhd> h'\\<rbrakk>\n                   \\<Longrightarrow> conf_fs P h' \\<Phi> M n T\\<^sub>r frs;\n        h \\<unlhd> h'; \\<Phi> ab ac ! b = \\<lfloor>(ST, LT)\\<rfloor>;\n        P \\<turnstile> ab sees ac: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                          mxl\\<^sub>0, is, xt)\\<rfloor> in ab;\n        is ! b = Invoke M n;\n        P,h \\<turnstile> a [:\\<le>] ST \\<and>\n        P,h \\<turnstile> aa [:\\<le>\\<^sub>\\<top>] LT \\<and> b < length is;\n        conf_fs P h \\<Phi> ac (length Ts) T frs;\n        class_type_of' (ST ! n) = \\<lfloor>D\\<rfloor>;\n        P \\<turnstile> T\\<^sub>r \\<le> T';\n        P \\<turnstile> D sees M: Ts'\\<rightarrow>T' = m in x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ST LT.\n                            \\<Phi> ab ac ! b =\n                            \\<lfloor>(ST, LT)\\<rfloor> \\<and>\n                            (\\<exists>Ts T mxs mxl\\<^sub>0 is.\n                                (\\<exists>xt.\n                                    P \\<turnstile> ab sees ac: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                mxl\\<^sub>0, is, xt)\\<rfloor> in ab) \\<and>\n                                is ! b = Invoke M n \\<and>\n                                (\\<exists>Ts' T' D.\n                                    class_type_of' (ST ! n) =\n                                    \\<lfloor>D\\<rfloor> \\<and>\n                                    (\\<exists>m.\n  Ex (Method P D M Ts' T' m)) \\<and>\n                                    P \\<turnstile> T\\<^sub>r \\<le> T') \\<and>\n                                P,h' \\<turnstile> a [:\\<le>] ST \\<and>\n                                P,h' \\<turnstile> aa [:\\<le>\\<^sub>\\<top>] LT \\<and>\n                                b < length is \\<and>\n                                conf_fs P h' \\<Phi> ac (length Ts) T frs)", "apply (fast elim!: confs_hext confTs_hext)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare fun_upd_apply[simp]"], ["", "lemma conf_xcp_hext:\n  \"\\<lbrakk> conf_xcp P h xcp i; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow> conf_xcp P h' xcp i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>conf_xcp P h xcp i; h \\<unlhd> h'\\<rbrakk>\n    \\<Longrightarrow> conf_xcp P h' xcp i", "by(cases xcp)(auto elim: typeof_addr_hext_mono)"], ["", "end"], ["", "context JVM_heap_conf_base begin"], ["", "lemmas defs1 = correct_state_def conf_f_def wt_instr_def eff_def norm_eff_def app_def xcpt_app_def"], ["", "lemma correct_state_impl_Some_method:\n  \"\\<Phi> \\<turnstile> t: (None, h, (stk,loc,C,M,pc)#frs)\\<surd> \n  \\<Longrightarrow> \\<exists>m Ts T. P \\<turnstile> C sees M:Ts\\<rightarrow>T = \\<lfloor>m\\<rfloor> in C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:(None, h,\n                           (stk, loc, C, M, pc) #\n                           frs) \\<surd> \\<Longrightarrow>\n    \\<exists>m Ts T.\n       P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>m\\<rfloor> in C", "by(fastforce simp add: defs1)"], ["", "end"], ["", "context JVM_heap_conf_base' begin"], ["", "lemma correct_state_hext_mono:\n  \"\\<lbrakk> \\<Phi> \\<turnstile> t: (xcp, h, frs) \\<surd>; h \\<unlhd> h'; hconf h' \\<rbrakk> \\<Longrightarrow> \\<Phi> \\<turnstile> t: (xcp, h', frs) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>; h \\<unlhd> h';\n     hconf h'\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> \\<turnstile> t:(xcp, h', frs) \\<surd>", "unfolding correct_state_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>case (xcp, h, frs) of\n             (xp, h, frs) \\<Rightarrow>\n               P,h \\<turnstile> t \\<surd>t \\<and>\n               hconf h \\<and>\n               preallocated h \\<and>\n               (case frs of [] \\<Rightarrow> True\n                | f # fs \\<Rightarrow>\n                    let (stk, loc, C, M, pc) = f\n                    in \\<exists>Ts T mxs mxl\\<^sub>0 is xt \\<tau>.\n                          P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n    mxl\\<^sub>0, is, xt)\\<rfloor> in C \\<and>\n                          \\<Phi> C M ! pc = \\<lfloor>\\<tau>\\<rfloor> \\<and>\n                          conf_f P h \\<tau> is f \\<and>\n                          conf_fs P h \\<Phi> M (length Ts) T fs \\<and>\n                          conf_xcp P h xp (is ! pc));\n     h \\<unlhd> h'; hconf h'\\<rbrakk>\n    \\<Longrightarrow> case (xcp, h', frs) of\n                      (xp, h, frs) \\<Rightarrow>\n                        P,h \\<turnstile> t \\<surd>t \\<and>\n                        hconf h \\<and>\n                        preallocated h \\<and>\n                        (case frs of [] \\<Rightarrow> True\n                         | f # fs \\<Rightarrow>\n                             let (stk, loc, C, M, pc) = f\n                             in \\<exists>Ts T mxs mxl\\<^sub>0 is xt \\<tau>.\n                                   P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n             mxl\\<^sub>0, is, xt)\\<rfloor> in C \\<and>\n                                   \\<Phi> C M ! pc =\n                                   \\<lfloor>\\<tau>\\<rfloor> \\<and>\n                                   conf_f P h \\<tau> is f \\<and>\n                                   conf_fs P h \\<Phi> M (length Ts) T\n                                    fs \\<and>\n                                   conf_xcp P h xp (is ! pc))", "by(fastforce elim: tconf_hext_mono preallocated_hext conf_f_hext conf_fs_hext conf_xcp_hext split: list.split)"], ["", "end"], ["", "end"]]}