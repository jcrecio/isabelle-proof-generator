{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Compiler/J1State.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma expr_locks_blocks1 [simp]:\n  \"expr_locks (blocks1 n Ts e) = expr_locks e\"", "lemma max_varss_append [simp]:\n  \"max_varss (es @ es') = max (max_varss es) (max_varss es')\"", "lemma max_varss_map_Val [simp]: \"max_varss (map Val vs) = 0\"", "lemma blocks1_max_vars:\n  \"max_vars (blocks1 n Ts e) = max_vars e + length Ts\"", "lemma blocks_max_vars:\n  \"\\<lbrakk> length vs = length pns; length Ts = length pns \\<rbrakk>\n  \\<Longrightarrow> max_vars (blocks pns Ts vs e) = max_vars e + length pns\"", "lemma Bs_append [simp]: \"\\<B>s (es @ es') n \\<longleftrightarrow> \\<B>s es n \\<and> \\<B>s es' n\"", "lemma Bs_map_Val [simp]: \"\\<B>s (map Val vs) n\"", "lemma B_blocks1 [intro]: \"\\<B> body (n + length Ts) \\<Longrightarrow> \\<B> (blocks1 n Ts body) n\"", "lemma B_extRet2J [simp]: \"\\<B> e n \\<Longrightarrow> \\<B> (extRet2J e va) n\"", "lemma B_inline_call: \"\\<lbrakk> \\<B> e n; \\<And>n. \\<B> e' n \\<rbrakk> \\<Longrightarrow> \\<B> (inline_call e' e) n\"\n  and Bs_inline_calls: \"\\<lbrakk> \\<B>s es n; \\<And>n. \\<B> e' n \\<rbrakk> \\<Longrightarrow> \\<B>s (inline_calls e' es) n\"", "lemma syncvarss_append [simp]: \"syncvarss (es @ es') \\<longleftrightarrow> syncvarss es \\<and> syncvarss es'\"", "lemma syncvarss_map_Val [simp]: \"syncvarss (map Val vs)\"", "lemma bsok_simps [simp]:\n  \"bsok (new C) n = True\"\n  \"bsok (newA T\\<lfloor>e\\<rceil>) n = bsok e n\"\n  \"bsok (Cast T e) n = bsok e n\"\n  \"bsok (e instanceof T) n = bsok e n\"\n  \"bsok (e1 \\<guillemotleft>bop\\<guillemotright> e2) n = (bsok e1 n \\<and> bsok e2 n)\"\n  \"bsok (Var V) n = True\"\n  \"bsok (Val v) n = True\"\n  \"bsok (V := e) n = bsok e n\"\n  \"bsok (a\\<lfloor>i\\<rceil>) n = (bsok a n \\<and> bsok i n)\"\n  \"bsok (a\\<lfloor>i\\<rceil> := e) n = (bsok a n \\<and> bsok i n \\<and> bsok e n)\"\n  \"bsok (a\\<bullet>length) n = bsok a n\"\n  \"bsok (e\\<bullet>F{D}) n = bsok e n\"\n  \"bsok (e\\<bullet>F{D} := e') n = (bsok e n \\<and> bsok e' n)\"\n  \"bsok (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) n = (bsok e n \\<and> bsok e' n \\<and> bsok e'' n)\"\n  \"bsok (e\\<bullet>M(ps)) n = (bsok e n \\<and> bsoks ps n)\"\n  \"bsok {V:T=vo; e} n = (bsok e (Suc n) \\<and> V = n)\"\n  \"bsok (sync\\<^bsub>V\\<^esub> (e) e') n = (bsok e n \\<and> bsok e' (Suc n) \\<and> V = n)\"\n  \"bsok (insync\\<^bsub>V\\<^esub> (ad) e) n = False\"\n  \"bsok (e;; e') n = (bsok e n \\<and> bsok e' n)\"\n  \"bsok (if (e) e1 else e2) n = (bsok e n \\<and> bsok e1 n \\<and> bsok e2 n)\"\n  \"bsok (while (b) c) n = (bsok b n \\<and> bsok c n)\"\n  \"bsok (throw e) n = bsok e n\"\n  \"bsok (try e catch(C V) e') n = (bsok e n \\<and> bsok e' (Suc n) \\<and> V = n)\"\n  and bsoks_simps [simp]:\n  \"bsoks [] n = True\"\n  \"bsoks (e # es) n = (bsok e n \\<and> bsoks es n)\"", "lemma call1_callE:\n  assumes \"call1 (obj\\<bullet>M(pns)) = \\<lfloor>(a, M', vs)\\<rfloor>\"\n  obtains (CallObj) \"call1 obj = \\<lfloor>(a, M', vs)\\<rfloor>\"\n  | (CallParams) v where \"obj = Val v\" \"calls1 pns = \\<lfloor>(a, M', vs)\\<rfloor>\"\n  | (Call) \"obj = addr a\" \"pns = map Val vs\" \"M = M'\"", "lemma calls1_map_Val_append [simp]:\n  \"calls1 (map Val vs @ es) = calls1 es\"", "lemma calls1_map_Val [simp]:\n  \"calls1 (map Val vs) = None\"", "lemma fixes e :: \"('a, 'b, 'addr) exp\" and es :: \"('a, 'b, 'addr) exp list\"\n  shows call1_imp_call: \"call1 e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow> call e = \\<lfloor>aMvs\\<rfloor>\"\n  and calls1_imp_calls: \"calls1 es = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow> calls es = \\<lfloor>aMvs\\<rfloor>\"", "lemma max_vars_inline_call: \"max_vars (inline_call e' e) \\<le> max_vars e + max_vars e'\"\n  and max_varss_inline_calls: \"max_varss (inline_calls e' es) \\<le> max_varss es + max_vars e'\"", "lemmas inline_call_max_vars1 = max_vars_inline_call", "lemmas inline_calls_max_varss1 = max_varss_inline_calls"], "translations": [["", "lemma expr_locks_blocks1 [simp]:\n  \"expr_locks (blocks1 n Ts e) = expr_locks e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expr_locks (blocks1 n Ts e) = expr_locks e", "by(induct n Ts e rule: blocks1.induct) simp_all"], ["", "lemma max_varss_append [simp]:\n  \"max_varss (es @ es') = max (max_varss es) (max_varss es')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_varss (es @ es') = max (max_varss es) (max_varss es')", "by(induct es, auto)"], ["", "lemma max_varss_map_Val [simp]: \"max_varss (map Val vs) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_varss (map Val vs) = 0", "by(induct vs) auto"], ["", "lemma blocks1_max_vars:\n  \"max_vars (blocks1 n Ts e) = max_vars e + length Ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_vars (blocks1 n Ts e) = max_vars e + length Ts", "by(induct n Ts e rule: blocks1.induct)(auto)"], ["", "lemma blocks_max_vars:\n  \"\\<lbrakk> length vs = length pns; length Ts = length pns \\<rbrakk>\n  \\<Longrightarrow> max_vars (blocks pns Ts vs e) = max_vars e + length pns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length vs = length pns; length Ts = length pns\\<rbrakk>\n    \\<Longrightarrow> max_vars (blocks pns Ts vs e) =\n                      max_vars e + length pns", "by(induct pns Ts vs e rule: blocks.induct)(auto)"], ["", "lemma Bs_append [simp]: \"\\<B>s (es @ es') n \\<longleftrightarrow> \\<B>s es n \\<and> \\<B>s es' n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<B>s (es @ es') n = (\\<B>s es n \\<and> \\<B>s es' n)", "by(induct es) auto"], ["", "lemma Bs_map_Val [simp]: \"\\<B>s (map Val vs) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<B>s (map Val vs) n", "by(induct vs) auto"], ["", "lemma B_blocks1 [intro]: \"\\<B> body (n + length Ts) \\<Longrightarrow> \\<B> (blocks1 n Ts body) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<B> body (n + length Ts) \\<Longrightarrow> \\<B> (blocks1 n Ts body) n", "by(induct n Ts body rule: blocks1.induct)(auto)"], ["", "lemma B_extRet2J [simp]: \"\\<B> e n \\<Longrightarrow> \\<B> (extRet2J e va) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<B> e n \\<Longrightarrow> \\<B> (extRet2J e va) n", "by(cases va) auto"], ["", "lemma B_inline_call: \"\\<lbrakk> \\<B> e n; \\<And>n. \\<B> e' n \\<rbrakk> \\<Longrightarrow> \\<B> (inline_call e' e) n\"\n  and Bs_inline_calls: \"\\<lbrakk> \\<B>s es n; \\<And>n. \\<B> e' n \\<rbrakk> \\<Longrightarrow> \\<B>s (inline_calls e' es) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<B> e n; \\<And>n. \\<B> e' n\\<rbrakk>\n     \\<Longrightarrow> \\<B> (inline_call e' e) n) &&&\n    (\\<lbrakk>\\<B>s es n; \\<And>n. \\<B> e' n\\<rbrakk>\n     \\<Longrightarrow> \\<B>s (inline_calls e' es) n)", "by(induct e and es arbitrary: n and n rule: call.induct calls.induct) auto"], ["", "lemma syncvarss_append [simp]: \"syncvarss (es @ es') \\<longleftrightarrow> syncvarss es \\<and> syncvarss es'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. syncvarss (es @ es') = (syncvarss es \\<and> syncvarss es')", "by(induct es) auto"], ["", "lemma syncvarss_map_Val [simp]: \"syncvarss (map Val vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. syncvarss (map Val vs)", "by(induct vs) auto"], ["", "lemma bsok_simps [simp]:\n  \"bsok (new C) n = True\"\n  \"bsok (newA T\\<lfloor>e\\<rceil>) n = bsok e n\"\n  \"bsok (Cast T e) n = bsok e n\"\n  \"bsok (e instanceof T) n = bsok e n\"\n  \"bsok (e1 \\<guillemotleft>bop\\<guillemotright> e2) n = (bsok e1 n \\<and> bsok e2 n)\"\n  \"bsok (Var V) n = True\"\n  \"bsok (Val v) n = True\"\n  \"bsok (V := e) n = bsok e n\"\n  \"bsok (a\\<lfloor>i\\<rceil>) n = (bsok a n \\<and> bsok i n)\"\n  \"bsok (a\\<lfloor>i\\<rceil> := e) n = (bsok a n \\<and> bsok i n \\<and> bsok e n)\"\n  \"bsok (a\\<bullet>length) n = bsok a n\"\n  \"bsok (e\\<bullet>F{D}) n = bsok e n\"\n  \"bsok (e\\<bullet>F{D} := e') n = (bsok e n \\<and> bsok e' n)\"\n  \"bsok (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) n = (bsok e n \\<and> bsok e' n \\<and> bsok e'' n)\"\n  \"bsok (e\\<bullet>M(ps)) n = (bsok e n \\<and> bsoks ps n)\"\n  \"bsok {V:T=vo; e} n = (bsok e (Suc n) \\<and> V = n)\"\n  \"bsok (sync\\<^bsub>V\\<^esub> (e) e') n = (bsok e n \\<and> bsok e' (Suc n) \\<and> V = n)\"\n  \"bsok (insync\\<^bsub>V\\<^esub> (ad) e) n = False\"\n  \"bsok (e;; e') n = (bsok e n \\<and> bsok e' n)\"\n  \"bsok (if (e) e1 else e2) n = (bsok e n \\<and> bsok e1 n \\<and> bsok e2 n)\"\n  \"bsok (while (b) c) n = (bsok b n \\<and> bsok c n)\"\n  \"bsok (throw e) n = bsok e n\"\n  \"bsok (try e catch(C V) e') n = (bsok e n \\<and> bsok e' (Suc n) \\<and> V = n)\"\n  and bsoks_simps [simp]:\n  \"bsoks [] n = True\"\n  \"bsoks (e # es) n = (bsok e n \\<and> bsoks es n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((((bsok (new C) n = True &&&\n        bsok (newA T\\<lfloor>e\\<rceil>) n = bsok e n) &&&\n       bsok (Cast T e) n = bsok e n &&&\n       bsok (e instanceof T) n = bsok e n &&&\n       bsok (e1 \\<guillemotleft>bop\\<guillemotright> e2) n =\n       (bsok e1 n \\<and> bsok e2 n)) &&&\n      (bsok (Var V) n = True &&&\n       bsok (Val v) n = True &&& bsok (V:=e) n = bsok e n) &&&\n      bsok (a\\<lfloor>i\\<rceil>) n = (bsok a n \\<and> bsok i n) &&&\n      bsok (a\\<lfloor>i\\<rceil> := e) n =\n      (bsok a n \\<and> bsok i n \\<and> bsok e n) &&&\n      bsok (a\\<bullet>length) n = bsok a n) &&&\n     ((bsok (e\\<bullet>F{D}) n = bsok e n &&&\n       bsok (e\\<bullet>F{D} := e') n = (bsok e n \\<and> bsok e' n) &&&\n       bsok (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) n =\n       (bsok e n \\<and> bsok e' n \\<and> bsok e'' n)) &&&\n      bsok (e\\<bullet>M(ps)) n = (bsok e n \\<and> bsoks ps n) &&&\n      bsok {V:T=vo; e} n = (bsok e (Suc n) \\<and> V = n) &&&\n      bsok (sync\\<^bsub>V\\<^esub> (e) e') n =\n      (bsok e n \\<and> bsok e' (Suc n) \\<and> V = n)) &&&\n     (bsok (insync\\<^bsub>V\\<^esub> (ad) e) n = False &&&\n      bsok (e;; e') n = (bsok e n \\<and> bsok e' n) &&&\n      bsok (if (e) e1 else e2) n =\n      (bsok e n \\<and> bsok e1 n \\<and> bsok e2 n)) &&&\n     bsok (while (b) c) n = (bsok b n \\<and> bsok c n) &&&\n     bsok (throw e) n = bsok e n &&&\n     bsok (try e catch(C V) e') n =\n     (bsok e n \\<and> bsok e' (Suc n) \\<and> V = n)) &&&\n    bsoks [] n = True &&& bsoks (e # es) n = (bsok e n \\<and> bsoks es n)", "by(auto simp add: bsok_def bsoks_def fun_eq_iff)"], ["", "lemma call1_callE:\n  assumes \"call1 (obj\\<bullet>M(pns)) = \\<lfloor>(a, M', vs)\\<rfloor>\"\n  obtains (CallObj) \"call1 obj = \\<lfloor>(a, M', vs)\\<rfloor>\"\n  | (CallParams) v where \"obj = Val v\" \"calls1 pns = \\<lfloor>(a, M', vs)\\<rfloor>\"\n  | (Call) \"obj = addr a\" \"pns = map Val vs\" \"M = M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>call1 obj = \\<lfloor>(a, M', vs)\\<rfloor> \\<Longrightarrow>\n             thesis;\n     \\<And>v.\n        \\<lbrakk>obj = Val v;\n         calls1 pns = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<lbrakk>obj = addr a; pns = map Val vs; M = M'\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  call1 (obj\\<bullet>M(pns)) = \\<lfloor>(a, M', vs)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>call1 obj = \\<lfloor>(a, M', vs)\\<rfloor> \\<Longrightarrow>\n             thesis;\n     \\<And>v.\n        \\<lbrakk>obj = Val v;\n         calls1 pns = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<lbrakk>obj = addr a; pns = map Val vs; M = M'\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(auto split: if_split_asm simp add: is_vals_conv)"], ["", "lemma calls1_map_Val_append [simp]:\n  \"calls1 (map Val vs @ es) = calls1 es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. calls1 (map Val vs @ es) = calls1 es", "by(induct vs) simp_all"], ["", "lemma calls1_map_Val [simp]:\n  \"calls1 (map Val vs) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. calls1 (map Val vs) = None", "by(induct vs) simp_all"], ["", "lemma fixes e :: \"('a, 'b, 'addr) exp\" and es :: \"('a, 'b, 'addr) exp list\"\n  shows call1_imp_call: \"call1 e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow> call e = \\<lfloor>aMvs\\<rfloor>\"\n  and calls1_imp_calls: \"calls1 es = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow> calls es = \\<lfloor>aMvs\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (call1 e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n     call e = \\<lfloor>aMvs\\<rfloor>) &&&\n    (calls1 es = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n     calls es = \\<lfloor>aMvs\\<rfloor>)", "by(induct e and es rule: call1.induct calls1.induct) auto"], ["", "lemma max_vars_inline_call: \"max_vars (inline_call e' e) \\<le> max_vars e + max_vars e'\"\n  and max_varss_inline_calls: \"max_varss (inline_calls e' es) \\<le> max_varss es + max_vars e'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_vars (inline_call e' e) \\<le> max_vars e + max_vars e' &&&\n    max_varss (inline_calls e' es) \\<le> max_varss es + max_vars e'", "by(induct e and es rule: call1.induct calls1.induct) auto"], ["", "lemmas inline_call_max_vars1 = max_vars_inline_call"], ["", "lemmas inline_calls_max_varss1 = max_varss_inline_calls"], ["", "end"]]}