{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Compiler/Correctness2.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma bisim1_list1_has_methodD: \"bisim1_list1 t h ex exs xcp ((stk, loc, C, M, pc) # frs) \\<Longrightarrow> P \\<turnstile> C has M\"", "lemma \\<tau>exec_1_d_silent_move:\n  \"\\<tau>exec_1_d P t (xcp, h, frs) (xcp', h', frs')\n  \\<Longrightarrow> \\<tau>trsys.silent_move (mexecd P t) (\\<tau>MOVE2 P) ((xcp, frs), h) ((xcp', frs'), h')\"", "lemma silent_move_\\<tau>exec_1_d:\n  \"\\<tau>trsys.silent_move (mexecd P t) (\\<tau>MOVE2 P) ((xcp, frs), h) ((xcp', frs'), h')\n  \\<Longrightarrow> \\<tau>exec_1_d P t (xcp, h, frs) (xcp', h', frs')\"", "lemma \\<tau>Exec_1_dr_rtranclpD:\n  \"\\<tau>Exec_1_dr P t (xcp, h, frs) (xcp', h', frs')\n  \\<Longrightarrow> \\<tau>trsys.silent_moves (mexecd P t) (\\<tau>MOVE2 P) ((xcp, frs), h) ((xcp', frs'), h')\"", "lemma \\<tau>Exec_1_dt_tranclpD:\n  \"\\<tau>Exec_1_dt P t (xcp, h, frs) (xcp', h', frs')\n  \\<Longrightarrow> \\<tau>trsys.silent_movet (mexecd P t) (\\<tau>MOVE2 P) ((xcp, frs), h) ((xcp', frs'), h')\"", "lemma rtranclp_\\<tau>Exec_1_dr:\n  \"\\<tau>trsys.silent_moves (mexecd P t) (\\<tau>MOVE2 P) ((xcp, frs), h) ((xcp', frs'), h')\n  \\<Longrightarrow> \\<tau>Exec_1_dr P t (xcp, h, frs) (xcp', h', frs')\"", "lemma tranclp_\\<tau>Exec_1_dt:\n  \"\\<tau>trsys.silent_movet (mexecd P t) (\\<tau>MOVE2 P) ((xcp, frs), h) ((xcp', frs'), h')\n  \\<Longrightarrow> \\<tau>Exec_1_dt P t (xcp, h, frs) (xcp', h', frs')\"", "lemma \\<tau>Exec_1_dr_conv_rtranclp:\n  \"\\<tau>Exec_1_dr P t (xcp, h, frs) (xcp', h', frs') = \n  \\<tau>trsys.silent_moves (mexecd P t) (\\<tau>MOVE2 P) ((xcp, frs), h) ((xcp', frs'), h')\"", "lemma \\<tau>Exec_1_dt_conv_tranclp:\n  \"\\<tau>Exec_1_dt P t (xcp, h, frs) (xcp', h', frs') = \n  \\<tau>trsys.silent_movet (mexecd P t) (\\<tau>MOVE2 P) ((xcp, frs), h) ((xcp', frs'), h')\"", "lemma Red1_execd_weak_bisim:\n  assumes wf: \"wf_J1_prog P\"\n  shows \"delay_bisimulation_measure (mred1 P t) (mexecd (compP2 P) t) (wbisim1 t) (ta_bisim wbisim1) (\\<tau>MOVE1 P) (\\<tau>MOVE2 (compP2 P)) (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h'). sim12_size e < sim12_size e') (\\<lambda>(xcpfrs, h) (xcpfrs', h). sim21_size (compP2 P) xcpfrs xcpfrs')\"", "lemma Red1_execd_delay_bisim:\n  assumes wf: \"wf_J1_prog P\"\n  shows \"delay_bisimulation_diverge (mred1 P t) (mexecd (compP2 P) t) (wbisim1 t) (ta_bisim wbisim1) (\\<tau>MOVE1 P) (\\<tau>MOVE2 (compP2 P))\"", "theorem Red1_exec1_FWwbisim:\n  assumes wf: \"wf_J1_prog P\"\n  shows \"FWdelay_bisimulation_diverge final_expr1 (mred1 P) JVM_final (mexecd (compP2 P)) wbisim1 (bisim_wait1JVM (compP2 P)) (\\<tau>MOVE1 P) (\\<tau>MOVE2 (compP2 P))\"", "lemma bisim_J1_JVM_start:\n  assumes wf: \"wf_J1_prog P\"\n  and wf_start: \"wf_start_state P C M vs\"\n  shows \"Red1_execd.mbisim (J1_start_state P C M vs) (JVM_start_state (compP2 P) C M vs)\"", "lemmas \\<tau>red1_Val_simps = \\<tau>red1r_Val \\<tau>red1t_Val \\<tau>reds1r_map_Val \\<tau>reds1t_map_Val"], "translations": [["", "lemma bisim1_list1_has_methodD: \"bisim1_list1 t h ex exs xcp ((stk, loc, C, M, pc) # frs) \\<Longrightarrow> P \\<turnstile> C has M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisim1_list1 t h ex exs xcp\n     ((stk, loc, C, M, pc) # frs) \\<Longrightarrow>\n    P \\<turnstile> C has M", "by(fastforce elim!: bisim1_list1.cases intro: has_methodI)"], ["", "end"], ["", "declare compP_has_method [simp]"], ["", "sublocale J1_JVM_heap_conf_base < Red1_exec: \n  delay_bisimulation_base \"mred1 P t\" \"mexec (compP2 P) t\" \"wbisim1 t\" \"ta_bisim wbisim1\" \"\\<tau>MOVE1 P\" \"\\<tau>MOVE2 (compP2 P)\" \n  for t"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sublocale J1_JVM_heap_conf_base < Red1_execd: delay_bisimulation_base\n  \"mred1 P t\"\n  \"mexecd (compP2 P) t\"\n  \"wbisim1 t\"\n  \"ta_bisim wbisim1\" \n  \"\\<tau>MOVE1 P\"\n  \"\\<tau>MOVE2 (compP2 P)\" \n  for t"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "context JVM_heap_base begin"], ["", "lemma \\<tau>exec_1_d_silent_move:\n  \"\\<tau>exec_1_d P t (xcp, h, frs) (xcp', h', frs')\n  \\<Longrightarrow> \\<tau>trsys.silent_move (mexecd P t) (\\<tau>MOVE2 P) ((xcp, frs), h) ((xcp', frs'), h')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_1_d P t (xcp, h, frs) (xcp', h', frs') \\<Longrightarrow>\n    execd_mthr.silent_move P t ((xcp, frs), h) ((xcp', frs'), h')", "apply(rule \\<tau>trsys.silent_move.intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<tau>exec_1_d P t (xcp, h, frs) (xcp', h', frs') \\<Longrightarrow>\n    execd_mthr.r_syntax P t (xcp, frs) h ?tl (xcp', frs') h'\n 2. \\<tau>exec_1_d P t (xcp, h, frs) (xcp', h', frs') \\<Longrightarrow>\n    (case ((xcp, frs), h) of\n     (x, xa) \\<Rightarrow>\n       (case x of\n        (xcp, frs) \\<Rightarrow>\n          \\<lambda>h ta s.\n             \\<tau>Move2 P (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n        xa)\n     ?tl ((xcp', frs'), h')", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_1_d P t (xcp, h, frs) (xcp', h', frs') \\<Longrightarrow>\n    P,t \\<turnstile> Normal\n                      (xcp, h,\n                       frs) -\\<lbrace>\\<rbrace>-jvmd\\<rightarrow> Normal\n                             (xcp', h', frs')", "apply(rule exec_1_d_NormalI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<tau>exec_1_d P t (xcp, h, frs) (xcp', h', frs') \\<Longrightarrow>\n    exec_d P t (xcp, h, frs) = Normal ?\\<Sigma>11\n 2. \\<tau>exec_1_d P t (xcp, h, frs) (xcp', h', frs') \\<Longrightarrow>\n    (\\<lbrace>\\<rbrace>, xcp', h', frs') \\<in> ?\\<Sigma>11", "apply(auto simp add: exec_1_iff exec_d_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma silent_move_\\<tau>exec_1_d:\n  \"\\<tau>trsys.silent_move (mexecd P t) (\\<tau>MOVE2 P) ((xcp, frs), h) ((xcp', frs'), h')\n  \\<Longrightarrow> \\<tau>exec_1_d P t (xcp, h, frs) (xcp', h', frs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execd_mthr.silent_move P t ((xcp, frs), h)\n     ((xcp', frs'), h') \\<Longrightarrow>\n    \\<tau>exec_1_d P t (xcp, h, frs) (xcp', h', frs')", "apply(erule \\<tau>trsys.silent_move.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' tl.\n       \\<lbrakk>((xcp, frs), h) = s; ((xcp', frs'), h') = s';\n        mexecd P t s tl s';\n        (case s of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (xcp, frs) \\<Rightarrow>\n              \\<lambda>h ta s.\n                 \\<tau>Move2 P (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n            xa)\n         tl s'\\<rbrakk>\n       \\<Longrightarrow> \\<tau>exec_1_d P t (xcp, h, frs) (xcp', h', frs')", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,t \\<turnstile> Normal\n                               (xcp, h,\n                                frs) -\\<lbrace>\\<rbrace>-jvmd\\<rightarrow> Normal\n(xcp', h', frs');\n     \\<tau>Move2 P (xcp, h, frs)\\<rbrakk>\n    \\<Longrightarrow> \\<tau>exec_1_d P t (xcp, h, frs) (xcp', h', frs')", "apply(erule jvmd_NormalE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xcpa ha f frsa.\n       \\<lbrakk>\\<tau>Move2 P (xcp, h, frs); check P (xcp, h, frs);\n        (\\<lbrace>\\<rbrace>, xcp', h', frs') \\<in> exec P t (xcp, h, frs);\n        (xcp, h, frs) = (xcpa, ha, f # frsa)\\<rbrakk>\n       \\<Longrightarrow> \\<tau>exec_1_d P t (xcp, h, frs) (xcp', h', frs')", "apply(auto simp add: exec_1_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \\<tau>Exec_1_dr_rtranclpD:\n  \"\\<tau>Exec_1_dr P t (xcp, h, frs) (xcp', h', frs')\n  \\<Longrightarrow> \\<tau>trsys.silent_moves (mexecd P t) (\\<tau>MOVE2 P) ((xcp, frs), h) ((xcp', frs'), h')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_1_dr P t (xcp, h, frs) (xcp', h', frs') \\<Longrightarrow>\n    execd_mthr.silent_moves P t ((xcp, frs), h) ((xcp', frs'), h')", "by(induct rule: rtranclp_induct3)(blast intro: rtranclp.rtrancl_into_rtrancl \\<tau>exec_1_d_silent_move)+"], ["", "lemma \\<tau>Exec_1_dt_tranclpD:\n  \"\\<tau>Exec_1_dt P t (xcp, h, frs) (xcp', h', frs')\n  \\<Longrightarrow> \\<tau>trsys.silent_movet (mexecd P t) (\\<tau>MOVE2 P) ((xcp, frs), h) ((xcp', frs'), h')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_1_dt P t (xcp, h, frs) (xcp', h', frs') \\<Longrightarrow>\n    execd_mthr.silent_movet P t ((xcp, frs), h) ((xcp', frs'), h')", "by(induct rule: tranclp_induct3)(blast intro: tranclp.trancl_into_trancl \\<tau>exec_1_d_silent_move)+"], ["", "lemma rtranclp_\\<tau>Exec_1_dr:\n  \"\\<tau>trsys.silent_moves (mexecd P t) (\\<tau>MOVE2 P) ((xcp, frs), h) ((xcp', frs'), h')\n  \\<Longrightarrow> \\<tau>Exec_1_dr P t (xcp, h, frs) (xcp', h', frs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execd_mthr.silent_moves P t ((xcp, frs), h)\n     ((xcp', frs'), h') \\<Longrightarrow>\n    \\<tau>Exec_1_dr P t (xcp, h, frs) (xcp', h', frs')", "by(induct rule: rtranclp_induct[of _ \"((ax, ay), az)\" \"((bx, by), bz)\", split_rule, consumes 1])(blast intro: rtranclp.rtrancl_into_rtrancl silent_move_\\<tau>exec_1_d)+"], ["", "lemma tranclp_\\<tau>Exec_1_dt:\n  \"\\<tau>trsys.silent_movet (mexecd P t) (\\<tau>MOVE2 P) ((xcp, frs), h) ((xcp', frs'), h')\n  \\<Longrightarrow> \\<tau>Exec_1_dt P t (xcp, h, frs) (xcp', h', frs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execd_mthr.silent_movet P t ((xcp, frs), h)\n     ((xcp', frs'), h') \\<Longrightarrow>\n    \\<tau>Exec_1_dt P t (xcp, h, frs) (xcp', h', frs')", "by(induct rule: tranclp_induct[of _ \"((ax, ay), az)\" \"((bx, by), bz)\", split_rule, consumes 1])(blast intro: tranclp.trancl_into_trancl silent_move_\\<tau>exec_1_d)+"], ["", "lemma \\<tau>Exec_1_dr_conv_rtranclp:\n  \"\\<tau>Exec_1_dr P t (xcp, h, frs) (xcp', h', frs') = \n  \\<tau>trsys.silent_moves (mexecd P t) (\\<tau>MOVE2 P) ((xcp, frs), h) ((xcp', frs'), h')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_1_dr P t (xcp, h, frs) (xcp', h', frs') =\n    execd_mthr.silent_moves P t ((xcp, frs), h) ((xcp', frs'), h')", "by(blast intro: \\<tau>Exec_1_dr_rtranclpD rtranclp_\\<tau>Exec_1_dr)"], ["", "lemma \\<tau>Exec_1_dt_conv_tranclp:\n  \"\\<tau>Exec_1_dt P t (xcp, h, frs) (xcp', h', frs') = \n  \\<tau>trsys.silent_movet (mexecd P t) (\\<tau>MOVE2 P) ((xcp, frs), h) ((xcp', frs'), h')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_1_dt P t (xcp, h, frs) (xcp', h', frs') =\n    execd_mthr.silent_movet P t ((xcp, frs), h) ((xcp', frs'), h')", "by(blast intro: \\<tau>Exec_1_dt_tranclpD tranclp_\\<tau>Exec_1_dt)"], ["", "end"], ["", "context J1_JVM_conf_read begin"], ["", "lemma Red1_execd_weak_bisim:\n  assumes wf: \"wf_J1_prog P\"\n  shows \"delay_bisimulation_measure (mred1 P t) (mexecd (compP2 P) t) (wbisim1 t) (ta_bisim wbisim1) (\\<tau>MOVE1 P) (\\<tau>MOVE2 (compP2 P)) (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h'). sim12_size e < sim12_size e') (\\<lambda>(xcpfrs, h) (xcpfrs', h). sim21_size (compP2 P) xcpfrs xcpfrs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_measure (mred1 P t) (mexecd (compP2 P) t) (wbisim1 t)\n     (ta_bisim wbisim1)\n     (\\<lambda>(exexs, h) ta s.\n         \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n     (\\<lambda>((xcp, frs), h) ta s.\n         \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n         ta = \\<lbrace>\\<rbrace>)\n     (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n         sim12_size e < sim12_size e')\n     (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n         sim21_size (compP2 P) xcpfrs xcpfrs')", "proof"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. \\<And>s1 s2 s1'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        Red1_mthr.silent_move True P t s1 s1'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1' s2 \\<and>\n                         (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'),\n                             h').\n                             sim12_size e < sim12_size e')\\<^sup>+\\<^sup>+\n                          s1' s1 \\<or>\n                         (\\<exists>s2'.\n                             execd_mthr.silent_movet (compP2 P) t s2\n                              s2' \\<and>\n                             wbisim1 t s1' s2')\n 4. \\<And>s1 s2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        execd_mthr.silent_move (compP2 P) t s2 s2'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1 s2' \\<and>\n                         (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n                             sim21_size (compP2 P) xcpfrs\n                              xcpfrs')\\<^sup>+\\<^sup>+\n                          s2' s2 \\<or>\n                         (\\<exists>s1'.\n                             Red1_mthr.silent_movet True P t s1 s1' \\<and>\n                             wbisim1 t s1' s2')\n 5. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 6. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "fix s1 s2 s1'"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. \\<And>s1 s2 s1'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        Red1_mthr.silent_move True P t s1 s1'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1' s2 \\<and>\n                         (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'),\n                             h').\n                             sim12_size e < sim12_size e')\\<^sup>+\\<^sup>+\n                          s1' s1 \\<or>\n                         (\\<exists>s2'.\n                             execd_mthr.silent_movet (compP2 P) t s2\n                              s2' \\<and>\n                             wbisim1 t s1' s2')\n 4. \\<And>s1 s2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        execd_mthr.silent_move (compP2 P) t s2 s2'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1 s2' \\<and>\n                         (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n                             sim21_size (compP2 P) xcpfrs\n                              xcpfrs')\\<^sup>+\\<^sup>+\n                          s2' s2 \\<or>\n                         (\\<exists>s1'.\n                             Red1_mthr.silent_movet True P t s1 s1' \\<and>\n                             wbisim1 t s1' s2')\n 5. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 6. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "assume \"wbisim1 t s1 s2\" and \"\\<tau>trsys.silent_move (mred1 P t) (\\<tau>MOVE1 P) s1 s1'\""], ["proof (state)\nthis:\n  wbisim1 t s1 s2\n  Red1_mthr.silent_move True P t s1 s1'\n\ngoal (6 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. \\<And>s1 s2 s1'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        Red1_mthr.silent_move True P t s1 s1'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1' s2 \\<and>\n                         (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'),\n                             h').\n                             sim12_size e < sim12_size e')\\<^sup>+\\<^sup>+\n                          s1' s1 \\<or>\n                         (\\<exists>s2'.\n                             execd_mthr.silent_movet (compP2 P) t s2\n                              s2' \\<and>\n                             wbisim1 t s1' s2')\n 4. \\<And>s1 s2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        execd_mthr.silent_move (compP2 P) t s2 s2'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1 s2' \\<and>\n                         (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n                             sim21_size (compP2 P) xcpfrs\n                              xcpfrs')\\<^sup>+\\<^sup>+\n                          s2' s2 \\<or>\n                         (\\<exists>s1'.\n                             Red1_mthr.silent_movet True P t s1 s1' \\<and>\n                             wbisim1 t s1' s2')\n 5. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 6. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "moreover"], ["proof (state)\nthis:\n  wbisim1 t s1 s2\n  Red1_mthr.silent_move True P t s1 s1'\n\ngoal (6 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. \\<And>s1 s2 s1'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        Red1_mthr.silent_move True P t s1 s1'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1' s2 \\<and>\n                         (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'),\n                             h').\n                             sim12_size e < sim12_size e')\\<^sup>+\\<^sup>+\n                          s1' s1 \\<or>\n                         (\\<exists>s2'.\n                             execd_mthr.silent_movet (compP2 P) t s2\n                              s2' \\<and>\n                             wbisim1 t s1' s2')\n 4. \\<And>s1 s2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        execd_mthr.silent_move (compP2 P) t s2 s2'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1 s2' \\<and>\n                         (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n                             sim21_size (compP2 P) xcpfrs\n                              xcpfrs')\\<^sup>+\\<^sup>+\n                          s2' s2 \\<or>\n                         (\\<exists>s1'.\n                             Red1_mthr.silent_movet True P t s1 s1' \\<and>\n                             wbisim1 t s1' s2')\n 5. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 6. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "obtain e xs exs h where s1: \"s1 = (((e, xs), exs), h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e xs exs h.\n        s1 = (((e, xs), exs), h) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s1) auto"], ["proof (state)\nthis:\n  s1 = (((e, xs), exs), h)\n\ngoal (6 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. \\<And>s1 s2 s1'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        Red1_mthr.silent_move True P t s1 s1'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1' s2 \\<and>\n                         (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'),\n                             h').\n                             sim12_size e < sim12_size e')\\<^sup>+\\<^sup>+\n                          s1' s1 \\<or>\n                         (\\<exists>s2'.\n                             execd_mthr.silent_movet (compP2 P) t s2\n                              s2' \\<and>\n                             wbisim1 t s1' s2')\n 4. \\<And>s1 s2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        execd_mthr.silent_move (compP2 P) t s2 s2'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1 s2' \\<and>\n                         (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n                             sim21_size (compP2 P) xcpfrs\n                              xcpfrs')\\<^sup>+\\<^sup>+\n                          s2' s2 \\<or>\n                         (\\<exists>s1'.\n                             Red1_mthr.silent_movet True P t s1 s1' \\<and>\n                             wbisim1 t s1' s2')\n 5. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 6. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "moreover"], ["proof (state)\nthis:\n  s1 = (((e, xs), exs), h)\n\ngoal (6 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. \\<And>s1 s2 s1'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        Red1_mthr.silent_move True P t s1 s1'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1' s2 \\<and>\n                         (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'),\n                             h').\n                             sim12_size e < sim12_size e')\\<^sup>+\\<^sup>+\n                          s1' s1 \\<or>\n                         (\\<exists>s2'.\n                             execd_mthr.silent_movet (compP2 P) t s2\n                              s2' \\<and>\n                             wbisim1 t s1' s2')\n 4. \\<And>s1 s2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        execd_mthr.silent_move (compP2 P) t s2 s2'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1 s2' \\<and>\n                         (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n                             sim21_size (compP2 P) xcpfrs\n                              xcpfrs')\\<^sup>+\\<^sup>+\n                          s2' s2 \\<or>\n                         (\\<exists>s1'.\n                             Red1_mthr.silent_movet True P t s1 s1' \\<and>\n                             wbisim1 t s1' s2')\n 5. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 6. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "obtain e' xs' exs' h1' where s1': \"s1' = (((e', xs'), exs'), h1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e' xs' exs' h1'.\n        s1' = (((e', xs'), exs'), h1') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases s1') auto"], ["proof (state)\nthis:\n  s1' = (((e', xs'), exs'), h1')\n\ngoal (6 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. \\<And>s1 s2 s1'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        Red1_mthr.silent_move True P t s1 s1'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1' s2 \\<and>\n                         (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'),\n                             h').\n                             sim12_size e < sim12_size e')\\<^sup>+\\<^sup>+\n                          s1' s1 \\<or>\n                         (\\<exists>s2'.\n                             execd_mthr.silent_movet (compP2 P) t s2\n                              s2' \\<and>\n                             wbisim1 t s1' s2')\n 4. \\<And>s1 s2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        execd_mthr.silent_move (compP2 P) t s2 s2'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1 s2' \\<and>\n                         (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n                             sim21_size (compP2 P) xcpfrs\n                              xcpfrs')\\<^sup>+\\<^sup>+\n                          s2' s2 \\<or>\n                         (\\<exists>s1'.\n                             Red1_mthr.silent_movet True P t s1 s1' \\<and>\n                             wbisim1 t s1' s2')\n 5. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 6. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "moreover"], ["proof (state)\nthis:\n  s1' = (((e', xs'), exs'), h1')\n\ngoal (6 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. \\<And>s1 s2 s1'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        Red1_mthr.silent_move True P t s1 s1'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1' s2 \\<and>\n                         (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'),\n                             h').\n                             sim12_size e < sim12_size e')\\<^sup>+\\<^sup>+\n                          s1' s1 \\<or>\n                         (\\<exists>s2'.\n                             execd_mthr.silent_movet (compP2 P) t s2\n                              s2' \\<and>\n                             wbisim1 t s1' s2')\n 4. \\<And>s1 s2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        execd_mthr.silent_move (compP2 P) t s2 s2'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1 s2' \\<and>\n                         (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n                             sim21_size (compP2 P) xcpfrs\n                              xcpfrs')\\<^sup>+\\<^sup>+\n                          s2' s2 \\<or>\n                         (\\<exists>s1'.\n                             Red1_mthr.silent_movet True P t s1 s1' \\<and>\n                             wbisim1 t s1' s2')\n 5. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 6. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "obtain xcp frs h2 where s2: \"s2 = ((xcp, frs), h2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xcp frs h2.\n        s2 = ((xcp, frs), h2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s2) auto"], ["proof (state)\nthis:\n  s2 = ((xcp, frs), h2)\n\ngoal (6 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. \\<And>s1 s2 s1'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        Red1_mthr.silent_move True P t s1 s1'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1' s2 \\<and>\n                         (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'),\n                             h').\n                             sim12_size e < sim12_size e')\\<^sup>+\\<^sup>+\n                          s1' s1 \\<or>\n                         (\\<exists>s2'.\n                             execd_mthr.silent_movet (compP2 P) t s2\n                              s2' \\<and>\n                             wbisim1 t s1' s2')\n 4. \\<And>s1 s2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        execd_mthr.silent_move (compP2 P) t s2 s2'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1 s2' \\<and>\n                         (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n                             sim21_size (compP2 P) xcpfrs\n                              xcpfrs')\\<^sup>+\\<^sup>+\n                          s2' s2 \\<or>\n                         (\\<exists>s1'.\n                             Red1_mthr.silent_movet True P t s1 s1' \\<and>\n                             wbisim1 t s1' s2')\n 5. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 6. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "ultimately"], ["proof (chain)\npicking this:\n  wbisim1 t s1 s2\n  Red1_mthr.silent_move True P t s1 s1'\n  s1 = (((e, xs), exs), h)\n  s1' = (((e', xs'), exs'), h1')\n  s2 = ((xcp, frs), h2)", "have [simp]: \"h2 = h\" and red: \"True,P,t \\<turnstile>1 \\<langle>(e, xs)/exs,h\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>(e', xs')/exs',h1'\\<rangle>\"\n    and \\<tau>: \"\\<tau>Move1 P h ((e, xs), exs)\" and bisim: \"bisim1_list1 t h (e, xs) exs xcp frs\""], ["proof (prove)\nusing this:\n  wbisim1 t s1 s2\n  Red1_mthr.silent_move True P t s1 s1'\n  s1 = (((e, xs), exs), h)\n  s1' = (((e', xs'), exs'), h1')\n  s2 = ((xcp, frs), h2)\n\ngoal (1 subgoal):\n 1. (h2 = h &&&\n     True,P,t \\<turnstile>1 \\<langle>(e, xs)/exs,\n                             h\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                            \\<langle>(e', xs')/exs',h1'\\<rangle>) &&&\n    \\<tau>Move1 P h ((e, xs), exs) &&& bisim1_list1 t h (e, xs) exs xcp frs", "by(auto)"], ["proof (state)\nthis:\n  h2 = h\n  True,P,t \\<turnstile>1 \\<langle>(e, xs)/exs,\n                          h\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                         \\<langle>(e', xs')/exs',h1'\\<rangle>\n  \\<tau>Move1 P h ((e, xs), exs)\n  bisim1_list1 t h (e, xs) exs xcp frs\n\ngoal (6 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. \\<And>s1 s2 s1'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        Red1_mthr.silent_move True P t s1 s1'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1' s2 \\<and>\n                         (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'),\n                             h').\n                             sim12_size e < sim12_size e')\\<^sup>+\\<^sup>+\n                          s1' s1 \\<or>\n                         (\\<exists>s2'.\n                             execd_mthr.silent_movet (compP2 P) t s2\n                              s2' \\<and>\n                             wbisim1 t s1' s2')\n 4. \\<And>s1 s2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        execd_mthr.silent_move (compP2 P) t s2 s2'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1 s2' \\<and>\n                         (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n                             sim21_size (compP2 P) xcpfrs\n                              xcpfrs')\\<^sup>+\\<^sup>+\n                          s2' s2 \\<or>\n                         (\\<exists>s1'.\n                             Red1_mthr.silent_movet True P t s1 s1' \\<and>\n                             wbisim1 t s1' s2')\n 5. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 6. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "from red \\<tau> bisim"], ["proof (chain)\npicking this:\n  True,P,t \\<turnstile>1 \\<langle>(e, xs)/exs,\n                          h\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                         \\<langle>(e', xs')/exs',h1'\\<rangle>\n  \\<tau>Move1 P h ((e, xs), exs)\n  bisim1_list1 t h (e, xs) exs xcp frs", "have h1' [simp]: \"h1' = h\""], ["proof (prove)\nusing this:\n  True,P,t \\<turnstile>1 \\<langle>(e, xs)/exs,\n                          h\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                         \\<langle>(e', xs')/exs',h1'\\<rangle>\n  \\<tau>Move1 P h ((e, xs), exs)\n  bisim1_list1 t h (e, xs) exs xcp frs\n\ngoal (1 subgoal):\n 1. h1' = h", "by(auto dest: \\<tau>move1_heap_unchanged elim!: Red1.cases bisim1_list1.cases)"], ["proof (state)\nthis:\n  h1' = h\n\ngoal (6 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. \\<And>s1 s2 s1'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        Red1_mthr.silent_move True P t s1 s1'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1' s2 \\<and>\n                         (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'),\n                             h').\n                             sim12_size e < sim12_size e')\\<^sup>+\\<^sup>+\n                          s1' s1 \\<or>\n                         (\\<exists>s2'.\n                             execd_mthr.silent_movet (compP2 P) t s2\n                              s2' \\<and>\n                             wbisim1 t s1' s2')\n 4. \\<And>s1 s2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        execd_mthr.silent_move (compP2 P) t s2 s2'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1 s2' \\<and>\n                         (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n                             sim21_size (compP2 P) xcpfrs\n                              xcpfrs')\\<^sup>+\\<^sup>+\n                          s2' s2 \\<or>\n                         (\\<exists>s1'.\n                             Red1_mthr.silent_movet True P t s1 s1' \\<and>\n                             wbisim1 t s1' s2')\n 5. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 6. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "from exec_1_simulates_Red1_\\<tau>[OF wf red[unfolded h1'] bisim \\<tau>]"], ["proof (chain)\npicking this:\n  \\<exists>xcp' frs'.\n     (if sim12_size e' < sim12_size e then \\<tau>Exec_1_dr\n      else \\<tau>Exec_1_dt)\n      (compP2 P) t (xcp, h, frs) (xcp', h, frs') \\<and>\n     bisim1_list1 t h (e', xs') exs' xcp' frs'", "obtain xcp' frs'\n    where exec: \"(if sim12_size e' < sim12_size e then \\<tau>Exec_1_dr else \\<tau>Exec_1_dt) (compP2 P) t (xcp, h, frs) (xcp', h, frs')\"\n    and bisim': \"bisim1_list1 t h (e', xs') exs' xcp' frs'\""], ["proof (prove)\nusing this:\n  \\<exists>xcp' frs'.\n     (if sim12_size e' < sim12_size e then \\<tau>Exec_1_dr\n      else \\<tau>Exec_1_dt)\n      (compP2 P) t (xcp, h, frs) (xcp', h, frs') \\<and>\n     bisim1_list1 t h (e', xs') exs' xcp' frs'\n\ngoal (1 subgoal):\n 1. (\\<And>xcp' frs'.\n        \\<lbrakk>(if sim12_size e' < sim12_size e then \\<tau>Exec_1_dr\n                  else \\<tau>Exec_1_dt)\n                  (compP2 P) t (xcp, h, frs) (xcp', h, frs');\n         bisim1_list1 t h (e', xs') exs' xcp' frs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (if sim12_size e' < sim12_size e then \\<tau>Exec_1_dr\n   else \\<tau>Exec_1_dt)\n   (compP2 P) t (xcp, h, frs) (xcp', h, frs')\n  bisim1_list1 t h (e', xs') exs' xcp' frs'\n\ngoal (6 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. \\<And>s1 s2 s1'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        Red1_mthr.silent_move True P t s1 s1'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1' s2 \\<and>\n                         (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'),\n                             h').\n                             sim12_size e < sim12_size e')\\<^sup>+\\<^sup>+\n                          s1' s1 \\<or>\n                         (\\<exists>s2'.\n                             execd_mthr.silent_movet (compP2 P) t s2\n                              s2' \\<and>\n                             wbisim1 t s1' s2')\n 4. \\<And>s1 s2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        execd_mthr.silent_move (compP2 P) t s2 s2'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1 s2' \\<and>\n                         (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n                             sim21_size (compP2 P) xcpfrs\n                              xcpfrs')\\<^sup>+\\<^sup>+\n                          s2' s2 \\<or>\n                         (\\<exists>s1'.\n                             Red1_mthr.silent_movet True P t s1 s1' \\<and>\n                             wbisim1 t s1' s2')\n 5. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 6. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "from exec"], ["proof (chain)\npicking this:\n  (if sim12_size e' < sim12_size e then \\<tau>Exec_1_dr\n   else \\<tau>Exec_1_dt)\n   (compP2 P) t (xcp, h, frs) (xcp', h, frs')", "have \"(if (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h'). sim12_size e < sim12_size e') (((e', xs'), exs'), h) (((e, xs), exs), h) then \\<tau>trsys.silent_moves (mexecd (compP2 P) t) (\\<tau>MOVE2 (compP2 P)) else \\<tau>trsys.silent_movet (mexecd (compP2 P) t) (\\<tau>MOVE2 (compP2 P))) ((xcp, frs), h) ((xcp', frs'), h)\""], ["proof (prove)\nusing this:\n  (if sim12_size e' < sim12_size e then \\<tau>Exec_1_dr\n   else \\<tau>Exec_1_dt)\n   (compP2 P) t (xcp, h, frs) (xcp', h, frs')\n\ngoal (1 subgoal):\n 1. (if (case (((e', xs'), exs'), h) of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (x, xa) \\<Rightarrow>\n              (case x of\n               (e, xs) \\<Rightarrow>\n                 \\<lambda>exs h (((e', xs'), exs'), h').\n                    sim12_size e < sim12_size e')\n               xa)\n            xa)\n         (((e, xs), exs), h)\n     then execd_mthr.silent_moves (compP2 P) t\n     else execd_mthr.silent_movet (compP2 P) t)\n     ((xcp, frs), h) ((xcp', frs'), h)", "by(auto simp add: \\<tau>Exec_1_dr_conv_rtranclp \\<tau>Exec_1_dt_conv_tranclp)"], ["proof (state)\nthis:\n  (if (case (((e', xs'), exs'), h) of\n       (x, xa) \\<Rightarrow>\n         (case x of\n          (x, xa) \\<Rightarrow>\n            (case x of\n             (e, xs) \\<Rightarrow>\n               \\<lambda>exs h (((e', xs'), exs'), h').\n                  sim12_size e < sim12_size e')\n             xa)\n          xa)\n       (((e, xs), exs), h)\n   then execd_mthr.silent_moves (compP2 P) t\n   else execd_mthr.silent_movet (compP2 P) t)\n   ((xcp, frs), h) ((xcp', frs'), h)\n\ngoal (6 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. \\<And>s1 s2 s1'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        Red1_mthr.silent_move True P t s1 s1'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1' s2 \\<and>\n                         (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'),\n                             h').\n                             sim12_size e < sim12_size e')\\<^sup>+\\<^sup>+\n                          s1' s1 \\<or>\n                         (\\<exists>s2'.\n                             execd_mthr.silent_movet (compP2 P) t s2\n                              s2' \\<and>\n                             wbisim1 t s1' s2')\n 4. \\<And>s1 s2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        execd_mthr.silent_move (compP2 P) t s2 s2'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1 s2' \\<and>\n                         (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n                             sim21_size (compP2 P) xcpfrs\n                              xcpfrs')\\<^sup>+\\<^sup>+\n                          s2' s2 \\<or>\n                         (\\<exists>s1'.\n                             Red1_mthr.silent_movet True P t s1 s1' \\<and>\n                             wbisim1 t s1' s2')\n 5. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 6. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "thus \"wbisim1 t s1' s2 \\<and> (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h'). sim12_size e < sim12_size e')\\<^sup>+\\<^sup>+ s1' s1 \\<or>\n       (\\<exists>s2'. (\\<tau>trsys.silent_movet (mexecd (compP2 P) t) (\\<tau>MOVE2 (compP2 P))) s2 s2' \\<and> wbisim1 t s1' s2')\""], ["proof (prove)\nusing this:\n  (if (case (((e', xs'), exs'), h) of\n       (x, xa) \\<Rightarrow>\n         (case x of\n          (x, xa) \\<Rightarrow>\n            (case x of\n             (e, xs) \\<Rightarrow>\n               \\<lambda>exs h (((e', xs'), exs'), h').\n                  sim12_size e < sim12_size e')\n             xa)\n          xa)\n       (((e, xs), exs), h)\n   then execd_mthr.silent_moves (compP2 P) t\n   else execd_mthr.silent_movet (compP2 P) t)\n   ((xcp, frs), h) ((xcp', frs'), h)\n\ngoal (1 subgoal):\n 1. wbisim1 t s1' s2 \\<and>\n    (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n        sim12_size e < sim12_size e')\\<^sup>+\\<^sup>+\n     s1' s1 \\<or>\n    (\\<exists>s2'.\n        execd_mthr.silent_movet (compP2 P) t s2 s2' \\<and>\n        wbisim1 t s1' s2')", "using bisim' s1 s1' s2"], ["proof (prove)\nusing this:\n  (if (case (((e', xs'), exs'), h) of\n       (x, xa) \\<Rightarrow>\n         (case x of\n          (x, xa) \\<Rightarrow>\n            (case x of\n             (e, xs) \\<Rightarrow>\n               \\<lambda>exs h (((e', xs'), exs'), h').\n                  sim12_size e < sim12_size e')\n             xa)\n          xa)\n       (((e, xs), exs), h)\n   then execd_mthr.silent_moves (compP2 P) t\n   else execd_mthr.silent_movet (compP2 P) t)\n   ((xcp, frs), h) ((xcp', frs'), h)\n  bisim1_list1 t h (e', xs') exs' xcp' frs'\n  s1 = (((e, xs), exs), h)\n  s1' = (((e', xs'), exs'), h1')\n  s2 = ((xcp, frs), h2)\n\ngoal (1 subgoal):\n 1. wbisim1 t s1' s2 \\<and>\n    (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n        sim12_size e < sim12_size e')\\<^sup>+\\<^sup>+\n     s1' s1 \\<or>\n    (\\<exists>s2'.\n        execd_mthr.silent_movet (compP2 P) t s2 s2' \\<and>\n        wbisim1 t s1' s2')", "by -(rule delay_bisimulation_base.simulation_silent1I', auto split del: if_split)"], ["proof (state)\nthis:\n  wbisim1 t s1' s2 \\<and>\n  (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n      sim12_size e < sim12_size e')\\<^sup>+\\<^sup>+\n   s1' s1 \\<or>\n  (\\<exists>s2'.\n      execd_mthr.silent_movet (compP2 P) t s2 s2' \\<and> wbisim1 t s1' s2')\n\ngoal (5 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. \\<And>s1 s2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        execd_mthr.silent_move (compP2 P) t s2 s2'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1 s2' \\<and>\n                         (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n                             sim21_size (compP2 P) xcpfrs\n                              xcpfrs')\\<^sup>+\\<^sup>+\n                          s2' s2 \\<or>\n                         (\\<exists>s1'.\n                             Red1_mthr.silent_movet True P t s1 s1' \\<and>\n                             wbisim1 t s1' s2')\n 4. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 5. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. \\<And>s1 s2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        execd_mthr.silent_move (compP2 P) t s2 s2'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1 s2' \\<and>\n                         (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n                             sim21_size (compP2 P) xcpfrs\n                              xcpfrs')\\<^sup>+\\<^sup>+\n                          s2' s2 \\<or>\n                         (\\<exists>s1'.\n                             Red1_mthr.silent_movet True P t s1 s1' \\<and>\n                             wbisim1 t s1' s2')\n 4. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 5. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "fix s1 s2 s2'"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. \\<And>s1 s2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        execd_mthr.silent_move (compP2 P) t s2 s2'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1 s2' \\<and>\n                         (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n                             sim21_size (compP2 P) xcpfrs\n                              xcpfrs')\\<^sup>+\\<^sup>+\n                          s2' s2 \\<or>\n                         (\\<exists>s1'.\n                             Red1_mthr.silent_movet True P t s1 s1' \\<and>\n                             wbisim1 t s1' s2')\n 4. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 5. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "assume \"wbisim1 t s1 s2\" and \"\\<tau>trsys.silent_move (mexecd (compP2 P) t) (\\<tau>MOVE2 (compP2 P)) s2 s2'\""], ["proof (state)\nthis:\n  wbisim1 t s1 s2\n  execd_mthr.silent_move (compP2 P) t s2 s2'\n\ngoal (5 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. \\<And>s1 s2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        execd_mthr.silent_move (compP2 P) t s2 s2'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1 s2' \\<and>\n                         (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n                             sim21_size (compP2 P) xcpfrs\n                              xcpfrs')\\<^sup>+\\<^sup>+\n                          s2' s2 \\<or>\n                         (\\<exists>s1'.\n                             Red1_mthr.silent_movet True P t s1 s1' \\<and>\n                             wbisim1 t s1' s2')\n 4. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 5. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "moreover"], ["proof (state)\nthis:\n  wbisim1 t s1 s2\n  execd_mthr.silent_move (compP2 P) t s2 s2'\n\ngoal (5 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. \\<And>s1 s2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        execd_mthr.silent_move (compP2 P) t s2 s2'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1 s2' \\<and>\n                         (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n                             sim21_size (compP2 P) xcpfrs\n                              xcpfrs')\\<^sup>+\\<^sup>+\n                          s2' s2 \\<or>\n                         (\\<exists>s1'.\n                             Red1_mthr.silent_movet True P t s1 s1' \\<and>\n                             wbisim1 t s1' s2')\n 4. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 5. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "obtain e xs exs h1 where s1: \"s1 = (((e, xs), exs), h1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e xs exs h1.\n        s1 = (((e, xs), exs), h1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases s1) auto"], ["proof (state)\nthis:\n  s1 = (((e, xs), exs), h1)\n\ngoal (5 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. \\<And>s1 s2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        execd_mthr.silent_move (compP2 P) t s2 s2'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1 s2' \\<and>\n                         (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n                             sim21_size (compP2 P) xcpfrs\n                              xcpfrs')\\<^sup>+\\<^sup>+\n                          s2' s2 \\<or>\n                         (\\<exists>s1'.\n                             Red1_mthr.silent_movet True P t s1 s1' \\<and>\n                             wbisim1 t s1' s2')\n 4. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 5. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "moreover"], ["proof (state)\nthis:\n  s1 = (((e, xs), exs), h1)\n\ngoal (5 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. \\<And>s1 s2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        execd_mthr.silent_move (compP2 P) t s2 s2'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1 s2' \\<and>\n                         (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n                             sim21_size (compP2 P) xcpfrs\n                              xcpfrs')\\<^sup>+\\<^sup>+\n                          s2' s2 \\<or>\n                         (\\<exists>s1'.\n                             Red1_mthr.silent_movet True P t s1 s1' \\<and>\n                             wbisim1 t s1' s2')\n 4. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 5. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "obtain xcp frs h where s2: \"s2 = ((xcp, frs), h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xcp frs h.\n        s2 = ((xcp, frs), h) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s2) auto"], ["proof (state)\nthis:\n  s2 = ((xcp, frs), h)\n\ngoal (5 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. \\<And>s1 s2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        execd_mthr.silent_move (compP2 P) t s2 s2'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1 s2' \\<and>\n                         (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n                             sim21_size (compP2 P) xcpfrs\n                              xcpfrs')\\<^sup>+\\<^sup>+\n                          s2' s2 \\<or>\n                         (\\<exists>s1'.\n                             Red1_mthr.silent_movet True P t s1 s1' \\<and>\n                             wbisim1 t s1' s2')\n 4. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 5. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "moreover"], ["proof (state)\nthis:\n  s2 = ((xcp, frs), h)\n\ngoal (5 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. \\<And>s1 s2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        execd_mthr.silent_move (compP2 P) t s2 s2'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1 s2' \\<and>\n                         (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n                             sim21_size (compP2 P) xcpfrs\n                              xcpfrs')\\<^sup>+\\<^sup>+\n                          s2' s2 \\<or>\n                         (\\<exists>s1'.\n                             Red1_mthr.silent_movet True P t s1 s1' \\<and>\n                             wbisim1 t s1' s2')\n 4. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 5. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "obtain xcp' frs' h2' where s2': \"s2' = ((xcp', frs'), h2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xcp' frs' h2'.\n        s2' = ((xcp', frs'), h2') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases s2') auto"], ["proof (state)\nthis:\n  s2' = ((xcp', frs'), h2')\n\ngoal (5 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. \\<And>s1 s2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        execd_mthr.silent_move (compP2 P) t s2 s2'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1 s2' \\<and>\n                         (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n                             sim21_size (compP2 P) xcpfrs\n                              xcpfrs')\\<^sup>+\\<^sup>+\n                          s2' s2 \\<or>\n                         (\\<exists>s1'.\n                             Red1_mthr.silent_movet True P t s1 s1' \\<and>\n                             wbisim1 t s1' s2')\n 4. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 5. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "ultimately"], ["proof (chain)\npicking this:\n  wbisim1 t s1 s2\n  execd_mthr.silent_move (compP2 P) t s2 s2'\n  s1 = (((e, xs), exs), h1)\n  s2 = ((xcp, frs), h)\n  s2' = ((xcp', frs'), h2')", "have [simp]: \"h1 = h\" and exec: \"exec_1_d (compP2 P) t (Normal (xcp, h, frs)) \\<epsilon> (Normal (xcp', h2', frs'))\"\n    and \\<tau>: \"\\<tau>Move2 (compP2 P) (xcp, h, frs)\" and bisim: \"bisim1_list1 t h (e, xs) exs xcp frs\""], ["proof (prove)\nusing this:\n  wbisim1 t s1 s2\n  execd_mthr.silent_move (compP2 P) t s2 s2'\n  s1 = (((e, xs), exs), h1)\n  s2 = ((xcp, frs), h)\n  s2' = ((xcp', frs'), h2')\n\ngoal (1 subgoal):\n 1. (h1 = h &&&\n     compP2\n      P,t \\<turnstile> Normal\n                        (xcp, h,\n                         frs) -\\<lbrace>\\<rbrace>-jvmd\\<rightarrow> Normal\n                               (xcp', h2', frs')) &&&\n    \\<tau>Move2 (compP2 P) (xcp, h, frs) &&&\n    bisim1_list1 t h (e, xs) exs xcp frs", "by(auto)"], ["proof (state)\nthis:\n  h1 = h\n  compP2\n   P,t \\<turnstile> Normal\n                     (xcp, h,\n                      frs) -\\<lbrace>\\<rbrace>-jvmd\\<rightarrow> Normal\n                            (xcp', h2', frs')\n  \\<tau>Move2 (compP2 P) (xcp, h, frs)\n  bisim1_list1 t h (e, xs) exs xcp frs\n\ngoal (5 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. \\<And>s1 s2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        execd_mthr.silent_move (compP2 P) t s2 s2'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1 s2' \\<and>\n                         (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n                             sim21_size (compP2 P) xcpfrs\n                              xcpfrs')\\<^sup>+\\<^sup>+\n                          s2' s2 \\<or>\n                         (\\<exists>s1'.\n                             Red1_mthr.silent_movet True P t s1 s1' \\<and>\n                             wbisim1 t s1' s2')\n 4. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 5. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "from \\<tau>Red1_simulates_exec_1_\\<tau>[OF wf exec bisim \\<tau>]"], ["proof (chain)\npicking this:\n  h = h2' \\<and>\n  (\\<exists>e' xs' exs'.\n      (if sim21_size (compP2 P) (xcp', frs') (xcp, frs) then \\<tau>Red1r\n       else \\<tau>Red1t)\n       P t h ((e, xs), exs) ((e', xs'), exs') \\<and>\n      bisim1_list1 t h (e', xs') exs' xcp' frs')", "obtain e' xs' exs' where [simp]: \"h2' = h\"\n    and red: \"(if sim21_size (compP2 P) (xcp', frs') (xcp, frs) then \\<tau>Red1r else \\<tau>Red1t) P t h ((e, xs), exs) ((e', xs'), exs')\"\n    and bisim': \"bisim1_list1 t h (e', xs') exs' xcp' frs'\""], ["proof (prove)\nusing this:\n  h = h2' \\<and>\n  (\\<exists>e' xs' exs'.\n      (if sim21_size (compP2 P) (xcp', frs') (xcp, frs) then \\<tau>Red1r\n       else \\<tau>Red1t)\n       P t h ((e, xs), exs) ((e', xs'), exs') \\<and>\n      bisim1_list1 t h (e', xs') exs' xcp' frs')\n\ngoal (1 subgoal):\n 1. (\\<And>e' xs' exs'.\n        \\<lbrakk>h2' = h;\n         (if sim21_size (compP2 P) (xcp', frs') (xcp, frs) then \\<tau>Red1r\n          else \\<tau>Red1t)\n          P t h ((e, xs), exs) ((e', xs'), exs');\n         bisim1_list1 t h (e', xs') exs' xcp' frs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  h2' = h\n  (if sim21_size (compP2 P) (xcp', frs') (xcp, frs) then \\<tau>Red1r\n   else \\<tau>Red1t)\n   P t h ((e, xs), exs) ((e', xs'), exs')\n  bisim1_list1 t h (e', xs') exs' xcp' frs'\n\ngoal (5 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. \\<And>s1 s2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        execd_mthr.silent_move (compP2 P) t s2 s2'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1 s2' \\<and>\n                         (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n                             sim21_size (compP2 P) xcpfrs\n                              xcpfrs')\\<^sup>+\\<^sup>+\n                          s2' s2 \\<or>\n                         (\\<exists>s1'.\n                             Red1_mthr.silent_movet True P t s1 s1' \\<and>\n                             wbisim1 t s1' s2')\n 4. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 5. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "from red"], ["proof (chain)\npicking this:\n  (if sim21_size (compP2 P) (xcp', frs') (xcp, frs) then \\<tau>Red1r\n   else \\<tau>Red1t)\n   P t h ((e, xs), exs) ((e', xs'), exs')", "have \"(if ((\\<lambda>(xcpfrs, h) (xcpfrs', h). sim21_size (compP2 P) xcpfrs xcpfrs') ((xcp', frs'), h2') ((xcp, frs), h)) then \\<tau>trsys.silent_moves (mred1 P t) (\\<tau>MOVE1 P) else \\<tau>trsys.silent_movet (mred1 P t) (\\<tau>MOVE1 P)) (((e, xs), exs), h) (((e', xs'), exs'), h)\""], ["proof (prove)\nusing this:\n  (if sim21_size (compP2 P) (xcp', frs') (xcp, frs) then \\<tau>Red1r\n   else \\<tau>Red1t)\n   P t h ((e, xs), exs) ((e', xs'), exs')\n\ngoal (1 subgoal):\n 1. (if (case ((xcp', frs'), h2') of\n         (xcpfrs, h) \\<Rightarrow>\n           \\<lambda>(xcpfrs', h). sim21_size (compP2 P) xcpfrs xcpfrs')\n         ((xcp, frs), h)\n     then Red1_mthr.silent_moves True P t\n     else Red1_mthr.silent_movet True P t)\n     (((e, xs), exs), h) (((e', xs'), exs'), h)", "by(auto dest: \\<tau>Red1r_rtranclpD \\<tau>Red1t_tranclpD)"], ["proof (state)\nthis:\n  (if (case ((xcp', frs'), h2') of\n       (xcpfrs, h) \\<Rightarrow>\n         \\<lambda>(xcpfrs', h). sim21_size (compP2 P) xcpfrs xcpfrs')\n       ((xcp, frs), h)\n   then Red1_mthr.silent_moves True P t\n   else Red1_mthr.silent_movet True P t)\n   (((e, xs), exs), h) (((e', xs'), exs'), h)\n\ngoal (5 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. \\<And>s1 s2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2;\n        execd_mthr.silent_move (compP2 P) t s2 s2'\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t s1 s2' \\<and>\n                         (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n                             sim21_size (compP2 P) xcpfrs\n                              xcpfrs')\\<^sup>+\\<^sup>+\n                          s2' s2 \\<or>\n                         (\\<exists>s1'.\n                             Red1_mthr.silent_movet True P t s1 s1' \\<and>\n                             wbisim1 t s1' s2')\n 4. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 5. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "thus \"wbisim1 t s1 s2' \\<and> (\\<lambda>(xcpfrs, h) (xcpfrs', h). sim21_size (compP2 P) xcpfrs xcpfrs')\\<^sup>+\\<^sup>+ s2' s2 \\<or>\n       (\\<exists>s1'. \\<tau>trsys.silent_movet (mred1 P t) (\\<tau>MOVE1 P) s1 s1' \\<and> wbisim1 t s1' s2')\""], ["proof (prove)\nusing this:\n  (if (case ((xcp', frs'), h2') of\n       (xcpfrs, h) \\<Rightarrow>\n         \\<lambda>(xcpfrs', h). sim21_size (compP2 P) xcpfrs xcpfrs')\n       ((xcp, frs), h)\n   then Red1_mthr.silent_moves True P t\n   else Red1_mthr.silent_movet True P t)\n   (((e, xs), exs), h) (((e', xs'), exs'), h)\n\ngoal (1 subgoal):\n 1. wbisim1 t s1 s2' \\<and>\n    (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n        sim21_size (compP2 P) xcpfrs xcpfrs')\\<^sup>+\\<^sup>+\n     s2' s2 \\<or>\n    (\\<exists>s1'.\n        Red1_mthr.silent_movet True P t s1 s1' \\<and> wbisim1 t s1' s2')", "using bisim' s1 s2 s2'"], ["proof (prove)\nusing this:\n  (if (case ((xcp', frs'), h2') of\n       (xcpfrs, h) \\<Rightarrow>\n         \\<lambda>(xcpfrs', h). sim21_size (compP2 P) xcpfrs xcpfrs')\n       ((xcp, frs), h)\n   then Red1_mthr.silent_moves True P t\n   else Red1_mthr.silent_movet True P t)\n   (((e, xs), exs), h) (((e', xs'), exs'), h)\n  bisim1_list1 t h (e', xs') exs' xcp' frs'\n  s1 = (((e, xs), exs), h1)\n  s2 = ((xcp, frs), h)\n  s2' = ((xcp', frs'), h2')\n\ngoal (1 subgoal):\n 1. wbisim1 t s1 s2' \\<and>\n    (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n        sim21_size (compP2 P) xcpfrs xcpfrs')\\<^sup>+\\<^sup>+\n     s2' s2 \\<or>\n    (\\<exists>s1'.\n        Red1_mthr.silent_movet True P t s1 s1' \\<and> wbisim1 t s1' s2')", "by -(rule delay_bisimulation_base.simulation_silent2I', auto split del: if_split)"], ["proof (state)\nthis:\n  wbisim1 t s1 s2' \\<and>\n  (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n      sim21_size (compP2 P) xcpfrs xcpfrs')\\<^sup>+\\<^sup>+\n   s2' s2 \\<or>\n  (\\<exists>s1'.\n      Red1_mthr.silent_movet True P t s1 s1' \\<and> wbisim1 t s1' s2')\n\ngoal (4 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 4. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 4. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "fix s1 s2 tl1 s1'"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 4. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "assume \"wbisim1 t s1 s2\" and \"mred1 P t s1 tl1 s1'\" and \"\\<not> \\<tau>MOVE1 P s1 tl1 s1'\""], ["proof (state)\nthis:\n  wbisim1 t s1 s2\n  mred1 P t s1 tl1 s1'\n  \\<not> (case s1 of\n          (exexs, h) \\<Rightarrow>\n            \\<lambda>ta s.\n               \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n          tl1 s1'\n\ngoal (4 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 4. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "moreover"], ["proof (state)\nthis:\n  wbisim1 t s1 s2\n  mred1 P t s1 tl1 s1'\n  \\<not> (case s1 of\n          (exexs, h) \\<Rightarrow>\n            \\<lambda>ta s.\n               \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n          tl1 s1'\n\ngoal (4 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 4. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "obtain e xs exs h where s1: \"s1 = (((e, xs), exs), h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e xs exs h.\n        s1 = (((e, xs), exs), h) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s1) auto"], ["proof (state)\nthis:\n  s1 = (((e, xs), exs), h)\n\ngoal (4 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 4. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "moreover"], ["proof (state)\nthis:\n  s1 = (((e, xs), exs), h)\n\ngoal (4 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 4. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "obtain e' xs' exs' h1' where s1': \"s1' = (((e', xs'), exs'), h1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e' xs' exs' h1'.\n        s1' = (((e', xs'), exs'), h1') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases s1') auto"], ["proof (state)\nthis:\n  s1' = (((e', xs'), exs'), h1')\n\ngoal (4 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 4. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "moreover"], ["proof (state)\nthis:\n  s1' = (((e', xs'), exs'), h1')\n\ngoal (4 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 4. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "obtain xcp frs h2 where s2: \"s2 = ((xcp, frs), h2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xcp frs h2.\n        s2 = ((xcp, frs), h2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s2) auto"], ["proof (state)\nthis:\n  s2 = ((xcp, frs), h2)\n\ngoal (4 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 4. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "ultimately"], ["proof (chain)\npicking this:\n  wbisim1 t s1 s2\n  mred1 P t s1 tl1 s1'\n  \\<not> (case s1 of\n          (exexs, h) \\<Rightarrow>\n            \\<lambda>ta s.\n               \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n          tl1 s1'\n  s1 = (((e, xs), exs), h)\n  s1' = (((e', xs'), exs'), h1')\n  s2 = ((xcp, frs), h2)", "have [simp]: \"h2 = h\"  and red: \"True,P,t \\<turnstile>1 \\<langle>(e, xs)/exs,h\\<rangle> -tl1\\<rightarrow> \\<langle>(e', xs')/exs',h1'\\<rangle>\"\n    and \\<tau>: \"\\<not> \\<tau>Move1 P h ((e, xs), exs)\" and bisim: \"bisim1_list1 t h (e, xs) exs xcp frs\""], ["proof (prove)\nusing this:\n  wbisim1 t s1 s2\n  mred1 P t s1 tl1 s1'\n  \\<not> (case s1 of\n          (exexs, h) \\<Rightarrow>\n            \\<lambda>ta s.\n               \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n          tl1 s1'\n  s1 = (((e, xs), exs), h)\n  s1' = (((e', xs'), exs'), h1')\n  s2 = ((xcp, frs), h2)\n\ngoal (1 subgoal):\n 1. (h2 = h &&&\n     True,P,t \\<turnstile>1 \\<langle>(e, xs)/exs,\n                             h\\<rangle> -tl1\\<rightarrow>\n                            \\<langle>(e', xs')/exs',h1'\\<rangle>) &&&\n    \\<not> \\<tau>Move1 P h ((e, xs), exs) &&&\n    bisim1_list1 t h (e, xs) exs xcp frs", "by(fastforce elim!: Red1.cases dest: red1_\\<tau>_taD)+"], ["proof (state)\nthis:\n  h2 = h\n  True,P,t \\<turnstile>1 \\<langle>(e, xs)/exs,h\\<rangle> -tl1\\<rightarrow>\n                         \\<langle>(e', xs')/exs',h1'\\<rangle>\n  \\<not> \\<tau>Move1 P h ((e, xs), exs)\n  bisim1_list1 t h (e, xs) exs xcp frs\n\ngoal (4 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 4. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "from exec_1_simulates_Red1_not_\\<tau>[OF wf red bisim \\<tau>]"], ["proof (chain)\npicking this:\n  \\<exists>xcp' frs'.\n     \\<tau>Exec_1_dr (compP2 P) t (xcp, h, frs) (xcp', h, frs') \\<and>\n     (\\<exists>ta' xcp'' frs''.\n         compP2\n          P,t \\<turnstile> Normal\n                            (xcp', h,\n                             frs') -ta'-jvmd\\<rightarrow> Normal\n                     (xcp'', h1', frs'') \\<and>\n         \\<not> \\<tau>Move2 (compP2 P) (xcp', h, frs') \\<and>\n         ta_bisim wbisim1 tl1 ta' \\<and>\n         bisim1_list1 t h1' (e', xs') exs' xcp'' frs'') \\<and>\n     (call1 e = None \\<or>\n      (case frs of [] \\<Rightarrow> False\n       | (stk, loc, C, M, pc) # FRS \\<Rightarrow>\n           \\<forall>M' n.\n              instrs_of (compP2 P) C M ! pc \\<noteq> Invoke M' n) \\<or>\n      xcp' = xcp \\<and> frs' = frs)", "obtain ta' xcp' frs' xcp'' frs''\n    where exec1: \"\\<tau>Exec_1_dr (compP2 P) t (xcp, h, frs) (xcp', h, frs')\"\n    and exec2: \"exec_1_d (compP2 P) t (Normal (xcp', h, frs')) ta' (Normal (xcp'', h1', frs''))\"\n    and \\<tau>': \"\\<not> \\<tau>Move2 (compP2 P) (xcp', h, frs')\"\n    and bisim': \"bisim1_list1 t h1' (e', xs') exs' xcp'' frs''\"\n    and ta': \"ta_bisim wbisim1 tl1 ta'\""], ["proof (prove)\nusing this:\n  \\<exists>xcp' frs'.\n     \\<tau>Exec_1_dr (compP2 P) t (xcp, h, frs) (xcp', h, frs') \\<and>\n     (\\<exists>ta' xcp'' frs''.\n         compP2\n          P,t \\<turnstile> Normal\n                            (xcp', h,\n                             frs') -ta'-jvmd\\<rightarrow> Normal\n                     (xcp'', h1', frs'') \\<and>\n         \\<not> \\<tau>Move2 (compP2 P) (xcp', h, frs') \\<and>\n         ta_bisim wbisim1 tl1 ta' \\<and>\n         bisim1_list1 t h1' (e', xs') exs' xcp'' frs'') \\<and>\n     (call1 e = None \\<or>\n      (case frs of [] \\<Rightarrow> False\n       | (stk, loc, C, M, pc) # FRS \\<Rightarrow>\n           \\<forall>M' n.\n              instrs_of (compP2 P) C M ! pc \\<noteq> Invoke M' n) \\<or>\n      xcp' = xcp \\<and> frs' = frs)\n\ngoal (1 subgoal):\n 1. (\\<And>xcp' frs' ta' xcp'' frs''.\n        \\<lbrakk>\\<tau>Exec_1_dr (compP2 P) t (xcp, h, frs) (xcp', h, frs');\n         compP2\n          P,t \\<turnstile> Normal\n                            (xcp', h,\n                             frs') -ta'-jvmd\\<rightarrow> Normal\n                     (xcp'', h1', frs'');\n         \\<not> \\<tau>Move2 (compP2 P) (xcp', h, frs');\n         bisim1_list1 t h1' (e', xs') exs' xcp'' frs'';\n         ta_bisim wbisim1 tl1 ta'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<tau>Exec_1_dr (compP2 P) t (xcp, h, frs) (xcp', h, frs')\n  compP2\n   P,t \\<turnstile> Normal\n                     (xcp', h,\n                      frs') -ta'-jvmd\\<rightarrow> Normal\n              (xcp'', h1', frs'')\n  \\<not> \\<tau>Move2 (compP2 P) (xcp', h, frs')\n  bisim1_list1 t h1' (e', xs') exs' xcp'' frs''\n  ta_bisim wbisim1 tl1 ta'\n\ngoal (4 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 4. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "from exec1"], ["proof (chain)\npicking this:\n  \\<tau>Exec_1_dr (compP2 P) t (xcp, h, frs) (xcp', h, frs')", "have \"\\<tau>trsys.silent_moves (mexecd (compP2 P) t) (\\<tau>MOVE2 (compP2 P)) ((xcp, frs), h) ((xcp', frs'), h)\""], ["proof (prove)\nusing this:\n  \\<tau>Exec_1_dr (compP2 P) t (xcp, h, frs) (xcp', h, frs')\n\ngoal (1 subgoal):\n 1. execd_mthr.silent_moves (compP2 P) t ((xcp, frs), h) ((xcp', frs'), h)", "by(rule \\<tau>Exec_1_dr_rtranclpD)"], ["proof (state)\nthis:\n  execd_mthr.silent_moves (compP2 P) t ((xcp, frs), h) ((xcp', frs'), h)\n\ngoal (4 subgoals):\n 1. \\<And>s1 s2 tl1 s1'.\n       \\<lbrakk>wbisim1 t s1 s2; mred1 P t s1 tl1 s1';\n        \\<not> (case s1 of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                tl1 s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2' s2'' tl2.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n                            \\<not> (case s2' of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (xcp, frs) \\<Rightarrow>\n   \\<lambda>h ta s.\n      \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n xa)\n                                    tl2 s2'' \\<and>\n                            wbisim1 t s1' s2'' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 3. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 4. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "thus \"\\<exists>s2' s2'' tl2. \\<tau>trsys.silent_moves (mexecd (compP2 P) t) (\\<tau>MOVE2 (compP2 P)) s2 s2' \\<and> \n                       mexecd (compP2 P) t s2' tl2 s2'' \\<and> \\<not> \\<tau>MOVE2 (compP2 P) s2' tl2 s2'' \\<and>\n                       wbisim1 t s1' s2'' \\<and> ta_bisim wbisim1 tl1 tl2\""], ["proof (prove)\nusing this:\n  execd_mthr.silent_moves (compP2 P) t ((xcp, frs), h) ((xcp', frs'), h)\n\ngoal (1 subgoal):\n 1. \\<exists>s2' s2'' tl2.\n       execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n       mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n       \\<not> (case s2' of\n               (x, xa) \\<Rightarrow>\n                 (case x of\n                  (xcp, frs) \\<Rightarrow>\n                    \\<lambda>h ta s.\n                       \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                       ta = \\<lbrace>\\<rbrace>)\n                  xa)\n               tl2 s2'' \\<and>\n       wbisim1 t s1' s2'' \\<and> ta_bisim wbisim1 tl1 tl2", "using bisim' exec2 \\<tau>' s1 s1' s2 ta'"], ["proof (prove)\nusing this:\n  execd_mthr.silent_moves (compP2 P) t ((xcp, frs), h) ((xcp', frs'), h)\n  bisim1_list1 t h1' (e', xs') exs' xcp'' frs''\n  compP2\n   P,t \\<turnstile> Normal\n                     (xcp', h,\n                      frs') -ta'-jvmd\\<rightarrow> Normal\n              (xcp'', h1', frs'')\n  \\<not> \\<tau>Move2 (compP2 P) (xcp', h, frs')\n  s1 = (((e, xs), exs), h)\n  s1' = (((e', xs'), exs'), h1')\n  s2 = ((xcp, frs), h2)\n  ta_bisim wbisim1 tl1 ta'\n\ngoal (1 subgoal):\n 1. \\<exists>s2' s2'' tl2.\n       execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n       mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n       \\<not> (case s2' of\n               (x, xa) \\<Rightarrow>\n                 (case x of\n                  (xcp, frs) \\<Rightarrow>\n                    \\<lambda>h ta s.\n                       \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                       ta = \\<lbrace>\\<rbrace>)\n                  xa)\n               tl2 s2'' \\<and>\n       wbisim1 t s1' s2'' \\<and> ta_bisim wbisim1 tl1 tl2", "unfolding \\<open>h2 = h\\<close>"], ["proof (prove)\nusing this:\n  execd_mthr.silent_moves (compP2 P) t ((xcp, frs), h) ((xcp', frs'), h)\n  bisim1_list1 t h1' (e', xs') exs' xcp'' frs''\n  compP2\n   P,t \\<turnstile> Normal\n                     (xcp', h,\n                      frs') -ta'-jvmd\\<rightarrow> Normal\n              (xcp'', h1', frs'')\n  \\<not> \\<tau>Move2 (compP2 P) (xcp', h, frs')\n  s1 = (((e, xs), exs), h)\n  s1' = (((e', xs'), exs'), h1')\n  s2 = ((xcp, frs), h)\n  ta_bisim wbisim1 tl1 ta'\n\ngoal (1 subgoal):\n 1. \\<exists>s2' s2'' tl2.\n       execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n       mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n       \\<not> (case s2' of\n               (x, xa) \\<Rightarrow>\n                 (case x of\n                  (xcp, frs) \\<Rightarrow>\n                    \\<lambda>h ta s.\n                       \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                       ta = \\<lbrace>\\<rbrace>)\n                  xa)\n               tl2 s2'' \\<and>\n       wbisim1 t s1' s2'' \\<and> ta_bisim wbisim1 tl1 tl2", "apply(subst (1 2) split_paired_Ex)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>execd_mthr.silent_moves (compP2 P) t ((xcp, frs), h)\n              ((xcp', frs'), h);\n     bisim1_list1 t h1' (e', xs') exs' xcp'' frs'';\n     compP2\n      P,t \\<turnstile> Normal\n                        (xcp', h,\n                         frs') -ta'-jvmd\\<rightarrow> Normal\n                 (xcp'', h1', frs'');\n     \\<not> \\<tau>Move2 (compP2 P) (xcp', h, frs');\n     s1 = (((e, xs), exs), h); s1' = (((e', xs'), exs'), h1');\n     s2 = ((xcp, frs), h); ta_bisim wbisim1 tl1 ta'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b aa ba tl2.\n                         execd_mthr.silent_moves (compP2 P) t s2\n                          (a, b) \\<and>\n                         execd_mthr.r_syntax (compP2 P) t a b tl2 aa\n                          ba \\<and>\n                         \\<not> (case (a, b) of\n                                 (x, xa) \\<Rightarrow>\n                                   (case x of\n                                    (xcp, frs) \\<Rightarrow>\n\\<lambda>h ta s.\n   \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    xa)\n                                 tl2 (aa, ba) \\<and>\n                         wbisim1 t s1' (aa, ba) \\<and>\n                         ta_bisim wbisim1 tl1 tl2", "apply(subst (1 2) split_paired_Ex)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>execd_mthr.silent_moves (compP2 P) t ((xcp, frs), h)\n              ((xcp', frs'), h);\n     bisim1_list1 t h1' (e', xs') exs' xcp'' frs'';\n     compP2\n      P,t \\<turnstile> Normal\n                        (xcp', h,\n                         frs') -ta'-jvmd\\<rightarrow> Normal\n                 (xcp'', h1', frs'');\n     \\<not> \\<tau>Move2 (compP2 P) (xcp', h, frs');\n     s1 = (((e, xs), exs), h); s1' = (((e', xs'), exs'), h1');\n     s2 = ((xcp, frs), h); ta_bisim wbisim1 tl1 ta'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b ba aa baa baaa tl2.\n                         execd_mthr.silent_moves (compP2 P) t s2\n                          ((a, b), ba) \\<and>\n                         execd_mthr.r_syntax (compP2 P) t (a, b) ba tl2\n                          (aa, baa) baaa \\<and>\n                         \\<not> (case ((a, b), ba) of\n                                 (x, xa) \\<Rightarrow>\n                                   (case x of\n                                    (xcp, frs) \\<Rightarrow>\n\\<lambda>h ta s.\n   \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    xa)\n                                 tl2 ((aa, baa), baaa) \\<and>\n                         wbisim1 t s1' ((aa, baa), baaa) \\<and>\n                         ta_bisim wbisim1 tl1 tl2", "by clarify ((rule exI conjI|assumption)+, auto)"], ["proof (state)\nthis:\n  \\<exists>s2' s2'' tl2.\n     execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n     mexecd (compP2 P) t s2' tl2 s2'' \\<and>\n     \\<not> (case s2' of\n             (x, xa) \\<Rightarrow>\n               (case x of\n                (xcp, frs) \\<Rightarrow>\n                  \\<lambda>h ta s.\n                     \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                     ta = \\<lbrace>\\<rbrace>)\n                xa)\n             tl2 s2'' \\<and>\n     wbisim1 t s1' s2'' \\<and> ta_bisim wbisim1 tl1 tl2\n\ngoal (3 subgoals):\n 1. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 3. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 3. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "fix s1 s2 tl2 s2'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 3. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "assume \"wbisim1 t s1 s2\" and \"mexecd (compP2 P) t s2 tl2 s2'\" and \"\\<not> \\<tau>MOVE2 (compP2 P) s2 tl2 s2'\""], ["proof (state)\nthis:\n  wbisim1 t s1 s2\n  mexecd (compP2 P) t s2 tl2 s2'\n  \\<not> (case s2 of\n          (x, xa) \\<Rightarrow>\n            (case x of\n             (xcp, frs) \\<Rightarrow>\n               \\<lambda>h ta s.\n                  \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                  ta = \\<lbrace>\\<rbrace>)\n             xa)\n          tl2 s2'\n\ngoal (3 subgoals):\n 1. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 3. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "moreover"], ["proof (state)\nthis:\n  wbisim1 t s1 s2\n  mexecd (compP2 P) t s2 tl2 s2'\n  \\<not> (case s2 of\n          (x, xa) \\<Rightarrow>\n            (case x of\n             (xcp, frs) \\<Rightarrow>\n               \\<lambda>h ta s.\n                  \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                  ta = \\<lbrace>\\<rbrace>)\n             xa)\n          tl2 s2'\n\ngoal (3 subgoals):\n 1. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 3. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "obtain e xs exs h1 where s1: \"s1 = (((e, xs), exs), h1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e xs exs h1.\n        s1 = (((e, xs), exs), h1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases s1) auto"], ["proof (state)\nthis:\n  s1 = (((e, xs), exs), h1)\n\ngoal (3 subgoals):\n 1. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 3. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "moreover"], ["proof (state)\nthis:\n  s1 = (((e, xs), exs), h1)\n\ngoal (3 subgoals):\n 1. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 3. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "obtain xcp frs h where s2: \"s2 = ((xcp, frs), h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xcp frs h.\n        s2 = ((xcp, frs), h) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s2) auto"], ["proof (state)\nthis:\n  s2 = ((xcp, frs), h)\n\ngoal (3 subgoals):\n 1. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 3. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "moreover"], ["proof (state)\nthis:\n  s2 = ((xcp, frs), h)\n\ngoal (3 subgoals):\n 1. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 3. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "obtain xcp' frs' h2' where s2': \"s2' = ((xcp', frs'), h2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xcp' frs' h2'.\n        s2' = ((xcp', frs'), h2') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases s2') auto"], ["proof (state)\nthis:\n  s2' = ((xcp', frs'), h2')\n\ngoal (3 subgoals):\n 1. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 3. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "ultimately"], ["proof (chain)\npicking this:\n  wbisim1 t s1 s2\n  mexecd (compP2 P) t s2 tl2 s2'\n  \\<not> (case s2 of\n          (x, xa) \\<Rightarrow>\n            (case x of\n             (xcp, frs) \\<Rightarrow>\n               \\<lambda>h ta s.\n                  \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                  ta = \\<lbrace>\\<rbrace>)\n             xa)\n          tl2 s2'\n  s1 = (((e, xs), exs), h1)\n  s2 = ((xcp, frs), h)\n  s2' = ((xcp', frs'), h2')", "have [simp]: \"h1 = h\"  and exec: \"exec_1_d (compP2 P) t (Normal (xcp, h, frs)) tl2 (Normal (xcp', h2', frs'))\"\n    and \\<tau>: \"\\<not> \\<tau>Move2 (compP2 P) (xcp, h, frs)\" and bisim: \"bisim1_list1 t h (e, xs) exs xcp frs\""], ["proof (prove)\nusing this:\n  wbisim1 t s1 s2\n  mexecd (compP2 P) t s2 tl2 s2'\n  \\<not> (case s2 of\n          (x, xa) \\<Rightarrow>\n            (case x of\n             (xcp, frs) \\<Rightarrow>\n               \\<lambda>h ta s.\n                  \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                  ta = \\<lbrace>\\<rbrace>)\n             xa)\n          tl2 s2'\n  s1 = (((e, xs), exs), h1)\n  s2 = ((xcp, frs), h)\n  s2' = ((xcp', frs'), h2')\n\ngoal (1 subgoal):\n 1. (h1 = h &&&\n     compP2\n      P,t \\<turnstile> Normal\n                        (xcp, h,\n                         frs) -tl2-jvmd\\<rightarrow> Normal\n                (xcp', h2', frs')) &&&\n    \\<not> \\<tau>Move2 (compP2 P) (xcp, h, frs) &&&\n    bisim1_list1 t h (e, xs) exs xcp frs", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>compP2\n              P,t \\<turnstile> Normal\n                                (xcp, h,\n                                 frs) -tl2-jvmd\\<rightarrow> Normal\n                        (xcp', h2', frs');\n     s1 = (((e, xs), exs), h); s2 = ((xcp, frs), h);\n     s2' = ((xcp', frs'), h2'); bisim1_list1 t h (e, xs) exs xcp frs;\n     h1 = h; \\<tau>Move2 (compP2 P) (xcp, h, frs);\n     tl2 \\<noteq> \\<lbrace>\\<rbrace>\\<rbrakk>\n    \\<Longrightarrow> False", "apply(erule jvmd_NormalE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xcpa ha f frsa.\n       \\<lbrakk>s1 = (((e, xs), exs), h); s2 = ((xcp, frs), h);\n        s2' = ((xcp', frs'), h2'); bisim1_list1 t h (e, xs) exs xcp frs;\n        h1 = h; \\<tau>Move2 (compP2 P) (xcp, h, frs);\n        tl2 \\<noteq> \\<lbrace>\\<rbrace>; check (compP2 P) (xcp, h, frs);\n        (tl2, xcp', h2', frs') \\<in> exec (compP2 P) t (xcp, h, frs);\n        (xcp, h, frs) = (xcpa, ha, f # frsa)\\<rbrakk>\n       \\<Longrightarrow> False", "apply(cases xcp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xcpa ha f frsa.\n       \\<lbrakk>s1 = (((e, xs), exs), h); s2 = ((xcp, frs), h);\n        s2' = ((xcp', frs'), h2'); bisim1_list1 t h (e, xs) exs xcp frs;\n        h1 = h; \\<tau>Move2 (compP2 P) (xcp, h, frs);\n        tl2 \\<noteq> \\<lbrace>\\<rbrace>; check (compP2 P) (xcp, h, frs);\n        (tl2, xcp', h2', frs') \\<in> exec (compP2 P) t (xcp, h, frs);\n        (xcp, h, frs) = (xcpa, ha, f # frsa); xcp = None\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>xcpa ha f frsa a.\n       \\<lbrakk>s1 = (((e, xs), exs), h); s2 = ((xcp, frs), h);\n        s2' = ((xcp', frs'), h2'); bisim1_list1 t h (e, xs) exs xcp frs;\n        h1 = h; \\<tau>Move2 (compP2 P) (xcp, h, frs);\n        tl2 \\<noteq> \\<lbrace>\\<rbrace>; check (compP2 P) (xcp, h, frs);\n        (tl2, xcp', h2', frs') \\<in> exec (compP2 P) t (xcp, h, frs);\n        (xcp, h, frs) = (xcpa, ha, f # frsa);\n        xcp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac b frsa.\n       \\<lbrakk>s1 = (((e, xs), exs), h);\n        s2 = ((None, (a, aa, ab, ac, b) # frsa), h);\n        s2' = ((xcp', frs'), h2');\n        bisim1_list1 t h (e, xs) exs None ((a, aa, ab, ac, b) # frsa);\n        h1 = h; tl2 \\<noteq> \\<lbrace>\\<rbrace>;\n        check (compP2 P) (None, h, (a, aa, ab, ac, b) # frsa);\n        (tl2, xcp', h2', frs')\n        \\<in> exec_instr (instrs_of (compP2 P) ab ac ! b) (compP2 P) t h a\n               aa ab ac b frsa;\n        frs = (a, aa, ab, ac, b) # frsa; xcp = None;\n        b < length (instrs_of (compP2 P) ab ac);\n        \\<tau>instr (compP2 P) h a (instrs_of (compP2 P) ab ac ! b)\\<rbrakk>\n       \\<Longrightarrow> False", "apply(rename_tac stk loc C M pc frs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stk loc C M pc frsa.\n       \\<lbrakk>s1 = (((e, xs), exs), h);\n        s2 = ((None, (stk, loc, C, M, pc) # frsa), h);\n        s2' = ((xcp', frs'), h2');\n        bisim1_list1 t h (e, xs) exs None ((stk, loc, C, M, pc) # frsa);\n        h1 = h; tl2 \\<noteq> \\<lbrace>\\<rbrace>;\n        check (compP2 P) (None, h, (stk, loc, C, M, pc) # frsa);\n        (tl2, xcp', h2', frs')\n        \\<in> exec_instr (instrs_of (compP2 P) C M ! pc) (compP2 P) t h stk\n               loc C M pc frsa;\n        frs = (stk, loc, C, M, pc) # frsa; xcp = None;\n        pc < length (instrs_of (compP2 P) C M);\n        \\<tau>instr (compP2 P) h stk\n         (instrs_of (compP2 P) C M ! pc)\\<rbrakk>\n       \\<Longrightarrow> False", "apply(case_tac \"instrs_of (compP2 P) C M ! pc\")"], ["proof (prove)\ngoal (24 subgoals):\n 1. \\<And>stk loc C M pc frsa x1.\n       \\<lbrakk>s1 = (((e, xs), exs), h);\n        s2 = ((None, (stk, loc, C, M, pc) # frsa), h);\n        s2' = ((xcp', frs'), h2');\n        bisim1_list1 t h (e, xs) exs None ((stk, loc, C, M, pc) # frsa);\n        h1 = h; tl2 \\<noteq> \\<lbrace>\\<rbrace>;\n        check (compP2 P) (None, h, (stk, loc, C, M, pc) # frsa);\n        (tl2, xcp', h2', frs')\n        \\<in> exec_instr (instrs_of (compP2 P) C M ! pc) (compP2 P) t h stk\n               loc C M pc frsa;\n        frs = (stk, loc, C, M, pc) # frsa; xcp = None;\n        pc < length (instrs_of (compP2 P) C M);\n        \\<tau>instr (compP2 P) h stk (instrs_of (compP2 P) C M ! pc);\n        instrs_of (compP2 P) C M ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>stk loc C M pc frsa x2.\n       \\<lbrakk>s1 = (((e, xs), exs), h);\n        s2 = ((None, (stk, loc, C, M, pc) # frsa), h);\n        s2' = ((xcp', frs'), h2');\n        bisim1_list1 t h (e, xs) exs None ((stk, loc, C, M, pc) # frsa);\n        h1 = h; tl2 \\<noteq> \\<lbrace>\\<rbrace>;\n        check (compP2 P) (None, h, (stk, loc, C, M, pc) # frsa);\n        (tl2, xcp', h2', frs')\n        \\<in> exec_instr (instrs_of (compP2 P) C M ! pc) (compP2 P) t h stk\n               loc C M pc frsa;\n        frs = (stk, loc, C, M, pc) # frsa; xcp = None;\n        pc < length (instrs_of (compP2 P) C M);\n        \\<tau>instr (compP2 P) h stk (instrs_of (compP2 P) C M ! pc);\n        instrs_of (compP2 P) C M ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>stk loc C M pc frsa x3.\n       \\<lbrakk>s1 = (((e, xs), exs), h);\n        s2 = ((None, (stk, loc, C, M, pc) # frsa), h);\n        s2' = ((xcp', frs'), h2');\n        bisim1_list1 t h (e, xs) exs None ((stk, loc, C, M, pc) # frsa);\n        h1 = h; tl2 \\<noteq> \\<lbrace>\\<rbrace>;\n        check (compP2 P) (None, h, (stk, loc, C, M, pc) # frsa);\n        (tl2, xcp', h2', frs')\n        \\<in> exec_instr (instrs_of (compP2 P) C M ! pc) (compP2 P) t h stk\n               loc C M pc frsa;\n        frs = (stk, loc, C, M, pc) # frsa; xcp = None;\n        pc < length (instrs_of (compP2 P) C M);\n        \\<tau>instr (compP2 P) h stk (instrs_of (compP2 P) C M ! pc);\n        instrs_of (compP2 P) C M ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>stk loc C M pc frsa x4.\n       \\<lbrakk>s1 = (((e, xs), exs), h);\n        s2 = ((None, (stk, loc, C, M, pc) # frsa), h);\n        s2' = ((xcp', frs'), h2');\n        bisim1_list1 t h (e, xs) exs None ((stk, loc, C, M, pc) # frsa);\n        h1 = h; tl2 \\<noteq> \\<lbrace>\\<rbrace>;\n        check (compP2 P) (None, h, (stk, loc, C, M, pc) # frsa);\n        (tl2, xcp', h2', frs')\n        \\<in> exec_instr (instrs_of (compP2 P) C M ! pc) (compP2 P) t h stk\n               loc C M pc frsa;\n        frs = (stk, loc, C, M, pc) # frsa; xcp = None;\n        pc < length (instrs_of (compP2 P) C M);\n        \\<tau>instr (compP2 P) h stk (instrs_of (compP2 P) C M ! pc);\n        instrs_of (compP2 P) C M ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>stk loc C M pc frsa x5.\n       \\<lbrakk>s1 = (((e, xs), exs), h);\n        s2 = ((None, (stk, loc, C, M, pc) # frsa), h);\n        s2' = ((xcp', frs'), h2');\n        bisim1_list1 t h (e, xs) exs None ((stk, loc, C, M, pc) # frsa);\n        h1 = h; tl2 \\<noteq> \\<lbrace>\\<rbrace>;\n        check (compP2 P) (None, h, (stk, loc, C, M, pc) # frsa);\n        (tl2, xcp', h2', frs')\n        \\<in> exec_instr (instrs_of (compP2 P) C M ! pc) (compP2 P) t h stk\n               loc C M pc frsa;\n        frs = (stk, loc, C, M, pc) # frsa; xcp = None;\n        pc < length (instrs_of (compP2 P) C M);\n        \\<tau>instr (compP2 P) h stk (instrs_of (compP2 P) C M ! pc);\n        instrs_of (compP2 P) C M ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>stk loc C M pc frsa.\n       \\<lbrakk>s1 = (((e, xs), exs), h);\n        s2 = ((None, (stk, loc, C, M, pc) # frsa), h);\n        s2' = ((xcp', frs'), h2');\n        bisim1_list1 t h (e, xs) exs None ((stk, loc, C, M, pc) # frsa);\n        h1 = h; tl2 \\<noteq> \\<lbrace>\\<rbrace>;\n        check (compP2 P) (None, h, (stk, loc, C, M, pc) # frsa);\n        (tl2, xcp', h2', frs')\n        \\<in> exec_instr (instrs_of (compP2 P) C M ! pc) (compP2 P) t h stk\n               loc C M pc frsa;\n        frs = (stk, loc, C, M, pc) # frsa; xcp = None;\n        pc < length (instrs_of (compP2 P) C M);\n        \\<tau>instr (compP2 P) h stk (instrs_of (compP2 P) C M ! pc);\n        instrs_of (compP2 P) C M ! pc = ALoad\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>stk loc C M pc frsa.\n       \\<lbrakk>s1 = (((e, xs), exs), h);\n        s2 = ((None, (stk, loc, C, M, pc) # frsa), h);\n        s2' = ((xcp', frs'), h2');\n        bisim1_list1 t h (e, xs) exs None ((stk, loc, C, M, pc) # frsa);\n        h1 = h; tl2 \\<noteq> \\<lbrace>\\<rbrace>;\n        check (compP2 P) (None, h, (stk, loc, C, M, pc) # frsa);\n        (tl2, xcp', h2', frs')\n        \\<in> exec_instr (instrs_of (compP2 P) C M ! pc) (compP2 P) t h stk\n               loc C M pc frsa;\n        frs = (stk, loc, C, M, pc) # frsa; xcp = None;\n        pc < length (instrs_of (compP2 P) C M);\n        \\<tau>instr (compP2 P) h stk (instrs_of (compP2 P) C M ! pc);\n        instrs_of (compP2 P) C M ! pc = AStore\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>stk loc C M pc frsa.\n       \\<lbrakk>s1 = (((e, xs), exs), h);\n        s2 = ((None, (stk, loc, C, M, pc) # frsa), h);\n        s2' = ((xcp', frs'), h2');\n        bisim1_list1 t h (e, xs) exs None ((stk, loc, C, M, pc) # frsa);\n        h1 = h; tl2 \\<noteq> \\<lbrace>\\<rbrace>;\n        check (compP2 P) (None, h, (stk, loc, C, M, pc) # frsa);\n        (tl2, xcp', h2', frs')\n        \\<in> exec_instr (instrs_of (compP2 P) C M ! pc) (compP2 P) t h stk\n               loc C M pc frsa;\n        frs = (stk, loc, C, M, pc) # frsa; xcp = None;\n        pc < length (instrs_of (compP2 P) C M);\n        \\<tau>instr (compP2 P) h stk (instrs_of (compP2 P) C M ! pc);\n        instrs_of (compP2 P) C M ! pc = ALength\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>stk loc C M pc frsa x91 x92.\n       \\<lbrakk>s1 = (((e, xs), exs), h);\n        s2 = ((None, (stk, loc, C, M, pc) # frsa), h);\n        s2' = ((xcp', frs'), h2');\n        bisim1_list1 t h (e, xs) exs None ((stk, loc, C, M, pc) # frsa);\n        h1 = h; tl2 \\<noteq> \\<lbrace>\\<rbrace>;\n        check (compP2 P) (None, h, (stk, loc, C, M, pc) # frsa);\n        (tl2, xcp', h2', frs')\n        \\<in> exec_instr (instrs_of (compP2 P) C M ! pc) (compP2 P) t h stk\n               loc C M pc frsa;\n        frs = (stk, loc, C, M, pc) # frsa; xcp = None;\n        pc < length (instrs_of (compP2 P) C M);\n        \\<tau>instr (compP2 P) h stk (instrs_of (compP2 P) C M ! pc);\n        instrs_of (compP2 P) C M ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>stk loc C M pc frsa x101 x102.\n        \\<lbrakk>s1 = (((e, xs), exs), h);\n         s2 = ((None, (stk, loc, C, M, pc) # frsa), h);\n         s2' = ((xcp', frs'), h2');\n         bisim1_list1 t h (e, xs) exs None ((stk, loc, C, M, pc) # frsa);\n         h1 = h; tl2 \\<noteq> \\<lbrace>\\<rbrace>;\n         check (compP2 P) (None, h, (stk, loc, C, M, pc) # frsa);\n         (tl2, xcp', h2', frs')\n         \\<in> exec_instr (instrs_of (compP2 P) C M ! pc) (compP2 P) t h stk\n                loc C M pc frsa;\n         frs = (stk, loc, C, M, pc) # frsa; xcp = None;\n         pc < length (instrs_of (compP2 P) C M);\n         \\<tau>instr (compP2 P) h stk (instrs_of (compP2 P) C M ! pc);\n         instrs_of (compP2 P) C M ! pc = Putfield x101 x102\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 24 subgoals...", "apply(simp_all split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stk loc C M pc frsa x141 x142.\n       \\<lbrakk>frs = (stk, loc, C, M, pc) # frsa; xcp = None;\n        pc < length (instrs_of (compP2 P) C M);\n        instrs_of (compP2 P) C M ! pc = Invoke x141 x142;\n        s1 = (((e, xs), exs), h);\n        s2 = ((None, (stk, loc, C, M, pc) # frsa), h);\n        s2' = ((xcp', frs'), h2');\n        bisim1_list1 t h (e, xs) exs None ((stk, loc, C, M, pc) # frsa);\n        h1 = h; tl2 \\<noteq> \\<lbrace>\\<rbrace>;\n        check (compP2 P) (None, h, (stk, loc, C, M, pc) # frsa);\n        stk ! x142 \\<noteq> Null; x142 < length stk;\n        \\<forall>T.\n           typeof_addr h (the_Addr (stk ! x142)) =\n           \\<lfloor>T\\<rfloor> \\<longrightarrow>\n           (\\<forall>Ts Tr D.\n               compP2\n                P \\<turnstile> class_type_of\n                                T sees x141: Ts\\<rightarrow>Tr = Native in D \\<longrightarrow>\n               \\<tau>external_defs D x141);\n        snd (snd (snd (method (compP2 P)\n                        (class_type_of\n                          (the (typeof_addr h (the_Addr (stk ! x142)))))\n                        x141))) =\n        None;\n        \\<exists>a aa aaa aaaa aaaaa b.\n           tl2 =\n           (a, map (convert_new_thread_action (extNTA2JVM (compP2 P))) aa,\n            aaa, aaaa, aaaaa, b) \\<and>\n           (\\<exists>va.\n               (case va of\n                RetVal v \\<Rightarrow>\n                  xcp' = None \\<and>\n                  frs' = (v # drop (Suc x142) stk, loc, C, M, pc + 1) # frsa\n                | RetExc a \\<Rightarrow>\n                    xcp' = \\<lfloor>a\\<rfloor> \\<and>\n                    frs' = (stk, loc, C, M, pc) # frsa\n                | RetStaySame \\<Rightarrow>\n                    xcp' = None \\<and>\n                    frs' = (stk, loc, C, M, pc) # frsa) \\<and>\n               ((a, aa, aaa, aaaa, aaaaa, b), va, h2')\n               \\<in> red_external_aggr (compP2 P) t (the_Addr (stk ! x142))\n                      x141 (rev (take x142 stk)) h)\\<rbrakk>\n       \\<Longrightarrow> False", "apply(auto dest!: \\<tau>external_red_external_aggr_TA_empty simp add: check_def has_method_def \\<tau>external_def \\<tau>external'_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  h1 = h\n  compP2\n   P,t \\<turnstile> Normal\n                     (xcp, h,\n                      frs) -tl2-jvmd\\<rightarrow> Normal (xcp', h2', frs')\n  \\<not> \\<tau>Move2 (compP2 P) (xcp, h, frs)\n  bisim1_list1 t h (e, xs) exs xcp frs\n\ngoal (3 subgoals):\n 1. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 3. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "from \\<tau>Red1_simulates_exec_1_not_\\<tau>[OF wf exec bisim \\<tau>]"], ["proof (chain)\npicking this:\n  \\<exists>e' xs' exs' ta' e'' xs'' exs''.\n     \\<tau>Red1r P t h ((e, xs), exs) ((e', xs'), exs') \\<and>\n     True,P,t \\<turnstile>1 \\<langle>(e', xs')/exs',\n                             h\\<rangle> -ta'\\<rightarrow>\n                            \\<langle>(e'', xs'')/exs'',h2'\\<rangle> \\<and>\n     \\<not> \\<tau>Move1 P h ((e', xs'), exs') \\<and>\n     ta_bisim wbisim1 ta' tl2 \\<and>\n     bisim1_list1 t h2' (e'', xs'') exs'' xcp' frs' \\<and>\n     (call1 e = None \\<or>\n      (case frs of [] \\<Rightarrow> False\n       | (stk, loc, C, M, pc) # FRS \\<Rightarrow>\n           \\<forall>M' n.\n              instrs_of (compP2 P) C M ! pc \\<noteq> Invoke M' n) \\<or>\n      e' = e \\<and> xs' = xs \\<and> exs' = exs)", "obtain e' xs' exs' ta' e'' xs'' exs''\n    where red1: \"\\<tau>Red1r P t h ((e, xs), exs) ((e', xs'), exs')\"\n    and red2: \"True,P,t \\<turnstile>1 \\<langle>(e', xs')/exs',h\\<rangle> -ta'\\<rightarrow> \\<langle>(e'', xs'')/exs'',h2'\\<rangle>\"\n    and \\<tau>': \"\\<not> \\<tau>Move1 P h ((e', xs'), exs')\" and ta': \"ta_bisim wbisim1 ta' tl2\"\n    and bisim': \"bisim1_list1 t h2' (e'', xs'') exs'' xcp' frs'\""], ["proof (prove)\nusing this:\n  \\<exists>e' xs' exs' ta' e'' xs'' exs''.\n     \\<tau>Red1r P t h ((e, xs), exs) ((e', xs'), exs') \\<and>\n     True,P,t \\<turnstile>1 \\<langle>(e', xs')/exs',\n                             h\\<rangle> -ta'\\<rightarrow>\n                            \\<langle>(e'', xs'')/exs'',h2'\\<rangle> \\<and>\n     \\<not> \\<tau>Move1 P h ((e', xs'), exs') \\<and>\n     ta_bisim wbisim1 ta' tl2 \\<and>\n     bisim1_list1 t h2' (e'', xs'') exs'' xcp' frs' \\<and>\n     (call1 e = None \\<or>\n      (case frs of [] \\<Rightarrow> False\n       | (stk, loc, C, M, pc) # FRS \\<Rightarrow>\n           \\<forall>M' n.\n              instrs_of (compP2 P) C M ! pc \\<noteq> Invoke M' n) \\<or>\n      e' = e \\<and> xs' = xs \\<and> exs' = exs)\n\ngoal (1 subgoal):\n 1. (\\<And>e' xs' exs' ta' e'' xs'' exs''.\n        \\<lbrakk>\\<tau>Red1r P t h ((e, xs), exs) ((e', xs'), exs');\n         True,P,t \\<turnstile>1 \\<langle>(e', xs')/exs',\n                                 h\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>(e'', xs'')/exs'',h2'\\<rangle>;\n         \\<not> \\<tau>Move1 P h ((e', xs'), exs'); ta_bisim wbisim1 ta' tl2;\n         bisim1_list1 t h2' (e'', xs'') exs'' xcp' frs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<tau>Red1r P t h ((e, xs), exs) ((e', xs'), exs')\n  True,P,t \\<turnstile>1 \\<langle>(e', xs')/exs',\n                          h\\<rangle> -ta'\\<rightarrow>\n                         \\<langle>(e'', xs'')/exs'',h2'\\<rangle>\n  \\<not> \\<tau>Move1 P h ((e', xs'), exs')\n  ta_bisim wbisim1 ta' tl2\n  bisim1_list1 t h2' (e'', xs'') exs'' xcp' frs'\n\ngoal (3 subgoals):\n 1. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 3. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "from red1"], ["proof (chain)\npicking this:\n  \\<tau>Red1r P t h ((e, xs), exs) ((e', xs'), exs')", "have \"\\<tau>trsys.silent_moves (mred1 P t) (\\<tau>MOVE1 P) (((e, xs), exs), h) (((e', xs'), exs'), h)\""], ["proof (prove)\nusing this:\n  \\<tau>Red1r P t h ((e, xs), exs) ((e', xs'), exs')\n\ngoal (1 subgoal):\n 1. Red1_mthr.silent_moves True P t (((e, xs), exs), h)\n     (((e', xs'), exs'), h)", "by(rule \\<tau>Red1r_rtranclpD)"], ["proof (state)\nthis:\n  Red1_mthr.silent_moves True P t (((e, xs), exs), h) (((e', xs'), exs'), h)\n\ngoal (3 subgoals):\n 1. \\<And>s1 s2 tl2 s2'.\n       \\<lbrakk>wbisim1 t s1 s2; mexecd (compP2 P) t s2 tl2 s2';\n        \\<not> (case s2 of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                tl2 s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            mred1 P t s1' tl1 s1'' \\<and>\n                            \\<not> (case s1' of\n                                    (exexs, h) \\<Rightarrow>\n\\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                    tl1 s1'' \\<and>\n                            wbisim1 t s1'' s2' \\<and>\n                            ta_bisim wbisim1 tl1 tl2\n 2. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 3. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "thus \"\\<exists>s1' s1'' tl1. \\<tau>trsys.silent_moves (mred1 P t) (\\<tau>MOVE1 P) s1 s1' \\<and> mred1 P t s1' tl1 s1'' \\<and>\n                      \\<not> \\<tau>MOVE1 P s1' tl1 s1'' \\<and> wbisim1 t s1'' s2' \\<and> ta_bisim wbisim1 tl1 tl2\""], ["proof (prove)\nusing this:\n  Red1_mthr.silent_moves True P t (((e, xs), exs), h) (((e', xs'), exs'), h)\n\ngoal (1 subgoal):\n 1. \\<exists>s1' s1'' tl1.\n       Red1_mthr.silent_moves True P t s1 s1' \\<and>\n       mred1 P t s1' tl1 s1'' \\<and>\n       \\<not> (case s1' of\n               (exexs, h) \\<Rightarrow>\n                 \\<lambda>ta s.\n                    \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n               tl1 s1'' \\<and>\n       wbisim1 t s1'' s2' \\<and> ta_bisim wbisim1 tl1 tl2", "using bisim' red2 \\<tau>' s1 s2 s2' \\<open>h1 = h\\<close> ta'"], ["proof (prove)\nusing this:\n  Red1_mthr.silent_moves True P t (((e, xs), exs), h) (((e', xs'), exs'), h)\n  bisim1_list1 t h2' (e'', xs'') exs'' xcp' frs'\n  True,P,t \\<turnstile>1 \\<langle>(e', xs')/exs',\n                          h\\<rangle> -ta'\\<rightarrow>\n                         \\<langle>(e'', xs'')/exs'',h2'\\<rangle>\n  \\<not> \\<tau>Move1 P h ((e', xs'), exs')\n  s1 = (((e, xs), exs), h1)\n  s2 = ((xcp, frs), h)\n  s2' = ((xcp', frs'), h2')\n  h1 = h\n  ta_bisim wbisim1 ta' tl2\n\ngoal (1 subgoal):\n 1. \\<exists>s1' s1'' tl1.\n       Red1_mthr.silent_moves True P t s1 s1' \\<and>\n       mred1 P t s1' tl1 s1'' \\<and>\n       \\<not> (case s1' of\n               (exexs, h) \\<Rightarrow>\n                 \\<lambda>ta s.\n                    \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n               tl1 s1'' \\<and>\n       wbisim1 t s1'' s2' \\<and> ta_bisim wbisim1 tl1 tl2", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Red1_mthr.silent_moves True P t (((e, xs), exs), h)\n              (((e', xs'), exs'), h);\n     bisim1_list1 t h2' (e'', xs'') exs'' xcp' frs';\n     True,P,t \\<turnstile>1 \\<langle>(e', xs')/exs',\n                             h\\<rangle> -ta'\\<rightarrow>\n                            \\<langle>(e'', xs'')/exs'',h2'\\<rangle>;\n     \\<not> \\<tau>Move1 P h ((e', xs'), exs'); s1 = (((e, xs), exs), h1);\n     s2 = ((xcp, frs), h); s2' = ((xcp', frs'), h2'); h1 = h;\n     ta_bisim wbisim1 ta' tl2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s1' s1'' tl1.\n                         Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                         mred1 P t s1' tl1 s1'' \\<and>\n                         \\<not> (case s1' of\n                                 (exexs, h) \\<Rightarrow>\n                                   \\<lambda>ta s.\n\\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                 tl1 s1'' \\<and>\n                         wbisim1 t s1'' s2' \\<and> ta_bisim wbisim1 tl1 tl2", "apply(rule exI[where x=\"(((e', xs'), exs'), h)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Red1_mthr.silent_moves True P t (((e, xs), exs), h)\n              (((e', xs'), exs'), h);\n     bisim1_list1 t h2' (e'', xs'') exs'' xcp' frs';\n     True,P,t \\<turnstile>1 \\<langle>(e', xs')/exs',\n                             h\\<rangle> -ta'\\<rightarrow>\n                            \\<langle>(e'', xs'')/exs'',h2'\\<rangle>;\n     \\<not> \\<tau>Move1 P h ((e', xs'), exs'); s1 = (((e, xs), exs), h1);\n     s2 = ((xcp, frs), h); s2' = ((xcp', frs'), h2'); h1 = h;\n     ta_bisim wbisim1 ta' tl2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s1'' tl1.\n                         Red1_mthr.silent_moves True P t s1\n                          (((e', xs'), exs'), h) \\<and>\n                         mred1 P t (((e', xs'), exs'), h) tl1 s1'' \\<and>\n                         \\<not> (case (((e', xs'), exs'), h) of\n                                 (exexs, h) \\<Rightarrow>\n                                   \\<lambda>ta s.\n\\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                 tl1 s1'' \\<and>\n                         wbisim1 t s1'' s2' \\<and> ta_bisim wbisim1 tl1 tl2", "apply(rule exI[where x=\"(((e'', xs''), exs''), h2')\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Red1_mthr.silent_moves True P t (((e, xs), exs), h)\n              (((e', xs'), exs'), h);\n     bisim1_list1 t h2' (e'', xs'') exs'' xcp' frs';\n     True,P,t \\<turnstile>1 \\<langle>(e', xs')/exs',\n                             h\\<rangle> -ta'\\<rightarrow>\n                            \\<langle>(e'', xs'')/exs'',h2'\\<rangle>;\n     \\<not> \\<tau>Move1 P h ((e', xs'), exs'); s1 = (((e, xs), exs), h1);\n     s2 = ((xcp, frs), h); s2' = ((xcp', frs'), h2'); h1 = h;\n     ta_bisim wbisim1 ta' tl2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tl1.\n                         Red1_mthr.silent_moves True P t s1\n                          (((e', xs'), exs'), h) \\<and>\n                         Red1_mthr.r_syntax True P t ((e', xs'), exs') h tl1\n                          ((e'', xs''), exs'') h2' \\<and>\n                         \\<not> (case (((e', xs'), exs'), h) of\n                                 (exexs, h) \\<Rightarrow>\n                                   \\<lambda>ta s.\n\\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                                 tl1 (((e'', xs''), exs''), h2') \\<and>\n                         wbisim1 t (((e'', xs''), exs''), h2') s2' \\<and>\n                         ta_bisim wbisim1 tl1 tl2", "apply(rule exI[where x=\"ta'\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Red1_mthr.silent_moves True P t (((e, xs), exs), h)\n              (((e', xs'), exs'), h);\n     bisim1_list1 t h2' (e'', xs'') exs'' xcp' frs';\n     True,P,t \\<turnstile>1 \\<langle>(e', xs')/exs',\n                             h\\<rangle> -ta'\\<rightarrow>\n                            \\<langle>(e'', xs'')/exs'',h2'\\<rangle>;\n     \\<not> \\<tau>Move1 P h ((e', xs'), exs'); s1 = (((e, xs), exs), h1);\n     s2 = ((xcp, frs), h); s2' = ((xcp', frs'), h2'); h1 = h;\n     ta_bisim wbisim1 ta' tl2\\<rbrakk>\n    \\<Longrightarrow> Red1_mthr.silent_moves True P t s1\n                       (((e', xs'), exs'), h) \\<and>\n                      Red1_mthr.r_syntax True P t ((e', xs'), exs') h ta'\n                       ((e'', xs''), exs'') h2' \\<and>\n                      \\<not> (case (((e', xs'), exs'), h) of\n                              (exexs, h) \\<Rightarrow>\n                                \\<lambda>ta s.\n                                   \\<tau>Move1 P h exexs \\<and>\n                                   ta = \\<lbrace>\\<rbrace>)\n                              ta' (((e'', xs''), exs''), h2') \\<and>\n                      wbisim1 t (((e'', xs''), exs''), h2') s2' \\<and>\n                      ta_bisim wbisim1 ta' tl2", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>s1' s1'' tl1.\n     Red1_mthr.silent_moves True P t s1 s1' \\<and>\n     mred1 P t s1' tl1 s1'' \\<and>\n     \\<not> (case s1' of\n             (exexs, h) \\<Rightarrow>\n               \\<lambda>ta s.\n                  \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n             tl1 s1'' \\<and>\n     wbisim1 t s1'' s2' \\<and> ta_bisim wbisim1 tl1 tl2\n\ngoal (2 subgoals):\n 1. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 2. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 2. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "have \"wf (inv_image {(x, y). x < y} (\\<lambda>(((e, xs), exs), h). sim12_size e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (inv_image {(x, y). x < y}\n         (\\<lambda>(((e, xs), exs), h). sim12_size e))", "by(rule wf_inv_image)(rule wf_less)"], ["proof (state)\nthis:\n  wf (inv_image {(x, y). x < y}\n       (\\<lambda>(((e, xs), exs), h). sim12_size e))\n\ngoal (2 subgoals):\n 1. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 2. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "also"], ["proof (state)\nthis:\n  wf (inv_image {(x, y). x < y}\n       (\\<lambda>(((e, xs), exs), h). sim12_size e))\n\ngoal (2 subgoals):\n 1. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 2. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "have \"inv_image {(x, y). x < y} (\\<lambda>(((e, xs), exs), h). sim12_size e) =\n    {(x, y). (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h'). sim12_size e < sim12_size e') x y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_image {(x, y). x < y} (\\<lambda>(((e, xs), exs), h). sim12_size e) =\n    {(x, y).\n     (case x of\n      (x, xa) \\<Rightarrow>\n        (case x of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, xs) \\<Rightarrow>\n              \\<lambda>exs h (((e', xs'), exs'), h').\n                 sim12_size e < sim12_size e')\n            xa)\n         xa)\n      y}", "by auto"], ["proof (state)\nthis:\n  inv_image {(x, y). x < y} (\\<lambda>(((e, xs), exs), h). sim12_size e) =\n  {(x, y).\n   (case x of\n    (x, xa) \\<Rightarrow>\n      (case x of\n       (x, xa) \\<Rightarrow>\n         (case x of\n          (e, xs) \\<Rightarrow>\n            \\<lambda>exs h (((e', xs'), exs'), h').\n               sim12_size e < sim12_size e')\n          xa)\n       xa)\n    y}\n\ngoal (2 subgoals):\n 1. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')\n 2. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "finally"], ["proof (chain)\npicking this:\n  wf {(x, y).\n      (case x of\n       (x, xa) \\<Rightarrow>\n         (case x of\n          (x, xa) \\<Rightarrow>\n            (case x of\n             (e, xs) \\<Rightarrow>\n               \\<lambda>exs h (((e', xs'), exs'), h').\n                  sim12_size e < sim12_size e')\n             xa)\n          xa)\n       y}", "show \"wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h'). sim12_size e < sim12_size e')\""], ["proof (prove)\nusing this:\n  wf {(x, y).\n      (case x of\n       (x, xa) \\<Rightarrow>\n         (case x of\n          (x, xa) \\<Rightarrow>\n            (case x of\n             (e, xs) \\<Rightarrow>\n               \\<lambda>exs h (((e', xs'), exs'), h').\n                  sim12_size e < sim12_size e')\n             xa)\n          xa)\n       y}\n\ngoal (1 subgoal):\n 1. wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n            sim12_size e < sim12_size e')", "unfolding wfP_def"], ["proof (prove)\nusing this:\n  wf {(x, y).\n      (case x of\n       (x, xa) \\<Rightarrow>\n         (case x of\n          (x, xa) \\<Rightarrow>\n            (case x of\n             (e, xs) \\<Rightarrow>\n               \\<lambda>exs h (((e', xs'), exs'), h').\n                  sim12_size e < sim12_size e')\n             xa)\n          xa)\n       y}\n\ngoal (1 subgoal):\n 1. wf {((((e, xs), exs), h), ((e', xs'), exs'), h').\n        sim12_size e < sim12_size e'}", "."], ["proof (state)\nthis:\n  wfP (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n          sim12_size e < sim12_size e')\n\ngoal (1 subgoal):\n 1. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "from wfP_sim21_size"], ["proof (chain)\npicking this:\n  wfP (sim21_size ?P)", "have \"wf {(xcpfrs, xcpfrs'). sim21_size (compP2 P) xcpfrs xcpfrs'}\""], ["proof (prove)\nusing this:\n  wfP (sim21_size ?P)\n\ngoal (1 subgoal):\n 1. wf {(xcpfrs, xcpfrs'). sim21_size (compP2 P) xcpfrs xcpfrs'}", "by(unfold wfP_def)"], ["proof (state)\nthis:\n  wf {(xcpfrs, xcpfrs'). sim21_size (compP2 P) xcpfrs xcpfrs'}\n\ngoal (1 subgoal):\n 1. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "hence \"wf (inv_image {(xcpfrs, xcpfrs'). sim21_size (compP2 P) xcpfrs xcpfrs'} fst)\""], ["proof (prove)\nusing this:\n  wf {(xcpfrs, xcpfrs'). sim21_size (compP2 P) xcpfrs xcpfrs'}\n\ngoal (1 subgoal):\n 1. wf (inv_image {(xcpfrs, xcpfrs'). sim21_size (compP2 P) xcpfrs xcpfrs'}\n         fst)", "by(rule wf_inv_image)"], ["proof (state)\nthis:\n  wf (inv_image {(xcpfrs, xcpfrs'). sim21_size (compP2 P) xcpfrs xcpfrs'}\n       fst)\n\ngoal (1 subgoal):\n 1. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "also"], ["proof (state)\nthis:\n  wf (inv_image {(xcpfrs, xcpfrs'). sim21_size (compP2 P) xcpfrs xcpfrs'}\n       fst)\n\ngoal (1 subgoal):\n 1. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "have \"inv_image {(xcpfrs, xcpfrs'). sim21_size (compP2 P) xcpfrs xcpfrs'} fst =\n    {((xcpfrs, h), (xcpfrs', h)). sim21_size (compP2 P) xcpfrs xcpfrs'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_image {(xcpfrs, xcpfrs'). sim21_size (compP2 P) xcpfrs xcpfrs'}\n     fst =\n    {((xcpfrs, h), xcpfrs', h). sim21_size (compP2 P) xcpfrs xcpfrs'}", "by auto"], ["proof (state)\nthis:\n  inv_image {(xcpfrs, xcpfrs'). sim21_size (compP2 P) xcpfrs xcpfrs'} fst =\n  {((xcpfrs, h), xcpfrs', h). sim21_size (compP2 P) xcpfrs xcpfrs'}\n\ngoal (1 subgoal):\n 1. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "also"], ["proof (state)\nthis:\n  inv_image {(xcpfrs, xcpfrs'). sim21_size (compP2 P) xcpfrs xcpfrs'} fst =\n  {((xcpfrs, h), xcpfrs', h). sim21_size (compP2 P) xcpfrs xcpfrs'}\n\ngoal (1 subgoal):\n 1. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "have \"\\<dots> = {(x, y). (\\<lambda>(xcpfrs, h) (xcpfrs', h). sim21_size (compP2 P) xcpfrs xcpfrs') x y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {((xcpfrs, h), xcpfrs', h). sim21_size (compP2 P) xcpfrs xcpfrs'} =\n    {(x, y).\n     (case x of\n      (xcpfrs, h) \\<Rightarrow>\n        \\<lambda>(xcpfrs', h). sim21_size (compP2 P) xcpfrs xcpfrs')\n      y}", "by(auto)"], ["proof (state)\nthis:\n  {((xcpfrs, h), xcpfrs', h). sim21_size (compP2 P) xcpfrs xcpfrs'} =\n  {(x, y).\n   (case x of\n    (xcpfrs, h) \\<Rightarrow>\n      \\<lambda>(xcpfrs', h). sim21_size (compP2 P) xcpfrs xcpfrs')\n    y}\n\ngoal (1 subgoal):\n 1. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "finally"], ["proof (chain)\npicking this:\n  wf {(x, y).\n      (case x of\n       (xcpfrs, h) \\<Rightarrow>\n         \\<lambda>(xcpfrs', h). sim21_size (compP2 P) xcpfrs xcpfrs')\n       y}", "show \"wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h). sim21_size (compP2 P) xcpfrs xcpfrs')\""], ["proof (prove)\nusing this:\n  wf {(x, y).\n      (case x of\n       (xcpfrs, h) \\<Rightarrow>\n         \\<lambda>(xcpfrs', h). sim21_size (compP2 P) xcpfrs xcpfrs')\n       y}\n\ngoal (1 subgoal):\n 1. wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n            sim21_size (compP2 P) xcpfrs xcpfrs')", "unfolding wfP_def"], ["proof (prove)\nusing this:\n  wf {(x, y).\n      (case x of\n       (xcpfrs, h) \\<Rightarrow>\n         \\<lambda>(xcpfrs', h). sim21_size (compP2 P) xcpfrs xcpfrs')\n       y}\n\ngoal (1 subgoal):\n 1. wf {((xcpfrs, h), xcpfrs', h). sim21_size (compP2 P) xcpfrs xcpfrs'}", "."], ["proof (state)\nthis:\n  wfP (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n          sim21_size (compP2 P) xcpfrs xcpfrs')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Red1_execd_delay_bisim:\n  assumes wf: \"wf_J1_prog P\"\n  shows \"delay_bisimulation_diverge (mred1 P t) (mexecd (compP2 P) t) (wbisim1 t) (ta_bisim wbisim1) (\\<tau>MOVE1 P) (\\<tau>MOVE2 (compP2 P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge (mred1 P t) (mexecd (compP2 P) t) (wbisim1 t)\n     (ta_bisim wbisim1)\n     (\\<lambda>(exexs, h) ta s.\n         \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n     (\\<lambda>((xcp, frs), h) ta s.\n         \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n         ta = \\<lbrace>\\<rbrace>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge (mred1 P t) (mexecd (compP2 P) t) (wbisim1 t)\n     (ta_bisim wbisim1)\n     (\\<lambda>(exexs, h) ta s.\n         \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n     (\\<lambda>((xcp, frs), h) ta s.\n         \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n         ta = \\<lbrace>\\<rbrace>)", "interpret delay_bisimulation_measure\n    \"mred1 P t\" \"mexecd (compP2 P) t\" \"wbisim1 t\" \"ta_bisim wbisim1\" \"\\<tau>MOVE1 P\" \"\\<tau>MOVE2 (compP2 P)\"\n    \"\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h'). sim12_size e < sim12_size e'\"\n    \"\\<lambda>(xcpfrs, h) (xcpfrs', h). sim21_size (compP2 P) xcpfrs xcpfrs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_measure (mred1 P t) (mexecd (compP2 P) t) (wbisim1 t)\n     (ta_bisim wbisim1)\n     (\\<lambda>(exexs, h) ta s.\n         \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n     (\\<lambda>((xcp, frs), h) ta s.\n         \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n         ta = \\<lbrace>\\<rbrace>)\n     (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n         sim12_size e < sim12_size e')\n     (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n         sim21_size (compP2 P) xcpfrs xcpfrs')", "using wf"], ["proof (prove)\nusing this:\n  wf_J1_prog P\n\ngoal (1 subgoal):\n 1. delay_bisimulation_measure (mred1 P t) (mexecd (compP2 P) t) (wbisim1 t)\n     (ta_bisim wbisim1)\n     (\\<lambda>(exexs, h) ta s.\n         \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n     (\\<lambda>((xcp, frs), h) ta s.\n         \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n         ta = \\<lbrace>\\<rbrace>)\n     (\\<lambda>(((e, xs), exs), h) (((e', xs'), exs'), h').\n         sim12_size e < sim12_size e')\n     (\\<lambda>(xcpfrs, h) (xcpfrs', h).\n         sim21_size (compP2 P) xcpfrs xcpfrs')", "by(rule Red1_execd_weak_bisim)"], ["proof (state)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge (mred1 P t) (mexecd (compP2 P) t) (wbisim1 t)\n     (ta_bisim wbisim1)\n     (\\<lambda>(exexs, h) ta s.\n         \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n     (\\<lambda>((xcp, frs), h) ta s.\n         \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n         ta = \\<lbrace>\\<rbrace>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge (mred1 P t) (mexecd (compP2 P) t) (wbisim1 t)\n     (ta_bisim wbisim1)\n     (\\<lambda>(exexs, h) ta s.\n         \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n     (\\<lambda>((xcp, frs), h) ta s.\n         \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n         ta = \\<lbrace>\\<rbrace>)", "by(unfold_locales)"], ["proof (state)\nthis:\n  delay_bisimulation_diverge (mred1 P t) (mexecd (compP2 P) t) (wbisim1 t)\n   (ta_bisim wbisim1)\n   (\\<lambda>(exexs, h) ta s.\n       \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n   (\\<lambda>((xcp, frs), h) ta s.\n       \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "definition bisim_wait1JVM :: \n  \"'addr jvm_prog \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<times> ('addr expr1 \\<times> 'addr locals1) list \\<Rightarrow> 'addr jvm_thread_state \\<Rightarrow> bool\"\nwhere\n  \"bisim_wait1JVM P \\<equiv> \n  \\<lambda>((e1, xs1), exs1) (xcp, frs). call1 e1 \\<noteq> None \\<and> \n     (case frs of Nil \\<Rightarrow> False | (stk, loc, C, M, pc) # frs' \\<Rightarrow> \\<exists>M' n. instrs_of P C M ! pc = Invoke M' n)\""], ["", "sublocale J1_JVM_heap_conf_base < Red1_execd:\n  FWbisimulation_base \n    final_expr1\n    \"mred1 P\"\n    JVM_final\n    \"mexecd (compP2 P)\"\n    convert_RA\n    wbisim1\n    \"bisim_wait1JVM (compP2 P)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sublocale JVM_heap_base < execd_mthr:\n  \\<tau>multithreaded\n    JVM_final\n    \"mexecd P\"\n    convert_RA\n    \"\\<tau>MOVE2 P\"\n  for P"], ["proof (prove)\ngoal:\nNo subgoals!", "by(unfold_locales)"], ["", "sublocale J1_JVM_heap_conf_base < Red1_execd:\n  FWdelay_bisimulation_base \n    final_expr1\n    \"mred1 P\"\n    JVM_final\n    \"mexecd (compP2 P)\"\n    convert_RA\n    \"wbisim1\"\n    \"bisim_wait1JVM (compP2 P)\" \n    \"\\<tau>MOVE1 P\"\n    \"\\<tau>MOVE2 (compP2 P)\""], ["proof (prove)\ngoal:\nNo subgoals!", "by(unfold_locales)"], ["", "context J1_JVM_conf_read begin"], ["", "theorem Red1_exec1_FWwbisim:\n  assumes wf: \"wf_J1_prog P\"\n  shows \"FWdelay_bisimulation_diverge final_expr1 (mred1 P) JVM_final (mexecd (compP2 P)) wbisim1 (bisim_wait1JVM (compP2 P)) (\\<tau>MOVE1 P) (\\<tau>MOVE2 (compP2 P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FWdelay_bisimulation_diverge final_expr1 (mred1 P) JVM_final\n     (mexecd (compP2 P)) wbisim1 (bisim_wait1JVM (compP2 P))\n     (\\<lambda>(exexs, h) ta s.\n         \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n     (\\<lambda>((xcp, frs), h) ta s.\n         \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n         ta = \\<lbrace>\\<rbrace>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. FWdelay_bisimulation_diverge final_expr1 (mred1 P) JVM_final\n     (mexecd (compP2 P)) wbisim1 (bisim_wait1JVM (compP2 P))\n     (\\<lambda>(exexs, h) ta s.\n         \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n     (\\<lambda>((xcp, frs), h) ta s.\n         \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n         ta = \\<lbrace>\\<rbrace>)", "let ?exec = \"mexecd (compP2 P)\""], ["proof (state)\ngoal (1 subgoal):\n 1. FWdelay_bisimulation_diverge final_expr1 (mred1 P) JVM_final\n     (mexecd (compP2 P)) wbisim1 (bisim_wait1JVM (compP2 P))\n     (\\<lambda>(exexs, h) ta s.\n         \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n     (\\<lambda>((xcp, frs), h) ta s.\n         \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n         ta = \\<lbrace>\\<rbrace>)", "let ?\\<tau>exec = \"\\<lambda>t. \\<tau>trsys.silent_moves (mexecd (compP2 P) t) (\\<tau>MOVE2 (compP2 P))\""], ["proof (state)\ngoal (1 subgoal):\n 1. FWdelay_bisimulation_diverge final_expr1 (mred1 P) JVM_final\n     (mexecd (compP2 P)) wbisim1 (bisim_wait1JVM (compP2 P))\n     (\\<lambda>(exexs, h) ta s.\n         \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n     (\\<lambda>((xcp, frs), h) ta s.\n         \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n         ta = \\<lbrace>\\<rbrace>)", "let ?\\<tau>red = \"\\<lambda>t. \\<tau>trsys.silent_moves (mred1 P t) (\\<tau>MOVE1 P)\""], ["proof (state)\ngoal (1 subgoal):\n 1. FWdelay_bisimulation_diverge final_expr1 (mred1 P) JVM_final\n     (mexecd (compP2 P)) wbisim1 (bisim_wait1JVM (compP2 P))\n     (\\<lambda>(exexs, h) ta s.\n         \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n     (\\<lambda>((xcp, frs), h) ta s.\n         \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n         ta = \\<lbrace>\\<rbrace>)", "interpret delay_bisimulation_diverge \n    \"mred1 P t\" \"?exec t\" \"wbisim1 t\" \"ta_bisim wbisim1\" \"\\<tau>MOVE1 P\" \"\\<tau>MOVE2 (compP2 P)\"\n    for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge (mred1 P t) (mexecd (compP2 P) t) (wbisim1 t)\n     Red1_execd.ta_bisim_bisim_syntax\n     (\\<lambda>(exexs, h) ta s.\n         \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n     (\\<lambda>((xcp, frs), h) ta s.\n         \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n         ta = \\<lbrace>\\<rbrace>)", "using wf"], ["proof (prove)\nusing this:\n  wf_J1_prog P\n\ngoal (1 subgoal):\n 1. delay_bisimulation_diverge (mred1 P t) (mexecd (compP2 P) t) (wbisim1 t)\n     Red1_execd.ta_bisim_bisim_syntax\n     (\\<lambda>(exexs, h) ta s.\n         \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n     (\\<lambda>((xcp, frs), h) ta s.\n         \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n         ta = \\<lbrace>\\<rbrace>)", "by(rule Red1_execd_delay_bisim)"], ["proof (state)\ngoal (1 subgoal):\n 1. FWdelay_bisimulation_diverge final_expr1 (mred1 P) JVM_final\n     (mexecd (compP2 P)) wbisim1 (bisim_wait1JVM (compP2 P))\n     (\\<lambda>(exexs, h) ta s.\n         \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n     (\\<lambda>((xcp, frs), h) ta s.\n         \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n         ta = \\<lbrace>\\<rbrace>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. FWdelay_bisimulation_diverge final_expr1 (mred1 P) JVM_final\n     (mexecd (compP2 P)) wbisim1 (bisim_wait1JVM (compP2 P))\n     (\\<lambda>(exexs, h) ta s.\n         \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n     (\\<lambda>((xcp, frs), h) ta s.\n         \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n         ta = \\<lbrace>\\<rbrace>)", "proof"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>t s1 s2.\n       \\<lbrakk>wbisim1 t s1 s2;\n        case s1 of (x1, m) \\<Rightarrow> final_expr1 x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            wbisim1 t s1 s2' \\<and>\n                            (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n 2. \\<And>t s1 s2.\n       \\<lbrakk>wbisim1 t s1 s2;\n        case s2 of (x2, m) \\<Rightarrow> JVM_final x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            wbisim1 t s1' s2 \\<and>\n                            (case s1' of\n                             (x1, m) \\<Rightarrow> final_expr1 x1)\n 3. \\<And>t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'.\n       \\<lbrakk>wbisim1 t' (x, m1) (xx, m2); wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')\n 4. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 5. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 6. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 7. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "fix t s1 s2"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>t s1 s2.\n       \\<lbrakk>wbisim1 t s1 s2;\n        case s1 of (x1, m) \\<Rightarrow> final_expr1 x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            wbisim1 t s1 s2' \\<and>\n                            (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n 2. \\<And>t s1 s2.\n       \\<lbrakk>wbisim1 t s1 s2;\n        case s2 of (x2, m) \\<Rightarrow> JVM_final x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            wbisim1 t s1' s2 \\<and>\n                            (case s1' of\n                             (x1, m) \\<Rightarrow> final_expr1 x1)\n 3. \\<And>t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'.\n       \\<lbrakk>wbisim1 t' (x, m1) (xx, m2); wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')\n 4. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 5. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 6. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 7. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "assume \"wbisim1 t s1 s2\" \"(\\<lambda>(x1, m). final_expr1 x1) s1\""], ["proof (state)\nthis:\n  wbisim1 t s1 s2\n  case s1 of (x1, m) \\<Rightarrow> final_expr1 x1\n\ngoal (7 subgoals):\n 1. \\<And>t s1 s2.\n       \\<lbrakk>wbisim1 t s1 s2;\n        case s1 of (x1, m) \\<Rightarrow> final_expr1 x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            wbisim1 t s1 s2' \\<and>\n                            (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n 2. \\<And>t s1 s2.\n       \\<lbrakk>wbisim1 t s1 s2;\n        case s2 of (x2, m) \\<Rightarrow> JVM_final x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            wbisim1 t s1' s2 \\<and>\n                            (case s1' of\n                             (x1, m) \\<Rightarrow> final_expr1 x1)\n 3. \\<And>t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'.\n       \\<lbrakk>wbisim1 t' (x, m1) (xx, m2); wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')\n 4. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 5. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 6. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 7. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "moreover"], ["proof (state)\nthis:\n  wbisim1 t s1 s2\n  case s1 of (x1, m) \\<Rightarrow> final_expr1 x1\n\ngoal (7 subgoals):\n 1. \\<And>t s1 s2.\n       \\<lbrakk>wbisim1 t s1 s2;\n        case s1 of (x1, m) \\<Rightarrow> final_expr1 x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            wbisim1 t s1 s2' \\<and>\n                            (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n 2. \\<And>t s1 s2.\n       \\<lbrakk>wbisim1 t s1 s2;\n        case s2 of (x2, m) \\<Rightarrow> JVM_final x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            wbisim1 t s1' s2 \\<and>\n                            (case s1' of\n                             (x1, m) \\<Rightarrow> final_expr1 x1)\n 3. \\<And>t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'.\n       \\<lbrakk>wbisim1 t' (x, m1) (xx, m2); wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')\n 4. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 5. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 6. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 7. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "obtain e xs exs m1 where [simp]: \"s1 = (((e, xs), exs), m1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e xs exs m1.\n        s1 = (((e, xs), exs), m1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases s1) auto"], ["proof (state)\nthis:\n  s1 = (((e, xs), exs), m1)\n\ngoal (7 subgoals):\n 1. \\<And>t s1 s2.\n       \\<lbrakk>wbisim1 t s1 s2;\n        case s1 of (x1, m) \\<Rightarrow> final_expr1 x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            wbisim1 t s1 s2' \\<and>\n                            (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n 2. \\<And>t s1 s2.\n       \\<lbrakk>wbisim1 t s1 s2;\n        case s2 of (x2, m) \\<Rightarrow> JVM_final x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            wbisim1 t s1' s2 \\<and>\n                            (case s1' of\n                             (x1, m) \\<Rightarrow> final_expr1 x1)\n 3. \\<And>t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'.\n       \\<lbrakk>wbisim1 t' (x, m1) (xx, m2); wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')\n 4. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 5. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 6. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 7. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "moreover"], ["proof (state)\nthis:\n  s1 = (((e, xs), exs), m1)\n\ngoal (7 subgoals):\n 1. \\<And>t s1 s2.\n       \\<lbrakk>wbisim1 t s1 s2;\n        case s1 of (x1, m) \\<Rightarrow> final_expr1 x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            wbisim1 t s1 s2' \\<and>\n                            (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n 2. \\<And>t s1 s2.\n       \\<lbrakk>wbisim1 t s1 s2;\n        case s2 of (x2, m) \\<Rightarrow> JVM_final x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            wbisim1 t s1' s2 \\<and>\n                            (case s1' of\n                             (x1, m) \\<Rightarrow> final_expr1 x1)\n 3. \\<And>t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'.\n       \\<lbrakk>wbisim1 t' (x, m1) (xx, m2); wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')\n 4. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 5. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 6. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 7. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "obtain xcp frs m2 where [simp]: \"s2 = ((xcp, frs), m2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xcp frs m2.\n        s2 = ((xcp, frs), m2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s2) auto"], ["proof (state)\nthis:\n  s2 = ((xcp, frs), m2)\n\ngoal (7 subgoals):\n 1. \\<And>t s1 s2.\n       \\<lbrakk>wbisim1 t s1 s2;\n        case s1 of (x1, m) \\<Rightarrow> final_expr1 x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            wbisim1 t s1 s2' \\<and>\n                            (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n 2. \\<And>t s1 s2.\n       \\<lbrakk>wbisim1 t s1 s2;\n        case s2 of (x2, m) \\<Rightarrow> JVM_final x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            wbisim1 t s1' s2 \\<and>\n                            (case s1' of\n                             (x1, m) \\<Rightarrow> final_expr1 x1)\n 3. \\<And>t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'.\n       \\<lbrakk>wbisim1 t' (x, m1) (xx, m2); wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')\n 4. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 5. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 6. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 7. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "ultimately"], ["proof (chain)\npicking this:\n  wbisim1 t s1 s2\n  case s1 of (x1, m) \\<Rightarrow> final_expr1 x1\n  s1 = (((e, xs), exs), m1)\n  s2 = ((xcp, frs), m2)", "have [simp]: \"m2 = m1\" \"exs = []\"\n      and \"bisim1_list1 t m1 (e, xs) [] xcp frs\" \n      and \"final e\""], ["proof (prove)\nusing this:\n  wbisim1 t s1 s2\n  case s1 of (x1, m) \\<Rightarrow> final_expr1 x1\n  s1 = (((e, xs), exs), m1)\n  s2 = ((xcp, frs), m2)\n\ngoal (1 subgoal):\n 1. (m2 = m1 &&& exs = []) &&&\n    bisim1_list1 t m1 (e, xs) [] xcp frs &&& final e", "by auto"], ["proof (state)\nthis:\n  m2 = m1\n  exs = []\n  bisim1_list1 t m1 (e, xs) [] xcp frs\n  final e\n\ngoal (7 subgoals):\n 1. \\<And>t s1 s2.\n       \\<lbrakk>wbisim1 t s1 s2;\n        case s1 of (x1, m) \\<Rightarrow> final_expr1 x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            wbisim1 t s1 s2' \\<and>\n                            (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n 2. \\<And>t s1 s2.\n       \\<lbrakk>wbisim1 t s1 s2;\n        case s2 of (x2, m) \\<Rightarrow> JVM_final x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            wbisim1 t s1' s2 \\<and>\n                            (case s1' of\n                             (x1, m) \\<Rightarrow> final_expr1 x1)\n 3. \\<And>t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'.\n       \\<lbrakk>wbisim1 t' (x, m1) (xx, m2); wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')\n 4. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 5. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 6. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 7. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "from \\<open>bisim1_list1 t m1 (e, xs) [] xcp frs\\<close> \\<open>final e\\<close>"], ["proof (chain)\npicking this:\n  bisim1_list1 t m1 (e, xs) [] xcp frs\n  final e", "show \"\\<exists>s2'. ?\\<tau>exec t s2 s2' \\<and> wbisim1 t s1 s2' \\<and> (\\<lambda>(x2, m). JVM_final x2) s2'\""], ["proof (prove)\nusing this:\n  bisim1_list1 t m1 (e, xs) [] xcp frs\n  final e\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n       wbisim1 t s1 s2' \\<and>\n       (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>stk loc C M pc frsa Ts T body D.\n       \\<lbrakk>final e; frs = (stk, loc, C, M, pc) # frsa;\n        compTP\n         P \\<turnstile> t:(xcp, m1, (stk, loc, C, M, pc) # frsa) \\<surd>;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        P,blocks1 0 (Class D # Ts)\n           body,m1 \\<turnstile> (e, xs) \\<leftrightarrow> (stk, loc, pc,\n                     xcp);\n        max_vars e \\<le> length xs;\n        list_all2 (bisim1_fr P m1) [] frsa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            wbisim1 t s1 s2' \\<and>\n                            (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n 2. \\<And>v.\n       \\<lbrakk>final e; e = Val v; xcp = None; frs = []; hconf m1;\n        preallocated m1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            wbisim1 t s1 s2' \\<and>\n                            (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n 3. \\<And>a.\n       \\<lbrakk>final e; e = Throw a; xcp = \\<lfloor>a\\<rfloor>; frs = [];\n        hconf m1; preallocated m1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            wbisim1 t s1 s2' \\<and>\n                            (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "case (bl1_Normal stk loc C M pc frs' Ts T body D)"], ["proof (state)\nthis:\n  frs = (stk, loc, C, M, pc) # frs'\n  compTP P \\<turnstile> t:(xcp, m1, (stk, loc, C, M, pc) # frs') \\<surd>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\n  P,blocks1 0 (Class D # Ts)\n     body,m1 \\<turnstile> (e, xs) \\<leftrightarrow> (stk, loc, pc, xcp)\n  max_vars e \\<le> length xs\n  list_all2 (bisim1_fr P m1) [] frs'\n\ngoal (3 subgoals):\n 1. \\<And>stk loc C M pc frsa Ts T body D.\n       \\<lbrakk>final e; frs = (stk, loc, C, M, pc) # frsa;\n        compTP\n         P \\<turnstile> t:(xcp, m1, (stk, loc, C, M, pc) # frsa) \\<surd>;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        P,blocks1 0 (Class D # Ts)\n           body,m1 \\<turnstile> (e, xs) \\<leftrightarrow> (stk, loc, pc,\n                     xcp);\n        max_vars e \\<le> length xs;\n        list_all2 (bisim1_fr P m1) [] frsa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            wbisim1 t s1 s2' \\<and>\n                            (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n 2. \\<And>v.\n       \\<lbrakk>final e; e = Val v; xcp = None; frs = []; hconf m1;\n        preallocated m1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            wbisim1 t s1 s2' \\<and>\n                            (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n 3. \\<And>a.\n       \\<lbrakk>final e; e = Throw a; xcp = \\<lfloor>a\\<rfloor>; frs = [];\n        hconf m1; preallocated m1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            wbisim1 t s1 s2' \\<and>\n                            (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "hence [simp]: \"frs = [(stk, loc, C, M, pc)]\"\n        and conf: \"compTP P \\<turnstile> t:(xcp, m1, frs) \\<surd>\"\n        and sees: \"P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\"\n        and bisim: \"P,blocks1 0 (Class D # Ts) body,m1 \\<turnstile> (e, xs) \\<leftrightarrow> (stk, loc, pc, xcp)\"\n        and var: \"max_vars e \\<le> length xs\""], ["proof (prove)\nusing this:\n  frs = (stk, loc, C, M, pc) # frs'\n  compTP P \\<turnstile> t:(xcp, m1, (stk, loc, C, M, pc) # frs') \\<surd>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\n  P,blocks1 0 (Class D # Ts)\n     body,m1 \\<turnstile> (e, xs) \\<leftrightarrow> (stk, loc, pc, xcp)\n  max_vars e \\<le> length xs\n  list_all2 (bisim1_fr P m1) [] frs'\n\ngoal (1 subgoal):\n 1. (frs = [(stk, loc, C, M, pc)] &&&\n     compTP P \\<turnstile> t:(xcp, m1, frs) \\<surd>) &&&\n    P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D &&&\n    P,blocks1 0 (Class D # Ts)\n       body,m1 \\<turnstile> (e, xs) \\<leftrightarrow> (stk, loc, pc,\n                 xcp) &&&\n    max_vars e \\<le> length xs", "by auto"], ["proof (state)\nthis:\n  frs = [(stk, loc, C, M, pc)]\n  compTP P \\<turnstile> t:(xcp, m1, frs) \\<surd>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\n  P,blocks1 0 (Class D # Ts)\n     body,m1 \\<turnstile> (e, xs) \\<leftrightarrow> (stk, loc, pc, xcp)\n  max_vars e \\<le> length xs\n\ngoal (3 subgoals):\n 1. \\<And>stk loc C M pc frsa Ts T body D.\n       \\<lbrakk>final e; frs = (stk, loc, C, M, pc) # frsa;\n        compTP\n         P \\<turnstile> t:(xcp, m1, (stk, loc, C, M, pc) # frsa) \\<surd>;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        P,blocks1 0 (Class D # Ts)\n           body,m1 \\<turnstile> (e, xs) \\<leftrightarrow> (stk, loc, pc,\n                     xcp);\n        max_vars e \\<le> length xs;\n        list_all2 (bisim1_fr P m1) [] frsa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            wbisim1 t s1 s2' \\<and>\n                            (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n 2. \\<And>v.\n       \\<lbrakk>final e; e = Val v; xcp = None; frs = []; hconf m1;\n        preallocated m1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            wbisim1 t s1 s2' \\<and>\n                            (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n 3. \\<And>a.\n       \\<lbrakk>final e; e = Throw a; xcp = \\<lfloor>a\\<rfloor>; frs = [];\n        hconf m1; preallocated m1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            wbisim1 t s1 s2' \\<and>\n                            (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "from \\<open>final e\\<close>"], ["proof (chain)\npicking this:\n  final e", "show ?thesis"], ["proof (prove)\nusing this:\n  final e\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n       wbisim1 t s1 s2' \\<and>\n       (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       e = Val v \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n 2. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "fix v"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       e = Val v \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n 2. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "assume [simp]: \"e = Val v\""], ["proof (state)\nthis:\n  e = Val v\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       e = Val v \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n 2. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "with bisim"], ["proof (chain)\npicking this:\n  P,blocks1 0 (Class D # Ts)\n     body,m1 \\<turnstile> (e, xs) \\<leftrightarrow> (stk, loc, pc, xcp)\n  e = Val v", "have [simp]: \"xcp = None\" \"xs = loc\"\n          and exec: \"\\<tau>Exec_mover_a P t (blocks1 0 (Class D # Ts) body) m1 (stk, loc, pc, xcp) ([v], loc, length (compE2 body), None)\""], ["proof (prove)\nusing this:\n  P,blocks1 0 (Class D # Ts)\n     body,m1 \\<turnstile> (e, xs) \\<leftrightarrow> (stk, loc, pc, xcp)\n  e = Val v\n\ngoal (1 subgoal):\n 1. (xcp = None &&& xs = loc) &&&\n    \\<tau>Exec_mover_a P t (blocks1 0 (Class D # Ts) body) m1\n     (stk, loc, pc, xcp) ([v], loc, length (compE2 body), None)", "by(auto dest!: bisim1Val2D1)"], ["proof (state)\nthis:\n  xcp = None\n  xs = loc\n  \\<tau>Exec_mover_a P t (blocks1 0 (Class D # Ts) body) m1\n   (stk, loc, pc, xcp) ([v], loc, length (compE2 body), None)\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       e = Val v \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n 2. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "from exec"], ["proof (chain)\npicking this:\n  \\<tau>Exec_mover_a P t (blocks1 0 (Class D # Ts) body) m1\n   (stk, loc, pc, xcp) ([v], loc, length (compE2 body), None)", "have \"\\<tau>Exec_mover_a P t body m1 (stk, loc, pc, xcp) ([v], loc, length (compE2 body), None)\""], ["proof (prove)\nusing this:\n  \\<tau>Exec_mover_a P t (blocks1 0 (Class D # Ts) body) m1\n   (stk, loc, pc, xcp) ([v], loc, length (compE2 body), None)\n\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover_a P t body m1 (stk, loc, pc, xcp)\n     ([v], loc, length (compE2 body), None)", "unfolding  \\<tau>Exec_mover_blocks1"], ["proof (prove)\nusing this:\n  \\<tau>Exec_mover_a P t body m1 (stk, loc, pc, xcp)\n   ([v], loc, length (compE2 body), None)\n\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover_a P t body m1 (stk, loc, pc, xcp)\n     ([v], loc, length (compE2 body), None)", "."], ["proof (state)\nthis:\n  \\<tau>Exec_mover_a P t body m1 (stk, loc, pc, xcp)\n   ([v], loc, length (compE2 body), None)\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       e = Val v \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n 2. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "with sees"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\n  \\<tau>Exec_mover_a P t body m1 (stk, loc, pc, xcp)\n   ([v], loc, length (compE2 body), None)", "have \"\\<tau>Exec_1r (compP2 P) t (xcp, m1, frs) (None, m1, [([v], loc, C, M, length (compE2 body))])\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\n  \\<tau>Exec_mover_a P t body m1 (stk, loc, pc, xcp)\n   ([v], loc, length (compE2 body), None)\n\ngoal (1 subgoal):\n 1. \\<tau>Exec_1r (compP2 P) t (xcp, m1, frs)\n     (None, m1, [([v], loc, C, M, length (compE2 body))])", "by(auto intro: \\<tau>Exec_mover_\\<tau>Exec_1r)"], ["proof (state)\nthis:\n  \\<tau>Exec_1r (compP2 P) t (xcp, m1, frs)\n   (None, m1, [([v], loc, C, M, length (compE2 body))])\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       e = Val v \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n 2. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "with wt_compTP_compP2[OF wf]"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>compTP P\\<^esub> (compP2 P)\n  \\<tau>Exec_1r (compP2 P) t (xcp, m1, frs)\n   (None, m1, [([v], loc, C, M, length (compE2 body))])", "have execd: \"\\<tau>Exec_1_dr (compP2 P) t (xcp, m1, frs) (None, m1, [([v], loc, C, M, length (compE2 body))])\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>compTP P\\<^esub> (compP2 P)\n  \\<tau>Exec_1r (compP2 P) t (xcp, m1, frs)\n   (None, m1, [([v], loc, C, M, length (compE2 body))])\n\ngoal (1 subgoal):\n 1. \\<tau>Exec_1_dr (compP2 P) t (xcp, m1, frs)\n     (None, m1, [([v], loc, C, M, length (compE2 body))])", "using conf"], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>compTP P\\<^esub> (compP2 P)\n  \\<tau>Exec_1r (compP2 P) t (xcp, m1, frs)\n   (None, m1, [([v], loc, C, M, length (compE2 body))])\n  compTP P \\<turnstile> t:(xcp, m1, frs) \\<surd>\n\ngoal (1 subgoal):\n 1. \\<tau>Exec_1_dr (compP2 P) t (xcp, m1, frs)\n     (None, m1, [([v], loc, C, M, length (compE2 body))])", "by(rule \\<tau>Exec_1r_\\<tau>Exec_1_dr)"], ["proof (state)\nthis:\n  \\<tau>Exec_1_dr (compP2 P) t (xcp, m1, frs)\n   (None, m1, [([v], loc, C, M, length (compE2 body))])\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       e = Val v \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n 2. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "also"], ["proof (state)\nthis:\n  \\<tau>Exec_1_dr (compP2 P) t (xcp, m1, frs)\n   (None, m1, [([v], loc, C, M, length (compE2 body))])\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       e = Val v \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n 2. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "from sees_method_compP[OF sees, of \"\\<lambda>C M Ts T. compMb2\"] sees max_stack1[of body]"], ["proof (chain)\npicking this:\n  compP (\\<lambda>C M Ts T. compMb2)\n   P \\<turnstile> C sees M: Ts\\<rightarrow>T = map_option compMb2\n          \\<lfloor>body\\<rfloor> in D\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\n  1 \\<le> max_stack body", "have \"\\<tau>exec_1_d (compP2 P) t (None, m1, [([v], loc, C, M, length (compE2 body))]) (None, m1, [])\""], ["proof (prove)\nusing this:\n  compP (\\<lambda>C M Ts T. compMb2)\n   P \\<turnstile> C sees M: Ts\\<rightarrow>T = map_option compMb2\n          \\<lfloor>body\\<rfloor> in D\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\n  1 \\<le> max_stack body\n\ngoal (1 subgoal):\n 1. \\<tau>exec_1_d (compP2 P) t\n     (None, m1, [([v], loc, C, M, length (compE2 body))]) (None, m1, [])", "by(auto simp add: \\<tau>exec_1_d_def compP2_def compMb2_def check_def has_methodI intro: exec_1I)"], ["proof (state)\nthis:\n  \\<tau>exec_1_d (compP2 P) t\n   (None, m1, [([v], loc, C, M, length (compE2 body))]) (None, m1, [])\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       e = Val v \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n 2. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "finally"], ["proof (chain)\npicking this:\n  \\<tau>Exec_1_dr (compP2 P) t (xcp, m1, frs) (None, m1, [])", "have \"?\\<tau>exec t s2 ((None, []), m1)\""], ["proof (prove)\nusing this:\n  \\<tau>Exec_1_dr (compP2 P) t (xcp, m1, frs) (None, m1, [])\n\ngoal (1 subgoal):\n 1. execd_mthr.silent_moves (compP2 P) t s2 ((None, []), m1)", "unfolding \\<tau>Exec_1_dr_conv_rtranclp"], ["proof (prove)\nusing this:\n  execd_mthr.silent_moves (compP2 P) t ((xcp, frs), m1) ((None, []), m1)\n\ngoal (1 subgoal):\n 1. execd_mthr.silent_moves (compP2 P) t s2 ((None, []), m1)", "by simp"], ["proof (state)\nthis:\n  execd_mthr.silent_moves (compP2 P) t s2 ((None, []), m1)\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       e = Val v \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n 2. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "moreover"], ["proof (state)\nthis:\n  execd_mthr.silent_moves (compP2 P) t s2 ((None, []), m1)\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       e = Val v \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n 2. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "have \"JVM_final (None, [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. JVM_final (None, [])", "by simp"], ["proof (state)\nthis:\n  JVM_final (None, [])\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       e = Val v \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n 2. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "moreover"], ["proof (state)\nthis:\n  JVM_final (None, [])\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       e = Val v \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n 2. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "from conf"], ["proof (chain)\npicking this:\n  compTP P \\<turnstile> t:(xcp, m1, frs) \\<surd>", "have \"hconf m1\" \"preallocated m1\""], ["proof (prove)\nusing this:\n  compTP P \\<turnstile> t:(xcp, m1, frs) \\<surd>\n\ngoal (1 subgoal):\n 1. hconf m1 &&& preallocated m1", "unfolding correct_state_def"], ["proof (prove)\nusing this:\n  case (xcp, m1, frs) of\n  (xp, h, frs) \\<Rightarrow>\n    compP2 P,h \\<turnstile> t \\<surd>t \\<and>\n    hconf h \\<and>\n    preallocated h \\<and>\n    (case frs of [] \\<Rightarrow> True\n     | f # fs \\<Rightarrow>\n         let (stk, loc, C, M, pc) = f\n         in \\<exists>Ts T mxs mxl\\<^sub>0 is xt \\<tau>.\n               compP2\n                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                                mxl\\<^sub>0, is, xt)\\<rfloor> in C \\<and>\n               compTP P C M ! pc = \\<lfloor>\\<tau>\\<rfloor> \\<and>\n               conf_f (compP2 P) h \\<tau> is f \\<and>\n               conf_fs (compP2 P) h (compTP P) M (length Ts) T fs \\<and>\n               conf_xcp (compP2 P) h xp (is ! pc))\n\ngoal (1 subgoal):\n 1. hconf m1 &&& preallocated m1", "by(simp_all)"], ["proof (state)\nthis:\n  hconf m1\n  preallocated m1\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       e = Val v \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n 2. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "hence \"wbisim1 t s1 ((None, []), m1)\""], ["proof (prove)\nusing this:\n  hconf m1\n  preallocated m1\n\ngoal (1 subgoal):\n 1. wbisim1 t s1 ((None, []), m1)", "by(auto intro: bisim1_list1.intros)"], ["proof (state)\nthis:\n  wbisim1 t s1 ((None, []), m1)\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       e = Val v \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n 2. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "ultimately"], ["proof (chain)\npicking this:\n  execd_mthr.silent_moves (compP2 P) t s2 ((None, []), m1)\n  JVM_final (None, [])\n  wbisim1 t s1 ((None, []), m1)", "show ?thesis"], ["proof (prove)\nusing this:\n  execd_mthr.silent_moves (compP2 P) t s2 ((None, []), m1)\n  JVM_final (None, [])\n  wbisim1 t s1 ((None, []), m1)\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n       wbisim1 t s1 s2' \\<and>\n       (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n     wbisim1 t s1 s2' \\<and>\n     (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "assume [simp]: \"e = throw (addr a)\""], ["proof (state)\nthis:\n  e = Throw a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "hence \"\\<exists>stk' loc' pc'. \\<tau>Exec_mover_a P t body m1 (stk, loc, pc, xcp) (stk', loc', pc', \\<lfloor>a\\<rfloor>) \\<and> P,blocks1 0 (Class D # Ts) body,m1 \\<turnstile> (Throw a, xs) \\<leftrightarrow> (stk', loc', pc', \\<lfloor>a\\<rfloor>)\""], ["proof (prove)\nusing this:\n  e = Throw a\n\ngoal (1 subgoal):\n 1. \\<exists>stk' loc' pc'.\n       \\<tau>Exec_mover_a P t body m1 (stk, loc, pc, xcp)\n        (stk', loc', pc', \\<lfloor>a\\<rfloor>) \\<and>\n       P,blocks1 0 (Class D # Ts)\n          body,m1 \\<turnstile> (Throw a,\n                                xs) \\<leftrightarrow> (stk', loc', pc',\n                 \\<lfloor>a\\<rfloor>)", "proof(cases xcp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>e = Throw a; xcp = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>stk' loc' pc'.\n                         \\<tau>Exec_mover_a P t body m1 (stk, loc, pc, xcp)\n                          (stk', loc', pc', \\<lfloor>a\\<rfloor>) \\<and>\n                         P,blocks1 0 (Class D # Ts)\n                            body,m1 \\<turnstile> (Throw a,\n            xs) \\<leftrightarrow> (stk', loc', pc', \\<lfloor>a\\<rfloor>)\n 2. \\<And>aa.\n       \\<lbrakk>e = Throw a; xcp = \\<lfloor>aa\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stk' loc' pc'.\n                            \\<tau>Exec_mover_a P t body m1\n                             (stk, loc, pc, xcp)\n                             (stk', loc', pc', \\<lfloor>a\\<rfloor>) \\<and>\n                            P,blocks1 0 (Class D # Ts)\n                               body,m1 \\<turnstile> (Throw a,\n               xs) \\<leftrightarrow> (stk', loc', pc', \\<lfloor>a\\<rfloor>)", "case None"], ["proof (state)\nthis:\n  xcp = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>e = Throw a; xcp = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>stk' loc' pc'.\n                         \\<tau>Exec_mover_a P t body m1 (stk, loc, pc, xcp)\n                          (stk', loc', pc', \\<lfloor>a\\<rfloor>) \\<and>\n                         P,blocks1 0 (Class D # Ts)\n                            body,m1 \\<turnstile> (Throw a,\n            xs) \\<leftrightarrow> (stk', loc', pc', \\<lfloor>a\\<rfloor>)\n 2. \\<And>aa.\n       \\<lbrakk>e = Throw a; xcp = \\<lfloor>aa\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stk' loc' pc'.\n                            \\<tau>Exec_mover_a P t body m1\n                             (stk, loc, pc, xcp)\n                             (stk', loc', pc', \\<lfloor>a\\<rfloor>) \\<and>\n                            P,blocks1 0 (Class D # Ts)\n                               body,m1 \\<turnstile> (Throw a,\n               xs) \\<leftrightarrow> (stk', loc', pc', \\<lfloor>a\\<rfloor>)", "with bisim"], ["proof (chain)\npicking this:\n  P,blocks1 0 (Class D # Ts)\n     body,m1 \\<turnstile> (e, xs) \\<leftrightarrow> (stk, loc, pc, xcp)\n  xcp = None", "show ?thesis"], ["proof (prove)\nusing this:\n  P,blocks1 0 (Class D # Ts)\n     body,m1 \\<turnstile> (e, xs) \\<leftrightarrow> (stk, loc, pc, xcp)\n  xcp = None\n\ngoal (1 subgoal):\n 1. \\<exists>stk' loc' pc'.\n       \\<tau>Exec_mover_a P t body m1 (stk, loc, pc, xcp)\n        (stk', loc', pc', \\<lfloor>a\\<rfloor>) \\<and>\n       P,blocks1 0 (Class D # Ts)\n          body,m1 \\<turnstile> (Throw a,\n                                xs) \\<leftrightarrow> (stk', loc', pc',\n                 \\<lfloor>a\\<rfloor>)", "by(fastforce dest!: bisim1_Throw_\\<tau>Exec_movet simp del: blocks1.simps intro: tranclp_into_rtranclp)"], ["proof (state)\nthis:\n  \\<exists>stk' loc' pc'.\n     \\<tau>Exec_mover_a P t body m1 (stk, loc, pc, xcp)\n      (stk', loc', pc', \\<lfloor>a\\<rfloor>) \\<and>\n     P,blocks1 0 (Class D # Ts)\n        body,m1 \\<turnstile> (Throw a,\n                              xs) \\<leftrightarrow> (stk', loc', pc',\n               \\<lfloor>a\\<rfloor>)\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>e = Throw a; xcp = \\<lfloor>aa\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stk' loc' pc'.\n                            \\<tau>Exec_mover_a P t body m1\n                             (stk, loc, pc, xcp)\n                             (stk', loc', pc', \\<lfloor>a\\<rfloor>) \\<and>\n                            P,blocks1 0 (Class D # Ts)\n                               body,m1 \\<turnstile> (Throw a,\n               xs) \\<leftrightarrow> (stk', loc', pc', \\<lfloor>a\\<rfloor>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>e = Throw a; xcp = \\<lfloor>aa\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stk' loc' pc'.\n                            \\<tau>Exec_mover_a P t body m1\n                             (stk, loc, pc, xcp)\n                             (stk', loc', pc', \\<lfloor>a\\<rfloor>) \\<and>\n                            P,blocks1 0 (Class D # Ts)\n                               body,m1 \\<turnstile> (Throw a,\n               xs) \\<leftrightarrow> (stk', loc', pc', \\<lfloor>a\\<rfloor>)", "case (Some a')"], ["proof (state)\nthis:\n  xcp = \\<lfloor>a'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>e = Throw a; xcp = \\<lfloor>aa\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stk' loc' pc'.\n                            \\<tau>Exec_mover_a P t body m1\n                             (stk, loc, pc, xcp)\n                             (stk', loc', pc', \\<lfloor>a\\<rfloor>) \\<and>\n                            P,blocks1 0 (Class D # Ts)\n                               body,m1 \\<turnstile> (Throw a,\n               xs) \\<leftrightarrow> (stk', loc', pc', \\<lfloor>a\\<rfloor>)", "with bisim"], ["proof (chain)\npicking this:\n  P,blocks1 0 (Class D # Ts)\n     body,m1 \\<turnstile> (e, xs) \\<leftrightarrow> (stk, loc, pc, xcp)\n  xcp = \\<lfloor>a'\\<rfloor>", "have \"a = a'\""], ["proof (prove)\nusing this:\n  P,blocks1 0 (Class D # Ts)\n     body,m1 \\<turnstile> (e, xs) \\<leftrightarrow> (stk, loc, pc, xcp)\n  xcp = \\<lfloor>a'\\<rfloor>\n\ngoal (1 subgoal):\n 1. a = a'", "by(auto dest: bisim1_ThrowD)"], ["proof (state)\nthis:\n  a = a'\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>e = Throw a; xcp = \\<lfloor>aa\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stk' loc' pc'.\n                            \\<tau>Exec_mover_a P t body m1\n                             (stk, loc, pc, xcp)\n                             (stk', loc', pc', \\<lfloor>a\\<rfloor>) \\<and>\n                            P,blocks1 0 (Class D # Ts)\n                               body,m1 \\<turnstile> (Throw a,\n               xs) \\<leftrightarrow> (stk', loc', pc', \\<lfloor>a\\<rfloor>)", "with Some bisim"], ["proof (chain)\npicking this:\n  xcp = \\<lfloor>a'\\<rfloor>\n  P,blocks1 0 (Class D # Ts)\n     body,m1 \\<turnstile> (e, xs) \\<leftrightarrow> (stk, loc, pc, xcp)\n  a = a'", "show ?thesis"], ["proof (prove)\nusing this:\n  xcp = \\<lfloor>a'\\<rfloor>\n  P,blocks1 0 (Class D # Ts)\n     body,m1 \\<turnstile> (e, xs) \\<leftrightarrow> (stk, loc, pc, xcp)\n  a = a'\n\ngoal (1 subgoal):\n 1. \\<exists>stk' loc' pc'.\n       \\<tau>Exec_mover_a P t body m1 (stk, loc, pc, xcp)\n        (stk', loc', pc', \\<lfloor>a\\<rfloor>) \\<and>\n       P,blocks1 0 (Class D # Ts)\n          body,m1 \\<turnstile> (Throw a,\n                                xs) \\<leftrightarrow> (stk', loc', pc',\n                 \\<lfloor>a\\<rfloor>)", "by(auto)"], ["proof (state)\nthis:\n  \\<exists>stk' loc' pc'.\n     \\<tau>Exec_mover_a P t body m1 (stk, loc, pc, xcp)\n      (stk', loc', pc', \\<lfloor>a\\<rfloor>) \\<and>\n     P,blocks1 0 (Class D # Ts)\n        body,m1 \\<turnstile> (Throw a,\n                              xs) \\<leftrightarrow> (stk', loc', pc',\n               \\<lfloor>a\\<rfloor>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>stk' loc' pc'.\n     \\<tau>Exec_mover_a P t body m1 (stk, loc, pc, xcp)\n      (stk', loc', pc', \\<lfloor>a\\<rfloor>) \\<and>\n     P,blocks1 0 (Class D # Ts)\n        body,m1 \\<turnstile> (Throw a,\n                              xs) \\<leftrightarrow> (stk', loc', pc',\n               \\<lfloor>a\\<rfloor>)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "then"], ["proof (chain)\npicking this:\n  \\<exists>stk' loc' pc'.\n     \\<tau>Exec_mover_a P t body m1 (stk, loc, pc, xcp)\n      (stk', loc', pc', \\<lfloor>a\\<rfloor>) \\<and>\n     P,blocks1 0 (Class D # Ts)\n        body,m1 \\<turnstile> (Throw a,\n                              xs) \\<leftrightarrow> (stk', loc', pc',\n               \\<lfloor>a\\<rfloor>)", "obtain stk' loc' pc'\n          where exec: \"\\<tau>Exec_mover_a P t body m1 (stk, loc, pc, xcp) (stk', loc', pc', \\<lfloor>a\\<rfloor>)\" \n          and bisim': \"P,blocks1 0 (Class D # Ts) body,m1 \\<turnstile> (throw (addr a), xs) \\<leftrightarrow> (stk', loc', pc', \\<lfloor>a\\<rfloor>)\""], ["proof (prove)\nusing this:\n  \\<exists>stk' loc' pc'.\n     \\<tau>Exec_mover_a P t body m1 (stk, loc, pc, xcp)\n      (stk', loc', pc', \\<lfloor>a\\<rfloor>) \\<and>\n     P,blocks1 0 (Class D # Ts)\n        body,m1 \\<turnstile> (Throw a,\n                              xs) \\<leftrightarrow> (stk', loc', pc',\n               \\<lfloor>a\\<rfloor>)\n\ngoal (1 subgoal):\n 1. (\\<And>stk' loc' pc'.\n        \\<lbrakk>\\<tau>Exec_mover_a P t body m1 (stk, loc, pc, xcp)\n                  (stk', loc', pc', \\<lfloor>a\\<rfloor>);\n         P,blocks1 0 (Class D # Ts)\n            body,m1 \\<turnstile> (Throw a,\n                                  xs) \\<leftrightarrow> (stk', loc', pc',\n                   \\<lfloor>a\\<rfloor>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<tau>Exec_mover_a P t body m1 (stk, loc, pc, xcp)\n   (stk', loc', pc', \\<lfloor>a\\<rfloor>)\n  P,blocks1 0 (Class D # Ts)\n     body,m1 \\<turnstile> (Throw a,\n                           xs) \\<leftrightarrow> (stk', loc', pc',\n            \\<lfloor>a\\<rfloor>)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "with sees"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\n  \\<tau>Exec_mover_a P t body m1 (stk, loc, pc, xcp)\n   (stk', loc', pc', \\<lfloor>a\\<rfloor>)\n  P,blocks1 0 (Class D # Ts)\n     body,m1 \\<turnstile> (Throw a,\n                           xs) \\<leftrightarrow> (stk', loc', pc',\n            \\<lfloor>a\\<rfloor>)", "have \"\\<tau>Exec_1r (compP2 P) t (xcp, m1, frs) (\\<lfloor>a\\<rfloor>, m1, [(stk', loc', C, M, pc')])\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\n  \\<tau>Exec_mover_a P t body m1 (stk, loc, pc, xcp)\n   (stk', loc', pc', \\<lfloor>a\\<rfloor>)\n  P,blocks1 0 (Class D # Ts)\n     body,m1 \\<turnstile> (Throw a,\n                           xs) \\<leftrightarrow> (stk', loc', pc',\n            \\<lfloor>a\\<rfloor>)\n\ngoal (1 subgoal):\n 1. \\<tau>Exec_1r (compP2 P) t (xcp, m1, frs)\n     (\\<lfloor>a\\<rfloor>, m1, [(stk', loc', C, M, pc')])", "by(auto intro: \\<tau>Exec_mover_\\<tau>Exec_1r)"], ["proof (state)\nthis:\n  \\<tau>Exec_1r (compP2 P) t (xcp, m1, frs)\n   (\\<lfloor>a\\<rfloor>, m1, [(stk', loc', C, M, pc')])\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "with wt_compTP_compP2[OF wf]"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>compTP P\\<^esub> (compP2 P)\n  \\<tau>Exec_1r (compP2 P) t (xcp, m1, frs)\n   (\\<lfloor>a\\<rfloor>, m1, [(stk', loc', C, M, pc')])", "have execd: \"\\<tau>Exec_1_dr (compP2 P) t (xcp, m1, frs) (\\<lfloor>a\\<rfloor>, m1, [(stk', loc', C, M, pc')])\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>compTP P\\<^esub> (compP2 P)\n  \\<tau>Exec_1r (compP2 P) t (xcp, m1, frs)\n   (\\<lfloor>a\\<rfloor>, m1, [(stk', loc', C, M, pc')])\n\ngoal (1 subgoal):\n 1. \\<tau>Exec_1_dr (compP2 P) t (xcp, m1, frs)\n     (\\<lfloor>a\\<rfloor>, m1, [(stk', loc', C, M, pc')])", "using conf"], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>compTP P\\<^esub> (compP2 P)\n  \\<tau>Exec_1r (compP2 P) t (xcp, m1, frs)\n   (\\<lfloor>a\\<rfloor>, m1, [(stk', loc', C, M, pc')])\n  compTP P \\<turnstile> t:(xcp, m1, frs) \\<surd>\n\ngoal (1 subgoal):\n 1. \\<tau>Exec_1_dr (compP2 P) t (xcp, m1, frs)\n     (\\<lfloor>a\\<rfloor>, m1, [(stk', loc', C, M, pc')])", "by(rule \\<tau>Exec_1r_\\<tau>Exec_1_dr)"], ["proof (state)\nthis:\n  \\<tau>Exec_1_dr (compP2 P) t (xcp, m1, frs)\n   (\\<lfloor>a\\<rfloor>, m1, [(stk', loc', C, M, pc')])\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "also"], ["proof (state)\nthis:\n  \\<tau>Exec_1_dr (compP2 P) t (xcp, m1, frs)\n   (\\<lfloor>a\\<rfloor>, m1, [(stk', loc', C, M, pc')])\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "{"], ["proof (state)\nthis:\n  \\<tau>Exec_1_dr (compP2 P) t (xcp, m1, frs)\n   (\\<lfloor>a\\<rfloor>, m1, [(stk', loc', C, M, pc')])\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "from bisim1_xcp_Some_not_caught[OF bisim', of \"\\<lambda>C M Ts T. compMb2\" 0 0]"], ["proof (chain)\npicking this:\n  match_ex_table (compP (\\<lambda>C M Ts T. compMb2) P) (cname_of m1 a)\n   (0 + pc') (compxE2 (blocks1 0 (Class D # Ts) body) 0 0) =\n  None", "have \"match_ex_table (compP2 P) (cname_of m1 a) pc' (compxE2 body 0 0) = None\""], ["proof (prove)\nusing this:\n  match_ex_table (compP (\\<lambda>C M Ts T. compMb2) P) (cname_of m1 a)\n   (0 + pc') (compxE2 (blocks1 0 (Class D # Ts) body) 0 0) =\n  None\n\ngoal (1 subgoal):\n 1. match_ex_table (compP2 P) (cname_of m1 a) pc' (compxE2 body 0 0) = None", "by(simp add: compP2_def)"], ["proof (state)\nthis:\n  match_ex_table (compP2 P) (cname_of m1 a) pc' (compxE2 body 0 0) = None\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "moreover"], ["proof (state)\nthis:\n  match_ex_table (compP2 P) (cname_of m1 a) pc' (compxE2 body 0 0) = None\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "from bisim'"], ["proof (chain)\npicking this:\n  P,blocks1 0 (Class D # Ts)\n     body,m1 \\<turnstile> (Throw a,\n                           xs) \\<leftrightarrow> (stk', loc', pc',\n            \\<lfloor>a\\<rfloor>)", "have \"pc' < length (compE2 body)\""], ["proof (prove)\nusing this:\n  P,blocks1 0 (Class D # Ts)\n     body,m1 \\<turnstile> (Throw a,\n                           xs) \\<leftrightarrow> (stk', loc', pc',\n            \\<lfloor>a\\<rfloor>)\n\ngoal (1 subgoal):\n 1. pc' < length (compE2 body)", "by(auto dest: bisim1_ThrowD)"], ["proof (state)\nthis:\n  pc' < length (compE2 body)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "ultimately"], ["proof (chain)\npicking this:\n  match_ex_table (compP2 P) (cname_of m1 a) pc' (compxE2 body 0 0) = None\n  pc' < length (compE2 body)", "have \"\\<tau>exec_1 (compP2 P) t (\\<lfloor>a\\<rfloor>, m1, [(stk', loc', C, M, pc')]) (\\<lfloor>a\\<rfloor>, m1, [])\""], ["proof (prove)\nusing this:\n  match_ex_table (compP2 P) (cname_of m1 a) pc' (compxE2 body 0 0) = None\n  pc' < length (compE2 body)\n\ngoal (1 subgoal):\n 1. \\<tau>exec_1 (compP2 P) t\n     (\\<lfloor>a\\<rfloor>, m1, [(stk', loc', C, M, pc')])\n     (\\<lfloor>a\\<rfloor>, m1, [])", "using sees_method_compP[OF sees, of \"\\<lambda>C M Ts T. compMb2\"] sees"], ["proof (prove)\nusing this:\n  match_ex_table (compP2 P) (cname_of m1 a) pc' (compxE2 body 0 0) = None\n  pc' < length (compE2 body)\n  compP (\\<lambda>C M Ts T. compMb2)\n   P \\<turnstile> C sees M: Ts\\<rightarrow>T = map_option compMb2\n          \\<lfloor>body\\<rfloor> in D\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\n\ngoal (1 subgoal):\n 1. \\<tau>exec_1 (compP2 P) t\n     (\\<lfloor>a\\<rfloor>, m1, [(stk', loc', C, M, pc')])\n     (\\<lfloor>a\\<rfloor>, m1, [])", "by(auto simp add: \\<tau>exec_1_def compP2_def compMb2_def has_methodI intro: exec_1I)"], ["proof (state)\nthis:\n  \\<tau>exec_1 (compP2 P) t\n   (\\<lfloor>a\\<rfloor>, m1, [(stk', loc', C, M, pc')])\n   (\\<lfloor>a\\<rfloor>, m1, [])\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "moreover"], ["proof (state)\nthis:\n  \\<tau>exec_1 (compP2 P) t\n   (\\<lfloor>a\\<rfloor>, m1, [(stk', loc', C, M, pc')])\n   (\\<lfloor>a\\<rfloor>, m1, [])\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "from wt_compTP_compP2[OF wf] execd conf"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>compTP P\\<^esub> (compP2 P)\n  \\<tau>Exec_1_dr (compP2 P) t (xcp, m1, frs)\n   (\\<lfloor>a\\<rfloor>, m1, [(stk', loc', C, M, pc')])\n  compTP P \\<turnstile> t:(xcp, m1, frs) \\<surd>", "have \"compTP P \\<turnstile> t:(\\<lfloor>a\\<rfloor>, m1, [(stk', loc', C, M, pc')]) \\<surd>\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>compTP P\\<^esub> (compP2 P)\n  \\<tau>Exec_1_dr (compP2 P) t (xcp, m1, frs)\n   (\\<lfloor>a\\<rfloor>, m1, [(stk', loc', C, M, pc')])\n  compTP P \\<turnstile> t:(xcp, m1, frs) \\<surd>\n\ngoal (1 subgoal):\n 1. compTP\n     P \\<turnstile> t:(\\<lfloor>a\\<rfloor>, m1,\n                       [(stk', loc', C, M, pc')]) \\<surd>", "by(rule \\<tau>Exec_1_dr_preserves_correct_state)"], ["proof (state)\nthis:\n  compTP\n   P \\<turnstile> t:(\\<lfloor>a\\<rfloor>, m1,\n                     [(stk', loc', C, M, pc')]) \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "ultimately"], ["proof (chain)\npicking this:\n  \\<tau>exec_1 (compP2 P) t\n   (\\<lfloor>a\\<rfloor>, m1, [(stk', loc', C, M, pc')])\n   (\\<lfloor>a\\<rfloor>, m1, [])\n  compTP\n   P \\<turnstile> t:(\\<lfloor>a\\<rfloor>, m1,\n                     [(stk', loc', C, M, pc')]) \\<surd>", "have \"\\<tau>exec_1_d (compP2 P) t (\\<lfloor>a\\<rfloor>, m1, [(stk', loc', C, M, pc')]) (\\<lfloor>a\\<rfloor>, m1, [])\""], ["proof (prove)\nusing this:\n  \\<tau>exec_1 (compP2 P) t\n   (\\<lfloor>a\\<rfloor>, m1, [(stk', loc', C, M, pc')])\n   (\\<lfloor>a\\<rfloor>, m1, [])\n  compTP\n   P \\<turnstile> t:(\\<lfloor>a\\<rfloor>, m1,\n                     [(stk', loc', C, M, pc')]) \\<surd>\n\ngoal (1 subgoal):\n 1. \\<tau>exec_1_d (compP2 P) t\n     (\\<lfloor>a\\<rfloor>, m1, [(stk', loc', C, M, pc')])\n     (\\<lfloor>a\\<rfloor>, m1, [])", "using wt_compTP_compP2[OF wf]"], ["proof (prove)\nusing this:\n  \\<tau>exec_1 (compP2 P) t\n   (\\<lfloor>a\\<rfloor>, m1, [(stk', loc', C, M, pc')])\n   (\\<lfloor>a\\<rfloor>, m1, [])\n  compTP\n   P \\<turnstile> t:(\\<lfloor>a\\<rfloor>, m1,\n                     [(stk', loc', C, M, pc')]) \\<surd>\n  wf_jvm_prog\\<^bsub>compTP P\\<^esub> (compP2 P)\n\ngoal (1 subgoal):\n 1. \\<tau>exec_1_d (compP2 P) t\n     (\\<lfloor>a\\<rfloor>, m1, [(stk', loc', C, M, pc')])\n     (\\<lfloor>a\\<rfloor>, m1, [])", "by(auto simp add: \\<tau>exec_1_def \\<tau>exec_1_d_def welltyped_commute[symmetric] elim: jvmd_NormalE)"], ["proof (state)\nthis:\n  \\<tau>exec_1_d (compP2 P) t\n   (\\<lfloor>a\\<rfloor>, m1, [(stk', loc', C, M, pc')])\n   (\\<lfloor>a\\<rfloor>, m1, [])\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "}"], ["proof (state)\nthis:\n  \\<tau>exec_1_d (compP2 P) t\n   (\\<lfloor>a\\<rfloor>, m1, [(stk', loc', C, M, pc')])\n   (\\<lfloor>a\\<rfloor>, m1, [])\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "finally"], ["proof (chain)\npicking this:\n  \\<tau>Exec_1_dr (compP2 P) t (xcp, m1, frs) (\\<lfloor>a\\<rfloor>, m1, [])", "have \"?\\<tau>exec t s2 ((\\<lfloor>a\\<rfloor>, []), m1)\""], ["proof (prove)\nusing this:\n  \\<tau>Exec_1_dr (compP2 P) t (xcp, m1, frs) (\\<lfloor>a\\<rfloor>, m1, [])\n\ngoal (1 subgoal):\n 1. execd_mthr.silent_moves (compP2 P) t s2 ((\\<lfloor>a\\<rfloor>, []), m1)", "unfolding \\<tau>Exec_1_dr_conv_rtranclp"], ["proof (prove)\nusing this:\n  execd_mthr.silent_moves (compP2 P) t ((xcp, frs), m1)\n   ((\\<lfloor>a\\<rfloor>, []), m1)\n\ngoal (1 subgoal):\n 1. execd_mthr.silent_moves (compP2 P) t s2 ((\\<lfloor>a\\<rfloor>, []), m1)", "by simp"], ["proof (state)\nthis:\n  execd_mthr.silent_moves (compP2 P) t s2 ((\\<lfloor>a\\<rfloor>, []), m1)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "moreover"], ["proof (state)\nthis:\n  execd_mthr.silent_moves (compP2 P) t s2 ((\\<lfloor>a\\<rfloor>, []), m1)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "have \"JVM_final (\\<lfloor>a\\<rfloor>, [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. JVM_final (\\<lfloor>a\\<rfloor>, [])", "by simp"], ["proof (state)\nthis:\n  JVM_final (\\<lfloor>a\\<rfloor>, [])\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "moreover"], ["proof (state)\nthis:\n  JVM_final (\\<lfloor>a\\<rfloor>, [])\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "from conf"], ["proof (chain)\npicking this:\n  compTP P \\<turnstile> t:(xcp, m1, frs) \\<surd>", "have \"hconf m1\" \"preallocated m1\""], ["proof (prove)\nusing this:\n  compTP P \\<turnstile> t:(xcp, m1, frs) \\<surd>\n\ngoal (1 subgoal):\n 1. hconf m1 &&& preallocated m1", "by(simp_all add: correct_state_def)"], ["proof (state)\nthis:\n  hconf m1\n  preallocated m1\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "hence \"wbisim1 t s1 ((\\<lfloor>a\\<rfloor>, []), m1)\""], ["proof (prove)\nusing this:\n  hconf m1\n  preallocated m1\n\ngoal (1 subgoal):\n 1. wbisim1 t s1 ((\\<lfloor>a\\<rfloor>, []), m1)", "by(auto intro: bisim1_list1.intros)"], ["proof (state)\nthis:\n  wbisim1 t s1 ((\\<lfloor>a\\<rfloor>, []), m1)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       e = Throw a \\<Longrightarrow>\n       \\<exists>s2'.\n          execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n          wbisim1 t s1 s2' \\<and>\n          (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "ultimately"], ["proof (chain)\npicking this:\n  execd_mthr.silent_moves (compP2 P) t s2 ((\\<lfloor>a\\<rfloor>, []), m1)\n  JVM_final (\\<lfloor>a\\<rfloor>, [])\n  wbisim1 t s1 ((\\<lfloor>a\\<rfloor>, []), m1)", "show ?thesis"], ["proof (prove)\nusing this:\n  execd_mthr.silent_moves (compP2 P) t s2 ((\\<lfloor>a\\<rfloor>, []), m1)\n  JVM_final (\\<lfloor>a\\<rfloor>, [])\n  wbisim1 t s1 ((\\<lfloor>a\\<rfloor>, []), m1)\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n       wbisim1 t s1 s2' \\<and>\n       (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n     wbisim1 t s1 s2' \\<and>\n     (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n     wbisim1 t s1 s2' \\<and>\n     (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>final e; e = Val v; xcp = None; frs = []; hconf m1;\n        preallocated m1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            wbisim1 t s1 s2' \\<and>\n                            (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n 2. \\<And>a.\n       \\<lbrakk>final e; e = Throw a; xcp = \\<lfloor>a\\<rfloor>; frs = [];\n        hconf m1; preallocated m1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            execd_mthr.silent_moves (compP2 P) t s2\n                             s2' \\<and>\n                            wbisim1 t s1 s2' \\<and>\n                            (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)", "qed(auto intro!: exI bisim1_list1.intros)"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     execd_mthr.silent_moves (compP2 P) t s2 s2' \\<and>\n     wbisim1 t s1 s2' \\<and>\n     (case s2' of (x2, m) \\<Rightarrow> JVM_final x2)\n\ngoal (6 subgoals):\n 1. \\<And>t s1 s2.\n       \\<lbrakk>wbisim1 t s1 s2;\n        case s2 of (x2, m) \\<Rightarrow> JVM_final x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            wbisim1 t s1' s2 \\<and>\n                            (case s1' of\n                             (x1, m) \\<Rightarrow> final_expr1 x1)\n 2. \\<And>t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'.\n       \\<lbrakk>wbisim1 t' (x, m1) (xx, m2); wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')\n 3. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 4. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 5. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 6. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>t s1 s2.\n       \\<lbrakk>wbisim1 t s1 s2;\n        case s2 of (x2, m) \\<Rightarrow> JVM_final x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            wbisim1 t s1' s2 \\<and>\n                            (case s1' of\n                             (x1, m) \\<Rightarrow> final_expr1 x1)\n 2. \\<And>t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'.\n       \\<lbrakk>wbisim1 t' (x, m1) (xx, m2); wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')\n 3. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 4. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 5. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 6. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "fix t s1 s2"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>t s1 s2.\n       \\<lbrakk>wbisim1 t s1 s2;\n        case s2 of (x2, m) \\<Rightarrow> JVM_final x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            wbisim1 t s1' s2 \\<and>\n                            (case s1' of\n                             (x1, m) \\<Rightarrow> final_expr1 x1)\n 2. \\<And>t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'.\n       \\<lbrakk>wbisim1 t' (x, m1) (xx, m2); wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')\n 3. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 4. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 5. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 6. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "assume \"wbisim1 t s1 s2\" \"(\\<lambda>(x2, m). JVM_final x2) s2\""], ["proof (state)\nthis:\n  wbisim1 t s1 s2\n  case s2 of (x2, m) \\<Rightarrow> JVM_final x2\n\ngoal (6 subgoals):\n 1. \\<And>t s1 s2.\n       \\<lbrakk>wbisim1 t s1 s2;\n        case s2 of (x2, m) \\<Rightarrow> JVM_final x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            wbisim1 t s1' s2 \\<and>\n                            (case s1' of\n                             (x1, m) \\<Rightarrow> final_expr1 x1)\n 2. \\<And>t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'.\n       \\<lbrakk>wbisim1 t' (x, m1) (xx, m2); wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')\n 3. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 4. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 5. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 6. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "moreover"], ["proof (state)\nthis:\n  wbisim1 t s1 s2\n  case s2 of (x2, m) \\<Rightarrow> JVM_final x2\n\ngoal (6 subgoals):\n 1. \\<And>t s1 s2.\n       \\<lbrakk>wbisim1 t s1 s2;\n        case s2 of (x2, m) \\<Rightarrow> JVM_final x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            wbisim1 t s1' s2 \\<and>\n                            (case s1' of\n                             (x1, m) \\<Rightarrow> final_expr1 x1)\n 2. \\<And>t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'.\n       \\<lbrakk>wbisim1 t' (x, m1) (xx, m2); wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')\n 3. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 4. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 5. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 6. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "obtain e xs exs m1 where [simp]: \"s1 = (((e, xs), exs), m1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e xs exs m1.\n        s1 = (((e, xs), exs), m1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases s1) auto"], ["proof (state)\nthis:\n  s1 = (((e, xs), exs), m1)\n\ngoal (6 subgoals):\n 1. \\<And>t s1 s2.\n       \\<lbrakk>wbisim1 t s1 s2;\n        case s2 of (x2, m) \\<Rightarrow> JVM_final x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            wbisim1 t s1' s2 \\<and>\n                            (case s1' of\n                             (x1, m) \\<Rightarrow> final_expr1 x1)\n 2. \\<And>t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'.\n       \\<lbrakk>wbisim1 t' (x, m1) (xx, m2); wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')\n 3. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 4. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 5. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 6. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "moreover"], ["proof (state)\nthis:\n  s1 = (((e, xs), exs), m1)\n\ngoal (6 subgoals):\n 1. \\<And>t s1 s2.\n       \\<lbrakk>wbisim1 t s1 s2;\n        case s2 of (x2, m) \\<Rightarrow> JVM_final x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            wbisim1 t s1' s2 \\<and>\n                            (case s1' of\n                             (x1, m) \\<Rightarrow> final_expr1 x1)\n 2. \\<And>t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'.\n       \\<lbrakk>wbisim1 t' (x, m1) (xx, m2); wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')\n 3. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 4. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 5. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 6. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "obtain xcp frs m2 where [simp]: \"s2 = ((xcp, frs), m2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xcp frs m2.\n        s2 = ((xcp, frs), m2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s2) auto"], ["proof (state)\nthis:\n  s2 = ((xcp, frs), m2)\n\ngoal (6 subgoals):\n 1. \\<And>t s1 s2.\n       \\<lbrakk>wbisim1 t s1 s2;\n        case s2 of (x2, m) \\<Rightarrow> JVM_final x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            wbisim1 t s1' s2 \\<and>\n                            (case s1' of\n                             (x1, m) \\<Rightarrow> final_expr1 x1)\n 2. \\<And>t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'.\n       \\<lbrakk>wbisim1 t' (x, m1) (xx, m2); wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')\n 3. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 4. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 5. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 6. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "ultimately"], ["proof (chain)\npicking this:\n  wbisim1 t s1 s2\n  case s2 of (x2, m) \\<Rightarrow> JVM_final x2\n  s1 = (((e, xs), exs), m1)\n  s2 = ((xcp, frs), m2)", "have [simp]: \"m2 = m1\" \"exs = []\" \"frs = []\"\n      and bisim: \"bisim1_list1 t m1 (e, xs) [] xcp []\""], ["proof (prove)\nusing this:\n  wbisim1 t s1 s2\n  case s2 of (x2, m) \\<Rightarrow> JVM_final x2\n  s1 = (((e, xs), exs), m1)\n  s2 = ((xcp, frs), m2)\n\ngoal (1 subgoal):\n 1. (m2 = m1 &&& exs = [] &&& frs = []) &&&\n    bisim1_list1 t m1 (e, xs) [] xcp []", "by(auto elim: bisim1_list1.cases)"], ["proof (state)\nthis:\n  m2 = m1\n  exs = []\n  frs = []\n  bisim1_list1 t m1 (e, xs) [] xcp []\n\ngoal (6 subgoals):\n 1. \\<And>t s1 s2.\n       \\<lbrakk>wbisim1 t s1 s2;\n        case s2 of (x2, m) \\<Rightarrow> JVM_final x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            wbisim1 t s1' s2 \\<and>\n                            (case s1' of\n                             (x1, m) \\<Rightarrow> final_expr1 x1)\n 2. \\<And>t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'.\n       \\<lbrakk>wbisim1 t' (x, m1) (xx, m2); wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')\n 3. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 4. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 5. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 6. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "hence \"final e\""], ["proof (prove)\nusing this:\n  m2 = m1\n  exs = []\n  frs = []\n  bisim1_list1 t m1 (e, xs) [] xcp []\n\ngoal (1 subgoal):\n 1. final e", "by(auto elim: bisim1_list1.cases)"], ["proof (state)\nthis:\n  final e\n\ngoal (6 subgoals):\n 1. \\<And>t s1 s2.\n       \\<lbrakk>wbisim1 t s1 s2;\n        case s2 of (x2, m) \\<Rightarrow> JVM_final x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Red1_mthr.silent_moves True P t s1 s1' \\<and>\n                            wbisim1 t s1' s2 \\<and>\n                            (case s1' of\n                             (x1, m) \\<Rightarrow> final_expr1 x1)\n 2. \\<And>t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'.\n       \\<lbrakk>wbisim1 t' (x, m1) (xx, m2); wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')\n 3. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 4. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 5. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 6. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "thus \"\\<exists>s1'. ?\\<tau>red t s1 s1' \\<and> wbisim1 t s1' s2 \\<and> (\\<lambda>(x1, m). final_expr1 x1) s1'\""], ["proof (prove)\nusing this:\n  final e\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Red1_mthr.silent_moves True P t s1 s1' \\<and>\n       wbisim1 t s1' s2 \\<and>\n       (case s1' of (x1, m) \\<Rightarrow> final_expr1 x1)", "using bisim"], ["proof (prove)\nusing this:\n  final e\n  bisim1_list1 t m1 (e, xs) [] xcp []\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Red1_mthr.silent_moves True P t s1 s1' \\<and>\n       wbisim1 t s1' s2 \\<and>\n       (case s1' of (x1, m) \\<Rightarrow> final_expr1 x1)", "by auto"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Red1_mthr.silent_moves True P t s1 s1' \\<and>\n     wbisim1 t s1' s2 \\<and>\n     (case s1' of (x1, m) \\<Rightarrow> final_expr1 x1)\n\ngoal (5 subgoals):\n 1. \\<And>t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'.\n       \\<lbrakk>wbisim1 t' (x, m1) (xx, m2); wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')\n 2. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 3. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 4. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 5. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'.\n       \\<lbrakk>wbisim1 t' (x, m1) (xx, m2); wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')\n 2. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 3. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 4. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 5. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "fix t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'.\n       \\<lbrakk>wbisim1 t' (x, m1) (xx, m2); wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')\n 2. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 3. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 4. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 5. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "assume b: \"wbisim1 t' (x, m1) (xx, m2)\" and b': \"wbisim1 t (x1, m1) (x2, m2)\"\n      and \\<tau>red: \"?\\<tau>red t (x1, m1) (x1', m1)\"\n      and red: \"mred1 P t (x1', m1) ta1 (x1'', m1')\"\n      and \"\\<not> \\<tau>MOVE1 P (x1', m1) ta1 (x1'', m1')\"\n      and \\<tau>exec: \"?\\<tau>exec t (x2, m2) (x2', m2)\"\n      and exec: \"?exec t (x2', m2) ta2 (x2'', m2')\"\n      and \"\\<not> \\<tau>MOVE2 (compP2 P) (x2', m2) ta2 (x2'', m2')\"\n      and b2: \"wbisim1 t (x1'', m1') (x2'', m2')\""], ["proof (state)\nthis:\n  wbisim1 t' (x, m1) (xx, m2)\n  wbisim1 t (x1, m1) (x2, m2)\n  Red1_mthr.silent_moves True P t (x1, m1) (x1', m1)\n  Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1'\n  \\<not> (case (x1', m1) of\n          (exexs, h) \\<Rightarrow>\n            \\<lambda>ta s.\n               \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n          ta1 (x1'', m1')\n  execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2)\n  execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2'\n  \\<not> (case (x2', m2) of\n          (x, xa) \\<Rightarrow>\n            (case x of\n             (xcp, frs) \\<Rightarrow>\n               \\<lambda>h ta s.\n                  \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                  ta = \\<lbrace>\\<rbrace>)\n             xa)\n          ta2 (x2'', m2')\n  wbisim1 t (x1'', m1') (x2'', m2')\n\ngoal (5 subgoals):\n 1. \\<And>t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'.\n       \\<lbrakk>wbisim1 t' (x, m1) (xx, m2); wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')\n 2. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 3. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 4. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 5. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "from red"], ["proof (chain)\npicking this:\n  Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1'", "have \"hext m1 m1'\""], ["proof (prove)\nusing this:\n  Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1'\n\ngoal (1 subgoal):\n 1. m1 \\<unlhd> m1'", "by(auto simp add: split_beta intro: Red1_hext_incr)"], ["proof (state)\nthis:\n  m1 \\<unlhd> m1'\n\ngoal (5 subgoals):\n 1. \\<And>t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'.\n       \\<lbrakk>wbisim1 t' (x, m1) (xx, m2); wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')\n 2. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 3. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 4. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 5. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "moreover"], ["proof (state)\nthis:\n  m1 \\<unlhd> m1'\n\ngoal (5 subgoals):\n 1. \\<And>t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'.\n       \\<lbrakk>wbisim1 t' (x, m1) (xx, m2); wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')\n 2. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 3. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 4. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 5. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "from b2"], ["proof (chain)\npicking this:\n  wbisim1 t (x1'', m1') (x2'', m2')", "have \"m1' = m2'\""], ["proof (prove)\nusing this:\n  wbisim1 t (x1'', m1') (x2'', m2')\n\ngoal (1 subgoal):\n 1. m1' = m2'", "by(cases x1'', cases x2'') simp"], ["proof (state)\nthis:\n  m1' = m2'\n\ngoal (5 subgoals):\n 1. \\<And>t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'.\n       \\<lbrakk>wbisim1 t' (x, m1) (xx, m2); wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')\n 2. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 3. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 4. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 5. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "moreover"], ["proof (state)\nthis:\n  m1' = m2'\n\ngoal (5 subgoals):\n 1. \\<And>t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'.\n       \\<lbrakk>wbisim1 t' (x, m1) (xx, m2); wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')\n 2. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 3. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 4. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 5. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "from b2"], ["proof (chain)\npicking this:\n  wbisim1 t (x1'', m1') (x2'', m2')", "have \"hconf m2'\""], ["proof (prove)\nusing this:\n  wbisim1 t (x1'', m1') (x2'', m2')\n\ngoal (1 subgoal):\n 1. hconf m2'", "by(cases x1'', cases x2'')(auto elim!: bisim1_list1.cases simp add: correct_state_def)"], ["proof (state)\nthis:\n  hconf m2'\n\ngoal (5 subgoals):\n 1. \\<And>t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'.\n       \\<lbrakk>wbisim1 t' (x, m1) (xx, m2); wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')\n 2. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 3. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 4. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 5. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "moreover"], ["proof (state)\nthis:\n  hconf m2'\n\ngoal (5 subgoals):\n 1. \\<And>t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'.\n       \\<lbrakk>wbisim1 t' (x, m1) (xx, m2); wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')\n 2. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 3. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 4. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 5. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "from b' exec"], ["proof (chain)\npicking this:\n  wbisim1 t (x1, m1) (x2, m2)\n  execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2'", "have \"preallocated m2\""], ["proof (prove)\nusing this:\n  wbisim1 t (x1, m1) (x2, m2)\n  execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2'\n\ngoal (1 subgoal):\n 1. preallocated m2", "by(cases x1, cases x2)(auto elim!: bisim1_list1.cases simp add: correct_state_def)"], ["proof (state)\nthis:\n  preallocated m2\n\ngoal (5 subgoals):\n 1. \\<And>t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'.\n       \\<lbrakk>wbisim1 t' (x, m1) (xx, m2); wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')\n 2. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 3. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 4. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 5. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "moreover"], ["proof (state)\nthis:\n  preallocated m2\n\ngoal (5 subgoals):\n 1. \\<And>t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'.\n       \\<lbrakk>wbisim1 t' (x, m1) (xx, m2); wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')\n 2. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 3. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 4. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 5. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "from b' \\<tau>red red"], ["proof (chain)\npicking this:\n  wbisim1 t (x1, m1) (x2, m2)\n  Red1_mthr.silent_moves True P t (x1, m1) (x1', m1)\n  Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1'", "have tconf: \"compP2 P,m2 \\<turnstile> t \\<surd>t\""], ["proof (prove)\nusing this:\n  wbisim1 t (x1, m1) (x2, m2)\n  Red1_mthr.silent_moves True P t (x1, m1) (x1', m1)\n  Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1'\n\ngoal (1 subgoal):\n 1. compP2 P,m2 \\<turnstile> t \\<surd>t", "by(cases x1, cases x2)(auto elim!: bisim1_list1.cases Red1.cases simp add: correct_state_def \\<tau>mreds1_Val_Nil \\<tau>mreds1_Throw_Nil)"], ["proof (state)\nthis:\n  compP2 P,m2 \\<turnstile> t \\<surd>t\n\ngoal (5 subgoals):\n 1. \\<And>t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'.\n       \\<lbrakk>wbisim1 t' (x, m1) (xx, m2); wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')\n 2. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 3. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 4. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 5. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "from \\<tau>exec"], ["proof (chain)\npicking this:\n  execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2)", "have \\<tau>exec': \"\\<tau>Exec_1_dr (compP2 P) t (fst x2, m2, snd x2) (fst x2', m2, snd x2')\""], ["proof (prove)\nusing this:\n  execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2)\n\ngoal (1 subgoal):\n 1. \\<tau>Exec_1_dr (compP2 P) t (fst x2, m2, snd x2) (fst x2', m2, snd x2')", "unfolding \\<tau>Exec_1_dr_conv_rtranclp"], ["proof (prove)\nusing this:\n  execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2)\n\ngoal (1 subgoal):\n 1. execd_mthr.silent_moves (compP2 P) t ((fst x2, snd x2), m2)\n     ((fst x2', snd x2'), m2)", "by simp"], ["proof (state)\nthis:\n  \\<tau>Exec_1_dr (compP2 P) t (fst x2, m2, snd x2) (fst x2', m2, snd x2')\n\ngoal (5 subgoals):\n 1. \\<And>t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'.\n       \\<lbrakk>wbisim1 t' (x, m1) (xx, m2); wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')\n 2. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 3. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 4. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 5. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "with b' tconf"], ["proof (chain)\npicking this:\n  wbisim1 t (x1, m1) (x2, m2)\n  compP2 P,m2 \\<turnstile> t \\<surd>t\n  \\<tau>Exec_1_dr (compP2 P) t (fst x2, m2, snd x2) (fst x2', m2, snd x2')", "have \"compTP P \\<turnstile> t: (fst x2', m2, snd x2') \\<surd>\""], ["proof (prove)\nusing this:\n  wbisim1 t (x1, m1) (x2, m2)\n  compP2 P,m2 \\<turnstile> t \\<surd>t\n  \\<tau>Exec_1_dr (compP2 P) t (fst x2, m2, snd x2) (fst x2', m2, snd x2')\n\ngoal (1 subgoal):\n 1. compTP P \\<turnstile> t:(fst x2', m2, snd x2') \\<surd>", "using \\<open>preallocated m2\\<close>"], ["proof (prove)\nusing this:\n  wbisim1 t (x1, m1) (x2, m2)\n  compP2 P,m2 \\<turnstile> t \\<surd>t\n  \\<tau>Exec_1_dr (compP2 P) t (fst x2, m2, snd x2) (fst x2', m2, snd x2')\n  preallocated m2\n\ngoal (1 subgoal):\n 1. compTP P \\<turnstile> t:(fst x2', m2, snd x2') \\<surd>", "apply(cases x1, cases x2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        compP2 P,m2 \\<turnstile> t \\<surd>t;\n        \\<tau>Exec_1_dr (compP2 P) t (fst x2, m2, snd x2)\n         (fst x2', m2, snd x2');\n        preallocated m2; x1 = (a, b); wbisim1 t (x1, m1) (x2, m2);\n        compP2 P,m2 \\<turnstile> t \\<surd>t;\n        \\<tau>Exec_1_dr (compP2 P) t (fst x2, m2, snd x2)\n         (fst x2', m2, snd x2');\n        preallocated m2; x2 = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> compTP\n                          P \\<turnstile> t:(fst x2', m2, snd x2') \\<surd>", "apply(erule \\<tau>Exec_1_dr_preserves_correct_state[OF wt_compTP_compP2[OF wf]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        compP2 P,m2 \\<turnstile> t \\<surd>t; preallocated m2; x1 = (a, b);\n        wbisim1 t (x1, m1) (x2, m2); compP2 P,m2 \\<turnstile> t \\<surd>t;\n        \\<tau>Exec_1_dr (compP2 P) t (fst x2, m2, snd x2)\n         (fst x2', m2, snd x2');\n        preallocated m2; x2 = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> compTP\n                          P \\<turnstile> t:(fst x2, m2, snd x2) \\<surd>", "apply(auto elim!: bisim1_list1.cases simp add: correct_state_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  compTP P \\<turnstile> t:(fst x2', m2, snd x2') \\<surd>\n\ngoal (5 subgoals):\n 1. \\<And>t' x m1 xx m2 t x1 x2 x1' ta1 x1'' m1' x2' ta2 x2'' m2'.\n       \\<lbrakk>wbisim1 t' (x, m1) (xx, m2); wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')\n 2. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 3. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 4. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 5. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "ultimately"], ["proof (chain)\npicking this:\n  m1 \\<unlhd> m1'\n  m1' = m2'\n  hconf m2'\n  preallocated m2\n  compTP P \\<turnstile> t:(fst x2', m2, snd x2') \\<surd>", "show \"wbisim1 t' (x, m1') (xx, m2')\""], ["proof (prove)\nusing this:\n  m1 \\<unlhd> m1'\n  m1' = m2'\n  hconf m2'\n  preallocated m2\n  compTP P \\<turnstile> t:(fst x2', m2, snd x2') \\<surd>\n\ngoal (1 subgoal):\n 1. wbisim1 t' (x, m1') (xx, m2')", "using b exec"], ["proof (prove)\nusing this:\n  m1 \\<unlhd> m1'\n  m1' = m2'\n  hconf m2'\n  preallocated m2\n  compTP P \\<turnstile> t:(fst x2', m2, snd x2') \\<surd>\n  wbisim1 t' (x, m1) (xx, m2)\n  execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2'\n\ngoal (1 subgoal):\n 1. wbisim1 t' (x, m1') (xx, m2')", "apply(cases x, cases xx)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>m1 \\<unlhd> m1'; m1' = m2'; hconf m2'; preallocated m2;\n        compTP P \\<turnstile> t:(fst x2', m2, snd x2') \\<surd>;\n        wbisim1 t' (x, m1) (xx, m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2'; x = (a, b);\n        m1 \\<unlhd> m1'; m1' = m2'; hconf m2'; preallocated m2;\n        compTP P \\<turnstile> t:(fst x2', m2, snd x2') \\<surd>;\n        wbisim1 t' (x, m1) (xx, m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        xx = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> wbisim1 t' (x, m1') (xx, m2')", "apply(auto elim!: bisim1_list1.cases intro!: bisim1_list1.intros simp add: split_beta intro: preallocated_hext)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Ts T body D xcpa stka loca Ca Ma pca frsa Tsa Ta bodya Da ea xsa\n       exsa.\n       \\<lbrakk>compP2\n                 P,t \\<turnstile> Normal\n                                   (fst x2', m2,\n                                    snd x2') -ta2-jvmd\\<rightarrow> Normal\n                               (fst x2'', m2', snd x2'');\n        x = ((ea, xsa), exsa); m2 \\<unlhd> m2'; m1' = m2'; hconf m2';\n        preallocated m2;\n        compTP P \\<turnstile> t:(fst x2', m2, snd x2') \\<surd>;\n        xx = (xcpa, (stka, loca, Ca, Ma, pca) # frsa); m1 = m2;\n        P \\<turnstile> Ca sees Ma: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        P,{0:Class\n              D=None; blocks1 (Suc 0) Ts\n                       body},m2 \\<turnstile> (ea,\n        xsa) \\<leftrightarrow> (stka, loca, pca, xcpa);\n        compTP\n         P \\<turnstile> t':(xcpa, m2,\n                            (stka, loca, Ca, Ma, pca) # frsa) \\<surd>;\n        P \\<turnstile> Ca sees Ma: Tsa\\<rightarrow>Ta = \\<lfloor>bodya\\<rfloor> in Da;\n        P,{0:Class\n              Da=None; blocks1 (Suc 0) Tsa\n                        bodya},m2 \\<turnstile> (ea,\n          xsa) \\<leftrightarrow> (stka, loca, pca, xcpa);\n        max_vars ea \\<le> length xsa;\n        list_all2 (bisim1_fr P m2) exsa frsa\\<rbrakk>\n       \\<Longrightarrow> compTP\n                          P \\<turnstile> t':(xcpa, m2',\n       (stka, loca, Ca, Ma, pca) # frsa) \\<surd>\n 2. \\<And>Ts T body D xcpa stka loca Ca Ma pca frsa Tsa Ta bodya Da ea xsa\n       exsa.\n       \\<lbrakk>compP2\n                 P,t \\<turnstile> Normal\n                                   (fst x2', m2,\n                                    snd x2') -ta2-jvmd\\<rightarrow> Normal\n                               (fst x2'', m2', snd x2'');\n        x = ((ea, xsa), exsa); m2 \\<unlhd> m2'; m1' = m2'; hconf m2';\n        preallocated m2;\n        compTP P \\<turnstile> t:(fst x2', m2, snd x2') \\<surd>;\n        xx = (xcpa, (stka, loca, Ca, Ma, pca) # frsa); m1 = m2;\n        P \\<turnstile> Ca sees Ma: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        P,{0:Class\n              D=None; blocks1 (Suc 0) Ts\n                       body},m2 \\<turnstile> (ea,\n        xsa) \\<leftrightarrow> (stka, loca, pca, xcpa);\n        compTP\n         P \\<turnstile> t':(xcpa, m2,\n                            (stka, loca, Ca, Ma, pca) # frsa) \\<surd>;\n        P \\<turnstile> Ca sees Ma: Tsa\\<rightarrow>Ta = \\<lfloor>bodya\\<rfloor> in Da;\n        P,{0:Class\n              Da=None; blocks1 (Suc 0) Tsa\n                        bodya},m2 \\<turnstile> (ea,\n          xsa) \\<leftrightarrow> (stka, loca, pca, xcpa);\n        max_vars ea \\<le> length xsa;\n        list_all2 (bisim1_fr P m2) exsa frsa\\<rbrakk>\n       \\<Longrightarrow> P,{0:Class\n                               D=None; blocks1 (Suc 0) Ts\n  body},m2' \\<turnstile> (ea, xsa) \\<leftrightarrow> (stka, loca, pca, xcpa)\n 3. \\<And>Ts T body D xcpa stka loca Ca Ma pca frsa Tsa Ta bodya Da ea xsa\n       exsa.\n       \\<lbrakk>compP2\n                 P,t \\<turnstile> Normal\n                                   (fst x2', m2,\n                                    snd x2') -ta2-jvmd\\<rightarrow> Normal\n                               (fst x2'', m2', snd x2'');\n        x = ((ea, xsa), exsa); m2 \\<unlhd> m2'; m1' = m2'; hconf m2';\n        preallocated m2;\n        compTP P \\<turnstile> t:(fst x2', m2, snd x2') \\<surd>;\n        xx = (xcpa, (stka, loca, Ca, Ma, pca) # frsa); m1 = m2;\n        P \\<turnstile> Ca sees Ma: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        P,{0:Class\n              D=None; blocks1 (Suc 0) Ts\n                       body},m2 \\<turnstile> (ea,\n        xsa) \\<leftrightarrow> (stka, loca, pca, xcpa);\n        compTP\n         P \\<turnstile> t':(xcpa, m2,\n                            (stka, loca, Ca, Ma, pca) # frsa) \\<surd>;\n        P \\<turnstile> Ca sees Ma: Tsa\\<rightarrow>Ta = \\<lfloor>bodya\\<rfloor> in Da;\n        P,{0:Class\n              Da=None; blocks1 (Suc 0) Tsa\n                        bodya},m2 \\<turnstile> (ea,\n          xsa) \\<leftrightarrow> (stka, loca, pca, xcpa);\n        max_vars ea \\<le> length xsa;\n        list_all2 (bisim1_fr P m2) exsa frsa\\<rbrakk>\n       \\<Longrightarrow> list_all2 (bisim1_fr P m2') exsa frsa", "apply(erule (2) correct_state_heap_change[OF wt_compTP_compP2[OF wf]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Ts T body D xcpa stka loca Ca Ma pca frsa Tsa Ta bodya Da ea xsa\n       exsa.\n       \\<lbrakk>compP2\n                 P,t \\<turnstile> Normal\n                                   (fst x2', m2,\n                                    snd x2') -ta2-jvmd\\<rightarrow> Normal\n                               (fst x2'', m2', snd x2'');\n        x = ((ea, xsa), exsa); m2 \\<unlhd> m2'; m1' = m2'; hconf m2';\n        preallocated m2;\n        compTP P \\<turnstile> t:(fst x2', m2, snd x2') \\<surd>;\n        xx = (xcpa, (stka, loca, Ca, Ma, pca) # frsa); m1 = m2;\n        P \\<turnstile> Ca sees Ma: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        P,{0:Class\n              D=None; blocks1 (Suc 0) Ts\n                       body},m2 \\<turnstile> (ea,\n        xsa) \\<leftrightarrow> (stka, loca, pca, xcpa);\n        compTP\n         P \\<turnstile> t':(xcpa, m2,\n                            (stka, loca, Ca, Ma, pca) # frsa) \\<surd>;\n        P \\<turnstile> Ca sees Ma: Tsa\\<rightarrow>Ta = \\<lfloor>bodya\\<rfloor> in Da;\n        P,{0:Class\n              Da=None; blocks1 (Suc 0) Tsa\n                        bodya},m2 \\<turnstile> (ea,\n          xsa) \\<leftrightarrow> (stka, loca, pca, xcpa);\n        max_vars ea \\<le> length xsa;\n        list_all2 (bisim1_fr P m2) exsa frsa\\<rbrakk>\n       \\<Longrightarrow> P,{0:Class\n                               D=None; blocks1 (Suc 0) Ts\n  body},m2' \\<turnstile> (ea, xsa) \\<leftrightarrow> (stka, loca, pca, xcpa)\n 2. \\<And>Ts T body D xcpa stka loca Ca Ma pca frsa Tsa Ta bodya Da ea xsa\n       exsa.\n       \\<lbrakk>compP2\n                 P,t \\<turnstile> Normal\n                                   (fst x2', m2,\n                                    snd x2') -ta2-jvmd\\<rightarrow> Normal\n                               (fst x2'', m2', snd x2'');\n        x = ((ea, xsa), exsa); m2 \\<unlhd> m2'; m1' = m2'; hconf m2';\n        preallocated m2;\n        compTP P \\<turnstile> t:(fst x2', m2, snd x2') \\<surd>;\n        xx = (xcpa, (stka, loca, Ca, Ma, pca) # frsa); m1 = m2;\n        P \\<turnstile> Ca sees Ma: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        P,{0:Class\n              D=None; blocks1 (Suc 0) Ts\n                       body},m2 \\<turnstile> (ea,\n        xsa) \\<leftrightarrow> (stka, loca, pca, xcpa);\n        compTP\n         P \\<turnstile> t':(xcpa, m2,\n                            (stka, loca, Ca, Ma, pca) # frsa) \\<surd>;\n        P \\<turnstile> Ca sees Ma: Tsa\\<rightarrow>Ta = \\<lfloor>bodya\\<rfloor> in Da;\n        P,{0:Class\n              Da=None; blocks1 (Suc 0) Tsa\n                        bodya},m2 \\<turnstile> (ea,\n          xsa) \\<leftrightarrow> (stka, loca, pca, xcpa);\n        max_vars ea \\<le> length xsa;\n        list_all2 (bisim1_fr P m2) exsa frsa\\<rbrakk>\n       \\<Longrightarrow> list_all2 (bisim1_fr P m2') exsa frsa", "apply(erule (1) bisim1_hext_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ts T body D xcpa stka loca Ca Ma pca frsa Tsa Ta bodya Da ea xsa\n       exsa.\n       \\<lbrakk>compP2\n                 P,t \\<turnstile> Normal\n                                   (fst x2', m2,\n                                    snd x2') -ta2-jvmd\\<rightarrow> Normal\n                               (fst x2'', m2', snd x2'');\n        x = ((ea, xsa), exsa); m2 \\<unlhd> m2'; m1' = m2'; hconf m2';\n        preallocated m2;\n        compTP P \\<turnstile> t:(fst x2', m2, snd x2') \\<surd>;\n        xx = (xcpa, (stka, loca, Ca, Ma, pca) # frsa); m1 = m2;\n        P \\<turnstile> Ca sees Ma: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        P,{0:Class\n              D=None; blocks1 (Suc 0) Ts\n                       body},m2 \\<turnstile> (ea,\n        xsa) \\<leftrightarrow> (stka, loca, pca, xcpa);\n        compTP\n         P \\<turnstile> t':(xcpa, m2,\n                            (stka, loca, Ca, Ma, pca) # frsa) \\<surd>;\n        P \\<turnstile> Ca sees Ma: Tsa\\<rightarrow>Ta = \\<lfloor>bodya\\<rfloor> in Da;\n        P,{0:Class\n              Da=None; blocks1 (Suc 0) Tsa\n                        bodya},m2 \\<turnstile> (ea,\n          xsa) \\<leftrightarrow> (stka, loca, pca, xcpa);\n        max_vars ea \\<le> length xsa;\n        list_all2 (bisim1_fr P m2) exsa frsa\\<rbrakk>\n       \\<Longrightarrow> list_all2 (bisim1_fr P m2') exsa frsa", "apply(erule List.list_all2_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ts T body D xcpa stka loca Ca Ma pca frsa Tsa Ta bodya Da ea xsa\n       exsa xs ys.\n       \\<lbrakk>compP2\n                 P,t \\<turnstile> Normal\n                                   (fst x2', m2,\n                                    snd x2') -ta2-jvmd\\<rightarrow> Normal\n                               (fst x2'', m2', snd x2'');\n        x = ((ea, xsa), exsa); m2 \\<unlhd> m2'; m1' = m2'; hconf m2';\n        preallocated m2;\n        compTP P \\<turnstile> t:(fst x2', m2, snd x2') \\<surd>;\n        xx = (xcpa, (stka, loca, Ca, Ma, pca) # frsa); m1 = m2;\n        P \\<turnstile> Ca sees Ma: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        P,{0:Class\n              D=None; blocks1 (Suc 0) Ts\n                       body},m2 \\<turnstile> (ea,\n        xsa) \\<leftrightarrow> (stka, loca, pca, xcpa);\n        compTP\n         P \\<turnstile> t':(xcpa, m2,\n                            (stka, loca, Ca, Ma, pca) # frsa) \\<surd>;\n        P \\<turnstile> Ca sees Ma: Tsa\\<rightarrow>Ta = \\<lfloor>bodya\\<rfloor> in Da;\n        P,{0:Class\n              Da=None; blocks1 (Suc 0) Tsa\n                        bodya},m2 \\<turnstile> (ea,\n          xsa) \\<leftrightarrow> (stka, loca, pca, xcpa);\n        max_vars ea \\<le> length xsa; bisim1_fr P m2 xs ys\\<rbrakk>\n       \\<Longrightarrow> bisim1_fr P m2' xs ys", "apply(erule (1) bisim1_fr_hext_mono)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  wbisim1 t' (x, m1') (xx, m2')\n\ngoal (4 subgoals):\n 1. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 2. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 3. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 4. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 2. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 3. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 4. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "fix t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 2. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 3. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 4. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "assume b: \"wbisim1 t (x1, m1) (x2, m2)\"\n      and \\<tau>red: \"?\\<tau>red t (x1, m1) (x1', m1)\"\n      and red: \"mred1 P t (x1', m1) ta1 (x1'', m1')\"\n      and \"\\<not> \\<tau>MOVE1 P (x1', m1) ta1 (x1'', m1')\"\n      and \\<tau>exec: \"?\\<tau>exec t (x2, m2) (x2', m2)\"\n      and exec: \"?exec t (x2', m2) ta2 (x2'', m2')\"\n      and \"\\<not> \\<tau>MOVE2 (compP2 P) (x2', m2) ta2 (x2'', m2')\"\n      and b': \"wbisim1 t (x1'', m1') (x2'', m2')\"\n      and \"ta_bisim wbisim1 ta1 ta2\"\n      and Suspend: \"Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\" \"Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\""], ["proof (state)\nthis:\n  wbisim1 t (x1, m1) (x2, m2)\n  Red1_mthr.silent_moves True P t (x1, m1) (x1', m1)\n  Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1'\n  \\<not> (case (x1', m1) of\n          (exexs, h) \\<Rightarrow>\n            \\<lambda>ta s.\n               \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n          ta1 (x1'', m1')\n  execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2)\n  execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2'\n  \\<not> (case (x2', m2) of\n          (x, xa) \\<Rightarrow>\n            (case x of\n             (xcp, frs) \\<Rightarrow>\n               \\<lambda>h ta s.\n                  \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                  ta = \\<lbrace>\\<rbrace>)\n             xa)\n          ta2 (x2'', m2')\n  wbisim1 t (x1'', m1') (x2'', m2')\n  Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n  Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\n  Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\n\ngoal (4 subgoals):\n 1. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 2. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 3. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 4. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "from red Suspend"], ["proof (chain)\npicking this:\n  Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1'\n  Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\n  Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>", "have \"call1 (fst (fst x1'')) \\<noteq> None\""], ["proof (prove)\nusing this:\n  Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1'\n  Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\n  Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\n\ngoal (1 subgoal):\n 1. call1 (fst (fst x1'')) \\<noteq> None", "by(cases x1')(cases x1'', auto dest: Red1_Suspend_is_call)"], ["proof (state)\nthis:\n  call1 (fst (fst x1'')) \\<noteq> None\n\ngoal (4 subgoals):\n 1. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 2. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 3. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 4. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "moreover"], ["proof (state)\nthis:\n  call1 (fst (fst x1'')) \\<noteq> None\n\ngoal (4 subgoals):\n 1. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 2. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 3. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 4. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "from mexecd_Suspend_Invoke[OF exec Suspend(2)]"], ["proof (chain)\npicking this:\n  \\<exists>stk loc C M pc frs' n a T Ts Tr D.\n     x2'' = (None, (stk, loc, C, M, pc) # frs') \\<and>\n     instrs_of (compP2 P) C M ! pc = Invoke wait n \\<and>\n     stk ! n = Addr a \\<and>\n     typeof_addr m2 a = \\<lfloor>T\\<rfloor> \\<and>\n     compP2\n      P \\<turnstile> class_type_of\n                      T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n     D\\<bullet>wait(Ts) :: Tr", "obtain xcp stk loc C M pc frs' M' n where \"x2'' = (xcp, (stk, loc, C, M, pc) # frs')\"\n      \"instrs_of (compP2 P) C M ! pc = Invoke M' n\""], ["proof (prove)\nusing this:\n  \\<exists>stk loc C M pc frs' n a T Ts Tr D.\n     x2'' = (None, (stk, loc, C, M, pc) # frs') \\<and>\n     instrs_of (compP2 P) C M ! pc = Invoke wait n \\<and>\n     stk ! n = Addr a \\<and>\n     typeof_addr m2 a = \\<lfloor>T\\<rfloor> \\<and>\n     compP2\n      P \\<turnstile> class_type_of\n                      T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n     D\\<bullet>wait(Ts) :: Tr\n\ngoal (1 subgoal):\n 1. (\\<And>xcp stk loc C M pc frs' M' n.\n        \\<lbrakk>x2'' = (xcp, (stk, loc, C, M, pc) # frs');\n         instrs_of (compP2 P) C M ! pc = Invoke M' n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x2'' = (xcp, (stk, loc, C, M, pc) # frs')\n  instrs_of (compP2 P) C M ! pc = Invoke M' n\n\ngoal (4 subgoals):\n 1. \\<And>t x1 m1 x2 m2 x1' ta1 x1'' m1' x2' ta2 x2'' m2' w.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        Red1_mthr.silent_moves True P t (x1, m1) (x1', m1);\n        Red1_mthr.r_syntax True P t x1' m1 ta1 x1'' m1';\n        \\<not> (case (x1', m1) of\n                (exexs, h) \\<Rightarrow>\n                  \\<lambda>ta s.\n                     \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n                ta1 (x1'', m1');\n        execd_mthr.silent_moves (compP2 P) t (x2, m2) (x2', m2);\n        execd_mthr.r_syntax (compP2 P) t x2' m2 ta2 x2'' m2';\n        \\<not> (case (x2', m2) of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (xcp, frs) \\<Rightarrow>\n                     \\<lambda>h ta s.\n                        \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and>\n                        ta = \\<lbrace>\\<rbrace>)\n                   xa)\n                ta2 (x2'', m2');\n        wbisim1 t (x1'', m1') (x2'', m2');\n        Red1_execd.ta_bisim_bisim_syntax ta1 ta2;\n        Suspend w \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>;\n        Suspend w \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> bisim_wait1JVM (compP2 P) x1'' x2''\n 2. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 3. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 4. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "ultimately"], ["proof (chain)\npicking this:\n  call1 (fst (fst x1'')) \\<noteq> None\n  x2'' = (xcp, (stk, loc, C, M, pc) # frs')\n  instrs_of (compP2 P) C M ! pc = Invoke M' n", "show \"bisim_wait1JVM (compP2 P) x1'' x2''\""], ["proof (prove)\nusing this:\n  call1 (fst (fst x1'')) \\<noteq> None\n  x2'' = (xcp, (stk, loc, C, M, pc) # frs')\n  instrs_of (compP2 P) C M ! pc = Invoke M' n\n\ngoal (1 subgoal):\n 1. bisim_wait1JVM (compP2 P) x1'' x2''", "by(simp add: bisim_wait1JVM_def split_beta)"], ["proof (state)\nthis:\n  bisim_wait1JVM (compP2 P) x1'' x2''\n\ngoal (3 subgoals):\n 1. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 2. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 3. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 2. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 3. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "fix t x1 m1 x2 m2 ta1 x1' m1'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 2. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 3. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "assume \"wbisim1 t (x1, m1) (x2, m2)\"\n      and \"bisim_wait1JVM (compP2 P) x1 x2\"\n      and \"mred1 P t (x1, m1) ta1 (x1', m1')\"\n      and wakeup: \"Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or> WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\""], ["proof (state)\nthis:\n  wbisim1 t (x1, m1) (x2, m2)\n  bisim_wait1JVM (compP2 P) x1 x2\n  Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1'\n  Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n  WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\n\ngoal (3 subgoals):\n 1. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 2. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 3. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "moreover"], ["proof (state)\nthis:\n  wbisim1 t (x1, m1) (x2, m2)\n  bisim_wait1JVM (compP2 P) x1 x2\n  Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1'\n  Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n  WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\n\ngoal (3 subgoals):\n 1. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 2. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 3. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "obtain e1 xs1 exs1 where [simp]: \"x1 = ((e1, xs1), exs1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e1 xs1 exs1.\n        x1 = ((e1, xs1), exs1) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases x1) auto"], ["proof (state)\nthis:\n  x1 = ((e1, xs1), exs1)\n\ngoal (3 subgoals):\n 1. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 2. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 3. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "moreover"], ["proof (state)\nthis:\n  x1 = ((e1, xs1), exs1)\n\ngoal (3 subgoals):\n 1. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 2. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 3. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "obtain xcp frs where [simp]: \"x2 = (xcp, frs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xcp frs.\n        x2 = (xcp, frs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases x2)"], ["proof (state)\nthis:\n  x2 = (xcp, frs)\n\ngoal (3 subgoals):\n 1. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 2. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 3. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "moreover"], ["proof (state)\nthis:\n  x2 = (xcp, frs)\n\ngoal (3 subgoals):\n 1. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 2. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 3. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "obtain e1' xs1' exs1' where [simp]: \"x1' = ((e1', xs1'), exs1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e1' xs1' exs1'.\n        x1' = ((e1', xs1'), exs1') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases x1') auto"], ["proof (state)\nthis:\n  x1' = ((e1', xs1'), exs1')\n\ngoal (3 subgoals):\n 1. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 2. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 3. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "ultimately"], ["proof (chain)\npicking this:\n  wbisim1 t (x1, m1) (x2, m2)\n  bisim_wait1JVM (compP2 P) x1 x2\n  Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1'\n  Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n  WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\n  x1 = ((e1, xs1), exs1)\n  x2 = (xcp, frs)\n  x1' = ((e1', xs1'), exs1')", "have [simp]: \"m1 = m2\" \n      and bisim: \"bisim1_list1 t m2 (e1, xs1) exs1 xcp frs\"\n      and red: \"True,P,t \\<turnstile>1 \\<langle>(e1, xs1)/exs1, m2\\<rangle> -ta1\\<rightarrow> \\<langle>(e1', xs1')/exs1', m1'\\<rangle>\"\n      and call: \"call1 e1 \\<noteq> None\" \n                \"case frs of [] \\<Rightarrow> False | (stk, loc, C, M, pc) # frs' \\<Rightarrow> \\<exists>M' n. instrs_of (compP2 P) C M ! pc = Invoke M' n\""], ["proof (prove)\nusing this:\n  wbisim1 t (x1, m1) (x2, m2)\n  bisim_wait1JVM (compP2 P) x1 x2\n  Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1'\n  Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n  WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\n  x1 = ((e1, xs1), exs1)\n  x2 = (xcp, frs)\n  x1' = ((e1', xs1'), exs1')\n\ngoal (1 subgoal):\n 1. (m1 = m2 &&& bisim1_list1 t m2 (e1, xs1) exs1 xcp frs) &&&\n    True,P,t \\<turnstile>1 \\<langle>(e1, xs1)/exs1,\n                            m2\\<rangle> -ta1\\<rightarrow>\n                           \\<langle>(e1', xs1')/exs1',m1'\\<rangle> &&&\n    call1 e1 \\<noteq> None &&&\n    case frs of [] \\<Rightarrow> False\n    | (stk, loc, C, M, pc) # frs' \\<Rightarrow>\n        \\<exists>M' n. instrs_of (compP2 P) C M ! pc = Invoke M' n", "by(auto simp add: bisim_wait1JVM_def split_def)"], ["proof (state)\nthis:\n  m1 = m2\n  bisim1_list1 t m2 (e1, xs1) exs1 xcp frs\n  True,P,t \\<turnstile>1 \\<langle>(e1, xs1)/exs1,\n                          m2\\<rangle> -ta1\\<rightarrow>\n                         \\<langle>(e1', xs1')/exs1',m1'\\<rangle>\n  call1 e1 \\<noteq> None\n  case frs of [] \\<Rightarrow> False\n  | (stk, loc, C, M, pc) # frs' \\<Rightarrow>\n      \\<exists>M' n. instrs_of (compP2 P) C M ! pc = Invoke M' n\n\ngoal (3 subgoals):\n 1. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 2. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 3. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "from red wakeup"], ["proof (chain)\npicking this:\n  True,P,t \\<turnstile>1 \\<langle>(e1, xs1)/exs1,\n                          m2\\<rangle> -ta1\\<rightarrow>\n                         \\<langle>(e1', xs1')/exs1',m1'\\<rangle>\n  Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n  WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>", "have \"\\<not> \\<tau>Move1 P m2 ((e1, xs1), exs1)\""], ["proof (prove)\nusing this:\n  True,P,t \\<turnstile>1 \\<langle>(e1, xs1)/exs1,\n                          m2\\<rangle> -ta1\\<rightarrow>\n                         \\<langle>(e1', xs1')/exs1',m1'\\<rangle>\n  Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n  WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> \\<tau>Move1 P m2 ((e1, xs1), exs1)", "by(auto elim!: Red1.cases dest: red1_\\<tau>_taD simp add: split_beta ta_upd_simps)"], ["proof (state)\nthis:\n  \\<not> \\<tau>Move1 P m2 ((e1, xs1), exs1)\n\ngoal (3 subgoals):\n 1. \\<And>t x1 m1 x2 m2 ta1 x1' m1'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1';\n        Notified \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta1\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta2 x2' m2'.\n                            execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2'\n                             m2' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 2. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 3. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "from exec_1_simulates_Red1_not_\\<tau>[OF wf red bisim this] call"], ["proof (chain)\npicking this:\n  \\<exists>xcp' frs'.\n     \\<tau>Exec_1_dr (compP2 P) t (xcp, m2, frs) (xcp', m2, frs') \\<and>\n     (\\<exists>ta' xcp'' frs''.\n         compP2\n          P,t \\<turnstile> Normal\n                            (xcp', m2,\n                             frs') -ta'-jvmd\\<rightarrow> Normal\n                     (xcp'', m1', frs'') \\<and>\n         \\<not> \\<tau>Move2 (compP2 P) (xcp', m2, frs') \\<and>\n         Red1_execd.ta_bisim_bisim_syntax ta1 ta' \\<and>\n         bisim1_list1 t m1' (e1', xs1') exs1' xcp'' frs'') \\<and>\n     (call1 e1 = None \\<or>\n      (case frs of [] \\<Rightarrow> False\n       | (stk, loc, C, M, pc) # FRS \\<Rightarrow>\n           \\<forall>M' n.\n              instrs_of (compP2 P) C M ! pc \\<noteq> Invoke M' n) \\<or>\n      xcp' = xcp \\<and> frs' = frs)\n  call1 e1 \\<noteq> None\n  case frs of [] \\<Rightarrow> False\n  | (stk, loc, C, M, pc) # frs' \\<Rightarrow>\n      \\<exists>M' n. instrs_of (compP2 P) C M ! pc = Invoke M' n", "show \"\\<exists>ta2 x2' m2'. mexecd (compP2 P) t (x2, m2) ta2 (x2', m2') \\<and> wbisim1 t (x1', m1') (x2', m2') \\<and> ta_bisim wbisim1 ta1 ta2\""], ["proof (prove)\nusing this:\n  \\<exists>xcp' frs'.\n     \\<tau>Exec_1_dr (compP2 P) t (xcp, m2, frs) (xcp', m2, frs') \\<and>\n     (\\<exists>ta' xcp'' frs''.\n         compP2\n          P,t \\<turnstile> Normal\n                            (xcp', m2,\n                             frs') -ta'-jvmd\\<rightarrow> Normal\n                     (xcp'', m1', frs'') \\<and>\n         \\<not> \\<tau>Move2 (compP2 P) (xcp', m2, frs') \\<and>\n         Red1_execd.ta_bisim_bisim_syntax ta1 ta' \\<and>\n         bisim1_list1 t m1' (e1', xs1') exs1' xcp'' frs'') \\<and>\n     (call1 e1 = None \\<or>\n      (case frs of [] \\<Rightarrow> False\n       | (stk, loc, C, M, pc) # FRS \\<Rightarrow>\n           \\<forall>M' n.\n              instrs_of (compP2 P) C M ! pc \\<noteq> Invoke M' n) \\<or>\n      xcp' = xcp \\<and> frs' = frs)\n  call1 e1 \\<noteq> None\n  case frs of [] \\<Rightarrow> False\n  | (stk, loc, C, M, pc) # frs' \\<Rightarrow>\n      \\<exists>M' n. instrs_of (compP2 P) C M ! pc = Invoke M' n\n\ngoal (1 subgoal):\n 1. \\<exists>ta2 x2' m2'.\n       execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2' \\<and>\n       wbisim1 t (x1', m1') (x2', m2') \\<and>\n       Red1_execd.ta_bisim_bisim_syntax ta1 ta2", "by(auto simp del: not_None_eq simp add: split_paired_Ex ta_bisim_def ta_upd_simps split: list.split_asm)"], ["proof (state)\nthis:\n  \\<exists>ta2 x2' m2'.\n     execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2' \\<and>\n     wbisim1 t (x1', m1') (x2', m2') \\<and>\n     Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n\ngoal (2 subgoals):\n 1. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 2. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 2. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "fix t x1 m1 x2 m2 ta2 x2' m2'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 2. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "assume \"wbisim1 t (x1, m1) (x2, m2)\"\n      and \"bisim_wait1JVM (compP2 P) x1 x2\"\n      and \"mexecd (compP2 P) t (x2, m2) ta2 (x2', m2')\"\n      and wakeup: \"Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or> WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\""], ["proof (state)\nthis:\n  wbisim1 t (x1, m1) (x2, m2)\n  bisim_wait1JVM (compP2 P) x1 x2\n  execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2'\n  Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n  WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 2. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "moreover"], ["proof (state)\nthis:\n  wbisim1 t (x1, m1) (x2, m2)\n  bisim_wait1JVM (compP2 P) x1 x2\n  execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2'\n  Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n  WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 2. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "obtain e1 xs1 exs1 where [simp]: \"x1 = ((e1, xs1), exs1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e1 xs1 exs1.\n        x1 = ((e1, xs1), exs1) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases x1) auto"], ["proof (state)\nthis:\n  x1 = ((e1, xs1), exs1)\n\ngoal (2 subgoals):\n 1. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 2. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "moreover"], ["proof (state)\nthis:\n  x1 = ((e1, xs1), exs1)\n\ngoal (2 subgoals):\n 1. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 2. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "obtain xcp frs where [simp]: \"x2 = (xcp, frs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xcp frs.\n        x2 = (xcp, frs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases x2)"], ["proof (state)\nthis:\n  x2 = (xcp, frs)\n\ngoal (2 subgoals):\n 1. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 2. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "moreover"], ["proof (state)\nthis:\n  x2 = (xcp, frs)\n\ngoal (2 subgoals):\n 1. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 2. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "obtain xcp' frs' where [simp]: \"x2' = (xcp', frs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xcp' frs'.\n        x2' = (xcp', frs') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases x2')"], ["proof (state)\nthis:\n  x2' = (xcp', frs')\n\ngoal (2 subgoals):\n 1. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 2. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "ultimately"], ["proof (chain)\npicking this:\n  wbisim1 t (x1, m1) (x2, m2)\n  bisim_wait1JVM (compP2 P) x1 x2\n  execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2'\n  Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n  WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\n  x1 = ((e1, xs1), exs1)\n  x2 = (xcp, frs)\n  x2' = (xcp', frs')", "have [simp]: \"m1 = m2\" \n      and bisim: \"bisim1_list1 t m2 (e1, xs1) exs1 xcp frs\"\n      and exec: \"compP2 P,t \\<turnstile> Normal (xcp, m2, frs) -ta2-jvmd\\<rightarrow> Normal (xcp', m2', frs')\"\n      and call: \"call1 e1 \\<noteq> None\" \n                \"case frs of [] \\<Rightarrow> False | (stk, loc, C, M, pc) # frs' \\<Rightarrow> \\<exists>M' n. instrs_of (compP2 P) C M ! pc = Invoke M' n\""], ["proof (prove)\nusing this:\n  wbisim1 t (x1, m1) (x2, m2)\n  bisim_wait1JVM (compP2 P) x1 x2\n  execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2'\n  Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n  WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\n  x1 = ((e1, xs1), exs1)\n  x2 = (xcp, frs)\n  x2' = (xcp', frs')\n\ngoal (1 subgoal):\n 1. (m1 = m2 &&& bisim1_list1 t m2 (e1, xs1) exs1 xcp frs) &&&\n    compP2\n     P,t \\<turnstile> Normal\n                       (xcp, m2,\n                        frs) -ta2-jvmd\\<rightarrow> Normal\n               (xcp', m2', frs') &&&\n    call1 e1 \\<noteq> None &&&\n    case frs of [] \\<Rightarrow> False\n    | (stk, loc, C, M, pc) # frs' \\<Rightarrow>\n        \\<exists>M' n. instrs_of (compP2 P) C M ! pc = Invoke M' n", "by(auto simp add: bisim_wait1JVM_def split_def)"], ["proof (state)\nthis:\n  m1 = m2\n  bisim1_list1 t m2 (e1, xs1) exs1 xcp frs\n  compP2\n   P,t \\<turnstile> Normal\n                     (xcp, m2,\n                      frs) -ta2-jvmd\\<rightarrow> Normal (xcp', m2', frs')\n  call1 e1 \\<noteq> None\n  case frs of [] \\<Rightarrow> False\n  | (stk, loc, C, M, pc) # frs' \\<Rightarrow>\n      \\<exists>M' n. instrs_of (compP2 P) C M ! pc = Invoke M' n\n\ngoal (2 subgoals):\n 1. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 2. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "from exec wakeup"], ["proof (chain)\npicking this:\n  compP2\n   P,t \\<turnstile> Normal\n                     (xcp, m2,\n                      frs) -ta2-jvmd\\<rightarrow> Normal (xcp', m2', frs')\n  Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n  WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>", "have \"\\<not> \\<tau>Move2 (compP2 P) (xcp, m2, frs)\""], ["proof (prove)\nusing this:\n  compP2\n   P,t \\<turnstile> Normal\n                     (xcp, m2,\n                      frs) -ta2-jvmd\\<rightarrow> Normal (xcp', m2', frs')\n  Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n  WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> \\<tau>Move2 (compP2 P) (xcp, m2, frs)", "by(auto dest: \\<tau>exec_1_taD simp add: split_beta ta_upd_simps)"], ["proof (state)\nthis:\n  \\<not> \\<tau>Move2 (compP2 P) (xcp, m2, frs)\n\ngoal (2 subgoals):\n 1. \\<And>t x1 m1 x2 m2 ta2 x2' m2'.\n       \\<lbrakk>wbisim1 t (x1, m1) (x2, m2);\n        bisim_wait1JVM (compP2 P) x1 x2;\n        execd_mthr.r_syntax (compP2 P) t x2 m2 ta2 x2' m2';\n        Notified \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta2\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta1 x1' m1'.\n                            Red1_mthr.r_syntax True P t x1 m1 ta1 x1'\n                             m1' \\<and>\n                            wbisim1 t (x1', m1') (x2', m2') \\<and>\n                            Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n 2. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "from \\<tau>Red1_simulates_exec_1_not_\\<tau>[OF wf exec bisim this] call"], ["proof (chain)\npicking this:\n  \\<exists>e' xs' exs' ta' e'' xs'' exs''.\n     \\<tau>Red1r P t m2 ((e1, xs1), exs1) ((e', xs'), exs') \\<and>\n     True,P,t \\<turnstile>1 \\<langle>(e', xs')/exs',\n                             m2\\<rangle> -ta'\\<rightarrow>\n                            \\<langle>(e'', xs'')/exs'',m2'\\<rangle> \\<and>\n     \\<not> \\<tau>Move1 P m2 ((e', xs'), exs') \\<and>\n     Red1_execd.ta_bisim_bisim_syntax ta' ta2 \\<and>\n     bisim1_list1 t m2' (e'', xs'') exs'' xcp' frs' \\<and>\n     (call1 e1 = None \\<or>\n      (case frs of [] \\<Rightarrow> False\n       | (stk, loc, C, M, pc) # FRS \\<Rightarrow>\n           \\<forall>M' n.\n              instrs_of (compP2 P) C M ! pc \\<noteq> Invoke M' n) \\<or>\n      e' = e1 \\<and> xs' = xs1 \\<and> exs' = exs1)\n  call1 e1 \\<noteq> None\n  case frs of [] \\<Rightarrow> False\n  | (stk, loc, C, M, pc) # frs' \\<Rightarrow>\n      \\<exists>M' n. instrs_of (compP2 P) C M ! pc = Invoke M' n", "show \"\\<exists>ta1 x1' m1'. mred1 P t (x1, m1) ta1 (x1', m1') \\<and> wbisim1 t (x1', m1') (x2', m2') \\<and> ta_bisim wbisim1 ta1 ta2\""], ["proof (prove)\nusing this:\n  \\<exists>e' xs' exs' ta' e'' xs'' exs''.\n     \\<tau>Red1r P t m2 ((e1, xs1), exs1) ((e', xs'), exs') \\<and>\n     True,P,t \\<turnstile>1 \\<langle>(e', xs')/exs',\n                             m2\\<rangle> -ta'\\<rightarrow>\n                            \\<langle>(e'', xs'')/exs'',m2'\\<rangle> \\<and>\n     \\<not> \\<tau>Move1 P m2 ((e', xs'), exs') \\<and>\n     Red1_execd.ta_bisim_bisim_syntax ta' ta2 \\<and>\n     bisim1_list1 t m2' (e'', xs'') exs'' xcp' frs' \\<and>\n     (call1 e1 = None \\<or>\n      (case frs of [] \\<Rightarrow> False\n       | (stk, loc, C, M, pc) # FRS \\<Rightarrow>\n           \\<forall>M' n.\n              instrs_of (compP2 P) C M ! pc \\<noteq> Invoke M' n) \\<or>\n      e' = e1 \\<and> xs' = xs1 \\<and> exs' = exs1)\n  call1 e1 \\<noteq> None\n  case frs of [] \\<Rightarrow> False\n  | (stk, loc, C, M, pc) # frs' \\<Rightarrow>\n      \\<exists>M' n. instrs_of (compP2 P) C M ! pc = Invoke M' n\n\ngoal (1 subgoal):\n 1. \\<exists>ta1 x1' m1'.\n       Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1' \\<and>\n       wbisim1 t (x1', m1') (x2', m2') \\<and>\n       Red1_execd.ta_bisim_bisim_syntax ta1 ta2", "by(auto simp del: not_None_eq simp add: split_paired_Ex ta_bisim_def ta_upd_simps split: list.split_asm)"], ["proof (state)\nthis:\n  \\<exists>ta1 x1' m1'.\n     Red1_mthr.r_syntax True P t x1 m1 ta1 x1' m1' \\<and>\n     wbisim1 t (x1', m1') (x2', m2') \\<and>\n     Red1_execd.ta_bisim_bisim_syntax ta1 ta2\n\ngoal (1 subgoal):\n 1. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Ex final_expr1 = (\\<exists>x2. JVM_final x2)", "show \"(\\<exists>x. final_expr1 x) \\<longleftrightarrow> (\\<exists>x. JVM_final x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex final_expr1 = (\\<exists>x. JVM_final x)", "by(auto simp add: split_paired_Ex final_iff)"], ["proof (state)\nthis:\n  Ex final_expr1 = (\\<exists>x. JVM_final x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  FWdelay_bisimulation_diverge final_expr1 (mred1 P) JVM_final\n   (mexecd (compP2 P)) wbisim1 (bisim_wait1JVM (compP2 P))\n   (\\<lambda>(exexs, h) ta s.\n       \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n   (\\<lambda>((xcp, frs), h) ta s.\n       \\<tau>Move2 (compP2 P) (xcp, h, frs) \\<and> ta = \\<lbrace>\\<rbrace>)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "sublocale J1_JVM_heap_conf_base < Red1_mexecd:\n  FWbisimulation_base\n    final_expr1\n    \"mred1 P\"\n    JVM_final\n    \"mexecd (compP2 P)\"\n    convert_RA\n    \"wbisim1\"\n    \"bisim_wait1JVM (compP2 P)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "context J1_JVM_heap_conf begin"], ["", "lemma bisim_J1_JVM_start:\n  assumes wf: \"wf_J1_prog P\"\n  and wf_start: \"wf_start_state P C M vs\"\n  shows \"Red1_execd.mbisim (J1_start_state P C M vs) (JVM_start_state (compP2 P) C M vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Red1_execd.mbisim (J1_start_state P C M vs)\n     (start_state JVM_local_start (compP2 P) C M vs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Red1_execd.mbisim (J1_start_state P C M vs)\n     (start_state JVM_local_start (compP2 P) C M vs)", "from wf_start"], ["proof (chain)\npicking this:\n  wf_start_state P C M vs", "obtain Ts T body D where start: \"start_heap_ok\"\n  and sees: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=\\<lfloor>body\\<rfloor> in D\" and conf: \"P,start_heap \\<turnstile> vs [:\\<le>] Ts\""], ["proof (prove)\nusing this:\n  wf_start_state P C M vs\n\ngoal (1 subgoal):\n 1. (\\<And>Ts T body D.\n        \\<lbrakk>start_heap_ok;\n         P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n         P,start_heap \\<turnstile> vs [:\\<le>] Ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases"], ["proof (state)\nthis:\n  start_heap_ok\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\n  P,start_heap \\<turnstile> vs [:\\<le>] Ts\n\ngoal (1 subgoal):\n 1. Red1_execd.mbisim (J1_start_state P C M vs)\n     (start_state JVM_local_start (compP2 P) C M vs)", "let ?e = \"blocks1 0 (Class D#Ts) body\""], ["proof (state)\ngoal (1 subgoal):\n 1. Red1_execd.mbisim (J1_start_state P C M vs)\n     (start_state JVM_local_start (compP2 P) C M vs)", "let ?xs = \"Null # vs @ replicate (max_vars body) undefined_value\""], ["proof (state)\ngoal (1 subgoal):\n 1. Red1_execd.mbisim (J1_start_state P C M vs)\n     (start_state JVM_local_start (compP2 P) C M vs)", "from sees_wf_mdecl[OF wf sees]"], ["proof (chain)\npicking this:\n  wf_mdecl wf_J1_mdecl P D (M, Ts, T, \\<lfloor>body\\<rfloor>)", "obtain T'\n    where B: \"\\<B> body (Suc (length Ts))\"\n    and wt: \"P,Class D # Ts \\<turnstile>1 body :: T'\"\n    and da: \"\\<D> body \\<lfloor>{..length Ts}\\<rfloor>\"\n    and sv: \"syncvars body\""], ["proof (prove)\nusing this:\n  wf_mdecl wf_J1_mdecl P D (M, Ts, T, \\<lfloor>body\\<rfloor>)\n\ngoal (1 subgoal):\n 1. (\\<And>T'.\n        \\<lbrakk>\\<B> body (Suc (length Ts));\n         P,Class D # Ts \\<turnstile>1 body :: T';\n         \\<D> body \\<lfloor>{..length Ts}\\<rfloor>; syncvars body\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: wf_mdecl_def)"], ["proof (state)\nthis:\n  \\<B> body (Suc (length Ts))\n  P,Class D # Ts \\<turnstile>1 body :: T'\n  \\<D> body \\<lfloor>{..length Ts}\\<rfloor>\n  syncvars body\n\ngoal (1 subgoal):\n 1. Red1_execd.mbisim (J1_start_state P C M vs)\n     (start_state JVM_local_start (compP2 P) C M vs)", "have \"P,?e,start_heap \\<turnstile> (?e, ?xs) \\<leftrightarrow> ([], ?xs, 0, None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,blocks1 0 (Class D # Ts)\n       body,start_heap \\<turnstile> (blocks1 0 (Class D # Ts) body,\n                                     Null #\n                                     vs @\n                                     replicate (max_vars body)\nundefined_value) \\<leftrightarrow> ([],\n                                    Null #\n                                    vs @\n                                    replicate (max_vars body)\n                                     undefined_value,\n                                    0, None)", "by(rule bisim1_refl)"], ["proof (state)\nthis:\n  P,blocks1 0 (Class D # Ts)\n     body,start_heap \\<turnstile> (blocks1 0 (Class D # Ts) body,\n                                   Null #\n                                   vs @\n                                   replicate (max_vars body)\n                                    undefined_value) \\<leftrightarrow> ([],\n                                  Null #\n                                  vs @\n                                  replicate (max_vars body) undefined_value,\n                                  0, None)\n\ngoal (1 subgoal):\n 1. Red1_execd.mbisim (J1_start_state P C M vs)\n     (start_state JVM_local_start (compP2 P) C M vs)", "moreover"], ["proof (state)\nthis:\n  P,blocks1 0 (Class D # Ts)\n     body,start_heap \\<turnstile> (blocks1 0 (Class D # Ts) body,\n                                   Null #\n                                   vs @\n                                   replicate (max_vars body)\n                                    undefined_value) \\<leftrightarrow> ([],\n                                  Null #\n                                  vs @\n                                  replicate (max_vars body) undefined_value,\n                                  0, None)\n\ngoal (1 subgoal):\n 1. Red1_execd.mbisim (J1_start_state P C M vs)\n     (start_state JVM_local_start (compP2 P) C M vs)", "from wf"], ["proof (chain)\npicking this:\n  wf_J1_prog P", "have wf': \"wf_jvm_prog\\<^bsub>compTP P\\<^esub> (compP2 P)\""], ["proof (prove)\nusing this:\n  wf_J1_prog P\n\ngoal (1 subgoal):\n 1. wf_jvm_prog\\<^bsub>compTP P\\<^esub> (compP2 P)", "by(rule wt_compTP_compP2)"], ["proof (state)\nthis:\n  wf_jvm_prog\\<^bsub>compTP P\\<^esub> (compP2 P)\n\ngoal (1 subgoal):\n 1. Red1_execd.mbisim (J1_start_state P C M vs)\n     (start_state JVM_local_start (compP2 P) C M vs)", "from sees_method_compP[OF sees, of \"\\<lambda>C M Ts T. compMb2\"]"], ["proof (chain)\npicking this:\n  compP (\\<lambda>C M Ts T. compMb2)\n   P \\<turnstile> C sees M: Ts\\<rightarrow>T = map_option compMb2\n          \\<lfloor>body\\<rfloor> in D", "have sees': \"compP2 P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>compMb2 body\\<rfloor> in D\""], ["proof (prove)\nusing this:\n  compP (\\<lambda>C M Ts T. compMb2)\n   P \\<turnstile> C sees M: Ts\\<rightarrow>T = map_option compMb2\n          \\<lfloor>body\\<rfloor> in D\n\ngoal (1 subgoal):\n 1. compP2\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>compMb2\n                     body\\<rfloor> in D", "by(simp add: compP2_def)"], ["proof (state)\nthis:\n  compP2\n   P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>compMb2\n                   body\\<rfloor> in D\n\ngoal (1 subgoal):\n 1. Red1_execd.mbisim (J1_start_state P C M vs)\n     (start_state JVM_local_start (compP2 P) C M vs)", "from conf"], ["proof (chain)\npicking this:\n  P,start_heap \\<turnstile> vs [:\\<le>] Ts", "have \"compP2 P,start_heap \\<turnstile> vs [:\\<le>] Ts\""], ["proof (prove)\nusing this:\n  P,start_heap \\<turnstile> vs [:\\<le>] Ts\n\ngoal (1 subgoal):\n 1. compP2 P,start_heap \\<turnstile> vs [:\\<le>] Ts", "by(simp add: compP2_def heap_base.compP_confs)"], ["proof (state)\nthis:\n  compP2 P,start_heap \\<turnstile> vs [:\\<le>] Ts\n\ngoal (1 subgoal):\n 1. Red1_execd.mbisim (J1_start_state P C M vs)\n     (start_state JVM_local_start (compP2 P) C M vs)", "from BV_correct_initial[OF wf' start sees' this] sees'"], ["proof (chain)\npicking this:\n  compTP P \\<turnstile> start_tid:JVM_start_state' (compP2 P) C M vs \\<surd>\n  compP2\n   P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>compMb2\n                   body\\<rfloor> in D", "have \"compTP P \\<turnstile> start_tid:(None, start_heap, [([], ?xs, D, M, 0)]) \\<surd>\""], ["proof (prove)\nusing this:\n  compTP P \\<turnstile> start_tid:JVM_start_state' (compP2 P) C M vs \\<surd>\n  compP2\n   P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>compMb2\n                   body\\<rfloor> in D\n\ngoal (1 subgoal):\n 1. compTP\n     P \\<turnstile> start_tid:(None, start_heap,\n                               [([],\n                                 Null #\n                                 vs @\n                                 replicate (max_vars body) undefined_value,\n                                 D, M, 0)]) \\<surd>", "by(simp add: JVM_start_state'_def compP2_def compMb2_def)"], ["proof (state)\nthis:\n  compTP\n   P \\<turnstile> start_tid:(None, start_heap,\n                             [([],\n                               Null #\n                               vs @\n                               replicate (max_vars body) undefined_value,\n                               D, M, 0)]) \\<surd>\n\ngoal (1 subgoal):\n 1. Red1_execd.mbisim (J1_start_state P C M vs)\n     (start_state JVM_local_start (compP2 P) C M vs)", "hence \"bisim1_list1 start_tid start_heap (?e, ?xs) [] None [([], ?xs, D, M, 0)]\""], ["proof (prove)\nusing this:\n  compTP\n   P \\<turnstile> start_tid:(None, start_heap,\n                             [([],\n                               Null #\n                               vs @\n                               replicate (max_vars body) undefined_value,\n                               D, M, 0)]) \\<surd>\n\ngoal (1 subgoal):\n 1. bisim1_list1 start_tid start_heap\n     (blocks1 0 (Class D # Ts) body,\n      Null # vs @ replicate (max_vars body) undefined_value)\n     [] None\n     [([], Null # vs @ replicate (max_vars body) undefined_value, D, M, 0)]", "using sees_method_idemp[OF sees]"], ["proof (prove)\nusing this:\n  compTP\n   P \\<turnstile> start_tid:(None, start_heap,\n                             [([],\n                               Null #\n                               vs @\n                               replicate (max_vars body) undefined_value,\n                               D, M, 0)]) \\<surd>\n  P \\<turnstile> D sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\n\ngoal (1 subgoal):\n 1. bisim1_list1 start_tid start_heap\n     (blocks1 0 (Class D # Ts) body,\n      Null # vs @ replicate (max_vars body) undefined_value)\n     [] None\n     [([], Null # vs @ replicate (max_vars body) undefined_value, D, M, 0)]", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. P,blocks1 0 (Class D # Ts)\n       body,start_heap \\<turnstile> (blocks1 0 (Class D # Ts) body,\n                                     Null #\n                                     vs @\n                                     replicate (max_vars body)\nundefined_value) \\<leftrightarrow> ([],\n                                    Null #\n                                    vs @\n                                    replicate (max_vars body)\n                                     undefined_value,\n                                    0, None)\n 2. max_vars (blocks1 0 (Class D # Ts) body)\n    \\<le> length (Null # vs @ replicate (max_vars body) undefined_value)\n 3. list_all2 (bisim1_fr P start_heap) [] []", "show \"P,?e,start_heap \\<turnstile> (?e, ?xs) \\<leftrightarrow> ([], ?xs, 0, None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,blocks1 0 (Class D # Ts)\n       body,start_heap \\<turnstile> (blocks1 0 (Class D # Ts) body,\n                                     Null #\n                                     vs @\n                                     replicate (max_vars body)\nundefined_value) \\<leftrightarrow> ([],\n                                    Null #\n                                    vs @\n                                    replicate (max_vars body)\n                                     undefined_value,\n                                    0, None)", "by(rule bisim1_refl)"], ["proof (state)\nthis:\n  P,blocks1 0 (Class D # Ts)\n     body,start_heap \\<turnstile> (blocks1 0 (Class D # Ts) body,\n                                   Null #\n                                   vs @\n                                   replicate (max_vars body)\n                                    undefined_value) \\<leftrightarrow> ([],\n                                  Null #\n                                  vs @\n                                  replicate (max_vars body) undefined_value,\n                                  0, None)\n\ngoal (2 subgoals):\n 1. max_vars (blocks1 0 (Class D # Ts) body)\n    \\<le> length (Null # vs @ replicate (max_vars body) undefined_value)\n 2. list_all2 (bisim1_fr P start_heap) [] []", "show \"max_vars ?e \\<le> length ?xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_vars (blocks1 0 (Class D # Ts) body)\n    \\<le> length (Null # vs @ replicate (max_vars body) undefined_value)", "using conf"], ["proof (prove)\nusing this:\n  P,start_heap \\<turnstile> vs [:\\<le>] Ts\n\ngoal (1 subgoal):\n 1. max_vars (blocks1 0 (Class D # Ts) body)\n    \\<le> length (Null # vs @ replicate (max_vars body) undefined_value)", "by(auto simp add: blocks1_max_vars dest: list_all2_lengthD)"], ["proof (state)\nthis:\n  max_vars (blocks1 0 (Class D # Ts) body)\n  \\<le> length (Null # vs @ replicate (max_vars body) undefined_value)\n\ngoal (1 subgoal):\n 1. list_all2 (bisim1_fr P start_heap) [] []", "qed simp"], ["proof (state)\nthis:\n  bisim1_list1 start_tid start_heap\n   (blocks1 0 (Class D # Ts) body,\n    Null # vs @ replicate (max_vars body) undefined_value)\n   [] None\n   [([], Null # vs @ replicate (max_vars body) undefined_value, D, M, 0)]\n\ngoal (1 subgoal):\n 1. Red1_execd.mbisim (J1_start_state P C M vs)\n     (start_state JVM_local_start (compP2 P) C M vs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  bisim1_list1 start_tid start_heap\n   (blocks1 0 (Class D # Ts) body,\n    Null # vs @ replicate (max_vars body) undefined_value)\n   [] None\n   [([], Null # vs @ replicate (max_vars body) undefined_value, D, M, 0)]\n\ngoal (1 subgoal):\n 1. Red1_execd.mbisim (J1_start_state P C M vs)\n     (start_state JVM_local_start (compP2 P) C M vs)", "using sees sees'"], ["proof (prove)\nusing this:\n  bisim1_list1 start_tid start_heap\n   (blocks1 0 (Class D # Ts) body,\n    Null # vs @ replicate (max_vars body) undefined_value)\n   [] None\n   [([], Null # vs @ replicate (max_vars body) undefined_value, D, M, 0)]\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\n  compP2\n   P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>compMb2\n                   body\\<rfloor> in D\n\ngoal (1 subgoal):\n 1. Red1_execd.mbisim (J1_start_state P C M vs)\n     (start_state JVM_local_start (compP2 P) C M vs)", "unfolding start_state_def"], ["proof (prove)\nusing this:\n  bisim1_list1 start_tid start_heap\n   (blocks1 0 (Class D # Ts) body,\n    Null # vs @ replicate (max_vars body) undefined_value)\n   [] None\n   [([], Null # vs @ replicate (max_vars body) undefined_value, D, M, 0)]\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\n  compP2\n   P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>compMb2\n                   body\\<rfloor> in D\n\ngoal (1 subgoal):\n 1. Red1_execd.mbisim\n     (let (D, Ts, T, m) = method P C M\n      in (K$ None,\n          ([start_tid \\<mapsto>\n            (((blocks1 0 (Class D # Ts) (the m),\n               Null # vs @ replicate (max_vars (the m)) undefined_value),\n              []),\n             no_wait_locks)],\n           start_heap),\n          Map.empty, {}))\n     (let (D, Ts, T, m) = method (compP2 P) C M\n      in (K$ None,\n          ([start_tid \\<mapsto>\n            ((case the m of\n              (mxs, mxl0, b) \\<Rightarrow>\n                \\<lambda>vs.\n                   (None,\n                    [([], Null # vs @ replicate mxl0 undefined_value, D, M,\n                      0)]))\n              vs,\n             no_wait_locks)],\n           start_heap),\n          Map.empty, {}))", "by -(rule Red1_execd.mbisimI, auto split: if_split_asm intro: wset_thread_okI simp add: compP2_def compMb2_def)"], ["proof (state)\nthis:\n  Red1_execd.mbisim (J1_start_state P C M vs)\n   (start_state JVM_local_start (compP2 P) C M vs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas \\<tau>red1_Val_simps = \\<tau>red1r_Val \\<tau>red1t_Val \\<tau>reds1r_map_Val \\<tau>reds1t_map_Val"], ["", "end"], ["", "end"]]}