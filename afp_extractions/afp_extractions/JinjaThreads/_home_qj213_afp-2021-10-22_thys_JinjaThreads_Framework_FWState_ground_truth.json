{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Framework/FWState.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma locks_a_conv [simp]: \"locks_a (ls, ntsjswss) = ls\"", "lemma thr_a_conv [simp]: \"thr_a (ls, nts, jswss) = nts\"", "lemma cond_a_conv [simp]: \"cond_a (ls, nts, js, wws) = js\"", "lemma wset_a_conv [simp]: \"wset_a (ls, nts, js, wss, isobs) = wss\"", "lemma interrupt_a_conv [simp]: \"interrupt_a (ls, nts, js, ws, is, obs) = is\"", "lemma obs_a_conv [simp]: \"obs_a (ls, nts, js, wss, is, obs) = obs\"", "lemma ta_upd_proj_simps [simp]:\n  shows ta_obs_proj_simps:\n  \"\\<lbrace>ta_update_obs ta obs\\<rbrace>\\<^bsub>l\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\" \"\\<lbrace>ta_update_obs ta obs\\<rbrace>\\<^bsub>t\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\" \"\\<lbrace>ta_update_obs ta obs\\<rbrace>\\<^bsub>w\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\" \n  \"\\<lbrace>ta_update_obs ta obs\\<rbrace>\\<^bsub>c\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>\" \"\\<lbrace>ta_update_obs ta obs\\<rbrace>\\<^bsub>i\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\" \"\\<lbrace>ta_update_obs ta obs\\<rbrace>\\<^bsub>o\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> @ [obs]\"\n  and ta_lock_proj_simps:\n  \"\\<lbrace>ta_update_locks ta x l\\<rbrace>\\<^bsub>l\\<^esub> = (let ls = \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> in ls(l $:= ls $ l @ [x]))\"\n  \"\\<lbrace>ta_update_locks ta x l\\<rbrace>\\<^bsub>t\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\" \"\\<lbrace>ta_update_locks ta x l\\<rbrace>\\<^bsub>w\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\" \"\\<lbrace>ta_update_locks ta x l\\<rbrace>\\<^bsub>c\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>\" \n  \"\\<lbrace>ta_update_locks ta x l\\<rbrace>\\<^bsub>i\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\" \"\\<lbrace>ta_update_locks ta x l\\<rbrace>\\<^bsub>o\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\"\n  and ta_thread_proj_simps:\n  \"\\<lbrace>ta_update_NewThread ta t\\<rbrace>\\<^bsub>l\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\" \"\\<lbrace>ta_update_NewThread ta t\\<rbrace>\\<^bsub>t\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> @ [t]\" \"\\<lbrace>ta_update_NewThread ta t\\<rbrace>\\<^bsub>w\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\" \n  \"\\<lbrace>ta_update_NewThread ta t\\<rbrace>\\<^bsub>c\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>\" \"\\<lbrace>ta_update_NewThread ta t\\<rbrace>\\<^bsub>i\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\" \"\\<lbrace>ta_update_NewThread ta t\\<rbrace>\\<^bsub>o\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\"\n  and ta_wset_proj_simps:\n  \"\\<lbrace>ta_update_wait_set ta w\\<rbrace>\\<^bsub>l\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\" \"\\<lbrace>ta_update_wait_set ta w\\<rbrace>\\<^bsub>t\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\" \"\\<lbrace>ta_update_wait_set ta w\\<rbrace>\\<^bsub>w\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> @ [w]\"\n  \"\\<lbrace>ta_update_wait_set ta w\\<rbrace>\\<^bsub>c\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>\" \"\\<lbrace>ta_update_wait_set ta w\\<rbrace>\\<^bsub>i\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\" \"\\<lbrace>ta_update_wait_set ta w\\<rbrace>\\<^bsub>o\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\"\n  and ta_cond_proj_simps:\n  \"\\<lbrace>ta_update_Conditional ta c\\<rbrace>\\<^bsub>l\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\" \"\\<lbrace>ta_update_Conditional ta c\\<rbrace>\\<^bsub>t\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\" \"\\<lbrace>ta_update_Conditional ta c\\<rbrace>\\<^bsub>w\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\"\n  \"\\<lbrace>ta_update_Conditional ta c\\<rbrace>\\<^bsub>c\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> @ [c]\" \"\\<lbrace>ta_update_Conditional ta c\\<rbrace>\\<^bsub>i\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\" \"\\<lbrace>ta_update_Conditional ta c\\<rbrace>\\<^bsub>o\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\"\n  and ta_interrupt_proj_simps:\n  \"\\<lbrace>ta_update_interrupt ta i\\<rbrace>\\<^bsub>l\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\" \"\\<lbrace>ta_update_interrupt ta i\\<rbrace>\\<^bsub>t\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\" \"\\<lbrace>ta_update_interrupt ta i\\<rbrace>\\<^bsub>c\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>\"\n  \"\\<lbrace>ta_update_interrupt ta i\\<rbrace>\\<^bsub>w\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\" \"\\<lbrace>ta_update_interrupt ta i\\<rbrace>\\<^bsub>i\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> @ [i]\" \"\\<lbrace>ta_update_interrupt ta i\\<rbrace>\\<^bsub>o\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\"", "lemma thread_action'_to_thread_action_proj_simps [simp]:\n  shows thread_action'_to_thread_action_proj_locks_simps:\n  \"\\<lbrace>thread_action'_to_thread_action (LockAction (la, l)) ta\\<rbrace>\\<^bsub>l\\<^esub> = \\<lbrace>ta_update_locks ta la l\\<rbrace>\\<^bsub>l\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (NewThreadAction nt) ta\\<rbrace>\\<^bsub>l\\<^esub> = \\<lbrace>ta_update_NewThread ta nt\\<rbrace>\\<^bsub>l\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (ConditionalAction ca) ta\\<rbrace>\\<^bsub>l\\<^esub> = \\<lbrace>ta_update_Conditional ta ca\\<rbrace>\\<^bsub>l\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (WaitSetAction wa) ta\\<rbrace>\\<^bsub>l\\<^esub> = \\<lbrace>ta_update_wait_set ta wa\\<rbrace>\\<^bsub>l\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (InterruptAction ia) ta\\<rbrace>\\<^bsub>l\\<^esub> = \\<lbrace>ta_update_interrupt ta ia\\<rbrace>\\<^bsub>l\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (ObsAction ob) ta\\<rbrace>\\<^bsub>l\\<^esub> = \\<lbrace>ta_update_obs ta ob\\<rbrace>\\<^bsub>l\\<^esub>\"\n  and thread_action'_to_thread_action_proj_nt_simps:\n  \"\\<lbrace>thread_action'_to_thread_action (LockAction (la, l)) ta\\<rbrace>\\<^bsub>t\\<^esub> = \\<lbrace>ta_update_locks ta la l\\<rbrace>\\<^bsub>t\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (NewThreadAction nt) ta\\<rbrace>\\<^bsub>t\\<^esub> = \\<lbrace>ta_update_NewThread ta nt\\<rbrace>\\<^bsub>t\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (ConditionalAction ca) ta\\<rbrace>\\<^bsub>t\\<^esub> = \\<lbrace>ta_update_Conditional ta ca\\<rbrace>\\<^bsub>t\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (WaitSetAction wa) ta\\<rbrace>\\<^bsub>t\\<^esub> = \\<lbrace>ta_update_wait_set ta wa\\<rbrace>\\<^bsub>t\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (InterruptAction ia) ta\\<rbrace>\\<^bsub>t\\<^esub> = \\<lbrace>ta_update_interrupt ta ia\\<rbrace>\\<^bsub>t\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (ObsAction ob) ta\\<rbrace>\\<^bsub>t\\<^esub> = \\<lbrace>ta_update_obs ta ob\\<rbrace>\\<^bsub>t\\<^esub>\"\n  and thread_action'_to_thread_action_proj_cond_simps:\n  \"\\<lbrace>thread_action'_to_thread_action (LockAction (la, l)) ta\\<rbrace>\\<^bsub>c\\<^esub> = \\<lbrace>ta_update_locks ta la l\\<rbrace>\\<^bsub>c\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (NewThreadAction nt) ta\\<rbrace>\\<^bsub>c\\<^esub> = \\<lbrace>ta_update_NewThread ta nt\\<rbrace>\\<^bsub>c\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (ConditionalAction ca) ta\\<rbrace>\\<^bsub>c\\<^esub> = \\<lbrace>ta_update_Conditional ta ca\\<rbrace>\\<^bsub>c\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (WaitSetAction wa) ta\\<rbrace>\\<^bsub>c\\<^esub> = \\<lbrace>ta_update_wait_set ta wa\\<rbrace>\\<^bsub>c\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (InterruptAction ia) ta\\<rbrace>\\<^bsub>c\\<^esub> = \\<lbrace>ta_update_interrupt ta ia\\<rbrace>\\<^bsub>c\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (ObsAction ob) ta\\<rbrace>\\<^bsub>c\\<^esub> = \\<lbrace>ta_update_obs ta ob\\<rbrace>\\<^bsub>c\\<^esub>\"\n  and thread_action'_to_thread_action_proj_wset_simps:\n  \"\\<lbrace>thread_action'_to_thread_action (LockAction (la, l)) ta\\<rbrace>\\<^bsub>w\\<^esub> = \\<lbrace>ta_update_locks ta la l\\<rbrace>\\<^bsub>w\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (NewThreadAction nt) ta\\<rbrace>\\<^bsub>w\\<^esub> = \\<lbrace>ta_update_NewThread ta nt\\<rbrace>\\<^bsub>w\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (ConditionalAction ca) ta\\<rbrace>\\<^bsub>w\\<^esub> = \\<lbrace>ta_update_Conditional ta ca\\<rbrace>\\<^bsub>w\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (WaitSetAction wa) ta\\<rbrace>\\<^bsub>w\\<^esub> = \\<lbrace>ta_update_wait_set ta wa\\<rbrace>\\<^bsub>w\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (InterruptAction ia) ta\\<rbrace>\\<^bsub>w\\<^esub> = \\<lbrace>ta_update_interrupt ta ia\\<rbrace>\\<^bsub>w\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (ObsAction ob) ta\\<rbrace>\\<^bsub>w\\<^esub> = \\<lbrace>ta_update_obs ta ob\\<rbrace>\\<^bsub>w\\<^esub>\"\n  and thread_action'_to_thread_action_proj_interrupt_simps:\n  \"\\<lbrace>thread_action'_to_thread_action (LockAction (la, l)) ta\\<rbrace>\\<^bsub>i\\<^esub> = \\<lbrace>ta_update_locks ta la l\\<rbrace>\\<^bsub>i\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (NewThreadAction nt) ta\\<rbrace>\\<^bsub>i\\<^esub> = \\<lbrace>ta_update_NewThread ta nt\\<rbrace>\\<^bsub>i\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (ConditionalAction ca) ta\\<rbrace>\\<^bsub>i\\<^esub> = \\<lbrace>ta_update_Conditional ta ca\\<rbrace>\\<^bsub>i\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (WaitSetAction wa) ta\\<rbrace>\\<^bsub>i\\<^esub> = \\<lbrace>ta_update_wait_set ta wa\\<rbrace>\\<^bsub>i\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (InterruptAction ia) ta\\<rbrace>\\<^bsub>i\\<^esub> = \\<lbrace>ta_update_interrupt ta ia\\<rbrace>\\<^bsub>i\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (ObsAction ob) ta\\<rbrace>\\<^bsub>i\\<^esub> = \\<lbrace>ta_update_obs ta ob\\<rbrace>\\<^bsub>i\\<^esub>\"\n  and thread_action'_to_thread_action_proj_obs_simps:\n  \"\\<lbrace>thread_action'_to_thread_action (LockAction (la, l)) ta\\<rbrace>\\<^bsub>o\\<^esub> = \\<lbrace>ta_update_locks ta la l\\<rbrace>\\<^bsub>o\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (NewThreadAction nt) ta\\<rbrace>\\<^bsub>o\\<^esub> = \\<lbrace>ta_update_NewThread ta nt\\<rbrace>\\<^bsub>o\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (ConditionalAction ca) ta\\<rbrace>\\<^bsub>o\\<^esub> = \\<lbrace>ta_update_Conditional ta ca\\<rbrace>\\<^bsub>o\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (WaitSetAction wa) ta\\<rbrace>\\<^bsub>o\\<^esub> = \\<lbrace>ta_update_wait_set ta wa\\<rbrace>\\<^bsub>o\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (InterruptAction ia) ta\\<rbrace>\\<^bsub>o\\<^esub> = \\<lbrace>ta_update_interrupt ta ia\\<rbrace>\\<^bsub>o\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (ObsAction ob) ta\\<rbrace>\\<^bsub>o\\<^esub> = \\<lbrace>ta_update_obs ta ob\\<rbrace>\\<^bsub>o\\<^esub>\"", "lemmas ta_upd_simps =\n  ta_update_locks.simps ta_update_NewThread.simps ta_update_Conditional.simps\n  ta_update_wait_set.simps ta_update_interrupt.simps ta_update_obs.simps\n  thread_action'_to_thread_action.simps", "lemma neq_no_wait_locks_conv:\n  \"\\<And>ln. ln \\<noteq> no_wait_locks \\<longleftrightarrow> (\\<exists>l. ln $ l > 0)\"", "lemma neq_no_wait_locksE:\n  fixes ln assumes \"ln \\<noteq> no_wait_locks\" obtains l where \"ln $ l > 0\"", "lemma locks_conv [simp]: \"locks (ls, tsmws) = ls\"", "lemma thr_conv [simp]: \"thr (ls, (ts, m), ws) = ts\"", "lemma shr_conv [simp]: \"shr (ls, (ts, m), ws, is) = m\"", "lemma wset_conv [simp]: \"wset (ls, (ts, m), ws, is) = ws\"", "lemma interrupts_conv [simp]: \"interrupts (ls, (ts, m), ws, is) = is\"", "lemma convert_new_thread_action_inv [simp]:\n  \"NewThread t x h = convert_new_thread_action f nta \\<longleftrightarrow> (\\<exists>x'. nta = NewThread t x' h \\<and> x = f x')\"\n  \"ThreadExists t b = convert_new_thread_action f nta \\<longleftrightarrow> nta = ThreadExists t b\"\n  \"convert_new_thread_action f nta = NewThread t x h \\<longleftrightarrow> (\\<exists>x'. nta = NewThread t x' h \\<and> x = f x')\"\n  \"convert_new_thread_action f nta = ThreadExists t b \\<longleftrightarrow> nta = ThreadExists t b\"", "lemma convert_new_thread_action_eqI: \n  \"\\<lbrakk> \\<And>t x m. nta = NewThread t x m \\<Longrightarrow> nta' = NewThread t (f x) m;\n     \\<And>t b. nta = ThreadExists t b \\<Longrightarrow> nta' = ThreadExists t b \\<rbrakk>\n  \\<Longrightarrow> convert_new_thread_action f nta = nta'\"", "lemma convert_new_thread_action_compose [simp]:\n  \"convert_new_thread_action f (convert_new_thread_action g ta) = convert_new_thread_action (f o g) ta\"", "lemma inj_convert_new_thread_action [simp]: \n  \"inj (convert_new_thread_action f) = inj f\"", "lemma convert_new_thread_action_id:\n  \"convert_new_thread_action id = (id :: ('t, 'x, 'm) new_thread_action \\<Rightarrow> ('t, 'x, 'm) new_thread_action)\" (is ?thesis1)\n  \"convert_new_thread_action (\\<lambda>x. x) = (id :: ('t, 'x, 'm) new_thread_action \\<Rightarrow> ('t, 'x, 'm) new_thread_action)\" (is ?thesis2)", "lemma convert_extTA_simps [simp]:\n  \"convert_extTA f \\<epsilon> = \\<epsilon>\"\n  \"\\<lbrace>convert_extTA f ta\\<rbrace>\\<^bsub>l\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\"\n  \"\\<lbrace>convert_extTA f ta\\<rbrace>\\<^bsub>t\\<^esub> = map (convert_new_thread_action f) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\"\n  \"\\<lbrace>convert_extTA f ta\\<rbrace>\\<^bsub>c\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>\"\n  \"\\<lbrace>convert_extTA f ta\\<rbrace>\\<^bsub>w\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\"\n  \"\\<lbrace>convert_extTA f ta\\<rbrace>\\<^bsub>i\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\"\n  \"convert_extTA f (las, tas, was, cas, is, obs) = (las, map (convert_new_thread_action f) tas, was, cas, is, obs)\"", "lemma convert_extTA_eq_conv:\n  \"convert_extTA f ta = ta' \\<longleftrightarrow>\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and> \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> = \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and> \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> = \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> \\<and> \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub> \\<and> \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> = \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub> \\<and> length \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> = length \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> \\<and> \n   (\\<forall>n < length \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>. convert_new_thread_action f (\\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> ! n) = \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> ! n)\"", "lemma convert_extTA_compose [simp]:\n  \"convert_extTA f (convert_extTA g ta) = convert_extTA (f o g) ta\"", "lemma obs_a_convert_extTA [simp]: \"obs_a (convert_extTA f ta) = obs_a ta\"", "lemma inj_NormalAction [simp]: \"inj NormalAction\"", "lemma convert_obs_initial_inject [simp]:\n  \"convert_obs_initial ta = convert_obs_initial ta' \\<longleftrightarrow> ta = ta'\"", "lemma convert_obs_initial_empty_TA [simp]:\n  \"convert_obs_initial \\<epsilon> = \\<epsilon>\"", "lemma convert_obs_initial_eq_empty_TA [simp]:\n  \"convert_obs_initial ta = \\<epsilon> \\<longleftrightarrow> ta = \\<epsilon>\"\n  \"\\<epsilon> = convert_obs_initial ta \\<longleftrightarrow> ta = \\<epsilon>\"", "lemma convert_obs_initial_simps [simp]:\n  \"\\<lbrace>convert_obs_initial ta\\<rbrace>\\<^bsub>o\\<^esub> = map NormalAction \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\"\n  \"\\<lbrace>convert_obs_initial ta\\<rbrace>\\<^bsub>l\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\"\n  \"\\<lbrace>convert_obs_initial ta\\<rbrace>\\<^bsub>t\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\"\n  \"\\<lbrace>convert_obs_initial ta\\<rbrace>\\<^bsub>c\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>\"\n  \"\\<lbrace>convert_obs_initial ta\\<rbrace>\\<^bsub>w\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\"\n  \"\\<lbrace>convert_obs_initial ta\\<rbrace>\\<^bsub>i\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\""], "translations": [["", "lemma locks_a_conv [simp]: \"locks_a (ls, ntsjswss) = ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>(ls, ntsjswss)\\<rbrace>\\<^bsub>l\\<^esub> = ls", "by(simp add:locks_a_def)"], ["", "lemma thr_a_conv [simp]: \"thr_a (ls, nts, jswss) = nts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>(ls, nts, jswss)\\<rbrace>\\<^bsub>t\\<^esub> = nts", "by(simp add: thr_a_def)"], ["", "lemma cond_a_conv [simp]: \"cond_a (ls, nts, js, wws) = js\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>(ls, nts, js, wws)\\<rbrace>\\<^bsub>c\\<^esub> = js", "by(simp add: cond_a_def)"], ["", "lemma wset_a_conv [simp]: \"wset_a (ls, nts, js, wss, isobs) = wss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>(ls, nts, js, wss, isobs)\\<rbrace>\\<^bsub>w\\<^esub> = wss", "by(simp add: wset_a_def)"], ["", "lemma interrupt_a_conv [simp]: \"interrupt_a (ls, nts, js, ws, is, obs) = is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>(ls, nts, js, ws, is, obs)\\<rbrace>\\<^bsub>i\\<^esub> = is", "by(simp add: interrupt_a_def)"], ["", "lemma obs_a_conv [simp]: \"obs_a (ls, nts, js, wss, is, obs) = obs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>(ls, nts, js, wss, is, obs)\\<rbrace>\\<^bsub>o\\<^esub> = obs", "by(simp add: obs_a_def)"], ["", "fun ta_update_locks :: \"('l,'t,'x,'m,'w,'o) thread_action \\<Rightarrow> lock_action \\<Rightarrow> 'l \\<Rightarrow> ('l,'t,'x,'m,'w,'o) thread_action\" where\n  \"ta_update_locks (ls, nts, js, wss, obs) lta l = (ls(l $:= ls $ l @ [lta]), nts, js, wss, obs)\""], ["", "fun ta_update_NewThread :: \"('l,'t,'x,'m,'w,'o) thread_action \\<Rightarrow> ('t,'x,'m) new_thread_action \\<Rightarrow> ('l,'t,'x,'m,'w,'o) thread_action\" where\n  \"ta_update_NewThread (ls, nts, js, wss, is, obs) nt = (ls, nts @ [nt], js, wss, is, obs)\""], ["", "fun ta_update_Conditional :: \"('l,'t,'x,'m,'w,'o) thread_action \\<Rightarrow> 't conditional_action \\<Rightarrow> ('l,'t,'x,'m,'w,'o) thread_action\"\nwhere\n  \"ta_update_Conditional (ls, nts, js, wss, is, obs) j = (ls, nts, js @ [j], wss, is, obs)\""], ["", "fun ta_update_wait_set :: \"('l,'t,'x,'m,'w,'o) thread_action \\<Rightarrow> ('t, 'w) wait_set_action \\<Rightarrow> ('l,'t,'x,'m,'w,'o) thread_action\" where\n  \"ta_update_wait_set (ls, nts, js, wss, is, obs) ws = (ls, nts, js, wss @ [ws], is, obs)\""], ["", "fun ta_update_interrupt :: \"('l,'t,'x,'m,'w,'o) thread_action \\<Rightarrow> 't interrupt_action \\<Rightarrow> ('l,'t,'x,'m,'w,'o) thread_action\"\nwhere\n  \"ta_update_interrupt (ls, nts, js, wss, is, obs) i = (ls, nts, js, wss, is @ [i], obs)\""], ["", "fun ta_update_obs :: \"('l,'t,'x,'m,'w,'o) thread_action \\<Rightarrow> 'o \\<Rightarrow> ('l,'t,'x,'m,'w,'o) thread_action\"\nwhere\n  \"ta_update_obs (ls, nts, js, wss, is, obs) ob = (ls, nts, js, wss, is, obs @ [ob])\""], ["", "abbreviation empty_ta :: \"('l,'t,'x,'m,'w,'o) thread_action\" where\n  \"empty_ta \\<equiv> (K$ [], [], [], [], [], [])\""], ["", "notation (input) empty_ta (\"\\<epsilon>\")"], ["", "text \\<open>\n  Pretty syntax for specifying thread actions:\n  Write \\<open>\\<lbrace> Lock\\<rightarrow>l, Unlock\\<rightarrow>l, Suspend w, Interrupt t\\<rbrace>\\<close> instead of\n  @{term \"((K$ [])(l $:= [Lock, Unlock]), [], [Suspend w], [Interrupt t], [])\"}.\n\n  \\<open>thread_action'\\<close> is a type that contains of all basic thread actions.\n  Automatically coerce basic thread actions into that type and then dispatch to the right\n  update function by pattern matching.\n  For coercion, adhoc overloading replaces the generic injection \\<open>inject_thread_action\\<close>\n  by the specific ones, i.e. constructors.\n  To avoid ambiguities with observable actions, the observable actions must be of sort \\<open>obs_action\\<close>,\n  which the basic thread action types are not.\n\\<close>"], ["", "class obs_action"], ["", "datatype ('l,'t,'x,'m,'w,'o) thread_action' \n  = LockAction \"lock_action \\<times> 'l\"\n  | NewThreadAction \"('t,'x,'m) new_thread_action\"\n  | ConditionalAction \"'t conditional_action\"\n  | WaitSetAction \"('t, 'w) wait_set_action\"\n  | InterruptAction \"'t interrupt_action\"\n  | ObsAction 'o"], ["", "setup \\<open>\n  Sign.add_const_constraint (@{const_name ObsAction}, SOME @{typ \"'o :: obs_action \\<Rightarrow> ('l,'t,'x,'m,'w,'o) thread_action'\"})\n\\<close>"], ["", "fun thread_action'_to_thread_action :: \n  \"('l,'t,'x,'m,'w,'o :: obs_action) thread_action' \\<Rightarrow> ('l,'t,'x,'m,'w,'o) thread_action \\<Rightarrow> ('l,'t,'x,'m,'w,'o) thread_action\"\nwhere\n  \"thread_action'_to_thread_action (LockAction (la, l)) ta = ta_update_locks ta la l\"\n| \"thread_action'_to_thread_action (NewThreadAction nt) ta = ta_update_NewThread ta nt\"\n| \"thread_action'_to_thread_action (ConditionalAction ca) ta = ta_update_Conditional ta ca\"\n| \"thread_action'_to_thread_action (WaitSetAction wa) ta = ta_update_wait_set ta wa\"\n| \"thread_action'_to_thread_action (InterruptAction ia) ta = ta_update_interrupt ta ia\"\n| \"thread_action'_to_thread_action (ObsAction ob) ta = ta_update_obs ta ob\""], ["", "consts inject_thread_action :: \"'a \\<Rightarrow> ('l,'t,'x,'m,'w,'o) thread_action'\""], ["", "nonterminal ta_let and ta_lets"], ["", "syntax\n  \"_ta_snoc\" :: \"ta_lets \\<Rightarrow> ta_let \\<Rightarrow> ta_lets\" (\"_,/ _\")\n  \"_ta_block\" :: \"ta_lets \\<Rightarrow> 'a\" (\"\\<lbrace>_\\<rbrace>\" [0] 1000)\n  \"_ta_empty\" :: \"ta_lets\" (\"\") \n  \"_ta_single\" :: \"ta_let \\<Rightarrow> ta_lets\" (\"_\")\n  \"_ta_inject\" :: \"logic \\<Rightarrow> ta_let\" (\"(_)\")\n  \"_ta_lock\" :: \"logic \\<Rightarrow> logic \\<Rightarrow> ta_let\" (\"_\\<rightarrow>_\")"], ["", "translations\n  \"_ta_block _ta_empty\" == \"CONST empty_ta\"\n  \"_ta_block (_ta_single bta)\" == \"_ta_block (_ta_snoc _ta_empty bta)\"\n  \"_ta_inject bta\" == \"CONST inject_thread_action bta\"\n  \"_ta_lock la l\" == \"CONST inject_thread_action (CONST Pair la l)\"\n  \"_ta_block (_ta_snoc btas bta)\" == \"CONST thread_action'_to_thread_action bta (_ta_block btas)\""], ["", "adhoc_overloading\n  inject_thread_action NewThreadAction ConditionalAction WaitSetAction InterruptAction ObsAction LockAction"], ["", "lemma ta_upd_proj_simps [simp]:\n  shows ta_obs_proj_simps:\n  \"\\<lbrace>ta_update_obs ta obs\\<rbrace>\\<^bsub>l\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\" \"\\<lbrace>ta_update_obs ta obs\\<rbrace>\\<^bsub>t\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\" \"\\<lbrace>ta_update_obs ta obs\\<rbrace>\\<^bsub>w\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\" \n  \"\\<lbrace>ta_update_obs ta obs\\<rbrace>\\<^bsub>c\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>\" \"\\<lbrace>ta_update_obs ta obs\\<rbrace>\\<^bsub>i\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\" \"\\<lbrace>ta_update_obs ta obs\\<rbrace>\\<^bsub>o\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> @ [obs]\"\n  and ta_lock_proj_simps:\n  \"\\<lbrace>ta_update_locks ta x l\\<rbrace>\\<^bsub>l\\<^esub> = (let ls = \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> in ls(l $:= ls $ l @ [x]))\"\n  \"\\<lbrace>ta_update_locks ta x l\\<rbrace>\\<^bsub>t\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\" \"\\<lbrace>ta_update_locks ta x l\\<rbrace>\\<^bsub>w\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\" \"\\<lbrace>ta_update_locks ta x l\\<rbrace>\\<^bsub>c\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>\" \n  \"\\<lbrace>ta_update_locks ta x l\\<rbrace>\\<^bsub>i\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\" \"\\<lbrace>ta_update_locks ta x l\\<rbrace>\\<^bsub>o\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\"\n  and ta_thread_proj_simps:\n  \"\\<lbrace>ta_update_NewThread ta t\\<rbrace>\\<^bsub>l\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\" \"\\<lbrace>ta_update_NewThread ta t\\<rbrace>\\<^bsub>t\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> @ [t]\" \"\\<lbrace>ta_update_NewThread ta t\\<rbrace>\\<^bsub>w\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\" \n  \"\\<lbrace>ta_update_NewThread ta t\\<rbrace>\\<^bsub>c\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>\" \"\\<lbrace>ta_update_NewThread ta t\\<rbrace>\\<^bsub>i\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\" \"\\<lbrace>ta_update_NewThread ta t\\<rbrace>\\<^bsub>o\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\"\n  and ta_wset_proj_simps:\n  \"\\<lbrace>ta_update_wait_set ta w\\<rbrace>\\<^bsub>l\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\" \"\\<lbrace>ta_update_wait_set ta w\\<rbrace>\\<^bsub>t\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\" \"\\<lbrace>ta_update_wait_set ta w\\<rbrace>\\<^bsub>w\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> @ [w]\"\n  \"\\<lbrace>ta_update_wait_set ta w\\<rbrace>\\<^bsub>c\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>\" \"\\<lbrace>ta_update_wait_set ta w\\<rbrace>\\<^bsub>i\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\" \"\\<lbrace>ta_update_wait_set ta w\\<rbrace>\\<^bsub>o\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\"\n  and ta_cond_proj_simps:\n  \"\\<lbrace>ta_update_Conditional ta c\\<rbrace>\\<^bsub>l\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\" \"\\<lbrace>ta_update_Conditional ta c\\<rbrace>\\<^bsub>t\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\" \"\\<lbrace>ta_update_Conditional ta c\\<rbrace>\\<^bsub>w\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\"\n  \"\\<lbrace>ta_update_Conditional ta c\\<rbrace>\\<^bsub>c\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> @ [c]\" \"\\<lbrace>ta_update_Conditional ta c\\<rbrace>\\<^bsub>i\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\" \"\\<lbrace>ta_update_Conditional ta c\\<rbrace>\\<^bsub>o\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\"\n  and ta_interrupt_proj_simps:\n  \"\\<lbrace>ta_update_interrupt ta i\\<rbrace>\\<^bsub>l\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\" \"\\<lbrace>ta_update_interrupt ta i\\<rbrace>\\<^bsub>t\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\" \"\\<lbrace>ta_update_interrupt ta i\\<rbrace>\\<^bsub>c\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>\"\n  \"\\<lbrace>ta_update_interrupt ta i\\<rbrace>\\<^bsub>w\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\" \"\\<lbrace>ta_update_interrupt ta i\\<rbrace>\\<^bsub>i\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> @ [i]\" \"\\<lbrace>ta_update_interrupt ta i\\<rbrace>\\<^bsub>o\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((\\<lbrace>ta_update_obs ta obs\\<rbrace>\\<^bsub>l\\<^esub> =\n       \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> &&&\n       \\<lbrace>ta_update_obs ta obs\\<rbrace>\\<^bsub>t\\<^esub> =\n       \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> &&&\n       \\<lbrace>ta_update_obs ta obs\\<rbrace>\\<^bsub>w\\<^esub> =\n       \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>) &&&\n      \\<lbrace>ta_update_obs ta obs\\<rbrace>\\<^bsub>c\\<^esub> =\n      \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> &&&\n      \\<lbrace>ta_update_obs ta obs\\<rbrace>\\<^bsub>i\\<^esub> =\n      \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> &&&\n      \\<lbrace>ta_update_obs ta obs\\<rbrace>\\<^bsub>o\\<^esub> =\n      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> @ [obs]) &&&\n     ((\\<lbrace>ta_update_locks ta x l\\<rbrace>\\<^bsub>l\\<^esub> =\n       (let ls = \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\n        in ls(l $:= ls $ l @ [x])) &&&\n       \\<lbrace>ta_update_locks ta x l\\<rbrace>\\<^bsub>t\\<^esub> =\n       \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> &&&\n       \\<lbrace>ta_update_locks ta x l\\<rbrace>\\<^bsub>w\\<^esub> =\n       \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>) &&&\n      \\<lbrace>ta_update_locks ta x l\\<rbrace>\\<^bsub>c\\<^esub> =\n      \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> &&&\n      \\<lbrace>ta_update_locks ta x l\\<rbrace>\\<^bsub>i\\<^esub> =\n      \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> &&&\n      \\<lbrace>ta_update_locks ta x l\\<rbrace>\\<^bsub>o\\<^esub> =\n      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) &&&\n     (\\<lbrace>ta_update_NewThread ta t\\<rbrace>\\<^bsub>l\\<^esub> =\n      \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> &&&\n      \\<lbrace>ta_update_NewThread ta t\\<rbrace>\\<^bsub>t\\<^esub> =\n      \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> @ [t] &&&\n      \\<lbrace>ta_update_NewThread ta t\\<rbrace>\\<^bsub>w\\<^esub> =\n      \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>) &&&\n     \\<lbrace>ta_update_NewThread ta t\\<rbrace>\\<^bsub>c\\<^esub> =\n     \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> &&&\n     \\<lbrace>ta_update_NewThread ta t\\<rbrace>\\<^bsub>i\\<^esub> =\n     \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> &&&\n     \\<lbrace>ta_update_NewThread ta t\\<rbrace>\\<^bsub>o\\<^esub> =\n     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) &&&\n    ((\\<lbrace>ta_update_wait_set ta w\\<rbrace>\\<^bsub>l\\<^esub> =\n      \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> &&&\n      \\<lbrace>ta_update_wait_set ta w\\<rbrace>\\<^bsub>t\\<^esub> =\n      \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> &&&\n      \\<lbrace>ta_update_wait_set ta w\\<rbrace>\\<^bsub>w\\<^esub> =\n      \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> @ [w]) &&&\n     \\<lbrace>ta_update_wait_set ta w\\<rbrace>\\<^bsub>c\\<^esub> =\n     \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> &&&\n     \\<lbrace>ta_update_wait_set ta w\\<rbrace>\\<^bsub>i\\<^esub> =\n     \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> &&&\n     \\<lbrace>ta_update_wait_set ta w\\<rbrace>\\<^bsub>o\\<^esub> =\n     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) &&&\n    ((\\<lbrace>ta_update_Conditional ta c\\<rbrace>\\<^bsub>l\\<^esub> =\n      \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> &&&\n      \\<lbrace>ta_update_Conditional ta c\\<rbrace>\\<^bsub>t\\<^esub> =\n      \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> &&&\n      \\<lbrace>ta_update_Conditional ta c\\<rbrace>\\<^bsub>w\\<^esub> =\n      \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>) &&&\n     \\<lbrace>ta_update_Conditional ta c\\<rbrace>\\<^bsub>c\\<^esub> =\n     \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> @ [c] &&&\n     \\<lbrace>ta_update_Conditional ta c\\<rbrace>\\<^bsub>i\\<^esub> =\n     \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> &&&\n     \\<lbrace>ta_update_Conditional ta c\\<rbrace>\\<^bsub>o\\<^esub> =\n     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) &&&\n    (\\<lbrace>ta_update_interrupt ta i\\<rbrace>\\<^bsub>l\\<^esub> =\n     \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> &&&\n     \\<lbrace>ta_update_interrupt ta i\\<rbrace>\\<^bsub>t\\<^esub> =\n     \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> &&&\n     \\<lbrace>ta_update_interrupt ta i\\<rbrace>\\<^bsub>c\\<^esub> =\n     \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>) &&&\n    \\<lbrace>ta_update_interrupt ta i\\<rbrace>\\<^bsub>w\\<^esub> =\n    \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> &&&\n    \\<lbrace>ta_update_interrupt ta i\\<rbrace>\\<^bsub>i\\<^esub> =\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> @ [i] &&&\n    \\<lbrace>ta_update_interrupt ta i\\<rbrace>\\<^bsub>o\\<^esub> =\n    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>", "by(cases ta, simp)+"], ["", "lemma thread_action'_to_thread_action_proj_simps [simp]:\n  shows thread_action'_to_thread_action_proj_locks_simps:\n  \"\\<lbrace>thread_action'_to_thread_action (LockAction (la, l)) ta\\<rbrace>\\<^bsub>l\\<^esub> = \\<lbrace>ta_update_locks ta la l\\<rbrace>\\<^bsub>l\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (NewThreadAction nt) ta\\<rbrace>\\<^bsub>l\\<^esub> = \\<lbrace>ta_update_NewThread ta nt\\<rbrace>\\<^bsub>l\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (ConditionalAction ca) ta\\<rbrace>\\<^bsub>l\\<^esub> = \\<lbrace>ta_update_Conditional ta ca\\<rbrace>\\<^bsub>l\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (WaitSetAction wa) ta\\<rbrace>\\<^bsub>l\\<^esub> = \\<lbrace>ta_update_wait_set ta wa\\<rbrace>\\<^bsub>l\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (InterruptAction ia) ta\\<rbrace>\\<^bsub>l\\<^esub> = \\<lbrace>ta_update_interrupt ta ia\\<rbrace>\\<^bsub>l\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (ObsAction ob) ta\\<rbrace>\\<^bsub>l\\<^esub> = \\<lbrace>ta_update_obs ta ob\\<rbrace>\\<^bsub>l\\<^esub>\"\n  and thread_action'_to_thread_action_proj_nt_simps:\n  \"\\<lbrace>thread_action'_to_thread_action (LockAction (la, l)) ta\\<rbrace>\\<^bsub>t\\<^esub> = \\<lbrace>ta_update_locks ta la l\\<rbrace>\\<^bsub>t\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (NewThreadAction nt) ta\\<rbrace>\\<^bsub>t\\<^esub> = \\<lbrace>ta_update_NewThread ta nt\\<rbrace>\\<^bsub>t\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (ConditionalAction ca) ta\\<rbrace>\\<^bsub>t\\<^esub> = \\<lbrace>ta_update_Conditional ta ca\\<rbrace>\\<^bsub>t\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (WaitSetAction wa) ta\\<rbrace>\\<^bsub>t\\<^esub> = \\<lbrace>ta_update_wait_set ta wa\\<rbrace>\\<^bsub>t\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (InterruptAction ia) ta\\<rbrace>\\<^bsub>t\\<^esub> = \\<lbrace>ta_update_interrupt ta ia\\<rbrace>\\<^bsub>t\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (ObsAction ob) ta\\<rbrace>\\<^bsub>t\\<^esub> = \\<lbrace>ta_update_obs ta ob\\<rbrace>\\<^bsub>t\\<^esub>\"\n  and thread_action'_to_thread_action_proj_cond_simps:\n  \"\\<lbrace>thread_action'_to_thread_action (LockAction (la, l)) ta\\<rbrace>\\<^bsub>c\\<^esub> = \\<lbrace>ta_update_locks ta la l\\<rbrace>\\<^bsub>c\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (NewThreadAction nt) ta\\<rbrace>\\<^bsub>c\\<^esub> = \\<lbrace>ta_update_NewThread ta nt\\<rbrace>\\<^bsub>c\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (ConditionalAction ca) ta\\<rbrace>\\<^bsub>c\\<^esub> = \\<lbrace>ta_update_Conditional ta ca\\<rbrace>\\<^bsub>c\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (WaitSetAction wa) ta\\<rbrace>\\<^bsub>c\\<^esub> = \\<lbrace>ta_update_wait_set ta wa\\<rbrace>\\<^bsub>c\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (InterruptAction ia) ta\\<rbrace>\\<^bsub>c\\<^esub> = \\<lbrace>ta_update_interrupt ta ia\\<rbrace>\\<^bsub>c\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (ObsAction ob) ta\\<rbrace>\\<^bsub>c\\<^esub> = \\<lbrace>ta_update_obs ta ob\\<rbrace>\\<^bsub>c\\<^esub>\"\n  and thread_action'_to_thread_action_proj_wset_simps:\n  \"\\<lbrace>thread_action'_to_thread_action (LockAction (la, l)) ta\\<rbrace>\\<^bsub>w\\<^esub> = \\<lbrace>ta_update_locks ta la l\\<rbrace>\\<^bsub>w\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (NewThreadAction nt) ta\\<rbrace>\\<^bsub>w\\<^esub> = \\<lbrace>ta_update_NewThread ta nt\\<rbrace>\\<^bsub>w\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (ConditionalAction ca) ta\\<rbrace>\\<^bsub>w\\<^esub> = \\<lbrace>ta_update_Conditional ta ca\\<rbrace>\\<^bsub>w\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (WaitSetAction wa) ta\\<rbrace>\\<^bsub>w\\<^esub> = \\<lbrace>ta_update_wait_set ta wa\\<rbrace>\\<^bsub>w\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (InterruptAction ia) ta\\<rbrace>\\<^bsub>w\\<^esub> = \\<lbrace>ta_update_interrupt ta ia\\<rbrace>\\<^bsub>w\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (ObsAction ob) ta\\<rbrace>\\<^bsub>w\\<^esub> = \\<lbrace>ta_update_obs ta ob\\<rbrace>\\<^bsub>w\\<^esub>\"\n  and thread_action'_to_thread_action_proj_interrupt_simps:\n  \"\\<lbrace>thread_action'_to_thread_action (LockAction (la, l)) ta\\<rbrace>\\<^bsub>i\\<^esub> = \\<lbrace>ta_update_locks ta la l\\<rbrace>\\<^bsub>i\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (NewThreadAction nt) ta\\<rbrace>\\<^bsub>i\\<^esub> = \\<lbrace>ta_update_NewThread ta nt\\<rbrace>\\<^bsub>i\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (ConditionalAction ca) ta\\<rbrace>\\<^bsub>i\\<^esub> = \\<lbrace>ta_update_Conditional ta ca\\<rbrace>\\<^bsub>i\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (WaitSetAction wa) ta\\<rbrace>\\<^bsub>i\\<^esub> = \\<lbrace>ta_update_wait_set ta wa\\<rbrace>\\<^bsub>i\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (InterruptAction ia) ta\\<rbrace>\\<^bsub>i\\<^esub> = \\<lbrace>ta_update_interrupt ta ia\\<rbrace>\\<^bsub>i\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (ObsAction ob) ta\\<rbrace>\\<^bsub>i\\<^esub> = \\<lbrace>ta_update_obs ta ob\\<rbrace>\\<^bsub>i\\<^esub>\"\n  and thread_action'_to_thread_action_proj_obs_simps:\n  \"\\<lbrace>thread_action'_to_thread_action (LockAction (la, l)) ta\\<rbrace>\\<^bsub>o\\<^esub> = \\<lbrace>ta_update_locks ta la l\\<rbrace>\\<^bsub>o\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (NewThreadAction nt) ta\\<rbrace>\\<^bsub>o\\<^esub> = \\<lbrace>ta_update_NewThread ta nt\\<rbrace>\\<^bsub>o\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (ConditionalAction ca) ta\\<rbrace>\\<^bsub>o\\<^esub> = \\<lbrace>ta_update_Conditional ta ca\\<rbrace>\\<^bsub>o\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (WaitSetAction wa) ta\\<rbrace>\\<^bsub>o\\<^esub> = \\<lbrace>ta_update_wait_set ta wa\\<rbrace>\\<^bsub>o\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (InterruptAction ia) ta\\<rbrace>\\<^bsub>o\\<^esub> = \\<lbrace>ta_update_interrupt ta ia\\<rbrace>\\<^bsub>o\\<^esub>\"\n  \"\\<lbrace>thread_action'_to_thread_action (ObsAction ob) ta\\<rbrace>\\<^bsub>o\\<^esub> = \\<lbrace>ta_update_obs ta ob\\<rbrace>\\<^bsub>o\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((\\<lbrace>thread_action'_to_thread_action (la, l)\n                 ta\\<rbrace>\\<^bsub>l\\<^esub> =\n       \\<lbrace>ta_update_locks ta la l\\<rbrace>\\<^bsub>l\\<^esub> &&&\n       \\<lbrace>thread_action'_to_thread_action nt\n                 ta\\<rbrace>\\<^bsub>l\\<^esub> =\n       \\<lbrace>ta_update_NewThread ta nt\\<rbrace>\\<^bsub>l\\<^esub> &&&\n       \\<lbrace>thread_action'_to_thread_action ca\n                 ta\\<rbrace>\\<^bsub>l\\<^esub> =\n       \\<lbrace>ta_update_Conditional ta ca\\<rbrace>\\<^bsub>l\\<^esub>) &&&\n      \\<lbrace>thread_action'_to_thread_action wa\n                ta\\<rbrace>\\<^bsub>l\\<^esub> =\n      \\<lbrace>ta_update_wait_set ta wa\\<rbrace>\\<^bsub>l\\<^esub> &&&\n      \\<lbrace>thread_action'_to_thread_action ia\n                ta\\<rbrace>\\<^bsub>l\\<^esub> =\n      \\<lbrace>ta_update_interrupt ta ia\\<rbrace>\\<^bsub>l\\<^esub> &&&\n      \\<lbrace>thread_action'_to_thread_action ob\n                ta\\<rbrace>\\<^bsub>l\\<^esub> =\n      \\<lbrace>ta_update_obs ta ob\\<rbrace>\\<^bsub>l\\<^esub>) &&&\n     ((\\<lbrace>thread_action'_to_thread_action (la, l)\n                 ta\\<rbrace>\\<^bsub>t\\<^esub> =\n       \\<lbrace>ta_update_locks ta la l\\<rbrace>\\<^bsub>t\\<^esub> &&&\n       \\<lbrace>thread_action'_to_thread_action nt\n                 ta\\<rbrace>\\<^bsub>t\\<^esub> =\n       \\<lbrace>ta_update_NewThread ta nt\\<rbrace>\\<^bsub>t\\<^esub> &&&\n       \\<lbrace>thread_action'_to_thread_action ca\n                 ta\\<rbrace>\\<^bsub>t\\<^esub> =\n       \\<lbrace>ta_update_Conditional ta ca\\<rbrace>\\<^bsub>t\\<^esub>) &&&\n      \\<lbrace>thread_action'_to_thread_action wa\n                ta\\<rbrace>\\<^bsub>t\\<^esub> =\n      \\<lbrace>ta_update_wait_set ta wa\\<rbrace>\\<^bsub>t\\<^esub> &&&\n      \\<lbrace>thread_action'_to_thread_action ia\n                ta\\<rbrace>\\<^bsub>t\\<^esub> =\n      \\<lbrace>ta_update_interrupt ta ia\\<rbrace>\\<^bsub>t\\<^esub> &&&\n      \\<lbrace>thread_action'_to_thread_action ob\n                ta\\<rbrace>\\<^bsub>t\\<^esub> =\n      \\<lbrace>ta_update_obs ta ob\\<rbrace>\\<^bsub>t\\<^esub>) &&&\n     (\\<lbrace>thread_action'_to_thread_action (la, l)\n                ta\\<rbrace>\\<^bsub>c\\<^esub> =\n      \\<lbrace>ta_update_locks ta la l\\<rbrace>\\<^bsub>c\\<^esub> &&&\n      \\<lbrace>thread_action'_to_thread_action nt\n                ta\\<rbrace>\\<^bsub>c\\<^esub> =\n      \\<lbrace>ta_update_NewThread ta nt\\<rbrace>\\<^bsub>c\\<^esub> &&&\n      \\<lbrace>thread_action'_to_thread_action ca\n                ta\\<rbrace>\\<^bsub>c\\<^esub> =\n      \\<lbrace>ta_update_Conditional ta ca\\<rbrace>\\<^bsub>c\\<^esub>) &&&\n     \\<lbrace>thread_action'_to_thread_action wa\n               ta\\<rbrace>\\<^bsub>c\\<^esub> =\n     \\<lbrace>ta_update_wait_set ta wa\\<rbrace>\\<^bsub>c\\<^esub> &&&\n     \\<lbrace>thread_action'_to_thread_action ia\n               ta\\<rbrace>\\<^bsub>c\\<^esub> =\n     \\<lbrace>ta_update_interrupt ta ia\\<rbrace>\\<^bsub>c\\<^esub> &&&\n     \\<lbrace>thread_action'_to_thread_action ob\n               ta\\<rbrace>\\<^bsub>c\\<^esub> =\n     \\<lbrace>ta_update_obs ta ob\\<rbrace>\\<^bsub>c\\<^esub>) &&&\n    ((\\<lbrace>thread_action'_to_thread_action (la, l)\n                ta\\<rbrace>\\<^bsub>w\\<^esub> =\n      \\<lbrace>ta_update_locks ta la l\\<rbrace>\\<^bsub>w\\<^esub> &&&\n      \\<lbrace>thread_action'_to_thread_action nt\n                ta\\<rbrace>\\<^bsub>w\\<^esub> =\n      \\<lbrace>ta_update_NewThread ta nt\\<rbrace>\\<^bsub>w\\<^esub> &&&\n      \\<lbrace>thread_action'_to_thread_action ca\n                ta\\<rbrace>\\<^bsub>w\\<^esub> =\n      \\<lbrace>ta_update_Conditional ta ca\\<rbrace>\\<^bsub>w\\<^esub>) &&&\n     \\<lbrace>thread_action'_to_thread_action wa\n               ta\\<rbrace>\\<^bsub>w\\<^esub> =\n     \\<lbrace>ta_update_wait_set ta wa\\<rbrace>\\<^bsub>w\\<^esub> &&&\n     \\<lbrace>thread_action'_to_thread_action ia\n               ta\\<rbrace>\\<^bsub>w\\<^esub> =\n     \\<lbrace>ta_update_interrupt ta ia\\<rbrace>\\<^bsub>w\\<^esub> &&&\n     \\<lbrace>thread_action'_to_thread_action ob\n               ta\\<rbrace>\\<^bsub>w\\<^esub> =\n     \\<lbrace>ta_update_obs ta ob\\<rbrace>\\<^bsub>w\\<^esub>) &&&\n    ((\\<lbrace>thread_action'_to_thread_action (la, l)\n                ta\\<rbrace>\\<^bsub>i\\<^esub> =\n      \\<lbrace>ta_update_locks ta la l\\<rbrace>\\<^bsub>i\\<^esub> &&&\n      \\<lbrace>thread_action'_to_thread_action nt\n                ta\\<rbrace>\\<^bsub>i\\<^esub> =\n      \\<lbrace>ta_update_NewThread ta nt\\<rbrace>\\<^bsub>i\\<^esub> &&&\n      \\<lbrace>thread_action'_to_thread_action ca\n                ta\\<rbrace>\\<^bsub>i\\<^esub> =\n      \\<lbrace>ta_update_Conditional ta ca\\<rbrace>\\<^bsub>i\\<^esub>) &&&\n     \\<lbrace>thread_action'_to_thread_action wa\n               ta\\<rbrace>\\<^bsub>i\\<^esub> =\n     \\<lbrace>ta_update_wait_set ta wa\\<rbrace>\\<^bsub>i\\<^esub> &&&\n     \\<lbrace>thread_action'_to_thread_action ia\n               ta\\<rbrace>\\<^bsub>i\\<^esub> =\n     \\<lbrace>ta_update_interrupt ta ia\\<rbrace>\\<^bsub>i\\<^esub> &&&\n     \\<lbrace>thread_action'_to_thread_action ob\n               ta\\<rbrace>\\<^bsub>i\\<^esub> =\n     \\<lbrace>ta_update_obs ta ob\\<rbrace>\\<^bsub>i\\<^esub>) &&&\n    (\\<lbrace>thread_action'_to_thread_action (la, l)\n               ta\\<rbrace>\\<^bsub>o\\<^esub> =\n     \\<lbrace>ta_update_locks ta la l\\<rbrace>\\<^bsub>o\\<^esub> &&&\n     \\<lbrace>thread_action'_to_thread_action nt\n               ta\\<rbrace>\\<^bsub>o\\<^esub> =\n     \\<lbrace>ta_update_NewThread ta nt\\<rbrace>\\<^bsub>o\\<^esub> &&&\n     \\<lbrace>thread_action'_to_thread_action ca\n               ta\\<rbrace>\\<^bsub>o\\<^esub> =\n     \\<lbrace>ta_update_Conditional ta ca\\<rbrace>\\<^bsub>o\\<^esub>) &&&\n    \\<lbrace>thread_action'_to_thread_action wa\n              ta\\<rbrace>\\<^bsub>o\\<^esub> =\n    \\<lbrace>ta_update_wait_set ta wa\\<rbrace>\\<^bsub>o\\<^esub> &&&\n    \\<lbrace>thread_action'_to_thread_action ia\n              ta\\<rbrace>\\<^bsub>o\\<^esub> =\n    \\<lbrace>ta_update_interrupt ta ia\\<rbrace>\\<^bsub>o\\<^esub> &&&\n    \\<lbrace>thread_action'_to_thread_action ob\n              ta\\<rbrace>\\<^bsub>o\\<^esub> =\n    \\<lbrace>ta_update_obs ta ob\\<rbrace>\\<^bsub>o\\<^esub>", "by(simp_all)"], ["", "lemmas ta_upd_simps =\n  ta_update_locks.simps ta_update_NewThread.simps ta_update_Conditional.simps\n  ta_update_wait_set.simps ta_update_interrupt.simps ta_update_obs.simps\n  thread_action'_to_thread_action.simps"], ["", "declare ta_upd_simps [simp del]"], ["", "hide_const (open)\n  LockAction NewThreadAction ConditionalAction WaitSetAction InterruptAction ObsAction\n  thread_action'_to_thread_action"], ["", "hide_type (open) thread_action'"], ["", "datatype wake_up_status =\n  WSNotified\n| WSWokenUp"], ["", "datatype 'w wait_set_status =\n  InWS 'w\n| PostWS wake_up_status"], ["", "type_synonym 't lock = \"('t \\<times> nat) option\""], ["", "type_synonym ('l,'t) locks = \"'l \\<Rightarrow>f 't lock\""], ["", "type_synonym 'l released_locks = \"'l \\<Rightarrow>f nat\""], ["", "type_synonym ('l,'t,'x) thread_info = \"'t \\<rightharpoonup> ('x \\<times> 'l released_locks)\""], ["", "type_synonym ('w,'t) wait_sets = \"'t \\<rightharpoonup> 'w wait_set_status\""], ["", "type_synonym 't interrupts = \"'t set\""], ["", "type_synonym ('l,'t,'x,'m,'w) state = \"('l,'t) locks \\<times> (('l,'t,'x) thread_info \\<times> 'm) \\<times> ('w,'t) wait_sets \\<times> 't interrupts\""], ["", "translations\n  (type) \"('l, 't) locks\" <= (type) \"'l \\<Rightarrow>f ('t \\<times> nat) option\"\n  (type) \"('l, 't, 'x) thread_info\" <= (type) \"'t \\<rightharpoonup> ('x \\<times> ('l \\<Rightarrow>f nat))\""], ["", "(* pretty printing for state type *)"], ["", "print_translation \\<open>\n  let\n    fun tr'\n       [Const (@{type_syntax finfun}, _) $ l1 $\n        (Const (@{type_syntax option}, _) $\n          (Const (@{type_syntax \"prod\"}, _) $ t1 $ Const (@{type_syntax nat}, _))),\n        Const (@{type_syntax \"prod\"}, _) $\n          (Const (@{type_syntax \"prod\"}, _) $\n            (Const (@{type_syntax fun}, _) $ t2 $\n              (Const (@{type_syntax option}, _) $\n                (Const (@{type_syntax \"prod\"}, _) $ x $\n                  (Const (@{type_syntax finfun}, _) $ l2 $ Const (@{type_syntax nat}, _))))) $\n            m) $\n          (Const (@{type_syntax prod}, _) $\n            (Const (@{type_syntax fun}, _) $ t3 $ \n              (Const (@{type_syntax option}, _) $ (Const (@{type_syntax wait_set_status}, _) $ w))) $\n            (Const (@{type_syntax fun}, _) $ t4 $ (Const (@{type_syntax bool}, _))))] =\n      if t1 = t2 andalso t1 = t3 andalso t1 = t4 andalso l1 = l2\n      then Syntax.const @{type_syntax state} $ l1 $ t1 $ x $ m $ w\n      else raise Match;\n  in [(@{type_syntax \"prod\"}, K tr')]\n  end\n\\<close>"], ["", "typ \"('l,'t,'x,'m,'w) state\""], ["", "abbreviation no_wait_locks :: \"'l \\<Rightarrow>f nat\"\nwhere \"no_wait_locks \\<equiv> (K$ 0)\""], ["", "lemma neq_no_wait_locks_conv:\n  \"\\<And>ln. ln \\<noteq> no_wait_locks \\<longleftrightarrow> (\\<exists>l. ln $ l > 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln. (ln \\<noteq> no_wait_locks) = (\\<exists>l. 0 < ln $ l)", "by(auto simp add: expand_finfun_eq fun_eq_iff)"], ["", "lemma neq_no_wait_locksE:\n  fixes ln assumes \"ln \\<noteq> no_wait_locks\" obtains l where \"ln $ l > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l. 0 < ln $ l \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  ln \\<noteq> no_wait_locks\n\ngoal (1 subgoal):\n 1. (\\<And>l. 0 < ln $ l \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by(auto simp add: neq_no_wait_locks_conv)"], ["", "text \\<open>\n  Use type variables for components instead of @{typ \"('l,'t,'x,'m,'w) state\"} in types for state projections\n  to allow to reuse them for refined state implementations for code generation.\n\\<close>"], ["", "definition locks :: \"('locks \\<times> ('thread_info \\<times> 'm) \\<times> 'wsets \\<times> 'interrupts) \\<Rightarrow> 'locks\" where\n  \"locks lstsmws \\<equiv> fst lstsmws\""], ["", "definition thr :: \"('locks \\<times> ('thread_info \\<times> 'm) \\<times> 'wsets \\<times> 'interrupts) \\<Rightarrow> 'thread_info\" where\n  \"thr lstsmws \\<equiv> fst (fst (snd lstsmws))\""], ["", "definition shr :: \"('locks \\<times> ('thread_info \\<times> 'm) \\<times> 'wsets \\<times> 'interrupts) \\<Rightarrow> 'm\" where\n  \"shr lstsmws \\<equiv> snd (fst (snd lstsmws))\""], ["", "definition wset :: \"('locks \\<times> ('thread_info \\<times> 'm) \\<times> 'wsets \\<times> 'interrupts) \\<Rightarrow> 'wsets\" where\n  \"wset lstsmws \\<equiv> fst (snd (snd lstsmws))\""], ["", "definition interrupts :: \"('locks \\<times> ('thread_info \\<times> 'm) \\<times> 'wsets \\<times> 'interrupts) \\<Rightarrow> 'interrupts\" where\n  \"interrupts lstsmws \\<equiv> snd (snd (snd lstsmws))\""], ["", "lemma locks_conv [simp]: \"locks (ls, tsmws) = ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. locks (ls, tsmws) = ls", "by(simp add: locks_def)"], ["", "lemma thr_conv [simp]: \"thr (ls, (ts, m), ws) = ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thr (ls, (ts, m), ws) = ts", "by(simp add: thr_def)"], ["", "lemma shr_conv [simp]: \"shr (ls, (ts, m), ws, is) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shr (ls, (ts, m), ws, is) = m", "by(simp add: shr_def)"], ["", "lemma wset_conv [simp]: \"wset (ls, (ts, m), ws, is) = ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wset (ls, (ts, m), ws, is) = ws", "by(simp add: wset_def)"], ["", "lemma interrupts_conv [simp]: \"interrupts (ls, (ts, m), ws, is) = is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interrupts (ls, (ts, m), ws, is) = is", "by(simp add: interrupts_def)"], ["", "primrec convert_new_thread_action :: \"('x \\<Rightarrow> 'x') \\<Rightarrow> ('t,'x,'m) new_thread_action \\<Rightarrow> ('t,'x','m) new_thread_action\"\nwhere\n  \"convert_new_thread_action f (NewThread t x m) = NewThread t (f x) m\"\n| \"convert_new_thread_action f (ThreadExists t b) = ThreadExists t b\""], ["", "lemma convert_new_thread_action_inv [simp]:\n  \"NewThread t x h = convert_new_thread_action f nta \\<longleftrightarrow> (\\<exists>x'. nta = NewThread t x' h \\<and> x = f x')\"\n  \"ThreadExists t b = convert_new_thread_action f nta \\<longleftrightarrow> nta = ThreadExists t b\"\n  \"convert_new_thread_action f nta = NewThread t x h \\<longleftrightarrow> (\\<exists>x'. nta = NewThread t x' h \\<and> x = f x')\"\n  \"convert_new_thread_action f nta = ThreadExists t b \\<longleftrightarrow> nta = ThreadExists t b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((NewThread t x h = convert_new_thread_action f nta) =\n     (\\<exists>x'. nta = NewThread t x' h \\<and> x = f x') &&&\n     (ThreadExists t b = convert_new_thread_action f nta) =\n     (nta = ThreadExists t b)) &&&\n    (convert_new_thread_action f nta = NewThread t x h) =\n    (\\<exists>x'. nta = NewThread t x' h \\<and> x = f x') &&&\n    (convert_new_thread_action f nta = ThreadExists t b) =\n    (nta = ThreadExists t b)", "by(cases nta, auto)+"], ["", "lemma convert_new_thread_action_eqI: \n  \"\\<lbrakk> \\<And>t x m. nta = NewThread t x m \\<Longrightarrow> nta' = NewThread t (f x) m;\n     \\<And>t b. nta = ThreadExists t b \\<Longrightarrow> nta' = ThreadExists t b \\<rbrakk>\n  \\<Longrightarrow> convert_new_thread_action f nta = nta'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t x m.\n                nta = NewThread t x m \\<Longrightarrow>\n                nta' = NewThread t (f x) m;\n     \\<And>t b.\n        nta = ThreadExists t b \\<Longrightarrow>\n        nta' = ThreadExists t b\\<rbrakk>\n    \\<Longrightarrow> convert_new_thread_action f nta = nta'", "apply(cases nta)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>\\<And>t x m.\n                   nta = NewThread t x m \\<Longrightarrow>\n                   nta' = NewThread t (f x) m;\n        \\<And>t b.\n           nta = ThreadExists t b \\<Longrightarrow> nta' = ThreadExists t b;\n        nta = NewThread x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> convert_new_thread_action f nta = nta'\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>t x m.\n                   nta = NewThread t x m \\<Longrightarrow>\n                   nta' = NewThread t (f x) m;\n        \\<And>t b.\n           nta = ThreadExists t b \\<Longrightarrow> nta' = ThreadExists t b;\n        nta = ThreadExists x21 x22\\<rbrakk>\n       \\<Longrightarrow> convert_new_thread_action f nta = nta'", "apply fastforce+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma convert_new_thread_action_compose [simp]:\n  \"convert_new_thread_action f (convert_new_thread_action g ta) = convert_new_thread_action (f o g) ta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convert_new_thread_action f (convert_new_thread_action g ta) =\n    convert_new_thread_action (f \\<circ> g) ta", "apply(cases ta)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13.\n       ta = NewThread x11 x12 x13 \\<Longrightarrow>\n       convert_new_thread_action f (convert_new_thread_action g ta) =\n       convert_new_thread_action (f \\<circ> g) ta\n 2. \\<And>x21 x22.\n       ta = ThreadExists x21 x22 \\<Longrightarrow>\n       convert_new_thread_action f (convert_new_thread_action g ta) =\n       convert_new_thread_action (f \\<circ> g) ta", "apply(simp_all add: convert_new_thread_action_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inj_convert_new_thread_action [simp]: \n  \"inj (convert_new_thread_action f) = inj f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (convert_new_thread_action f) = inj f", "apply(rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. inj (convert_new_thread_action f) \\<Longrightarrow> inj f\n 2. inj f \\<Longrightarrow> inj (convert_new_thread_action f)", "apply(rule injI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>inj (convert_new_thread_action f); f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. inj f \\<Longrightarrow> inj (convert_new_thread_action f)", "apply(drule_tac x=\"NewThread undefined x undefined\" in injD)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       f x = f y \\<Longrightarrow>\n       convert_new_thread_action f (NewThread undefined x undefined) =\n       convert_new_thread_action f (?y5 x y)\n 2. \\<And>x y.\n       \\<lbrakk>f x = f y;\n        NewThread undefined x undefined = ?y5 x y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 3. inj f \\<Longrightarrow> inj (convert_new_thread_action f)", "apply auto[2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj f \\<Longrightarrow> inj (convert_new_thread_action f)", "apply(rule injI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>inj f;\n        convert_new_thread_action f x =\n        convert_new_thread_action f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply(case_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y x11 x12 x13.\n       \\<lbrakk>inj f;\n        convert_new_thread_action f x = convert_new_thread_action f y;\n        x = NewThread x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y x21 x22.\n       \\<lbrakk>inj f;\n        convert_new_thread_action f x = convert_new_thread_action f y;\n        x = ThreadExists x21 x22\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply(auto dest: injD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma convert_new_thread_action_id:\n  \"convert_new_thread_action id = (id :: ('t, 'x, 'm) new_thread_action \\<Rightarrow> ('t, 'x, 'm) new_thread_action)\" (is ?thesis1)\n  \"convert_new_thread_action (\\<lambda>x. x) = (id :: ('t, 'x, 'm) new_thread_action \\<Rightarrow> ('t, 'x, 'm) new_thread_action)\" (is ?thesis2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. convert_new_thread_action id = id &&&\n    convert_new_thread_action (\\<lambda>x. x) = id", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. convert_new_thread_action id = id\n 2. convert_new_thread_action (\\<lambda>x. x) = id", "show ?thesis1"], ["proof (prove)\ngoal (1 subgoal):\n 1. convert_new_thread_action id = id", "by(rule ext)(case_tac x, simp_all)"], ["proof (state)\nthis:\n  convert_new_thread_action id = id\n\ngoal (1 subgoal):\n 1. convert_new_thread_action (\\<lambda>x. x) = id", "thus ?thesis2"], ["proof (prove)\nusing this:\n  convert_new_thread_action id = id\n\ngoal (1 subgoal):\n 1. convert_new_thread_action (\\<lambda>x. x) = id", "by(simp add: id_def)"], ["proof (state)\nthis:\n  convert_new_thread_action (\\<lambda>x. x) = id\n\ngoal:\nNo subgoals!", "qed"], ["", "definition convert_extTA :: \"('x \\<Rightarrow> 'x') \\<Rightarrow> ('l,'t,'x,'m,'w,'o) thread_action \\<Rightarrow> ('l,'t,'x','m,'w,'o) thread_action\"\nwhere \"convert_extTA f ta = (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>, map (convert_new_thread_action f) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>, snd (snd ta))\""], ["", "lemma convert_extTA_simps [simp]:\n  \"convert_extTA f \\<epsilon> = \\<epsilon>\"\n  \"\\<lbrace>convert_extTA f ta\\<rbrace>\\<^bsub>l\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\"\n  \"\\<lbrace>convert_extTA f ta\\<rbrace>\\<^bsub>t\\<^esub> = map (convert_new_thread_action f) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\"\n  \"\\<lbrace>convert_extTA f ta\\<rbrace>\\<^bsub>c\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>\"\n  \"\\<lbrace>convert_extTA f ta\\<rbrace>\\<^bsub>w\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\"\n  \"\\<lbrace>convert_extTA f ta\\<rbrace>\\<^bsub>i\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\"\n  \"convert_extTA f (las, tas, was, cas, is, obs) = (las, map (convert_new_thread_action f) tas, was, cas, is, obs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (convert_extTA f \\<lbrace>\\<rbrace> = \\<lbrace>\\<rbrace> &&&\n     \\<lbrace>convert_extTA f ta\\<rbrace>\\<^bsub>l\\<^esub> =\n     \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> &&&\n     \\<lbrace>convert_extTA f ta\\<rbrace>\\<^bsub>t\\<^esub> =\n     map (convert_new_thread_action f)\n      \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) &&&\n    (\\<lbrace>convert_extTA f ta\\<rbrace>\\<^bsub>c\\<^esub> =\n     \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> &&&\n     \\<lbrace>convert_extTA f ta\\<rbrace>\\<^bsub>w\\<^esub> =\n     \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>) &&&\n    \\<lbrace>convert_extTA f ta\\<rbrace>\\<^bsub>i\\<^esub> =\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> &&&\n    convert_extTA f (las, tas, was, cas, is, obs) =\n    (las, map (convert_new_thread_action f) tas, was, cas, is, obs)", "apply(simp_all add: convert_extTA_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrace>(\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>,\n              map (convert_new_thread_action f)\n               \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>,\n              snd (snd ta))\\<rbrace>\\<^bsub>c\\<^esub> =\n    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>\n 2. \\<lbrace>(\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>,\n              map (convert_new_thread_action f)\n               \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>,\n              snd (snd ta))\\<rbrace>\\<^bsub>w\\<^esub> =\n    \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\n 3. \\<lbrace>(\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>,\n              map (convert_new_thread_action f)\n               \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>,\n              snd (snd ta))\\<rbrace>\\<^bsub>i\\<^esub> =\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "apply(cases ta, simp)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma convert_extTA_eq_conv:\n  \"convert_extTA f ta = ta' \\<longleftrightarrow>\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and> \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> = \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and> \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> = \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> \\<and> \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub> \\<and> \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> = \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub> \\<and> length \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> = length \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> \\<and> \n   (\\<forall>n < length \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>. convert_new_thread_action f (\\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> ! n) = \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> ! n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (convert_extTA f ta = ta') =\n    (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n     \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n     \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n     \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> =\n     \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> =\n     \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n     \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n     \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n     length \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> =\n     length \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n     (\\<forall>n<length \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>.\n         convert_new_thread_action f\n          (\\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> ! n) =\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> ! n))", "apply(cases ta, cases ta')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d e fa aa ba ca da ea faa.\n       \\<lbrakk>ta = (a, b, c, d, e, fa);\n        ta' = (aa, ba, ca, da, ea, faa)\\<rbrakk>\n       \\<Longrightarrow> (convert_extTA f ta = ta') =\n                         (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> =\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> =\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                          length \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> =\n                          length\n                           \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n                          (\\<forall>n<length\n \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>.\n                              convert_new_thread_action f\n                               (\\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> ! n) =\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> ! n))", "apply(auto simp add: convert_extTA_def map_eq_all_nth_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma convert_extTA_compose [simp]:\n  \"convert_extTA f (convert_extTA g ta) = convert_extTA (f o g) ta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convert_extTA f (convert_extTA g ta) = convert_extTA (f \\<circ> g) ta", "by(simp add: convert_extTA_def)"], ["", "lemma obs_a_convert_extTA [simp]: \"obs_a (convert_extTA f ta) = obs_a ta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>convert_extTA f ta\\<rbrace>\\<^bsub>o\\<^esub> =\n    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>", "by(cases ta) simp"], ["", "text \\<open>Actions for thread start/finish\\<close>"], ["", "datatype 'o action =\n    NormalAction 'o\n  | InitialThreadAction\n  | ThreadFinishAction"], ["", "instance action :: (type) obs_action"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a action, obs_action_class)", "proof"], ["proof (state)\ngoal:\nNo subgoals!", "qed"], ["", "definition convert_obs_initial :: \"('l,'t,'x,'m,'w,'o) thread_action \\<Rightarrow> ('l,'t,'x,'m,'w,'o action) thread_action\"\nwhere \n  \"convert_obs_initial ta = (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>, \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>, \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>, \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>, \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>, map NormalAction \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\""], ["", "lemma inj_NormalAction [simp]: \"inj NormalAction\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj NormalAction", "by(rule injI) auto"], ["", "lemma convert_obs_initial_inject [simp]:\n  \"convert_obs_initial ta = convert_obs_initial ta' \\<longleftrightarrow> ta = ta'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (convert_obs_initial ta = convert_obs_initial ta') = (ta = ta')", "by(cases ta)(cases ta', auto simp add: convert_obs_initial_def)"], ["", "lemma convert_obs_initial_empty_TA [simp]:\n  \"convert_obs_initial \\<epsilon> = \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convert_obs_initial \\<lbrace>\\<rbrace> = \\<lbrace>\\<rbrace>", "by(simp add: convert_obs_initial_def)"], ["", "lemma convert_obs_initial_eq_empty_TA [simp]:\n  \"convert_obs_initial ta = \\<epsilon> \\<longleftrightarrow> ta = \\<epsilon>\"\n  \"\\<epsilon> = convert_obs_initial ta \\<longleftrightarrow> ta = \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (convert_obs_initial ta = \\<lbrace>\\<rbrace>) =\n    (ta = \\<lbrace>\\<rbrace>) &&&\n    (\\<lbrace>\\<rbrace> = convert_obs_initial ta) =\n    (ta = \\<lbrace>\\<rbrace>)", "by(case_tac [!] ta)(auto simp add: convert_obs_initial_def)"], ["", "lemma convert_obs_initial_simps [simp]:\n  \"\\<lbrace>convert_obs_initial ta\\<rbrace>\\<^bsub>o\\<^esub> = map NormalAction \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\"\n  \"\\<lbrace>convert_obs_initial ta\\<rbrace>\\<^bsub>l\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\"\n  \"\\<lbrace>convert_obs_initial ta\\<rbrace>\\<^bsub>t\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\"\n  \"\\<lbrace>convert_obs_initial ta\\<rbrace>\\<^bsub>c\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>\"\n  \"\\<lbrace>convert_obs_initial ta\\<rbrace>\\<^bsub>w\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\"\n  \"\\<lbrace>convert_obs_initial ta\\<rbrace>\\<^bsub>i\\<^esub> = \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrace>convert_obs_initial ta\\<rbrace>\\<^bsub>o\\<^esub> =\n     map NormalAction \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> &&&\n     \\<lbrace>convert_obs_initial ta\\<rbrace>\\<^bsub>l\\<^esub> =\n     \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> &&&\n     \\<lbrace>convert_obs_initial ta\\<rbrace>\\<^bsub>t\\<^esub> =\n     \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>) &&&\n    \\<lbrace>convert_obs_initial ta\\<rbrace>\\<^bsub>c\\<^esub> =\n    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> &&&\n    \\<lbrace>convert_obs_initial ta\\<rbrace>\\<^bsub>w\\<^esub> =\n    \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> &&&\n    \\<lbrace>convert_obs_initial ta\\<rbrace>\\<^bsub>i\\<^esub> =\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "by(simp_all add: convert_obs_initial_def)"], ["", "type_synonym\n  ('l,'t,'x,'m,'w,'o) semantics =\n    \"'t \\<Rightarrow> 'x \\<times> 'm \\<Rightarrow> ('l,'t,'x,'m,'w,'o) thread_action \\<Rightarrow> 'x \\<times> 'm \\<Rightarrow> bool\""], ["", "(* pretty printing for semantics *)"], ["", "print_translation \\<open>\n  let\n    fun tr'\n       [t4,\n        Const (@{type_syntax fun}, _) $\n          (Const (@{type_syntax \"prod\"}, _) $ x1 $ m1) $\n          (Const (@{type_syntax fun}, _) $\n            (Const (@{type_syntax \"prod\"}, _) $\n              (Const (@{type_syntax finfun}, _) $ l $\n                (Const (@{type_syntax list}, _) $ Const (@{type_syntax lock_action}, _))) $\n              (Const (@{type_syntax \"prod\"}, _) $\n                (Const (@{type_syntax list}, _) $ (Const (@{type_syntax new_thread_action}, _) $ t1 $ x2 $ m2)) $\n                (Const (@{type_syntax \"prod\"}, _) $\n                  (Const (@{type_syntax list}, _) $ (Const (@{type_syntax conditional_action}, _) $ t2)) $\n                  (Const (@{type_syntax \"prod\"}, _) $\n                    (Const (@{type_syntax list}, _) $ (Const (@{type_syntax wait_set_action}, _) $ t3 $ w)) $ \n                    (Const (@{type_syntax prod}, _) $\n                       (Const (@{type_syntax list}, _) $ (Const (@{type_syntax interrupt_action}, _) $ t5)) $\n                       (Const (@{type_syntax list}, _) $ o1)))))) $\n            (Const (@{type_syntax fun}, _) $ (Const (@{type_syntax \"prod\"}, _) $ x3 $ m3) $\n              Const (@{type_syntax bool}, _)))] =\n      if x1 = x2 andalso x1 = x3 andalso m1 = m2 andalso m1 = m3 \n        andalso t1 = t2 andalso t2 = t3 andalso t3 = t4 andalso t4 = t5\n      then Syntax.const @{type_syntax semantics} $ l $ t1 $ x1 $ m1 $ w $ o1\n      else raise Match;\n  in [(@{type_syntax fun}, K tr')]\n  end\n\\<close>"], ["", "typ \"('l,'t,'x,'m,'w,'o) semantics\""], ["", "end"]]}