{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Common/ExternalCallWF.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma external_WT_defs_is_type:\n  assumes \"wf_prog wf_md P\" and \"C\\<bullet>M(Ts) :: T\"\n  shows \"is_class P C\" and \"is_type P T\" \"set Ts \\<subseteq> types P\"", "lemma WT_red_external_aggr_imp_red_external:\n  \"\\<lbrakk> wf_prog wf_md P; (ta, va, h') \\<in> red_external_aggr P t a M vs h; P,h \\<turnstile> a\\<bullet>M(vs) : U; P,h \\<turnstile> t \\<surd>t \\<rbrakk>\n  \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>\"", "lemma WT_red_external_list_conv:\n  \"\\<lbrakk> wf_prog wf_md P; P,h \\<turnstile> a\\<bullet>M(vs) : U; P,h \\<turnstile> t \\<surd>t \\<rbrakk>\n  \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle> \\<longleftrightarrow> (ta, va, h') \\<in> red_external_aggr P t a M vs h\"", "lemma red_external_new_thread_sees:\n  \"\\<lbrakk> wf_prog wf_md P; P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>; NewThread t' (C, M', a') h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> typeof_addr h' a' = \\<lfloor>Class_type C\\<rfloor> \\<and> (\\<exists>T meth D. P \\<turnstile> C sees M':[]\\<rightarrow>T = \\<lfloor>meth\\<rfloor> in D)\"", "lemma hconf_heap_copy_loc_mono:\n  assumes \"heap_copy_loc a a' al h obs h'\"\n  and \"hconf h\"\n  and \"P,h \\<turnstile> a@al : T\" \"P,h \\<turnstile> a'@al : T\"\n  shows \"hconf h'\"", "lemma hconf_heap_copies_mono:\n  assumes \"heap_copies a a' als h obs h'\"\n  and \"hconf h\"\n  and \"list_all2 (\\<lambda>al T. P,h \\<turnstile> a@al : T) als Ts\"\n  and \"list_all2 (\\<lambda>al T. P,h \\<turnstile> a'@al : T) als Ts\"\n  shows \"hconf h'\"", "lemma hconf_heap_clone_mono:\n  assumes \"heap_clone P h a h' res\"\n  and \"hconf h\"\n  shows \"hconf h'\"", "theorem external_call_hconf:\n  assumes major: \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>\"\n  and minor: \"P,h \\<turnstile> a\\<bullet>M(vs) : U\" \"hconf h\"\n  shows \"hconf h'\"", "lemma red_external_conf_extRet:\n  assumes wf: \"wf_prog wf_md P\"\n  shows \"\\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>; P,h \\<turnstile> a\\<bullet>M(vs) : U; hconf h; preallocated h; P,h \\<turnstile> t \\<surd>t \\<rbrakk>\n  \\<Longrightarrow> conf_extRet P h' va U\"", "lemma heap_copy_loc_progress:\n  assumes hconf: \"hconf h\"\n  and alconfa: \"P,h \\<turnstile> a@al : T\"\n  and alconfa': \"P,h \\<turnstile> a'@al : T\"\n  shows \"\\<exists>v h'. heap_copy_loc a a' al h ([ReadMem a al v, WriteMem a' al v]) h' \\<and> P,h \\<turnstile> v :\\<le> T \\<and> hconf h'\"", "lemma heap_copies_progress:\n  assumes \"hconf h\"\n  and \"list_all2 (\\<lambda>al T. P,h \\<turnstile> a@al : T) als Ts\"\n  and \"list_all2 (\\<lambda>al T. P,h \\<turnstile> a'@al : T) als Ts\"\n  shows \"\\<exists>vs h'. heap_copies a a' als h (concat (map (\\<lambda>(al, v). [ReadMem a al v, WriteMem a' al v]) (zip als vs))) h' \\<and> hconf h'\"", "lemma heap_clone_progress:\n  assumes wf: \"wf_prog wf_md P\"\n  and typea: \"typeof_addr h a = \\<lfloor>hT\\<rfloor>\"\n  and hconf: \"hconf h\"\n  shows \"\\<exists>h' res. heap_clone P h a h' res\"", "theorem external_call_progress:\n  assumes wf: \"wf_prog wf_md P\"\n  and wt: \"P,h \\<turnstile> a\\<bullet>M(vs) : U\"\n  and hconf: \"hconf h\"\n  shows \"\\<exists>ta va h'. P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>\"", "lemma red_external_wt_hconf_hext:\n  assumes wf: \"wf_prog wf_md P\"\n  and red: \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\"\n  and hext: \"h'' \\<unlhd> h\"\n  and wt: \"P,h'' \\<turnstile> a\\<bullet>M(vs) : U\"\n  and tconf: \"P,h'' \\<turnstile> t \\<surd>t\"\n  and hconf: \"hconf h''\"\n  shows \"\\<exists>ta' va' h'''. P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va', h'''\\<rangle> \\<and>\n                        collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                        collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> = collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                        collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> = collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\"", "lemma red_external_wf_red:\n  assumes wf: \"wf_prog wf_md P\"\n  and red: \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>\"\n  and tconf: \"P,h \\<turnstile> t \\<surd>t\"\n  and hconf: \"hconf h\"\n  and wst: \"wset s t = None \\<or> (M = wait \\<and> (\\<exists>w. wset s t = \\<lfloor>PostWS w\\<rfloor>))\"\n  obtains ta' va' h''\n  where \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va', h''\\<rangle>\"\n  and \"final_thread.actions_ok final s t ta' \\<or> final_thread.actions_ok' s t ta' \\<and> final_thread.actions_subset ta' ta\"", "lemma red_external_ta_satisfiable:\n  fixes final\n  assumes \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>\"\n  shows \"\\<exists>s. final_thread.actions_ok final s t ta\"", "lemma red_external_aggr_ta_satisfiable:\n  fixes final\n  assumes \"(ta, va, h') \\<in> red_external_aggr P t a M vs h\"\n  shows \"\\<exists>s. final_thread.actions_ok final s t ta\"", "lemma heap_copy_loc_deterministic:\n  assumes det: \"deterministic_heap_ops\"\n  and copy: \"heap_copy_loc a a' al h ops h'\" \"heap_copy_loc a a' al h ops' h''\"\n  shows \"ops = ops' \\<and> h' = h''\"", "lemma heap_copies_deterministic:\n  assumes det: \"deterministic_heap_ops\"\n  and copy: \"heap_copies a a' als h ops h'\" \"heap_copies a a' als h ops' h''\"\n  shows \"ops = ops' \\<and> h' = h''\"", "lemma heap_clone_deterministic:\n  assumes det: \"deterministic_heap_ops\"\n  and clone: \"heap_clone P h a h' obs\" \"heap_clone P h a h'' obs'\"\n  shows \"h' = h'' \\<and> obs = obs'\"", "lemma red_external_deterministic:\n  fixes final\n  assumes det: \"deterministic_heap_ops\"\n  and red: \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), (shr s)\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>\" \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), (shr s)\\<rangle> -ta'\\<rightarrow>ext \\<langle>va', h''\\<rangle>\"\n  and aok: \"final_thread.actions_ok final s t ta\" \"final_thread.actions_ok final s t ta'\"\n  shows \"ta = ta' \\<and> va = va' \\<and> h' = h''\""], "translations": [["", "lemma external_WT_defs_is_type:\n  assumes \"wf_prog wf_md P\" and \"C\\<bullet>M(Ts) :: T\"\n  shows \"is_class P C\" and \"is_type P T\" \"set Ts \\<subseteq> types P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_class P C &&& is_type P T &&& set Ts \\<subseteq> types P", "using assms"], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  C\\<bullet>M(Ts) :: T\n\ngoal (1 subgoal):\n 1. is_class P C &&& is_type P T &&& set Ts \\<subseteq> types P", "by(auto elim: external_WT_defs.cases)"], ["", "context heap_base begin"], ["", "lemma WT_red_external_aggr_imp_red_external:\n  \"\\<lbrakk> wf_prog wf_md P; (ta, va, h') \\<in> red_external_aggr P t a M vs h; P,h \\<turnstile> a\\<bullet>M(vs) : U; P,h \\<turnstile> t \\<surd>t \\<rbrakk>\n  \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P;\n     (ta, va, h') \\<in> red_external_aggr P t a M vs h;\n     P,h \\<turnstile> a\\<bullet>M(vs) : U;\n     P,h \\<turnstile> t \\<surd>t\\<rbrakk>\n    \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>", "apply(drule tconfD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P;\n     (ta, va, h') \\<in> red_external_aggr P t a M vs h;\n     P,h \\<turnstile> a\\<bullet>M(vs) : U;\n     \\<exists>C.\n        typeof_addr h (thread_id2addr t) =\n        \\<lfloor>Class_type C\\<rfloor> \\<and>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n    \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>", "apply(erule external_WT'.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>hT Ts Ts' D.\n       \\<lbrakk>wf_prog wf_md P;\n        (ta, va, h') \\<in> red_external_aggr P t a M vs h;\n        \\<exists>C.\n           typeof_addr h (thread_id2addr t) =\n           \\<lfloor>Class_type C\\<rfloor> \\<and>\n           P \\<turnstile> C \\<preceq>\\<^sup>* Thread;\n        typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n        P \\<turnstile> class_type_of\n                        hT sees M: Ts'\\<rightarrow>U = Native in D;\n        P \\<turnstile> Ts [\\<le>] Ts'\\<rbrakk>\n       \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>hT Ts Ts' D C.\n       \\<lbrakk>wf_prog wf_md P;\n        (ta, va, h') \\<in> red_external_aggr P t a M vs h;\n        typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n        P \\<turnstile> class_type_of\n                        hT sees M: Ts'\\<rightarrow>U = Native in D;\n        P \\<turnstile> Ts [\\<le>] Ts';\n        typeof_addr h (thread_id2addr t) = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>", "apply(drule (1) sees_wf_native)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>hT Ts Ts' D C.\n       \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n        typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n        P \\<turnstile> class_type_of\n                        hT sees M: Ts'\\<rightarrow>U = Native in D;\n        P \\<turnstile> Ts [\\<le>] Ts';\n        typeof_addr h (thread_id2addr t) = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread;\n        D\\<bullet>M(Ts') :: U\\<rbrakk>\n       \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>", "apply(erule external_WT_defs.cases)"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>hT Ts Ts' D C.\n       \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n        typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n        P \\<turnstile> class_type_of\n                        hT sees M: Ts'\\<rightarrow>U = Native in D;\n        P \\<turnstile> Ts [\\<le>] Ts';\n        typeof_addr h (thread_id2addr t) = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread; D = Thread; M = start;\n        Ts' = []; U = Void\\<rbrakk>\n       \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 2. \\<And>hT Ts Ts' D C.\n       \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n        typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n        P \\<turnstile> class_type_of\n                        hT sees M: Ts'\\<rightarrow>U = Native in D;\n        P \\<turnstile> Ts [\\<le>] Ts';\n        typeof_addr h (thread_id2addr t) = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread; D = Thread; M = join;\n        Ts' = []; U = Void\\<rbrakk>\n       \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 3. \\<And>hT Ts Ts' D C.\n       \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n        typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n        P \\<turnstile> class_type_of\n                        hT sees M: Ts'\\<rightarrow>U = Native in D;\n        P \\<turnstile> Ts [\\<le>] Ts';\n        typeof_addr h (thread_id2addr t) = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread; D = Thread;\n        M = interrupt; Ts' = []; U = Void\\<rbrakk>\n       \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 4. \\<And>hT Ts Ts' D C.\n       \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n        typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n        P \\<turnstile> class_type_of\n                        hT sees M: Ts'\\<rightarrow>U = Native in D;\n        P \\<turnstile> Ts [\\<le>] Ts';\n        typeof_addr h (thread_id2addr t) = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread; D = Thread;\n        M = isInterrupted; Ts' = []; U = Boolean\\<rbrakk>\n       \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 5. \\<And>hT Ts Ts' D C.\n       \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n        typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n        P \\<turnstile> class_type_of\n                        hT sees M: Ts'\\<rightarrow>U = Native in D;\n        P \\<turnstile> Ts [\\<le>] Ts';\n        typeof_addr h (thread_id2addr t) = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread; D = Object; M = wait;\n        Ts' = []; U = Void\\<rbrakk>\n       \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 6. \\<And>hT Ts Ts' D C.\n       \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n        typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n        P \\<turnstile> class_type_of\n                        hT sees M: Ts'\\<rightarrow>U = Native in D;\n        P \\<turnstile> Ts [\\<le>] Ts';\n        typeof_addr h (thread_id2addr t) = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread; D = Object; M = notify;\n        Ts' = []; U = Void\\<rbrakk>\n       \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 7. \\<And>hT Ts Ts' D C.\n       \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n        typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n        P \\<turnstile> class_type_of\n                        hT sees M: Ts'\\<rightarrow>U = Native in D;\n        P \\<turnstile> Ts [\\<le>] Ts';\n        typeof_addr h (thread_id2addr t) = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread; D = Object;\n        M = notifyAll; Ts' = []; U = Void\\<rbrakk>\n       \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 8. \\<And>hT Ts Ts' D C.\n       \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n        typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n        P \\<turnstile> class_type_of\n                        hT sees M: Ts'\\<rightarrow>U = Native in D;\n        P \\<turnstile> Ts [\\<le>] Ts';\n        typeof_addr h (thread_id2addr t) = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread; D = Object; M = clone;\n        Ts' = []; U = Class Object\\<rbrakk>\n       \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 9. \\<And>hT Ts Ts' D C.\n       \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n        typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n        P \\<turnstile> class_type_of\n                        hT sees M: Ts'\\<rightarrow>U = Native in D;\n        P \\<turnstile> Ts [\\<le>] Ts';\n        typeof_addr h (thread_id2addr t) = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread; D = Object; M = hashcode;\n        Ts' = []; U = Integer\\<rbrakk>\n       \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 10. \\<And>hT Ts Ts' D C.\n        \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n         typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n         map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n         P \\<turnstile> class_type_of\n                         hT sees M: Ts'\\<rightarrow>U = Native in D;\n         P \\<turnstile> Ts [\\<le>] Ts';\n         typeof_addr h (thread_id2addr t) = \\<lfloor>Class_type C\\<rfloor>;\n         P \\<turnstile> C \\<preceq>\\<^sup>* Thread; D = Object; M = print;\n         Ts' = [Integer]; U = Void\\<rbrakk>\n        \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\nA total of 13 subgoals...", "apply(case_tac [!] hT)"], ["proof (prove)\ngoal (26 subgoals):\n 1. \\<And>hT Ts Ts' D C x1.\n       \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n        typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n        P \\<turnstile> class_type_of\n                        hT sees M: Ts'\\<rightarrow>U = Native in D;\n        P \\<turnstile> Ts [\\<le>] Ts';\n        typeof_addr h (thread_id2addr t) = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread; D = Thread; M = start;\n        Ts' = []; U = Void; hT = Class_type x1\\<rbrakk>\n       \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 2. \\<And>hT Ts Ts' D C x21 x22.\n       \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n        typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n        P \\<turnstile> class_type_of\n                        hT sees M: Ts'\\<rightarrow>U = Native in D;\n        P \\<turnstile> Ts [\\<le>] Ts';\n        typeof_addr h (thread_id2addr t) = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread; D = Thread; M = start;\n        Ts' = []; U = Void; hT = Array_type x21 x22\\<rbrakk>\n       \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 3. \\<And>hT Ts Ts' D C x1.\n       \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n        typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n        P \\<turnstile> class_type_of\n                        hT sees M: Ts'\\<rightarrow>U = Native in D;\n        P \\<turnstile> Ts [\\<le>] Ts';\n        typeof_addr h (thread_id2addr t) = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread; D = Thread; M = join;\n        Ts' = []; U = Void; hT = Class_type x1\\<rbrakk>\n       \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 4. \\<And>hT Ts Ts' D C x21 x22.\n       \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n        typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n        P \\<turnstile> class_type_of\n                        hT sees M: Ts'\\<rightarrow>U = Native in D;\n        P \\<turnstile> Ts [\\<le>] Ts';\n        typeof_addr h (thread_id2addr t) = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread; D = Thread; M = join;\n        Ts' = []; U = Void; hT = Array_type x21 x22\\<rbrakk>\n       \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 5. \\<And>hT Ts Ts' D C x1.\n       \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n        typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n        P \\<turnstile> class_type_of\n                        hT sees M: Ts'\\<rightarrow>U = Native in D;\n        P \\<turnstile> Ts [\\<le>] Ts';\n        typeof_addr h (thread_id2addr t) = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread; D = Thread;\n        M = interrupt; Ts' = []; U = Void; hT = Class_type x1\\<rbrakk>\n       \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 6. \\<And>hT Ts Ts' D C x21 x22.\n       \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n        typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n        P \\<turnstile> class_type_of\n                        hT sees M: Ts'\\<rightarrow>U = Native in D;\n        P \\<turnstile> Ts [\\<le>] Ts';\n        typeof_addr h (thread_id2addr t) = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread; D = Thread;\n        M = interrupt; Ts' = []; U = Void; hT = Array_type x21 x22\\<rbrakk>\n       \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 7. \\<And>hT Ts Ts' D C x1.\n       \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n        typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n        P \\<turnstile> class_type_of\n                        hT sees M: Ts'\\<rightarrow>U = Native in D;\n        P \\<turnstile> Ts [\\<le>] Ts';\n        typeof_addr h (thread_id2addr t) = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread; D = Thread;\n        M = isInterrupted; Ts' = []; U = Boolean;\n        hT = Class_type x1\\<rbrakk>\n       \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 8. \\<And>hT Ts Ts' D C x21 x22.\n       \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n        typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n        P \\<turnstile> class_type_of\n                        hT sees M: Ts'\\<rightarrow>U = Native in D;\n        P \\<turnstile> Ts [\\<le>] Ts';\n        typeof_addr h (thread_id2addr t) = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread; D = Thread;\n        M = isInterrupted; Ts' = []; U = Boolean;\n        hT = Array_type x21 x22\\<rbrakk>\n       \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 9. \\<And>hT Ts Ts' D C x1.\n       \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n        typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n        P \\<turnstile> class_type_of\n                        hT sees M: Ts'\\<rightarrow>U = Native in D;\n        P \\<turnstile> Ts [\\<le>] Ts';\n        typeof_addr h (thread_id2addr t) = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread; D = Object; M = wait;\n        Ts' = []; U = Void; hT = Class_type x1\\<rbrakk>\n       \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 10. \\<And>hT Ts Ts' D C x21 x22.\n        \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n         typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n         map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n         P \\<turnstile> class_type_of\n                         hT sees M: Ts'\\<rightarrow>U = Native in D;\n         P \\<turnstile> Ts [\\<le>] Ts';\n         typeof_addr h (thread_id2addr t) = \\<lfloor>Class_type C\\<rfloor>;\n         P \\<turnstile> C \\<preceq>\\<^sup>* Thread; D = Object; M = wait;\n         Ts' = []; U = Void; hT = Array_type x21 x22\\<rbrakk>\n        \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\nA total of 26 subgoals...", "apply(auto 4 4 simp add: red_external_aggr_def widen_Class intro: red_external.intros heap_base.red_external.intros[where addr2thread_id=addr2thread_id and thread_id2addr=thread_id2addr and spurious_wakeups=True and empty_heap=empty_heap and allocate=allocate and typeof_addr=typeof_addr and heap_read=heap_read and heap_write=heap_write] heap_base.red_external.intros[where addr2thread_id=addr2thread_id and thread_id2addr=thread_id2addr and spurious_wakeups=False and empty_heap=empty_heap and allocate=allocate and typeof_addr=typeof_addr and heap_read=heap_read and heap_write=heap_write] split: if_split_asm dest: sees_method_decl_above)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WT_red_external_list_conv:\n  \"\\<lbrakk> wf_prog wf_md P; P,h \\<turnstile> a\\<bullet>M(vs) : U; P,h \\<turnstile> t \\<surd>t \\<rbrakk>\n  \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle> \\<longleftrightarrow> (ta, va, h') \\<in> red_external_aggr P t a M vs h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; P,h \\<turnstile> a\\<bullet>M(vs) : U;\n     P,h \\<turnstile> t \\<surd>t\\<rbrakk>\n    \\<Longrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle> =\n                      ((ta, va, h') \\<in> red_external_aggr P t a M vs h)", "by(blast intro: WT_red_external_aggr_imp_red_external red_external_imp_red_external_aggr)"], ["", "lemma red_external_new_thread_sees:\n  \"\\<lbrakk> wf_prog wf_md P; P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>; NewThread t' (C, M', a') h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> typeof_addr h' a' = \\<lfloor>Class_type C\\<rfloor> \\<and> (\\<exists>T meth D. P \\<turnstile> C sees M':[]\\<rightarrow>T = \\<lfloor>meth\\<rfloor> in D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P;\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n               h'\\<rangle>;\n     NewThread t' (C, M', a') h''\n     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> typeof_addr h' a' =\n                      \\<lfloor>Class_type C\\<rfloor> \\<and>\n                      (\\<exists>T meth D.\n                          P \\<turnstile> C sees M': []\\<rightarrow>T = \\<lfloor>meth\\<rfloor> in D)", "by(fastforce elim!: red_external.cases simp add: widen_Class ta_upd_simps dest: sub_Thread_sees_run)"], ["", "end"], ["", "subsection \\<open>Preservation of heap conformance\\<close>"], ["", "context heap_conf_read begin"], ["", "lemma hconf_heap_copy_loc_mono:\n  assumes \"heap_copy_loc a a' al h obs h'\"\n  and \"hconf h\"\n  and \"P,h \\<turnstile> a@al : T\" \"P,h \\<turnstile> a'@al : T\"\n  shows \"hconf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hconf h'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hconf h'", "from \\<open>heap_copy_loc a a' al h obs h'\\<close>"], ["proof (chain)\npicking this:\n  heap_copy_loc a a' al h obs h'", "obtain v\n    where read: \"heap_read h a al v\"\n    and \"write\": \"heap_write h a' al v h'\""], ["proof (prove)\nusing this:\n  heap_copy_loc a a' al h obs h'\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>heap_read h a al v; heap_write h a' al v h'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  heap_read h a al v\n  heap_write h a' al v h'\n\ngoal (1 subgoal):\n 1. hconf h'", "from read \\<open>P,h \\<turnstile> a@al : T\\<close> \\<open>hconf h\\<close>"], ["proof (chain)\npicking this:\n  heap_read h a al v\n  P,h \\<turnstile> a@al : T\n  hconf h", "have \"P,h \\<turnstile> v :\\<le> T\""], ["proof (prove)\nusing this:\n  heap_read h a al v\n  P,h \\<turnstile> a@al : T\n  hconf h\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> v :\\<le> T", "by(rule heap_read_conf)"], ["proof (state)\nthis:\n  P,h \\<turnstile> v :\\<le> T\n\ngoal (1 subgoal):\n 1. hconf h'", "with \"write\" \\<open>hconf h\\<close> \\<open>P,h \\<turnstile> a'@al : T\\<close>"], ["proof (chain)\npicking this:\n  heap_write h a' al v h'\n  hconf h\n  P,h \\<turnstile> a'@al : T\n  P,h \\<turnstile> v :\\<le> T", "show ?thesis"], ["proof (prove)\nusing this:\n  heap_write h a' al v h'\n  hconf h\n  P,h \\<turnstile> a'@al : T\n  P,h \\<turnstile> v :\\<le> T\n\ngoal (1 subgoal):\n 1. hconf h'", "by(rule hconf_heap_write_mono)"], ["proof (state)\nthis:\n  hconf h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hconf_heap_copies_mono:\n  assumes \"heap_copies a a' als h obs h'\"\n  and \"hconf h\"\n  and \"list_all2 (\\<lambda>al T. P,h \\<turnstile> a@al : T) als Ts\"\n  and \"list_all2 (\\<lambda>al T. P,h \\<turnstile> a'@al : T) als Ts\"\n  shows \"hconf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hconf h'", "using assms"], ["proof (prove)\nusing this:\n  heap_copies a a' als h obs h'\n  hconf h\n  list_all2 (addr_loc_type P h a) als Ts\n  list_all2 (addr_loc_type P h a') als Ts\n\ngoal (1 subgoal):\n 1. hconf h'", "proof(induct arbitrary: Ts)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h Ts.\n       \\<lbrakk>hconf h; list_all2 (addr_loc_type P h a) [] Ts;\n        list_all2 (addr_loc_type P h a') [] Ts\\<rbrakk>\n       \\<Longrightarrow> hconf h\n 2. \\<And>al h ob h' als obs h'' Ts.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts.\n           \\<lbrakk>hconf h'; list_all2 (addr_loc_type P h' a) als Ts;\n            list_all2 (addr_loc_type P h' a') als Ts\\<rbrakk>\n           \\<Longrightarrow> hconf h'';\n        hconf h; list_all2 (addr_loc_type P h a) (al # als) Ts;\n        list_all2 (addr_loc_type P h a') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> hconf h''", "case Nil"], ["proof (state)\nthis:\n  hconf h_\n  list_all2 (addr_loc_type P h_ a) [] Ts\n  list_all2 (addr_loc_type P h_ a') [] Ts\n\ngoal (2 subgoals):\n 1. \\<And>h Ts.\n       \\<lbrakk>hconf h; list_all2 (addr_loc_type P h a) [] Ts;\n        list_all2 (addr_loc_type P h a') [] Ts\\<rbrakk>\n       \\<Longrightarrow> hconf h\n 2. \\<And>al h ob h' als obs h'' Ts.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts.\n           \\<lbrakk>hconf h'; list_all2 (addr_loc_type P h' a) als Ts;\n            list_all2 (addr_loc_type P h' a') als Ts\\<rbrakk>\n           \\<Longrightarrow> hconf h'';\n        hconf h; list_all2 (addr_loc_type P h a) (al # als) Ts;\n        list_all2 (addr_loc_type P h a') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> hconf h''", "thus ?case"], ["proof (prove)\nusing this:\n  hconf h_\n  list_all2 (addr_loc_type P h_ a) [] Ts\n  list_all2 (addr_loc_type P h_ a') [] Ts\n\ngoal (1 subgoal):\n 1. hconf h_", "by simp"], ["proof (state)\nthis:\n  hconf h_\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts.\n           \\<lbrakk>hconf h'; list_all2 (addr_loc_type P h' a) als Ts;\n            list_all2 (addr_loc_type P h' a') als Ts\\<rbrakk>\n           \\<Longrightarrow> hconf h'';\n        hconf h; list_all2 (addr_loc_type P h a) (al # als) Ts;\n        list_all2 (addr_loc_type P h a') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> hconf h''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts.\n           \\<lbrakk>hconf h'; list_all2 (addr_loc_type P h' a) als Ts;\n            list_all2 (addr_loc_type P h' a') als Ts\\<rbrakk>\n           \\<Longrightarrow> hconf h'';\n        hconf h; list_all2 (addr_loc_type P h a) (al # als) Ts;\n        list_all2 (addr_loc_type P h a') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> hconf h''", "case (Cons al h ob h' als obs h'')"], ["proof (state)\nthis:\n  heap_copy_loc a a' al h ob h'\n  heap_copies a a' als h' obs h''\n  \\<lbrakk>hconf h'; list_all2 (addr_loc_type P h' a) als ?Ts14;\n   list_all2 (addr_loc_type P h' a') als ?Ts14\\<rbrakk>\n  \\<Longrightarrow> hconf h''\n  hconf h\n  list_all2 (addr_loc_type P h a) (al # als) Ts\n  list_all2 (addr_loc_type P h a') (al # als) Ts\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts.\n           \\<lbrakk>hconf h'; list_all2 (addr_loc_type P h' a) als Ts;\n            list_all2 (addr_loc_type P h' a') als Ts\\<rbrakk>\n           \\<Longrightarrow> hconf h'';\n        hconf h; list_all2 (addr_loc_type P h a) (al # als) Ts;\n        list_all2 (addr_loc_type P h a') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> hconf h''", "note step = \\<open>heap_copy_loc a a' al h ob h'\\<close>"], ["proof (state)\nthis:\n  heap_copy_loc a a' al h ob h'\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts.\n           \\<lbrakk>hconf h'; list_all2 (addr_loc_type P h' a) als Ts;\n            list_all2 (addr_loc_type P h' a') als Ts\\<rbrakk>\n           \\<Longrightarrow> hconf h'';\n        hconf h; list_all2 (addr_loc_type P h a) (al # als) Ts;\n        list_all2 (addr_loc_type P h a') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> hconf h''", "from \\<open>list_all2 (\\<lambda>al T. P,h \\<turnstile> a@al : T) (al # als) Ts\\<close>"], ["proof (chain)\npicking this:\n  list_all2 (addr_loc_type P h a) (al # als) Ts", "obtain T Ts' where [simp]: \"Ts = T # Ts'\"\n    and \"P,h \\<turnstile> a@al : T\" \"list_all2 (\\<lambda>al T. P,h \\<turnstile> a@al : T) als Ts'\""], ["proof (prove)\nusing this:\n  list_all2 (addr_loc_type P h a) (al # als) Ts\n\ngoal (1 subgoal):\n 1. (\\<And>T Ts'.\n        \\<lbrakk>Ts = T # Ts'; P,h \\<turnstile> a@al : T;\n         list_all2 (addr_loc_type P h a) als Ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: list_all2_Cons1)"], ["proof (state)\nthis:\n  Ts = T # Ts'\n  P,h \\<turnstile> a@al : T\n  list_all2 (addr_loc_type P h a) als Ts'\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts.\n           \\<lbrakk>hconf h'; list_all2 (addr_loc_type P h' a) als Ts;\n            list_all2 (addr_loc_type P h' a') als Ts\\<rbrakk>\n           \\<Longrightarrow> hconf h'';\n        hconf h; list_all2 (addr_loc_type P h a) (al # als) Ts;\n        list_all2 (addr_loc_type P h a') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> hconf h''", "from \\<open>list_all2 (\\<lambda>al T. P,h \\<turnstile> a'@al : T) (al # als) Ts\\<close>"], ["proof (chain)\npicking this:\n  list_all2 (addr_loc_type P h a') (al # als) Ts", "have \"P,h \\<turnstile> a'@al : T\" \"list_all2 (\\<lambda>al T. P,h \\<turnstile> a'@al : T) als Ts'\""], ["proof (prove)\nusing this:\n  list_all2 (addr_loc_type P h a') (al # als) Ts\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> a'@al : T &&& list_all2 (addr_loc_type P h a') als Ts'", "by simp_all"], ["proof (state)\nthis:\n  P,h \\<turnstile> a'@al : T\n  list_all2 (addr_loc_type P h a') als Ts'\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts.\n           \\<lbrakk>hconf h'; list_all2 (addr_loc_type P h' a) als Ts;\n            list_all2 (addr_loc_type P h' a') als Ts\\<rbrakk>\n           \\<Longrightarrow> hconf h'';\n        hconf h; list_all2 (addr_loc_type P h a) (al # als) Ts;\n        list_all2 (addr_loc_type P h a') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> hconf h''", "from step \\<open>hconf h\\<close> \\<open>P,h \\<turnstile> a@al : T\\<close> \\<open>P,h \\<turnstile> a'@al : T\\<close>"], ["proof (chain)\npicking this:\n  heap_copy_loc a a' al h ob h'\n  hconf h\n  P,h \\<turnstile> a@al : T\n  P,h \\<turnstile> a'@al : T", "have \"hconf h'\""], ["proof (prove)\nusing this:\n  heap_copy_loc a a' al h ob h'\n  hconf h\n  P,h \\<turnstile> a@al : T\n  P,h \\<turnstile> a'@al : T\n\ngoal (1 subgoal):\n 1. hconf h'", "by(rule hconf_heap_copy_loc_mono)"], ["proof (state)\nthis:\n  hconf h'\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts.\n           \\<lbrakk>hconf h'; list_all2 (addr_loc_type P h' a) als Ts;\n            list_all2 (addr_loc_type P h' a') als Ts\\<rbrakk>\n           \\<Longrightarrow> hconf h'';\n        hconf h; list_all2 (addr_loc_type P h a) (al # als) Ts;\n        list_all2 (addr_loc_type P h a') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> hconf h''", "moreover"], ["proof (state)\nthis:\n  hconf h'\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts.\n           \\<lbrakk>hconf h'; list_all2 (addr_loc_type P h' a) als Ts;\n            list_all2 (addr_loc_type P h' a') als Ts\\<rbrakk>\n           \\<Longrightarrow> hconf h'';\n        hconf h; list_all2 (addr_loc_type P h a) (al # als) Ts;\n        list_all2 (addr_loc_type P h a') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> hconf h''", "from step"], ["proof (chain)\npicking this:\n  heap_copy_loc a a' al h ob h'", "have \"h \\<unlhd> h'\""], ["proof (prove)\nusing this:\n  heap_copy_loc a a' al h ob h'\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "by(rule hext_heap_copy_loc)"], ["proof (state)\nthis:\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts.\n           \\<lbrakk>hconf h'; list_all2 (addr_loc_type P h' a) als Ts;\n            list_all2 (addr_loc_type P h' a') als Ts\\<rbrakk>\n           \\<Longrightarrow> hconf h'';\n        hconf h; list_all2 (addr_loc_type P h a) (al # als) Ts;\n        list_all2 (addr_loc_type P h a') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> hconf h''", "from \\<open>list_all2 (\\<lambda>al T. P,h \\<turnstile> a@al : T) als Ts'\\<close>"], ["proof (chain)\npicking this:\n  list_all2 (addr_loc_type P h a) als Ts'", "have \"list_all2 (\\<lambda>al T. P,h' \\<turnstile> a@al : T) als Ts'\""], ["proof (prove)\nusing this:\n  list_all2 (addr_loc_type P h a) als Ts'\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h' a) als Ts'", "by(rule list_all2_mono)(rule addr_loc_type_hext_mono[OF _ \\<open>h \\<unlhd> h'\\<close>])"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h' a) als Ts'\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts.\n           \\<lbrakk>hconf h'; list_all2 (addr_loc_type P h' a) als Ts;\n            list_all2 (addr_loc_type P h' a') als Ts\\<rbrakk>\n           \\<Longrightarrow> hconf h'';\n        hconf h; list_all2 (addr_loc_type P h a) (al # als) Ts;\n        list_all2 (addr_loc_type P h a') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> hconf h''", "moreover"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h' a) als Ts'\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts.\n           \\<lbrakk>hconf h'; list_all2 (addr_loc_type P h' a) als Ts;\n            list_all2 (addr_loc_type P h' a') als Ts\\<rbrakk>\n           \\<Longrightarrow> hconf h'';\n        hconf h; list_all2 (addr_loc_type P h a) (al # als) Ts;\n        list_all2 (addr_loc_type P h a') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> hconf h''", "from \\<open>list_all2 (\\<lambda>al T. P,h \\<turnstile> a'@al : T) als Ts'\\<close>"], ["proof (chain)\npicking this:\n  list_all2 (addr_loc_type P h a') als Ts'", "have \"list_all2 (\\<lambda>al T. P,h' \\<turnstile> a'@al : T) als Ts'\""], ["proof (prove)\nusing this:\n  list_all2 (addr_loc_type P h a') als Ts'\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h' a') als Ts'", "by(rule list_all2_mono)(rule addr_loc_type_hext_mono[OF _ \\<open>h \\<unlhd> h'\\<close>])"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h' a') als Ts'\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts.\n           \\<lbrakk>hconf h'; list_all2 (addr_loc_type P h' a) als Ts;\n            list_all2 (addr_loc_type P h' a') als Ts\\<rbrakk>\n           \\<Longrightarrow> hconf h'';\n        hconf h; list_all2 (addr_loc_type P h a) (al # als) Ts;\n        list_all2 (addr_loc_type P h a') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> hconf h''", "ultimately"], ["proof (chain)\npicking this:\n  hconf h'\n  list_all2 (addr_loc_type P h' a) als Ts'\n  list_all2 (addr_loc_type P h' a') als Ts'", "show ?case"], ["proof (prove)\nusing this:\n  hconf h'\n  list_all2 (addr_loc_type P h' a) als Ts'\n  list_all2 (addr_loc_type P h' a') als Ts'\n\ngoal (1 subgoal):\n 1. hconf h''", "by(rule Cons)"], ["proof (state)\nthis:\n  hconf h''\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hconf_heap_clone_mono:\n  assumes \"heap_clone P h a h' res\"\n  and \"hconf h\"\n  shows \"hconf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hconf h'", "using \\<open>heap_clone P h a h' res\\<close>"], ["proof (prove)\nusing this:\n  heap_clone P h a h' res\n\ngoal (1 subgoal):\n 1. hconf h'", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>hT.\n       \\<lbrakk>h' = h; res = None; typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        allocate h hT = {}\\<rbrakk>\n       \\<Longrightarrow> hconf h'\n 2. \\<And>C h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Class_type C) # obs, a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'\n 3. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "case CloneFail"], ["proof (state)\nthis:\n  h' = h\n  res = None\n  typeof_addr h a = \\<lfloor>hT_\\<rfloor>\n  allocate h hT_ = {}\n\ngoal (3 subgoals):\n 1. \\<And>hT.\n       \\<lbrakk>h' = h; res = None; typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        allocate h hT = {}\\<rbrakk>\n       \\<Longrightarrow> hconf h'\n 2. \\<And>C h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Class_type C) # obs, a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'\n 3. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "thus ?thesis"], ["proof (prove)\nusing this:\n  h' = h\n  res = None\n  typeof_addr h a = \\<lfloor>hT_\\<rfloor>\n  allocate h hT_ = {}\n\ngoal (1 subgoal):\n 1. hconf h'", "using \\<open>hconf h\\<close>"], ["proof (prove)\nusing this:\n  h' = h\n  res = None\n  typeof_addr h a = \\<lfloor>hT_\\<rfloor>\n  allocate h hT_ = {}\n  hconf h\n\ngoal (1 subgoal):\n 1. hconf h'", "by(fastforce intro: hconf_heap_ops_mono dest: typeof_addr_is_type)"], ["proof (state)\nthis:\n  hconf h'\n\ngoal (2 subgoals):\n 1. \\<And>C h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Class_type C) # obs, a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'\n 2. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Class_type C) # obs, a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'\n 2. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "case (ObjClone C h'' a' FDTs obs)"], ["proof (state)\nthis:\n  res = \\<lfloor>(NewHeapElem a' (Class_type C) # obs, a')\\<rfloor>\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  (h'', a') \\<in> allocate h (Class_type C)\n  P \\<turnstile> C has_fields FDTs\n  heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'' obs\n   h'\n\ngoal (2 subgoals):\n 1. \\<And>C h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Class_type C) # obs, a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'\n 2. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "note FDTs = \\<open>P \\<turnstile> C has_fields FDTs\\<close>"], ["proof (state)\nthis:\n  P \\<turnstile> C has_fields FDTs\n\ngoal (2 subgoals):\n 1. \\<And>C h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Class_type C) # obs, a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'\n 2. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "let ?als = \"map (\\<lambda>((F, D), Tfm). CField D F) FDTs\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Class_type C) # obs, a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'\n 2. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "let ?Ts = \"map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Class_type C) # obs, a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'\n 2. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "note \\<open>heap_copies a a' ?als h'' obs h'\\<close>"], ["proof (state)\nthis:\n  heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'' obs\n   h'\n\ngoal (2 subgoals):\n 1. \\<And>C h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Class_type C) # obs, a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'\n 2. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "moreover"], ["proof (state)\nthis:\n  heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'' obs\n   h'\n\ngoal (2 subgoals):\n 1. \\<And>C h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Class_type C) # obs, a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'\n 2. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "from \\<open>typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\\<close> \\<open>hconf h\\<close>"], ["proof (chain)\npicking this:\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  hconf h", "have \"is_class P C\""], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  hconf h\n\ngoal (1 subgoal):\n 1. is_class P C", "by(auto dest: typeof_addr_is_type)"], ["proof (state)\nthis:\n  is_class P C\n\ngoal (2 subgoals):\n 1. \\<And>C h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Class_type C) # obs, a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'\n 2. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "from \\<open>(h'', a') \\<in> allocate h (Class_type C)\\<close>"], ["proof (chain)\npicking this:\n  (h'', a') \\<in> allocate h (Class_type C)", "have \"h \\<unlhd> h''\" \"hconf h''\""], ["proof (prove)\nusing this:\n  (h'', a') \\<in> allocate h (Class_type C)\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'' &&& hconf h''", "by(rule hext_heap_ops hconf_allocate_mono)+(simp_all add: \\<open>hconf h\\<close> \\<open>is_class P C\\<close>)"], ["proof (state)\nthis:\n  h \\<unlhd> h''\n  hconf h''\n\ngoal (2 subgoals):\n 1. \\<And>C h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Class_type C) # obs, a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'\n 2. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "note \\<open>hconf h''\\<close>"], ["proof (state)\nthis:\n  hconf h''\n\ngoal (2 subgoals):\n 1. \\<And>C h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Class_type C) # obs, a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'\n 2. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "moreover"], ["proof (state)\nthis:\n  hconf h''\n\ngoal (2 subgoals):\n 1. \\<And>C h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Class_type C) # obs, a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'\n 2. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "from \\<open>typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\\<close> FDTs"], ["proof (chain)\npicking this:\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  P \\<turnstile> C has_fields FDTs", "have \"list_all2 (\\<lambda>al T. P,h \\<turnstile> a@al : T) ?als ?Ts\""], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h a)\n     (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n     (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)", "unfolding list_all2_map1 list_all2_map2 list_all2_refl_conv"], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set FDTs.\n       P,h \\<turnstile> a@(case x of\n                           (x, xa) \\<Rightarrow>\n                             (case x of\n                              (F, D) \\<Rightarrow> \\<lambda>Tfm. CField D F)\n                              xa) : (case x of\n                                     (FD, T) \\<Rightarrow>\n fst (the (map_of FDTs FD)))", "by(fastforce intro: addr_loc_type.intros simp add: has_field_def dest: weak_map_of_SomeI)"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h a)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n\ngoal (2 subgoals):\n 1. \\<And>C h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Class_type C) # obs, a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'\n 2. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "hence \"list_all2 (\\<lambda>al T. P,h'' \\<turnstile> a@al : T) ?als ?Ts\""], ["proof (prove)\nusing this:\n  list_all2 (addr_loc_type P h a)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h'' a)\n     (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n     (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)", "by(rule list_all2_mono)(rule addr_loc_type_hext_mono[OF _ \\<open>h \\<unlhd> h''\\<close>])"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h'' a)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n\ngoal (2 subgoals):\n 1. \\<And>C h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Class_type C) # obs, a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'\n 2. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "moreover"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h'' a)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n\ngoal (2 subgoals):\n 1. \\<And>C h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Class_type C) # obs, a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'\n 2. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "from \\<open>(h'', a') \\<in> allocate h (Class_type C)\\<close> \\<open>is_class P C\\<close>"], ["proof (chain)\npicking this:\n  (h'', a') \\<in> allocate h (Class_type C)\n  is_class P C", "have \"typeof_addr h'' a' = \\<lfloor>Class_type C\\<rfloor>\""], ["proof (prove)\nusing this:\n  (h'', a') \\<in> allocate h (Class_type C)\n  is_class P C\n\ngoal (1 subgoal):\n 1. typeof_addr h'' a' = \\<lfloor>Class_type C\\<rfloor>", "by(auto dest: allocate_SomeD)"], ["proof (state)\nthis:\n  typeof_addr h'' a' = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>C h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Class_type C) # obs, a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'\n 2. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "with FDTs"], ["proof (chain)\npicking this:\n  P \\<turnstile> C has_fields FDTs\n  typeof_addr h'' a' = \\<lfloor>Class_type C\\<rfloor>", "have \"list_all2 (\\<lambda>al T. P,h'' \\<turnstile> a'@al : T) ?als ?Ts\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n  typeof_addr h'' a' = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h'' a')\n     (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n     (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)", "unfolding list_all2_map1 list_all2_map2 list_all2_refl_conv"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n  typeof_addr h'' a' = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set FDTs.\n       P,h'' \\<turnstile> a'@(case x of\n                              (x, xa) \\<Rightarrow>\n                                (case x of\n                                 (F, D) \\<Rightarrow>\n                                   \\<lambda>Tfm. CField D F)\n                                 xa) : (case x of\n  (FD, T) \\<Rightarrow> fst (the (map_of FDTs FD)))", "by(fastforce intro: addr_loc_type.intros simp add: has_field_def dest: weak_map_of_SomeI)"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h'' a')\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n\ngoal (2 subgoals):\n 1. \\<And>C h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Class_type C) # obs, a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'\n 2. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "ultimately"], ["proof (chain)\npicking this:\n  heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'' obs\n   h'\n  hconf h''\n  list_all2 (addr_loc_type P h'' a)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n  list_all2 (addr_loc_type P h'' a')\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)", "have \"hconf h'\""], ["proof (prove)\nusing this:\n  heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'' obs\n   h'\n  hconf h''\n  list_all2 (addr_loc_type P h'' a)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n  list_all2 (addr_loc_type P h'' a')\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n\ngoal (1 subgoal):\n 1. hconf h'", "by(rule hconf_heap_copies_mono)"], ["proof (state)\nthis:\n  hconf h'\n\ngoal (2 subgoals):\n 1. \\<And>C h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Class_type C) # obs, a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'\n 2. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "thus ?thesis"], ["proof (prove)\nusing this:\n  hconf h'\n\ngoal (1 subgoal):\n 1. hconf h'", "using ObjClone"], ["proof (prove)\nusing this:\n  hconf h'\n  res = \\<lfloor>(NewHeapElem a' (Class_type C) # obs, a')\\<rfloor>\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  (h'', a') \\<in> allocate h (Class_type C)\n  P \\<turnstile> C has_fields FDTs\n  heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'' obs\n   h'\n\ngoal (1 subgoal):\n 1. hconf h'", "by simp"], ["proof (state)\nthis:\n  hconf h'\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "case (ArrClone T n h'' a' FDTs obs)"], ["proof (state)\nthis:\n  res = \\<lfloor>(NewHeapElem a' (Array_type T n) # obs, a')\\<rfloor>\n  typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>\n  (h'', a') \\<in> allocate h (Array_type T n)\n  P \\<turnstile> Object has_fields FDTs\n  heap_copies a a'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) h''\n   obs h'\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "let ?als = \"map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "let ?Ts = \"map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "note \\<open>heap_copies a a' ?als h'' obs h'\\<close>"], ["proof (state)\nthis:\n  heap_copies a a'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) h''\n   obs h'\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "moreover"], ["proof (state)\nthis:\n  heap_copies a a'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) h''\n   obs h'\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "from \\<open>typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>\\<close> \\<open>hconf h\\<close>"], ["proof (chain)\npicking this:\n  typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>\n  hconf h", "have \"is_type P (T\\<lfloor>\\<rceil>)\""], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>\n  hconf h\n\ngoal (1 subgoal):\n 1. is_type P (T\\<lfloor>\\<rceil>)", "by(auto dest: typeof_addr_is_type)"], ["proof (state)\nthis:\n  is_type P (T\\<lfloor>\\<rceil>)\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "from \\<open>(h'', a') \\<in> allocate h (Array_type T n)\\<close>"], ["proof (chain)\npicking this:\n  (h'', a') \\<in> allocate h (Array_type T n)", "have \"h \\<unlhd> h''\" \"hconf h''\""], ["proof (prove)\nusing this:\n  (h'', a') \\<in> allocate h (Array_type T n)\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'' &&& hconf h''", "by(rule hext_heap_ops hconf_allocate_mono)+(simp_all add: \\<open>hconf h\\<close> \\<open>is_type P (T\\<lfloor>\\<rceil>)\\<close>[simplified])"], ["proof (state)\nthis:\n  h \\<unlhd> h''\n  hconf h''\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "note \\<open>hconf h''\\<close>"], ["proof (state)\nthis:\n  hconf h''\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "moreover"], ["proof (state)\nthis:\n  hconf h''\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "from \\<open>h \\<unlhd> h''\\<close> \\<open>typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  h \\<unlhd> h''\n  typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>", "have type'a: \"typeof_addr h'' a = \\<lfloor>Array_type T n\\<rfloor>\""], ["proof (prove)\nusing this:\n  h \\<unlhd> h''\n  typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>\n\ngoal (1 subgoal):\n 1. typeof_addr h'' a = \\<lfloor>Array_type T n\\<rfloor>", "by(auto intro: hext_arrD)"], ["proof (state)\nthis:\n  typeof_addr h'' a = \\<lfloor>Array_type T n\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "note FDTs = \\<open>P \\<turnstile> Object has_fields FDTs\\<close>"], ["proof (state)\nthis:\n  P \\<turnstile> Object has_fields FDTs\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "from type'a FDTs"], ["proof (chain)\npicking this:\n  typeof_addr h'' a = \\<lfloor>Array_type T n\\<rfloor>\n  P \\<turnstile> Object has_fields FDTs", "have \"list_all2 (\\<lambda>al T. P,h'' \\<turnstile> a@al : T) ?als ?Ts\""], ["proof (prove)\nusing this:\n  typeof_addr h'' a = \\<lfloor>Array_type T n\\<rfloor>\n  P \\<turnstile> Object has_fields FDTs\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h'' a)\n     (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n     (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @\n      replicate n T)", "by(fastforce intro: list_all2_all_nthI addr_loc_type.intros simp add: has_field_def distinct_fst_def list_all2_append list_all2_map1 list_all2_map2 list_all2_refl_conv dest: weak_map_of_SomeI)"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h'' a)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "moreover"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h'' a)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "from \\<open>(h'', a') \\<in> allocate h (Array_type T n)\\<close> \\<open>is_type P (T\\<lfloor>\\<rceil>)\\<close>"], ["proof (chain)\npicking this:\n  (h'', a') \\<in> allocate h (Array_type T n)\n  is_type P (T\\<lfloor>\\<rceil>)", "have \"typeof_addr h'' a' = \\<lfloor>Array_type T n\\<rfloor>\""], ["proof (prove)\nusing this:\n  (h'', a') \\<in> allocate h (Array_type T n)\n  is_type P (T\\<lfloor>\\<rceil>)\n\ngoal (1 subgoal):\n 1. typeof_addr h'' a' = \\<lfloor>Array_type T n\\<rfloor>", "by(auto dest: allocate_SomeD)"], ["proof (state)\nthis:\n  typeof_addr h'' a' = \\<lfloor>Array_type T n\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "hence \"list_all2 (\\<lambda>al T. P,h'' \\<turnstile> a'@al : T) ?als ?Ts\""], ["proof (prove)\nusing this:\n  typeof_addr h'' a' = \\<lfloor>Array_type T n\\<rfloor>\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h'' a')\n     (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n     (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @\n      replicate n T)", "using FDTs"], ["proof (prove)\nusing this:\n  typeof_addr h'' a' = \\<lfloor>Array_type T n\\<rfloor>\n  P \\<turnstile> Object has_fields FDTs\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h'' a')\n     (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n     (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @\n      replicate n T)", "by(fastforce intro: list_all2_all_nthI addr_loc_type.intros simp add: has_field_def distinct_fst_def list_all2_append list_all2_map1 list_all2_map2 list_all2_refl_conv dest: weak_map_of_SomeI)"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h'' a')\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "ultimately"], ["proof (chain)\npicking this:\n  heap_copies a a'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) h''\n   obs h'\n  hconf h''\n  list_all2 (addr_loc_type P h'' a)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)\n  list_all2 (addr_loc_type P h'' a')\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)", "have \"hconf h'\""], ["proof (prove)\nusing this:\n  heap_copies a a'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) h''\n   obs h'\n  hconf h''\n  list_all2 (addr_loc_type P h'' a)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)\n  list_all2 (addr_loc_type P h'' a')\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)\n\ngoal (1 subgoal):\n 1. hconf h'", "by(rule hconf_heap_copies_mono)"], ["proof (state)\nthis:\n  hconf h'\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a a' FDTs obs.\n       \\<lbrakk>res =\n                \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                          a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h'\\<rbrakk>\n       \\<Longrightarrow> hconf h'", "thus ?thesis"], ["proof (prove)\nusing this:\n  hconf h'\n\ngoal (1 subgoal):\n 1. hconf h'", "using ArrClone"], ["proof (prove)\nusing this:\n  hconf h'\n  res = \\<lfloor>(NewHeapElem a' (Array_type T n) # obs, a')\\<rfloor>\n  typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>\n  (h'', a') \\<in> allocate h (Array_type T n)\n  P \\<turnstile> Object has_fields FDTs\n  heap_copies a a'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) h''\n   obs h'\n\ngoal (1 subgoal):\n 1. hconf h'", "by simp"], ["proof (state)\nthis:\n  hconf h'\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem external_call_hconf:\n  assumes major: \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>\"\n  and minor: \"P,h \\<turnstile> a\\<bullet>M(vs) : U\" \"hconf h\"\n  shows \"hconf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hconf h'", "using major minor"], ["proof (prove)\nusing this:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n  P,h \\<turnstile> a\\<bullet>M(vs) : U\n  hconf h\n\ngoal (1 subgoal):\n 1. hconf h'", "by cases(fastforce intro: hconf_heap_clone_mono)+"], ["", "end"], ["", "context heap_base begin"], ["", "primrec conf_extRet :: \"'m prog \\<Rightarrow> 'heap \\<Rightarrow> 'addr extCallRet \\<Rightarrow> ty \\<Rightarrow> bool\" where\n  \"conf_extRet P h (RetVal v) T = (P,h \\<turnstile> v :\\<le> T)\"\n| \"conf_extRet P h (RetExc a) T = (P,h \\<turnstile> Addr a :\\<le> Class Throwable)\"\n| \"conf_extRet P h RetStaySame T = True\""], ["", "end"], ["", "context heap_conf begin"], ["", "lemma red_external_conf_extRet:\n  assumes wf: \"wf_prog wf_md P\"\n  shows \"\\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>; P,h \\<turnstile> a\\<bullet>M(vs) : U; hconf h; preallocated h; P,h \\<turnstile> t \\<surd>t \\<rbrakk>\n  \\<Longrightarrow> conf_extRet P h' va U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                              h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                       h'\\<rangle>;\n     P,h \\<turnstile> a\\<bullet>M(vs) : U; hconf h; preallocated h;\n     P,h \\<turnstile> t \\<surd>t\\<rbrakk>\n    \\<Longrightarrow> conf_extRet P h' va U", "using wf"], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                              h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                       h'\\<rangle>;\n     P,h \\<turnstile> a\\<bullet>M(vs) : U; hconf h; preallocated h;\n     P,h \\<turnstile> t \\<surd>t\\<rbrakk>\n    \\<Longrightarrow> conf_extRet P h' va U", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                              h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                       h'\\<rangle>;\n     P,h \\<turnstile> a\\<bullet>M(vs) : U; hconf h; preallocated h;\n     P,h \\<turnstile> t \\<surd>t; wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> conf_extRet P h' va U", "apply(frule red_external_hext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                              h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                       h'\\<rangle>;\n     P,h \\<turnstile> a\\<bullet>M(vs) : U; hconf h; preallocated h;\n     P,h \\<turnstile> t \\<surd>t; wf_prog wf_md P; h \\<unlhd> h'\\<rbrakk>\n    \\<Longrightarrow> conf_extRet P h' va U", "apply(drule (1) preallocated_hext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                              h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                       h'\\<rangle>;\n     P,h \\<turnstile> a\\<bullet>M(vs) : U; hconf h;\n     P,h \\<turnstile> t \\<surd>t; wf_prog wf_md P; h \\<unlhd> h';\n     preallocated h'\\<rbrakk>\n    \\<Longrightarrow> conf_extRet P h' va U", "apply(auto elim!: red_external.cases external_WT'.cases external_WT_defs_cases dest!: sees_wf_native[OF wf])"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>hconf h; P,h \\<turnstile> t \\<surd>t; wf_prog wf_md P;\n        preallocated h; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>;\n        va = RetEXC IllegalThreadState; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread; M = start;\n        U = Void\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> Addr\n     (addr_of_sys_xcpt IllegalThreadState) :\\<le> Class Throwable\n 2. \\<And>C.\n       \\<lbrakk>hconf h; P,h \\<turnstile> t \\<surd>t; wf_prog wf_md P;\n        preallocated h; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread; M = join;\n        U = Void\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> Addr\n     (addr_of_sys_xcpt InterruptedException) :\\<le> Class Throwable\n 3. \\<And>hT.\n       \\<lbrakk>hconf h; P,h \\<turnstile> t \\<surd>t; wf_prog wf_md P;\n        preallocated h; typeof_addr h a = \\<lfloor>hT\\<rfloor>; vs = [];\n        ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n        ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h; M = wait;\n        U = Void\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> Addr\n     (addr_of_sys_xcpt InterruptedException) :\\<le> Class Throwable\n 4. \\<And>hT.\n       \\<lbrakk>hconf h; P,h \\<turnstile> t \\<surd>t; wf_prog wf_md P;\n        preallocated h; typeof_addr h a = \\<lfloor>hT\\<rfloor>; vs = [];\n        ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n        va = RetEXC IllegalMonitorState; h' = h; M = wait; U = Void\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> Addr\n     (addr_of_sys_xcpt IllegalMonitorState) :\\<le> Class Throwable\n 5. \\<And>hT.\n       \\<lbrakk>hconf h; P,h \\<turnstile> t \\<surd>t; wf_prog wf_md P;\n        preallocated h; typeof_addr h a = \\<lfloor>hT\\<rfloor>; vs = [];\n        ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h; M = wait;\n        U = Void\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> Addr\n     (addr_of_sys_xcpt InterruptedException) :\\<le> Class Throwable\n 6. \\<And>hT.\n       \\<lbrakk>hconf h; P,h \\<turnstile> t \\<surd>t; wf_prog wf_md P;\n        preallocated h; typeof_addr h a = \\<lfloor>hT\\<rfloor>; vs = [];\n        ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n        va = RetEXC IllegalMonitorState; h' = h; M = notify;\n        U = Void\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> Addr\n     (addr_of_sys_xcpt IllegalMonitorState) :\\<le> Class Throwable\n 7. \\<And>hT.\n       \\<lbrakk>hconf h; P,h \\<turnstile> t \\<surd>t; wf_prog wf_md P;\n        preallocated h; typeof_addr h a = \\<lfloor>hT\\<rfloor>; vs = [];\n        ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n        va = RetEXC IllegalMonitorState; h' = h; M = notifyAll;\n        U = Void\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> Addr\n     (addr_of_sys_xcpt IllegalMonitorState) :\\<le> Class Throwable\n 8. \\<And>hT obs a'.\n       \\<lbrakk>hconf h; P,h \\<turnstile> t \\<surd>t; wf_prog wf_md P;\n        h \\<unlhd> h'; preallocated h';\n        typeof_addr h a = \\<lfloor>hT\\<rfloor>; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>; M = clone;\n        U = Class Object\\<rbrakk>\n       \\<Longrightarrow> P,h' \\<turnstile> Addr a' :\\<le> Class Object\n 9. \\<And>hT.\n       \\<lbrakk>hconf h; P,h \\<turnstile> t \\<surd>t; wf_prog wf_md P;\n        h \\<unlhd> h'; preallocated h';\n        typeof_addr h a = \\<lfloor>hT\\<rfloor>; vs = [];\n        ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n        heap_clone P h a h' None; M = clone; U = Class Object\\<rbrakk>\n       \\<Longrightarrow> P,h' \\<turnstile> Addr\n      (addr_of_sys_xcpt OutOfMemory) :\\<le> Class Throwable\n 10. \\<And>hT.\n        \\<lbrakk>hconf h; P,h \\<turnstile> t \\<surd>t; wf_prog wf_md P;\n         preallocated h; typeof_addr h a = \\<lfloor>hT\\<rfloor>; vs = [];\n         ta = \\<lbrace>\\<rbrace>; va = RetVal (Addr (thread_id2addr t));\n         h' = h; M = currentThread; U = Class Thread\\<rbrakk>\n        \\<Longrightarrow> P,h \\<turnstile> Addr\n      (thread_id2addr t) :\\<le> Class Thread", "apply(auto simp add: conf_def tconf_def intro: xcpt_subcls_Throwable dest!: hext_heap_write)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>hT obs a' C.\n       \\<lbrakk>hconf h; wf_prog wf_md P; h \\<unlhd> h'; preallocated h';\n        typeof_addr h a = \\<lfloor>hT\\<rfloor>; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>; M = clone;\n        U = Class Object;\n        typeof_addr h (thread_id2addr t) = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T'.\n                            (\\<exists>z.\n                                typeof_addr h' a' =\n                                \\<lfloor>z\\<rfloor> \\<and>\n                                ty_of_htype z = T') \\<and>\n                            P \\<turnstile> T' \\<le> Class Object", "apply(case_tac hT)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>hT obs a' C x1.\n       \\<lbrakk>hconf h; wf_prog wf_md P; h \\<unlhd> h'; preallocated h';\n        typeof_addr h a = \\<lfloor>hT\\<rfloor>; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>; M = clone;\n        U = Class Object;\n        typeof_addr h (thread_id2addr t) = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread;\n        hT = Class_type x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T'.\n                            (\\<exists>z.\n                                typeof_addr h' a' =\n                                \\<lfloor>z\\<rfloor> \\<and>\n                                ty_of_htype z = T') \\<and>\n                            P \\<turnstile> T' \\<le> Class Object\n 2. \\<And>hT obs a' C x21 x22.\n       \\<lbrakk>hconf h; wf_prog wf_md P; h \\<unlhd> h'; preallocated h';\n        typeof_addr h a = \\<lfloor>hT\\<rfloor>; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>; M = clone;\n        U = Class Object;\n        typeof_addr h (thread_id2addr t) = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread;\n        hT = Array_type x21 x22\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T'.\n                            (\\<exists>z.\n                                typeof_addr h' a' =\n                                \\<lfloor>z\\<rfloor> \\<and>\n                                ty_of_htype z = T') \\<and>\n                            P \\<turnstile> T' \\<le> Class Object", "apply(auto 4 4 dest!: typeof_addr_heap_clone dest: typeof_addr_is_type intro: widen_array_object subcls_C_Object)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsection \\<open>Progress theorems for external calls\\<close>"], ["", "context heap_progress begin"], ["", "lemma heap_copy_loc_progress:\n  assumes hconf: \"hconf h\"\n  and alconfa: \"P,h \\<turnstile> a@al : T\"\n  and alconfa': \"P,h \\<turnstile> a'@al : T\"\n  shows \"\\<exists>v h'. heap_copy_loc a a' al h ([ReadMem a al v, WriteMem a' al v]) h' \\<and> P,h \\<turnstile> v :\\<le> T \\<and> hconf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v h'.\n       heap_copy_loc a a' al h [ReadMem a al v, WriteMem a' al v] h' \\<and>\n       P,h \\<turnstile> v :\\<le> T \\<and> hconf h'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v h'.\n       heap_copy_loc a a' al h [ReadMem a al v, WriteMem a' al v] h' \\<and>\n       P,h \\<turnstile> v :\\<le> T \\<and> hconf h'", "from heap_read_total[OF hconf alconfa]"], ["proof (chain)\npicking this:\n  \\<exists>v. heap_read h a al v \\<and> P,h \\<turnstile> v :\\<le> T", "obtain v where \"heap_read h a al v\" \"P,h \\<turnstile> v :\\<le> T\""], ["proof (prove)\nusing this:\n  \\<exists>v. heap_read h a al v \\<and> P,h \\<turnstile> v :\\<le> T\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>heap_read h a al v; P,h \\<turnstile> v :\\<le> T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  heap_read h a al v\n  P,h \\<turnstile> v :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<exists>v h'.\n       heap_copy_loc a a' al h [ReadMem a al v, WriteMem a' al v] h' \\<and>\n       P,h \\<turnstile> v :\\<le> T \\<and> hconf h'", "moreover"], ["proof (state)\nthis:\n  heap_read h a al v\n  P,h \\<turnstile> v :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<exists>v h'.\n       heap_copy_loc a a' al h [ReadMem a al v, WriteMem a' al v] h' \\<and>\n       P,h \\<turnstile> v :\\<le> T \\<and> hconf h'", "from heap_write_total[OF hconf alconfa' \\<open>P,h \\<turnstile> v :\\<le> T\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>h'. heap_write h a' al v h'", "obtain h' where \"heap_write h a' al v h'\""], ["proof (prove)\nusing this:\n  \\<exists>h'. heap_write h a' al v h'\n\ngoal (1 subgoal):\n 1. (\\<And>h'.\n        heap_write h a' al v h' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  heap_write h a' al v h'\n\ngoal (1 subgoal):\n 1. \\<exists>v h'.\n       heap_copy_loc a a' al h [ReadMem a al v, WriteMem a' al v] h' \\<and>\n       P,h \\<turnstile> v :\\<le> T \\<and> hconf h'", "moreover"], ["proof (state)\nthis:\n  heap_write h a' al v h'\n\ngoal (1 subgoal):\n 1. \\<exists>v h'.\n       heap_copy_loc a a' al h [ReadMem a al v, WriteMem a' al v] h' \\<and>\n       P,h \\<turnstile> v :\\<le> T \\<and> hconf h'", "hence \"hconf h'\""], ["proof (prove)\nusing this:\n  heap_write h a' al v h'\n\ngoal (1 subgoal):\n 1. hconf h'", "using hconf alconfa' \\<open>P,h \\<turnstile> v :\\<le> T\\<close>"], ["proof (prove)\nusing this:\n  heap_write h a' al v h'\n  hconf h\n  P,h \\<turnstile> a'@al : T\n  P,h \\<turnstile> v :\\<le> T\n\ngoal (1 subgoal):\n 1. hconf h'", "by(rule hconf_heap_write_mono)"], ["proof (state)\nthis:\n  hconf h'\n\ngoal (1 subgoal):\n 1. \\<exists>v h'.\n       heap_copy_loc a a' al h [ReadMem a al v, WriteMem a' al v] h' \\<and>\n       P,h \\<turnstile> v :\\<le> T \\<and> hconf h'", "ultimately"], ["proof (chain)\npicking this:\n  heap_read h a al v\n  P,h \\<turnstile> v :\\<le> T\n  heap_write h a' al v h'\n  hconf h'", "show ?thesis"], ["proof (prove)\nusing this:\n  heap_read h a al v\n  P,h \\<turnstile> v :\\<le> T\n  heap_write h a' al v h'\n  hconf h'\n\ngoal (1 subgoal):\n 1. \\<exists>v h'.\n       heap_copy_loc a a' al h [ReadMem a al v, WriteMem a' al v] h' \\<and>\n       P,h \\<turnstile> v :\\<le> T \\<and> hconf h'", "by(blast intro: heap_copy_loc.intros)"], ["proof (state)\nthis:\n  \\<exists>v h'.\n     heap_copy_loc a a' al h [ReadMem a al v, WriteMem a' al v] h' \\<and>\n     P,h \\<turnstile> v :\\<le> T \\<and> hconf h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma heap_copies_progress:\n  assumes \"hconf h\"\n  and \"list_all2 (\\<lambda>al T. P,h \\<turnstile> a@al : T) als Ts\"\n  and \"list_all2 (\\<lambda>al T. P,h \\<turnstile> a'@al : T) als Ts\"\n  shows \"\\<exists>vs h'. heap_copies a a' als h (concat (map (\\<lambda>(al, v). [ReadMem a al v, WriteMem a' al v]) (zip als vs))) h' \\<and> hconf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>vs h'.\n       heap_copies a a' als h\n        (concat\n          (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n        h' \\<and>\n       hconf h'", "using assms"], ["proof (prove)\nusing this:\n  hconf h\n  list_all2 (addr_loc_type P h a) als Ts\n  list_all2 (addr_loc_type P h a') als Ts\n\ngoal (1 subgoal):\n 1. \\<exists>vs h'.\n       heap_copies a a' als h\n        (concat\n          (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n        h' \\<and>\n       hconf h'", "proof(induct als arbitrary: h Ts)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h Ts.\n       \\<lbrakk>hconf h; list_all2 (addr_loc_type P h a) [] Ts;\n        list_all2 (addr_loc_type P h a') [] Ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs h'.\n                            heap_copies a a' [] h\n                             (concat\n                               (map2\n                                 (\\<lambda>al v.\n                                     [ReadMem a al v, WriteMem a' al v])\n                                 [] vs))\n                             h' \\<and>\n                            hconf h'\n 2. \\<And>aa als h Ts.\n       \\<lbrakk>\\<And>h Ts.\n                   \\<lbrakk>hconf h; list_all2 (addr_loc_type P h a) als Ts;\n                    list_all2 (addr_loc_type P h a') als Ts\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>vs h'.\n  heap_copies a a' als h\n   (concat\n     (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n   h' \\<and>\n  hconf h';\n        hconf h; list_all2 (addr_loc_type P h a) (aa # als) Ts;\n        list_all2 (addr_loc_type P h a') (aa # als) Ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs h'.\n                            heap_copies a a' (aa # als) h\n                             (concat\n                               (map2\n                                 (\\<lambda>al v.\n                                     [ReadMem a al v, WriteMem a' al v])\n                                 (aa # als) vs))\n                             h' \\<and>\n                            hconf h'", "case Nil"], ["proof (state)\nthis:\n  hconf h\n  list_all2 (addr_loc_type P h a) [] Ts\n  list_all2 (addr_loc_type P h a') [] Ts\n\ngoal (2 subgoals):\n 1. \\<And>h Ts.\n       \\<lbrakk>hconf h; list_all2 (addr_loc_type P h a) [] Ts;\n        list_all2 (addr_loc_type P h a') [] Ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs h'.\n                            heap_copies a a' [] h\n                             (concat\n                               (map2\n                                 (\\<lambda>al v.\n                                     [ReadMem a al v, WriteMem a' al v])\n                                 [] vs))\n                             h' \\<and>\n                            hconf h'\n 2. \\<And>aa als h Ts.\n       \\<lbrakk>\\<And>h Ts.\n                   \\<lbrakk>hconf h; list_all2 (addr_loc_type P h a) als Ts;\n                    list_all2 (addr_loc_type P h a') als Ts\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>vs h'.\n  heap_copies a a' als h\n   (concat\n     (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n   h' \\<and>\n  hconf h';\n        hconf h; list_all2 (addr_loc_type P h a) (aa # als) Ts;\n        list_all2 (addr_loc_type P h a') (aa # als) Ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs h'.\n                            heap_copies a a' (aa # als) h\n                             (concat\n                               (map2\n                                 (\\<lambda>al v.\n                                     [ReadMem a al v, WriteMem a' al v])\n                                 (aa # als) vs))\n                             h' \\<and>\n                            hconf h'", "thus ?case"], ["proof (prove)\nusing this:\n  hconf h\n  list_all2 (addr_loc_type P h a) [] Ts\n  list_all2 (addr_loc_type P h a') [] Ts\n\ngoal (1 subgoal):\n 1. \\<exists>vs h'.\n       heap_copies a a' [] h\n        (concat\n          (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) [] vs))\n        h' \\<and>\n       hconf h'", "by(auto intro: heap_copies.Nil)"], ["proof (state)\nthis:\n  \\<exists>vs h'.\n     heap_copies a a' [] h\n      (concat\n        (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) [] vs))\n      h' \\<and>\n     hconf h'\n\ngoal (1 subgoal):\n 1. \\<And>aa als h Ts.\n       \\<lbrakk>\\<And>h Ts.\n                   \\<lbrakk>hconf h; list_all2 (addr_loc_type P h a) als Ts;\n                    list_all2 (addr_loc_type P h a') als Ts\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>vs h'.\n  heap_copies a a' als h\n   (concat\n     (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n   h' \\<and>\n  hconf h';\n        hconf h; list_all2 (addr_loc_type P h a) (aa # als) Ts;\n        list_all2 (addr_loc_type P h a') (aa # als) Ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs h'.\n                            heap_copies a a' (aa # als) h\n                             (concat\n                               (map2\n                                 (\\<lambda>al v.\n                                     [ReadMem a al v, WriteMem a' al v])\n                                 (aa # als) vs))\n                             h' \\<and>\n                            hconf h'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa als h Ts.\n       \\<lbrakk>\\<And>h Ts.\n                   \\<lbrakk>hconf h; list_all2 (addr_loc_type P h a) als Ts;\n                    list_all2 (addr_loc_type P h a') als Ts\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>vs h'.\n  heap_copies a a' als h\n   (concat\n     (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n   h' \\<and>\n  hconf h';\n        hconf h; list_all2 (addr_loc_type P h a) (aa # als) Ts;\n        list_all2 (addr_loc_type P h a') (aa # als) Ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs h'.\n                            heap_copies a a' (aa # als) h\n                             (concat\n                               (map2\n                                 (\\<lambda>al v.\n                                     [ReadMem a al v, WriteMem a' al v])\n                                 (aa # als) vs))\n                             h' \\<and>\n                            hconf h'", "case (Cons al als)"], ["proof (state)\nthis:\n  \\<lbrakk>hconf ?h15; list_all2 (addr_loc_type P ?h15 a) als ?Ts15;\n   list_all2 (addr_loc_type P ?h15 a') als ?Ts15\\<rbrakk>\n  \\<Longrightarrow> \\<exists>vs h'.\n                       heap_copies a a' als ?h15\n                        (concat\n                          (map2\n                            (\\<lambda>al v.\n                                [ReadMem a al v, WriteMem a' al v])\n                            als vs))\n                        h' \\<and>\n                       hconf h'\n  hconf h\n  list_all2 (addr_loc_type P h a) (al # als) Ts\n  list_all2 (addr_loc_type P h a') (al # als) Ts\n\ngoal (1 subgoal):\n 1. \\<And>aa als h Ts.\n       \\<lbrakk>\\<And>h Ts.\n                   \\<lbrakk>hconf h; list_all2 (addr_loc_type P h a) als Ts;\n                    list_all2 (addr_loc_type P h a') als Ts\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>vs h'.\n  heap_copies a a' als h\n   (concat\n     (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n   h' \\<and>\n  hconf h';\n        hconf h; list_all2 (addr_loc_type P h a) (aa # als) Ts;\n        list_all2 (addr_loc_type P h a') (aa # als) Ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs h'.\n                            heap_copies a a' (aa # als) h\n                             (concat\n                               (map2\n                                 (\\<lambda>al v.\n                                     [ReadMem a al v, WriteMem a' al v])\n                                 (aa # als) vs))\n                             h' \\<and>\n                            hconf h'", "from \\<open>list_all2 (\\<lambda>al T. P,h \\<turnstile> a@al : T) (al # als) Ts\\<close>"], ["proof (chain)\npicking this:\n  list_all2 (addr_loc_type P h a) (al # als) Ts", "obtain T' Ts' where [simp]: \"Ts = T' # Ts'\"\n    and \"P,h \\<turnstile> a@al : T'\" \"list_all2 (\\<lambda>al T. P,h \\<turnstile> a@al : T) als Ts'\""], ["proof (prove)\nusing this:\n  list_all2 (addr_loc_type P h a) (al # als) Ts\n\ngoal (1 subgoal):\n 1. (\\<And>T' Ts'.\n        \\<lbrakk>Ts = T' # Ts'; P,h \\<turnstile> a@al : T';\n         list_all2 (addr_loc_type P h a) als Ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: list_all2_Cons1)"], ["proof (state)\nthis:\n  Ts = T' # Ts'\n  P,h \\<turnstile> a@al : T'\n  list_all2 (addr_loc_type P h a) als Ts'\n\ngoal (1 subgoal):\n 1. \\<And>aa als h Ts.\n       \\<lbrakk>\\<And>h Ts.\n                   \\<lbrakk>hconf h; list_all2 (addr_loc_type P h a) als Ts;\n                    list_all2 (addr_loc_type P h a') als Ts\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>vs h'.\n  heap_copies a a' als h\n   (concat\n     (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n   h' \\<and>\n  hconf h';\n        hconf h; list_all2 (addr_loc_type P h a) (aa # als) Ts;\n        list_all2 (addr_loc_type P h a') (aa # als) Ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs h'.\n                            heap_copies a a' (aa # als) h\n                             (concat\n                               (map2\n                                 (\\<lambda>al v.\n                                     [ReadMem a al v, WriteMem a' al v])\n                                 (aa # als) vs))\n                             h' \\<and>\n                            hconf h'", "from \\<open>list_all2 (\\<lambda>al T. P,h \\<turnstile> a'@al : T) (al # als) Ts\\<close>"], ["proof (chain)\npicking this:\n  list_all2 (addr_loc_type P h a') (al # als) Ts", "have \"P,h \\<turnstile> a'@al : T'\" and \"list_all2 (\\<lambda>al T. P,h \\<turnstile> a'@al : T) als Ts'\""], ["proof (prove)\nusing this:\n  list_all2 (addr_loc_type P h a') (al # als) Ts\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> a'@al : T' &&& list_all2 (addr_loc_type P h a') als Ts'", "by simp_all"], ["proof (state)\nthis:\n  P,h \\<turnstile> a'@al : T'\n  list_all2 (addr_loc_type P h a') als Ts'\n\ngoal (1 subgoal):\n 1. \\<And>aa als h Ts.\n       \\<lbrakk>\\<And>h Ts.\n                   \\<lbrakk>hconf h; list_all2 (addr_loc_type P h a) als Ts;\n                    list_all2 (addr_loc_type P h a') als Ts\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>vs h'.\n  heap_copies a a' als h\n   (concat\n     (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n   h' \\<and>\n  hconf h';\n        hconf h; list_all2 (addr_loc_type P h a) (aa # als) Ts;\n        list_all2 (addr_loc_type P h a') (aa # als) Ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs h'.\n                            heap_copies a a' (aa # als) h\n                             (concat\n                               (map2\n                                 (\\<lambda>al v.\n                                     [ReadMem a al v, WriteMem a' al v])\n                                 (aa # als) vs))\n                             h' \\<and>\n                            hconf h'", "from \\<open>hconf h\\<close> \\<open>P,h \\<turnstile> a@al : T'\\<close> \\<open>P,h \\<turnstile> a'@al : T'\\<close>"], ["proof (chain)\npicking this:\n  hconf h\n  P,h \\<turnstile> a@al : T'\n  P,h \\<turnstile> a'@al : T'", "obtain v h' where \"heap_copy_loc a a' al h [ReadMem a al v, WriteMem a' al v] h'\"\n    and \"hconf h'\""], ["proof (prove)\nusing this:\n  hconf h\n  P,h \\<turnstile> a@al : T'\n  P,h \\<turnstile> a'@al : T'\n\ngoal (1 subgoal):\n 1. (\\<And>v h'.\n        \\<lbrakk>heap_copy_loc a a' al h [ReadMem a al v, WriteMem a' al v]\n                  h';\n         hconf h'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest: heap_copy_loc_progress)"], ["proof (state)\nthis:\n  heap_copy_loc a a' al h [ReadMem a al v, WriteMem a' al v] h'\n  hconf h'\n\ngoal (1 subgoal):\n 1. \\<And>aa als h Ts.\n       \\<lbrakk>\\<And>h Ts.\n                   \\<lbrakk>hconf h; list_all2 (addr_loc_type P h a) als Ts;\n                    list_all2 (addr_loc_type P h a') als Ts\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>vs h'.\n  heap_copies a a' als h\n   (concat\n     (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n   h' \\<and>\n  hconf h';\n        hconf h; list_all2 (addr_loc_type P h a) (aa # als) Ts;\n        list_all2 (addr_loc_type P h a') (aa # als) Ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs h'.\n                            heap_copies a a' (aa # als) h\n                             (concat\n                               (map2\n                                 (\\<lambda>al v.\n                                     [ReadMem a al v, WriteMem a' al v])\n                                 (aa # als) vs))\n                             h' \\<and>\n                            hconf h'", "moreover"], ["proof (state)\nthis:\n  heap_copy_loc a a' al h [ReadMem a al v, WriteMem a' al v] h'\n  hconf h'\n\ngoal (1 subgoal):\n 1. \\<And>aa als h Ts.\n       \\<lbrakk>\\<And>h Ts.\n                   \\<lbrakk>hconf h; list_all2 (addr_loc_type P h a) als Ts;\n                    list_all2 (addr_loc_type P h a') als Ts\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>vs h'.\n  heap_copies a a' als h\n   (concat\n     (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n   h' \\<and>\n  hconf h';\n        hconf h; list_all2 (addr_loc_type P h a) (aa # als) Ts;\n        list_all2 (addr_loc_type P h a') (aa # als) Ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs h'.\n                            heap_copies a a' (aa # als) h\n                             (concat\n                               (map2\n                                 (\\<lambda>al v.\n                                     [ReadMem a al v, WriteMem a' al v])\n                                 (aa # als) vs))\n                             h' \\<and>\n                            hconf h'", "hence \"h \\<unlhd> h'\""], ["proof (prove)\nusing this:\n  heap_copy_loc a a' al h [ReadMem a al v, WriteMem a' al v] h'\n  hconf h'\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "by-(rule hext_heap_copy_loc)"], ["proof (state)\nthis:\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. \\<And>aa als h Ts.\n       \\<lbrakk>\\<And>h Ts.\n                   \\<lbrakk>hconf h; list_all2 (addr_loc_type P h a) als Ts;\n                    list_all2 (addr_loc_type P h a') als Ts\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>vs h'.\n  heap_copies a a' als h\n   (concat\n     (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n   h' \\<and>\n  hconf h';\n        hconf h; list_all2 (addr_loc_type P h a) (aa # als) Ts;\n        list_all2 (addr_loc_type P h a') (aa # als) Ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs h'.\n                            heap_copies a a' (aa # als) h\n                             (concat\n                               (map2\n                                 (\\<lambda>al v.\n                                     [ReadMem a al v, WriteMem a' al v])\n                                 (aa # als) vs))\n                             h' \\<and>\n                            hconf h'", "{"], ["proof (state)\nthis:\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. \\<And>aa als h Ts.\n       \\<lbrakk>\\<And>h Ts.\n                   \\<lbrakk>hconf h; list_all2 (addr_loc_type P h a) als Ts;\n                    list_all2 (addr_loc_type P h a') als Ts\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>vs h'.\n  heap_copies a a' als h\n   (concat\n     (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n   h' \\<and>\n  hconf h';\n        hconf h; list_all2 (addr_loc_type P h a) (aa # als) Ts;\n        list_all2 (addr_loc_type P h a') (aa # als) Ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs h'.\n                            heap_copies a a' (aa # als) h\n                             (concat\n                               (map2\n                                 (\\<lambda>al v.\n                                     [ReadMem a al v, WriteMem a' al v])\n                                 (aa # als) vs))\n                             h' \\<and>\n                            hconf h'", "note \\<open>hconf h'\\<close>"], ["proof (state)\nthis:\n  hconf h'\n\ngoal (1 subgoal):\n 1. \\<And>aa als h Ts.\n       \\<lbrakk>\\<And>h Ts.\n                   \\<lbrakk>hconf h; list_all2 (addr_loc_type P h a) als Ts;\n                    list_all2 (addr_loc_type P h a') als Ts\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>vs h'.\n  heap_copies a a' als h\n   (concat\n     (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n   h' \\<and>\n  hconf h';\n        hconf h; list_all2 (addr_loc_type P h a) (aa # als) Ts;\n        list_all2 (addr_loc_type P h a') (aa # als) Ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs h'.\n                            heap_copies a a' (aa # als) h\n                             (concat\n                               (map2\n                                 (\\<lambda>al v.\n                                     [ReadMem a al v, WriteMem a' al v])\n                                 (aa # als) vs))\n                             h' \\<and>\n                            hconf h'", "moreover"], ["proof (state)\nthis:\n  hconf h'\n\ngoal (1 subgoal):\n 1. \\<And>aa als h Ts.\n       \\<lbrakk>\\<And>h Ts.\n                   \\<lbrakk>hconf h; list_all2 (addr_loc_type P h a) als Ts;\n                    list_all2 (addr_loc_type P h a') als Ts\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>vs h'.\n  heap_copies a a' als h\n   (concat\n     (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n   h' \\<and>\n  hconf h';\n        hconf h; list_all2 (addr_loc_type P h a) (aa # als) Ts;\n        list_all2 (addr_loc_type P h a') (aa # als) Ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs h'.\n                            heap_copies a a' (aa # als) h\n                             (concat\n                               (map2\n                                 (\\<lambda>al v.\n                                     [ReadMem a al v, WriteMem a' al v])\n                                 (aa # als) vs))\n                             h' \\<and>\n                            hconf h'", "from \\<open>list_all2 (\\<lambda>al T. P,h \\<turnstile> a@al : T) als Ts'\\<close>"], ["proof (chain)\npicking this:\n  list_all2 (addr_loc_type P h a) als Ts'", "have \"list_all2 (\\<lambda>al T. P,h' \\<turnstile> a@al : T) als Ts'\""], ["proof (prove)\nusing this:\n  list_all2 (addr_loc_type P h a) als Ts'\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h' a) als Ts'", "by(rule list_all2_mono)(rule addr_loc_type_hext_mono[OF _ \\<open>h \\<unlhd> h'\\<close>])"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h' a) als Ts'\n\ngoal (1 subgoal):\n 1. \\<And>aa als h Ts.\n       \\<lbrakk>\\<And>h Ts.\n                   \\<lbrakk>hconf h; list_all2 (addr_loc_type P h a) als Ts;\n                    list_all2 (addr_loc_type P h a') als Ts\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>vs h'.\n  heap_copies a a' als h\n   (concat\n     (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n   h' \\<and>\n  hconf h';\n        hconf h; list_all2 (addr_loc_type P h a) (aa # als) Ts;\n        list_all2 (addr_loc_type P h a') (aa # als) Ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs h'.\n                            heap_copies a a' (aa # als) h\n                             (concat\n                               (map2\n                                 (\\<lambda>al v.\n                                     [ReadMem a al v, WriteMem a' al v])\n                                 (aa # als) vs))\n                             h' \\<and>\n                            hconf h'", "moreover"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h' a) als Ts'\n\ngoal (1 subgoal):\n 1. \\<And>aa als h Ts.\n       \\<lbrakk>\\<And>h Ts.\n                   \\<lbrakk>hconf h; list_all2 (addr_loc_type P h a) als Ts;\n                    list_all2 (addr_loc_type P h a') als Ts\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>vs h'.\n  heap_copies a a' als h\n   (concat\n     (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n   h' \\<and>\n  hconf h';\n        hconf h; list_all2 (addr_loc_type P h a) (aa # als) Ts;\n        list_all2 (addr_loc_type P h a') (aa # als) Ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs h'.\n                            heap_copies a a' (aa # als) h\n                             (concat\n                               (map2\n                                 (\\<lambda>al v.\n                                     [ReadMem a al v, WriteMem a' al v])\n                                 (aa # als) vs))\n                             h' \\<and>\n                            hconf h'", "from \\<open>list_all2 (\\<lambda>al T. P,h \\<turnstile> a'@al : T) als Ts'\\<close>"], ["proof (chain)\npicking this:\n  list_all2 (addr_loc_type P h a') als Ts'", "have \"list_all2 (\\<lambda>al T. P,h' \\<turnstile> a'@al : T) als Ts'\""], ["proof (prove)\nusing this:\n  list_all2 (addr_loc_type P h a') als Ts'\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h' a') als Ts'", "by(rule list_all2_mono)(rule addr_loc_type_hext_mono[OF _ \\<open>h \\<unlhd> h'\\<close>])"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h' a') als Ts'\n\ngoal (1 subgoal):\n 1. \\<And>aa als h Ts.\n       \\<lbrakk>\\<And>h Ts.\n                   \\<lbrakk>hconf h; list_all2 (addr_loc_type P h a) als Ts;\n                    list_all2 (addr_loc_type P h a') als Ts\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>vs h'.\n  heap_copies a a' als h\n   (concat\n     (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n   h' \\<and>\n  hconf h';\n        hconf h; list_all2 (addr_loc_type P h a) (aa # als) Ts;\n        list_all2 (addr_loc_type P h a') (aa # als) Ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs h'.\n                            heap_copies a a' (aa # als) h\n                             (concat\n                               (map2\n                                 (\\<lambda>al v.\n                                     [ReadMem a al v, WriteMem a' al v])\n                                 (aa # als) vs))\n                             h' \\<and>\n                            hconf h'", "ultimately"], ["proof (chain)\npicking this:\n  hconf h'\n  list_all2 (addr_loc_type P h' a) als Ts'\n  list_all2 (addr_loc_type P h' a') als Ts'", "have \"\\<exists>vs h''. heap_copies a a' als h' (concat (map (\\<lambda>(al, v). [ReadMem a al v, WriteMem a' al v]) (zip als vs))) h'' \\<and> hconf h''\""], ["proof (prove)\nusing this:\n  hconf h'\n  list_all2 (addr_loc_type P h' a) als Ts'\n  list_all2 (addr_loc_type P h' a') als Ts'\n\ngoal (1 subgoal):\n 1. \\<exists>vs h''.\n       heap_copies a a' als h'\n        (concat\n          (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n        h'' \\<and>\n       hconf h''", "by(rule Cons)"], ["proof (state)\nthis:\n  \\<exists>vs h''.\n     heap_copies a a' als h'\n      (concat\n        (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n      h'' \\<and>\n     hconf h''\n\ngoal (1 subgoal):\n 1. \\<And>aa als h Ts.\n       \\<lbrakk>\\<And>h Ts.\n                   \\<lbrakk>hconf h; list_all2 (addr_loc_type P h a) als Ts;\n                    list_all2 (addr_loc_type P h a') als Ts\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>vs h'.\n  heap_copies a a' als h\n   (concat\n     (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n   h' \\<and>\n  hconf h';\n        hconf h; list_all2 (addr_loc_type P h a) (aa # als) Ts;\n        list_all2 (addr_loc_type P h a') (aa # als) Ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs h'.\n                            heap_copies a a' (aa # als) h\n                             (concat\n                               (map2\n                                 (\\<lambda>al v.\n                                     [ReadMem a al v, WriteMem a' al v])\n                                 (aa # als) vs))\n                             h' \\<and>\n                            hconf h'", "}"], ["proof (state)\nthis:\n  \\<exists>vs h''.\n     heap_copies a a' als h'\n      (concat\n        (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n      h'' \\<and>\n     hconf h''\n\ngoal (1 subgoal):\n 1. \\<And>aa als h Ts.\n       \\<lbrakk>\\<And>h Ts.\n                   \\<lbrakk>hconf h; list_all2 (addr_loc_type P h a) als Ts;\n                    list_all2 (addr_loc_type P h a') als Ts\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>vs h'.\n  heap_copies a a' als h\n   (concat\n     (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n   h' \\<and>\n  hconf h';\n        hconf h; list_all2 (addr_loc_type P h a) (aa # als) Ts;\n        list_all2 (addr_loc_type P h a') (aa # als) Ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs h'.\n                            heap_copies a a' (aa # als) h\n                             (concat\n                               (map2\n                                 (\\<lambda>al v.\n                                     [ReadMem a al v, WriteMem a' al v])\n                                 (aa # als) vs))\n                             h' \\<and>\n                            hconf h'", "then"], ["proof (chain)\npicking this:\n  \\<exists>vs h''.\n     heap_copies a a' als h'\n      (concat\n        (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n      h'' \\<and>\n     hconf h''", "obtain vs h''\n    where \"heap_copies a a' als h' (concat (map (\\<lambda>(al, v). [ReadMem a al v, WriteMem a' al v]) (zip als vs))) h''\"\n    and \"hconf h''\""], ["proof (prove)\nusing this:\n  \\<exists>vs h''.\n     heap_copies a a' als h'\n      (concat\n        (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n      h'' \\<and>\n     hconf h''\n\ngoal (1 subgoal):\n 1. (\\<And>vs h''.\n        \\<lbrakk>heap_copies a a' als h'\n                  (concat\n                    (map2\n                      (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v])\n                      als vs))\n                  h'';\n         hconf h''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  heap_copies a a' als h'\n   (concat\n     (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n   h''\n  hconf h''\n\ngoal (1 subgoal):\n 1. \\<And>aa als h Ts.\n       \\<lbrakk>\\<And>h Ts.\n                   \\<lbrakk>hconf h; list_all2 (addr_loc_type P h a) als Ts;\n                    list_all2 (addr_loc_type P h a') als Ts\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>vs h'.\n  heap_copies a a' als h\n   (concat\n     (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n   h' \\<and>\n  hconf h';\n        hconf h; list_all2 (addr_loc_type P h a) (aa # als) Ts;\n        list_all2 (addr_loc_type P h a') (aa # als) Ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs h'.\n                            heap_copies a a' (aa # als) h\n                             (concat\n                               (map2\n                                 (\\<lambda>al v.\n                                     [ReadMem a al v, WriteMem a' al v])\n                                 (aa # als) vs))\n                             h' \\<and>\n                            hconf h'", "ultimately"], ["proof (chain)\npicking this:\n  heap_copy_loc a a' al h [ReadMem a al v, WriteMem a' al v] h'\n  hconf h'\n  heap_copies a a' als h'\n   (concat\n     (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n   h''\n  hconf h''", "have \"heap_copies a a' (al # als) h ([ReadMem a al v, WriteMem a' al v] @ (concat (map (\\<lambda>(al, v). [ReadMem a al v, WriteMem a' al v]) (zip als vs)))) h''\""], ["proof (prove)\nusing this:\n  heap_copy_loc a a' al h [ReadMem a al v, WriteMem a' al v] h'\n  hconf h'\n  heap_copies a a' als h'\n   (concat\n     (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n   h''\n  hconf h''\n\ngoal (1 subgoal):\n 1. heap_copies a a' (al # als) h\n     ([ReadMem a al v, WriteMem a' al v] @\n      concat\n       (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n     h''", "by- (rule heap_copies.Cons)"], ["proof (state)\nthis:\n  heap_copies a a' (al # als) h\n   ([ReadMem a al v, WriteMem a' al v] @\n    concat\n     (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n   h''\n\ngoal (1 subgoal):\n 1. \\<And>aa als h Ts.\n       \\<lbrakk>\\<And>h Ts.\n                   \\<lbrakk>hconf h; list_all2 (addr_loc_type P h a) als Ts;\n                    list_all2 (addr_loc_type P h a') als Ts\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>vs h'.\n  heap_copies a a' als h\n   (concat\n     (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n   h' \\<and>\n  hconf h';\n        hconf h; list_all2 (addr_loc_type P h a) (aa # als) Ts;\n        list_all2 (addr_loc_type P h a') (aa # als) Ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs h'.\n                            heap_copies a a' (aa # als) h\n                             (concat\n                               (map2\n                                 (\\<lambda>al v.\n                                     [ReadMem a al v, WriteMem a' al v])\n                                 (aa # als) vs))\n                             h' \\<and>\n                            hconf h'", "also"], ["proof (state)\nthis:\n  heap_copies a a' (al # als) h\n   ([ReadMem a al v, WriteMem a' al v] @\n    concat\n     (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n   h''\n\ngoal (1 subgoal):\n 1. \\<And>aa als h Ts.\n       \\<lbrakk>\\<And>h Ts.\n                   \\<lbrakk>hconf h; list_all2 (addr_loc_type P h a) als Ts;\n                    list_all2 (addr_loc_type P h a') als Ts\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>vs h'.\n  heap_copies a a' als h\n   (concat\n     (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n   h' \\<and>\n  hconf h';\n        hconf h; list_all2 (addr_loc_type P h a) (aa # als) Ts;\n        list_all2 (addr_loc_type P h a') (aa # als) Ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs h'.\n                            heap_copies a a' (aa # als) h\n                             (concat\n                               (map2\n                                 (\\<lambda>al v.\n                                     [ReadMem a al v, WriteMem a' al v])\n                                 (aa # als) vs))\n                             h' \\<and>\n                            hconf h'", "have \"[ReadMem a al v, WriteMem a' al v] @ (concat (map (\\<lambda>(al, v). [ReadMem a al v, WriteMem a' al v]) (zip als vs))) =\n            (concat (map (\\<lambda>(al, v). [ReadMem a al v, WriteMem a' al v]) (zip (al # als) (v # vs))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ReadMem a al v, WriteMem a' al v] @\n    concat\n     (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs) =\n    concat\n     (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) (al # als)\n       (v # vs))", "by simp"], ["proof (state)\nthis:\n  [ReadMem a al v, WriteMem a' al v] @\n  concat (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs) =\n  concat\n   (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) (al # als)\n     (v # vs))\n\ngoal (1 subgoal):\n 1. \\<And>aa als h Ts.\n       \\<lbrakk>\\<And>h Ts.\n                   \\<lbrakk>hconf h; list_all2 (addr_loc_type P h a) als Ts;\n                    list_all2 (addr_loc_type P h a') als Ts\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>vs h'.\n  heap_copies a a' als h\n   (concat\n     (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n   h' \\<and>\n  hconf h';\n        hconf h; list_all2 (addr_loc_type P h a) (aa # als) Ts;\n        list_all2 (addr_loc_type P h a') (aa # als) Ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs h'.\n                            heap_copies a a' (aa # als) h\n                             (concat\n                               (map2\n                                 (\\<lambda>al v.\n                                     [ReadMem a al v, WriteMem a' al v])\n                                 (aa # als) vs))\n                             h' \\<and>\n                            hconf h'", "finally"], ["proof (chain)\npicking this:\n  heap_copies a a' (al # als) h\n   (concat\n     (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) (al # als)\n       (v # vs)))\n   h''", "show ?case"], ["proof (prove)\nusing this:\n  heap_copies a a' (al # als) h\n   (concat\n     (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) (al # als)\n       (v # vs)))\n   h''\n\ngoal (1 subgoal):\n 1. \\<exists>vs h'.\n       heap_copies a a' (al # als) h\n        (concat\n          (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v])\n            (al # als) vs))\n        h' \\<and>\n       hconf h'", "using \\<open>hconf h''\\<close>"], ["proof (prove)\nusing this:\n  heap_copies a a' (al # als) h\n   (concat\n     (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) (al # als)\n       (v # vs)))\n   h''\n  hconf h''\n\ngoal (1 subgoal):\n 1. \\<exists>vs h'.\n       heap_copies a a' (al # als) h\n        (concat\n          (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v])\n            (al # als) vs))\n        h' \\<and>\n       hconf h'", "by blast"], ["proof (state)\nthis:\n  \\<exists>vs h'.\n     heap_copies a a' (al # als) h\n      (concat\n        (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) (al # als)\n          vs))\n      h' \\<and>\n     hconf h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma heap_clone_progress:\n  assumes wf: \"wf_prog wf_md P\"\n  and typea: \"typeof_addr h a = \\<lfloor>hT\\<rfloor>\"\n  and hconf: \"hconf h\"\n  shows \"\\<exists>h' res. heap_clone P h a h' res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>h' res. heap_clone P h a h' res", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>h' res. heap_clone P h a h' res", "from typea hconf"], ["proof (chain)\npicking this:\n  typeof_addr h a = \\<lfloor>hT\\<rfloor>\n  hconf h", "have \"is_htype P hT\""], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>hT\\<rfloor>\n  hconf h\n\ngoal (1 subgoal):\n 1. is_htype P hT", "by(rule typeof_addr_is_type)"], ["proof (state)\nthis:\n  is_htype P hT\n\ngoal (1 subgoal):\n 1. \\<exists>h' res. heap_clone P h a h' res", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>h' res. heap_clone P h a h' res", "proof(cases \"allocate h hT = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. allocate h hT = {} \\<Longrightarrow>\n    \\<exists>h' res. heap_clone P h a h' res\n 2. allocate h hT \\<noteq> {} \\<Longrightarrow>\n    \\<exists>h' res. heap_clone P h a h' res", "case True"], ["proof (state)\nthis:\n  allocate h hT = {}\n\ngoal (2 subgoals):\n 1. allocate h hT = {} \\<Longrightarrow>\n    \\<exists>h' res. heap_clone P h a h' res\n 2. allocate h hT \\<noteq> {} \\<Longrightarrow>\n    \\<exists>h' res. heap_clone P h a h' res", "with typea CloneFail[of h a hT P]"], ["proof (chain)\npicking this:\n  typeof_addr h a = \\<lfloor>hT\\<rfloor>\n  \\<lbrakk>typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n   allocate h hT = {}\\<rbrakk>\n  \\<Longrightarrow> heap_clone P h a h None\n  allocate h hT = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>hT\\<rfloor>\n  \\<lbrakk>typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n   allocate h hT = {}\\<rbrakk>\n  \\<Longrightarrow> heap_clone P h a h None\n  allocate h hT = {}\n\ngoal (1 subgoal):\n 1. \\<exists>h' res. heap_clone P h a h' res", "by auto"], ["proof (state)\nthis:\n  \\<exists>h' res. heap_clone P h a h' res\n\ngoal (1 subgoal):\n 1. allocate h hT \\<noteq> {} \\<Longrightarrow>\n    \\<exists>h' res. heap_clone P h a h' res", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. allocate h hT \\<noteq> {} \\<Longrightarrow>\n    \\<exists>h' res. heap_clone P h a h' res", "case False"], ["proof (state)\nthis:\n  allocate h hT \\<noteq> {}\n\ngoal (1 subgoal):\n 1. allocate h hT \\<noteq> {} \\<Longrightarrow>\n    \\<exists>h' res. heap_clone P h a h' res", "then"], ["proof (chain)\npicking this:\n  allocate h hT \\<noteq> {}", "obtain h' a' where new: \"(h', a') \\<in> allocate h hT\""], ["proof (prove)\nusing this:\n  allocate h hT \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>h' a'.\n        (h', a') \\<in> allocate h hT \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(rule not_empty_pairE)"], ["proof (state)\nthis:\n  (h', a') \\<in> allocate h hT\n\ngoal (1 subgoal):\n 1. allocate h hT \\<noteq> {} \\<Longrightarrow>\n    \\<exists>h' res. heap_clone P h a h' res", "hence \"h \\<unlhd> h'\""], ["proof (prove)\nusing this:\n  (h', a') \\<in> allocate h hT\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "by(rule hext_allocate)"], ["proof (state)\nthis:\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. allocate h hT \\<noteq> {} \\<Longrightarrow>\n    \\<exists>h' res. heap_clone P h a h' res", "have \"hconf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hconf h'", "using new hconf \\<open>is_htype P hT\\<close>"], ["proof (prove)\nusing this:\n  (h', a') \\<in> allocate h hT\n  hconf h\n  is_htype P hT\n\ngoal (1 subgoal):\n 1. hconf h'", "by(rule hconf_allocate_mono)"], ["proof (state)\nthis:\n  hconf h'\n\ngoal (1 subgoal):\n 1. allocate h hT \\<noteq> {} \\<Longrightarrow>\n    \\<exists>h' res. heap_clone P h a h' res", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>h' res. heap_clone P h a h' res", "proof(cases hT)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       hT = Class_type x1 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res\n 2. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res", "case [simp]: (Class_type C)"], ["proof (state)\nthis:\n  hT = Class_type C\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       hT = Class_type x1 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res\n 2. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res", "from \\<open>is_htype P hT\\<close>"], ["proof (chain)\npicking this:\n  is_htype P hT", "have \"is_class P C\""], ["proof (prove)\nusing this:\n  is_htype P hT\n\ngoal (1 subgoal):\n 1. is_class P C", "by simp"], ["proof (state)\nthis:\n  is_class P C\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       hT = Class_type x1 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res\n 2. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res", "from wf_Fields_Ex[OF wf this]"], ["proof (chain)\npicking this:\n  \\<exists>FDTs. P \\<turnstile> C has_fields FDTs", "obtain FDTs where FDTs: \"P \\<turnstile> C has_fields FDTs\""], ["proof (prove)\nusing this:\n  \\<exists>FDTs. P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. (\\<And>FDTs.\n        P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  P \\<turnstile> C has_fields FDTs\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       hT = Class_type x1 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res\n 2. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res", "let ?als = \"map (\\<lambda>((F, D), Tfm). CField D F) FDTs\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       hT = Class_type x1 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res\n 2. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res", "let ?Ts = \"map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       hT = Class_type x1 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res\n 2. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res", "from typea FDTs"], ["proof (chain)\npicking this:\n  typeof_addr h a = \\<lfloor>hT\\<rfloor>\n  P \\<turnstile> C has_fields FDTs", "have \"list_all2 (\\<lambda>al T. P,h \\<turnstile> a@al : T) ?als ?Ts\""], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>hT\\<rfloor>\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h a)\n     (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n     (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)", "unfolding list_all2_map1 list_all2_map2 list_all2_refl_conv"], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>hT\\<rfloor>\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set FDTs.\n       P,h \\<turnstile> a@(case x of\n                           (x, xa) \\<Rightarrow>\n                             (case x of\n                              (F, D) \\<Rightarrow> \\<lambda>Tfm. CField D F)\n                              xa) : (case x of\n                                     (FD, T) \\<Rightarrow>\n fst (the (map_of FDTs FD)))", "by(fastforce intro: addr_loc_type.intros simp add: has_field_def dest: weak_map_of_SomeI)"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h a)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       hT = Class_type x1 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res\n 2. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res", "hence \"list_all2 (\\<lambda>al T. P,h' \\<turnstile> a@al : T) ?als ?Ts\""], ["proof (prove)\nusing this:\n  list_all2 (addr_loc_type P h a)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h' a)\n     (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n     (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)", "by(rule list_all2_mono)(simp add: addr_loc_type_hext_mono[OF _ \\<open>h \\<unlhd> h'\\<close>] split_def)"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h' a)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       hT = Class_type x1 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res\n 2. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res", "moreover"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h' a)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       hT = Class_type x1 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res\n 2. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res", "from new \\<open>is_class P C\\<close>"], ["proof (chain)\npicking this:\n  (h', a') \\<in> allocate h hT\n  is_class P C", "have \"typeof_addr h' a' = \\<lfloor>Class_type C\\<rfloor>\""], ["proof (prove)\nusing this:\n  (h', a') \\<in> allocate h hT\n  is_class P C\n\ngoal (1 subgoal):\n 1. typeof_addr h' a' = \\<lfloor>Class_type C\\<rfloor>", "by(auto dest: allocate_SomeD)"], ["proof (state)\nthis:\n  typeof_addr h' a' = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       hT = Class_type x1 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res\n 2. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res", "with FDTs"], ["proof (chain)\npicking this:\n  P \\<turnstile> C has_fields FDTs\n  typeof_addr h' a' = \\<lfloor>Class_type C\\<rfloor>", "have \"list_all2 (\\<lambda>al T. P,h' \\<turnstile> a'@al : T) ?als ?Ts\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n  typeof_addr h' a' = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h' a')\n     (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n     (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)", "unfolding list_all2_map1 list_all2_map2 list_all2_refl_conv"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n  typeof_addr h' a' = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set FDTs.\n       P,h' \\<turnstile> a'@(case x of\n                             (x, xa) \\<Rightarrow>\n                               (case x of\n                                (F, D) \\<Rightarrow>\n                                  \\<lambda>Tfm. CField D F)\n                                xa) : (case x of\n (FD, T) \\<Rightarrow> fst (the (map_of FDTs FD)))", "by(fastforce intro: addr_loc_type.intros map_of_SomeI simp add: has_field_def dest: weak_map_of_SomeI)"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h' a')\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       hT = Class_type x1 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res\n 2. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res", "ultimately"], ["proof (chain)\npicking this:\n  list_all2 (addr_loc_type P h' a)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n  list_all2 (addr_loc_type P h' a')\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)", "obtain obs h'' where \"heap_copies a a' ?als h' obs h''\" \"hconf h''\""], ["proof (prove)\nusing this:\n  list_all2 (addr_loc_type P h' a)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n  list_all2 (addr_loc_type P h' a')\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n\ngoal (1 subgoal):\n 1. (\\<And>obs h''.\n        \\<lbrakk>heap_copies a a'\n                  (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h' obs\n                  h'';\n         hconf h''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(blast dest: heap_copies_progress[OF \\<open>hconf h'\\<close>])"], ["proof (state)\nthis:\n  heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h' obs\n   h''\n  hconf h''\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       hT = Class_type x1 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res\n 2. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res", "with typea new FDTs ObjClone[of h a C h' a' P FDTs obs h'']"], ["proof (chain)\npicking this:\n  typeof_addr h a = \\<lfloor>hT\\<rfloor>\n  (h', a') \\<in> allocate h hT\n  P \\<turnstile> C has_fields FDTs\n  \\<lbrakk>typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n   (h', a') \\<in> allocate h (Class_type C);\n   P \\<turnstile> C has_fields FDTs;\n   heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h' obs\n    h''\\<rbrakk>\n  \\<Longrightarrow> heap_clone P h a h''\n                     \\<lfloor>(NewHeapElem a' (Class_type C) # obs,\n                               a')\\<rfloor>\n  heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h' obs\n   h''\n  hconf h''", "show ?thesis"], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>hT\\<rfloor>\n  (h', a') \\<in> allocate h hT\n  P \\<turnstile> C has_fields FDTs\n  \\<lbrakk>typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n   (h', a') \\<in> allocate h (Class_type C);\n   P \\<turnstile> C has_fields FDTs;\n   heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h' obs\n    h''\\<rbrakk>\n  \\<Longrightarrow> heap_clone P h a h''\n                     \\<lfloor>(NewHeapElem a' (Class_type C) # obs,\n                               a')\\<rfloor>\n  heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h' obs\n   h''\n  hconf h''\n\ngoal (1 subgoal):\n 1. \\<exists>h' res. heap_clone P h a h' res", "by auto"], ["proof (state)\nthis:\n  \\<exists>h' res. heap_clone P h a h' res\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res", "case [simp]: (Array_type T n)"], ["proof (state)\nthis:\n  hT = Array_type T n\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res", "from wf"], ["proof (chain)\npicking this:\n  wf_prog wf_md P", "obtain FDTs where FDTs: \"P \\<turnstile> Object has_fields FDTs\""], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. (\\<And>FDTs.\n        P \\<turnstile> Object has_fields FDTs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(blast dest: wf_Fields_Ex is_class_Object)"], ["proof (state)\nthis:\n  P \\<turnstile> Object has_fields FDTs\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res", "let ?als = \"map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res", "let ?Ts = \"map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res", "from \\<open>h \\<unlhd> h'\\<close> typea"], ["proof (chain)\npicking this:\n  h \\<unlhd> h'\n  typeof_addr h a = \\<lfloor>hT\\<rfloor>", "have type'a: \"typeof_addr h' a = \\<lfloor>Array_type T n\\<rfloor>\""], ["proof (prove)\nusing this:\n  h \\<unlhd> h'\n  typeof_addr h a = \\<lfloor>hT\\<rfloor>\n\ngoal (1 subgoal):\n 1. typeof_addr h' a = \\<lfloor>Array_type T n\\<rfloor>", "by(auto intro: hext_arrD)"], ["proof (state)\nthis:\n  typeof_addr h' a = \\<lfloor>Array_type T n\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res", "from type'a FDTs"], ["proof (chain)\npicking this:\n  typeof_addr h' a = \\<lfloor>Array_type T n\\<rfloor>\n  P \\<turnstile> Object has_fields FDTs", "have \"list_all2 (\\<lambda>al T. P,h' \\<turnstile> a@al : T) ?als ?Ts\""], ["proof (prove)\nusing this:\n  typeof_addr h' a = \\<lfloor>Array_type T n\\<rfloor>\n  P \\<turnstile> Object has_fields FDTs\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h' a)\n     (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n     (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @\n      replicate n T)", "by(fastforce intro: list_all2_all_nthI addr_loc_type.intros simp add: has_field_def list_all2_append list_all2_map1 list_all2_map2 list_all2_refl_conv dest: weak_map_of_SomeI)"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h' a)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res", "moreover"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h' a)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res", "from new \\<open>is_htype P hT\\<close>"], ["proof (chain)\npicking this:\n  (h', a') \\<in> allocate h hT\n  is_htype P hT", "have \"typeof_addr h' a' = \\<lfloor>Array_type T n\\<rfloor>\""], ["proof (prove)\nusing this:\n  (h', a') \\<in> allocate h hT\n  is_htype P hT\n\ngoal (1 subgoal):\n 1. typeof_addr h' a' = \\<lfloor>Array_type T n\\<rfloor>", "by(auto dest: allocate_SomeD)"], ["proof (state)\nthis:\n  typeof_addr h' a' = \\<lfloor>Array_type T n\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res", "hence \"list_all2 (\\<lambda>al T. P,h' \\<turnstile> a'@al : T) ?als ?Ts\""], ["proof (prove)\nusing this:\n  typeof_addr h' a' = \\<lfloor>Array_type T n\\<rfloor>\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h' a')\n     (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n     (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @\n      replicate n T)", "using FDTs"], ["proof (prove)\nusing this:\n  typeof_addr h' a' = \\<lfloor>Array_type T n\\<rfloor>\n  P \\<turnstile> Object has_fields FDTs\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h' a')\n     (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n     (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @\n      replicate n T)", "by(fastforce intro: list_all2_all_nthI addr_loc_type.intros simp add: has_field_def list_all2_append list_all2_map1 list_all2_map2 list_all2_refl_conv dest: weak_map_of_SomeI)"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h' a')\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res", "ultimately"], ["proof (chain)\npicking this:\n  list_all2 (addr_loc_type P h' a)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)\n  list_all2 (addr_loc_type P h' a')\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)", "obtain obs h'' where \"heap_copies a a' ?als h' obs h''\" \"hconf h''\""], ["proof (prove)\nusing this:\n  list_all2 (addr_loc_type P h' a)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)\n  list_all2 (addr_loc_type P h' a')\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)\n\ngoal (1 subgoal):\n 1. (\\<And>obs h''.\n        \\<lbrakk>heap_copies a a'\n                  (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n                   map ACell [0..<n])\n                  h' obs h'';\n         hconf h''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(blast dest: heap_copies_progress[OF \\<open>hconf h'\\<close>])"], ["proof (state)\nthis:\n  heap_copies a a'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) h'\n   obs h''\n  hconf h''\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       \\<exists>h' res. heap_clone P h a h' res", "with typea new FDTs ArrClone[of h a T n h' a' P FDTs obs h'']"], ["proof (chain)\npicking this:\n  typeof_addr h a = \\<lfloor>hT\\<rfloor>\n  (h', a') \\<in> allocate h hT\n  P \\<turnstile> Object has_fields FDTs\n  \\<lbrakk>typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n   (h', a') \\<in> allocate h (Array_type T n);\n   P \\<turnstile> Object has_fields FDTs;\n   heap_copies a a'\n    (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) h'\n    obs h''\\<rbrakk>\n  \\<Longrightarrow> heap_clone P h a h''\n                     \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                               a')\\<rfloor>\n  heap_copies a a'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) h'\n   obs h''\n  hconf h''", "show ?thesis"], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>hT\\<rfloor>\n  (h', a') \\<in> allocate h hT\n  P \\<turnstile> Object has_fields FDTs\n  \\<lbrakk>typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n   (h', a') \\<in> allocate h (Array_type T n);\n   P \\<turnstile> Object has_fields FDTs;\n   heap_copies a a'\n    (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) h'\n    obs h''\\<rbrakk>\n  \\<Longrightarrow> heap_clone P h a h''\n                     \\<lfloor>(NewHeapElem a' (Array_type T n) # obs,\n                               a')\\<rfloor>\n  heap_copies a a'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) h'\n   obs h''\n  hconf h''\n\ngoal (1 subgoal):\n 1. \\<exists>h' res. heap_clone P h a h' res", "by auto"], ["proof (state)\nthis:\n  \\<exists>h' res. heap_clone P h a h' res\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>h' res. heap_clone P h a h' res\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>h' res. heap_clone P h a h' res\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem external_call_progress:\n  assumes wf: \"wf_prog wf_md P\"\n  and wt: \"P,h \\<turnstile> a\\<bullet>M(vs) : U\"\n  and hconf: \"hconf h\"\n  shows \"\\<exists>ta va h'. P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ta va h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                 h'\\<rangle>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ta va h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                 h'\\<rangle>", "note [simp del] = split_paired_Ex"], ["proof (state)\nthis:\n  (\\<exists>x. ?P x) = (\\<exists>a b. ?P (a, b))\n\ngoal (1 subgoal):\n 1. \\<exists>ta va h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                 h'\\<rangle>", "from wt"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> a\\<bullet>M(vs) : U", "obtain hT Ts Ts' D\n    where T: \"typeof_addr h a = \\<lfloor>hT\\<rfloor>\" and Ts: \"map typeof\\<^bsub>h\\<^esub> vs = map Some Ts\"\n    and \"P \\<turnstile> class_type_of hT sees M:Ts'\\<rightarrow>U = Native in D\" and subTs: \"P \\<turnstile> Ts [\\<le>] Ts'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> a\\<bullet>M(vs) : U\n\ngoal (1 subgoal):\n 1. (\\<And>hT Ts Ts' D.\n        \\<lbrakk>typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n         map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n         P \\<turnstile> class_type_of\n                         hT sees M: Ts'\\<rightarrow>U = Native in D;\n         P \\<turnstile> Ts [\\<le>] Ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding external_WT'_iff"], ["proof (prove)\nusing this:\n  \\<exists>hT Ts Ts' D.\n     typeof_addr h a = \\<lfloor>hT\\<rfloor> \\<and>\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts \\<and>\n     P \\<turnstile> class_type_of\n                     hT sees M: Ts'\\<rightarrow>U = Native in D \\<and>\n     P \\<turnstile> Ts [\\<le>] Ts'\n\ngoal (1 subgoal):\n 1. (\\<And>hT Ts Ts' D.\n        \\<lbrakk>typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n         map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n         P \\<turnstile> class_type_of\n                         hT sees M: Ts'\\<rightarrow>U = Native in D;\n         P \\<turnstile> Ts [\\<le>] Ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  typeof_addr h a = \\<lfloor>hT\\<rfloor>\n  map typeof\\<^bsub>h\\<^esub> vs = map Some Ts\n  P \\<turnstile> class_type_of hT sees M: Ts'\\<rightarrow>U = Native in D\n  P \\<turnstile> Ts [\\<le>] Ts'\n\ngoal (1 subgoal):\n 1. \\<exists>ta va h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                 h'\\<rangle>", "from wf \\<open>P \\<turnstile> class_type_of hT sees M:Ts'\\<rightarrow>U = Native in D\\<close>"], ["proof (chain)\npicking this:\n  wf_prog wf_md P\n  P \\<turnstile> class_type_of hT sees M: Ts'\\<rightarrow>U = Native in D", "have \"D\\<bullet>M(Ts') :: U\""], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  P \\<turnstile> class_type_of hT sees M: Ts'\\<rightarrow>U = Native in D\n\ngoal (1 subgoal):\n 1. D\\<bullet>M(Ts') :: U", "by(rule sees_wf_native)"], ["proof (state)\nthis:\n  D\\<bullet>M(Ts') :: U\n\ngoal (1 subgoal):\n 1. \\<exists>ta va h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                 h'\\<rangle>", "moreover"], ["proof (state)\nthis:\n  D\\<bullet>M(Ts') :: U\n\ngoal (1 subgoal):\n 1. \\<exists>ta va h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                 h'\\<rangle>", "from \\<open>P \\<turnstile> class_type_of hT sees M:Ts'\\<rightarrow>U = Native in D\\<close>"], ["proof (chain)\npicking this:\n  P \\<turnstile> class_type_of hT sees M: Ts'\\<rightarrow>U = Native in D", "have \"P \\<turnstile> ty_of_htype hT \\<le> Class D\""], ["proof (prove)\nusing this:\n  P \\<turnstile> class_type_of hT sees M: Ts'\\<rightarrow>U = Native in D\n\ngoal (1 subgoal):\n 1. P \\<turnstile> ty_of_htype hT \\<le> Class D", "by(cases hT)(auto dest: sees_method_decl_above intro: widen_trans widen_array_object)"], ["proof (state)\nthis:\n  P \\<turnstile> ty_of_htype hT \\<le> Class D\n\ngoal (1 subgoal):\n 1. \\<exists>ta va h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                 h'\\<rangle>", "ultimately"], ["proof (chain)\npicking this:\n  D\\<bullet>M(Ts') :: U\n  P \\<turnstile> ty_of_htype hT \\<le> Class D", "show ?thesis"], ["proof (prove)\nusing this:\n  D\\<bullet>M(Ts') :: U\n  P \\<turnstile> ty_of_htype hT \\<le> Class D\n\ngoal (1 subgoal):\n 1. \\<exists>ta va h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                 h'\\<rangle>", "using T Ts subTs"], ["proof (prove)\nusing this:\n  D\\<bullet>M(Ts') :: U\n  P \\<turnstile> ty_of_htype hT \\<le> Class D\n  typeof_addr h a = \\<lfloor>hT\\<rfloor>\n  map typeof\\<^bsub>h\\<^esub> vs = map Some Ts\n  P \\<turnstile> Ts [\\<le>] Ts'\n\ngoal (1 subgoal):\n 1. \\<exists>ta va h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                 h'\\<rangle>", "proof cases"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Thread; M = start; Ts' = [];\n     U = Void\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 2. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Thread; M = join; Ts' = [];\n     U = Void\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 3. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Thread; M = interrupt; Ts' = [];\n     U = Void\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 4. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Thread; M = isInterrupted; Ts' = [];\n     U = Boolean\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 5. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Object; M = wait; Ts' = [];\n     U = Void\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 6. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Object; M = notify; Ts' = [];\n     U = Void\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 7. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Object; M = notifyAll; Ts' = [];\n     U = Void\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 8. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Object; M = clone; Ts' = [];\n     U = Class Object\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 9. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Object; M = hashcode; Ts' = [];\n     U = Integer\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 10. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n      typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n      map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n      P \\<turnstile> Ts [\\<le>] Ts'; D = Object; M = print; Ts' = [Integer];\n      U = Void\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta va h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\nA total of 13 subgoals...", "assume [simp]: \"D = Object\" \"M = clone\" \"Ts' = []\" \"U = Class Object\""], ["proof (state)\nthis:\n  D = Object\n  M = clone\n  Ts' = []\n  U = Class Object\n\ngoal (13 subgoals):\n 1. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Thread; M = start; Ts' = [];\n     U = Void\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 2. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Thread; M = join; Ts' = [];\n     U = Void\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 3. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Thread; M = interrupt; Ts' = [];\n     U = Void\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 4. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Thread; M = isInterrupted; Ts' = [];\n     U = Boolean\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 5. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Object; M = wait; Ts' = [];\n     U = Void\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 6. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Object; M = notify; Ts' = [];\n     U = Void\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 7. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Object; M = notifyAll; Ts' = [];\n     U = Void\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 8. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Object; M = clone; Ts' = [];\n     U = Class Object\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 9. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Object; M = hashcode; Ts' = [];\n     U = Integer\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 10. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n      typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n      map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n      P \\<turnstile> Ts [\\<le>] Ts'; D = Object; M = print; Ts' = [Integer];\n      U = Void\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta va h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\nA total of 13 subgoals...", "from heap_clone_progress[OF wf T hconf]"], ["proof (chain)\npicking this:\n  \\<exists>h' res. heap_clone P h a h' res", "obtain h' res where \"heap_clone P h a h' res\""], ["proof (prove)\nusing this:\n  \\<exists>h' res. heap_clone P h a h' res\n\ngoal (1 subgoal):\n 1. (\\<And>h' res.\n        heap_clone P h a h' res \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  heap_clone P h a h' res\n\ngoal (13 subgoals):\n 1. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Thread; M = start; Ts' = [];\n     U = Void\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 2. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Thread; M = join; Ts' = [];\n     U = Void\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 3. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Thread; M = interrupt; Ts' = [];\n     U = Void\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 4. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Thread; M = isInterrupted; Ts' = [];\n     U = Boolean\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 5. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Object; M = wait; Ts' = [];\n     U = Void\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 6. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Object; M = notify; Ts' = [];\n     U = Void\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 7. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Object; M = notifyAll; Ts' = [];\n     U = Void\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 8. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Object; M = clone; Ts' = [];\n     U = Class Object\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 9. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Object; M = hashcode; Ts' = [];\n     U = Integer\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 10. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n      typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n      map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n      P \\<turnstile> Ts [\\<le>] Ts'; D = Object; M = print; Ts' = [Integer];\n      U = Void\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta va h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\nA total of 13 subgoals...", "thus ?thesis"], ["proof (prove)\nusing this:\n  heap_clone P h a h' res\n\ngoal (1 subgoal):\n 1. \\<exists>ta va h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                 h'\\<rangle>", "using subTs Ts"], ["proof (prove)\nusing this:\n  heap_clone P h a h' res\n  P \\<turnstile> Ts [\\<le>] Ts'\n  map typeof\\<^bsub>h\\<^esub> vs = map Some Ts\n\ngoal (1 subgoal):\n 1. \\<exists>ta va h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                 h'\\<rangle>", "by(cases res)(auto intro: red_external.intros)"], ["proof (state)\nthis:\n  \\<exists>ta va h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (12 subgoals):\n 1. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Thread; M = start; Ts' = [];\n     U = Void\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 2. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Thread; M = join; Ts' = [];\n     U = Void\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 3. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Thread; M = interrupt; Ts' = [];\n     U = Void\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 4. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Thread; M = isInterrupted; Ts' = [];\n     U = Boolean\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 5. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Object; M = wait; Ts' = [];\n     U = Void\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 6. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Object; M = notify; Ts' = [];\n     U = Void\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 7. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Object; M = notifyAll; Ts' = [];\n     U = Void\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 8. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Object; M = hashcode; Ts' = [];\n     U = Integer\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 9. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n     typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n     map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'; D = Object; M = print; Ts' = [Integer];\n     U = Void\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n 10. \\<lbrakk>P \\<turnstile> ty_of_htype hT \\<le> Class D;\n      typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n      map typeof\\<^bsub>h\\<^esub> vs = map Some Ts;\n      P \\<turnstile> Ts [\\<le>] Ts'; D = Object; M = currentThread;\n      Ts' = []; U = Class Thread\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta va h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\nA total of 12 subgoals...", "qed(auto simp add: widen_Class intro: red_external.intros)"], ["proof (state)\nthis:\n  \\<exists>ta va h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Lemmas for preservation of deadlocked threads\\<close>"], ["", "context heap_progress begin"], ["", "lemma red_external_wt_hconf_hext:\n  assumes wf: \"wf_prog wf_md P\"\n  and red: \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\"\n  and hext: \"h'' \\<unlhd> h\"\n  and wt: \"P,h'' \\<turnstile> a\\<bullet>M(vs) : U\"\n  and tconf: \"P,h'' \\<turnstile> t \\<surd>t\"\n  and hconf: \"hconf h''\"\n  shows \"\\<exists>ta' va' h'''. P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va', h'''\\<rangle> \\<and>\n                        collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                        collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> = collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                        collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> = collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'''.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                    h'''\\<rangle> \\<and>\n       collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>", "using red wt hext"], ["proof (prove)\nusing this:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n  P,h'' \\<turnstile> a\\<bullet>M(vs) : U\n  h'' \\<unlhd> h\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'''.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                    h'''\\<rangle> \\<and>\n       collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>", "proof cases"], ["proof (state)\ngoal (26 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = start; vs = [];\n        ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) h,\n        ThreadStart (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 2. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = start; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>;\n        va = RetEXC IllegalThreadState; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 3. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 4. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 5. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = interrupt; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 6. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = interrupt; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 7. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = isInterrupted; vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 8. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = isInterrupted; vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 9. \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n     M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'''.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                         collect_locks\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         collect_locks\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                         collect_cond_actions\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                         collect_cond_actions\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                         collect_interrupts\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                         collect_interrupts\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 10. \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n      M = wait; vs = [];\n      ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>;\n      va = RetStaySame; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'''.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                          collect_locks\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                          collect_locks\n                           \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                          collect_cond_actions\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                          collect_cond_actions\n                           \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                          collect_interrupts\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                          collect_interrupts\n                           \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\nA total of 26 subgoals...", "case (RedClone obs a')"], ["proof (state)\nthis:\n  M = clone\n  vs = []\n  ta = (K$ [], [], [], [], [], obs)\n  va = RetVal (Addr a')\n  heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\n\ngoal (26 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = start; vs = [];\n        ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) h,\n        ThreadStart (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 2. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = start; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>;\n        va = RetEXC IllegalThreadState; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 3. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 4. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 5. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = interrupt; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 6. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = interrupt; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 7. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = isInterrupted; vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 8. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = isInterrupted; vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 9. \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n     M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'''.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                         collect_locks\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         collect_locks\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                         collect_cond_actions\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                         collect_cond_actions\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                         collect_interrupts\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                         collect_interrupts\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 10. \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n      M = wait; vs = [];\n      ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>;\n      va = RetStaySame; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'''.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                          collect_locks\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                          collect_locks\n                           \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                          collect_cond_actions\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                          collect_cond_actions\n                           \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                          collect_interrupts\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                          collect_interrupts\n                           \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\nA total of 26 subgoals...", "from wt"], ["proof (chain)\npicking this:\n  P,h'' \\<turnstile> a\\<bullet>M(vs) : U", "obtain hT C Ts Ts' D\n    where T: \"typeof_addr h'' a = \\<lfloor>hT\\<rfloor>\""], ["proof (prove)\nusing this:\n  P,h'' \\<turnstile> a\\<bullet>M(vs) : U\n\ngoal (1 subgoal):\n 1. (\\<And>hT.\n        typeof_addr h'' a = \\<lfloor>hT\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding external_WT'_iff"], ["proof (prove)\nusing this:\n  \\<exists>hT Ts Ts' D.\n     typeof_addr h'' a = \\<lfloor>hT\\<rfloor> \\<and>\n     map typeof\\<^bsub>h''\\<^esub> vs = map Some Ts \\<and>\n     P \\<turnstile> class_type_of\n                     hT sees M: Ts'\\<rightarrow>U = Native in D \\<and>\n     P \\<turnstile> Ts [\\<le>] Ts'\n\ngoal (1 subgoal):\n 1. (\\<And>hT.\n        typeof_addr h'' a = \\<lfloor>hT\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  typeof_addr h'' a = \\<lfloor>hT\\<rfloor>\n\ngoal (26 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = start; vs = [];\n        ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) h,\n        ThreadStart (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 2. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = start; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>;\n        va = RetEXC IllegalThreadState; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 3. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 4. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 5. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = interrupt; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 6. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = interrupt; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 7. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = isInterrupted; vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 8. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = isInterrupted; vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 9. \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n     M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'''.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                         collect_locks\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         collect_locks\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                         collect_cond_actions\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                         collect_cond_actions\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                         collect_interrupts\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                         collect_interrupts\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 10. \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n      M = wait; vs = [];\n      ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>;\n      va = RetStaySame; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'''.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                          collect_locks\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                          collect_locks\n                           \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                          collect_cond_actions\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                          collect_cond_actions\n                           \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                          collect_interrupts\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                          collect_interrupts\n                           \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\nA total of 26 subgoals...", "from heap_clone_progress[OF wf T hconf]"], ["proof (chain)\npicking this:\n  \\<exists>h' res. heap_clone P h'' a h' res", "obtain h''' res where \"heap_clone P h'' a h''' res\""], ["proof (prove)\nusing this:\n  \\<exists>h' res. heap_clone P h'' a h' res\n\ngoal (1 subgoal):\n 1. (\\<And>h''' res.\n        heap_clone P h'' a h''' res \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  heap_clone P h'' a h''' res\n\ngoal (26 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = start; vs = [];\n        ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) h,\n        ThreadStart (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 2. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = start; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>;\n        va = RetEXC IllegalThreadState; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 3. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 4. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 5. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = interrupt; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 6. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = interrupt; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 7. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = isInterrupted; vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 8. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = isInterrupted; vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 9. \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n     M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'''.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                         collect_locks\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         collect_locks\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                         collect_cond_actions\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                         collect_cond_actions\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                         collect_interrupts\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                         collect_interrupts\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 10. \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n      M = wait; vs = [];\n      ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>;\n      va = RetStaySame; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'''.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                          collect_locks\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                          collect_locks\n                           \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                          collect_cond_actions\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                          collect_cond_actions\n                           \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                          collect_interrupts\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                          collect_interrupts\n                           \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\nA total of 26 subgoals...", "thus ?thesis"], ["proof (prove)\nusing this:\n  heap_clone P h'' a h''' res\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'''.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                    h'''\\<rangle> \\<and>\n       collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>", "using RedClone"], ["proof (prove)\nusing this:\n  heap_clone P h'' a h''' res\n  M = clone\n  vs = []\n  ta = (K$ [], [], [], [], [], obs)\n  va = RetVal (Addr a')\n  heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'''.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                    h'''\\<rangle> \\<and>\n       collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>", "by(cases res)(fastforce intro: red_external.intros)+"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'''.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'''\\<rangle> \\<and>\n     collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n     collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n     collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n     collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n\ngoal (25 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = start; vs = [];\n        ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) h,\n        ThreadStart (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 2. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = start; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>;\n        va = RetEXC IllegalThreadState; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 3. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 4. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 5. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = interrupt; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 6. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = interrupt; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 7. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = isInterrupted; vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 8. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = isInterrupted; vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 9. \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n     M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'''.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                         collect_locks\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         collect_locks\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                         collect_cond_actions\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                         collect_cond_actions\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                         collect_interrupts\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                         collect_interrupts\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 10. \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n      M = wait; vs = [];\n      ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>;\n      va = RetStaySame; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'''.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                          collect_locks\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                          collect_locks\n                           \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                          collect_cond_actions\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                          collect_cond_actions\n                           \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                          collect_interrupts\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                          collect_interrupts\n                           \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\nA total of 25 subgoals...", "next"], ["proof (state)\ngoal (25 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = start; vs = [];\n        ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) h,\n        ThreadStart (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 2. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = start; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>;\n        va = RetEXC IllegalThreadState; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 3. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 4. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 5. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = interrupt; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 6. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = interrupt; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 7. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = isInterrupted; vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 8. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = isInterrupted; vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 9. \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n     M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'''.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                         collect_locks\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         collect_locks\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                         collect_cond_actions\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                         collect_cond_actions\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                         collect_interrupts\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                         collect_interrupts\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 10. \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n      M = wait; vs = [];\n      ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>;\n      va = RetStaySame; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'''.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                          collect_locks\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                          collect_locks\n                           \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                          collect_cond_actions\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                          collect_cond_actions\n                           \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                          collect_interrupts\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                          collect_interrupts\n                           \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\nA total of 25 subgoals...", "case RedCloneFail"], ["proof (state)\nthis:\n  M = clone\n  vs = []\n  ta = \\<lbrace>\\<rbrace>\n  va = RetEXC OutOfMemory\n  heap_clone P h a h' None\n\ngoal (25 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = start; vs = [];\n        ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) h,\n        ThreadStart (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 2. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = start; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>;\n        va = RetEXC IllegalThreadState; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 3. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 4. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 5. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = interrupt; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 6. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = interrupt; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 7. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = isInterrupted; vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 8. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = isInterrupted; vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 9. \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n     M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'''.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                         collect_locks\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         collect_locks\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                         collect_cond_actions\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                         collect_cond_actions\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                         collect_interrupts\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                         collect_interrupts\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 10. \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n      M = wait; vs = [];\n      ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>;\n      va = RetStaySame; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'''.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                          collect_locks\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                          collect_locks\n                           \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                          collect_cond_actions\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                          collect_cond_actions\n                           \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                          collect_interrupts\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                          collect_interrupts\n                           \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\nA total of 25 subgoals...", "from wt"], ["proof (chain)\npicking this:\n  P,h'' \\<turnstile> a\\<bullet>M(vs) : U", "obtain hT Ts Ts'\n    where T: \"typeof_addr h'' a = \\<lfloor>hT\\<rfloor>\""], ["proof (prove)\nusing this:\n  P,h'' \\<turnstile> a\\<bullet>M(vs) : U\n\ngoal (1 subgoal):\n 1. (\\<And>hT.\n        typeof_addr h'' a = \\<lfloor>hT\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding external_WT'_iff"], ["proof (prove)\nusing this:\n  \\<exists>hT Ts Ts' D.\n     typeof_addr h'' a = \\<lfloor>hT\\<rfloor> \\<and>\n     map typeof\\<^bsub>h''\\<^esub> vs = map Some Ts \\<and>\n     P \\<turnstile> class_type_of\n                     hT sees M: Ts'\\<rightarrow>U = Native in D \\<and>\n     P \\<turnstile> Ts [\\<le>] Ts'\n\ngoal (1 subgoal):\n 1. (\\<And>hT.\n        typeof_addr h'' a = \\<lfloor>hT\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  typeof_addr h'' a = \\<lfloor>hT\\<rfloor>\n\ngoal (25 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = start; vs = [];\n        ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) h,\n        ThreadStart (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 2. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = start; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>;\n        va = RetEXC IllegalThreadState; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 3. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 4. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 5. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = interrupt; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 6. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = interrupt; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 7. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = isInterrupted; vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 8. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = isInterrupted; vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 9. \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n     M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'''.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                         collect_locks\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         collect_locks\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                         collect_cond_actions\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                         collect_cond_actions\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                         collect_interrupts\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                         collect_interrupts\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 10. \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n      M = wait; vs = [];\n      ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>;\n      va = RetStaySame; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'''.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                          collect_locks\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                          collect_locks\n                           \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                          collect_cond_actions\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                          collect_cond_actions\n                           \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                          collect_interrupts\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                          collect_interrupts\n                           \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\nA total of 25 subgoals...", "from heap_clone_progress[OF wf T hconf]"], ["proof (chain)\npicking this:\n  \\<exists>h' res. heap_clone P h'' a h' res", "obtain h''' res where \"heap_clone P h'' a h''' res\""], ["proof (prove)\nusing this:\n  \\<exists>h' res. heap_clone P h'' a h' res\n\ngoal (1 subgoal):\n 1. (\\<And>h''' res.\n        heap_clone P h'' a h''' res \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  heap_clone P h'' a h''' res\n\ngoal (25 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = start; vs = [];\n        ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) h,\n        ThreadStart (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 2. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = start; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>;\n        va = RetEXC IllegalThreadState; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 3. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 4. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 5. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = interrupt; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 6. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = interrupt; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 7. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = isInterrupted; vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 8. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = isInterrupted; vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 9. \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n     M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'''.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                         collect_locks\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         collect_locks\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                         collect_cond_actions\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                         collect_cond_actions\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                         collect_interrupts\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                         collect_interrupts\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 10. \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n      M = wait; vs = [];\n      ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>;\n      va = RetStaySame; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'''.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                          collect_locks\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                          collect_locks\n                           \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                          collect_cond_actions\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                          collect_cond_actions\n                           \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                          collect_interrupts\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                          collect_interrupts\n                           \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\nA total of 25 subgoals...", "thus ?thesis"], ["proof (prove)\nusing this:\n  heap_clone P h'' a h''' res\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'''.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                    h'''\\<rangle> \\<and>\n       collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>", "using RedCloneFail"], ["proof (prove)\nusing this:\n  heap_clone P h'' a h''' res\n  M = clone\n  vs = []\n  ta = \\<lbrace>\\<rbrace>\n  va = RetEXC OutOfMemory\n  heap_clone P h a h' None\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'''.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                    h'''\\<rangle> \\<and>\n       collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>", "by(cases res)(fastforce intro: red_external.intros)+"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'''.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'''\\<rangle> \\<and>\n     collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n     collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n     collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n     collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n\ngoal (24 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = start; vs = [];\n        ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) h,\n        ThreadStart (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 2. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = start; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>;\n        va = RetEXC IllegalThreadState; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 3. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 4. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 5. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = interrupt; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 6. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = interrupt; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 7. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = isInterrupted; vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 8. \\<And>C.\n       \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n        M = isInterrupted; vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 9. \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n     M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'''.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                         collect_locks\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         collect_locks\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                         collect_cond_actions\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                         collect_cond_actions\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                         collect_interrupts\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                         collect_interrupts\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n 10. \\<lbrakk>P,h'' \\<turnstile> a\\<bullet>M(vs) : U; h'' \\<unlhd> h;\n      M = wait; vs = [];\n      ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>;\n      va = RetStaySame; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'''.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h''\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'''\\<rangle> \\<and>\n                          collect_locks\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                          collect_locks\n                           \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                          collect_cond_actions\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                          collect_cond_actions\n                           \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                          collect_interrupts\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                          collect_interrupts\n                           \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\nA total of 24 subgoals...", "qed(fastforce simp add: ta_upd_simps elim!: external_WT'.cases intro: red_external.intros[simplified] dest: typeof_addr_hext_mono)+"], ["", "lemma red_external_wf_red:\n  assumes wf: \"wf_prog wf_md P\"\n  and red: \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>\"\n  and tconf: \"P,h \\<turnstile> t \\<surd>t\"\n  and hconf: \"hconf h\"\n  and wst: \"wset s t = None \\<or> (M = wait \\<and> (\\<exists>w. wset s t = \\<lfloor>PostWS w\\<rfloor>))\"\n  obtains ta' va' h''\n  where \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va', h''\\<rangle>\"\n  and \"final_thread.actions_ok final s t ta' \\<or> final_thread.actions_ok' s t ta' \\<and> final_thread.actions_subset ta' ta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ta' va' h''.\n        \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                                  h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                            h''\\<rangle>;\n         final_thread.actions_ok final s t ta' \\<or>\n         final_thread.actions_ok' s t ta' \\<and>\n         final_thread.actions_subset ta' ta\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h''.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h''\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "let ?a_t = \"thread_id2addr t\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h''.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h''\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "let ?t_a = \"addr2thread_id a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h''.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h''\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "from tconf"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> t \\<surd>t", "obtain C where ht: \"typeof_addr h ?a_t = \\<lfloor>Class_type C\\<rfloor>\"\n    and sub: \"P \\<turnstile> C \\<preceq>\\<^sup>* Thread\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> t \\<surd>t\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>typeof_addr h (thread_id2addr t) =\n                 \\<lfloor>Class_type C\\<rfloor>;\n         P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest: tconfD)"], ["proof (state)\nthis:\n  typeof_addr h (thread_id2addr t) = \\<lfloor>Class_type C\\<rfloor>\n  P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h''.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h''\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "show \"\\<exists>ta' va' h'. P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va', h'\\<rangle> \\<and> (final_thread.actions_ok final s t ta' \\<or> final_thread.actions_ok' s t ta' \\<and> final_thread.actions_subset ta' ta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "proof(cases \"final_thread.actions_ok' s t ta\")"], ["proof (state)\ngoal (2 subgoals):\n 1. final_thread.actions_ok' s t ta \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. \\<not> final_thread.actions_ok' s t ta \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "case True"], ["proof (state)\nthis:\n  final_thread.actions_ok' s t ta\n\ngoal (2 subgoals):\n 1. final_thread.actions_ok' s t ta \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. \\<not> final_thread.actions_ok' s t ta \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "have \"final_thread.actions_subset ta ta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final_thread.actions_subset ta ta", "by(rule final_thread.actions_subset_refl)"], ["proof (state)\nthis:\n  final_thread.actions_subset ta ta\n\ngoal (2 subgoals):\n 1. final_thread.actions_ok' s t ta \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. \\<not> final_thread.actions_ok' s t ta \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "with True red"], ["proof (chain)\npicking this:\n  final_thread.actions_ok' s t ta\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n  final_thread.actions_subset ta ta", "show ?thesis"], ["proof (prove)\nusing this:\n  final_thread.actions_ok' s t ta\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n  final_thread.actions_subset ta ta\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                h'\\<rangle> \\<and>\n     (final_thread.actions_ok final s t ta' \\<or>\n      final_thread.actions_ok' s t ta' \\<and>\n      final_thread.actions_subset ta' ta)\n\ngoal (1 subgoal):\n 1. \\<not> final_thread.actions_ok' s t ta \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> final_thread.actions_ok' s t ta \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "case False"], ["proof (state)\nthis:\n  \\<not> final_thread.actions_ok' s t ta\n\ngoal (1 subgoal):\n 1. \\<not> final_thread.actions_ok' s t ta \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "note [simp] = final_thread.actions_ok'_iff lock_ok_las'_def final_thread.cond_action_oks'_subset_Join\n      final_thread.actions_subset_iff ta_upd_simps collect_cond_actions_def collect_interrupts_def"], ["proof (state)\nthis:\n  final_thread.actions_ok' ?s ?t ?ta =\n  (lock_ok_las' (locks ?s) ?t \\<lbrace>?ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n   thread_oks (thr ?s) \\<lbrace>?ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n   final_thread.cond_action_oks' ?s ?t\n    \\<lbrace>?ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n   wset_actions_ok (wset ?s) ?t\n    \\<lbrace>?ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n   interrupt_actions_ok' (interrupts ?s)\n    \\<lbrace>?ta\\<rbrace>\\<^bsub>i\\<^esub>)\n  lock_ok_las' ?ls ?t ?las \\<equiv>\n  \\<forall>l. lock_actions_ok' (?ls $ l) ?t (?las $ l)\n  set ?cts \\<subseteq> insert Yield (range Join) \\<Longrightarrow>\n  final_thread.cond_action_oks' ?s ?t ?cts\n  final_thread.actions_subset ?ta' ?ta =\n  (collect_locks' \\<lbrace>?ta'\\<rbrace>\\<^bsub>l\\<^esub>\n   \\<subseteq> collect_locks \\<lbrace>?ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n   collect_cond_actions \\<lbrace>?ta'\\<rbrace>\\<^bsub>c\\<^esub>\n   \\<subseteq> collect_cond_actions\n                \\<lbrace>?ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n   collect_interrupts \\<lbrace>?ta'\\<rbrace>\\<^bsub>i\\<^esub>\n   \\<subseteq> collect_interrupts \\<lbrace>?ta\\<rbrace>\\<^bsub>i\\<^esub>)\n  ta_update_locks (?ls, ?nts, ?js, ?wss, ?obs) ?lta ?l =\n  (?ls(?l $:= ?ls $ ?l @ [?lta]), ?nts, ?js, ?wss, ?obs)\n  ta_update_NewThread (?ls, ?nts, ?js, ?wss, ?is, ?obs) ?nt =\n  (?ls, ?nts @ [?nt], ?js, ?wss, ?is, ?obs)\n  ta_update_Conditional (?ls, ?nts, ?js, ?wss, ?is, ?obs) ?j =\n  (?ls, ?nts, ?js @ [?j], ?wss, ?is, ?obs)\n  ta_update_wait_set (?ls, ?nts, ?js, ?wss, ?is, ?obs) ?ws =\n  (?ls, ?nts, ?js, ?wss @ [?ws], ?is, ?obs)\n  ta_update_interrupt (?ls, ?nts, ?js, ?wss, ?is, ?obs) ?i =\n  (?ls, ?nts, ?js, ?wss, ?is @ [?i], ?obs)\n  ta_update_obs (?ls, ?nts, ?js, ?wss, ?is, ?obs) ?ob =\n  (?ls, ?nts, ?js, ?wss, ?is, ?obs @ [?ob])\n  FWState.thread_action'_to_thread_action (?la, ?l) ?ta =\n  ta_update_locks ?ta ?la ?l\n  FWState.thread_action'_to_thread_action ?nt ?ta =\n  ta_update_NewThread ?ta ?nt\n  FWState.thread_action'_to_thread_action ?ca ?ta =\n  ta_update_Conditional ?ta ?ca\n  FWState.thread_action'_to_thread_action ?wa ?ta =\n  ta_update_wait_set ?ta ?wa\n  FWState.thread_action'_to_thread_action ?ia ?ta =\n  ta_update_interrupt ?ta ?ia\n  FWState.thread_action'_to_thread_action ?ob ?ta = ta_update_obs ?ta ?ob\n  collect_cond_actions ?cts = {t. Join t \\<in> set ?cts}\n  collect_interrupts ?ias = foldr collect_interrupt ?ias {}\n\ngoal (1 subgoal):\n 1. \\<not> final_thread.actions_ok' s t ta \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "note [rule del] = subsetI"], ["proof (state)\nthis:\n  (\\<And>x. x \\<in> ?A \\<Longrightarrow> x \\<in> ?B) \\<Longrightarrow>\n  ?A \\<subseteq> ?B\n\ngoal (1 subgoal):\n 1. \\<not> final_thread.actions_ok' s t ta \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "note [intro] = collect_locks'_subset_collect_locks red_external.intros[simplified]"], ["proof (state)\nthis:\n  collect_locks' ?las \\<subseteq> collect_locks ?las\n  \\<lbrakk>typeof_addr ?h ?a = \\<lfloor>Class_type ?C\\<rfloor>;\n   ?P \\<turnstile> ?C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n  \\<Longrightarrow> ?P,?t \\<turnstile> \\<langle>?a\\<bullet>start([]),\n ?h\\<rangle> -(K$ [], [NewThread (addr2thread_id ?a) (?C, run, ?a) ?h], [],\n               [], [],\n               [ThreadStart\n                 (addr2thread_id\n                   ?a)])\\<rightarrow>ext \\<langle>RetVal Unit,?h\\<rangle>\n  \\<lbrakk>typeof_addr ?h ?a = \\<lfloor>Class_type ?C\\<rfloor>;\n   ?P \\<turnstile> ?C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n  \\<Longrightarrow> ?P,?t \\<turnstile> \\<langle>?a\\<bullet>start([]),\n ?h\\<rangle> -(K$ [], [ThreadExists (addr2thread_id ?a) True], [], [], [],\n               [])\\<rightarrow>ext \\<langle>RetEXC IllegalThreadState,\n                                   ?h\\<rangle>\n  \\<lbrakk>typeof_addr ?h ?a = \\<lfloor>Class_type ?C\\<rfloor>;\n   ?P \\<turnstile> ?C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n  \\<Longrightarrow> ?P,?t \\<turnstile> \\<langle>?a\\<bullet>join([]),\n ?h\\<rangle> -(K$ [], [], [Join (addr2thread_id ?a)], [],\n               [IsInterrupted ?t False],\n               [ThreadJoin\n                 (addr2thread_id\n                   ?a)])\\<rightarrow>ext \\<langle>RetVal Unit,?h\\<rangle>\n  \\<lbrakk>typeof_addr ?h ?a = \\<lfloor>Class_type ?C\\<rfloor>;\n   ?P \\<turnstile> ?C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n  \\<Longrightarrow> ?P,?t \\<turnstile> \\<langle>?a\\<bullet>join([]),\n ?h\\<rangle> -(K$ [], [], [], [],\n               [IsInterrupted ?t True, ClearInterrupt ?t],\n               [ObsInterrupted\n                 ?t])\\<rightarrow>ext \\<langle>RetEXC InterruptedException,\n?h\\<rangle>\n  \\<lbrakk>typeof_addr ?h ?a = \\<lfloor>Class_type ?C\\<rfloor>;\n   ?P \\<turnstile> ?C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n  \\<Longrightarrow> ?P,?t \\<turnstile> \\<langle>?a\\<bullet>interrupt([]),\n ?h\\<rangle> -(K$ [], [ThreadExists (addr2thread_id ?a) True], [],\n               [WakeUp (addr2thread_id ?a)],\n               [Interrupt (addr2thread_id ?a)],\n               [ObsInterrupt\n                 (addr2thread_id\n                   ?a)])\\<rightarrow>ext \\<langle>RetVal Unit,?h\\<rangle>\n  \\<lbrakk>typeof_addr ?h ?a = \\<lfloor>Class_type ?C\\<rfloor>;\n   ?P \\<turnstile> ?C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n  \\<Longrightarrow> ?P,?t \\<turnstile> \\<langle>?a\\<bullet>interrupt([]),\n ?h\\<rangle> -(K$ [], [ThreadExists (addr2thread_id ?a) False], [], [], [],\n               [])\\<rightarrow>ext \\<langle>RetVal Unit,?h\\<rangle>\n  \\<lbrakk>typeof_addr ?h ?a = \\<lfloor>Class_type ?C\\<rfloor>;\n   ?P \\<turnstile> ?C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n  \\<Longrightarrow> ?P,?t \\<turnstile> \\<langle>?a\\<bullet>isInterrupted([]),\n ?h\\<rangle> -(K$ [], [], [], [], [IsInterrupted (addr2thread_id ?a) True],\n               [ObsInterrupted\n                 (addr2thread_id\n                   ?a)])\\<rightarrow>ext \\<langle>RetVal (Bool True),\n   ?h\\<rangle>\n  \\<lbrakk>typeof_addr ?h ?a = \\<lfloor>Class_type ?C\\<rfloor>;\n   ?P \\<turnstile> ?C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n  \\<Longrightarrow> ?P,?t \\<turnstile> \\<langle>?a\\<bullet>isInterrupted([]),\n ?h\\<rangle> -(K$ [], [], [], [], [IsInterrupted (addr2thread_id ?a) False],\n               [])\\<rightarrow>ext \\<langle>RetVal (Bool False),?h\\<rangle>\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -((K$ [])(?a $:= [Unlock, Lock]), [], [],\n                                   [],\n                                   [IsInterrupted ?t True,\n                                    ClearInterrupt ?t],\n                                   [ObsInterrupted\n                                     ?t])\\<rightarrow>ext \\<langle>RetEXC\n                              InterruptedException,\n                    ?h\\<rangle>\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -((K$ [])(?a $:= [Unlock, Lock,\n             ReleaseAcquire]),\n                                   [], [], [Suspend ?a],\n                                   [IsInterrupted ?t False],\n                                   [SyncUnlock\n                                     ?a])\\<rightarrow>ext \\<langle>RetStaySame,\n                    ?h\\<rangle>\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -((K$ [])(?a $:= [UnlockFail]), [], [], [],\n                                   [],\n                                   [])\\<rightarrow>ext \\<langle>RetEXC\n                           IllegalMonitorState,\n                 ?h\\<rangle>\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -(K$ [], [], [], [Notified], [],\n                                   [])\\<rightarrow>ext \\<langle>RetVal Unit,\n                 ?h\\<rangle>\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -(K$ [], [], [], [WokenUp],\n                                   [ClearInterrupt ?t],\n                                   [ObsInterrupted\n                                     ?t])\\<rightarrow>ext \\<langle>RetEXC\n                              InterruptedException,\n                    ?h\\<rangle>\n  spurious_wakeups \\<Longrightarrow>\n  heap_base.red_external addr2thread_id thread_id2addr True empty_heap\n   allocate typeof_addr heap_read heap_write ?P ?t ?h ?a wait []\n   ((K$ [])(?a $:= [Unlock, Lock, ReleaseAcquire]), [], [], [],\n    [IsInterrupted ?t False], [SyncUnlock ?a])\n   (RetVal Unit) ?h\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>notify([]),\n                     ?h\\<rangle> -((K$ [])(?a $:= [Unlock, Lock]), [], [],\n                                   [Notify ?a], [],\n                                   [])\\<rightarrow>ext \\<langle>RetVal Unit,\n                 ?h\\<rangle>\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>notify([]),\n                     ?h\\<rangle> -((K$ [])(?a $:= [UnlockFail]), [], [], [],\n                                   [],\n                                   [])\\<rightarrow>ext \\<langle>RetEXC\n                           IllegalMonitorState,\n                 ?h\\<rangle>\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>notifyAll([]),\n                     ?h\\<rangle> -((K$ [])(?a $:= [Unlock, Lock]), [], [],\n                                   [NotifyAll ?a], [],\n                                   [])\\<rightarrow>ext \\<langle>RetVal Unit,\n                 ?h\\<rangle>\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>notifyAll([]),\n                     ?h\\<rangle> -((K$ [])(?a $:= [UnlockFail]), [], [], [],\n                                   [],\n                                   [])\\<rightarrow>ext \\<langle>RetEXC\n                           IllegalMonitorState,\n                 ?h\\<rangle>\n  heap_clone ?P ?h ?a ?h' \\<lfloor>(?obs, ?a')\\<rfloor> \\<Longrightarrow>\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>clone([]),\n                     ?h\\<rangle> -(K$ [], [], [], [], [],\n                                   ?obs)\\<rightarrow>ext \\<langle>RetVal\n                             (Addr ?a'),\n                   ?h'\\<rangle>\n  heap_clone ?P ?h ?a ?h' None \\<Longrightarrow>\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>clone([]),\n                     ?h\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>ext \\<langle>RetEXC\n   OutOfMemory,\n                               ?h'\\<rangle>\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>hashcode([]),\n                     ?h\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>ext \\<langle>RetVal\n   (Intg (word_of_int (hash_addr ?a))),\n                               ?h\\<rangle>\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>print(?vs),\n                     ?h\\<rangle> -(K$ [], [], [], [], [],\n                                   [ExternalCall ?a print ?vs\n                                     Unit])\\<rightarrow>ext \\<langle>RetVal\n                                Unit,\n                      ?h\\<rangle>\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>currentThread([]),\n                     ?h\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>ext \\<langle>RetVal\n   (Addr (thread_id2addr ?t)),\n                               ?h\\<rangle>\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>interrupted([]),\n                     ?h\\<rangle> -(K$ [], [], [], [],\n                                   [IsInterrupted ?t True,\n                                    ClearInterrupt ?t],\n                                   [ObsInterrupted\n                                     ?t])\\<rightarrow>ext \\<langle>RetVal\n                              (Bool True),\n                    ?h\\<rangle>\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>interrupted([]),\n                     ?h\\<rangle> -(K$ [], [], [], [],\n                                   [IsInterrupted ?t False],\n                                   [])\\<rightarrow>ext \\<langle>RetVal\n                           (Bool False),\n                 ?h\\<rangle>\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>yield([]),\n                     ?h\\<rangle> -(K$ [], [], [Yield], [], [],\n                                   [])\\<rightarrow>ext \\<langle>RetVal Unit,\n                 ?h\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> final_thread.actions_ok' s t ta \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "proof(cases \"wset s t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. wset s t = None \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. \\<And>aa.\n       wset s t = \\<lfloor>aa\\<rfloor> \\<Longrightarrow>\n       \\<exists>ta' va' h'.\n          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                           h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                     h'\\<rangle> \\<and>\n          (final_thread.actions_ok final s t ta' \\<or>\n           final_thread.actions_ok' s t ta' \\<and>\n           final_thread.actions_subset ta' ta)", "case [simp]: (Some w)"], ["proof (state)\nthis:\n  wset s t = \\<lfloor>w\\<rfloor>\n\ngoal (2 subgoals):\n 1. wset s t = None \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. \\<And>aa.\n       wset s t = \\<lfloor>aa\\<rfloor> \\<Longrightarrow>\n       \\<exists>ta' va' h'.\n          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                           h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                     h'\\<rangle> \\<and>\n          (final_thread.actions_ok final s t ta' \\<or>\n           final_thread.actions_ok' s t ta' \\<and>\n           final_thread.actions_subset ta' ta)", "with wst"], ["proof (chain)\npicking this:\n  wset s t = None \\<or>\n  M = wait \\<and> (\\<exists>w. wset s t = \\<lfloor>PostWS w\\<rfloor>)\n  wset s t = \\<lfloor>w\\<rfloor>", "obtain w' where [simp]: \"w = PostWS w'\" \"M = wait\""], ["proof (prove)\nusing this:\n  wset s t = None \\<or>\n  M = wait \\<and> (\\<exists>w. wset s t = \\<lfloor>PostWS w\\<rfloor>)\n  wset s t = \\<lfloor>w\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>w'.\n        \\<lbrakk>w = PostWS w'; M = wait\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w = PostWS w'\n  M = wait\n\ngoal (2 subgoals):\n 1. wset s t = None \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. \\<And>aa.\n       wset s t = \\<lfloor>aa\\<rfloor> \\<Longrightarrow>\n       \\<exists>ta' va' h'.\n          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                           h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                     h'\\<rangle> \\<and>\n          (final_thread.actions_ok final s t ta' \\<or>\n           final_thread.actions_ok' s t ta' \\<and>\n           final_thread.actions_subset ta' ta)", "from red"], ["proof (chain)\npicking this:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>", "have [simp]: \"vs = []\""], ["proof (prove)\nusing this:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (1 subgoal):\n 1. vs = []", "by(auto elim: red_external.cases)"], ["proof (state)\nthis:\n  vs = []\n\ngoal (2 subgoals):\n 1. wset s t = None \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. \\<And>aa.\n       wset s t = \\<lfloor>aa\\<rfloor> \\<Longrightarrow>\n       \\<exists>ta' va' h'.\n          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                           h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                     h'\\<rangle> \\<and>\n          (final_thread.actions_ok final s t ta' \\<or>\n           final_thread.actions_ok' s t ta' \\<and>\n           final_thread.actions_subset ta' ta)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "proof(cases w')"], ["proof (state)\ngoal (2 subgoals):\n 1. w' = WSNotified \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. w' = WSWokenUp \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "case [simp]: WSWokenUp"], ["proof (state)\nthis:\n  w' = WSWokenUp\n\ngoal (2 subgoals):\n 1. w' = WSNotified \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. w' = WSWokenUp \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "let ?ta' = \"\\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>\""], ["proof (state)\ngoal (2 subgoals):\n 1. w' = WSNotified \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. w' = WSWokenUp \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "have \"final_thread.actions_ok' s t ?ta'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final_thread.actions_ok' s t \\<lbrace>WokenUp, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>", "by(simp add: wset_actions_ok_def)"], ["proof (state)\nthis:\n  final_thread.actions_ok' s t \\<lbrace>WokenUp, ClearInterrupt t,\n   ObsInterrupted t\\<rbrace>\n\ngoal (2 subgoals):\n 1. w' = WSNotified \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. w' = WSWokenUp \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_ok' s t \\<lbrace>WokenUp, ClearInterrupt t,\n   ObsInterrupted t\\<rbrace>\n\ngoal (2 subgoals):\n 1. w' = WSNotified \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. w' = WSWokenUp \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "have \"final_thread.actions_subset ?ta' ta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final_thread.actions_subset \\<lbrace>WokenUp, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace> ta", "by(auto simp add: collect_locks'_def finfun_upd_apply)"], ["proof (state)\nthis:\n  final_thread.actions_subset \\<lbrace>WokenUp, ClearInterrupt t,\n   ObsInterrupted t\\<rbrace> ta\n\ngoal (2 subgoals):\n 1. w' = WSNotified \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. w' = WSWokenUp \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_subset \\<lbrace>WokenUp, ClearInterrupt t,\n   ObsInterrupted t\\<rbrace> ta\n\ngoal (2 subgoals):\n 1. w' = WSNotified \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. w' = WSWokenUp \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "from RedWaitInterrupted"], ["proof (chain)\npicking this:\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -\\<lbrace>WokenUp,\n  ClearInterrupt ?t,\n  ObsInterrupted\n   ?t\\<rbrace>\\<rightarrow>ext \\<langle>RetEXC InterruptedException,\n                               ?h\\<rangle>", "have \"\\<exists>va h'. P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -?ta'\\<rightarrow>ext \\<langle>va,h'\\<rangle>\""], ["proof (prove)\nusing this:\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -\\<lbrace>WokenUp,\n  ClearInterrupt ?t,\n  ObsInterrupted\n   ?t\\<rbrace>\\<rightarrow>ext \\<langle>RetEXC InterruptedException,\n                               ?h\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>va h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -\\<lbrace>WokenUp,\n       ClearInterrupt t,\n       ObsInterrupted t\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>", "by auto"], ["proof (state)\nthis:\n  \\<exists>va h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -\\<lbrace>WokenUp,\n     ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (2 subgoals):\n 1. w' = WSNotified \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. w' = WSWokenUp \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "ultimately"], ["proof (chain)\npicking this:\n  final_thread.actions_ok' s t \\<lbrace>WokenUp, ClearInterrupt t,\n   ObsInterrupted t\\<rbrace>\n  final_thread.actions_subset \\<lbrace>WokenUp, ClearInterrupt t,\n   ObsInterrupted t\\<rbrace> ta\n  \\<exists>va h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -\\<lbrace>WokenUp,\n     ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  final_thread.actions_ok' s t \\<lbrace>WokenUp, ClearInterrupt t,\n   ObsInterrupted t\\<rbrace>\n  final_thread.actions_subset \\<lbrace>WokenUp, ClearInterrupt t,\n   ObsInterrupted t\\<rbrace> ta\n  \\<exists>va h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -\\<lbrace>WokenUp,\n     ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                h'\\<rangle> \\<and>\n     (final_thread.actions_ok final s t ta' \\<or>\n      final_thread.actions_ok' s t ta' \\<and>\n      final_thread.actions_subset ta' ta)\n\ngoal (1 subgoal):\n 1. w' = WSNotified \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. w' = WSNotified \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "case [simp]: WSNotified"], ["proof (state)\nthis:\n  w' = WSNotified\n\ngoal (1 subgoal):\n 1. w' = WSNotified \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "let ?ta' = \"\\<lbrace>Notified\\<rbrace>\""], ["proof (state)\ngoal (1 subgoal):\n 1. w' = WSNotified \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "have \"final_thread.actions_ok' s t ?ta'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final_thread.actions_ok' s t \\<lbrace>Notified\\<rbrace>", "by(simp add: wset_actions_ok_def)"], ["proof (state)\nthis:\n  final_thread.actions_ok' s t \\<lbrace>Notified\\<rbrace>\n\ngoal (1 subgoal):\n 1. w' = WSNotified \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_ok' s t \\<lbrace>Notified\\<rbrace>\n\ngoal (1 subgoal):\n 1. w' = WSNotified \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "have \"final_thread.actions_subset ?ta' ta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final_thread.actions_subset \\<lbrace>Notified\\<rbrace> ta", "by(auto simp add: collect_locks'_def finfun_upd_apply)"], ["proof (state)\nthis:\n  final_thread.actions_subset \\<lbrace>Notified\\<rbrace> ta\n\ngoal (1 subgoal):\n 1. w' = WSNotified \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_subset \\<lbrace>Notified\\<rbrace> ta\n\ngoal (1 subgoal):\n 1. w' = WSNotified \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "from RedWaitNotified"], ["proof (chain)\npicking this:\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -\\<lbrace>Notified\\<rbrace>\\<rightarrow>ext \\<langle>RetVal\n           Unit,\n ?h\\<rangle>", "have \"\\<exists>va h'. P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -?ta'\\<rightarrow>ext \\<langle>va,h'\\<rangle>\""], ["proof (prove)\nusing this:\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -\\<lbrace>Notified\\<rbrace>\\<rightarrow>ext \\<langle>RetVal\n           Unit,\n ?h\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>va h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -\\<lbrace>Notified\\<rbrace>\\<rightarrow>ext \\<langle>va,\n   h'\\<rangle>", "by auto"], ["proof (state)\nthis:\n  \\<exists>va h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -\\<lbrace>Notified\\<rbrace>\\<rightarrow>ext \\<langle>va,\n h'\\<rangle>\n\ngoal (1 subgoal):\n 1. w' = WSNotified \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "ultimately"], ["proof (chain)\npicking this:\n  final_thread.actions_ok' s t \\<lbrace>Notified\\<rbrace>\n  final_thread.actions_subset \\<lbrace>Notified\\<rbrace> ta\n  \\<exists>va h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -\\<lbrace>Notified\\<rbrace>\\<rightarrow>ext \\<langle>va,\n h'\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  final_thread.actions_ok' s t \\<lbrace>Notified\\<rbrace>\n  final_thread.actions_subset \\<lbrace>Notified\\<rbrace> ta\n  \\<exists>va h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -\\<lbrace>Notified\\<rbrace>\\<rightarrow>ext \\<langle>va,\n h'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                h'\\<rangle> \\<and>\n     (final_thread.actions_ok final s t ta' \\<or>\n      final_thread.actions_ok' s t ta' \\<and>\n      final_thread.actions_subset ta' ta)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                h'\\<rangle> \\<and>\n     (final_thread.actions_ok final s t ta' \\<or>\n      final_thread.actions_ok' s t ta' \\<and>\n      final_thread.actions_subset ta' ta)\n\ngoal (1 subgoal):\n 1. wset s t = None \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. wset s t = None \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "case None"], ["proof (state)\nthis:\n  wset s t = None\n\ngoal (1 subgoal):\n 1. wset s t = None \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "from red False"], ["proof (chain)\npicking this:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n  \\<not> final_thread.actions_ok' s t ta", "show ?thesis"], ["proof (prove)\nusing this:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n  \\<not> final_thread.actions_ok' s t ta\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "proof cases"], ["proof (state)\ngoal (26 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = start; vs = [];\n        ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) h,\n        ThreadStart (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = start; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>;\n        va = RetEXC IllegalThreadState; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 7. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 8. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>;\n      va = RetStaySame; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 26 subgoals...", "case (RedNewThread C)"], ["proof (state)\nthis:\n  M = start\n  vs = []\n  ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) h,\n  ThreadStart (addr2thread_id a)\\<rbrace>\n  va = RetVal Unit\n  h' = h\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n\ngoal (26 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = start; vs = [];\n        ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) h,\n        ThreadStart (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = start; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>;\n        va = RetEXC IllegalThreadState; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 7. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 8. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>;\n      va = RetStaySame; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 26 subgoals...", "note ta = \\<open>ta = \\<lbrace>NewThread ?t_a (C, run, a) h, ThreadStart ?t_a\\<rbrace>\\<close>"], ["proof (state)\nthis:\n  ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) h,\n  ThreadStart (addr2thread_id a)\\<rbrace>\n\ngoal (26 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = start; vs = [];\n        ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) h,\n        ThreadStart (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = start; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>;\n        va = RetEXC IllegalThreadState; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 7. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 8. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>;\n      va = RetStaySame; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 26 subgoals...", "let ?ta' = \"\\<lbrace>ThreadExists ?t_a True\\<rbrace>\""], ["proof (state)\ngoal (26 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = start; vs = [];\n        ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) h,\n        ThreadStart (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = start; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>;\n        va = RetEXC IllegalThreadState; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 7. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 8. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>;\n      va = RetStaySame; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 26 subgoals...", "from ta False None"], ["proof (chain)\npicking this:\n  ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) h,\n  ThreadStart (addr2thread_id a)\\<rbrace>\n  \\<not> final_thread.actions_ok' s t ta\n  wset s t = None", "have \"final_thread.actions_ok' s t ?ta'\""], ["proof (prove)\nusing this:\n  ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) h,\n  ThreadStart (addr2thread_id a)\\<rbrace>\n  \\<not> final_thread.actions_ok' s t ta\n  wset s t = None\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok' s t\n     \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>", "by(auto)"], ["proof (state)\nthis:\n  final_thread.actions_ok' s t\n   \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>\n\ngoal (26 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = start; vs = [];\n        ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) h,\n        ThreadStart (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = start; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>;\n        va = RetEXC IllegalThreadState; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 7. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 8. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>;\n      va = RetStaySame; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 26 subgoals...", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_ok' s t\n   \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>\n\ngoal (26 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = start; vs = [];\n        ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) h,\n        ThreadStart (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = start; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>;\n        va = RetEXC IllegalThreadState; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 7. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 8. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>;\n      va = RetStaySame; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 26 subgoals...", "from ta"], ["proof (chain)\npicking this:\n  ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) h,\n  ThreadStart (addr2thread_id a)\\<rbrace>", "have \"final_thread.actions_subset ?ta' ta\""], ["proof (prove)\nusing this:\n  ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) h,\n  ThreadStart (addr2thread_id a)\\<rbrace>\n\ngoal (1 subgoal):\n 1. final_thread.actions_subset\n     \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace> ta", "by(auto)"], ["proof (state)\nthis:\n  final_thread.actions_subset\n   \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace> ta\n\ngoal (26 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = start; vs = [];\n        ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) h,\n        ThreadStart (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = start; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>;\n        va = RetEXC IllegalThreadState; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 7. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 8. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>;\n      va = RetStaySame; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 26 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  final_thread.actions_ok' s t\n   \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>\n  final_thread.actions_subset\n   \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace> ta", "show ?thesis"], ["proof (prove)\nusing this:\n  final_thread.actions_ok' s t\n   \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>\n  final_thread.actions_subset\n   \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace> ta\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "using RedNewThread"], ["proof (prove)\nusing this:\n  final_thread.actions_ok' s t\n   \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>\n  final_thread.actions_subset\n   \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace> ta\n  M = start\n  vs = []\n  ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) h,\n  ThreadStart (addr2thread_id a)\\<rbrace>\n  va = RetVal Unit\n  h' = h\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "by(fastforce)"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                h'\\<rangle> \\<and>\n     (final_thread.actions_ok final s t ta' \\<or>\n      final_thread.actions_ok' s t ta' \\<and>\n      final_thread.actions_subset ta' ta)\n\ngoal (25 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = start; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>;\n        va = RetEXC IllegalThreadState; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 7. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n      va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 25 subgoals...", "next"], ["proof (state)\ngoal (25 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = start; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>;\n        va = RetEXC IllegalThreadState; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 7. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n      va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 25 subgoals...", "case RedNewThreadFail"], ["proof (state)\nthis:\n  M = start\n  vs = []\n  ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>\n  va = RetEXC IllegalThreadState\n  h' = h\n  typeof_addr h a = \\<lfloor>Class_type C_\\<rfloor>\n  P \\<turnstile> C_ \\<preceq>\\<^sup>* Thread\n\ngoal (25 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = start; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>;\n        va = RetEXC IllegalThreadState; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 7. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n      va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 25 subgoals...", "then"], ["proof (chain)\npicking this:\n  M = start\n  vs = []\n  ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>\n  va = RetEXC IllegalThreadState\n  h' = h\n  typeof_addr h a = \\<lfloor>Class_type C_\\<rfloor>\n  P \\<turnstile> C_ \\<preceq>\\<^sup>* Thread", "obtain va' h' x where \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -\\<lbrace>NewThread ?t_a x h', ThreadStart ?t_a\\<rbrace>\\<rightarrow>ext \\<langle>va', h'\\<rangle>\""], ["proof (prove)\nusing this:\n  M = start\n  vs = []\n  ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>\n  va = RetEXC IllegalThreadState\n  h' = h\n  typeof_addr h a = \\<lfloor>Class_type C_\\<rfloor>\n  P \\<turnstile> C_ \\<preceq>\\<^sup>* Thread\n\ngoal (1 subgoal):\n 1. (\\<And>x h' va'.\n        P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                         h\\<rangle> -\\<lbrace>NewThread (addr2thread_id a) x\n         h',\n        ThreadStart\n         (addr2thread_id\n           a)\\<rbrace>\\<rightarrow>ext \\<langle>va',\n h'\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce)"], ["proof (state)\nthis:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>NewThread (addr2thread_id a) x h',\n  ThreadStart\n   (addr2thread_id a)\\<rbrace>\\<rightarrow>ext \\<langle>va',h'\\<rangle>\n\ngoal (25 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = start; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>;\n        va = RetEXC IllegalThreadState; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 7. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n      va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 25 subgoals...", "moreover"], ["proof (state)\nthis:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>NewThread (addr2thread_id a) x h',\n  ThreadStart\n   (addr2thread_id a)\\<rbrace>\\<rightarrow>ext \\<langle>va',h'\\<rangle>\n\ngoal (25 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = start; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>;\n        va = RetEXC IllegalThreadState; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 7. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n      va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 25 subgoals...", "from \\<open>ta = \\<lbrace>ThreadExists ?t_a True\\<rbrace>\\<close> False None"], ["proof (chain)\npicking this:\n  ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>\n  \\<not> final_thread.actions_ok' s t ta\n  wset s t = None", "have \"final_thread.actions_ok' s t \\<lbrace>NewThread ?t_a x h', ThreadStart ?t_a\\<rbrace>\""], ["proof (prove)\nusing this:\n  ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>\n  \\<not> final_thread.actions_ok' s t ta\n  wset s t = None\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok' s t \\<lbrace>NewThread (addr2thread_id a) x h',\n     ThreadStart (addr2thread_id a)\\<rbrace>", "by(auto)"], ["proof (state)\nthis:\n  final_thread.actions_ok' s t \\<lbrace>NewThread (addr2thread_id a) x h',\n   ThreadStart (addr2thread_id a)\\<rbrace>\n\ngoal (25 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = start; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>;\n        va = RetEXC IllegalThreadState; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 7. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n      va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 25 subgoals...", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_ok' s t \\<lbrace>NewThread (addr2thread_id a) x h',\n   ThreadStart (addr2thread_id a)\\<rbrace>\n\ngoal (25 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = start; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>;\n        va = RetEXC IllegalThreadState; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 7. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n      va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 25 subgoals...", "from \\<open>ta = \\<lbrace>ThreadExists ?t_a True\\<rbrace>\\<close>"], ["proof (chain)\npicking this:\n  ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>", "have \"final_thread.actions_subset \\<lbrace>NewThread ?t_a x h', ThreadStart ?t_a\\<rbrace> ta\""], ["proof (prove)\nusing this:\n  ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>\n\ngoal (1 subgoal):\n 1. final_thread.actions_subset \\<lbrace>NewThread (addr2thread_id a) x h',\n     ThreadStart (addr2thread_id a)\\<rbrace> ta", "by(auto)"], ["proof (state)\nthis:\n  final_thread.actions_subset \\<lbrace>NewThread (addr2thread_id a) x h',\n   ThreadStart (addr2thread_id a)\\<rbrace> ta\n\ngoal (25 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = start; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>;\n        va = RetEXC IllegalThreadState; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 7. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n      va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 25 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>NewThread (addr2thread_id a) x h',\n  ThreadStart\n   (addr2thread_id a)\\<rbrace>\\<rightarrow>ext \\<langle>va',h'\\<rangle>\n  final_thread.actions_ok' s t \\<lbrace>NewThread (addr2thread_id a) x h',\n   ThreadStart (addr2thread_id a)\\<rbrace>\n  final_thread.actions_subset \\<lbrace>NewThread (addr2thread_id a) x h',\n   ThreadStart (addr2thread_id a)\\<rbrace> ta", "show ?thesis"], ["proof (prove)\nusing this:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>NewThread (addr2thread_id a) x h',\n  ThreadStart\n   (addr2thread_id a)\\<rbrace>\\<rightarrow>ext \\<langle>va',h'\\<rangle>\n  final_thread.actions_ok' s t \\<lbrace>NewThread (addr2thread_id a) x h',\n   ThreadStart (addr2thread_id a)\\<rbrace>\n  final_thread.actions_subset \\<lbrace>NewThread (addr2thread_id a) x h',\n   ThreadStart (addr2thread_id a)\\<rbrace> ta\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                h'\\<rangle> \\<and>\n     (final_thread.actions_ok final s t ta' \\<or>\n      final_thread.actions_ok' s t ta' \\<and>\n      final_thread.actions_subset ta' ta)\n\ngoal (24 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 24 subgoals...", "next"], ["proof (state)\ngoal (24 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 24 subgoals...", "case RedJoin"], ["proof (state)\nthis:\n  M = join\n  vs = []\n  ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n  ThreadJoin (addr2thread_id a)\\<rbrace>\n  va = RetVal Unit\n  h' = h\n  typeof_addr h a = \\<lfloor>Class_type C_\\<rfloor>\n  P \\<turnstile> C_ \\<preceq>\\<^sup>* Thread\n\ngoal (24 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 24 subgoals...", "let ?ta = \"\\<lbrace>IsInterrupted t True, ClearInterrupt t, ObsInterrupted t\\<rbrace>\""], ["proof (state)\ngoal (24 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 24 subgoals...", "from \\<open>ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False, ThreadJoin (addr2thread_id a)\\<rbrace>\\<close> None False"], ["proof (chain)\npicking this:\n  ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n  ThreadJoin (addr2thread_id a)\\<rbrace>\n  wset s t = None\n  \\<not> final_thread.actions_ok' s t ta", "have \"t \\<in> interrupts s\""], ["proof (prove)\nusing this:\n  ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n  ThreadJoin (addr2thread_id a)\\<rbrace>\n  wset s t = None\n  \\<not> final_thread.actions_ok' s t ta\n\ngoal (1 subgoal):\n 1. t \\<in> interrupts s", "by(auto)"], ["proof (state)\nthis:\n  t \\<in> interrupts s\n\ngoal (24 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 24 subgoals...", "hence \"final_thread.actions_ok final s t ?ta\""], ["proof (prove)\nusing this:\n  t \\<in> interrupts s\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok final s t \\<lbrace>IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>", "using None"], ["proof (prove)\nusing this:\n  t \\<in> interrupts s\n  wset s t = None\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok final s t \\<lbrace>IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>", "by(auto simp add: final_thread.actions_ok_iff final_thread.cond_action_oks.simps)"], ["proof (state)\nthis:\n  final_thread.actions_ok final s t \\<lbrace>IsInterrupted t True,\n   ClearInterrupt t, ObsInterrupted t\\<rbrace>\n\ngoal (24 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 24 subgoals...", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_ok final s t \\<lbrace>IsInterrupted t True,\n   ClearInterrupt t, ObsInterrupted t\\<rbrace>\n\ngoal (24 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 24 subgoals...", "obtain va h' where \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -?ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>va h'.\n        P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                         h\\<rangle> -\\<lbrace>IsInterrupted t True,\n        ClearInterrupt t,\n        ObsInterrupted\n         t\\<rbrace>\\<rightarrow>ext \\<langle>va,\n                                    h'\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using RedJoinInterrupt RedJoin"], ["proof (prove)\nusing this:\n  \\<lbrakk>typeof_addr ?h ?a = \\<lfloor>Class_type ?C\\<rfloor>;\n   ?P \\<turnstile> ?C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n  \\<Longrightarrow> ?P,?t \\<turnstile> \\<langle>?a\\<bullet>join([]),\n ?h\\<rangle> -\\<lbrace>IsInterrupted ?t True,\n                    ClearInterrupt ?t,\n                    ObsInterrupted\n                     ?t\\<rbrace>\\<rightarrow>ext \\<langle>RetEXC\n                     InterruptedException,\n           ?h\\<rangle>\n  M = join\n  vs = []\n  ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n  ThreadJoin (addr2thread_id a)\\<rbrace>\n  va = RetVal Unit\n  h' = h\n  typeof_addr h a = \\<lfloor>Class_type C_\\<rfloor>\n  P \\<turnstile> C_ \\<preceq>\\<^sup>* Thread\n\ngoal (1 subgoal):\n 1. (\\<And>va h'.\n        P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                         h\\<rangle> -\\<lbrace>IsInterrupted t True,\n        ClearInterrupt t,\n        ObsInterrupted\n         t\\<rbrace>\\<rightarrow>ext \\<langle>va,\n                                    h'\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>IsInterrupted t True,\n  ClearInterrupt t,\n  ObsInterrupted t\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (24 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 24 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  final_thread.actions_ok final s t \\<lbrace>IsInterrupted t True,\n   ClearInterrupt t, ObsInterrupted t\\<rbrace>\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>IsInterrupted t True,\n  ClearInterrupt t,\n  ObsInterrupted t\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  final_thread.actions_ok final s t \\<lbrace>IsInterrupted t True,\n   ClearInterrupt t, ObsInterrupted t\\<rbrace>\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>IsInterrupted t True,\n  ClearInterrupt t,\n  ObsInterrupted t\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                h'\\<rangle> \\<and>\n     (final_thread.actions_ok final s t ta' \\<or>\n      final_thread.actions_ok' s t ta' \\<and>\n      final_thread.actions_subset ta' ta)\n\ngoal (23 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n      va = RetEXC InterruptedException; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 23 subgoals...", "next"], ["proof (state)\ngoal (23 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n      va = RetEXC InterruptedException; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 23 subgoals...", "case RedJoinInterrupt"], ["proof (state)\nthis:\n  M = join\n  vs = []\n  ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n  ObsInterrupted t\\<rbrace>\n  va = RetEXC InterruptedException\n  h' = h\n  typeof_addr h a = \\<lfloor>Class_type C_\\<rfloor>\n  P \\<turnstile> C_ \\<preceq>\\<^sup>* Thread\n\ngoal (23 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n      va = RetEXC InterruptedException; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 23 subgoals...", "hence False"], ["proof (prove)\nusing this:\n  M = join\n  vs = []\n  ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n  ObsInterrupted t\\<rbrace>\n  va = RetEXC InterruptedException\n  h' = h\n  typeof_addr h a = \\<lfloor>Class_type C_\\<rfloor>\n  P \\<turnstile> C_ \\<preceq>\\<^sup>* Thread\n\ngoal (1 subgoal):\n 1. False", "using False None"], ["proof (prove)\nusing this:\n  M = join\n  vs = []\n  ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n  ObsInterrupted t\\<rbrace>\n  va = RetEXC InterruptedException\n  h' = h\n  typeof_addr h a = \\<lfloor>Class_type C_\\<rfloor>\n  P \\<turnstile> C_ \\<preceq>\\<^sup>* Thread\n  \\<not> final_thread.actions_ok' s t ta\n  wset s t = None\n\ngoal (1 subgoal):\n 1. False", "by(auto)"], ["proof (state)\nthis:\n  False\n\ngoal (23 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n      va = RetEXC InterruptedException; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 23 subgoals...", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", ".."], ["proof (state)\nthis:\n  \\<exists>ta' va' h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                h'\\<rangle> \\<and>\n     (final_thread.actions_ok final s t ta' \\<or>\n      final_thread.actions_ok' s t ta' \\<and>\n      final_thread.actions_subset ta' ta)\n\ngoal (22 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>;\n      va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 22 subgoals...", "next"], ["proof (state)\ngoal (22 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>;\n      va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 22 subgoals...", "case RedInterrupt"], ["proof (state)\nthis:\n  M = interrupt\n  vs = []\n  ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n  WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n  ObsInterrupt (addr2thread_id a)\\<rbrace>\n  va = RetVal Unit\n  h' = h\n  typeof_addr h a = \\<lfloor>Class_type C_\\<rfloor>\n  P \\<turnstile> C_ \\<preceq>\\<^sup>* Thread\n\ngoal (22 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>;\n      va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 22 subgoals...", "let ?ta = \"\\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>\""], ["proof (state)\ngoal (22 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>;\n      va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 22 subgoals...", "from RedInterrupt None False"], ["proof (chain)\npicking this:\n  M = interrupt\n  vs = []\n  ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n  WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n  ObsInterrupt (addr2thread_id a)\\<rbrace>\n  va = RetVal Unit\n  h' = h\n  typeof_addr h a = \\<lfloor>Class_type C_\\<rfloor>\n  P \\<turnstile> C_ \\<preceq>\\<^sup>* Thread\n  wset s t = None\n  \\<not> final_thread.actions_ok' s t ta", "have \"free_thread_id (thr s) (addr2thread_id a)\""], ["proof (prove)\nusing this:\n  M = interrupt\n  vs = []\n  ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n  WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n  ObsInterrupt (addr2thread_id a)\\<rbrace>\n  va = RetVal Unit\n  h' = h\n  typeof_addr h a = \\<lfloor>Class_type C_\\<rfloor>\n  P \\<turnstile> C_ \\<preceq>\\<^sup>* Thread\n  wset s t = None\n  \\<not> final_thread.actions_ok' s t ta\n\ngoal (1 subgoal):\n 1. free_thread_id (thr s) (addr2thread_id a)", "by(auto simp add: wset_actions_ok_def)"], ["proof (state)\nthis:\n  free_thread_id (thr s) (addr2thread_id a)\n\ngoal (22 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>;\n      va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 22 subgoals...", "hence \"final_thread.actions_ok final s t ?ta\""], ["proof (prove)\nusing this:\n  free_thread_id (thr s) (addr2thread_id a)\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok final s t\n     \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>", "using None"], ["proof (prove)\nusing this:\n  free_thread_id (thr s) (addr2thread_id a)\n  wset s t = None\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok final s t\n     \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>", "by(auto simp add: final_thread.actions_ok_iff final_thread.cond_action_oks.simps)"], ["proof (state)\nthis:\n  final_thread.actions_ok final s t\n   \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>\n\ngoal (22 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>;\n      va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 22 subgoals...", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_ok final s t\n   \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>\n\ngoal (22 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>;\n      va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 22 subgoals...", "obtain va h' where \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -?ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>va h'.\n        P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                         h\\<rangle> -\\<lbrace>ThreadExists\n         (addr2thread_id a)\n         False\\<rbrace>\\<rightarrow>ext \\<langle>va,\n  h'\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using RedInterruptInexist RedInterrupt"], ["proof (prove)\nusing this:\n  \\<lbrakk>typeof_addr ?h ?a = \\<lfloor>Class_type ?C\\<rfloor>;\n   ?P \\<turnstile> ?C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n  \\<Longrightarrow> ?P,?t \\<turnstile> \\<langle>?a\\<bullet>interrupt([]),\n ?h\\<rangle> -\\<lbrace>ThreadExists (addr2thread_id ?a)\n                        False\\<rbrace>\\<rightarrow>ext \\<langle>RetVal Unit,\n                 ?h\\<rangle>\n  M = interrupt\n  vs = []\n  ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n  WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n  ObsInterrupt (addr2thread_id a)\\<rbrace>\n  va = RetVal Unit\n  h' = h\n  typeof_addr h a = \\<lfloor>Class_type C_\\<rfloor>\n  P \\<turnstile> C_ \\<preceq>\\<^sup>* Thread\n\ngoal (1 subgoal):\n 1. (\\<And>va h'.\n        P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                         h\\<rangle> -\\<lbrace>ThreadExists\n         (addr2thread_id a)\n         False\\<rbrace>\\<rightarrow>ext \\<langle>va,\n  h'\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>ThreadExists (addr2thread_id a)\n   False\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (22 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n      ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>;\n      va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 22 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  final_thread.actions_ok final s t\n   \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>ThreadExists (addr2thread_id a)\n   False\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  final_thread.actions_ok final s t\n   \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>ThreadExists (addr2thread_id a)\n   False\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                h'\\<rangle> \\<and>\n     (final_thread.actions_ok final s t ta' \\<or>\n      final_thread.actions_ok' s t ta' \\<and>\n      final_thread.actions_subset ta' ta)\n\ngoal (21 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n      ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n      va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 21 subgoals...", "next"], ["proof (state)\ngoal (21 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n      ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n      va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 21 subgoals...", "case RedInterruptInexist"], ["proof (state)\nthis:\n  M = interrupt\n  vs = []\n  ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>\n  va = RetVal Unit\n  h' = h\n  typeof_addr h a = \\<lfloor>Class_type C_\\<rfloor>\n  P \\<turnstile> C_ \\<preceq>\\<^sup>* Thread\n\ngoal (21 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n      ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n      va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 21 subgoals...", "let ?ta = \"\\<lbrace>ThreadExists (addr2thread_id a) True, WakeUp (addr2thread_id a), Interrupt (addr2thread_id a), ObsInterrupt (addr2thread_id a)\\<rbrace>\""], ["proof (state)\ngoal (21 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n      ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n      va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 21 subgoals...", "from RedInterruptInexist None False"], ["proof (chain)\npicking this:\n  M = interrupt\n  vs = []\n  ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>\n  va = RetVal Unit\n  h' = h\n  typeof_addr h a = \\<lfloor>Class_type C_\\<rfloor>\n  P \\<turnstile> C_ \\<preceq>\\<^sup>* Thread\n  wset s t = None\n  \\<not> final_thread.actions_ok' s t ta", "have \"\\<not> free_thread_id (thr s) (addr2thread_id a)\""], ["proof (prove)\nusing this:\n  M = interrupt\n  vs = []\n  ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>\n  va = RetVal Unit\n  h' = h\n  typeof_addr h a = \\<lfloor>Class_type C_\\<rfloor>\n  P \\<turnstile> C_ \\<preceq>\\<^sup>* Thread\n  wset s t = None\n  \\<not> final_thread.actions_ok' s t ta\n\ngoal (1 subgoal):\n 1. \\<not> free_thread_id (thr s) (addr2thread_id a)", "by(auto simp add: wset_actions_ok_def)"], ["proof (state)\nthis:\n  \\<not> free_thread_id (thr s) (addr2thread_id a)\n\ngoal (21 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n      ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n      va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 21 subgoals...", "hence \"final_thread.actions_ok final s t ?ta\""], ["proof (prove)\nusing this:\n  \\<not> free_thread_id (thr s) (addr2thread_id a)\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok final s t\n     \\<lbrace>ThreadExists (addr2thread_id a) True,\n     WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n     ObsInterrupt (addr2thread_id a)\\<rbrace>", "using None"], ["proof (prove)\nusing this:\n  \\<not> free_thread_id (thr s) (addr2thread_id a)\n  wset s t = None\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok final s t\n     \\<lbrace>ThreadExists (addr2thread_id a) True,\n     WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n     ObsInterrupt (addr2thread_id a)\\<rbrace>", "by(auto simp add: final_thread.actions_ok_iff final_thread.cond_action_oks.simps wset_actions_ok_def)"], ["proof (state)\nthis:\n  final_thread.actions_ok final s t\n   \\<lbrace>ThreadExists (addr2thread_id a) True, WakeUp (addr2thread_id a),\n   Interrupt (addr2thread_id a), ObsInterrupt (addr2thread_id a)\\<rbrace>\n\ngoal (21 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n      ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n      va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 21 subgoals...", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_ok final s t\n   \\<lbrace>ThreadExists (addr2thread_id a) True, WakeUp (addr2thread_id a),\n   Interrupt (addr2thread_id a), ObsInterrupt (addr2thread_id a)\\<rbrace>\n\ngoal (21 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n      ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n      va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 21 subgoals...", "obtain va h' where \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -?ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>va h'.\n        P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                         h\\<rangle> -\\<lbrace>ThreadExists\n         (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt\n         (addr2thread_id\n           a)\\<rbrace>\\<rightarrow>ext \\<langle>va,\n h'\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using RedInterruptInexist RedInterrupt"], ["proof (prove)\nusing this:\n  M = interrupt\n  vs = []\n  ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>\n  va = RetVal Unit\n  h' = h\n  typeof_addr h a = \\<lfloor>Class_type C_\\<rfloor>\n  P \\<turnstile> C_ \\<preceq>\\<^sup>* Thread\n  \\<lbrakk>typeof_addr ?h ?a = \\<lfloor>Class_type ?C\\<rfloor>;\n   ?P \\<turnstile> ?C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n  \\<Longrightarrow> ?P,?t \\<turnstile> \\<langle>?a\\<bullet>interrupt([]),\n ?h\\<rangle> -\\<lbrace>ThreadExists (addr2thread_id ?a) True,\n                    WakeUp (addr2thread_id ?a),\n                    Interrupt (addr2thread_id ?a),\n                    ObsInterrupt\n                     (addr2thread_id\n                       ?a)\\<rbrace>\\<rightarrow>ext \\<langle>RetVal Unit,\n              ?h\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>va h'.\n        P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                         h\\<rangle> -\\<lbrace>ThreadExists\n         (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt\n         (addr2thread_id\n           a)\\<rbrace>\\<rightarrow>ext \\<langle>va,\n h'\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>ThreadExists (addr2thread_id a)\n   True,\n  WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n  ObsInterrupt\n   (addr2thread_id a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (21 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n      ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n      va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 21 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  final_thread.actions_ok final s t\n   \\<lbrace>ThreadExists (addr2thread_id a) True, WakeUp (addr2thread_id a),\n   Interrupt (addr2thread_id a), ObsInterrupt (addr2thread_id a)\\<rbrace>\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>ThreadExists (addr2thread_id a)\n   True,\n  WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n  ObsInterrupt\n   (addr2thread_id a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  final_thread.actions_ok final s t\n   \\<lbrace>ThreadExists (addr2thread_id a) True, WakeUp (addr2thread_id a),\n   Interrupt (addr2thread_id a), ObsInterrupt (addr2thread_id a)\\<rbrace>\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>ThreadExists (addr2thread_id a)\n   True,\n  WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n  ObsInterrupt\n   (addr2thread_id a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                h'\\<rangle> \\<and>\n     (final_thread.actions_ok final s t ta' \\<or>\n      final_thread.actions_ok' s t ta' \\<and>\n      final_thread.actions_subset ta' ta)\n\ngoal (20 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n      ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n      va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 20 subgoals...", "next"], ["proof (state)\ngoal (20 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n      ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n      va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 20 subgoals...", "case (RedIsInterruptedTrue C)"], ["proof (state)\nthis:\n  M = isInterrupted\n  vs = []\n  ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n  ObsInterrupted (addr2thread_id a)\\<rbrace>\n  va = RetVal (Bool True)\n  h' = h\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n\ngoal (20 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n      ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n      va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 20 subgoals...", "let ?ta' = \"\\<lbrace>IsInterrupted ?t_a False\\<rbrace>\""], ["proof (state)\ngoal (20 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n      ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n      va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 20 subgoals...", "from RedIsInterruptedTrue False None"], ["proof (chain)\npicking this:\n  M = isInterrupted\n  vs = []\n  ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n  ObsInterrupted (addr2thread_id a)\\<rbrace>\n  va = RetVal (Bool True)\n  h' = h\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n  \\<not> final_thread.actions_ok' s t ta\n  wset s t = None", "have \"?t_a \\<notin> interrupts s\""], ["proof (prove)\nusing this:\n  M = isInterrupted\n  vs = []\n  ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n  ObsInterrupted (addr2thread_id a)\\<rbrace>\n  va = RetVal (Bool True)\n  h' = h\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n  \\<not> final_thread.actions_ok' s t ta\n  wset s t = None\n\ngoal (1 subgoal):\n 1. addr2thread_id a \\<notin> interrupts s", "by(auto)"], ["proof (state)\nthis:\n  addr2thread_id a \\<notin> interrupts s\n\ngoal (20 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n      ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n      va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 20 subgoals...", "hence \"final_thread.actions_ok' s t ?ta'\""], ["proof (prove)\nusing this:\n  addr2thread_id a \\<notin> interrupts s\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok' s t\n     \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>", "using None"], ["proof (prove)\nusing this:\n  addr2thread_id a \\<notin> interrupts s\n  wset s t = None\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok' s t\n     \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>", "by auto"], ["proof (state)\nthis:\n  final_thread.actions_ok' s t\n   \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>\n\ngoal (20 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n      ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n      va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 20 subgoals...", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_ok' s t\n   \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>\n\ngoal (20 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n      ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n      va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 20 subgoals...", "from RedIsInterruptedTrue"], ["proof (chain)\npicking this:\n  M = isInterrupted\n  vs = []\n  ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n  ObsInterrupted (addr2thread_id a)\\<rbrace>\n  va = RetVal (Bool True)\n  h' = h\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  P \\<turnstile> C \\<preceq>\\<^sup>* Thread", "have \"final_thread.actions_subset ?ta' ta\""], ["proof (prove)\nusing this:\n  M = isInterrupted\n  vs = []\n  ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n  ObsInterrupted (addr2thread_id a)\\<rbrace>\n  va = RetVal (Bool True)\n  h' = h\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n\ngoal (1 subgoal):\n 1. final_thread.actions_subset\n     \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace> ta", "by auto"], ["proof (state)\nthis:\n  final_thread.actions_subset\n   \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace> ta\n\ngoal (20 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n      ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n      va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 20 subgoals...", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_subset\n   \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace> ta\n\ngoal (20 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n      ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n      va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 20 subgoals...", "from RedIsInterruptedTrue RedIsInterruptedFalse"], ["proof (chain)\npicking this:\n  M = isInterrupted\n  vs = []\n  ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n  ObsInterrupted (addr2thread_id a)\\<rbrace>\n  va = RetVal (Bool True)\n  h' = h\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n  \\<lbrakk>typeof_addr ?h ?a = \\<lfloor>Class_type ?C\\<rfloor>;\n   ?P \\<turnstile> ?C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n  \\<Longrightarrow> ?P,?t \\<turnstile> \\<langle>?a\\<bullet>isInterrupted([]),\n ?h\\<rangle> -\\<lbrace>IsInterrupted (addr2thread_id ?a)\n                        False\\<rbrace>\\<rightarrow>ext \\<langle>RetVal\n                           (Bool False),\n                 ?h\\<rangle>", "obtain va h'\n          where \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -?ta'\\<rightarrow>ext \\<langle>va,h'\\<rangle>\""], ["proof (prove)\nusing this:\n  M = isInterrupted\n  vs = []\n  ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n  ObsInterrupted (addr2thread_id a)\\<rbrace>\n  va = RetVal (Bool True)\n  h' = h\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n  \\<lbrakk>typeof_addr ?h ?a = \\<lfloor>Class_type ?C\\<rfloor>;\n   ?P \\<turnstile> ?C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n  \\<Longrightarrow> ?P,?t \\<turnstile> \\<langle>?a\\<bullet>isInterrupted([]),\n ?h\\<rangle> -\\<lbrace>IsInterrupted (addr2thread_id ?a)\n                        False\\<rbrace>\\<rightarrow>ext \\<langle>RetVal\n                           (Bool False),\n                 ?h\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>va h'.\n        P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                         h\\<rangle> -\\<lbrace>IsInterrupted\n         (addr2thread_id a)\n         False\\<rbrace>\\<rightarrow>ext \\<langle>va,\n  h'\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>IsInterrupted (addr2thread_id a)\n   False\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (20 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n      ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n      va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 20 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  final_thread.actions_ok' s t\n   \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>\n  final_thread.actions_subset\n   \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace> ta\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>IsInterrupted (addr2thread_id a)\n   False\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  final_thread.actions_ok' s t\n   \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>\n  final_thread.actions_subset\n   \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace> ta\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>IsInterrupted (addr2thread_id a)\n   False\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                h'\\<rangle> \\<and>\n     (final_thread.actions_ok final s t ta' \\<or>\n      final_thread.actions_ok' s t ta' \\<and>\n      final_thread.actions_subset ta' ta)\n\ngoal (19 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll;\n      vs = []; ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n      va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 19 subgoals...", "next"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll;\n      vs = []; ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n      va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 19 subgoals...", "case (RedIsInterruptedFalse C)"], ["proof (state)\nthis:\n  M = isInterrupted\n  vs = []\n  ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>\n  va = RetVal (Bool False)\n  h' = h\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n\ngoal (19 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll;\n      vs = []; ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n      va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 19 subgoals...", "let ?ta' = \"\\<lbrace>IsInterrupted ?t_a True, ObsInterrupted ?t_a\\<rbrace>\""], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll;\n      vs = []; ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n      va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 19 subgoals...", "from RedIsInterruptedFalse"], ["proof (chain)\npicking this:\n  M = isInterrupted\n  vs = []\n  ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>\n  va = RetVal (Bool False)\n  h' = h\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  P \\<turnstile> C \\<preceq>\\<^sup>* Thread", "have \"?t_a \\<in> interrupts s\""], ["proof (prove)\nusing this:\n  M = isInterrupted\n  vs = []\n  ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>\n  va = RetVal (Bool False)\n  h' = h\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n\ngoal (1 subgoal):\n 1. addr2thread_id a \\<in> interrupts s", "using False None"], ["proof (prove)\nusing this:\n  M = isInterrupted\n  vs = []\n  ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>\n  va = RetVal (Bool False)\n  h' = h\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n  \\<not> final_thread.actions_ok' s t ta\n  wset s t = None\n\ngoal (1 subgoal):\n 1. addr2thread_id a \\<in> interrupts s", "by(auto)"], ["proof (state)\nthis:\n  addr2thread_id a \\<in> interrupts s\n\ngoal (19 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll;\n      vs = []; ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n      va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 19 subgoals...", "hence \"final_thread.actions_ok final s t ?ta'\""], ["proof (prove)\nusing this:\n  addr2thread_id a \\<in> interrupts s\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok final s t\n     \\<lbrace>IsInterrupted (addr2thread_id a) True,\n     ObsInterrupted (addr2thread_id a)\\<rbrace>", "using None"], ["proof (prove)\nusing this:\n  addr2thread_id a \\<in> interrupts s\n  wset s t = None\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok final s t\n     \\<lbrace>IsInterrupted (addr2thread_id a) True,\n     ObsInterrupted (addr2thread_id a)\\<rbrace>", "by(auto simp add: final_thread.actions_ok_iff final_thread.cond_action_oks.simps)"], ["proof (state)\nthis:\n  final_thread.actions_ok final s t\n   \\<lbrace>IsInterrupted (addr2thread_id a) True,\n   ObsInterrupted (addr2thread_id a)\\<rbrace>\n\ngoal (19 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll;\n      vs = []; ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n      va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 19 subgoals...", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_ok final s t\n   \\<lbrace>IsInterrupted (addr2thread_id a) True,\n   ObsInterrupted (addr2thread_id a)\\<rbrace>\n\ngoal (19 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll;\n      vs = []; ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n      va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 19 subgoals...", "obtain va h' where \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -?ta'\\<rightarrow>ext \\<langle>va,h'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>va h'.\n        P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                         h\\<rangle> -\\<lbrace>IsInterrupted\n         (addr2thread_id a) True,\n        ObsInterrupted\n         (addr2thread_id\n           a)\\<rbrace>\\<rightarrow>ext \\<langle>va,\n h'\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using RedIsInterruptedFalse RedIsInterruptedTrue"], ["proof (prove)\nusing this:\n  M = isInterrupted\n  vs = []\n  ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>\n  va = RetVal (Bool False)\n  h' = h\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n  \\<lbrakk>typeof_addr ?h ?a = \\<lfloor>Class_type ?C\\<rfloor>;\n   ?P \\<turnstile> ?C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n  \\<Longrightarrow> ?P,?t \\<turnstile> \\<langle>?a\\<bullet>isInterrupted([]),\n ?h\\<rangle> -\\<lbrace>IsInterrupted (addr2thread_id ?a) True,\n                    ObsInterrupted\n                     (addr2thread_id\n                       ?a)\\<rbrace>\\<rightarrow>ext \\<langle>RetVal\n                        (Bool True),\n              ?h\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>va h'.\n        P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                         h\\<rangle> -\\<lbrace>IsInterrupted\n         (addr2thread_id a) True,\n        ObsInterrupted\n         (addr2thread_id\n           a)\\<rbrace>\\<rightarrow>ext \\<langle>va,\n h'\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>IsInterrupted (addr2thread_id a)\n   True,\n  ObsInterrupted\n   (addr2thread_id a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (19 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll;\n      vs = []; ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n      va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 19 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  final_thread.actions_ok final s t\n   \\<lbrace>IsInterrupted (addr2thread_id a) True,\n   ObsInterrupted (addr2thread_id a)\\<rbrace>\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>IsInterrupted (addr2thread_id a)\n   True,\n  ObsInterrupted\n   (addr2thread_id a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  final_thread.actions_ok final s t\n   \\<lbrace>IsInterrupted (addr2thread_id a) True,\n   ObsInterrupted (addr2thread_id a)\\<rbrace>\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>IsInterrupted (addr2thread_id a)\n   True,\n  ObsInterrupted\n   (addr2thread_id a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                h'\\<rangle> \\<and>\n     (final_thread.actions_ok final s t ta' \\<or>\n      final_thread.actions_ok' s t ta' \\<and>\n      final_thread.actions_subset ta' ta)\n\ngoal (18 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll;\n      vs = []; ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n      va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 18 subgoals...", "next"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll;\n      vs = []; ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n      va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 18 subgoals...", "case RedWaitInterrupt"], ["proof (state)\nthis:\n  M = wait\n  vs = []\n  ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n  ClearInterrupt t, ObsInterrupted t\\<rbrace>\n  va = RetEXC InterruptedException\n  h' = h\n\ngoal (18 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll;\n      vs = []; ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n      va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 18 subgoals...", "note ta = \\<open>ta = \\<lbrace>Unlock\\<rightarrow>a, Lock\\<rightarrow>a, IsInterrupted t True, ClearInterrupt t, ObsInterrupted t\\<rbrace>\\<close>"], ["proof (state)\nthis:\n  ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n  ClearInterrupt t, ObsInterrupted t\\<rbrace>\n\ngoal (18 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll;\n      vs = []; ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n      va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 18 subgoals...", "from ta False None"], ["proof (chain)\npicking this:\n  ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n  ClearInterrupt t, ObsInterrupted t\\<rbrace>\n  \\<not> final_thread.actions_ok' s t ta\n  wset s t = None", "have hli: \"\\<not> has_lock (locks s $ a) t \\<or> t \\<notin> interrupts s\""], ["proof (prove)\nusing this:\n  ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n  ClearInterrupt t, ObsInterrupted t\\<rbrace>\n  \\<not> final_thread.actions_ok' s t ta\n  wset s t = None\n\ngoal (1 subgoal):\n 1. \\<not> has_lock (locks s $ a) t \\<or> t \\<notin> interrupts s", "by(fastforce simp add: lock_actions_ok'_iff finfun_upd_apply split: if_split_asm dest: may_lock_t_may_lock_unlock_lock_t dest: has_lock_may_lock)"], ["proof (state)\nthis:\n  \\<not> has_lock (locks s $ a) t \\<or> t \\<notin> interrupts s\n\ngoal (18 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll;\n      vs = []; ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n      va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 18 subgoals...", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "proof(cases \"has_lock (locks s $ a) t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "case True"], ["proof (state)\nthis:\n  has_lock (locks s $ a) t\n\ngoal (2 subgoals):\n 1. has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "let ?ta' = \"\\<lbrace>Suspend a, Unlock\\<rightarrow>a, Lock\\<rightarrow>a, ReleaseAcquire\\<rightarrow>a, IsInterrupted t False, SyncUnlock a \\<rbrace>\""], ["proof (state)\ngoal (2 subgoals):\n 1. has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "from True hli"], ["proof (chain)\npicking this:\n  has_lock (locks s $ a) t\n  \\<not> has_lock (locks s $ a) t \\<or> t \\<notin> interrupts s", "have \"t \\<notin> interrupts s\""], ["proof (prove)\nusing this:\n  has_lock (locks s $ a) t\n  \\<not> has_lock (locks s $ a) t \\<or> t \\<notin> interrupts s\n\ngoal (1 subgoal):\n 1. t \\<notin> interrupts s", "by simp"], ["proof (state)\nthis:\n  t \\<notin> interrupts s\n\ngoal (2 subgoals):\n 1. has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "with True False"], ["proof (chain)\npicking this:\n  has_lock (locks s $ a) t\n  \\<not> final_thread.actions_ok' s t ta\n  t \\<notin> interrupts s", "have \"final_thread.actions_ok' s t ?ta'\""], ["proof (prove)\nusing this:\n  has_lock (locks s $ a) t\n  \\<not> final_thread.actions_ok' s t ta\n  t \\<notin> interrupts s\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok' s t \\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n     (ReleaseAcquire, a), IsInterrupted t False, SyncUnlock a\\<rbrace>", "using None"], ["proof (prove)\nusing this:\n  has_lock (locks s $ a) t\n  \\<not> final_thread.actions_ok' s t ta\n  t \\<notin> interrupts s\n  wset s t = None\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok' s t \\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n     (ReleaseAcquire, a), IsInterrupted t False, SyncUnlock a\\<rbrace>", "by(auto simp add: lock_actions_ok'_iff finfun_upd_apply wset_actions_ok_def Cons_eq_append_conv)"], ["proof (state)\nthis:\n  final_thread.actions_ok' s t \\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n   (ReleaseAcquire, a), IsInterrupted t False, SyncUnlock a\\<rbrace>\n\ngoal (2 subgoals):\n 1. has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_ok' s t \\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n   (ReleaseAcquire, a), IsInterrupted t False, SyncUnlock a\\<rbrace>\n\ngoal (2 subgoals):\n 1. has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "from ta"], ["proof (chain)\npicking this:\n  ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n  ClearInterrupt t, ObsInterrupted t\\<rbrace>", "have \"final_thread.actions_subset ?ta' ta\""], ["proof (prove)\nusing this:\n  ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n  ClearInterrupt t, ObsInterrupted t\\<rbrace>\n\ngoal (1 subgoal):\n 1. final_thread.actions_subset \\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n     (ReleaseAcquire, a), IsInterrupted t False, SyncUnlock a\\<rbrace> ta", "by(auto simp add: collect_locks'_def finfun_upd_apply)"], ["proof (state)\nthis:\n  final_thread.actions_subset \\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n   (ReleaseAcquire, a), IsInterrupted t False, SyncUnlock a\\<rbrace> ta\n\ngoal (2 subgoals):\n 1. has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_subset \\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n   (ReleaseAcquire, a), IsInterrupted t False, SyncUnlock a\\<rbrace> ta\n\ngoal (2 subgoals):\n 1. has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "from RedWait RedWaitInterrupt"], ["proof (chain)\npicking this:\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -\\<lbrace>Suspend ?a,\n  (Unlock, ?a), (Lock, ?a), (ReleaseAcquire, ?a), IsInterrupted ?t False,\n  SyncUnlock ?a\\<rbrace>\\<rightarrow>ext \\<langle>RetStaySame,?h\\<rangle>\n  M = wait\n  vs = []\n  ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n  ClearInterrupt t, ObsInterrupted t\\<rbrace>\n  va = RetEXC InterruptedException\n  h' = h", "obtain va h' where \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -?ta'\\<rightarrow>ext \\<langle>va,h'\\<rangle>\""], ["proof (prove)\nusing this:\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -\\<lbrace>Suspend ?a,\n  (Unlock, ?a), (Lock, ?a), (ReleaseAcquire, ?a), IsInterrupted ?t False,\n  SyncUnlock ?a\\<rbrace>\\<rightarrow>ext \\<langle>RetStaySame,?h\\<rangle>\n  M = wait\n  vs = []\n  ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n  ClearInterrupt t, ObsInterrupted t\\<rbrace>\n  va = RetEXC InterruptedException\n  h' = h\n\ngoal (1 subgoal):\n 1. (\\<And>va h'.\n        P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                         h\\<rangle> -\\<lbrace>Suspend a,\n        (Unlock, a), (Lock, a), (ReleaseAcquire, a), IsInterrupted t False,\n        SyncUnlock\n         a\\<rbrace>\\<rightarrow>ext \\<langle>va,\n                                    h'\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -\\<lbrace>Suspend a,\n  (Unlock, a), (Lock, a), (ReleaseAcquire, a), IsInterrupted t False,\n  SyncUnlock a\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (2 subgoals):\n 1. has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "ultimately"], ["proof (chain)\npicking this:\n  final_thread.actions_ok' s t \\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n   (ReleaseAcquire, a), IsInterrupted t False, SyncUnlock a\\<rbrace>\n  final_thread.actions_subset \\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n   (ReleaseAcquire, a), IsInterrupted t False, SyncUnlock a\\<rbrace> ta\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -\\<lbrace>Suspend a,\n  (Unlock, a), (Lock, a), (ReleaseAcquire, a), IsInterrupted t False,\n  SyncUnlock a\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  final_thread.actions_ok' s t \\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n   (ReleaseAcquire, a), IsInterrupted t False, SyncUnlock a\\<rbrace>\n  final_thread.actions_subset \\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n   (ReleaseAcquire, a), IsInterrupted t False, SyncUnlock a\\<rbrace> ta\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -\\<lbrace>Suspend a,\n  (Unlock, a), (Lock, a), (ReleaseAcquire, a), IsInterrupted t False,\n  SyncUnlock a\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                h'\\<rangle> \\<and>\n     (final_thread.actions_ok final s t ta' \\<or>\n      final_thread.actions_ok' s t ta' \\<and>\n      final_thread.actions_subset ta' ta)\n\ngoal (1 subgoal):\n 1. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "case False"], ["proof (state)\nthis:\n  \\<not> has_lock (locks s $ a) t\n\ngoal (1 subgoal):\n 1. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "let ?ta' = \"\\<lbrace>UnlockFail\\<rightarrow>a\\<rbrace>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "from False"], ["proof (chain)\npicking this:\n  \\<not> has_lock (locks s $ a) t", "have \"final_thread.actions_ok' s t ?ta'\""], ["proof (prove)\nusing this:\n  \\<not> has_lock (locks s $ a) t\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok' s t \\<lbrace>(UnlockFail, a)\\<rbrace>", "using None"], ["proof (prove)\nusing this:\n  \\<not> has_lock (locks s $ a) t\n  wset s t = None\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok' s t \\<lbrace>(UnlockFail, a)\\<rbrace>", "by(auto simp add: lock_actions_ok'_iff finfun_upd_apply)"], ["proof (state)\nthis:\n  final_thread.actions_ok' s t \\<lbrace>(UnlockFail, a)\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_ok' s t \\<lbrace>(UnlockFail, a)\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "from ta"], ["proof (chain)\npicking this:\n  ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n  ClearInterrupt t, ObsInterrupted t\\<rbrace>", "have \"final_thread.actions_subset ?ta' ta\""], ["proof (prove)\nusing this:\n  ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n  ClearInterrupt t, ObsInterrupted t\\<rbrace>\n\ngoal (1 subgoal):\n 1. final_thread.actions_subset \\<lbrace>(UnlockFail, a)\\<rbrace> ta", "by(auto simp add: collect_locks'_def finfun_upd_apply)"], ["proof (state)\nthis:\n  final_thread.actions_subset \\<lbrace>(UnlockFail, a)\\<rbrace> ta\n\ngoal (1 subgoal):\n 1. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_subset \\<lbrace>(UnlockFail, a)\\<rbrace> ta\n\ngoal (1 subgoal):\n 1. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "from RedWaitInterrupt"], ["proof (chain)\npicking this:\n  M = wait\n  vs = []\n  ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n  ClearInterrupt t, ObsInterrupted t\\<rbrace>\n  va = RetEXC InterruptedException\n  h' = h", "obtain va h' where \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -?ta'\\<rightarrow>ext \\<langle>va,h'\\<rangle>\""], ["proof (prove)\nusing this:\n  M = wait\n  vs = []\n  ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n  ClearInterrupt t, ObsInterrupted t\\<rbrace>\n  va = RetEXC InterruptedException\n  h' = h\n\ngoal (1 subgoal):\n 1. (\\<And>va h'.\n        P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                         h\\<rangle> -\\<lbrace>(UnlockFail,\n         a)\\<rbrace>\\<rightarrow>ext \\<langle>va,\n                                     h'\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce)"], ["proof (state)\nthis:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>(UnlockFail,\n   a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "ultimately"], ["proof (chain)\npicking this:\n  final_thread.actions_ok' s t \\<lbrace>(UnlockFail, a)\\<rbrace>\n  final_thread.actions_subset \\<lbrace>(UnlockFail, a)\\<rbrace> ta\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>(UnlockFail,\n   a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  final_thread.actions_ok' s t \\<lbrace>(UnlockFail, a)\\<rbrace>\n  final_thread.actions_subset \\<lbrace>(UnlockFail, a)\\<rbrace> ta\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>(UnlockFail,\n   a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                h'\\<rangle> \\<and>\n     (final_thread.actions_ok final s t ta' \\<or>\n      final_thread.actions_ok' s t ta' \\<and>\n      final_thread.actions_subset ta' ta)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                h'\\<rangle> \\<and>\n     (final_thread.actions_ok final s t ta' \\<or>\n      final_thread.actions_ok' s t ta' \\<and>\n      final_thread.actions_subset ta' ta)\n\ngoal (17 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<And>obs a'.\n        \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n         ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n         heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ta' va' h'.\n                             P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                             (final_thread.actions_ok final s t ta' \\<or>\n                              final_thread.actions_ok' s t ta' \\<and>\n                              final_thread.actions_subset ta' ta)\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<And>obs a'.\n        \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n         ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n         heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ta' va' h'.\n                             P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                             (final_thread.actions_ok final s t ta' \\<or>\n                              final_thread.actions_ok' s t ta' \\<and>\n                              final_thread.actions_subset ta' ta)\nA total of 17 subgoals...", "case RedWait"], ["proof (state)\nthis:\n  M = wait\n  vs = []\n  ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n  IsInterrupted t False, SyncUnlock a\\<rbrace>\n  va = RetStaySame\n  h' = h\n\ngoal (17 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<And>obs a'.\n        \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n         ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n         heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ta' va' h'.\n                             P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                             (final_thread.actions_ok final s t ta' \\<or>\n                              final_thread.actions_ok' s t ta' \\<and>\n                              final_thread.actions_subset ta' ta)\nA total of 17 subgoals...", "note ta = \\<open>ta = \\<lbrace>Suspend a, Unlock\\<rightarrow>a, Lock\\<rightarrow>a, ReleaseAcquire\\<rightarrow>a, IsInterrupted t False, SyncUnlock a\\<rbrace>\\<close>"], ["proof (state)\nthis:\n  ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n  IsInterrupted t False, SyncUnlock a\\<rbrace>\n\ngoal (17 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<And>obs a'.\n        \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n         ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n         heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ta' va' h'.\n                             P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                             (final_thread.actions_ok final s t ta' \\<or>\n                              final_thread.actions_ok' s t ta' \\<and>\n                              final_thread.actions_subset ta' ta)\nA total of 17 subgoals...", "from ta False None"], ["proof (chain)\npicking this:\n  ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n  IsInterrupted t False, SyncUnlock a\\<rbrace>\n  \\<not> final_thread.actions_ok' s t ta\n  wset s t = None", "have hli: \"\\<not> has_lock (locks s $ a) t \\<or> t \\<in> interrupts s\""], ["proof (prove)\nusing this:\n  ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n  IsInterrupted t False, SyncUnlock a\\<rbrace>\n  \\<not> final_thread.actions_ok' s t ta\n  wset s t = None\n\ngoal (1 subgoal):\n 1. \\<not> has_lock (locks s $ a) t \\<or> t \\<in> interrupts s", "by(auto simp add: lock_actions_ok'_iff finfun_upd_apply wset_actions_ok_def Cons_eq_append_conv split: if_split_asm dest: may_lock_t_may_lock_unlock_lock_t dest: has_lock_may_lock)"], ["proof (state)\nthis:\n  \\<not> has_lock (locks s $ a) t \\<or> t \\<in> interrupts s\n\ngoal (17 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<And>obs a'.\n        \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n         ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n         heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ta' va' h'.\n                             P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                             (final_thread.actions_ok final s t ta' \\<or>\n                              final_thread.actions_ok' s t ta' \\<and>\n                              final_thread.actions_subset ta' ta)\nA total of 17 subgoals...", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "proof(cases \"has_lock (locks s $ a) t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "case True"], ["proof (state)\nthis:\n  has_lock (locks s $ a) t\n\ngoal (2 subgoals):\n 1. has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "let ?ta' = \"\\<lbrace>Unlock\\<rightarrow>a, Lock\\<rightarrow>a, IsInterrupted t True, ClearInterrupt t, ObsInterrupted t\\<rbrace>\""], ["proof (state)\ngoal (2 subgoals):\n 1. has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "from True hli"], ["proof (chain)\npicking this:\n  has_lock (locks s $ a) t\n  \\<not> has_lock (locks s $ a) t \\<or> t \\<in> interrupts s", "have \"t \\<in> interrupts s\""], ["proof (prove)\nusing this:\n  has_lock (locks s $ a) t\n  \\<not> has_lock (locks s $ a) t \\<or> t \\<in> interrupts s\n\ngoal (1 subgoal):\n 1. t \\<in> interrupts s", "by simp"], ["proof (state)\nthis:\n  t \\<in> interrupts s\n\ngoal (2 subgoals):\n 1. has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "with True False"], ["proof (chain)\npicking this:\n  has_lock (locks s $ a) t\n  \\<not> final_thread.actions_ok' s t ta\n  t \\<in> interrupts s", "have \"final_thread.actions_ok final s t ?ta'\""], ["proof (prove)\nusing this:\n  has_lock (locks s $ a) t\n  \\<not> final_thread.actions_ok' s t ta\n  t \\<in> interrupts s\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok final s t \\<lbrace>(Unlock, a), (Lock, a),\n     IsInterrupted t True, ClearInterrupt t, ObsInterrupted t\\<rbrace>", "using None"], ["proof (prove)\nusing this:\n  has_lock (locks s $ a) t\n  \\<not> final_thread.actions_ok' s t ta\n  t \\<in> interrupts s\n  wset s t = None\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok final s t \\<lbrace>(Unlock, a), (Lock, a),\n     IsInterrupted t True, ClearInterrupt t, ObsInterrupted t\\<rbrace>", "by(auto simp add: final_thread.actions_ok_iff final_thread.cond_action_oks.simps lock_ok_las_def finfun_upd_apply has_lock_may_lock)"], ["proof (state)\nthis:\n  final_thread.actions_ok final s t \\<lbrace>(Unlock, a), (Lock, a),\n   IsInterrupted t True, ClearInterrupt t, ObsInterrupted t\\<rbrace>\n\ngoal (2 subgoals):\n 1. has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_ok final s t \\<lbrace>(Unlock, a), (Lock, a),\n   IsInterrupted t True, ClearInterrupt t, ObsInterrupted t\\<rbrace>\n\ngoal (2 subgoals):\n 1. has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "from RedWait RedWaitInterrupt"], ["proof (chain)\npicking this:\n  M = wait\n  vs = []\n  ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n  IsInterrupted t False, SyncUnlock a\\<rbrace>\n  va = RetStaySame\n  h' = h\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -\\<lbrace>(Unlock, ?a),\n  (Lock, ?a), IsInterrupted ?t True, ClearInterrupt ?t,\n  ObsInterrupted\n   ?t\\<rbrace>\\<rightarrow>ext \\<langle>RetEXC InterruptedException,\n                               ?h\\<rangle>", "obtain va h' where \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -?ta'\\<rightarrow>ext \\<langle>va,h'\\<rangle>\""], ["proof (prove)\nusing this:\n  M = wait\n  vs = []\n  ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n  IsInterrupted t False, SyncUnlock a\\<rbrace>\n  va = RetStaySame\n  h' = h\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -\\<lbrace>(Unlock, ?a),\n  (Lock, ?a), IsInterrupted ?t True, ClearInterrupt ?t,\n  ObsInterrupted\n   ?t\\<rbrace>\\<rightarrow>ext \\<langle>RetEXC InterruptedException,\n                               ?h\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>va h'.\n        P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                         h\\<rangle> -\\<lbrace>(Unlock, a),\n        (Lock, a), IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted\n         t\\<rbrace>\\<rightarrow>ext \\<langle>va,\n                                    h'\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>(Unlock, a),\n  (Lock, a), IsInterrupted t True, ClearInterrupt t,\n  ObsInterrupted t\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (2 subgoals):\n 1. has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "ultimately"], ["proof (chain)\npicking this:\n  final_thread.actions_ok final s t \\<lbrace>(Unlock, a), (Lock, a),\n   IsInterrupted t True, ClearInterrupt t, ObsInterrupted t\\<rbrace>\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>(Unlock, a),\n  (Lock, a), IsInterrupted t True, ClearInterrupt t,\n  ObsInterrupted t\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  final_thread.actions_ok final s t \\<lbrace>(Unlock, a), (Lock, a),\n   IsInterrupted t True, ClearInterrupt t, ObsInterrupted t\\<rbrace>\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>(Unlock, a),\n  (Lock, a), IsInterrupted t True, ClearInterrupt t,\n  ObsInterrupted t\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                h'\\<rangle> \\<and>\n     (final_thread.actions_ok final s t ta' \\<or>\n      final_thread.actions_ok' s t ta' \\<and>\n      final_thread.actions_subset ta' ta)\n\ngoal (1 subgoal):\n 1. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "case False"], ["proof (state)\nthis:\n  \\<not> has_lock (locks s $ a) t\n\ngoal (1 subgoal):\n 1. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "let ?ta' = \"\\<lbrace>UnlockFail\\<rightarrow>a\\<rbrace>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "from False"], ["proof (chain)\npicking this:\n  \\<not> has_lock (locks s $ a) t", "have \"final_thread.actions_ok' s t ?ta'\""], ["proof (prove)\nusing this:\n  \\<not> has_lock (locks s $ a) t\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok' s t \\<lbrace>(UnlockFail, a)\\<rbrace>", "using None"], ["proof (prove)\nusing this:\n  \\<not> has_lock (locks s $ a) t\n  wset s t = None\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok' s t \\<lbrace>(UnlockFail, a)\\<rbrace>", "by(auto simp add: lock_actions_ok'_iff finfun_upd_apply)"], ["proof (state)\nthis:\n  final_thread.actions_ok' s t \\<lbrace>(UnlockFail, a)\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_ok' s t \\<lbrace>(UnlockFail, a)\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "from ta"], ["proof (chain)\npicking this:\n  ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n  IsInterrupted t False, SyncUnlock a\\<rbrace>", "have \"final_thread.actions_subset ?ta' ta\""], ["proof (prove)\nusing this:\n  ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n  IsInterrupted t False, SyncUnlock a\\<rbrace>\n\ngoal (1 subgoal):\n 1. final_thread.actions_subset \\<lbrace>(UnlockFail, a)\\<rbrace> ta", "by(auto simp add: collect_locks'_def finfun_upd_apply)"], ["proof (state)\nthis:\n  final_thread.actions_subset \\<lbrace>(UnlockFail, a)\\<rbrace> ta\n\ngoal (1 subgoal):\n 1. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_subset \\<lbrace>(UnlockFail, a)\\<rbrace> ta\n\ngoal (1 subgoal):\n 1. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "from RedWait RedWaitFail"], ["proof (chain)\npicking this:\n  M = wait\n  vs = []\n  ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n  IsInterrupted t False, SyncUnlock a\\<rbrace>\n  va = RetStaySame\n  h' = h\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -\\<lbrace>(UnlockFail,\n      ?a)\\<rbrace>\\<rightarrow>ext \\<langle>RetEXC IllegalMonitorState,\n                                   ?h\\<rangle>", "obtain va h' where \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -?ta'\\<rightarrow>ext \\<langle>va,h'\\<rangle>\""], ["proof (prove)\nusing this:\n  M = wait\n  vs = []\n  ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n  IsInterrupted t False, SyncUnlock a\\<rbrace>\n  va = RetStaySame\n  h' = h\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -\\<lbrace>(UnlockFail,\n      ?a)\\<rbrace>\\<rightarrow>ext \\<langle>RetEXC IllegalMonitorState,\n                                   ?h\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>va h'.\n        P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                         h\\<rangle> -\\<lbrace>(UnlockFail,\n         a)\\<rbrace>\\<rightarrow>ext \\<langle>va,\n                                     h'\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce)"], ["proof (state)\nthis:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>(UnlockFail,\n   a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "ultimately"], ["proof (chain)\npicking this:\n  final_thread.actions_ok' s t \\<lbrace>(UnlockFail, a)\\<rbrace>\n  final_thread.actions_subset \\<lbrace>(UnlockFail, a)\\<rbrace> ta\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>(UnlockFail,\n   a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  final_thread.actions_ok' s t \\<lbrace>(UnlockFail, a)\\<rbrace>\n  final_thread.actions_subset \\<lbrace>(UnlockFail, a)\\<rbrace> ta\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>(UnlockFail,\n   a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                h'\\<rangle> \\<and>\n     (final_thread.actions_ok final s t ta' \\<or>\n      final_thread.actions_ok' s t ta' \\<and>\n      final_thread.actions_subset ta' ta)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                h'\\<rangle> \\<and>\n     (final_thread.actions_ok final s t ta' \\<or>\n      final_thread.actions_ok' s t ta' \\<and>\n      final_thread.actions_subset ta' ta)\n\ngoal (16 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n      ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n      heap_clone P h a h' None\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n      ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n      heap_clone P h a h' None\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 16 subgoals...", "case RedWaitFail"], ["proof (state)\nthis:\n  M = wait\n  vs = []\n  ta = \\<lbrace>(UnlockFail, a)\\<rbrace>\n  va = RetEXC IllegalMonitorState\n  h' = h\n\ngoal (16 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n      ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n      heap_clone P h a h' None\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 16 subgoals...", "note ta = \\<open>ta = \\<lbrace>UnlockFail\\<rightarrow>a\\<rbrace>\\<close>"], ["proof (state)\nthis:\n  ta = \\<lbrace>(UnlockFail, a)\\<rbrace>\n\ngoal (16 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n      ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n      heap_clone P h a h' None\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 16 subgoals...", "let ?ta' = \"if t \\<in> interrupts s\n                   then \\<lbrace>Unlock\\<rightarrow>a, Lock\\<rightarrow>a, IsInterrupted t True, ClearInterrupt t, ObsInterrupted t\\<rbrace>\n                   else \\<lbrace>Suspend a, Unlock\\<rightarrow>a, Lock\\<rightarrow>a, ReleaseAcquire\\<rightarrow>a, IsInterrupted t False, SyncUnlock a \\<rbrace>\""], ["proof (state)\ngoal (16 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n      ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n      heap_clone P h a h' None\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 16 subgoals...", "from ta False None"], ["proof (chain)\npicking this:\n  ta = \\<lbrace>(UnlockFail, a)\\<rbrace>\n  \\<not> final_thread.actions_ok' s t ta\n  wset s t = None", "have \"has_lock (locks s $ a) t\""], ["proof (prove)\nusing this:\n  ta = \\<lbrace>(UnlockFail, a)\\<rbrace>\n  \\<not> final_thread.actions_ok' s t ta\n  wset s t = None\n\ngoal (1 subgoal):\n 1. has_lock (locks s $ a) t", "by(auto simp add: finfun_upd_apply split: if_split_asm)"], ["proof (state)\nthis:\n  has_lock (locks s $ a) t\n\ngoal (16 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n      ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n      heap_clone P h a h' None\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 16 subgoals...", "hence \"final_thread.actions_ok final s t ?ta'\""], ["proof (prove)\nusing this:\n  has_lock (locks s $ a) t\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok final s t\n     (if t \\<in> interrupts s\n      then \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n           ClearInterrupt t, ObsInterrupted t\\<rbrace>\n      else \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n           IsInterrupted t False, SyncUnlock a\\<rbrace>)", "using None"], ["proof (prove)\nusing this:\n  has_lock (locks s $ a) t\n  wset s t = None\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok final s t\n     (if t \\<in> interrupts s\n      then \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n           ClearInterrupt t, ObsInterrupted t\\<rbrace>\n      else \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n           IsInterrupted t False, SyncUnlock a\\<rbrace>)", "by(auto simp add: final_thread.actions_ok_iff final_thread.cond_action_oks.simps lock_ok_las_def finfun_upd_apply has_lock_may_lock wset_actions_ok_def)"], ["proof (state)\nthis:\n  final_thread.actions_ok final s t\n   (if t \\<in> interrupts s\n    then \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n         ClearInterrupt t, ObsInterrupted t\\<rbrace>\n    else \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n         IsInterrupted t False, SyncUnlock a\\<rbrace>)\n\ngoal (16 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n      ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n      heap_clone P h a h' None\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 16 subgoals...", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_ok final s t\n   (if t \\<in> interrupts s\n    then \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n         ClearInterrupt t, ObsInterrupted t\\<rbrace>\n    else \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n         IsInterrupted t False, SyncUnlock a\\<rbrace>)\n\ngoal (16 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n      ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n      heap_clone P h a h' None\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 16 subgoals...", "from RedWaitFail RedWait RedWaitInterrupt"], ["proof (chain)\npicking this:\n  M = wait\n  vs = []\n  ta = \\<lbrace>(UnlockFail, a)\\<rbrace>\n  va = RetEXC IllegalMonitorState\n  h' = h\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -\\<lbrace>Suspend ?a,\n  (Unlock, ?a), (Lock, ?a), (ReleaseAcquire, ?a), IsInterrupted ?t False,\n  SyncUnlock ?a\\<rbrace>\\<rightarrow>ext \\<langle>RetStaySame,?h\\<rangle>\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -\\<lbrace>(Unlock, ?a),\n  (Lock, ?a), IsInterrupted ?t True, ClearInterrupt ?t,\n  ObsInterrupted\n   ?t\\<rbrace>\\<rightarrow>ext \\<langle>RetEXC InterruptedException,\n                               ?h\\<rangle>", "obtain va h' where \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -?ta'\\<rightarrow>ext \\<langle>va,h'\\<rangle>\""], ["proof (prove)\nusing this:\n  M = wait\n  vs = []\n  ta = \\<lbrace>(UnlockFail, a)\\<rbrace>\n  va = RetEXC IllegalMonitorState\n  h' = h\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -\\<lbrace>Suspend ?a,\n  (Unlock, ?a), (Lock, ?a), (ReleaseAcquire, ?a), IsInterrupted ?t False,\n  SyncUnlock ?a\\<rbrace>\\<rightarrow>ext \\<langle>RetStaySame,?h\\<rangle>\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -\\<lbrace>(Unlock, ?a),\n  (Lock, ?a), IsInterrupted ?t True, ClearInterrupt ?t,\n  ObsInterrupted\n   ?t\\<rbrace>\\<rightarrow>ext \\<langle>RetEXC InterruptedException,\n                               ?h\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>va h'.\n        P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                         h\\<rangle> -if t \\<in> interrupts s\n                                     then \\<lbrace>(Unlock, a), (Lock, a),\n    IsInterrupted t True, ClearInterrupt t, ObsInterrupted t\\<rbrace>\n                                     else \\<lbrace>Suspend a, (Unlock, a),\n    (Lock, a), (ReleaseAcquire, a), IsInterrupted t False,\n    SyncUnlock\n     a\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases \"t \\<in> interrupts s\") (auto)"], ["proof (state)\nthis:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -if t \\<in> interrupts s\n                               then \\<lbrace>(Unlock, a), (Lock, a),\n                                    IsInterrupted t True, ClearInterrupt t,\n                                    ObsInterrupted t\\<rbrace>\n                               else \\<lbrace>Suspend a, (Unlock, a),\n                                    (Lock, a), (ReleaseAcquire, a),\n                                    IsInterrupted t False,\n                                    SyncUnlock\n                                     a\\<rbrace>\\<rightarrow>ext \\<langle>va,\n                          h'\\<rangle>\n\ngoal (16 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n      ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n      heap_clone P h a h' None\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 16 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  final_thread.actions_ok final s t\n   (if t \\<in> interrupts s\n    then \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n         ClearInterrupt t, ObsInterrupted t\\<rbrace>\n    else \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n         IsInterrupted t False, SyncUnlock a\\<rbrace>)\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -if t \\<in> interrupts s\n                               then \\<lbrace>(Unlock, a), (Lock, a),\n                                    IsInterrupted t True, ClearInterrupt t,\n                                    ObsInterrupted t\\<rbrace>\n                               else \\<lbrace>Suspend a, (Unlock, a),\n                                    (Lock, a), (ReleaseAcquire, a),\n                                    IsInterrupted t False,\n                                    SyncUnlock\n                                     a\\<rbrace>\\<rightarrow>ext \\<langle>va,\n                          h'\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  final_thread.actions_ok final s t\n   (if t \\<in> interrupts s\n    then \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n         ClearInterrupt t, ObsInterrupted t\\<rbrace>\n    else \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n         IsInterrupted t False, SyncUnlock a\\<rbrace>)\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -if t \\<in> interrupts s\n                               then \\<lbrace>(Unlock, a), (Lock, a),\n                                    IsInterrupted t True, ClearInterrupt t,\n                                    ObsInterrupted t\\<rbrace>\n                               else \\<lbrace>Suspend a, (Unlock, a),\n                                    (Lock, a), (ReleaseAcquire, a),\n                                    IsInterrupted t False,\n                                    SyncUnlock\n                                     a\\<rbrace>\\<rightarrow>ext \\<langle>va,\n                          h'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                h'\\<rangle> \\<and>\n     (final_thread.actions_ok final s t ta' \\<or>\n      final_thread.actions_ok' s t ta' \\<and>\n      final_thread.actions_subset ta' ta)\n\ngoal (15 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n      ta = \\<lbrace>\\<rbrace>;\n      va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n      ta = \\<lbrace>\\<rbrace>;\n      va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 15 subgoals...", "case RedWaitNotified"], ["proof (state)\nthis:\n  M = wait\n  vs = []\n  ta = \\<lbrace>Notified\\<rbrace>\n  va = RetVal Unit\n  h' = h\n\ngoal (15 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n      ta = \\<lbrace>\\<rbrace>;\n      va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 15 subgoals...", "note ta = \\<open>ta = \\<lbrace>Notified\\<rbrace>\\<close>"], ["proof (state)\nthis:\n  ta = \\<lbrace>Notified\\<rbrace>\n\ngoal (15 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n      ta = \\<lbrace>\\<rbrace>;\n      va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 15 subgoals...", "let ?ta' = \"if has_lock (locks s $ a) t\n                   then (if t \\<in> interrupts s\n                         then \\<lbrace>Unlock\\<rightarrow>a, Lock\\<rightarrow>a, IsInterrupted t True, ClearInterrupt t, ObsInterrupted t\\<rbrace>\n                         else \\<lbrace>Suspend a, Unlock\\<rightarrow>a, Lock\\<rightarrow>a, ReleaseAcquire\\<rightarrow>a, IsInterrupted t False, SyncUnlock a \\<rbrace>)\n                   else \\<lbrace>UnlockFail\\<rightarrow>a\\<rbrace>\""], ["proof (state)\ngoal (15 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n      ta = \\<lbrace>\\<rbrace>;\n      va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 15 subgoals...", "have \"final_thread.actions_ok final s t ?ta'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final_thread.actions_ok final s t\n     (if has_lock (locks s $ a) t\n      then if t \\<in> interrupts s\n           then \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n                ClearInterrupt t, ObsInterrupted t\\<rbrace>\n           else \\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n                (ReleaseAcquire, a), IsInterrupted t False,\n                SyncUnlock a\\<rbrace>\n      else \\<lbrace>(UnlockFail, a)\\<rbrace>)", "using None"], ["proof (prove)\nusing this:\n  wset s t = None\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok final s t\n     (if has_lock (locks s $ a) t\n      then if t \\<in> interrupts s\n           then \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n                ClearInterrupt t, ObsInterrupted t\\<rbrace>\n           else \\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n                (ReleaseAcquire, a), IsInterrupted t False,\n                SyncUnlock a\\<rbrace>\n      else \\<lbrace>(UnlockFail, a)\\<rbrace>)", "by(auto simp add: final_thread.actions_ok_iff final_thread.cond_action_oks.simps lock_ok_las_def finfun_upd_apply has_lock_may_lock wset_actions_ok_def)"], ["proof (state)\nthis:\n  final_thread.actions_ok final s t\n   (if has_lock (locks s $ a) t\n    then if t \\<in> interrupts s\n         then \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n              ClearInterrupt t, ObsInterrupted t\\<rbrace>\n         else \\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n              (ReleaseAcquire, a), IsInterrupted t False,\n              SyncUnlock a\\<rbrace>\n    else \\<lbrace>(UnlockFail, a)\\<rbrace>)\n\ngoal (15 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n      ta = \\<lbrace>\\<rbrace>;\n      va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 15 subgoals...", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_ok final s t\n   (if has_lock (locks s $ a) t\n    then if t \\<in> interrupts s\n         then \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n              ClearInterrupt t, ObsInterrupted t\\<rbrace>\n         else \\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n              (ReleaseAcquire, a), IsInterrupted t False,\n              SyncUnlock a\\<rbrace>\n    else \\<lbrace>(UnlockFail, a)\\<rbrace>)\n\ngoal (15 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n      ta = \\<lbrace>\\<rbrace>;\n      va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 15 subgoals...", "from RedWaitNotified RedWait RedWaitInterrupt RedWaitFail"], ["proof (chain)\npicking this:\n  M = wait\n  vs = []\n  ta = \\<lbrace>Notified\\<rbrace>\n  va = RetVal Unit\n  h' = h\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -\\<lbrace>Suspend ?a,\n  (Unlock, ?a), (Lock, ?a), (ReleaseAcquire, ?a), IsInterrupted ?t False,\n  SyncUnlock ?a\\<rbrace>\\<rightarrow>ext \\<langle>RetStaySame,?h\\<rangle>\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -\\<lbrace>(Unlock, ?a),\n  (Lock, ?a), IsInterrupted ?t True, ClearInterrupt ?t,\n  ObsInterrupted\n   ?t\\<rbrace>\\<rightarrow>ext \\<langle>RetEXC InterruptedException,\n                               ?h\\<rangle>\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -\\<lbrace>(UnlockFail,\n      ?a)\\<rbrace>\\<rightarrow>ext \\<langle>RetEXC IllegalMonitorState,\n                                   ?h\\<rangle>", "have \"\\<exists>va h'. P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -?ta'\\<rightarrow>ext \\<langle>va,h'\\<rangle>\""], ["proof (prove)\nusing this:\n  M = wait\n  vs = []\n  ta = \\<lbrace>Notified\\<rbrace>\n  va = RetVal Unit\n  h' = h\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -\\<lbrace>Suspend ?a,\n  (Unlock, ?a), (Lock, ?a), (ReleaseAcquire, ?a), IsInterrupted ?t False,\n  SyncUnlock ?a\\<rbrace>\\<rightarrow>ext \\<langle>RetStaySame,?h\\<rangle>\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -\\<lbrace>(Unlock, ?a),\n  (Lock, ?a), IsInterrupted ?t True, ClearInterrupt ?t,\n  ObsInterrupted\n   ?t\\<rbrace>\\<rightarrow>ext \\<langle>RetEXC InterruptedException,\n                               ?h\\<rangle>\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -\\<lbrace>(UnlockFail,\n      ?a)\\<rbrace>\\<rightarrow>ext \\<langle>RetEXC IllegalMonitorState,\n                                   ?h\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>va h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -if has_lock (locks s $ a) t\n                                    then if t \\<in> interrupts s\n   then \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n        ClearInterrupt t, ObsInterrupted t\\<rbrace>\n   else \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n        IsInterrupted t False, SyncUnlock a\\<rbrace>\n                                    else \\<lbrace>(UnlockFail,\n             a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>", "by auto"], ["proof (state)\nthis:\n  \\<exists>va h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -if has_lock (locks s $ a) t\n                                  then if t \\<in> interrupts s\n then \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n      ClearInterrupt t, ObsInterrupted t\\<rbrace>\n else \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>\n                                  else \\<lbrace>(UnlockFail,\n           a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (15 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>Notified\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n      ta = \\<lbrace>\\<rbrace>;\n      va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 15 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  final_thread.actions_ok final s t\n   (if has_lock (locks s $ a) t\n    then if t \\<in> interrupts s\n         then \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n              ClearInterrupt t, ObsInterrupted t\\<rbrace>\n         else \\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n              (ReleaseAcquire, a), IsInterrupted t False,\n              SyncUnlock a\\<rbrace>\n    else \\<lbrace>(UnlockFail, a)\\<rbrace>)\n  \\<exists>va h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -if has_lock (locks s $ a) t\n                                  then if t \\<in> interrupts s\n then \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n      ClearInterrupt t, ObsInterrupted t\\<rbrace>\n else \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>\n                                  else \\<lbrace>(UnlockFail,\n           a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  final_thread.actions_ok final s t\n   (if has_lock (locks s $ a) t\n    then if t \\<in> interrupts s\n         then \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n              ClearInterrupt t, ObsInterrupted t\\<rbrace>\n         else \\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n              (ReleaseAcquire, a), IsInterrupted t False,\n              SyncUnlock a\\<rbrace>\n    else \\<lbrace>(UnlockFail, a)\\<rbrace>)\n  \\<exists>va h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -if has_lock (locks s $ a) t\n                                  then if t \\<in> interrupts s\n then \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n      ClearInterrupt t, ObsInterrupted t\\<rbrace>\n else \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>\n                                  else \\<lbrace>(UnlockFail,\n           a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                h'\\<rangle> \\<and>\n     (final_thread.actions_ok final s t ta' \\<or>\n      final_thread.actions_ok' s t ta' \\<and>\n      final_thread.actions_subset ta' ta)\n\ngoal (14 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n      ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n      h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n      ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n      h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 14 subgoals...", "case RedWaitInterrupted"], ["proof (state)\nthis:\n  M = wait\n  vs = []\n  ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>\n  va = RetEXC InterruptedException\n  h' = h\n\ngoal (14 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n      ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n      h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 14 subgoals...", "note ta = \\<open>ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>\\<close>"], ["proof (state)\nthis:\n  ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>\n\ngoal (14 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n      ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n      h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 14 subgoals...", "let ?ta' = \"if has_lock (locks s $ a) t\n                   then (if t \\<in> interrupts s\n                         then \\<lbrace>Unlock\\<rightarrow>a, Lock\\<rightarrow>a, IsInterrupted t True, ClearInterrupt t, ObsInterrupted t\\<rbrace>\n                         else \\<lbrace>Suspend a, Unlock\\<rightarrow>a, Lock\\<rightarrow>a, ReleaseAcquire\\<rightarrow>a, IsInterrupted t False, SyncUnlock a \\<rbrace>)\n                   else \\<lbrace>UnlockFail\\<rightarrow>a\\<rbrace>\""], ["proof (state)\ngoal (14 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n      ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n      h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 14 subgoals...", "have \"final_thread.actions_ok final s t ?ta'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final_thread.actions_ok final s t\n     (if has_lock (locks s $ a) t\n      then if t \\<in> interrupts s\n           then \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n                ClearInterrupt t, ObsInterrupted t\\<rbrace>\n           else \\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n                (ReleaseAcquire, a), IsInterrupted t False,\n                SyncUnlock a\\<rbrace>\n      else \\<lbrace>(UnlockFail, a)\\<rbrace>)", "using None"], ["proof (prove)\nusing this:\n  wset s t = None\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok final s t\n     (if has_lock (locks s $ a) t\n      then if t \\<in> interrupts s\n           then \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n                ClearInterrupt t, ObsInterrupted t\\<rbrace>\n           else \\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n                (ReleaseAcquire, a), IsInterrupted t False,\n                SyncUnlock a\\<rbrace>\n      else \\<lbrace>(UnlockFail, a)\\<rbrace>)", "by(auto simp add: final_thread.actions_ok_iff final_thread.cond_action_oks.simps lock_ok_las_def finfun_upd_apply has_lock_may_lock wset_actions_ok_def)"], ["proof (state)\nthis:\n  final_thread.actions_ok final s t\n   (if has_lock (locks s $ a) t\n    then if t \\<in> interrupts s\n         then \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n              ClearInterrupt t, ObsInterrupted t\\<rbrace>\n         else \\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n              (ReleaseAcquire, a), IsInterrupted t False,\n              SyncUnlock a\\<rbrace>\n    else \\<lbrace>(UnlockFail, a)\\<rbrace>)\n\ngoal (14 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n      ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n      h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 14 subgoals...", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_ok final s t\n   (if has_lock (locks s $ a) t\n    then if t \\<in> interrupts s\n         then \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n              ClearInterrupt t, ObsInterrupted t\\<rbrace>\n         else \\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n              (ReleaseAcquire, a), IsInterrupted t False,\n              SyncUnlock a\\<rbrace>\n    else \\<lbrace>(UnlockFail, a)\\<rbrace>)\n\ngoal (14 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n      ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n      h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 14 subgoals...", "from RedWaitInterrupted RedWait RedWaitInterrupt RedWaitFail"], ["proof (chain)\npicking this:\n  M = wait\n  vs = []\n  ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>\n  va = RetEXC InterruptedException\n  h' = h\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -\\<lbrace>Suspend ?a,\n  (Unlock, ?a), (Lock, ?a), (ReleaseAcquire, ?a), IsInterrupted ?t False,\n  SyncUnlock ?a\\<rbrace>\\<rightarrow>ext \\<langle>RetStaySame,?h\\<rangle>\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -\\<lbrace>(Unlock, ?a),\n  (Lock, ?a), IsInterrupted ?t True, ClearInterrupt ?t,\n  ObsInterrupted\n   ?t\\<rbrace>\\<rightarrow>ext \\<langle>RetEXC InterruptedException,\n                               ?h\\<rangle>\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -\\<lbrace>(UnlockFail,\n      ?a)\\<rbrace>\\<rightarrow>ext \\<langle>RetEXC IllegalMonitorState,\n                                   ?h\\<rangle>", "have \"\\<exists>va h'. P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -?ta'\\<rightarrow>ext \\<langle>va,h'\\<rangle>\""], ["proof (prove)\nusing this:\n  M = wait\n  vs = []\n  ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>\n  va = RetEXC InterruptedException\n  h' = h\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -\\<lbrace>Suspend ?a,\n  (Unlock, ?a), (Lock, ?a), (ReleaseAcquire, ?a), IsInterrupted ?t False,\n  SyncUnlock ?a\\<rbrace>\\<rightarrow>ext \\<langle>RetStaySame,?h\\<rangle>\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -\\<lbrace>(Unlock, ?a),\n  (Lock, ?a), IsInterrupted ?t True, ClearInterrupt ?t,\n  ObsInterrupted\n   ?t\\<rbrace>\\<rightarrow>ext \\<langle>RetEXC InterruptedException,\n                               ?h\\<rangle>\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -\\<lbrace>(UnlockFail,\n      ?a)\\<rbrace>\\<rightarrow>ext \\<langle>RetEXC IllegalMonitorState,\n                                   ?h\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>va h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -if has_lock (locks s $ a) t\n                                    then if t \\<in> interrupts s\n   then \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n        ClearInterrupt t, ObsInterrupted t\\<rbrace>\n   else \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n        IsInterrupted t False, SyncUnlock a\\<rbrace>\n                                    else \\<lbrace>(UnlockFail,\n             a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>", "by auto"], ["proof (state)\nthis:\n  \\<exists>va h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -if has_lock (locks s $ a) t\n                                  then if t \\<in> interrupts s\n then \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n      ClearInterrupt t, ObsInterrupted t\\<rbrace>\n else \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>\n                                  else \\<lbrace>(UnlockFail,\n           a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (14 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n      ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n      h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 14 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  final_thread.actions_ok final s t\n   (if has_lock (locks s $ a) t\n    then if t \\<in> interrupts s\n         then \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n              ClearInterrupt t, ObsInterrupted t\\<rbrace>\n         else \\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n              (ReleaseAcquire, a), IsInterrupted t False,\n              SyncUnlock a\\<rbrace>\n    else \\<lbrace>(UnlockFail, a)\\<rbrace>)\n  \\<exists>va h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -if has_lock (locks s $ a) t\n                                  then if t \\<in> interrupts s\n then \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n      ClearInterrupt t, ObsInterrupted t\\<rbrace>\n else \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>\n                                  else \\<lbrace>(UnlockFail,\n           a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  final_thread.actions_ok final s t\n   (if has_lock (locks s $ a) t\n    then if t \\<in> interrupts s\n         then \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n              ClearInterrupt t, ObsInterrupted t\\<rbrace>\n         else \\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n              (ReleaseAcquire, a), IsInterrupted t False,\n              SyncUnlock a\\<rbrace>\n    else \\<lbrace>(UnlockFail, a)\\<rbrace>)\n  \\<exists>va h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -if has_lock (locks s $ a) t\n                                  then if t \\<in> interrupts s\n then \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n      ClearInterrupt t, ObsInterrupted t\\<rbrace>\n else \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>\n                                  else \\<lbrace>(UnlockFail,\n           a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                h'\\<rangle> \\<and>\n     (final_thread.actions_ok final s t ta' \\<or>\n      final_thread.actions_ok' s t ta' \\<and>\n      final_thread.actions_subset ta' ta)\n\ngoal (13 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n      vs = []; ta = \\<lbrace>\\<rbrace>;\n      va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n      vs = []; ta = \\<lbrace>\\<rbrace>;\n      va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 13 subgoals...", "case RedWaitSpurious"], ["proof (state)\nthis:\n  M = wait\n  vs = []\n  ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n  IsInterrupted t False, SyncUnlock a\\<rbrace>\n  va = RetVal Unit\n  h' = h\n  spurious_wakeups\n\ngoal (13 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n      vs = []; ta = \\<lbrace>\\<rbrace>;\n      va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 13 subgoals...", "note ta = \\<open>ta = \\<lbrace>Unlock\\<rightarrow>a, Lock\\<rightarrow>a, ReleaseAcquire\\<rightarrow>a, IsInterrupted t False, SyncUnlock a\\<rbrace>\\<close>"], ["proof (state)\nthis:\n  ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n  IsInterrupted t False, SyncUnlock a\\<rbrace>\n\ngoal (13 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n      vs = []; ta = \\<lbrace>\\<rbrace>;\n      va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 13 subgoals...", "from ta False None"], ["proof (chain)\npicking this:\n  ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n  IsInterrupted t False, SyncUnlock a\\<rbrace>\n  \\<not> final_thread.actions_ok' s t ta\n  wset s t = None", "have hli: \"\\<not> has_lock (locks s $ a) t \\<or> t \\<in> interrupts s\""], ["proof (prove)\nusing this:\n  ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n  IsInterrupted t False, SyncUnlock a\\<rbrace>\n  \\<not> final_thread.actions_ok' s t ta\n  wset s t = None\n\ngoal (1 subgoal):\n 1. \\<not> has_lock (locks s $ a) t \\<or> t \\<in> interrupts s", "by(auto simp add: lock_actions_ok'_iff finfun_upd_apply wset_actions_ok_def Cons_eq_append_conv split: if_split_asm dest: may_lock_t_may_lock_unlock_lock_t dest: has_lock_may_lock)"], ["proof (state)\nthis:\n  \\<not> has_lock (locks s $ a) t \\<or> t \\<in> interrupts s\n\ngoal (13 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = h; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n      vs = []; ta = \\<lbrace>\\<rbrace>;\n      va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 13 subgoals...", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "proof(cases \"has_lock (locks s $ a) t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "case True"], ["proof (state)\nthis:\n  has_lock (locks s $ a) t\n\ngoal (2 subgoals):\n 1. has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "let ?ta' = \"\\<lbrace>Unlock\\<rightarrow>a, Lock\\<rightarrow>a, IsInterrupted t True, ClearInterrupt t, ObsInterrupted t\\<rbrace>\""], ["proof (state)\ngoal (2 subgoals):\n 1. has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "from True hli"], ["proof (chain)\npicking this:\n  has_lock (locks s $ a) t\n  \\<not> has_lock (locks s $ a) t \\<or> t \\<in> interrupts s", "have \"t \\<in> interrupts s\""], ["proof (prove)\nusing this:\n  has_lock (locks s $ a) t\n  \\<not> has_lock (locks s $ a) t \\<or> t \\<in> interrupts s\n\ngoal (1 subgoal):\n 1. t \\<in> interrupts s", "by simp"], ["proof (state)\nthis:\n  t \\<in> interrupts s\n\ngoal (2 subgoals):\n 1. has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "with True False"], ["proof (chain)\npicking this:\n  has_lock (locks s $ a) t\n  \\<not> final_thread.actions_ok' s t ta\n  t \\<in> interrupts s", "have \"final_thread.actions_ok final s t ?ta'\""], ["proof (prove)\nusing this:\n  has_lock (locks s $ a) t\n  \\<not> final_thread.actions_ok' s t ta\n  t \\<in> interrupts s\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok final s t \\<lbrace>(Unlock, a), (Lock, a),\n     IsInterrupted t True, ClearInterrupt t, ObsInterrupted t\\<rbrace>", "using None"], ["proof (prove)\nusing this:\n  has_lock (locks s $ a) t\n  \\<not> final_thread.actions_ok' s t ta\n  t \\<in> interrupts s\n  wset s t = None\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok final s t \\<lbrace>(Unlock, a), (Lock, a),\n     IsInterrupted t True, ClearInterrupt t, ObsInterrupted t\\<rbrace>", "by(auto simp add: final_thread.actions_ok_iff final_thread.cond_action_oks.simps lock_ok_las_def finfun_upd_apply has_lock_may_lock)"], ["proof (state)\nthis:\n  final_thread.actions_ok final s t \\<lbrace>(Unlock, a), (Lock, a),\n   IsInterrupted t True, ClearInterrupt t, ObsInterrupted t\\<rbrace>\n\ngoal (2 subgoals):\n 1. has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_ok final s t \\<lbrace>(Unlock, a), (Lock, a),\n   IsInterrupted t True, ClearInterrupt t, ObsInterrupted t\\<rbrace>\n\ngoal (2 subgoals):\n 1. has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "from RedWaitInterrupt RedWaitSpurious(1-5)"], ["proof (chain)\npicking this:\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -\\<lbrace>(Unlock, ?a),\n  (Lock, ?a), IsInterrupted ?t True, ClearInterrupt ?t,\n  ObsInterrupted\n   ?t\\<rbrace>\\<rightarrow>ext \\<langle>RetEXC InterruptedException,\n                               ?h\\<rangle>\n  M = wait\n  vs = []\n  ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n  IsInterrupted t False, SyncUnlock a\\<rbrace>\n  va = RetVal Unit\n  h' = h", "obtain va h' where \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -?ta'\\<rightarrow>ext \\<langle>va,h'\\<rangle>\""], ["proof (prove)\nusing this:\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -\\<lbrace>(Unlock, ?a),\n  (Lock, ?a), IsInterrupted ?t True, ClearInterrupt ?t,\n  ObsInterrupted\n   ?t\\<rbrace>\\<rightarrow>ext \\<langle>RetEXC InterruptedException,\n                               ?h\\<rangle>\n  M = wait\n  vs = []\n  ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n  IsInterrupted t False, SyncUnlock a\\<rbrace>\n  va = RetVal Unit\n  h' = h\n\ngoal (1 subgoal):\n 1. (\\<And>va h'.\n        P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                         h\\<rangle> -\\<lbrace>(Unlock, a),\n        (Lock, a), IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted\n         t\\<rbrace>\\<rightarrow>ext \\<langle>va,\n                                    h'\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>(Unlock, a),\n  (Lock, a), IsInterrupted t True, ClearInterrupt t,\n  ObsInterrupted t\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (2 subgoals):\n 1. has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)\n 2. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "ultimately"], ["proof (chain)\npicking this:\n  final_thread.actions_ok final s t \\<lbrace>(Unlock, a), (Lock, a),\n   IsInterrupted t True, ClearInterrupt t, ObsInterrupted t\\<rbrace>\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>(Unlock, a),\n  (Lock, a), IsInterrupted t True, ClearInterrupt t,\n  ObsInterrupted t\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  final_thread.actions_ok final s t \\<lbrace>(Unlock, a), (Lock, a),\n   IsInterrupted t True, ClearInterrupt t, ObsInterrupted t\\<rbrace>\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>(Unlock, a),\n  (Lock, a), IsInterrupted t True, ClearInterrupt t,\n  ObsInterrupted t\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                h'\\<rangle> \\<and>\n     (final_thread.actions_ok final s t ta' \\<or>\n      final_thread.actions_ok' s t ta' \\<and>\n      final_thread.actions_subset ta' ta)\n\ngoal (1 subgoal):\n 1. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "case False"], ["proof (state)\nthis:\n  \\<not> has_lock (locks s $ a) t\n\ngoal (1 subgoal):\n 1. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "let ?ta' = \"\\<lbrace>UnlockFail\\<rightarrow>a\\<rbrace>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "from False"], ["proof (chain)\npicking this:\n  \\<not> has_lock (locks s $ a) t", "have \"final_thread.actions_ok' s t ?ta'\""], ["proof (prove)\nusing this:\n  \\<not> has_lock (locks s $ a) t\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok' s t \\<lbrace>(UnlockFail, a)\\<rbrace>", "using None"], ["proof (prove)\nusing this:\n  \\<not> has_lock (locks s $ a) t\n  wset s t = None\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok' s t \\<lbrace>(UnlockFail, a)\\<rbrace>", "by(auto simp add: lock_actions_ok'_iff finfun_upd_apply)"], ["proof (state)\nthis:\n  final_thread.actions_ok' s t \\<lbrace>(UnlockFail, a)\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_ok' s t \\<lbrace>(UnlockFail, a)\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "from ta"], ["proof (chain)\npicking this:\n  ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n  IsInterrupted t False, SyncUnlock a\\<rbrace>", "have \"final_thread.actions_subset ?ta' ta\""], ["proof (prove)\nusing this:\n  ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n  IsInterrupted t False, SyncUnlock a\\<rbrace>\n\ngoal (1 subgoal):\n 1. final_thread.actions_subset \\<lbrace>(UnlockFail, a)\\<rbrace> ta", "by(auto simp add: collect_locks'_def finfun_upd_apply)"], ["proof (state)\nthis:\n  final_thread.actions_subset \\<lbrace>(UnlockFail, a)\\<rbrace> ta\n\ngoal (1 subgoal):\n 1. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_subset \\<lbrace>(UnlockFail, a)\\<rbrace> ta\n\ngoal (1 subgoal):\n 1. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "from RedWaitSpurious(1-5) RedWaitFail"], ["proof (chain)\npicking this:\n  M = wait\n  vs = []\n  ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n  IsInterrupted t False, SyncUnlock a\\<rbrace>\n  va = RetVal Unit\n  h' = h\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -\\<lbrace>(UnlockFail,\n      ?a)\\<rbrace>\\<rightarrow>ext \\<langle>RetEXC IllegalMonitorState,\n                                   ?h\\<rangle>", "obtain va h' where \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -?ta'\\<rightarrow>ext \\<langle>va,h'\\<rangle>\""], ["proof (prove)\nusing this:\n  M = wait\n  vs = []\n  ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n  IsInterrupted t False, SyncUnlock a\\<rbrace>\n  va = RetVal Unit\n  h' = h\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>wait([]),\n                     ?h\\<rangle> -\\<lbrace>(UnlockFail,\n      ?a)\\<rbrace>\\<rightarrow>ext \\<langle>RetEXC IllegalMonitorState,\n                                   ?h\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>va h'.\n        P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                         h\\<rangle> -\\<lbrace>(UnlockFail,\n         a)\\<rbrace>\\<rightarrow>ext \\<langle>va,\n                                     h'\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce)"], ["proof (state)\nthis:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>(UnlockFail,\n   a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> has_lock (locks s $ a) t \\<Longrightarrow>\n    \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "ultimately"], ["proof (chain)\npicking this:\n  final_thread.actions_ok' s t \\<lbrace>(UnlockFail, a)\\<rbrace>\n  final_thread.actions_subset \\<lbrace>(UnlockFail, a)\\<rbrace> ta\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>(UnlockFail,\n   a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  final_thread.actions_ok' s t \\<lbrace>(UnlockFail, a)\\<rbrace>\n  final_thread.actions_subset \\<lbrace>(UnlockFail, a)\\<rbrace> ta\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>(UnlockFail,\n   a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                h'\\<rangle> \\<and>\n     (final_thread.actions_ok final s t ta' \\<or>\n      final_thread.actions_ok' s t ta' \\<and>\n      final_thread.actions_subset ta' ta)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                h'\\<rangle> \\<and>\n     (final_thread.actions_ok final s t ta' \\<or>\n      final_thread.actions_ok' s t ta' \\<and>\n      final_thread.actions_subset ta' ta)\n\ngoal (12 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n      vs = [];\n      ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n      ObsInterrupted t\\<rbrace>;\n      va = RetVal (Bool True); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n      vs = [];\n      ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n      ObsInterrupted t\\<rbrace>;\n      va = RetVal (Bool True); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 12 subgoals...", "case RedNotify"], ["proof (state)\nthis:\n  M = notify\n  vs = []\n  ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>\n  va = RetVal Unit\n  h' = h\n\ngoal (12 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n      vs = [];\n      ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n      ObsInterrupted t\\<rbrace>;\n      va = RetVal (Bool True); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 12 subgoals...", "note ta = \\<open>ta = \\<lbrace>Notify a, Unlock\\<rightarrow>a, Lock\\<rightarrow>a\\<rbrace>\\<close>"], ["proof (state)\nthis:\n  ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>\n\ngoal (12 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n      vs = [];\n      ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n      ObsInterrupted t\\<rbrace>;\n      va = RetVal (Bool True); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 12 subgoals...", "let ?ta' = \"\\<lbrace>UnlockFail\\<rightarrow>a\\<rbrace>\""], ["proof (state)\ngoal (12 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n      vs = [];\n      ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n      ObsInterrupted t\\<rbrace>;\n      va = RetVal (Bool True); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 12 subgoals...", "from ta False None"], ["proof (chain)\npicking this:\n  ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>\n  \\<not> final_thread.actions_ok' s t ta\n  wset s t = None", "have \"\\<not> has_lock (locks s $ a) t\""], ["proof (prove)\nusing this:\n  ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>\n  \\<not> final_thread.actions_ok' s t ta\n  wset s t = None\n\ngoal (1 subgoal):\n 1. \\<not> has_lock (locks s $ a) t", "by(fastforce simp add: lock_actions_ok'_iff finfun_upd_apply wset_actions_ok_def Cons_eq_append_conv split: if_split_asm dest: may_lock_t_may_lock_unlock_lock_t has_lock_may_lock)"], ["proof (state)\nthis:\n  \\<not> has_lock (locks s $ a) t\n\ngoal (12 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n      vs = [];\n      ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n      ObsInterrupted t\\<rbrace>;\n      va = RetVal (Bool True); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 12 subgoals...", "hence \"final_thread.actions_ok' s t ?ta'\""], ["proof (prove)\nusing this:\n  \\<not> has_lock (locks s $ a) t\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok' s t \\<lbrace>(UnlockFail, a)\\<rbrace>", "using None"], ["proof (prove)\nusing this:\n  \\<not> has_lock (locks s $ a) t\n  wset s t = None\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok' s t \\<lbrace>(UnlockFail, a)\\<rbrace>", "by(auto simp add: lock_actions_ok'_iff finfun_upd_apply)"], ["proof (state)\nthis:\n  final_thread.actions_ok' s t \\<lbrace>(UnlockFail, a)\\<rbrace>\n\ngoal (12 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n      vs = [];\n      ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n      ObsInterrupted t\\<rbrace>;\n      va = RetVal (Bool True); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 12 subgoals...", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_ok' s t \\<lbrace>(UnlockFail, a)\\<rbrace>\n\ngoal (12 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n      vs = [];\n      ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n      ObsInterrupted t\\<rbrace>;\n      va = RetVal (Bool True); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 12 subgoals...", "from ta"], ["proof (chain)\npicking this:\n  ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>", "have \"final_thread.actions_subset ?ta' ta\""], ["proof (prove)\nusing this:\n  ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>\n\ngoal (1 subgoal):\n 1. final_thread.actions_subset \\<lbrace>(UnlockFail, a)\\<rbrace> ta", "by(auto simp add: collect_locks'_def finfun_upd_apply)"], ["proof (state)\nthis:\n  final_thread.actions_subset \\<lbrace>(UnlockFail, a)\\<rbrace> ta\n\ngoal (12 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n      vs = [];\n      ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n      ObsInterrupted t\\<rbrace>;\n      va = RetVal (Bool True); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 12 subgoals...", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_subset \\<lbrace>(UnlockFail, a)\\<rbrace> ta\n\ngoal (12 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n      vs = [];\n      ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n      ObsInterrupted t\\<rbrace>;\n      va = RetVal (Bool True); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 12 subgoals...", "from RedNotify"], ["proof (chain)\npicking this:\n  M = notify\n  vs = []\n  ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>\n  va = RetVal Unit\n  h' = h", "obtain va h' where \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -?ta'\\<rightarrow>ext \\<langle>va,h'\\<rangle>\""], ["proof (prove)\nusing this:\n  M = notify\n  vs = []\n  ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>\n  va = RetVal Unit\n  h' = h\n\ngoal (1 subgoal):\n 1. (\\<And>va h'.\n        P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                         h\\<rangle> -\\<lbrace>(UnlockFail,\n         a)\\<rbrace>\\<rightarrow>ext \\<langle>va,\n                                     h'\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce)"], ["proof (state)\nthis:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>(UnlockFail,\n   a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (12 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n      vs = [];\n      ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n      ObsInterrupted t\\<rbrace>;\n      va = RetVal (Bool True); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 12 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  final_thread.actions_ok' s t \\<lbrace>(UnlockFail, a)\\<rbrace>\n  final_thread.actions_subset \\<lbrace>(UnlockFail, a)\\<rbrace> ta\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>(UnlockFail,\n   a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  final_thread.actions_ok' s t \\<lbrace>(UnlockFail, a)\\<rbrace>\n  final_thread.actions_subset \\<lbrace>(UnlockFail, a)\\<rbrace> ta\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>(UnlockFail,\n   a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                h'\\<rangle> \\<and>\n     (final_thread.actions_ok final s t ta' \\<or>\n      final_thread.actions_ok' s t ta' \\<and>\n      final_thread.actions_subset ta' ta)\n\ngoal (11 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n      vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n      va = RetVal (Bool False); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n      vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n      va = RetVal (Bool False); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 11 subgoals...", "case RedNotifyFail"], ["proof (state)\nthis:\n  M = notify\n  vs = []\n  ta = \\<lbrace>(UnlockFail, a)\\<rbrace>\n  va = RetEXC IllegalMonitorState\n  h' = h\n\ngoal (11 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n      vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n      va = RetVal (Bool False); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 11 subgoals...", "note ta = \\<open>ta = \\<lbrace>UnlockFail\\<rightarrow>a\\<rbrace>\\<close>"], ["proof (state)\nthis:\n  ta = \\<lbrace>(UnlockFail, a)\\<rbrace>\n\ngoal (11 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n      vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n      va = RetVal (Bool False); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 11 subgoals...", "let ?ta' = \"\\<lbrace>Notify a, Unlock\\<rightarrow>a, Lock\\<rightarrow>a\\<rbrace>\""], ["proof (state)\ngoal (11 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n      vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n      va = RetVal (Bool False); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 11 subgoals...", "from ta False None"], ["proof (chain)\npicking this:\n  ta = \\<lbrace>(UnlockFail, a)\\<rbrace>\n  \\<not> final_thread.actions_ok' s t ta\n  wset s t = None", "have \"has_lock (locks s $ a) t\""], ["proof (prove)\nusing this:\n  ta = \\<lbrace>(UnlockFail, a)\\<rbrace>\n  \\<not> final_thread.actions_ok' s t ta\n  wset s t = None\n\ngoal (1 subgoal):\n 1. has_lock (locks s $ a) t", "by(auto simp add: finfun_upd_apply split: if_split_asm)"], ["proof (state)\nthis:\n  has_lock (locks s $ a) t\n\ngoal (11 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n      vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n      va = RetVal (Bool False); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 11 subgoals...", "hence \"final_thread.actions_ok' s t ?ta'\""], ["proof (prove)\nusing this:\n  has_lock (locks s $ a) t\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok' s t \\<lbrace>Notify a, (Unlock, a),\n     (Lock, a)\\<rbrace>", "using None"], ["proof (prove)\nusing this:\n  has_lock (locks s $ a) t\n  wset s t = None\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok' s t \\<lbrace>Notify a, (Unlock, a),\n     (Lock, a)\\<rbrace>", "by(auto simp add: finfun_upd_apply simp add: wset_actions_ok_def intro: has_lock_may_lock)"], ["proof (state)\nthis:\n  final_thread.actions_ok' s t \\<lbrace>Notify a, (Unlock, a),\n   (Lock, a)\\<rbrace>\n\ngoal (11 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n      vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n      va = RetVal (Bool False); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 11 subgoals...", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_ok' s t \\<lbrace>Notify a, (Unlock, a),\n   (Lock, a)\\<rbrace>\n\ngoal (11 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n      vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n      va = RetVal (Bool False); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 11 subgoals...", "from ta"], ["proof (chain)\npicking this:\n  ta = \\<lbrace>(UnlockFail, a)\\<rbrace>", "have \"final_thread.actions_subset ?ta' ta\""], ["proof (prove)\nusing this:\n  ta = \\<lbrace>(UnlockFail, a)\\<rbrace>\n\ngoal (1 subgoal):\n 1. final_thread.actions_subset \\<lbrace>Notify a, (Unlock, a),\n     (Lock, a)\\<rbrace> ta", "by(auto simp add: collect_locks'_def finfun_upd_apply)"], ["proof (state)\nthis:\n  final_thread.actions_subset \\<lbrace>Notify a, (Unlock, a),\n   (Lock, a)\\<rbrace> ta\n\ngoal (11 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n      vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n      va = RetVal (Bool False); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 11 subgoals...", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_subset \\<lbrace>Notify a, (Unlock, a),\n   (Lock, a)\\<rbrace> ta\n\ngoal (11 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n      vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n      va = RetVal (Bool False); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 11 subgoals...", "from RedNotifyFail"], ["proof (chain)\npicking this:\n  M = notify\n  vs = []\n  ta = \\<lbrace>(UnlockFail, a)\\<rbrace>\n  va = RetEXC IllegalMonitorState\n  h' = h", "obtain va h' where \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -?ta'\\<rightarrow>ext \\<langle>va,h'\\<rangle>\""], ["proof (prove)\nusing this:\n  M = notify\n  vs = []\n  ta = \\<lbrace>(UnlockFail, a)\\<rbrace>\n  va = RetEXC IllegalMonitorState\n  h' = h\n\ngoal (1 subgoal):\n 1. (\\<And>va h'.\n        P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                         h\\<rangle> -\\<lbrace>Notify a,\n        (Unlock, a),\n        (Lock,\n         a)\\<rbrace>\\<rightarrow>ext \\<langle>va,\n                                     h'\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce)"], ["proof (state)\nthis:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -\\<lbrace>Notify a,\n  (Unlock, a), (Lock, a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (11 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notify; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n      vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n      va = RetVal (Bool False); h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)\nA total of 11 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  final_thread.actions_ok' s t \\<lbrace>Notify a, (Unlock, a),\n   (Lock, a)\\<rbrace>\n  final_thread.actions_subset \\<lbrace>Notify a, (Unlock, a),\n   (Lock, a)\\<rbrace> ta\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -\\<lbrace>Notify a,\n  (Unlock, a), (Lock, a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  final_thread.actions_ok' s t \\<lbrace>Notify a, (Unlock, a),\n   (Lock, a)\\<rbrace>\n  final_thread.actions_subset \\<lbrace>Notify a, (Unlock, a),\n   (Lock, a)\\<rbrace> ta\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -\\<lbrace>Notify a,\n  (Unlock, a), (Lock, a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                h'\\<rangle> \\<and>\n     (final_thread.actions_ok final s t ta' \\<or>\n      final_thread.actions_ok' s t ta' \\<and>\n      final_thread.actions_subset ta' ta)\n\ngoal (10 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n      ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n      ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)", "case RedNotifyAll"], ["proof (state)\nthis:\n  M = notifyAll\n  vs = []\n  ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>\n  va = RetVal Unit\n  h' = h\n\ngoal (10 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n      ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)", "note ta = \\<open>ta = \\<lbrace>NotifyAll a, Unlock\\<rightarrow>a, Lock\\<rightarrow>a\\<rbrace>\\<close>"], ["proof (state)\nthis:\n  ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>\n\ngoal (10 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n      ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)", "let ?ta' = \"\\<lbrace>UnlockFail\\<rightarrow>a\\<rbrace>\""], ["proof (state)\ngoal (10 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n      ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)", "from ta False None"], ["proof (chain)\npicking this:\n  ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>\n  \\<not> final_thread.actions_ok' s t ta\n  wset s t = None", "have \"\\<not> has_lock (locks s $ a) t\""], ["proof (prove)\nusing this:\n  ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>\n  \\<not> final_thread.actions_ok' s t ta\n  wset s t = None\n\ngoal (1 subgoal):\n 1. \\<not> has_lock (locks s $ a) t", "by(auto simp add: lock_actions_ok'_iff finfun_upd_apply wset_actions_ok_def Cons_eq_append_conv split: if_split_asm dest: may_lock_t_may_lock_unlock_lock_t)"], ["proof (state)\nthis:\n  \\<not> has_lock (locks s $ a) t\n\ngoal (10 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n      ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)", "hence \"final_thread.actions_ok' s t ?ta'\""], ["proof (prove)\nusing this:\n  \\<not> has_lock (locks s $ a) t\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok' s t \\<lbrace>(UnlockFail, a)\\<rbrace>", "using None"], ["proof (prove)\nusing this:\n  \\<not> has_lock (locks s $ a) t\n  wset s t = None\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok' s t \\<lbrace>(UnlockFail, a)\\<rbrace>", "by(auto simp add: lock_actions_ok'_iff finfun_upd_apply)"], ["proof (state)\nthis:\n  final_thread.actions_ok' s t \\<lbrace>(UnlockFail, a)\\<rbrace>\n\ngoal (10 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n      ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_ok' s t \\<lbrace>(UnlockFail, a)\\<rbrace>\n\ngoal (10 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n      ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)", "from ta"], ["proof (chain)\npicking this:\n  ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>", "have \"final_thread.actions_subset ?ta' ta\""], ["proof (prove)\nusing this:\n  ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>\n\ngoal (1 subgoal):\n 1. final_thread.actions_subset \\<lbrace>(UnlockFail, a)\\<rbrace> ta", "by(auto simp add: collect_locks'_def finfun_upd_apply)"], ["proof (state)\nthis:\n  final_thread.actions_subset \\<lbrace>(UnlockFail, a)\\<rbrace> ta\n\ngoal (10 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n      ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_subset \\<lbrace>(UnlockFail, a)\\<rbrace> ta\n\ngoal (10 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n      ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)", "from RedNotifyAll"], ["proof (chain)\npicking this:\n  M = notifyAll\n  vs = []\n  ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>\n  va = RetVal Unit\n  h' = h", "obtain va h' where \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -?ta'\\<rightarrow>ext \\<langle>va,h'\\<rangle>\""], ["proof (prove)\nusing this:\n  M = notifyAll\n  vs = []\n  ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>\n  va = RetVal Unit\n  h' = h\n\ngoal (1 subgoal):\n 1. (\\<And>va h'.\n        P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                         h\\<rangle> -\\<lbrace>(UnlockFail,\n         a)\\<rbrace>\\<rightarrow>ext \\<langle>va,\n                                     h'\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce)"], ["proof (state)\nthis:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>(UnlockFail,\n   a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (10 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>;\n     va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 10. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n      ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' va' h'.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                          (final_thread.actions_ok final s t ta' \\<or>\n                           final_thread.actions_ok' s t ta' \\<and>\n                           final_thread.actions_subset ta' ta)", "ultimately"], ["proof (chain)\npicking this:\n  final_thread.actions_ok' s t \\<lbrace>(UnlockFail, a)\\<rbrace>\n  final_thread.actions_subset \\<lbrace>(UnlockFail, a)\\<rbrace> ta\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>(UnlockFail,\n   a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  final_thread.actions_ok' s t \\<lbrace>(UnlockFail, a)\\<rbrace>\n  final_thread.actions_subset \\<lbrace>(UnlockFail, a)\\<rbrace> ta\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>(UnlockFail,\n   a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                h'\\<rangle> \\<and>\n     (final_thread.actions_ok final s t ta' \\<or>\n      final_thread.actions_ok' s t ta' \\<and>\n      final_thread.actions_subset ta' ta)\n\ngoal (9 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n     ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n     ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)", "case RedNotifyAllFail"], ["proof (state)\nthis:\n  M = notifyAll\n  vs = []\n  ta = \\<lbrace>(UnlockFail, a)\\<rbrace>\n  va = RetEXC IllegalMonitorState\n  h' = h\n\ngoal (9 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n     ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)", "note ta = \\<open>ta = \\<lbrace>UnlockFail\\<rightarrow>a\\<rbrace>\\<close>"], ["proof (state)\nthis:\n  ta = \\<lbrace>(UnlockFail, a)\\<rbrace>\n\ngoal (9 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n     ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)", "let ?ta' = \"\\<lbrace>NotifyAll a, Unlock\\<rightarrow>a, Lock\\<rightarrow>a\\<rbrace>\""], ["proof (state)\ngoal (9 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n     ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)", "from ta False None"], ["proof (chain)\npicking this:\n  ta = \\<lbrace>(UnlockFail, a)\\<rbrace>\n  \\<not> final_thread.actions_ok' s t ta\n  wset s t = None", "have \"has_lock (locks s $ a) t\""], ["proof (prove)\nusing this:\n  ta = \\<lbrace>(UnlockFail, a)\\<rbrace>\n  \\<not> final_thread.actions_ok' s t ta\n  wset s t = None\n\ngoal (1 subgoal):\n 1. has_lock (locks s $ a) t", "by(auto simp add: finfun_upd_apply split: if_split_asm)"], ["proof (state)\nthis:\n  has_lock (locks s $ a) t\n\ngoal (9 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n     ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)", "hence \"final_thread.actions_ok' s t ?ta'\""], ["proof (prove)\nusing this:\n  has_lock (locks s $ a) t\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok' s t \\<lbrace>NotifyAll a, (Unlock, a),\n     (Lock, a)\\<rbrace>", "using None"], ["proof (prove)\nusing this:\n  has_lock (locks s $ a) t\n  wset s t = None\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok' s t \\<lbrace>NotifyAll a, (Unlock, a),\n     (Lock, a)\\<rbrace>", "by(auto simp add: finfun_upd_apply wset_actions_ok_def intro: has_lock_may_lock)"], ["proof (state)\nthis:\n  final_thread.actions_ok' s t \\<lbrace>NotifyAll a, (Unlock, a),\n   (Lock, a)\\<rbrace>\n\ngoal (9 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n     ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_ok' s t \\<lbrace>NotifyAll a, (Unlock, a),\n   (Lock, a)\\<rbrace>\n\ngoal (9 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n     ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)", "from ta"], ["proof (chain)\npicking this:\n  ta = \\<lbrace>(UnlockFail, a)\\<rbrace>", "have \"final_thread.actions_subset ?ta' ta\""], ["proof (prove)\nusing this:\n  ta = \\<lbrace>(UnlockFail, a)\\<rbrace>\n\ngoal (1 subgoal):\n 1. final_thread.actions_subset \\<lbrace>NotifyAll a, (Unlock, a),\n     (Lock, a)\\<rbrace> ta", "by(auto simp add: collect_locks'_def finfun_upd_apply)"], ["proof (state)\nthis:\n  final_thread.actions_subset \\<lbrace>NotifyAll a, (Unlock, a),\n   (Lock, a)\\<rbrace> ta\n\ngoal (9 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n     ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_subset \\<lbrace>NotifyAll a, (Unlock, a),\n   (Lock, a)\\<rbrace> ta\n\ngoal (9 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n     ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)", "from RedNotifyAllFail"], ["proof (chain)\npicking this:\n  M = notifyAll\n  vs = []\n  ta = \\<lbrace>(UnlockFail, a)\\<rbrace>\n  va = RetEXC IllegalMonitorState\n  h' = h", "obtain va h' where \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -?ta'\\<rightarrow>ext \\<langle>va,h'\\<rangle>\""], ["proof (prove)\nusing this:\n  M = notifyAll\n  vs = []\n  ta = \\<lbrace>(UnlockFail, a)\\<rbrace>\n  va = RetEXC IllegalMonitorState\n  h' = h\n\ngoal (1 subgoal):\n 1. (\\<And>va h'.\n        P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                         h\\<rangle> -\\<lbrace>NotifyAll a,\n        (Unlock, a),\n        (Lock,\n         a)\\<rbrace>\\<rightarrow>ext \\<langle>va,\n                                     h'\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce)"], ["proof (state)\nthis:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>NotifyAll a,\n  (Unlock, a), (Lock, a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (9 subgoals):\n 1. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = notifyAll; vs = [];\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 2. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 9. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n     ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)", "ultimately"], ["proof (chain)\npicking this:\n  final_thread.actions_ok' s t \\<lbrace>NotifyAll a, (Unlock, a),\n   (Lock, a)\\<rbrace>\n  final_thread.actions_subset \\<lbrace>NotifyAll a, (Unlock, a),\n   (Lock, a)\\<rbrace> ta\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>NotifyAll a,\n  (Unlock, a), (Lock, a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  final_thread.actions_ok' s t \\<lbrace>NotifyAll a, (Unlock, a),\n   (Lock, a)\\<rbrace>\n  final_thread.actions_subset \\<lbrace>NotifyAll a, (Unlock, a),\n   (Lock, a)\\<rbrace> ta\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>NotifyAll a,\n  (Unlock, a), (Lock, a)\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                h'\\<rangle> \\<and>\n     (final_thread.actions_ok final s t ta' \\<or>\n      final_thread.actions_ok' s t ta' \\<and>\n      final_thread.actions_subset ta' ta)\n\ngoal (8 subgoals):\n 1. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n     ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n     ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)", "case RedInterruptedTrue"], ["proof (state)\nthis:\n  M = interrupted\n  vs = []\n  ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n  ObsInterrupted t\\<rbrace>\n  va = RetVal (Bool True)\n  h' = h\n\ngoal (8 subgoals):\n 1. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n     ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)", "let ?ta' = \"\\<lbrace>IsInterrupted t False\\<rbrace>\""], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n     ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)", "from RedInterruptedTrue"], ["proof (chain)\npicking this:\n  M = interrupted\n  vs = []\n  ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n  ObsInterrupted t\\<rbrace>\n  va = RetVal (Bool True)\n  h' = h", "have \"final_thread.actions_ok final s t ?ta'\""], ["proof (prove)\nusing this:\n  M = interrupted\n  vs = []\n  ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n  ObsInterrupted t\\<rbrace>\n  va = RetVal (Bool True)\n  h' = h\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok final s t\n     \\<lbrace>IsInterrupted t False\\<rbrace>", "using None False"], ["proof (prove)\nusing this:\n  M = interrupted\n  vs = []\n  ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n  ObsInterrupted t\\<rbrace>\n  va = RetVal (Bool True)\n  h' = h\n  wset s t = None\n  \\<not> final_thread.actions_ok' s t ta\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok final s t\n     \\<lbrace>IsInterrupted t False\\<rbrace>", "by(auto simp add: final_thread.actions_ok_iff final_thread.cond_action_oks.simps)"], ["proof (state)\nthis:\n  final_thread.actions_ok final s t \\<lbrace>IsInterrupted t False\\<rbrace>\n\ngoal (8 subgoals):\n 1. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n     ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_ok final s t \\<lbrace>IsInterrupted t False\\<rbrace>\n\ngoal (8 subgoals):\n 1. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n     ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)", "obtain va h' where \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -?ta'\\<rightarrow>ext \\<langle>va,h'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>va h'.\n        P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                         h\\<rangle> -\\<lbrace>IsInterrupted t\n         False\\<rbrace>\\<rightarrow>ext \\<langle>va,\n  h'\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using RedInterruptedFalse RedInterruptedTrue"], ["proof (prove)\nusing this:\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>interrupted([]),\n                     ?h\\<rangle> -\\<lbrace>IsInterrupted ?t\n      False\\<rbrace>\\<rightarrow>ext \\<langle>RetVal (Bool False),\n                                     ?h\\<rangle>\n  M = interrupted\n  vs = []\n  ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n  ObsInterrupted t\\<rbrace>\n  va = RetVal (Bool True)\n  h' = h\n\ngoal (1 subgoal):\n 1. (\\<And>va h'.\n        P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                         h\\<rangle> -\\<lbrace>IsInterrupted t\n         False\\<rbrace>\\<rightarrow>ext \\<langle>va,\n  h'\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>IsInterrupted t\n   False\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (8 subgoals):\n 1. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = [];\n     ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n     ObsInterrupted t\\<rbrace>;\n     va = RetVal (Bool True); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 8. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n     ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)", "ultimately"], ["proof (chain)\npicking this:\n  final_thread.actions_ok final s t \\<lbrace>IsInterrupted t False\\<rbrace>\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>IsInterrupted t\n   False\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  final_thread.actions_ok final s t \\<lbrace>IsInterrupted t False\\<rbrace>\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>IsInterrupted t\n   False\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                h'\\<rangle> \\<and>\n     (final_thread.actions_ok final s t ta' \\<or>\n      final_thread.actions_ok' s t ta' \\<and>\n      final_thread.actions_subset ta' ta)\n\ngoal (7 subgoals):\n 1. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n     ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n     ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)", "case RedInterruptedFalse"], ["proof (state)\nthis:\n  M = interrupted\n  vs = []\n  ta = \\<lbrace>IsInterrupted t False\\<rbrace>\n  va = RetVal (Bool False)\n  h' = h\n\ngoal (7 subgoals):\n 1. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n     ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)", "let ?ta' = \"\\<lbrace>IsInterrupted t True, ClearInterrupt t, ObsInterrupted t\\<rbrace>\""], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n     ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)", "from RedInterruptedFalse"], ["proof (chain)\npicking this:\n  M = interrupted\n  vs = []\n  ta = \\<lbrace>IsInterrupted t False\\<rbrace>\n  va = RetVal (Bool False)\n  h' = h", "have \"final_thread.actions_ok final s t ?ta'\""], ["proof (prove)\nusing this:\n  M = interrupted\n  vs = []\n  ta = \\<lbrace>IsInterrupted t False\\<rbrace>\n  va = RetVal (Bool False)\n  h' = h\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok final s t \\<lbrace>IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>", "using None False"], ["proof (prove)\nusing this:\n  M = interrupted\n  vs = []\n  ta = \\<lbrace>IsInterrupted t False\\<rbrace>\n  va = RetVal (Bool False)\n  h' = h\n  wset s t = None\n  \\<not> final_thread.actions_ok' s t ta\n\ngoal (1 subgoal):\n 1. final_thread.actions_ok final s t \\<lbrace>IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>", "by(auto simp add: final_thread.actions_ok_iff final_thread.cond_action_oks.simps)"], ["proof (state)\nthis:\n  final_thread.actions_ok final s t \\<lbrace>IsInterrupted t True,\n   ClearInterrupt t, ObsInterrupted t\\<rbrace>\n\ngoal (7 subgoals):\n 1. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n     ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)", "moreover"], ["proof (state)\nthis:\n  final_thread.actions_ok final s t \\<lbrace>IsInterrupted t True,\n   ClearInterrupt t, ObsInterrupted t\\<rbrace>\n\ngoal (7 subgoals):\n 1. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n     ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)", "obtain va h' where \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),h\\<rangle> -?ta'\\<rightarrow>ext \\<langle>va,h'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>va h'.\n        P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                         h\\<rangle> -\\<lbrace>IsInterrupted t True,\n        ClearInterrupt t,\n        ObsInterrupted\n         t\\<rbrace>\\<rightarrow>ext \\<langle>va,\n                                    h'\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using RedInterruptedFalse RedInterruptedTrue"], ["proof (prove)\nusing this:\n  M = interrupted\n  vs = []\n  ta = \\<lbrace>IsInterrupted t False\\<rbrace>\n  va = RetVal (Bool False)\n  h' = h\n  ?P,?t \\<turnstile> \\<langle>?a\\<bullet>interrupted([]),\n                     ?h\\<rangle> -\\<lbrace>IsInterrupted ?t True,\n  ClearInterrupt ?t,\n  ObsInterrupted\n   ?t\\<rbrace>\\<rightarrow>ext \\<langle>RetVal (Bool True),?h\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>va h'.\n        P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                         h\\<rangle> -\\<lbrace>IsInterrupted t True,\n        ClearInterrupt t,\n        ObsInterrupted\n         t\\<rbrace>\\<rightarrow>ext \\<langle>va,\n                                    h'\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>IsInterrupted t True,\n  ClearInterrupt t,\n  ObsInterrupted t\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (7 subgoals):\n 1. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = interrupted;\n     vs = []; ta = \\<lbrace>IsInterrupted t False\\<rbrace>;\n     va = RetVal (Bool False); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 7. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n     ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)", "ultimately"], ["proof (chain)\npicking this:\n  final_thread.actions_ok final s t \\<lbrace>IsInterrupted t True,\n   ClearInterrupt t, ObsInterrupted t\\<rbrace>\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>IsInterrupted t True,\n  ClearInterrupt t,\n  ObsInterrupted t\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  final_thread.actions_ok final s t \\<lbrace>IsInterrupted t True,\n   ClearInterrupt t, ObsInterrupted t\\<rbrace>\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -\\<lbrace>IsInterrupted t True,\n  ClearInterrupt t,\n  ObsInterrupted t\\<rbrace>\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>ta' va' h'.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                        h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                  h'\\<rangle> \\<and>\n       (final_thread.actions_ok final s t ta' \\<or>\n        final_thread.actions_ok' s t ta' \\<and>\n        final_thread.actions_subset ta' ta)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                h'\\<rangle> \\<and>\n     (final_thread.actions_ok final s t ta' \\<or>\n      final_thread.actions_ok' s t ta' \\<and>\n      final_thread.actions_subset ta' ta)\n\ngoal (6 subgoals):\n 1. \\<And>obs a'.\n       \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n        ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' va' h'.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n       h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                            (final_thread.actions_ok final s t ta' \\<or>\n                             final_thread.actions_ok' s t ta' \\<and>\n                             final_thread.actions_subset ta' ta)\n 2. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>; va = RetEXC OutOfMemory;\n     heap_clone P h a h' None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 3. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = hashcode; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Intg (word_of_int (hash_addr a))); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 4. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = print;\n     ta = \\<lbrace>ExternalCall a print vs Unit\\<rbrace>; va = RetVal Unit;\n     h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 5. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = currentThread;\n     vs = []; ta = \\<lbrace>\\<rbrace>;\n     va = RetVal (Addr (thread_id2addr t)); h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)\n 6. \\<lbrakk>\\<not> final_thread.actions_ok' s t ta; M = yield; vs = [];\n     ta = \\<lbrace>Yield\\<rbrace>; va = RetVal Unit; h' = h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' va' h'.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n    h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',h'\\<rangle> \\<and>\n                         (final_thread.actions_ok final s t ta' \\<or>\n                          final_thread.actions_ok' s t ta' \\<and>\n                          final_thread.actions_subset ta' ta)", "qed(auto simp add: None)"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                h'\\<rangle> \\<and>\n     (final_thread.actions_ok final s t ta' \\<or>\n      final_thread.actions_ok' s t ta' \\<and>\n      final_thread.actions_subset ta' ta)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                h'\\<rangle> \\<and>\n     (final_thread.actions_ok final s t ta' \\<or>\n      final_thread.actions_ok' s t ta' \\<and>\n      final_thread.actions_subset ta' ta)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ta' va' h'.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                h'\\<rangle> \\<and>\n     (final_thread.actions_ok final s t ta' \\<or>\n      final_thread.actions_ok' s t ta' \\<and>\n      final_thread.actions_subset ta' ta)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context heap_base begin"], ["", "lemma red_external_ta_satisfiable:\n  fixes final\n  assumes \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>\"\n  shows \"\\<exists>s. final_thread.actions_ok final s t ta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s. final_thread.actions_ok final s t ta", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s. final_thread.actions_ok final s t ta", "note [simp] =\n    final_thread.actions_ok_iff final_thread.cond_action_oks.simps final_thread.cond_action_ok.simps\n    lock_ok_las_def finfun_upd_apply wset_actions_ok_def has_lock_may_lock\n    and [intro] =\n    free_thread_id.intros\n    and [cong] = conj_cong"], ["proof (state)\nthis:\n  final_thread.actions_ok ?final ?s ?t ?ta =\n  (lock_ok_las (locks ?s) ?t \\<lbrace>?ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n   thread_oks (thr ?s) \\<lbrace>?ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n   final_thread.cond_action_oks ?final ?s ?t\n    \\<lbrace>?ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n   wset_actions_ok (wset ?s) ?t\n    \\<lbrace>?ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n   interrupt_actions_ok (interrupts ?s)\n    \\<lbrace>?ta\\<rbrace>\\<^bsub>i\\<^esub>)\n  final_thread.cond_action_oks ?final ?s ?t [] = True\n  final_thread.cond_action_oks ?final ?s ?t (?ct # ?cts) =\n  (final_thread.cond_action_ok ?final ?s ?t ?ct \\<and>\n   final_thread.cond_action_oks ?final ?s ?t ?cts)\n  final_thread.cond_action_ok ?final ?s ?t (Join ?T) =\n  (case thr ?s ?T of None \\<Rightarrow> True\n   | \\<lfloor>(x, ln)\\<rfloor> \\<Rightarrow>\n       ?t \\<noteq> ?T \\<and>\n       ?final x \\<and> ln = no_wait_locks \\<and> wset ?s ?T = None)\n  final_thread.cond_action_ok ?final ?s ?t Yield = True\n  lock_ok_las ?ls ?t ?las \\<equiv>\n  \\<forall>l. lock_actions_ok (?ls $ l) ?t (?las $ l)\n  ?f(?a $:= ?b) $ ?a' = (if ?a = ?a' then ?b else ?f $ ?a')\n  wset_actions_ok ?ws ?t ?was =\n  (if Notified \\<in> set ?was\n   then ?ws ?t = \\<lfloor>PostWS WSNotified\\<rfloor>\n   else if WokenUp \\<in> set ?was\n        then ?ws ?t = \\<lfloor>PostWS WSWokenUp\\<rfloor> else ?ws ?t = None)\n  has_lock ?l ?t \\<Longrightarrow> may_lock ?l ?t\n  ?ts ?t = None \\<Longrightarrow> free_thread_id ?ts ?t\n  \\<lbrakk>?P = ?P'; ?P' \\<Longrightarrow> ?Q = ?Q'\\<rbrakk>\n  \\<Longrightarrow> (?P \\<and> ?Q) = (?P' \\<and> ?Q')\n\ngoal (1 subgoal):\n 1. \\<exists>s. final_thread.actions_ok final s t ta", "from assms"], ["proof (chain)\npicking this:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>s. final_thread.actions_ok final s t ta", "by cases(fastforce intro: exI[where x=\"(K$ None)(a $:= \\<lfloor>(t, 0)\\<rfloor>)\"] exI[where x=\"(K$ None)\"])+"], ["proof (state)\nthis:\n  \\<exists>s. final_thread.actions_ok final s t ta\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma red_external_aggr_ta_satisfiable:\n  fixes final\n  assumes \"(ta, va, h') \\<in> red_external_aggr P t a M vs h\"\n  shows \"\\<exists>s. final_thread.actions_ok final s t ta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s. final_thread.actions_ok final s t ta", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s. final_thread.actions_ok final s t ta", "note [simp] =\n    final_thread.actions_ok_iff final_thread.cond_action_oks.simps final_thread.cond_action_ok.simps\n    lock_ok_las_def finfun_upd_apply wset_actions_ok_def has_lock_may_lock\n    and [intro] =\n    free_thread_id.intros\n    and [cong] = conj_cong"], ["proof (state)\nthis:\n  final_thread.actions_ok ?final ?s ?t ?ta =\n  (lock_ok_las (locks ?s) ?t \\<lbrace>?ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n   thread_oks (thr ?s) \\<lbrace>?ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n   final_thread.cond_action_oks ?final ?s ?t\n    \\<lbrace>?ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n   wset_actions_ok (wset ?s) ?t\n    \\<lbrace>?ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n   interrupt_actions_ok (interrupts ?s)\n    \\<lbrace>?ta\\<rbrace>\\<^bsub>i\\<^esub>)\n  final_thread.cond_action_oks ?final ?s ?t [] = True\n  final_thread.cond_action_oks ?final ?s ?t (?ct # ?cts) =\n  (final_thread.cond_action_ok ?final ?s ?t ?ct \\<and>\n   final_thread.cond_action_oks ?final ?s ?t ?cts)\n  final_thread.cond_action_ok ?final ?s ?t (Join ?T) =\n  (case thr ?s ?T of None \\<Rightarrow> True\n   | \\<lfloor>(x, ln)\\<rfloor> \\<Rightarrow>\n       ?t \\<noteq> ?T \\<and>\n       ?final x \\<and> ln = no_wait_locks \\<and> wset ?s ?T = None)\n  final_thread.cond_action_ok ?final ?s ?t Yield = True\n  lock_ok_las ?ls ?t ?las \\<equiv>\n  \\<forall>l. lock_actions_ok (?ls $ l) ?t (?las $ l)\n  ?f(?a $:= ?b) $ ?a' = (if ?a = ?a' then ?b else ?f $ ?a')\n  wset_actions_ok ?ws ?t ?was =\n  (if Notified \\<in> set ?was\n   then ?ws ?t = \\<lfloor>PostWS WSNotified\\<rfloor>\n   else if WokenUp \\<in> set ?was\n        then ?ws ?t = \\<lfloor>PostWS WSWokenUp\\<rfloor> else ?ws ?t = None)\n  has_lock ?l ?t \\<Longrightarrow> may_lock ?l ?t\n  ?ts ?t = None \\<Longrightarrow> free_thread_id ?ts ?t\n  \\<lbrakk>?P = ?P'; ?P' \\<Longrightarrow> ?Q = ?Q'\\<rbrakk>\n  \\<Longrightarrow> (?P \\<and> ?Q) = (?P' \\<and> ?Q')\n\ngoal (1 subgoal):\n 1. \\<exists>s. final_thread.actions_ok final s t ta", "from assms"], ["proof (chain)\npicking this:\n  (ta, va, h') \\<in> red_external_aggr P t a M vs h", "show ?thesis"], ["proof (prove)\nusing this:\n  (ta, va, h') \\<in> red_external_aggr P t a M vs h\n\ngoal (1 subgoal):\n 1. \\<exists>s. final_thread.actions_ok final s t ta", "by(fastforce simp add: red_external_aggr_def split_beta ta_upd_simps split: if_split_asm intro: exI[where x=\"Map.empty\"] exI[where x=\"(K$ None)(a $:= \\<lfloor>(t, 0)\\<rfloor>)\"] exI[where x=\"K$ None\"])"], ["proof (state)\nthis:\n  \\<exists>s. final_thread.actions_ok final s t ta\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Determinism\\<close>"], ["", "context heap_base begin"], ["", "lemma heap_copy_loc_deterministic:\n  assumes det: \"deterministic_heap_ops\"\n  and copy: \"heap_copy_loc a a' al h ops h'\" \"heap_copy_loc a a' al h ops' h''\"\n  shows \"ops = ops' \\<and> h' = h''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ops = ops' \\<and> h' = h''", "using copy"], ["proof (prove)\nusing this:\n  heap_copy_loc a a' al h ops h'\n  heap_copy_loc a a' al h ops' h''\n\ngoal (1 subgoal):\n 1. ops = ops' \\<and> h' = h''", "by(auto elim!: heap_copy_loc.cases dest: deterministic_heap_ops_readD[OF det] deterministic_heap_ops_writeD[OF det])"], ["", "lemma heap_copies_deterministic:\n  assumes det: \"deterministic_heap_ops\"\n  and copy: \"heap_copies a a' als h ops h'\" \"heap_copies a a' als h ops' h''\"\n  shows \"ops = ops' \\<and> h' = h''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ops = ops' \\<and> h' = h''", "using copy"], ["proof (prove)\nusing this:\n  heap_copies a a' als h ops h'\n  heap_copies a a' als h ops' h''\n\ngoal (1 subgoal):\n 1. ops = ops' \\<and> h' = h''", "apply(induct arbitrary: ops' h'')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h ops' h''.\n       heap_copies a a' [] h ops' h'' \\<Longrightarrow>\n       [] = ops' \\<and> h = h''\n 2. \\<And>al h ob h' als obs h'' ops' h''a.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>ops' h''a.\n           heap_copies a a' als h' ops' h''a \\<Longrightarrow>\n           obs = ops' \\<and> h'' = h''a;\n        heap_copies a a' (al # als) h ops' h''a\\<rbrakk>\n       \\<Longrightarrow> ob @ obs = ops' \\<and> h'' = h''a", "apply(fastforce elim!: heap_copies_cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' ops' h''a.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>ops' h''a.\n           heap_copies a a' als h' ops' h''a \\<Longrightarrow>\n           obs = ops' \\<and> h'' = h''a;\n        heap_copies a a' (al # als) h ops' h''a\\<rbrakk>\n       \\<Longrightarrow> ob @ obs = ops' \\<and> h'' = h''a", "apply(erule heap_copies_cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' ops' h''a oba h'a obsa.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>ops' h''a.\n           heap_copies a a' als h' ops' h''a \\<Longrightarrow>\n           obs = ops' \\<and> h'' = h''a;\n        ops' = oba @ obsa; heap_copy_loc a a' al h oba h'a;\n        heap_copies a a' als h'a obsa h''a\\<rbrakk>\n       \\<Longrightarrow> ob @ obs = ops' \\<and> h'' = h''a", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' ops' h''a oba h'a obsa.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>ops' h''a.\n           heap_copies a a' als h' ops' h''a \\<Longrightarrow>\n           obs = ops' \\<and> h'' = h''a;\n        heap_copy_loc a a' al h oba h'a;\n        heap_copies a a' als h'a obsa h''a\\<rbrakk>\n       \\<Longrightarrow> ob @ obs = oba @ obsa \\<and> h'' = h''a", "apply(drule (1) heap_copy_loc_deterministic[OF det])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' ops' h''a oba h'a obsa.\n       \\<lbrakk>heap_copies a a' als h' obs h'';\n        \\<And>ops' h''a.\n           heap_copies a a' als h' ops' h''a \\<Longrightarrow>\n           obs = ops' \\<and> h'' = h''a;\n        heap_copy_loc a a' al h oba h'a; heap_copies a a' als h'a obsa h''a;\n        ob = oba \\<and> h' = h'a\\<rbrakk>\n       \\<Longrightarrow> ob @ obs = oba @ obsa \\<and> h'' = h''a", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' ops' h''a oba h'a obsa.\n       \\<lbrakk>heap_copies a a' als h'a obs h'';\n        \\<And>ops' h''a.\n           heap_copies a a' als h'a ops' h''a \\<Longrightarrow>\n           obs = ops' \\<and> h'' = h''a;\n        heap_copy_loc a a' al h oba h'a;\n        heap_copies a a' als h'a obsa h''a\\<rbrakk>\n       \\<Longrightarrow> oba @ obs = oba @ obsa \\<and> h'' = h''a", "apply(unfold same_append_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' ops' h''a oba h'a obsa.\n       \\<lbrakk>heap_copies a a' als h'a obs h'';\n        \\<And>ops' h''a.\n           heap_copies a a' als h'a ops' h''a \\<Longrightarrow>\n           obs = ops' \\<and> h'' = h''a;\n        heap_copy_loc a a' al h oba h'a;\n        heap_copies a a' als h'a obsa h''a\\<rbrakk>\n       \\<Longrightarrow> obs = obsa \\<and> h'' = h''a", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma heap_clone_deterministic:\n  assumes det: \"deterministic_heap_ops\"\n  and clone: \"heap_clone P h a h' obs\" \"heap_clone P h a h'' obs'\"\n  shows \"h' = h'' \\<and> obs = obs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h' = h'' \\<and> obs = obs'", "using clone"], ["proof (prove)\nusing this:\n  heap_clone P h a h' obs\n  heap_clone P h a h'' obs'\n\ngoal (1 subgoal):\n 1. h' = h'' \\<and> obs = obs'", "by(auto 4 4 elim!: heap_clone.cases dest: heap_copies_deterministic[OF det] deterministic_heap_ops_allocateD[OF det] has_fields_fun)"], ["", "lemma red_external_deterministic:\n  fixes final\n  assumes det: \"deterministic_heap_ops\"\n  and red: \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), (shr s)\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>\" \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), (shr s)\\<rangle> -ta'\\<rightarrow>ext \\<langle>va', h''\\<rangle>\"\n  and aok: \"final_thread.actions_ok final s t ta\" \"final_thread.actions_ok final s t ta'\"\n  shows \"ta = ta' \\<and> va = va' \\<and> h' = h''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta = ta' \\<and> va = va' \\<and> h' = h''", "using red aok"], ["proof (prove)\nusing this:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   shr s\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                h'\\<rangle>\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   shr s\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                 h''\\<rangle>\n  final_thread.actions_ok final s t ta\n  final_thread.actions_ok final s t ta'\n\ngoal (1 subgoal):\n 1. ta = ta' \\<and> va = va' \\<and> h' = h''", "apply(simp add: final_thread.actions_ok_iff lock_ok_las_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                              shr s\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                           h'\\<rangle>;\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      shr s\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                    h''\\<rangle>;\n     (\\<forall>l.\n         lock_actions_ok (locks s $ l) t\n          (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n     thread_oks (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n     final_thread.cond_action_oks final s t\n      \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     wset_actions_ok (wset s) t \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n     interrupt_actions_ok (interrupts s)\n      \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n     (\\<forall>l.\n         lock_actions_ok (locks s $ l) t\n          (\\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n     thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n     final_thread.cond_action_oks final s t\n      \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     wset_actions_ok (wset s) t\n      \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n     interrupt_actions_ok (interrupts s)\n      \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> ta = ta' \\<and> va = va' \\<and> h' = h''", "apply(erule red_external.cases)"], ["proof (prove)\ngoal (26 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                                 shr s\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                               h''\\<rangle>;\n        (\\<forall>l.\n            lock_actions_ok (locks s $ l) t\n             (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n        thread_oks (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n        final_thread.cond_action_oks final s t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n        wset_actions_ok (wset s) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n        (\\<forall>l.\n            lock_actions_ok (locks s $ l) t\n             (\\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n        final_thread.cond_action_oks final s t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n        wset_actions_ok (wset s) t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        M = start; vs = [];\n        ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) (shr s),\n        ThreadStart (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> va = va' \\<and> h' = h''\n 2. \\<And>C.\n       \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                                 shr s\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                               h''\\<rangle>;\n        (\\<forall>l.\n            lock_actions_ok (locks s $ l) t\n             (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n        thread_oks (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n        final_thread.cond_action_oks final s t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n        wset_actions_ok (wset s) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n        (\\<forall>l.\n            lock_actions_ok (locks s $ l) t\n             (\\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n        final_thread.cond_action_oks final s t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n        wset_actions_ok (wset s) t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        M = start; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>;\n        va = RetEXC IllegalThreadState; h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> va = va' \\<and> h' = h''\n 3. \\<And>C.\n       \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                                 shr s\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                               h''\\<rangle>;\n        (\\<forall>l.\n            lock_actions_ok (locks s $ l) t\n             (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n        thread_oks (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n        final_thread.cond_action_oks final s t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n        wset_actions_ok (wset s) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n        (\\<forall>l.\n            lock_actions_ok (locks s $ l) t\n             (\\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n        final_thread.cond_action_oks final s t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n        wset_actions_ok (wset s) t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        M = join; vs = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> va = va' \\<and> h' = h''\n 4. \\<And>C.\n       \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                                 shr s\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                               h''\\<rangle>;\n        (\\<forall>l.\n            lock_actions_ok (locks s $ l) t\n             (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n        thread_oks (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n        final_thread.cond_action_oks final s t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n        wset_actions_ok (wset s) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n        (\\<forall>l.\n            lock_actions_ok (locks s $ l) t\n             (\\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n        final_thread.cond_action_oks final s t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n        wset_actions_ok (wset s) t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> va = va' \\<and> h' = h''\n 5. \\<And>C.\n       \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                                 shr s\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                               h''\\<rangle>;\n        (\\<forall>l.\n            lock_actions_ok (locks s $ l) t\n             (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n        thread_oks (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n        final_thread.cond_action_oks final s t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n        wset_actions_ok (wset s) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n        (\\<forall>l.\n            lock_actions_ok (locks s $ l) t\n             (\\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n        final_thread.cond_action_oks final s t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n        wset_actions_ok (wset s) t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        M = interrupt; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> va = va' \\<and> h' = h''\n 6. \\<And>C.\n       \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                                 shr s\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                               h''\\<rangle>;\n        (\\<forall>l.\n            lock_actions_ok (locks s $ l) t\n             (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n        thread_oks (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n        final_thread.cond_action_oks final s t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n        wset_actions_ok (wset s) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n        (\\<forall>l.\n            lock_actions_ok (locks s $ l) t\n             (\\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n        final_thread.cond_action_oks final s t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n        wset_actions_ok (wset s) t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        M = interrupt; vs = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> va = va' \\<and> h' = h''\n 7. \\<And>C.\n       \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                                 shr s\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                               h''\\<rangle>;\n        (\\<forall>l.\n            lock_actions_ok (locks s $ l) t\n             (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n        thread_oks (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n        final_thread.cond_action_oks final s t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n        wset_actions_ok (wset s) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n        (\\<forall>l.\n            lock_actions_ok (locks s $ l) t\n             (\\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n        final_thread.cond_action_oks final s t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n        wset_actions_ok (wset s) t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        M = isInterrupted; vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> va = va' \\<and> h' = h''\n 8. \\<And>C.\n       \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                                 shr s\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                               h''\\<rangle>;\n        (\\<forall>l.\n            lock_actions_ok (locks s $ l) t\n             (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n        thread_oks (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n        final_thread.cond_action_oks final s t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n        wset_actions_ok (wset s) t\n         \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n        (\\<forall>l.\n            lock_actions_ok (locks s $ l) t\n             (\\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n        final_thread.cond_action_oks final s t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n        wset_actions_ok (wset s) t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        M = isInterrupted; vs = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> va = va' \\<and> h' = h''\n 9. \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                              shr s\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                            h''\\<rangle>;\n     (\\<forall>l.\n         lock_actions_ok (locks s $ l) t\n          (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n     thread_oks (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n     final_thread.cond_action_oks final s t\n      \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     wset_actions_ok (wset s) t \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n     interrupt_actions_ok (interrupts s)\n      \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n     (\\<forall>l.\n         lock_actions_ok (locks s $ l) t\n          (\\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n     thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n     final_thread.cond_action_oks final s t\n      \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     wset_actions_ok (wset s) t\n      \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n     interrupt_actions_ok (interrupts s)\n      \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n     M = wait; vs = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = shr s\\<rbrakk>\n    \\<Longrightarrow> ta = ta' \\<and> va = va' \\<and> h' = h''\n 10. \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                               shr s\\<rangle> -ta'\\<rightarrow>ext \\<langle>va',\n                             h''\\<rangle>;\n      (\\<forall>l.\n          lock_actions_ok (locks s $ l) t\n           (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n      thread_oks (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n      final_thread.cond_action_oks final s t\n       \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n      wset_actions_ok (wset s) t\n       \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n      interrupt_actions_ok (interrupts s)\n       \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n      (\\<forall>l.\n          lock_actions_ok (locks s $ l) t\n           (\\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n      thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n      final_thread.cond_action_oks final s t\n       \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n      wset_actions_ok (wset s) t\n       \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n      interrupt_actions_ok (interrupts s)\n       \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n      M = wait; vs = [];\n      ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>;\n      va = RetStaySame; h' = shr s\\<rbrakk>\n     \\<Longrightarrow> ta = ta' \\<and> va = va' \\<and> h' = h''\nA total of 26 subgoals...", "apply(erule_tac [!] red_external.cases)"], ["proof (prove)\ngoal (676 subgoals):\n 1. \\<And>C Ca.\n       \\<lbrakk>(\\<forall>l.\n                    lock_actions_ok (locks s $ l) t\n                     (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n                thread_oks (thr s)\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n                final_thread.cond_action_oks final s t\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                wset_actions_ok (wset s) t\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n                interrupt_actions_ok (interrupts s)\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n        (\\<forall>l.\n            lock_actions_ok (locks s $ l) t\n             (\\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n        final_thread.cond_action_oks final s t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n        wset_actions_ok (wset s) t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        M = start; vs = [];\n        ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) (shr s),\n        ThreadStart (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread; M = start; vs = [];\n        ta' = \\<lbrace>NewThread (addr2thread_id a) (Ca, run, a) (shr s),\n        ThreadStart (addr2thread_id a)\\<rbrace>;\n        va' = RetVal Unit; h'' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type Ca\\<rfloor>;\n        P \\<turnstile> Ca \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> va = va' \\<and> h' = h''\n 2. \\<And>C Ca.\n       \\<lbrakk>(\\<forall>l.\n                    lock_actions_ok (locks s $ l) t\n                     (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n                thread_oks (thr s)\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n                final_thread.cond_action_oks final s t\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                wset_actions_ok (wset s) t\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n                interrupt_actions_ok (interrupts s)\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n        (\\<forall>l.\n            lock_actions_ok (locks s $ l) t\n             (\\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n        final_thread.cond_action_oks final s t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n        wset_actions_ok (wset s) t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        M = start; vs = [];\n        ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) (shr s),\n        ThreadStart (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread; M = start; vs = [];\n        ta' = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>;\n        va' = RetEXC IllegalThreadState; h'' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type Ca\\<rfloor>;\n        P \\<turnstile> Ca \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> va = va' \\<and> h' = h''\n 3. \\<And>C Ca.\n       \\<lbrakk>(\\<forall>l.\n                    lock_actions_ok (locks s $ l) t\n                     (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n                thread_oks (thr s)\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n                final_thread.cond_action_oks final s t\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                wset_actions_ok (wset s) t\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n                interrupt_actions_ok (interrupts s)\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n        (\\<forall>l.\n            lock_actions_ok (locks s $ l) t\n             (\\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n        final_thread.cond_action_oks final s t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n        wset_actions_ok (wset s) t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        M = start; vs = [];\n        ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) (shr s),\n        ThreadStart (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread; M = join; vs = [];\n        ta' = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va' = RetVal Unit; h'' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type Ca\\<rfloor>;\n        P \\<turnstile> Ca \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> va = va' \\<and> h' = h''\n 4. \\<And>C Ca.\n       \\<lbrakk>(\\<forall>l.\n                    lock_actions_ok (locks s $ l) t\n                     (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n                thread_oks (thr s)\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n                final_thread.cond_action_oks final s t\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                wset_actions_ok (wset s) t\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n                interrupt_actions_ok (interrupts s)\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n        (\\<forall>l.\n            lock_actions_ok (locks s $ l) t\n             (\\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n        final_thread.cond_action_oks final s t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n        wset_actions_ok (wset s) t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        M = start; vs = [];\n        ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) (shr s),\n        ThreadStart (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread; M = join; vs = [];\n        ta' = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va' = RetEXC InterruptedException; h'' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type Ca\\<rfloor>;\n        P \\<turnstile> Ca \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> va = va' \\<and> h' = h''\n 5. \\<And>C Ca.\n       \\<lbrakk>(\\<forall>l.\n                    lock_actions_ok (locks s $ l) t\n                     (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n                thread_oks (thr s)\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n                final_thread.cond_action_oks final s t\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                wset_actions_ok (wset s) t\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n                interrupt_actions_ok (interrupts s)\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n        (\\<forall>l.\n            lock_actions_ok (locks s $ l) t\n             (\\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n        final_thread.cond_action_oks final s t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n        wset_actions_ok (wset s) t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        M = start; vs = [];\n        ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) (shr s),\n        ThreadStart (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread; M = interrupt; vs = [];\n        ta' = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va' = RetVal Unit; h'' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type Ca\\<rfloor>;\n        P \\<turnstile> Ca \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> va = va' \\<and> h' = h''\n 6. \\<And>C Ca.\n       \\<lbrakk>(\\<forall>l.\n                    lock_actions_ok (locks s $ l) t\n                     (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n                thread_oks (thr s)\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n                final_thread.cond_action_oks final s t\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                wset_actions_ok (wset s) t\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n                interrupt_actions_ok (interrupts s)\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n        (\\<forall>l.\n            lock_actions_ok (locks s $ l) t\n             (\\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n        final_thread.cond_action_oks final s t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n        wset_actions_ok (wset s) t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        M = start; vs = [];\n        ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) (shr s),\n        ThreadStart (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread; M = interrupt; vs = [];\n        ta' = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va' = RetVal Unit; h'' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type Ca\\<rfloor>;\n        P \\<turnstile> Ca \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> va = va' \\<and> h' = h''\n 7. \\<And>C Ca.\n       \\<lbrakk>(\\<forall>l.\n                    lock_actions_ok (locks s $ l) t\n                     (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n                thread_oks (thr s)\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n                final_thread.cond_action_oks final s t\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                wset_actions_ok (wset s) t\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n                interrupt_actions_ok (interrupts s)\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n        (\\<forall>l.\n            lock_actions_ok (locks s $ l) t\n             (\\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n        final_thread.cond_action_oks final s t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n        wset_actions_ok (wset s) t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        M = start; vs = [];\n        ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) (shr s),\n        ThreadStart (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread; M = isInterrupted;\n        vs = [];\n        ta' = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va' = RetVal (Bool True); h'' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type Ca\\<rfloor>;\n        P \\<turnstile> Ca \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> va = va' \\<and> h' = h''\n 8. \\<And>C Ca.\n       \\<lbrakk>(\\<forall>l.\n                    lock_actions_ok (locks s $ l) t\n                     (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n                thread_oks (thr s)\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n                final_thread.cond_action_oks final s t\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                wset_actions_ok (wset s) t\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n                interrupt_actions_ok (interrupts s)\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n        (\\<forall>l.\n            lock_actions_ok (locks s $ l) t\n             (\\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n        final_thread.cond_action_oks final s t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n        wset_actions_ok (wset s) t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        M = start; vs = [];\n        ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) (shr s),\n        ThreadStart (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread; M = isInterrupted;\n        vs = [];\n        ta' = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va' = RetVal (Bool False); h'' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type Ca\\<rfloor>;\n        P \\<turnstile> Ca \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> va = va' \\<and> h' = h''\n 9. \\<And>C.\n       \\<lbrakk>(\\<forall>l.\n                    lock_actions_ok (locks s $ l) t\n                     (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n                thread_oks (thr s)\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n                final_thread.cond_action_oks final s t\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                wset_actions_ok (wset s) t\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n                interrupt_actions_ok (interrupts s)\n                 \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n        (\\<forall>l.\n            lock_actions_ok (locks s $ l) t\n             (\\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n        final_thread.cond_action_oks final s t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n        wset_actions_ok (wset s) t\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        M = start; vs = [];\n        ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) (shr s),\n        ThreadStart (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread; M = wait; vs = [];\n        ta' = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n        ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n        va' = RetEXC InterruptedException; h'' = shr s\\<rbrakk>\n       \\<Longrightarrow> ta = ta' \\<and> va = va' \\<and> h' = h''\n 10. \\<And>C.\n        \\<lbrakk>(\\<forall>l.\n                     lock_actions_ok (locks s $ l) t\n                      (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n                 thread_oks (thr s)\n                  \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n                 final_thread.cond_action_oks final s t\n                  \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                 wset_actions_ok (wset s) t\n                  \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n                 interrupt_actions_ok (interrupts s)\n                  \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n         (\\<forall>l.\n             lock_actions_ok (locks s $ l) t\n              (\\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> $ l)) \\<and>\n         thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n         final_thread.cond_action_oks final s t\n          \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n         wset_actions_ok (wset s) t\n          \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n         interrupt_actions_ok (interrupts s)\n          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n         M = start; vs = [];\n         ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) (shr s),\n         ThreadStart (addr2thread_id a)\\<rbrace>;\n         va = RetVal Unit; h' = shr s;\n         typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n         P \\<turnstile> C \\<preceq>\\<^sup>* Thread; M = wait; vs = [];\n         ta' = \\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n         (ReleaseAcquire, a), IsInterrupted t False, SyncUnlock a\\<rbrace>;\n         va' = RetStaySame; h'' = shr s\\<rbrakk>\n        \\<Longrightarrow> ta = ta' \\<and> va = va' \\<and> h' = h''\nA total of 676 subgoals...", "apply simp_all"], ["proof (prove)\ngoal (34 subgoals):\n 1. \\<lbrakk>(\\<forall>l.\n                 lock_actions_ok (locks s $ l) t\n                  ((K$ [])(a $:= [Unlock, Lock]) $ l)) \\<and>\n             final_thread.cond_action_oks final s t [] \\<and>\n             wset s t = None \\<and> t \\<in> interrupts s;\n     \\<forall>l.\n        lock_actions_ok (locks s $ l) t ((K$ [])(a $:= [UnlockFail]) $ l);\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = shr s; M = wait; vs = [];\n     ta' = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va' = RetEXC IllegalMonitorState; h'' = shr s\\<rbrakk>\n    \\<Longrightarrow> \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n                      ClearInterrupt t, ObsInterrupted t\\<rbrace> =\n                      \\<lbrace>(UnlockFail, a)\\<rbrace> \\<and>\n                      addr_of_sys_xcpt InterruptedException =\n                      addr_of_sys_xcpt IllegalMonitorState\n 2. \\<lbrakk>(\\<forall>l.\n                 lock_actions_ok (locks s $ l) t\n                  ((K$ [])(a $:= [Unlock, Lock]) $ l)) \\<and>\n             final_thread.cond_action_oks final s t [] \\<and>\n             wset s t = None \\<and> t \\<in> interrupts s;\n     wset_actions_ok (wset s) t [Notified];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = shr s; M = wait; vs = [];\n     ta' = \\<lbrace>Notified\\<rbrace>; va' = RetVal Unit;\n     h'' = shr s\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>(\\<forall>l.\n                 lock_actions_ok (locks s $ l) t\n                  ((K$ [])(a $:= [Unlock, Lock]) $ l)) \\<and>\n             final_thread.cond_action_oks final s t [] \\<and>\n             wset s t = None \\<and> t \\<in> interrupts s;\n     wset_actions_ok (wset s) t [WokenUp];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = shr s; M = wait; vs = [];\n     ta' = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va' = RetEXC InterruptedException; h'' = shr s\\<rbrakk>\n    \\<Longrightarrow> \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n                      ClearInterrupt t, ObsInterrupted t\\<rbrace> =\n                      \\<lbrace>WokenUp, ClearInterrupt t,\n                      ObsInterrupted t\\<rbrace>\n 4. \\<lbrakk>(\\<forall>l.\n                 lock_actions_ok (locks s $ l) t\n                  ((K$ [])(a $:= [Unlock, Lock, ReleaseAcquire]) $\n                   l)) \\<and>\n             final_thread.cond_action_oks final s t [] \\<and>\n             wset_actions_ok (wset s) t [Suspend a] \\<and>\n             t \\<notin> interrupts s;\n     (\\<forall>l.\n         lock_actions_ok (locks s $ l) t\n          ((K$ [])(a $:= [UnlockFail]) $ l)) \\<and>\n     wset s t = None;\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = shr s; M = wait; vs = [];\n     ta' = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va' = RetEXC IllegalMonitorState; h'' = shr s\\<rbrakk>\n    \\<Longrightarrow> False\n 5. \\<lbrakk>(\\<forall>l.\n                 lock_actions_ok (locks s $ l) t\n                  ((K$ [])(a $:= [Unlock, Lock, ReleaseAcquire]) $\n                   l)) \\<and>\n             final_thread.cond_action_oks final s t [] \\<and>\n             wset_actions_ok (wset s) t [Suspend a] \\<and>\n             t \\<notin> interrupts s;\n     wset_actions_ok (wset s) t [Notified];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = shr s; M = wait; vs = [];\n     ta' = \\<lbrace>Notified\\<rbrace>; va' = RetVal Unit;\n     h'' = shr s\\<rbrakk>\n    \\<Longrightarrow> False\n 6. \\<lbrakk>(\\<forall>l.\n                 lock_actions_ok (locks s $ l) t\n                  ((K$ [])(a $:= [Unlock, Lock, ReleaseAcquire]) $\n                   l)) \\<and>\n             final_thread.cond_action_oks final s t [] \\<and>\n             wset_actions_ok (wset s) t [Suspend a] \\<and>\n             t \\<notin> interrupts s;\n     wset_actions_ok (wset s) t [WokenUp];\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = shr s; M = wait; vs = [];\n     ta' = \\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va' = RetEXC InterruptedException; h'' = shr s\\<rbrakk>\n    \\<Longrightarrow> False\n 7. \\<lbrakk>(\\<forall>l.\n                 lock_actions_ok (locks s $ l) t\n                  ((K$ [])(a $:= [Unlock, Lock, ReleaseAcquire]) $\n                   l)) \\<and>\n             final_thread.cond_action_oks final s t [] \\<and>\n             wset_actions_ok (wset s) t [Suspend a] \\<and>\n             t \\<notin> interrupts s;\n     wset s t = None;\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = shr s; M = wait; vs = [];\n     ta' = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va' = RetVal Unit; h'' = shr s; spurious_wakeups\\<rbrakk>\n    \\<Longrightarrow> False\n 8. \\<lbrakk>(\\<forall>l.\n                 lock_actions_ok (locks s $ l) t\n                  ((K$ [])(a $:= [UnlockFail]) $ l)) \\<and>\n             final_thread.cond_action_oks final s t [] \\<and>\n             wset s t = None;\n     (\\<forall>l.\n         lock_actions_ok (locks s $ l) t\n          ((K$ [])(a $:= [Unlock, Lock]) $ l)) \\<and>\n     t \\<in> interrupts s;\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = shr s; M = wait; vs = [];\n     ta' = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va' = RetEXC InterruptedException; h'' = shr s\\<rbrakk>\n    \\<Longrightarrow> \\<lbrace>(UnlockFail, a)\\<rbrace> =\n                      \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n                      ClearInterrupt t, ObsInterrupted t\\<rbrace> \\<and>\n                      addr_of_sys_xcpt IllegalMonitorState =\n                      addr_of_sys_xcpt InterruptedException\n 9. \\<lbrakk>(\\<forall>l.\n                 lock_actions_ok (locks s $ l) t\n                  ((K$ [])(a $:= [UnlockFail]) $ l)) \\<and>\n             final_thread.cond_action_oks final s t [] \\<and>\n             wset s t = None;\n     (\\<forall>l.\n         lock_actions_ok (locks s $ l) t\n          ((K$ [])(a $:= [Unlock, Lock, ReleaseAcquire]) $ l)) \\<and>\n     wset_actions_ok (wset s) t [Suspend a] \\<and> t \\<notin> interrupts s;\n     ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n     va = RetEXC IllegalMonitorState; h' = shr s; M = wait; vs = [];\n     ta' = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va' = RetStaySame; h'' = shr s\\<rbrakk>\n    \\<Longrightarrow> False\n 10. \\<lbrakk>(\\<forall>l.\n                  lock_actions_ok (locks s $ l) t\n                   ((K$ [])(a $:= [UnlockFail]) $ l)) \\<and>\n              final_thread.cond_action_oks final s t [] \\<and>\n              wset s t = None;\n      wset_actions_ok (wset s) t [Notified];\n      ta = \\<lbrace>(UnlockFail, a)\\<rbrace>;\n      va = RetEXC IllegalMonitorState; h' = shr s; M = wait; vs = [];\n      ta' = \\<lbrace>Notified\\<rbrace>; va' = RetVal Unit;\n      h'' = shr s\\<rbrakk>\n     \\<Longrightarrow> False\nA total of 34 subgoals...", "apply(auto simp add: finfun_upd_apply wset_actions_ok_def dest: heap_clone_deterministic[OF det] split: if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wset s t = None;\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = shr s; M = wait; vs = [];\n     ta' = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va' = RetVal Unit; h'' = shr s; spurious_wakeups;\n     final_thread.cond_action_oks final s t []; t \\<notin> interrupts s;\n     has_lock (locks s $ a) t; may_lock (locks s $ a) t\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n             IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = shr s; spurious_wakeups; M = wait; vs = [];\n     ta' = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va' = RetStaySame; h'' = shr s;\n     final_thread.cond_action_oks final s t []; wset s t = None;\n     t \\<notin> interrupts s; has_lock (locks s $ a) t;\n     may_lock (locks s $ a) t\\<rbrakk>\n    \\<Longrightarrow> False", "using deterministic_heap_ops_no_spurious_wakeups[OF det]"], ["proof (prove)\nusing this:\n  \\<not> spurious_wakeups\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wset s t = None;\n     ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetStaySame; h' = shr s; M = wait; vs = [];\n     ta' = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va' = RetVal Unit; h'' = shr s; spurious_wakeups;\n     final_thread.cond_action_oks final s t []; t \\<notin> interrupts s;\n     has_lock (locks s $ a) t; may_lock (locks s $ a) t\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>ta = \\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n             IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va = RetVal Unit; h' = shr s; spurious_wakeups; M = wait; vs = [];\n     ta' = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n     IsInterrupted t False, SyncUnlock a\\<rbrace>;\n     va' = RetStaySame; h'' = shr s;\n     final_thread.cond_action_oks final s t []; wset s t = None;\n     t \\<notin> interrupts s; has_lock (locks s $ a) t;\n     may_lock (locks s $ a) t\\<rbrakk>\n    \\<Longrightarrow> False", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"]]}