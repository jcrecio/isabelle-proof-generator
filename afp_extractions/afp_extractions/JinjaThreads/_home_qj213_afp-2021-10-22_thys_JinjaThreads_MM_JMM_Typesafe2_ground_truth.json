{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/MM/JMM_Typesafe2.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma jmm_addr_loc_type_conv_jmm_addr_loc_type' [simp, heap_independent]:\n  \"jmm_addr_loc_type P h = jmm_addr_loc_type' P\"", "lemma jmm_conf_conv_jmm_conf' [simp, heap_independent]:\n  \"jmm_conf P h = jmm_conf' P\"", "lemma jmm_heap'': \"heap'' addr2thread_id thread_id2addr jmm_allocate (jmm_typeof_addr' P) jmm_heap_write P\"", "lemma if_mthr_Runs_heap_read_typedI:\n  fixes final and r :: \"('addr, 't, 'x, 'heap, 'w, ('addr :: addr, 'thread_id) obs_event) semantics\"\n  assumes \"trsys.Runs (multithreaded_base.redT (final_thread.init_fin_final final) (multithreaded_base.init_fin final r) (map NormalAction \\<circ> convert_RA)) s \\<xi>\"\n  (is \"trsys.Runs ?redT _ _\")\n  and \"\\<And>ad al v T. \\<lbrakk> NormalAction (ReadMem ad al v) \\<in> lset (lconcat (lmap (llist_of \\<circ> obs_a \\<circ> snd) \\<xi>)); heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<rbrakk> \\<Longrightarrow> heap_base'.conf TYPE('heap) typeof_addr P v T\"\n  (is \"\\<And>ad al v T. \\<lbrakk> ?obs \\<xi> ad al v; ?adal ad al T \\<rbrakk> \\<Longrightarrow> ?conf v T\")\n  shows \"trsys.Runs (multithreaded_base.redT (final_thread.init_fin_final final) (if_heap_read_typed final r typeof_addr P) (map NormalAction \\<circ> convert_RA)) s \\<xi>\"\n  (is \"trsys.Runs ?redT' _ _\")", "lemma if_mthr_Runs_heap_read_typedD:\n  fixes final and r :: \"('addr, 't, 'x, 'heap, 'w, ('addr :: addr, 'thread_id) obs_event) semantics\"\n  assumes Runs': \"trsys.Runs (multithreaded_base.redT (final_thread.init_fin_final final) (if_heap_read_typed final r typeof_addr P) (map NormalAction \\<circ> convert_RA)) s \\<xi>\"\n  (is \"?Runs' s \\<xi>\")\n  and stuck: \"\\<And>ttas s' tta s''. \\<lbrakk>\n    multithreaded_base.RedT (final_thread.init_fin_final final) (if_heap_read_typed final r typeof_addr P) (map NormalAction \\<circ> convert_RA) s ttas s';\n    multithreaded_base.redT (final_thread.init_fin_final final) (multithreaded_base.init_fin final r) (map NormalAction \\<circ> convert_RA) s' tta s'' \\<rbrakk>\n  \\<Longrightarrow> \\<exists>tta s''. multithreaded_base.redT (final_thread.init_fin_final final) (if_heap_read_typed final r typeof_addr P) (map NormalAction \\<circ> convert_RA) s' tta s''\"\n  (is \"\\<And>ttas s' tta s''. \\<lbrakk> ?RedT' s ttas s'; ?redT s' tta s'' \\<rbrakk> \\<Longrightarrow> \\<exists>tta s''. ?redT' s' tta s''\")\n  shows \"trsys.Runs (multithreaded_base.redT (final_thread.init_fin_final final) (multithreaded_base.init_fin final r) (map NormalAction \\<circ> convert_RA)) s \\<xi>\"\n  (is \"?Runs s \\<xi>\")", "lemma heap_copy_loc_heap_read_typed:\n  \"heap_base.heap_copy_loc (heap_base.heap_read_typed (\\<lambda>_ :: 'heap. typeof_addr) heap_read P) heap_write a a' al h obs h' \\<longleftrightarrow>\n  heap_base.heap_copy_loc heap_read heap_write a a' al h obs h' \\<and>\n  (\\<forall>ad al v T. ReadMem ad al v \\<in> set obs \\<longrightarrow> heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow> heap_base'.conf TYPE('heap) typeof_addr P v T)\"", "lemma heap_copies_heap_read_typed:\n  \"heap_base.heap_copies (heap_base.heap_read_typed (\\<lambda>_ :: 'heap. typeof_addr) heap_read P) heap_write a a' als h obs h' \\<longleftrightarrow>\n  heap_base.heap_copies heap_read heap_write a a' als h obs h' \\<and>\n  (\\<forall>ad al v T. ReadMem ad al v \\<in> set obs \\<longrightarrow> heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow> heap_base'.conf TYPE('heap) typeof_addr P v T)\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma heap_clone_heap_read_typed:\n  \"heap_base.heap_clone allocate (\\<lambda>_ :: 'heap. typeof_addr) (heap_base.heap_read_typed (\\<lambda>_ :: 'heap. typeof_addr) heap_read P) heap_write P a h h' obs \\<longleftrightarrow>\n  heap_base.heap_clone allocate (\\<lambda>_ :: 'heap. typeof_addr) heap_read heap_write P a h h' obs \\<and>\n  (\\<forall>ad al v T obs' a'. obs = \\<lfloor>(obs', a')\\<rfloor> \\<longrightarrow> ReadMem ad al v \\<in> set obs' \\<longrightarrow> heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow> heap_base'.conf TYPE('heap) typeof_addr P v T)\"", "lemma red_external_heap_read_typed:\n  \"heap_base.red_external addr2thread_id thread_id2addr spurious_wakeups empty_heap allocate (\\<lambda>_ :: 'heap. typeof_addr) (heap_base.heap_read_typed (\\<lambda>_ :: 'heap. typeof_addr) heap_read P) heap_write P t h a M vs ta va h' \\<longleftrightarrow>\n   heap_base.red_external addr2thread_id thread_id2addr spurious_wakeups empty_heap allocate (\\<lambda>_ :: 'heap. typeof_addr) heap_read heap_write P t h a M vs ta va h' \\<and>\n  (\\<forall>ad al v T obs' a'. ReadMem ad al v \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<longrightarrow> heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow> heap_base'.conf TYPE('heap) typeof_addr P v T)\"", "lemma red_external_aggr_heap_read_typed:\n  \"(ta, va, h') \\<in> heap_base.red_external_aggr addr2thread_id thread_id2addr spurious_wakeups empty_heap allocate (\\<lambda>_ :: 'heap. typeof_addr) (heap_base.heap_read_typed (\\<lambda>_ :: 'heap. typeof_addr) heap_read P) heap_write P t h a M vs \\<longleftrightarrow>\n   (ta, va, h') \\<in> heap_base.red_external_aggr addr2thread_id thread_id2addr spurious_wakeups empty_heap allocate (\\<lambda>_ :: 'heap. typeof_addr) heap_read heap_write P t h a M vs \\<and>\n  (\\<forall>ad al v T obs' a'. ReadMem ad al v \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<longrightarrow> heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow> heap_base'.conf TYPE('heap) typeof_addr P v T)\"", "lemma jmm'_heap_copy_locI: \n  \"\\<exists>obs h'. heap_base.heap_copy_loc (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write a a' al h obs h'\"", "lemma jmm'_heap_copiesI:\n  \"\\<exists>obs :: (addr, 'thread_id) obs_event list.\n   \\<exists>h'. heap_base.heap_copies (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write a a' als h obs h'\"", "lemma jmm'_heap_cloneI:\n  fixes obsa :: \"((addr, 'thread_id) obs_event list \\<times> addr) option\"\n  assumes \"heap_base.heap_clone allocate typeof_addr jmm_heap_read jmm_heap_write P h a h' obsa\"\n  shows \"\\<exists>h'. \\<exists>obsa :: ((addr, 'thread_id) obs_event list \\<times> addr) option. \n       heap_base.heap_clone allocate typeof_addr (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write P h a h' obsa\"", "lemma jmm'_red_externalI:\n  \"\\<And>final.\n  \\<lbrakk> heap_base.red_external addr2thread_id thread_id2addr spurious_wakeups empty_heap allocate typeof_addr jmm_heap_read jmm_heap_write P t h a M vs ta va h';\n     final_thread.actions_ok final s t ta \\<rbrakk>\n  \\<Longrightarrow> \\<exists>ta va h'. heap_base.red_external addr2thread_id thread_id2addr spurious_wakeups empty_heap allocate typeof_addr (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write P t h a M vs ta va h' \\<and> final_thread.actions_ok final s t ta\"", "lemma red_external_aggr_heap_read_typedI:\n  \"\\<And>final.\n  \\<lbrakk> (ta, vah') \\<in> heap_base.red_external_aggr addr2thread_id thread_id2addr spurious_wakeups empty_heap allocate typeof_addr jmm_heap_read jmm_heap_write P t h a M vs;\n    final_thread.actions_ok final s t ta\n  \\<rbrakk>\n  \\<Longrightarrow> \\<exists>ta vah'. (ta, vah') \\<in> heap_base.red_external_aggr addr2thread_id thread_id2addr spurious_wakeups empty_heap allocate typeof_addr (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write P t h a M vs \\<and> final_thread.actions_ok final s t ta\""], "translations": [["", "lemma jmm_addr_loc_type_conv_jmm_addr_loc_type' [simp, heap_independent]:\n  \"jmm_addr_loc_type P h = jmm_addr_loc_type' P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jmm'_addr_loc_type P h = jmm_addr_loc_type' P", "by(metis jmm_typeof_addr'_conv_jmm_typeof_addr heap_base'.addr_loc_type_conv_addr_loc_type)"], ["", "abbreviation jmm_conf' :: \"'m prog \\<Rightarrow> addr val \\<Rightarrow> ty \\<Rightarrow> bool\" (\"_ \\<turnstile>jmm _ :\\<le> _\"  [51,51,51] 50)\n  where \"jmm_conf' P \\<equiv> jmm.conf TYPE('m) P P\""], ["", "lemma jmm_conf_conv_jmm_conf' [simp, heap_independent]:\n  \"jmm_conf P h = jmm_conf' P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jmm'_conf P h = jmm_conf' P", "by (metis jmm_typeof_addr'_conv_jmm_typeof_addr heap_base'.conf_conv_conf)"], ["", "lemma jmm_heap'': \"heap'' addr2thread_id thread_id2addr jmm_allocate (jmm_typeof_addr' P) jmm_heap_write P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap'' (\\<lambda>x. x) (\\<lambda>x. x) jmm_allocate (jmm_typeof_addr' P)\n     jmm_heap_write P", "by(unfold_locales)(auto simp add: jmm_typeof_addr'_def jmm_allocate_def split: if_split_asm)"], ["", "interpretation jmm: heap''\n  addr2thread_id thread_id2addr\n  jmm_spurious_wakeups\n  jmm_empty jmm_allocate \"jmm_typeof_addr' P\" jmm_heap_read jmm_heap_write\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap'' (\\<lambda>x. x) (\\<lambda>x. x) jmm_allocate (jmm_typeof_addr' P)\n     jmm_heap_write P", "by(rule jmm_heap'')"], ["", "interpretation jmm': heap''\n  addr2thread_id thread_id2addr\n  jmm_spurious_wakeups\n  jmm_empty jmm_allocate \"jmm_typeof_addr' P\" \"jmm_heap_read_typed P\" jmm_heap_write\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap'' (\\<lambda>x. x) (\\<lambda>x. x) jmm_allocate (jmm_typeof_addr' P)\n     jmm_heap_write P", "by(rule jmm_heap'')"], ["", "abbreviation jmm_wf_start_state :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> mname \\<Rightarrow> addr val list \\<Rightarrow> bool\"\n  where \"jmm_wf_start_state P \\<equiv> jmm.wf_start_state TYPE('m) P P\""], ["", "abbreviation if_heap_read_typed ::\n  \"('x \\<Rightarrow> bool) \\<Rightarrow> ('l, 't, 'x, 'heap, 'w, ('addr :: addr, 'thread_id) obs_event) semantics\n   \\<Rightarrow> ('addr \\<Rightarrow> htype option)\n   \\<Rightarrow> 'm prog \\<Rightarrow> ('l, 't, status \\<times> 'x, 'heap, 'w, ('addr, 'thread_id) obs_event action) semantics\"\nwhere\n  \"\\<And>final. if_heap_read_typed final r typeof_addr P t xh ta x'h' \\<equiv>\n   multithreaded_base.init_fin final r t xh ta x'h' \\<and>\n  (\\<forall>ad al v T. NormalAction (ReadMem ad al v) \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<longrightarrow> heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow> heap_base'.conf TYPE('heap) typeof_addr P v T)\""], ["", "lemma if_mthr_Runs_heap_read_typedI:\n  fixes final and r :: \"('addr, 't, 'x, 'heap, 'w, ('addr :: addr, 'thread_id) obs_event) semantics\"\n  assumes \"trsys.Runs (multithreaded_base.redT (final_thread.init_fin_final final) (multithreaded_base.init_fin final r) (map NormalAction \\<circ> convert_RA)) s \\<xi>\"\n  (is \"trsys.Runs ?redT _ _\")\n  and \"\\<And>ad al v T. \\<lbrakk> NormalAction (ReadMem ad al v) \\<in> lset (lconcat (lmap (llist_of \\<circ> obs_a \\<circ> snd) \\<xi>)); heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<rbrakk> \\<Longrightarrow> heap_base'.conf TYPE('heap) typeof_addr P v T\"\n  (is \"\\<And>ad al v T. \\<lbrakk> ?obs \\<xi> ad al v; ?adal ad al T \\<rbrakk> \\<Longrightarrow> ?conf v T\")\n  shows \"trsys.Runs (multithreaded_base.redT (final_thread.init_fin_final final) (if_heap_read_typed final r typeof_addr P) (map NormalAction \\<circ> convert_RA)) s \\<xi>\"\n  (is \"trsys.Runs ?redT' _ _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. trsys.Runs\n     (multithreaded_base.redT (final_thread.init_fin_final final)\n       (if_heap_read_typed final r typeof_addr P)\n       (map NormalAction \\<circ> convert_RA))\n     s \\<xi>", "using assms"], ["proof (prove)\nusing this:\n  trsys.Runs\n   (multithreaded_base.redT (final_thread.init_fin_final final)\n     (multithreaded_base.init_fin final r)\n     (map NormalAction \\<circ> convert_RA))\n   s \\<xi>\n  \\<lbrakk>NormalAction (ReadMem ?ad ?al ?v)\n           \\<in> lset\n                  (lconcat\n                    (lmap (llist_of \\<circ> obs_a \\<circ> snd) \\<xi>));\n   heap_base'.addr_loc_type TYPE('heap) typeof_addr P ?ad ?al ?T\\<rbrakk>\n  \\<Longrightarrow> heap_base'.conf TYPE('heap) typeof_addr P ?v ?T\n\ngoal (1 subgoal):\n 1. trsys.Runs\n     (multithreaded_base.redT (final_thread.init_fin_final final)\n       (if_heap_read_typed final r typeof_addr P)\n       (map NormalAction \\<circ> convert_RA))\n     s \\<xi>", "proof(coinduction arbitrary: s \\<xi> rule: trsys.Runs.coinduct[consumes 1, case_names Runs, case_conclusion Runs Stuck Step])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s \\<xi>.\n       \\<lbrakk>trsys.Runs\n                 (multithreaded_base.redT\n                   (final_thread.init_fin_final final)\n                   (multithreaded_base.init_fin final r)\n                   (map NormalAction \\<circ> convert_RA))\n                 s \\<xi>;\n        \\<forall>ad al v T.\n           NormalAction (ReadMem ad al v)\n           \\<in> lset\n                  (lconcat\n                    (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n                      \\<xi>)) \\<longrightarrow>\n           heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n            T \\<longrightarrow>\n           heap_base'.conf TYPE('heap) typeof_addr P v T\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>sa.\n                             s = sa \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) sa x xa)) \\<or>\n                         (\\<exists>sa s' tls tl.\n                             s = sa \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (if_heap_read_typed final r typeof_addr P)\n                              (map NormalAction \\<circ> convert_RA) sa tl\n                              s' \\<and>\n                             ((\\<exists>s \\<xi>.\n                                  s' = s \\<and>\n                                  tls = \\<xi> \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (multithreaded_base.init_fin final r)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s \\<xi> \\<and>\n                                  (\\<forall>ad al v T.\nNormalAction (ReadMem ad al v)\n\\<in> lset\n       (lconcat\n         (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n           \\<xi>)) \\<longrightarrow>\nheap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow>\nheap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (if_heap_read_typed final r typeof_addr P)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))", "case (Runs s \\<xi>)"], ["proof (state)\nthis:\n  trsys.Runs\n   (multithreaded_base.redT (final_thread.init_fin_final final)\n     (multithreaded_base.init_fin final r)\n     (map NormalAction \\<circ> convert_RA))\n   s \\<xi>\n  \\<forall>ad al v T.\n     NormalAction (ReadMem ad al v)\n     \\<in> lset\n            (lconcat\n              (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n                \\<xi>)) \\<longrightarrow>\n     heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n      T \\<longrightarrow>\n     heap_base'.conf TYPE('heap) typeof_addr P v T\n\ngoal (1 subgoal):\n 1. \\<And>s \\<xi>.\n       \\<lbrakk>trsys.Runs\n                 (multithreaded_base.redT\n                   (final_thread.init_fin_final final)\n                   (multithreaded_base.init_fin final r)\n                   (map NormalAction \\<circ> convert_RA))\n                 s \\<xi>;\n        \\<forall>ad al v T.\n           NormalAction (ReadMem ad al v)\n           \\<in> lset\n                  (lconcat\n                    (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n                      \\<xi>)) \\<longrightarrow>\n           heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n            T \\<longrightarrow>\n           heap_base'.conf TYPE('heap) typeof_addr P v T\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>sa.\n                             s = sa \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) sa x xa)) \\<or>\n                         (\\<exists>sa s' tls tl.\n                             s = sa \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (if_heap_read_typed final r typeof_addr P)\n                              (map NormalAction \\<circ> convert_RA) sa tl\n                              s' \\<and>\n                             ((\\<exists>s \\<xi>.\n                                  s' = s \\<and>\n                                  tls = \\<xi> \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (multithreaded_base.init_fin final r)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s \\<xi> \\<and>\n                                  (\\<forall>ad al v T.\nNormalAction (ReadMem ad al v)\n\\<in> lset\n       (lconcat\n         (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n           \\<xi>)) \\<longrightarrow>\nheap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow>\nheap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (if_heap_read_typed final r typeof_addr P)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))", "let ?read = \"\\<lambda>\\<xi>. (\\<forall>ad al v T. ?obs \\<xi> ad al v \\<longrightarrow> ?adal ad al T \\<longrightarrow> ?conf v T)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s \\<xi>.\n       \\<lbrakk>trsys.Runs\n                 (multithreaded_base.redT\n                   (final_thread.init_fin_final final)\n                   (multithreaded_base.init_fin final r)\n                   (map NormalAction \\<circ> convert_RA))\n                 s \\<xi>;\n        \\<forall>ad al v T.\n           NormalAction (ReadMem ad al v)\n           \\<in> lset\n                  (lconcat\n                    (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n                      \\<xi>)) \\<longrightarrow>\n           heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n            T \\<longrightarrow>\n           heap_base'.conf TYPE('heap) typeof_addr P v T\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>sa.\n                             s = sa \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) sa x xa)) \\<or>\n                         (\\<exists>sa s' tls tl.\n                             s = sa \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (if_heap_read_typed final r typeof_addr P)\n                              (map NormalAction \\<circ> convert_RA) sa tl\n                              s' \\<and>\n                             ((\\<exists>s \\<xi>.\n                                  s' = s \\<and>\n                                  tls = \\<xi> \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (multithreaded_base.init_fin final r)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s \\<xi> \\<and>\n                                  (\\<forall>ad al v T.\nNormalAction (ReadMem ad al v)\n\\<in> lset\n       (lconcat\n         (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n           \\<xi>)) \\<longrightarrow>\nheap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow>\nheap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (if_heap_read_typed final r typeof_addr P)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))", "note read = Runs(2)"], ["proof (state)\nthis:\n  \\<forall>ad al v T.\n     NormalAction (ReadMem ad al v)\n     \\<in> lset\n            (lconcat\n              (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n                \\<xi>)) \\<longrightarrow>\n     heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n      T \\<longrightarrow>\n     heap_base'.conf TYPE('heap) typeof_addr P v T\n\ngoal (1 subgoal):\n 1. \\<And>s \\<xi>.\n       \\<lbrakk>trsys.Runs\n                 (multithreaded_base.redT\n                   (final_thread.init_fin_final final)\n                   (multithreaded_base.init_fin final r)\n                   (map NormalAction \\<circ> convert_RA))\n                 s \\<xi>;\n        \\<forall>ad al v T.\n           NormalAction (ReadMem ad al v)\n           \\<in> lset\n                  (lconcat\n                    (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n                      \\<xi>)) \\<longrightarrow>\n           heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n            T \\<longrightarrow>\n           heap_base'.conf TYPE('heap) typeof_addr P v T\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>sa.\n                             s = sa \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) sa x xa)) \\<or>\n                         (\\<exists>sa s' tls tl.\n                             s = sa \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (if_heap_read_typed final r typeof_addr P)\n                              (map NormalAction \\<circ> convert_RA) sa tl\n                              s' \\<and>\n                             ((\\<exists>s \\<xi>.\n                                  s' = s \\<and>\n                                  tls = \\<xi> \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (multithreaded_base.init_fin final r)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s \\<xi> \\<and>\n                                  (\\<forall>ad al v T.\nNormalAction (ReadMem ad al v)\n\\<in> lset\n       (lconcat\n         (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n           \\<xi>)) \\<longrightarrow>\nheap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow>\nheap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (if_heap_read_typed final r typeof_addr P)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))", "from Runs(1)"], ["proof (chain)\npicking this:\n  trsys.Runs\n   (multithreaded_base.redT (final_thread.init_fin_final final)\n     (multithreaded_base.init_fin final r)\n     (map NormalAction \\<circ> convert_RA))\n   s \\<xi>", "show ?case"], ["proof (prove)\nusing this:\n  trsys.Runs\n   (multithreaded_base.redT (final_thread.init_fin_final final)\n     (multithreaded_base.init_fin final r)\n     (map NormalAction \\<circ> convert_RA))\n   s \\<xi>\n\ngoal (1 subgoal):\n 1. (\\<exists>s.\n        s = s \\<and>\n        \\<xi> = LNil \\<and>\n        (\\<forall>x xa.\n            \\<not> multithreaded_base.redT\n                    (final_thread.init_fin_final final)\n                    (if_heap_read_typed final r typeof_addr P)\n                    (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n    (\\<exists>s s' tls tl.\n        s = s \\<and>\n        \\<xi> = LCons tl tls \\<and>\n        multithreaded_base.redT (final_thread.init_fin_final final)\n         (if_heap_read_typed final r typeof_addr P)\n         (map NormalAction \\<circ> convert_RA) s tl s' \\<and>\n        ((\\<exists>s \\<xi>.\n             s' = s \\<and>\n             tls = \\<xi> \\<and>\n             trsys.Runs\n              (multithreaded_base.redT (final_thread.init_fin_final final)\n                (multithreaded_base.init_fin final r)\n                (map NormalAction \\<circ> convert_RA))\n              s \\<xi> \\<and>\n             (\\<forall>ad al v T.\n                 NormalAction (ReadMem ad al v)\n                 \\<in> lset\n                        (lconcat\n                          (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n                            \\<xi>)) \\<longrightarrow>\n                 heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n                  T \\<longrightarrow>\n                 heap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n         trsys.Runs\n          (multithreaded_base.redT (final_thread.init_fin_final final)\n            (if_heap_read_typed final r typeof_addr P)\n            (map NormalAction \\<circ> convert_RA))\n          s' tls))", "proof(cases rule: trsys.Runs.cases[consumes 1, case_names Stuck Step])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s = s; \\<xi> = LNil;\n        \\<And>tl s'.\n           \\<not> multithreaded_base.redT\n                   (final_thread.init_fin_final final)\n                   (multithreaded_base.init_fin final r)\n                   (map NormalAction \\<circ> convert_RA) s tl s'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (if_heap_read_typed final r typeof_addr P)\n                              (map NormalAction \\<circ> convert_RA) s tl\n                              s' \\<and>\n                             ((\\<exists>s \\<xi>.\n                                  s' = s \\<and>\n                                  tls = \\<xi> \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (multithreaded_base.init_fin final r)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s \\<xi> \\<and>\n                                  (\\<forall>ad al v T.\nNormalAction (ReadMem ad al v)\n\\<in> lset\n       (lconcat\n         (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n           \\<xi>)) \\<longrightarrow>\nheap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow>\nheap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (if_heap_read_typed final r typeof_addr P)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))\n 2. \\<And>s s' tls tl.\n       \\<lbrakk>s = s; \\<xi> = LCons tl tls;\n        multithreaded_base.redT (final_thread.init_fin_final final)\n         (multithreaded_base.init_fin final r)\n         (map NormalAction \\<circ> convert_RA) s tl s';\n        trsys.Runs\n         (multithreaded_base.redT (final_thread.init_fin_final final)\n           (multithreaded_base.init_fin final r)\n           (map NormalAction \\<circ> convert_RA))\n         s' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (if_heap_read_typed final r typeof_addr P)\n                              (map NormalAction \\<circ> convert_RA) s tl\n                              s' \\<and>\n                             ((\\<exists>s \\<xi>.\n                                  s' = s \\<and>\n                                  tls = \\<xi> \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (multithreaded_base.init_fin final r)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s \\<xi> \\<and>\n                                  (\\<forall>ad al v T.\nNormalAction (ReadMem ad al v)\n\\<in> lset\n       (lconcat\n         (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n           \\<xi>)) \\<longrightarrow>\nheap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow>\nheap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (if_heap_read_typed final r typeof_addr P)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))", "case (Stuck S)"], ["proof (state)\nthis:\n  s = S\n  \\<xi> = LNil\n  \\<not> multithreaded_base.redT (final_thread.init_fin_final final)\n          (multithreaded_base.init_fin final r)\n          (map NormalAction \\<circ> convert_RA) S ?tl ?s'\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s = s; \\<xi> = LNil;\n        \\<And>tl s'.\n           \\<not> multithreaded_base.redT\n                   (final_thread.init_fin_final final)\n                   (multithreaded_base.init_fin final r)\n                   (map NormalAction \\<circ> convert_RA) s tl s'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (if_heap_read_typed final r typeof_addr P)\n                              (map NormalAction \\<circ> convert_RA) s tl\n                              s' \\<and>\n                             ((\\<exists>s \\<xi>.\n                                  s' = s \\<and>\n                                  tls = \\<xi> \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (multithreaded_base.init_fin final r)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s \\<xi> \\<and>\n                                  (\\<forall>ad al v T.\nNormalAction (ReadMem ad al v)\n\\<in> lset\n       (lconcat\n         (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n           \\<xi>)) \\<longrightarrow>\nheap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow>\nheap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (if_heap_read_typed final r typeof_addr P)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))\n 2. \\<And>s s' tls tl.\n       \\<lbrakk>s = s; \\<xi> = LCons tl tls;\n        multithreaded_base.redT (final_thread.init_fin_final final)\n         (multithreaded_base.init_fin final r)\n         (map NormalAction \\<circ> convert_RA) s tl s';\n        trsys.Runs\n         (multithreaded_base.redT (final_thread.init_fin_final final)\n           (multithreaded_base.init_fin final r)\n           (map NormalAction \\<circ> convert_RA))\n         s' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (if_heap_read_typed final r typeof_addr P)\n                              (map NormalAction \\<circ> convert_RA) s tl\n                              s' \\<and>\n                             ((\\<exists>s \\<xi>.\n                                  s' = s \\<and>\n                                  tls = \\<xi> \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (multithreaded_base.init_fin final r)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s \\<xi> \\<and>\n                                  (\\<forall>ad al v T.\nNormalAction (ReadMem ad al v)\n\\<in> lset\n       (lconcat\n         (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n           \\<xi>)) \\<longrightarrow>\nheap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow>\nheap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (if_heap_read_typed final r typeof_addr P)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))", "{"], ["proof (state)\nthis:\n  s = S\n  \\<xi> = LNil\n  \\<not> multithreaded_base.redT (final_thread.init_fin_final final)\n          (multithreaded_base.init_fin final r)\n          (map NormalAction \\<circ> convert_RA) S ?tl ?s'\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s = s; \\<xi> = LNil;\n        \\<And>tl s'.\n           \\<not> multithreaded_base.redT\n                   (final_thread.init_fin_final final)\n                   (multithreaded_base.init_fin final r)\n                   (map NormalAction \\<circ> convert_RA) s tl s'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (if_heap_read_typed final r typeof_addr P)\n                              (map NormalAction \\<circ> convert_RA) s tl\n                              s' \\<and>\n                             ((\\<exists>s \\<xi>.\n                                  s' = s \\<and>\n                                  tls = \\<xi> \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (multithreaded_base.init_fin final r)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s \\<xi> \\<and>\n                                  (\\<forall>ad al v T.\nNormalAction (ReadMem ad al v)\n\\<in> lset\n       (lconcat\n         (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n           \\<xi>)) \\<longrightarrow>\nheap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow>\nheap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (if_heap_read_typed final r typeof_addr P)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))\n 2. \\<And>s s' tls tl.\n       \\<lbrakk>s = s; \\<xi> = LCons tl tls;\n        multithreaded_base.redT (final_thread.init_fin_final final)\n         (multithreaded_base.init_fin final r)\n         (map NormalAction \\<circ> convert_RA) s tl s';\n        trsys.Runs\n         (multithreaded_base.redT (final_thread.init_fin_final final)\n           (multithreaded_base.init_fin final r)\n           (map NormalAction \\<circ> convert_RA))\n         s' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (if_heap_read_typed final r typeof_addr P)\n                              (map NormalAction \\<circ> convert_RA) s tl\n                              s' \\<and>\n                             ((\\<exists>s \\<xi>.\n                                  s' = s \\<and>\n                                  tls = \\<xi> \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (multithreaded_base.init_fin final r)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s \\<xi> \\<and>\n                                  (\\<forall>ad al v T.\nNormalAction (ReadMem ad al v)\n\\<in> lset\n       (lconcat\n         (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n           \\<xi>)) \\<longrightarrow>\nheap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow>\nheap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (if_heap_read_typed final r typeof_addr P)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))", "fix tta s'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s = s; \\<xi> = LNil;\n        \\<And>tl s'.\n           \\<not> multithreaded_base.redT\n                   (final_thread.init_fin_final final)\n                   (multithreaded_base.init_fin final r)\n                   (map NormalAction \\<circ> convert_RA) s tl s'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (if_heap_read_typed final r typeof_addr P)\n                              (map NormalAction \\<circ> convert_RA) s tl\n                              s' \\<and>\n                             ((\\<exists>s \\<xi>.\n                                  s' = s \\<and>\n                                  tls = \\<xi> \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (multithreaded_base.init_fin final r)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s \\<xi> \\<and>\n                                  (\\<forall>ad al v T.\nNormalAction (ReadMem ad al v)\n\\<in> lset\n       (lconcat\n         (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n           \\<xi>)) \\<longrightarrow>\nheap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow>\nheap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (if_heap_read_typed final r typeof_addr P)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))\n 2. \\<And>s s' tls tl.\n       \\<lbrakk>s = s; \\<xi> = LCons tl tls;\n        multithreaded_base.redT (final_thread.init_fin_final final)\n         (multithreaded_base.init_fin final r)\n         (map NormalAction \\<circ> convert_RA) s tl s';\n        trsys.Runs\n         (multithreaded_base.redT (final_thread.init_fin_final final)\n           (multithreaded_base.init_fin final r)\n           (map NormalAction \\<circ> convert_RA))\n         s' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (if_heap_read_typed final r typeof_addr P)\n                              (map NormalAction \\<circ> convert_RA) s tl\n                              s' \\<and>\n                             ((\\<exists>s \\<xi>.\n                                  s' = s \\<and>\n                                  tls = \\<xi> \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (multithreaded_base.init_fin final r)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s \\<xi> \\<and>\n                                  (\\<forall>ad al v T.\nNormalAction (ReadMem ad al v)\n\\<in> lset\n       (lconcat\n         (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n           \\<xi>)) \\<longrightarrow>\nheap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow>\nheap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (if_heap_read_typed final r typeof_addr P)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))", "from \\<open>\\<not> ?redT S tta s'\\<close>"], ["proof (chain)\npicking this:\n  \\<not> multithreaded_base.redT (final_thread.init_fin_final final)\n          (multithreaded_base.init_fin final r)\n          (map NormalAction \\<circ> convert_RA) S tta s'", "have \"\\<not> ?redT' S tta s'\""], ["proof (prove)\nusing this:\n  \\<not> multithreaded_base.redT (final_thread.init_fin_final final)\n          (multithreaded_base.init_fin final r)\n          (map NormalAction \\<circ> convert_RA) S tta s'\n\ngoal (1 subgoal):\n 1. \\<not> multithreaded_base.redT (final_thread.init_fin_final final)\n            (if_heap_read_typed final r typeof_addr P)\n            (map NormalAction \\<circ> convert_RA) S tta s'", "by(rule contrapos_nn)(fastforce simp add: multithreaded_base.redT.simps)"], ["proof (state)\nthis:\n  \\<not> multithreaded_base.redT (final_thread.init_fin_final final)\n          (if_heap_read_typed final r typeof_addr P)\n          (map NormalAction \\<circ> convert_RA) S tta s'\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s = s; \\<xi> = LNil;\n        \\<And>tl s'.\n           \\<not> multithreaded_base.redT\n                   (final_thread.init_fin_final final)\n                   (multithreaded_base.init_fin final r)\n                   (map NormalAction \\<circ> convert_RA) s tl s'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (if_heap_read_typed final r typeof_addr P)\n                              (map NormalAction \\<circ> convert_RA) s tl\n                              s' \\<and>\n                             ((\\<exists>s \\<xi>.\n                                  s' = s \\<and>\n                                  tls = \\<xi> \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (multithreaded_base.init_fin final r)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s \\<xi> \\<and>\n                                  (\\<forall>ad al v T.\nNormalAction (ReadMem ad al v)\n\\<in> lset\n       (lconcat\n         (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n           \\<xi>)) \\<longrightarrow>\nheap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow>\nheap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (if_heap_read_typed final r typeof_addr P)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))\n 2. \\<And>s s' tls tl.\n       \\<lbrakk>s = s; \\<xi> = LCons tl tls;\n        multithreaded_base.redT (final_thread.init_fin_final final)\n         (multithreaded_base.init_fin final r)\n         (map NormalAction \\<circ> convert_RA) s tl s';\n        trsys.Runs\n         (multithreaded_base.redT (final_thread.init_fin_final final)\n           (multithreaded_base.init_fin final r)\n           (map NormalAction \\<circ> convert_RA))\n         s' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (if_heap_read_typed final r typeof_addr P)\n                              (map NormalAction \\<circ> convert_RA) s tl\n                              s' \\<and>\n                             ((\\<exists>s \\<xi>.\n                                  s' = s \\<and>\n                                  tls = \\<xi> \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (multithreaded_base.init_fin final r)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s \\<xi> \\<and>\n                                  (\\<forall>ad al v T.\nNormalAction (ReadMem ad al v)\n\\<in> lset\n       (lconcat\n         (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n           \\<xi>)) \\<longrightarrow>\nheap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow>\nheap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (if_heap_read_typed final r typeof_addr P)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))", "}"], ["proof (state)\nthis:\n  \\<not> multithreaded_base.redT (final_thread.init_fin_final final)\n          (if_heap_read_typed final r typeof_addr P)\n          (map NormalAction \\<circ> convert_RA) S ?tta2 ?s'2\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s = s; \\<xi> = LNil;\n        \\<And>tl s'.\n           \\<not> multithreaded_base.redT\n                   (final_thread.init_fin_final final)\n                   (multithreaded_base.init_fin final r)\n                   (map NormalAction \\<circ> convert_RA) s tl s'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (if_heap_read_typed final r typeof_addr P)\n                              (map NormalAction \\<circ> convert_RA) s tl\n                              s' \\<and>\n                             ((\\<exists>s \\<xi>.\n                                  s' = s \\<and>\n                                  tls = \\<xi> \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (multithreaded_base.init_fin final r)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s \\<xi> \\<and>\n                                  (\\<forall>ad al v T.\nNormalAction (ReadMem ad al v)\n\\<in> lset\n       (lconcat\n         (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n           \\<xi>)) \\<longrightarrow>\nheap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow>\nheap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (if_heap_read_typed final r typeof_addr P)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))\n 2. \\<And>s s' tls tl.\n       \\<lbrakk>s = s; \\<xi> = LCons tl tls;\n        multithreaded_base.redT (final_thread.init_fin_final final)\n         (multithreaded_base.init_fin final r)\n         (map NormalAction \\<circ> convert_RA) s tl s';\n        trsys.Runs\n         (multithreaded_base.redT (final_thread.init_fin_final final)\n           (multithreaded_base.init_fin final r)\n           (map NormalAction \\<circ> convert_RA))\n         s' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (if_heap_read_typed final r typeof_addr P)\n                              (map NormalAction \\<circ> convert_RA) s tl\n                              s' \\<and>\n                             ((\\<exists>s \\<xi>.\n                                  s' = s \\<and>\n                                  tls = \\<xi> \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (multithreaded_base.init_fin final r)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s \\<xi> \\<and>\n                                  (\\<forall>ad al v T.\nNormalAction (ReadMem ad al v)\n\\<in> lset\n       (lconcat\n         (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n           \\<xi>)) \\<longrightarrow>\nheap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow>\nheap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (if_heap_read_typed final r typeof_addr P)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))", "hence ?Stuck"], ["proof (prove)\nusing this:\n  \\<not> multithreaded_base.redT (final_thread.init_fin_final final)\n          (if_heap_read_typed final r typeof_addr P)\n          (map NormalAction \\<circ> convert_RA) S ?tta2 ?s'2\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       s = s \\<and>\n       \\<xi> = LNil \\<and>\n       (\\<forall>x xa.\n           \\<not> multithreaded_base.redT\n                   (final_thread.init_fin_final final)\n                   (if_heap_read_typed final r typeof_addr P)\n                   (map NormalAction \\<circ> convert_RA) s x xa)", "using \\<open>\\<xi> = LNil\\<close>"], ["proof (prove)\nusing this:\n  \\<not> multithreaded_base.redT (final_thread.init_fin_final final)\n          (if_heap_read_typed final r typeof_addr P)\n          (map NormalAction \\<circ> convert_RA) S ?tta2 ?s'2\n  \\<xi> = LNil\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       s = s \\<and>\n       \\<xi> = LNil \\<and>\n       (\\<forall>x xa.\n           \\<not> multithreaded_base.redT\n                   (final_thread.init_fin_final final)\n                   (if_heap_read_typed final r typeof_addr P)\n                   (map NormalAction \\<circ> convert_RA) s x xa)", "unfolding \\<open>s = S\\<close>"], ["proof (prove)\nusing this:\n  \\<not> multithreaded_base.redT (final_thread.init_fin_final final)\n          (if_heap_read_typed final r typeof_addr P)\n          (map NormalAction \\<circ> convert_RA) S ?tta2 ?s'2\n  \\<xi> = LNil\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       S = s \\<and>\n       \\<xi> = LNil \\<and>\n       (\\<forall>x xa.\n           \\<not> multithreaded_base.redT\n                   (final_thread.init_fin_final final)\n                   (if_heap_read_typed final r typeof_addr P)\n                   (map NormalAction \\<circ> convert_RA) s x xa)", "by blast"], ["proof (state)\nthis:\n  \\<exists>s.\n     s = s \\<and>\n     \\<xi> = LNil \\<and>\n     (\\<forall>x xa.\n         \\<not> multithreaded_base.redT (final_thread.init_fin_final final)\n                 (if_heap_read_typed final r typeof_addr P)\n                 (map NormalAction \\<circ> convert_RA) s x xa)\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s = s; \\<xi> = LNil;\n        \\<And>tl s'.\n           \\<not> multithreaded_base.redT\n                   (final_thread.init_fin_final final)\n                   (multithreaded_base.init_fin final r)\n                   (map NormalAction \\<circ> convert_RA) s tl s'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (if_heap_read_typed final r typeof_addr P)\n                              (map NormalAction \\<circ> convert_RA) s tl\n                              s' \\<and>\n                             ((\\<exists>s \\<xi>.\n                                  s' = s \\<and>\n                                  tls = \\<xi> \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (multithreaded_base.init_fin final r)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s \\<xi> \\<and>\n                                  (\\<forall>ad al v T.\nNormalAction (ReadMem ad al v)\n\\<in> lset\n       (lconcat\n         (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n           \\<xi>)) \\<longrightarrow>\nheap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow>\nheap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (if_heap_read_typed final r typeof_addr P)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))\n 2. \\<And>s s' tls tl.\n       \\<lbrakk>s = s; \\<xi> = LCons tl tls;\n        multithreaded_base.redT (final_thread.init_fin_final final)\n         (multithreaded_base.init_fin final r)\n         (map NormalAction \\<circ> convert_RA) s tl s';\n        trsys.Runs\n         (multithreaded_base.redT (final_thread.init_fin_final final)\n           (multithreaded_base.init_fin final r)\n           (map NormalAction \\<circ> convert_RA))\n         s' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (if_heap_read_typed final r typeof_addr P)\n                              (map NormalAction \\<circ> convert_RA) s tl\n                              s' \\<and>\n                             ((\\<exists>s \\<xi>.\n                                  s' = s \\<and>\n                                  tls = \\<xi> \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (multithreaded_base.init_fin final r)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s \\<xi> \\<and>\n                                  (\\<forall>ad al v T.\nNormalAction (ReadMem ad al v)\n\\<in> lset\n       (lconcat\n         (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n           \\<xi>)) \\<longrightarrow>\nheap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow>\nheap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (if_heap_read_typed final r typeof_addr P)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s.\n     s = s \\<and>\n     \\<xi> = LNil \\<and>\n     (\\<forall>x xa.\n         \\<not> multithreaded_base.redT (final_thread.init_fin_final final)\n                 (if_heap_read_typed final r typeof_addr P)\n                 (map NormalAction \\<circ> convert_RA) s x xa)\n\ngoal (1 subgoal):\n 1. (\\<exists>s.\n        s = s \\<and>\n        \\<xi> = LNil \\<and>\n        (\\<forall>x xa.\n            \\<not> multithreaded_base.redT\n                    (final_thread.init_fin_final final)\n                    (if_heap_read_typed final r typeof_addr P)\n                    (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n    (\\<exists>s s' tls tl.\n        s = s \\<and>\n        \\<xi> = LCons tl tls \\<and>\n        multithreaded_base.redT (final_thread.init_fin_final final)\n         (if_heap_read_typed final r typeof_addr P)\n         (map NormalAction \\<circ> convert_RA) s tl s' \\<and>\n        ((\\<exists>s \\<xi>.\n             s' = s \\<and>\n             tls = \\<xi> \\<and>\n             trsys.Runs\n              (multithreaded_base.redT (final_thread.init_fin_final final)\n                (multithreaded_base.init_fin final r)\n                (map NormalAction \\<circ> convert_RA))\n              s \\<xi> \\<and>\n             (\\<forall>ad al v T.\n                 NormalAction (ReadMem ad al v)\n                 \\<in> lset\n                        (lconcat\n                          (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n                            \\<xi>)) \\<longrightarrow>\n                 heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n                  T \\<longrightarrow>\n                 heap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n         trsys.Runs\n          (multithreaded_base.redT (final_thread.init_fin_final final)\n            (if_heap_read_typed final r typeof_addr P)\n            (map NormalAction \\<circ> convert_RA))\n          s' tls))", ".."], ["proof (state)\nthis:\n  (\\<exists>s.\n      s = s \\<and>\n      \\<xi> = LNil \\<and>\n      (\\<forall>x xa.\n          \\<not> multithreaded_base.redT (final_thread.init_fin_final final)\n                  (if_heap_read_typed final r typeof_addr P)\n                  (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n  (\\<exists>s s' tls tl.\n      s = s \\<and>\n      \\<xi> = LCons tl tls \\<and>\n      multithreaded_base.redT (final_thread.init_fin_final final)\n       (if_heap_read_typed final r typeof_addr P)\n       (map NormalAction \\<circ> convert_RA) s tl s' \\<and>\n      ((\\<exists>s \\<xi>.\n           s' = s \\<and>\n           tls = \\<xi> \\<and>\n           trsys.Runs\n            (multithreaded_base.redT (final_thread.init_fin_final final)\n              (multithreaded_base.init_fin final r)\n              (map NormalAction \\<circ> convert_RA))\n            s \\<xi> \\<and>\n           (\\<forall>ad al v T.\n               NormalAction (ReadMem ad al v)\n               \\<in> lset\n                      (lconcat\n                        (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n                          \\<xi>)) \\<longrightarrow>\n               heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n                T \\<longrightarrow>\n               heap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n       trsys.Runs\n        (multithreaded_base.redT (final_thread.init_fin_final final)\n          (if_heap_read_typed final r typeof_addr P)\n          (map NormalAction \\<circ> convert_RA))\n        s' tls))\n\ngoal (1 subgoal):\n 1. \\<And>s s' tls tl.\n       \\<lbrakk>s = s; \\<xi> = LCons tl tls;\n        multithreaded_base.redT (final_thread.init_fin_final final)\n         (multithreaded_base.init_fin final r)\n         (map NormalAction \\<circ> convert_RA) s tl s';\n        trsys.Runs\n         (multithreaded_base.redT (final_thread.init_fin_final final)\n           (multithreaded_base.init_fin final r)\n           (map NormalAction \\<circ> convert_RA))\n         s' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (if_heap_read_typed final r typeof_addr P)\n                              (map NormalAction \\<circ> convert_RA) s tl\n                              s' \\<and>\n                             ((\\<exists>s \\<xi>.\n                                  s' = s \\<and>\n                                  tls = \\<xi> \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (multithreaded_base.init_fin final r)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s \\<xi> \\<and>\n                                  (\\<forall>ad al v T.\nNormalAction (ReadMem ad al v)\n\\<in> lset\n       (lconcat\n         (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n           \\<xi>)) \\<longrightarrow>\nheap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow>\nheap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (if_heap_read_typed final r typeof_addr P)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s s' tls tl.\n       \\<lbrakk>s = s; \\<xi> = LCons tl tls;\n        multithreaded_base.redT (final_thread.init_fin_final final)\n         (multithreaded_base.init_fin final r)\n         (map NormalAction \\<circ> convert_RA) s tl s';\n        trsys.Runs\n         (multithreaded_base.redT (final_thread.init_fin_final final)\n           (multithreaded_base.init_fin final r)\n           (map NormalAction \\<circ> convert_RA))\n         s' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (if_heap_read_typed final r typeof_addr P)\n                              (map NormalAction \\<circ> convert_RA) s tl\n                              s' \\<and>\n                             ((\\<exists>s \\<xi>.\n                                  s' = s \\<and>\n                                  tls = \\<xi> \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (multithreaded_base.init_fin final r)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s \\<xi> \\<and>\n                                  (\\<forall>ad al v T.\nNormalAction (ReadMem ad al v)\n\\<in> lset\n       (lconcat\n         (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n           \\<xi>)) \\<longrightarrow>\nheap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow>\nheap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (if_heap_read_typed final r typeof_addr P)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))", "case (Step S s' ttas tta)"], ["proof (state)\nthis:\n  s = S\n  \\<xi> = LCons tta ttas\n  multithreaded_base.redT (final_thread.init_fin_final final)\n   (multithreaded_base.init_fin final r)\n   (map NormalAction \\<circ> convert_RA) S tta s'\n  trsys.Runs\n   (multithreaded_base.redT (final_thread.init_fin_final final)\n     (multithreaded_base.init_fin final r)\n     (map NormalAction \\<circ> convert_RA))\n   s' ttas\n\ngoal (1 subgoal):\n 1. \\<And>s s' tls tl.\n       \\<lbrakk>s = s; \\<xi> = LCons tl tls;\n        multithreaded_base.redT (final_thread.init_fin_final final)\n         (multithreaded_base.init_fin final r)\n         (map NormalAction \\<circ> convert_RA) s tl s';\n        trsys.Runs\n         (multithreaded_base.redT (final_thread.init_fin_final final)\n           (multithreaded_base.init_fin final r)\n           (map NormalAction \\<circ> convert_RA))\n         s' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (if_heap_read_typed final r typeof_addr P)\n                              (map NormalAction \\<circ> convert_RA) s tl\n                              s' \\<and>\n                             ((\\<exists>s \\<xi>.\n                                  s' = s \\<and>\n                                  tls = \\<xi> \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (multithreaded_base.init_fin final r)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s \\<xi> \\<and>\n                                  (\\<forall>ad al v T.\nNormalAction (ReadMem ad al v)\n\\<in> lset\n       (lconcat\n         (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n           \\<xi>)) \\<longrightarrow>\nheap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow>\nheap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (if_heap_read_typed final r typeof_addr P)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))", "from \\<open>\\<xi> = LCons tta ttas\\<close> read"], ["proof (chain)\npicking this:\n  \\<xi> = LCons tta ttas\n  \\<forall>ad al v T.\n     NormalAction (ReadMem ad al v)\n     \\<in> lset\n            (lconcat\n              (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n                \\<xi>)) \\<longrightarrow>\n     heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n      T \\<longrightarrow>\n     heap_base'.conf TYPE('heap) typeof_addr P v T", "have read1: \"\\<And>ad al v T. \\<lbrakk> NormalAction (ReadMem ad al v) \\<in> set \\<lbrace>snd tta\\<rbrace>\\<^bsub>o\\<^esub>; ?adal ad al T \\<rbrakk> \\<Longrightarrow> ?conf v T\"\n      and read2: \"?read ttas\""], ["proof (prove)\nusing this:\n  \\<xi> = LCons tta ttas\n  \\<forall>ad al v T.\n     NormalAction (ReadMem ad al v)\n     \\<in> lset\n            (lconcat\n              (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n                \\<xi>)) \\<longrightarrow>\n     heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n      T \\<longrightarrow>\n     heap_base'.conf TYPE('heap) typeof_addr P v T\n\ngoal (1 subgoal):\n 1. (\\<And>ad al v T.\n        \\<lbrakk>NormalAction (ReadMem ad al v)\n                 \\<in> set \\<lbrace>snd tta\\<rbrace>\\<^bsub>o\\<^esub>;\n         heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T\\<rbrakk>\n        \\<Longrightarrow> heap_base'.conf TYPE('heap) typeof_addr P v T) &&&\n    \\<forall>ad al v T.\n       NormalAction (ReadMem ad al v)\n       \\<in> lset\n              (lconcat\n                (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n                  ttas)) \\<longrightarrow>\n       heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n        T \\<longrightarrow>\n       heap_base'.conf TYPE('heap) typeof_addr P v T", "by(auto simp add: o_def)"], ["proof (state)\nthis:\n  \\<lbrakk>NormalAction (ReadMem ?ad ?al ?v)\n           \\<in> set \\<lbrace>snd tta\\<rbrace>\\<^bsub>o\\<^esub>;\n   heap_base'.addr_loc_type TYPE('heap) typeof_addr P ?ad ?al ?T\\<rbrakk>\n  \\<Longrightarrow> heap_base'.conf TYPE('heap) typeof_addr P ?v ?T\n  \\<forall>ad al v T.\n     NormalAction (ReadMem ad al v)\n     \\<in> lset\n            (lconcat\n              (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n                ttas)) \\<longrightarrow>\n     heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n      T \\<longrightarrow>\n     heap_base'.conf TYPE('heap) typeof_addr P v T\n\ngoal (1 subgoal):\n 1. \\<And>s s' tls tl.\n       \\<lbrakk>s = s; \\<xi> = LCons tl tls;\n        multithreaded_base.redT (final_thread.init_fin_final final)\n         (multithreaded_base.init_fin final r)\n         (map NormalAction \\<circ> convert_RA) s tl s';\n        trsys.Runs\n         (multithreaded_base.redT (final_thread.init_fin_final final)\n           (multithreaded_base.init_fin final r)\n           (map NormalAction \\<circ> convert_RA))\n         s' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (if_heap_read_typed final r typeof_addr P)\n                              (map NormalAction \\<circ> convert_RA) s tl\n                              s' \\<and>\n                             ((\\<exists>s \\<xi>.\n                                  s' = s \\<and>\n                                  tls = \\<xi> \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (multithreaded_base.init_fin final r)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s \\<xi> \\<and>\n                                  (\\<forall>ad al v T.\nNormalAction (ReadMem ad al v)\n\\<in> lset\n       (lconcat\n         (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n           \\<xi>)) \\<longrightarrow>\nheap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow>\nheap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (if_heap_read_typed final r typeof_addr P)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))", "from \\<open>?redT S tta s'\\<close> read1"], ["proof (chain)\npicking this:\n  multithreaded_base.redT (final_thread.init_fin_final final)\n   (multithreaded_base.init_fin final r)\n   (map NormalAction \\<circ> convert_RA) S tta s'\n  \\<lbrakk>NormalAction (ReadMem ?ad ?al ?v)\n           \\<in> set \\<lbrace>snd tta\\<rbrace>\\<^bsub>o\\<^esub>;\n   heap_base'.addr_loc_type TYPE('heap) typeof_addr P ?ad ?al ?T\\<rbrakk>\n  \\<Longrightarrow> heap_base'.conf TYPE('heap) typeof_addr P ?v ?T", "have \"?redT' S tta s'\""], ["proof (prove)\nusing this:\n  multithreaded_base.redT (final_thread.init_fin_final final)\n   (multithreaded_base.init_fin final r)\n   (map NormalAction \\<circ> convert_RA) S tta s'\n  \\<lbrakk>NormalAction (ReadMem ?ad ?al ?v)\n           \\<in> set \\<lbrace>snd tta\\<rbrace>\\<^bsub>o\\<^esub>;\n   heap_base'.addr_loc_type TYPE('heap) typeof_addr P ?ad ?al ?T\\<rbrakk>\n  \\<Longrightarrow> heap_base'.conf TYPE('heap) typeof_addr P ?v ?T\n\ngoal (1 subgoal):\n 1. multithreaded_base.redT (final_thread.init_fin_final final)\n     (if_heap_read_typed final r typeof_addr P)\n     (map NormalAction \\<circ> convert_RA) S tta s'", "by(fastforce simp add: multithreaded_base.redT.simps)"], ["proof (state)\nthis:\n  multithreaded_base.redT (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) S tta s'\n\ngoal (1 subgoal):\n 1. \\<And>s s' tls tl.\n       \\<lbrakk>s = s; \\<xi> = LCons tl tls;\n        multithreaded_base.redT (final_thread.init_fin_final final)\n         (multithreaded_base.init_fin final r)\n         (map NormalAction \\<circ> convert_RA) s tl s';\n        trsys.Runs\n         (multithreaded_base.redT (final_thread.init_fin_final final)\n           (multithreaded_base.init_fin final r)\n           (map NormalAction \\<circ> convert_RA))\n         s' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (if_heap_read_typed final r typeof_addr P)\n                              (map NormalAction \\<circ> convert_RA) s tl\n                              s' \\<and>\n                             ((\\<exists>s \\<xi>.\n                                  s' = s \\<and>\n                                  tls = \\<xi> \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (multithreaded_base.init_fin final r)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s \\<xi> \\<and>\n                                  (\\<forall>ad al v T.\nNormalAction (ReadMem ad al v)\n\\<in> lset\n       (lconcat\n         (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n           \\<xi>)) \\<longrightarrow>\nheap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow>\nheap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (if_heap_read_typed final r typeof_addr P)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))", "hence ?Step"], ["proof (prove)\nusing this:\n  multithreaded_base.redT (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) S tta s'\n\ngoal (1 subgoal):\n 1. \\<exists>s s' tls tl.\n       s = s \\<and>\n       \\<xi> = LCons tl tls \\<and>\n       multithreaded_base.redT (final_thread.init_fin_final final)\n        (if_heap_read_typed final r typeof_addr P)\n        (map NormalAction \\<circ> convert_RA) s tl s' \\<and>\n       ((\\<exists>s \\<xi>.\n            s' = s \\<and>\n            tls = \\<xi> \\<and>\n            trsys.Runs\n             (multithreaded_base.redT (final_thread.init_fin_final final)\n               (multithreaded_base.init_fin final r)\n               (map NormalAction \\<circ> convert_RA))\n             s \\<xi> \\<and>\n            (\\<forall>ad al v T.\n                NormalAction (ReadMem ad al v)\n                \\<in> lset\n                       (lconcat\n                         (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n                           \\<xi>)) \\<longrightarrow>\n                heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n                 T \\<longrightarrow>\n                heap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n        trsys.Runs\n         (multithreaded_base.redT (final_thread.init_fin_final final)\n           (if_heap_read_typed final r typeof_addr P)\n           (map NormalAction \\<circ> convert_RA))\n         s' tls)", "using Step read2 \\<open>s = S\\<close>"], ["proof (prove)\nusing this:\n  multithreaded_base.redT (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) S tta s'\n  s = S\n  \\<xi> = LCons tta ttas\n  multithreaded_base.redT (final_thread.init_fin_final final)\n   (multithreaded_base.init_fin final r)\n   (map NormalAction \\<circ> convert_RA) S tta s'\n  trsys.Runs\n   (multithreaded_base.redT (final_thread.init_fin_final final)\n     (multithreaded_base.init_fin final r)\n     (map NormalAction \\<circ> convert_RA))\n   s' ttas\n  \\<forall>ad al v T.\n     NormalAction (ReadMem ad al v)\n     \\<in> lset\n            (lconcat\n              (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n                ttas)) \\<longrightarrow>\n     heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n      T \\<longrightarrow>\n     heap_base'.conf TYPE('heap) typeof_addr P v T\n  s = S\n\ngoal (1 subgoal):\n 1. \\<exists>s s' tls tl.\n       s = s \\<and>\n       \\<xi> = LCons tl tls \\<and>\n       multithreaded_base.redT (final_thread.init_fin_final final)\n        (if_heap_read_typed final r typeof_addr P)\n        (map NormalAction \\<circ> convert_RA) s tl s' \\<and>\n       ((\\<exists>s \\<xi>.\n            s' = s \\<and>\n            tls = \\<xi> \\<and>\n            trsys.Runs\n             (multithreaded_base.redT (final_thread.init_fin_final final)\n               (multithreaded_base.init_fin final r)\n               (map NormalAction \\<circ> convert_RA))\n             s \\<xi> \\<and>\n            (\\<forall>ad al v T.\n                NormalAction (ReadMem ad al v)\n                \\<in> lset\n                       (lconcat\n                         (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n                           \\<xi>)) \\<longrightarrow>\n                heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n                 T \\<longrightarrow>\n                heap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n        trsys.Runs\n         (multithreaded_base.redT (final_thread.init_fin_final final)\n           (if_heap_read_typed final r typeof_addr P)\n           (map NormalAction \\<circ> convert_RA))\n         s' tls)", "by blast"], ["proof (state)\nthis:\n  \\<exists>s s' tls tl.\n     s = s \\<and>\n     \\<xi> = LCons tl tls \\<and>\n     multithreaded_base.redT (final_thread.init_fin_final final)\n      (if_heap_read_typed final r typeof_addr P)\n      (map NormalAction \\<circ> convert_RA) s tl s' \\<and>\n     ((\\<exists>s \\<xi>.\n          s' = s \\<and>\n          tls = \\<xi> \\<and>\n          trsys.Runs\n           (multithreaded_base.redT (final_thread.init_fin_final final)\n             (multithreaded_base.init_fin final r)\n             (map NormalAction \\<circ> convert_RA))\n           s \\<xi> \\<and>\n          (\\<forall>ad al v T.\n              NormalAction (ReadMem ad al v)\n              \\<in> lset\n                     (lconcat\n                       (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n                         \\<xi>)) \\<longrightarrow>\n              heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n               T \\<longrightarrow>\n              heap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n      trsys.Runs\n       (multithreaded_base.redT (final_thread.init_fin_final final)\n         (if_heap_read_typed final r typeof_addr P)\n         (map NormalAction \\<circ> convert_RA))\n       s' tls)\n\ngoal (1 subgoal):\n 1. \\<And>s s' tls tl.\n       \\<lbrakk>s = s; \\<xi> = LCons tl tls;\n        multithreaded_base.redT (final_thread.init_fin_final final)\n         (multithreaded_base.init_fin final r)\n         (map NormalAction \\<circ> convert_RA) s tl s';\n        trsys.Runs\n         (multithreaded_base.redT (final_thread.init_fin_final final)\n           (multithreaded_base.init_fin final r)\n           (map NormalAction \\<circ> convert_RA))\n         s' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (if_heap_read_typed final r typeof_addr P)\n                              (map NormalAction \\<circ> convert_RA) s tl\n                              s' \\<and>\n                             ((\\<exists>s \\<xi>.\n                                  s' = s \\<and>\n                                  tls = \\<xi> \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (multithreaded_base.init_fin final r)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s \\<xi> \\<and>\n                                  (\\<forall>ad al v T.\nNormalAction (ReadMem ad al v)\n\\<in> lset\n       (lconcat\n         (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n           \\<xi>)) \\<longrightarrow>\nheap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow>\nheap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (if_heap_read_typed final r typeof_addr P)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s s' tls tl.\n     s = s \\<and>\n     \\<xi> = LCons tl tls \\<and>\n     multithreaded_base.redT (final_thread.init_fin_final final)\n      (if_heap_read_typed final r typeof_addr P)\n      (map NormalAction \\<circ> convert_RA) s tl s' \\<and>\n     ((\\<exists>s \\<xi>.\n          s' = s \\<and>\n          tls = \\<xi> \\<and>\n          trsys.Runs\n           (multithreaded_base.redT (final_thread.init_fin_final final)\n             (multithreaded_base.init_fin final r)\n             (map NormalAction \\<circ> convert_RA))\n           s \\<xi> \\<and>\n          (\\<forall>ad al v T.\n              NormalAction (ReadMem ad al v)\n              \\<in> lset\n                     (lconcat\n                       (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n                         \\<xi>)) \\<longrightarrow>\n              heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n               T \\<longrightarrow>\n              heap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n      trsys.Runs\n       (multithreaded_base.redT (final_thread.init_fin_final final)\n         (if_heap_read_typed final r typeof_addr P)\n         (map NormalAction \\<circ> convert_RA))\n       s' tls)\n\ngoal (1 subgoal):\n 1. (\\<exists>s.\n        s = s \\<and>\n        \\<xi> = LNil \\<and>\n        (\\<forall>x xa.\n            \\<not> multithreaded_base.redT\n                    (final_thread.init_fin_final final)\n                    (if_heap_read_typed final r typeof_addr P)\n                    (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n    (\\<exists>s s' tls tl.\n        s = s \\<and>\n        \\<xi> = LCons tl tls \\<and>\n        multithreaded_base.redT (final_thread.init_fin_final final)\n         (if_heap_read_typed final r typeof_addr P)\n         (map NormalAction \\<circ> convert_RA) s tl s' \\<and>\n        ((\\<exists>s \\<xi>.\n             s' = s \\<and>\n             tls = \\<xi> \\<and>\n             trsys.Runs\n              (multithreaded_base.redT (final_thread.init_fin_final final)\n                (multithreaded_base.init_fin final r)\n                (map NormalAction \\<circ> convert_RA))\n              s \\<xi> \\<and>\n             (\\<forall>ad al v T.\n                 NormalAction (ReadMem ad al v)\n                 \\<in> lset\n                        (lconcat\n                          (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n                            \\<xi>)) \\<longrightarrow>\n                 heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n                  T \\<longrightarrow>\n                 heap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n         trsys.Runs\n          (multithreaded_base.redT (final_thread.init_fin_final final)\n            (if_heap_read_typed final r typeof_addr P)\n            (map NormalAction \\<circ> convert_RA))\n          s' tls))", ".."], ["proof (state)\nthis:\n  (\\<exists>s.\n      s = s \\<and>\n      \\<xi> = LNil \\<and>\n      (\\<forall>x xa.\n          \\<not> multithreaded_base.redT (final_thread.init_fin_final final)\n                  (if_heap_read_typed final r typeof_addr P)\n                  (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n  (\\<exists>s s' tls tl.\n      s = s \\<and>\n      \\<xi> = LCons tl tls \\<and>\n      multithreaded_base.redT (final_thread.init_fin_final final)\n       (if_heap_read_typed final r typeof_addr P)\n       (map NormalAction \\<circ> convert_RA) s tl s' \\<and>\n      ((\\<exists>s \\<xi>.\n           s' = s \\<and>\n           tls = \\<xi> \\<and>\n           trsys.Runs\n            (multithreaded_base.redT (final_thread.init_fin_final final)\n              (multithreaded_base.init_fin final r)\n              (map NormalAction \\<circ> convert_RA))\n            s \\<xi> \\<and>\n           (\\<forall>ad al v T.\n               NormalAction (ReadMem ad al v)\n               \\<in> lset\n                      (lconcat\n                        (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n                          \\<xi>)) \\<longrightarrow>\n               heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n                T \\<longrightarrow>\n               heap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n       trsys.Runs\n        (multithreaded_base.redT (final_thread.init_fin_final final)\n          (if_heap_read_typed final r typeof_addr P)\n          (map NormalAction \\<circ> convert_RA))\n        s' tls))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>s.\n      s = s \\<and>\n      \\<xi> = LNil \\<and>\n      (\\<forall>x xa.\n          \\<not> multithreaded_base.redT (final_thread.init_fin_final final)\n                  (if_heap_read_typed final r typeof_addr P)\n                  (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n  (\\<exists>s s' tls tl.\n      s = s \\<and>\n      \\<xi> = LCons tl tls \\<and>\n      multithreaded_base.redT (final_thread.init_fin_final final)\n       (if_heap_read_typed final r typeof_addr P)\n       (map NormalAction \\<circ> convert_RA) s tl s' \\<and>\n      ((\\<exists>s \\<xi>.\n           s' = s \\<and>\n           tls = \\<xi> \\<and>\n           trsys.Runs\n            (multithreaded_base.redT (final_thread.init_fin_final final)\n              (multithreaded_base.init_fin final r)\n              (map NormalAction \\<circ> convert_RA))\n            s \\<xi> \\<and>\n           (\\<forall>ad al v T.\n               NormalAction (ReadMem ad al v)\n               \\<in> lset\n                      (lconcat\n                        (lmap (llist_of \\<circ> obs_a \\<circ> snd)\n                          \\<xi>)) \\<longrightarrow>\n               heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n                T \\<longrightarrow>\n               heap_base'.conf TYPE('heap) typeof_addr P v T)) \\<or>\n       trsys.Runs\n        (multithreaded_base.redT (final_thread.init_fin_final final)\n          (if_heap_read_typed final r typeof_addr P)\n          (map NormalAction \\<circ> convert_RA))\n        s' tls))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma if_mthr_Runs_heap_read_typedD:\n  fixes final and r :: \"('addr, 't, 'x, 'heap, 'w, ('addr :: addr, 'thread_id) obs_event) semantics\"\n  assumes Runs': \"trsys.Runs (multithreaded_base.redT (final_thread.init_fin_final final) (if_heap_read_typed final r typeof_addr P) (map NormalAction \\<circ> convert_RA)) s \\<xi>\"\n  (is \"?Runs' s \\<xi>\")\n  and stuck: \"\\<And>ttas s' tta s''. \\<lbrakk>\n    multithreaded_base.RedT (final_thread.init_fin_final final) (if_heap_read_typed final r typeof_addr P) (map NormalAction \\<circ> convert_RA) s ttas s';\n    multithreaded_base.redT (final_thread.init_fin_final final) (multithreaded_base.init_fin final r) (map NormalAction \\<circ> convert_RA) s' tta s'' \\<rbrakk>\n  \\<Longrightarrow> \\<exists>tta s''. multithreaded_base.redT (final_thread.init_fin_final final) (if_heap_read_typed final r typeof_addr P) (map NormalAction \\<circ> convert_RA) s' tta s''\"\n  (is \"\\<And>ttas s' tta s''. \\<lbrakk> ?RedT' s ttas s'; ?redT s' tta s'' \\<rbrakk> \\<Longrightarrow> \\<exists>tta s''. ?redT' s' tta s''\")\n  shows \"trsys.Runs (multithreaded_base.redT (final_thread.init_fin_final final) (multithreaded_base.init_fin final r) (map NormalAction \\<circ> convert_RA)) s \\<xi>\"\n  (is \"?Runs s \\<xi>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. trsys.Runs\n     (multithreaded_base.redT (final_thread.init_fin_final final)\n       (multithreaded_base.init_fin final r)\n       (map NormalAction \\<circ> convert_RA))\n     s \\<xi>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trsys.Runs\n     (multithreaded_base.redT (final_thread.init_fin_final final)\n       (multithreaded_base.init_fin final r)\n       (map NormalAction \\<circ> convert_RA))\n     s \\<xi>", "define s' where \"s' = s\""], ["proof (state)\nthis:\n  s' = s\n\ngoal (1 subgoal):\n 1. trsys.Runs\n     (multithreaded_base.redT (final_thread.init_fin_final final)\n       (multithreaded_base.init_fin final r)\n       (map NormalAction \\<circ> convert_RA))\n     s \\<xi>", "with Runs'"], ["proof (chain)\npicking this:\n  trsys.Runs\n   (multithreaded_base.redT (final_thread.init_fin_final final)\n     (if_heap_read_typed final r typeof_addr P)\n     (map NormalAction \\<circ> convert_RA))\n   s \\<xi>\n  s' = s", "have \"\\<exists>ttas. ?RedT' s ttas s' \\<and> ?Runs' s' \\<xi>\""], ["proof (prove)\nusing this:\n  trsys.Runs\n   (multithreaded_base.redT (final_thread.init_fin_final final)\n     (if_heap_read_typed final r typeof_addr P)\n     (map NormalAction \\<circ> convert_RA))\n   s \\<xi>\n  s' = s\n\ngoal (1 subgoal):\n 1. \\<exists>ttas.\n       multithreaded_base.RedT (final_thread.init_fin_final final)\n        (if_heap_read_typed final r typeof_addr P)\n        (map NormalAction \\<circ> convert_RA) s ttas s' \\<and>\n       trsys.Runs\n        (multithreaded_base.redT (final_thread.init_fin_final final)\n          (if_heap_read_typed final r typeof_addr P)\n          (map NormalAction \\<circ> convert_RA))\n        s' \\<xi>", "by(auto simp add: multithreaded_base.RedT_def o_def)"], ["proof (state)\nthis:\n  \\<exists>ttas.\n     multithreaded_base.RedT (final_thread.init_fin_final final)\n      (if_heap_read_typed final r typeof_addr P)\n      (map NormalAction \\<circ> convert_RA) s ttas s' \\<and>\n     trsys.Runs\n      (multithreaded_base.redT (final_thread.init_fin_final final)\n        (if_heap_read_typed final r typeof_addr P)\n        (map NormalAction \\<circ> convert_RA))\n      s' \\<xi>\n\ngoal (1 subgoal):\n 1. trsys.Runs\n     (multithreaded_base.redT (final_thread.init_fin_final final)\n       (multithreaded_base.init_fin final r)\n       (map NormalAction \\<circ> convert_RA))\n     s \\<xi>", "thus \"?Runs s' \\<xi>\""], ["proof (prove)\nusing this:\n  \\<exists>ttas.\n     multithreaded_base.RedT (final_thread.init_fin_final final)\n      (if_heap_read_typed final r typeof_addr P)\n      (map NormalAction \\<circ> convert_RA) s ttas s' \\<and>\n     trsys.Runs\n      (multithreaded_base.redT (final_thread.init_fin_final final)\n        (if_heap_read_typed final r typeof_addr P)\n        (map NormalAction \\<circ> convert_RA))\n      s' \\<xi>\n\ngoal (1 subgoal):\n 1. trsys.Runs\n     (multithreaded_base.redT (final_thread.init_fin_final final)\n       (multithreaded_base.init_fin final r)\n       (map NormalAction \\<circ> convert_RA))\n     s' \\<xi>", "proof(coinduct rule: trsys.Runs.coinduct[consumes 1, case_names Runs, case_conclusion Runs Stuck Step])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<exists>ttas.\n          multithreaded_base.RedT (final_thread.init_fin_final final)\n           (if_heap_read_typed final r typeof_addr P)\n           (map NormalAction \\<circ> convert_RA) s ttas x1 \\<and>\n          trsys.Runs\n           (multithreaded_base.redT (final_thread.init_fin_final final)\n             (if_heap_read_typed final r typeof_addr P)\n             (map NormalAction \\<circ> convert_RA))\n           x1 x2 \\<Longrightarrow>\n       (\\<exists>s.\n           x1 = s \\<and>\n           x2 = LNil \\<and>\n           (\\<forall>x xa.\n               \\<not> multithreaded_base.redT\n                       (final_thread.init_fin_final final)\n                       (multithreaded_base.init_fin final r)\n                       (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n       (\\<exists>sa s' tls tl.\n           x1 = sa \\<and>\n           x2 = LCons tl tls \\<and>\n           multithreaded_base.redT (final_thread.init_fin_final final)\n            (multithreaded_base.init_fin final r)\n            (map NormalAction \\<circ> convert_RA) sa tl s' \\<and>\n           ((\\<exists>ttas.\n                multithreaded_base.RedT (final_thread.init_fin_final final)\n                 (if_heap_read_typed final r typeof_addr P)\n                 (map NormalAction \\<circ> convert_RA) s ttas s' \\<and>\n                trsys.Runs\n                 (multithreaded_base.redT\n                   (final_thread.init_fin_final final)\n                   (if_heap_read_typed final r typeof_addr P)\n                   (map NormalAction \\<circ> convert_RA))\n                 s' tls) \\<or>\n            trsys.Runs\n             (multithreaded_base.redT (final_thread.init_fin_final final)\n               (multithreaded_base.init_fin final r)\n               (map NormalAction \\<circ> convert_RA))\n             s' tls))", "case (Runs s' \\<xi>)"], ["proof (state)\nthis:\n  \\<exists>ttas.\n     multithreaded_base.RedT (final_thread.init_fin_final final)\n      (if_heap_read_typed final r typeof_addr P)\n      (map NormalAction \\<circ> convert_RA) s ttas s' \\<and>\n     trsys.Runs\n      (multithreaded_base.redT (final_thread.init_fin_final final)\n        (if_heap_read_typed final r typeof_addr P)\n        (map NormalAction \\<circ> convert_RA))\n      s' \\<xi>\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<exists>ttas.\n          multithreaded_base.RedT (final_thread.init_fin_final final)\n           (if_heap_read_typed final r typeof_addr P)\n           (map NormalAction \\<circ> convert_RA) s ttas x1 \\<and>\n          trsys.Runs\n           (multithreaded_base.redT (final_thread.init_fin_final final)\n             (if_heap_read_typed final r typeof_addr P)\n             (map NormalAction \\<circ> convert_RA))\n           x1 x2 \\<Longrightarrow>\n       (\\<exists>s.\n           x1 = s \\<and>\n           x2 = LNil \\<and>\n           (\\<forall>x xa.\n               \\<not> multithreaded_base.redT\n                       (final_thread.init_fin_final final)\n                       (multithreaded_base.init_fin final r)\n                       (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n       (\\<exists>sa s' tls tl.\n           x1 = sa \\<and>\n           x2 = LCons tl tls \\<and>\n           multithreaded_base.redT (final_thread.init_fin_final final)\n            (multithreaded_base.init_fin final r)\n            (map NormalAction \\<circ> convert_RA) sa tl s' \\<and>\n           ((\\<exists>ttas.\n                multithreaded_base.RedT (final_thread.init_fin_final final)\n                 (if_heap_read_typed final r typeof_addr P)\n                 (map NormalAction \\<circ> convert_RA) s ttas s' \\<and>\n                trsys.Runs\n                 (multithreaded_base.redT\n                   (final_thread.init_fin_final final)\n                   (if_heap_read_typed final r typeof_addr P)\n                   (map NormalAction \\<circ> convert_RA))\n                 s' tls) \\<or>\n            trsys.Runs\n             (multithreaded_base.redT (final_thread.init_fin_final final)\n               (multithreaded_base.init_fin final r)\n               (map NormalAction \\<circ> convert_RA))\n             s' tls))", "then"], ["proof (chain)\npicking this:\n  \\<exists>ttas.\n     multithreaded_base.RedT (final_thread.init_fin_final final)\n      (if_heap_read_typed final r typeof_addr P)\n      (map NormalAction \\<circ> convert_RA) s ttas s' \\<and>\n     trsys.Runs\n      (multithreaded_base.redT (final_thread.init_fin_final final)\n        (if_heap_read_typed final r typeof_addr P)\n        (map NormalAction \\<circ> convert_RA))\n      s' \\<xi>", "obtain ttas where RedT': \"?RedT' s ttas s'\"\n      and Runs': \"?Runs' s' \\<xi>\""], ["proof (prove)\nusing this:\n  \\<exists>ttas.\n     multithreaded_base.RedT (final_thread.init_fin_final final)\n      (if_heap_read_typed final r typeof_addr P)\n      (map NormalAction \\<circ> convert_RA) s ttas s' \\<and>\n     trsys.Runs\n      (multithreaded_base.redT (final_thread.init_fin_final final)\n        (if_heap_read_typed final r typeof_addr P)\n        (map NormalAction \\<circ> convert_RA))\n      s' \\<xi>\n\ngoal (1 subgoal):\n 1. (\\<And>ttas.\n        \\<lbrakk>multithreaded_base.RedT (final_thread.init_fin_final final)\n                  (if_heap_read_typed final r typeof_addr P)\n                  (map NormalAction \\<circ> convert_RA) s ttas s';\n         trsys.Runs\n          (multithreaded_base.redT (final_thread.init_fin_final final)\n            (if_heap_read_typed final r typeof_addr P)\n            (map NormalAction \\<circ> convert_RA))\n          s' \\<xi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  multithreaded_base.RedT (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s ttas s'\n  trsys.Runs\n   (multithreaded_base.redT (final_thread.init_fin_final final)\n     (if_heap_read_typed final r typeof_addr P)\n     (map NormalAction \\<circ> convert_RA))\n   s' \\<xi>\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<exists>ttas.\n          multithreaded_base.RedT (final_thread.init_fin_final final)\n           (if_heap_read_typed final r typeof_addr P)\n           (map NormalAction \\<circ> convert_RA) s ttas x1 \\<and>\n          trsys.Runs\n           (multithreaded_base.redT (final_thread.init_fin_final final)\n             (if_heap_read_typed final r typeof_addr P)\n             (map NormalAction \\<circ> convert_RA))\n           x1 x2 \\<Longrightarrow>\n       (\\<exists>s.\n           x1 = s \\<and>\n           x2 = LNil \\<and>\n           (\\<forall>x xa.\n               \\<not> multithreaded_base.redT\n                       (final_thread.init_fin_final final)\n                       (multithreaded_base.init_fin final r)\n                       (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n       (\\<exists>sa s' tls tl.\n           x1 = sa \\<and>\n           x2 = LCons tl tls \\<and>\n           multithreaded_base.redT (final_thread.init_fin_final final)\n            (multithreaded_base.init_fin final r)\n            (map NormalAction \\<circ> convert_RA) sa tl s' \\<and>\n           ((\\<exists>ttas.\n                multithreaded_base.RedT (final_thread.init_fin_final final)\n                 (if_heap_read_typed final r typeof_addr P)\n                 (map NormalAction \\<circ> convert_RA) s ttas s' \\<and>\n                trsys.Runs\n                 (multithreaded_base.redT\n                   (final_thread.init_fin_final final)\n                   (if_heap_read_typed final r typeof_addr P)\n                   (map NormalAction \\<circ> convert_RA))\n                 s' tls) \\<or>\n            trsys.Runs\n             (multithreaded_base.redT (final_thread.init_fin_final final)\n               (multithreaded_base.init_fin final r)\n               (map NormalAction \\<circ> convert_RA))\n             s' tls))", "from Runs'"], ["proof (chain)\npicking this:\n  trsys.Runs\n   (multithreaded_base.redT (final_thread.init_fin_final final)\n     (if_heap_read_typed final r typeof_addr P)\n     (map NormalAction \\<circ> convert_RA))\n   s' \\<xi>", "show ?case"], ["proof (prove)\nusing this:\n  trsys.Runs\n   (multithreaded_base.redT (final_thread.init_fin_final final)\n     (if_heap_read_typed final r typeof_addr P)\n     (map NormalAction \\<circ> convert_RA))\n   s' \\<xi>\n\ngoal (1 subgoal):\n 1. (\\<exists>s.\n        s' = s \\<and>\n        \\<xi> = LNil \\<and>\n        (\\<forall>x xa.\n            \\<not> multithreaded_base.redT\n                    (final_thread.init_fin_final final)\n                    (multithreaded_base.init_fin final r)\n                    (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n    (\\<exists>sa s' tls tl.\n        s' = sa \\<and>\n        \\<xi> = LCons tl tls \\<and>\n        multithreaded_base.redT (final_thread.init_fin_final final)\n         (multithreaded_base.init_fin final r)\n         (map NormalAction \\<circ> convert_RA) sa tl s' \\<and>\n        ((\\<exists>ttas.\n             multithreaded_base.RedT (final_thread.init_fin_final final)\n              (if_heap_read_typed final r typeof_addr P)\n              (map NormalAction \\<circ> convert_RA) s ttas s' \\<and>\n             trsys.Runs\n              (multithreaded_base.redT (final_thread.init_fin_final final)\n                (if_heap_read_typed final r typeof_addr P)\n                (map NormalAction \\<circ> convert_RA))\n              s' tls) \\<or>\n         trsys.Runs\n          (multithreaded_base.redT (final_thread.init_fin_final final)\n            (multithreaded_base.init_fin final r)\n            (map NormalAction \\<circ> convert_RA))\n          s' tls))", "proof(cases rule: trsys.Runs.cases[consumes 1, case_names Stuck Step])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>sa.\n       \\<lbrakk>s' = sa; \\<xi> = LNil;\n        \\<And>tl s'.\n           \\<not> multithreaded_base.redT\n                   (final_thread.init_fin_final final)\n                   (if_heap_read_typed final r typeof_addr P)\n                   (map NormalAction \\<circ> convert_RA) sa tl s'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s' = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final) (multithreaded_base.init_fin final r)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>sa s' tls tl.\n                             s' = sa \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (multithreaded_base.init_fin final r)\n                              (map NormalAction \\<circ> convert_RA) sa tl\n                              s' \\<and>\n                             ((\\<exists>ttas.\n                                  multithreaded_base.RedT\n                                   (final_thread.init_fin_final final)\n                                   (if_heap_read_typed final r typeof_addr\n                                     P)\n                                   (map NormalAction \\<circ> convert_RA) s\n                                   ttas s' \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (if_heap_read_typed final r typeof_addr\n P)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s' tls) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (multithreaded_base.init_fin final r)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))\n 2. \\<And>sa s' tls tl.\n       \\<lbrakk>s' = sa; \\<xi> = LCons tl tls;\n        multithreaded_base.redT (final_thread.init_fin_final final)\n         (if_heap_read_typed final r typeof_addr P)\n         (map NormalAction \\<circ> convert_RA) sa tl s';\n        trsys.Runs\n         (multithreaded_base.redT (final_thread.init_fin_final final)\n           (if_heap_read_typed final r typeof_addr P)\n           (map NormalAction \\<circ> convert_RA))\n         s' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s' = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final) (multithreaded_base.init_fin final r)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>sa s' tls tl.\n                             s' = sa \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (multithreaded_base.init_fin final r)\n                              (map NormalAction \\<circ> convert_RA) sa tl\n                              s' \\<and>\n                             ((\\<exists>ttas.\n                                  multithreaded_base.RedT\n                                   (final_thread.init_fin_final final)\n                                   (if_heap_read_typed final r typeof_addr\n                                     P)\n                                   (map NormalAction \\<circ> convert_RA) s\n                                   ttas s' \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (if_heap_read_typed final r typeof_addr\n P)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s' tls) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (multithreaded_base.init_fin final r)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))", "case (Stuck S)"], ["proof (state)\nthis:\n  s' = S\n  \\<xi> = LNil\n  \\<not> multithreaded_base.redT (final_thread.init_fin_final final)\n          (if_heap_read_typed final r typeof_addr P)\n          (map NormalAction \\<circ> convert_RA) S ?tl ?s'\n\ngoal (2 subgoals):\n 1. \\<And>sa.\n       \\<lbrakk>s' = sa; \\<xi> = LNil;\n        \\<And>tl s'.\n           \\<not> multithreaded_base.redT\n                   (final_thread.init_fin_final final)\n                   (if_heap_read_typed final r typeof_addr P)\n                   (map NormalAction \\<circ> convert_RA) sa tl s'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s' = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final) (multithreaded_base.init_fin final r)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>sa s' tls tl.\n                             s' = sa \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (multithreaded_base.init_fin final r)\n                              (map NormalAction \\<circ> convert_RA) sa tl\n                              s' \\<and>\n                             ((\\<exists>ttas.\n                                  multithreaded_base.RedT\n                                   (final_thread.init_fin_final final)\n                                   (if_heap_read_typed final r typeof_addr\n                                     P)\n                                   (map NormalAction \\<circ> convert_RA) s\n                                   ttas s' \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (if_heap_read_typed final r typeof_addr\n P)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s' tls) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (multithreaded_base.init_fin final r)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))\n 2. \\<And>sa s' tls tl.\n       \\<lbrakk>s' = sa; \\<xi> = LCons tl tls;\n        multithreaded_base.redT (final_thread.init_fin_final final)\n         (if_heap_read_typed final r typeof_addr P)\n         (map NormalAction \\<circ> convert_RA) sa tl s';\n        trsys.Runs\n         (multithreaded_base.redT (final_thread.init_fin_final final)\n           (if_heap_read_typed final r typeof_addr P)\n           (map NormalAction \\<circ> convert_RA))\n         s' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s' = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final) (multithreaded_base.init_fin final r)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>sa s' tls tl.\n                             s' = sa \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (multithreaded_base.init_fin final r)\n                              (map NormalAction \\<circ> convert_RA) sa tl\n                              s' \\<and>\n                             ((\\<exists>ttas.\n                                  multithreaded_base.RedT\n                                   (final_thread.init_fin_final final)\n                                   (if_heap_read_typed final r typeof_addr\n                                     P)\n                                   (map NormalAction \\<circ> convert_RA) s\n                                   ttas s' \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (if_heap_read_typed final r typeof_addr\n P)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s' tls) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (multithreaded_base.init_fin final r)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))", "have \"\\<And>tta s''. \\<not> ?redT s' tta s''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tta s''.\n       \\<not> multithreaded_base.redT (final_thread.init_fin_final final)\n               (multithreaded_base.init_fin final r)\n               (map NormalAction \\<circ> convert_RA) s' tta s''", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>tta s''.\n       multithreaded_base.redT (final_thread.init_fin_final final)\n        (multithreaded_base.init_fin final r)\n        (map NormalAction \\<circ> convert_RA) s' tta s'' \\<Longrightarrow>\n       False", "fix tta s''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>tta s''.\n       multithreaded_base.redT (final_thread.init_fin_final final)\n        (multithreaded_base.init_fin final r)\n        (map NormalAction \\<circ> convert_RA) s' tta s'' \\<Longrightarrow>\n       False", "assume \"?redT s' tta s''\""], ["proof (state)\nthis:\n  multithreaded_base.redT (final_thread.init_fin_final final)\n   (multithreaded_base.init_fin final r)\n   (map NormalAction \\<circ> convert_RA) s' tta s''\n\ngoal (1 subgoal):\n 1. \\<And>tta s''.\n       multithreaded_base.redT (final_thread.init_fin_final final)\n        (multithreaded_base.init_fin final r)\n        (map NormalAction \\<circ> convert_RA) s' tta s'' \\<Longrightarrow>\n       False", "from stuck[OF RedT' this]"], ["proof (chain)\npicking this:\n  \\<exists>tta s''.\n     multithreaded_base.redT (final_thread.init_fin_final final)\n      (if_heap_read_typed final r typeof_addr P)\n      (map NormalAction \\<circ> convert_RA) s' tta s''", "obtain tta s'' where \"?redT' s' tta s''\""], ["proof (prove)\nusing this:\n  \\<exists>tta s''.\n     multithreaded_base.redT (final_thread.init_fin_final final)\n      (if_heap_read_typed final r typeof_addr P)\n      (map NormalAction \\<circ> convert_RA) s' tta s''\n\ngoal (1 subgoal):\n 1. (\\<And>tta s''.\n        multithreaded_base.redT (final_thread.init_fin_final final)\n         (if_heap_read_typed final r typeof_addr P)\n         (map NormalAction \\<circ> convert_RA) s' tta s'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  multithreaded_base.redT (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s' tta s''\n\ngoal (1 subgoal):\n 1. \\<And>tta s''.\n       multithreaded_base.redT (final_thread.init_fin_final final)\n        (multithreaded_base.init_fin final r)\n        (map NormalAction \\<circ> convert_RA) s' tta s'' \\<Longrightarrow>\n       False", "with Stuck(3)[of tta s'']"], ["proof (chain)\npicking this:\n  \\<not> multithreaded_base.redT (final_thread.init_fin_final final)\n          (if_heap_read_typed final r typeof_addr P)\n          (map NormalAction \\<circ> convert_RA) S tta s''\n  multithreaded_base.redT (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s' tta s''", "show False"], ["proof (prove)\nusing this:\n  \\<not> multithreaded_base.redT (final_thread.init_fin_final final)\n          (if_heap_read_typed final r typeof_addr P)\n          (map NormalAction \\<circ> convert_RA) S tta s''\n  multithreaded_base.redT (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s' tta s''\n\ngoal (1 subgoal):\n 1. False", "unfolding \\<open>s' = S\\<close>"], ["proof (prove)\nusing this:\n  \\<not> multithreaded_base.redT (final_thread.init_fin_final final)\n          (if_heap_read_typed final r typeof_addr P)\n          (map NormalAction \\<circ> convert_RA) S tta s''\n  multithreaded_base.redT (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) S tta s''\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> multithreaded_base.redT (final_thread.init_fin_final final)\n          (multithreaded_base.init_fin final r)\n          (map NormalAction \\<circ> convert_RA) s' ?tta ?s''\n\ngoal (2 subgoals):\n 1. \\<And>sa.\n       \\<lbrakk>s' = sa; \\<xi> = LNil;\n        \\<And>tl s'.\n           \\<not> multithreaded_base.redT\n                   (final_thread.init_fin_final final)\n                   (if_heap_read_typed final r typeof_addr P)\n                   (map NormalAction \\<circ> convert_RA) sa tl s'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s' = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final) (multithreaded_base.init_fin final r)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>sa s' tls tl.\n                             s' = sa \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (multithreaded_base.init_fin final r)\n                              (map NormalAction \\<circ> convert_RA) sa tl\n                              s' \\<and>\n                             ((\\<exists>ttas.\n                                  multithreaded_base.RedT\n                                   (final_thread.init_fin_final final)\n                                   (if_heap_read_typed final r typeof_addr\n                                     P)\n                                   (map NormalAction \\<circ> convert_RA) s\n                                   ttas s' \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (if_heap_read_typed final r typeof_addr\n P)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s' tls) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (multithreaded_base.init_fin final r)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))\n 2. \\<And>sa s' tls tl.\n       \\<lbrakk>s' = sa; \\<xi> = LCons tl tls;\n        multithreaded_base.redT (final_thread.init_fin_final final)\n         (if_heap_read_typed final r typeof_addr P)\n         (map NormalAction \\<circ> convert_RA) sa tl s';\n        trsys.Runs\n         (multithreaded_base.redT (final_thread.init_fin_final final)\n           (if_heap_read_typed final r typeof_addr P)\n           (map NormalAction \\<circ> convert_RA))\n         s' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s' = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final) (multithreaded_base.init_fin final r)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>sa s' tls tl.\n                             s' = sa \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (multithreaded_base.init_fin final r)\n                              (map NormalAction \\<circ> convert_RA) sa tl\n                              s' \\<and>\n                             ((\\<exists>ttas.\n                                  multithreaded_base.RedT\n                                   (final_thread.init_fin_final final)\n                                   (if_heap_read_typed final r typeof_addr\n                                     P)\n                                   (map NormalAction \\<circ> convert_RA) s\n                                   ttas s' \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (if_heap_read_typed final r typeof_addr\n P)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s' tls) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (multithreaded_base.init_fin final r)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))", "with Stuck(1-2)"], ["proof (chain)\npicking this:\n  s' = S\n  \\<xi> = LNil\n  \\<not> multithreaded_base.redT (final_thread.init_fin_final final)\n          (multithreaded_base.init_fin final r)\n          (map NormalAction \\<circ> convert_RA) s' ?tta ?s''", "have ?Stuck"], ["proof (prove)\nusing this:\n  s' = S\n  \\<xi> = LNil\n  \\<not> multithreaded_base.redT (final_thread.init_fin_final final)\n          (multithreaded_base.init_fin final r)\n          (map NormalAction \\<circ> convert_RA) s' ?tta ?s''\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       s' = s \\<and>\n       \\<xi> = LNil \\<and>\n       (\\<forall>x xa.\n           \\<not> multithreaded_base.redT\n                   (final_thread.init_fin_final final)\n                   (multithreaded_base.init_fin final r)\n                   (map NormalAction \\<circ> convert_RA) s x xa)", "by simp"], ["proof (state)\nthis:\n  \\<exists>s.\n     s' = s \\<and>\n     \\<xi> = LNil \\<and>\n     (\\<forall>x xa.\n         \\<not> multithreaded_base.redT (final_thread.init_fin_final final)\n                 (multithreaded_base.init_fin final r)\n                 (map NormalAction \\<circ> convert_RA) s x xa)\n\ngoal (2 subgoals):\n 1. \\<And>sa.\n       \\<lbrakk>s' = sa; \\<xi> = LNil;\n        \\<And>tl s'.\n           \\<not> multithreaded_base.redT\n                   (final_thread.init_fin_final final)\n                   (if_heap_read_typed final r typeof_addr P)\n                   (map NormalAction \\<circ> convert_RA) sa tl s'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s' = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final) (multithreaded_base.init_fin final r)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>sa s' tls tl.\n                             s' = sa \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (multithreaded_base.init_fin final r)\n                              (map NormalAction \\<circ> convert_RA) sa tl\n                              s' \\<and>\n                             ((\\<exists>ttas.\n                                  multithreaded_base.RedT\n                                   (final_thread.init_fin_final final)\n                                   (if_heap_read_typed final r typeof_addr\n                                     P)\n                                   (map NormalAction \\<circ> convert_RA) s\n                                   ttas s' \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (if_heap_read_typed final r typeof_addr\n P)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s' tls) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (multithreaded_base.init_fin final r)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))\n 2. \\<And>sa s' tls tl.\n       \\<lbrakk>s' = sa; \\<xi> = LCons tl tls;\n        multithreaded_base.redT (final_thread.init_fin_final final)\n         (if_heap_read_typed final r typeof_addr P)\n         (map NormalAction \\<circ> convert_RA) sa tl s';\n        trsys.Runs\n         (multithreaded_base.redT (final_thread.init_fin_final final)\n           (if_heap_read_typed final r typeof_addr P)\n           (map NormalAction \\<circ> convert_RA))\n         s' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s' = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final) (multithreaded_base.init_fin final r)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>sa s' tls tl.\n                             s' = sa \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (multithreaded_base.init_fin final r)\n                              (map NormalAction \\<circ> convert_RA) sa tl\n                              s' \\<and>\n                             ((\\<exists>ttas.\n                                  multithreaded_base.RedT\n                                   (final_thread.init_fin_final final)\n                                   (if_heap_read_typed final r typeof_addr\n                                     P)\n                                   (map NormalAction \\<circ> convert_RA) s\n                                   ttas s' \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (if_heap_read_typed final r typeof_addr\n P)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s' tls) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (multithreaded_base.init_fin final r)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s.\n     s' = s \\<and>\n     \\<xi> = LNil \\<and>\n     (\\<forall>x xa.\n         \\<not> multithreaded_base.redT (final_thread.init_fin_final final)\n                 (multithreaded_base.init_fin final r)\n                 (map NormalAction \\<circ> convert_RA) s x xa)\n\ngoal (1 subgoal):\n 1. (\\<exists>s.\n        s' = s \\<and>\n        \\<xi> = LNil \\<and>\n        (\\<forall>x xa.\n            \\<not> multithreaded_base.redT\n                    (final_thread.init_fin_final final)\n                    (multithreaded_base.init_fin final r)\n                    (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n    (\\<exists>sa s' tls tl.\n        s' = sa \\<and>\n        \\<xi> = LCons tl tls \\<and>\n        multithreaded_base.redT (final_thread.init_fin_final final)\n         (multithreaded_base.init_fin final r)\n         (map NormalAction \\<circ> convert_RA) sa tl s' \\<and>\n        ((\\<exists>ttas.\n             multithreaded_base.RedT (final_thread.init_fin_final final)\n              (if_heap_read_typed final r typeof_addr P)\n              (map NormalAction \\<circ> convert_RA) s ttas s' \\<and>\n             trsys.Runs\n              (multithreaded_base.redT (final_thread.init_fin_final final)\n                (if_heap_read_typed final r typeof_addr P)\n                (map NormalAction \\<circ> convert_RA))\n              s' tls) \\<or>\n         trsys.Runs\n          (multithreaded_base.redT (final_thread.init_fin_final final)\n            (multithreaded_base.init_fin final r)\n            (map NormalAction \\<circ> convert_RA))\n          s' tls))", "by(rule disjI1)"], ["proof (state)\nthis:\n  (\\<exists>s.\n      s' = s \\<and>\n      \\<xi> = LNil \\<and>\n      (\\<forall>x xa.\n          \\<not> multithreaded_base.redT (final_thread.init_fin_final final)\n                  (multithreaded_base.init_fin final r)\n                  (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n  (\\<exists>sa s' tls tl.\n      s' = sa \\<and>\n      \\<xi> = LCons tl tls \\<and>\n      multithreaded_base.redT (final_thread.init_fin_final final)\n       (multithreaded_base.init_fin final r)\n       (map NormalAction \\<circ> convert_RA) sa tl s' \\<and>\n      ((\\<exists>ttas.\n           multithreaded_base.RedT (final_thread.init_fin_final final)\n            (if_heap_read_typed final r typeof_addr P)\n            (map NormalAction \\<circ> convert_RA) s ttas s' \\<and>\n           trsys.Runs\n            (multithreaded_base.redT (final_thread.init_fin_final final)\n              (if_heap_read_typed final r typeof_addr P)\n              (map NormalAction \\<circ> convert_RA))\n            s' tls) \\<or>\n       trsys.Runs\n        (multithreaded_base.redT (final_thread.init_fin_final final)\n          (multithreaded_base.init_fin final r)\n          (map NormalAction \\<circ> convert_RA))\n        s' tls))\n\ngoal (1 subgoal):\n 1. \\<And>sa s' tls tl.\n       \\<lbrakk>s' = sa; \\<xi> = LCons tl tls;\n        multithreaded_base.redT (final_thread.init_fin_final final)\n         (if_heap_read_typed final r typeof_addr P)\n         (map NormalAction \\<circ> convert_RA) sa tl s';\n        trsys.Runs\n         (multithreaded_base.redT (final_thread.init_fin_final final)\n           (if_heap_read_typed final r typeof_addr P)\n           (map NormalAction \\<circ> convert_RA))\n         s' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s' = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final) (multithreaded_base.init_fin final r)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>sa s' tls tl.\n                             s' = sa \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (multithreaded_base.init_fin final r)\n                              (map NormalAction \\<circ> convert_RA) sa tl\n                              s' \\<and>\n                             ((\\<exists>ttas.\n                                  multithreaded_base.RedT\n                                   (final_thread.init_fin_final final)\n                                   (if_heap_read_typed final r typeof_addr\n                                     P)\n                                   (map NormalAction \\<circ> convert_RA) s\n                                   ttas s' \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (if_heap_read_typed final r typeof_addr\n P)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s' tls) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (multithreaded_base.init_fin final r)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>sa s' tls tl.\n       \\<lbrakk>s' = sa; \\<xi> = LCons tl tls;\n        multithreaded_base.redT (final_thread.init_fin_final final)\n         (if_heap_read_typed final r typeof_addr P)\n         (map NormalAction \\<circ> convert_RA) sa tl s';\n        trsys.Runs\n         (multithreaded_base.redT (final_thread.init_fin_final final)\n           (if_heap_read_typed final r typeof_addr P)\n           (map NormalAction \\<circ> convert_RA))\n         s' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s' = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final) (multithreaded_base.init_fin final r)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>sa s' tls tl.\n                             s' = sa \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (multithreaded_base.init_fin final r)\n                              (map NormalAction \\<circ> convert_RA) sa tl\n                              s' \\<and>\n                             ((\\<exists>ttas.\n                                  multithreaded_base.RedT\n                                   (final_thread.init_fin_final final)\n                                   (if_heap_read_typed final r typeof_addr\n                                     P)\n                                   (map NormalAction \\<circ> convert_RA) s\n                                   ttas s' \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (if_heap_read_typed final r typeof_addr\n P)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s' tls) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (multithreaded_base.init_fin final r)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))", "case (Step S s'' \\<xi>' tta)"], ["proof (state)\nthis:\n  s' = S\n  \\<xi> = LCons tta \\<xi>'\n  multithreaded_base.redT (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) S tta s''\n  trsys.Runs\n   (multithreaded_base.redT (final_thread.init_fin_final final)\n     (if_heap_read_typed final r typeof_addr P)\n     (map NormalAction \\<circ> convert_RA))\n   s'' \\<xi>'\n\ngoal (1 subgoal):\n 1. \\<And>sa s' tls tl.\n       \\<lbrakk>s' = sa; \\<xi> = LCons tl tls;\n        multithreaded_base.redT (final_thread.init_fin_final final)\n         (if_heap_read_typed final r typeof_addr P)\n         (map NormalAction \\<circ> convert_RA) sa tl s';\n        trsys.Runs\n         (multithreaded_base.redT (final_thread.init_fin_final final)\n           (if_heap_read_typed final r typeof_addr P)\n           (map NormalAction \\<circ> convert_RA))\n         s' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s' = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final) (multithreaded_base.init_fin final r)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>sa s' tls tl.\n                             s' = sa \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (multithreaded_base.init_fin final r)\n                              (map NormalAction \\<circ> convert_RA) sa tl\n                              s' \\<and>\n                             ((\\<exists>ttas.\n                                  multithreaded_base.RedT\n                                   (final_thread.init_fin_final final)\n                                   (if_heap_read_typed final r typeof_addr\n                                     P)\n                                   (map NormalAction \\<circ> convert_RA) s\n                                   ttas s' \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (if_heap_read_typed final r typeof_addr\n P)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s' tls) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (multithreaded_base.init_fin final r)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))", "note Step = Step(2-)[folded \\<open>s' = S\\<close>]"], ["proof (state)\nthis:\n  \\<xi> = LCons tta \\<xi>'\n  multithreaded_base.redT (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s' tta s''\n  trsys.Runs\n   (multithreaded_base.redT (final_thread.init_fin_final final)\n     (if_heap_read_typed final r typeof_addr P)\n     (map NormalAction \\<circ> convert_RA))\n   s'' \\<xi>'\n\ngoal (1 subgoal):\n 1. \\<And>sa s' tls tl.\n       \\<lbrakk>s' = sa; \\<xi> = LCons tl tls;\n        multithreaded_base.redT (final_thread.init_fin_final final)\n         (if_heap_read_typed final r typeof_addr P)\n         (map NormalAction \\<circ> convert_RA) sa tl s';\n        trsys.Runs\n         (multithreaded_base.redT (final_thread.init_fin_final final)\n           (if_heap_read_typed final r typeof_addr P)\n           (map NormalAction \\<circ> convert_RA))\n         s' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s' = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final) (multithreaded_base.init_fin final r)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>sa s' tls tl.\n                             s' = sa \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (multithreaded_base.init_fin final r)\n                              (map NormalAction \\<circ> convert_RA) sa tl\n                              s' \\<and>\n                             ((\\<exists>ttas.\n                                  multithreaded_base.RedT\n                                   (final_thread.init_fin_final final)\n                                   (if_heap_read_typed final r typeof_addr\n                                     P)\n                                   (map NormalAction \\<circ> convert_RA) s\n                                   ttas s' \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (if_heap_read_typed final r typeof_addr\n P)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s' tls) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (multithreaded_base.init_fin final r)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))", "from \\<open>?redT' s' tta s''\\<close>"], ["proof (chain)\npicking this:\n  multithreaded_base.redT (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s' tta s''", "have \"?redT s' tta s''\""], ["proof (prove)\nusing this:\n  multithreaded_base.redT (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s' tta s''\n\ngoal (1 subgoal):\n 1. multithreaded_base.redT (final_thread.init_fin_final final)\n     (multithreaded_base.init_fin final r)\n     (map NormalAction \\<circ> convert_RA) s' tta s''", "by(fastforce simp add: multithreaded_base.redT.simps)"], ["proof (state)\nthis:\n  multithreaded_base.redT (final_thread.init_fin_final final)\n   (multithreaded_base.init_fin final r)\n   (map NormalAction \\<circ> convert_RA) s' tta s''\n\ngoal (1 subgoal):\n 1. \\<And>sa s' tls tl.\n       \\<lbrakk>s' = sa; \\<xi> = LCons tl tls;\n        multithreaded_base.redT (final_thread.init_fin_final final)\n         (if_heap_read_typed final r typeof_addr P)\n         (map NormalAction \\<circ> convert_RA) sa tl s';\n        trsys.Runs\n         (multithreaded_base.redT (final_thread.init_fin_final final)\n           (if_heap_read_typed final r typeof_addr P)\n           (map NormalAction \\<circ> convert_RA))\n         s' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s' = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final) (multithreaded_base.init_fin final r)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>sa s' tls tl.\n                             s' = sa \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (multithreaded_base.init_fin final r)\n                              (map NormalAction \\<circ> convert_RA) sa tl\n                              s' \\<and>\n                             ((\\<exists>ttas.\n                                  multithreaded_base.RedT\n                                   (final_thread.init_fin_final final)\n                                   (if_heap_read_typed final r typeof_addr\n                                     P)\n                                   (map NormalAction \\<circ> convert_RA) s\n                                   ttas s' \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (if_heap_read_typed final r typeof_addr\n P)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s' tls) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (multithreaded_base.init_fin final r)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))", "moreover"], ["proof (state)\nthis:\n  multithreaded_base.redT (final_thread.init_fin_final final)\n   (multithreaded_base.init_fin final r)\n   (map NormalAction \\<circ> convert_RA) s' tta s''\n\ngoal (1 subgoal):\n 1. \\<And>sa s' tls tl.\n       \\<lbrakk>s' = sa; \\<xi> = LCons tl tls;\n        multithreaded_base.redT (final_thread.init_fin_final final)\n         (if_heap_read_typed final r typeof_addr P)\n         (map NormalAction \\<circ> convert_RA) sa tl s';\n        trsys.Runs\n         (multithreaded_base.redT (final_thread.init_fin_final final)\n           (if_heap_read_typed final r typeof_addr P)\n           (map NormalAction \\<circ> convert_RA))\n         s' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s' = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final) (multithreaded_base.init_fin final r)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>sa s' tls tl.\n                             s' = sa \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (multithreaded_base.init_fin final r)\n                              (map NormalAction \\<circ> convert_RA) sa tl\n                              s' \\<and>\n                             ((\\<exists>ttas.\n                                  multithreaded_base.RedT\n                                   (final_thread.init_fin_final final)\n                                   (if_heap_read_typed final r typeof_addr\n                                     P)\n                                   (map NormalAction \\<circ> convert_RA) s\n                                   ttas s' \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (if_heap_read_typed final r typeof_addr\n P)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s' tls) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (multithreaded_base.init_fin final r)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))", "from RedT' \\<open>?redT' s' tta s''\\<close>"], ["proof (chain)\npicking this:\n  multithreaded_base.RedT (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s ttas s'\n  multithreaded_base.redT (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s' tta s''", "have \"?RedT' s (ttas @ [tta]) s''\""], ["proof (prove)\nusing this:\n  multithreaded_base.RedT (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s ttas s'\n  multithreaded_base.redT (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s' tta s''\n\ngoal (1 subgoal):\n 1. multithreaded_base.RedT (final_thread.init_fin_final final)\n     (if_heap_read_typed final r typeof_addr P)\n     (map NormalAction \\<circ> convert_RA) s (ttas @ [tta]) s''", "unfolding multithreaded_base.RedT_def"], ["proof (prove)\nusing this:\n  rtrancl3p\n   (multithreaded_base.redT (final_thread.init_fin_final final)\n     (if_heap_read_typed final r typeof_addr P)\n     (map NormalAction \\<circ> convert_RA))\n   s ttas s'\n  multithreaded_base.redT (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s' tta s''\n\ngoal (1 subgoal):\n 1. rtrancl3p\n     (multithreaded_base.redT (final_thread.init_fin_final final)\n       (if_heap_read_typed final r typeof_addr P)\n       (map NormalAction \\<circ> convert_RA))\n     s (ttas @ [tta]) s''", "by(rule rtrancl3p_step)"], ["proof (state)\nthis:\n  multithreaded_base.RedT (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s (ttas @ [tta]) s''\n\ngoal (1 subgoal):\n 1. \\<And>sa s' tls tl.\n       \\<lbrakk>s' = sa; \\<xi> = LCons tl tls;\n        multithreaded_base.redT (final_thread.init_fin_final final)\n         (if_heap_read_typed final r typeof_addr P)\n         (map NormalAction \\<circ> convert_RA) sa tl s';\n        trsys.Runs\n         (multithreaded_base.redT (final_thread.init_fin_final final)\n           (if_heap_read_typed final r typeof_addr P)\n           (map NormalAction \\<circ> convert_RA))\n         s' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s' = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final) (multithreaded_base.init_fin final r)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>sa s' tls tl.\n                             s' = sa \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (multithreaded_base.init_fin final r)\n                              (map NormalAction \\<circ> convert_RA) sa tl\n                              s' \\<and>\n                             ((\\<exists>ttas.\n                                  multithreaded_base.RedT\n                                   (final_thread.init_fin_final final)\n                                   (if_heap_read_typed final r typeof_addr\n                                     P)\n                                   (map NormalAction \\<circ> convert_RA) s\n                                   ttas s' \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (if_heap_read_typed final r typeof_addr\n P)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s' tls) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (multithreaded_base.init_fin final r)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))", "ultimately"], ["proof (chain)\npicking this:\n  multithreaded_base.redT (final_thread.init_fin_final final)\n   (multithreaded_base.init_fin final r)\n   (map NormalAction \\<circ> convert_RA) s' tta s''\n  multithreaded_base.RedT (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s (ttas @ [tta]) s''", "have ?Step"], ["proof (prove)\nusing this:\n  multithreaded_base.redT (final_thread.init_fin_final final)\n   (multithreaded_base.init_fin final r)\n   (map NormalAction \\<circ> convert_RA) s' tta s''\n  multithreaded_base.RedT (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s (ttas @ [tta]) s''\n\ngoal (1 subgoal):\n 1. \\<exists>sa s' tls tl.\n       s' = sa \\<and>\n       \\<xi> = LCons tl tls \\<and>\n       multithreaded_base.redT (final_thread.init_fin_final final)\n        (multithreaded_base.init_fin final r)\n        (map NormalAction \\<circ> convert_RA) sa tl s' \\<and>\n       ((\\<exists>ttas.\n            multithreaded_base.RedT (final_thread.init_fin_final final)\n             (if_heap_read_typed final r typeof_addr P)\n             (map NormalAction \\<circ> convert_RA) s ttas s' \\<and>\n            trsys.Runs\n             (multithreaded_base.redT (final_thread.init_fin_final final)\n               (if_heap_read_typed final r typeof_addr P)\n               (map NormalAction \\<circ> convert_RA))\n             s' tls) \\<or>\n        trsys.Runs\n         (multithreaded_base.redT (final_thread.init_fin_final final)\n           (multithreaded_base.init_fin final r)\n           (map NormalAction \\<circ> convert_RA))\n         s' tls)", "using \\<open>\\<xi> = LCons tta \\<xi>'\\<close> \\<open>?Runs' s'' \\<xi>'\\<close>"], ["proof (prove)\nusing this:\n  multithreaded_base.redT (final_thread.init_fin_final final)\n   (multithreaded_base.init_fin final r)\n   (map NormalAction \\<circ> convert_RA) s' tta s''\n  multithreaded_base.RedT (final_thread.init_fin_final final)\n   (if_heap_read_typed final r typeof_addr P)\n   (map NormalAction \\<circ> convert_RA) s (ttas @ [tta]) s''\n  \\<xi> = LCons tta \\<xi>'\n  trsys.Runs\n   (multithreaded_base.redT (final_thread.init_fin_final final)\n     (if_heap_read_typed final r typeof_addr P)\n     (map NormalAction \\<circ> convert_RA))\n   s'' \\<xi>'\n\ngoal (1 subgoal):\n 1. \\<exists>sa s' tls tl.\n       s' = sa \\<and>\n       \\<xi> = LCons tl tls \\<and>\n       multithreaded_base.redT (final_thread.init_fin_final final)\n        (multithreaded_base.init_fin final r)\n        (map NormalAction \\<circ> convert_RA) sa tl s' \\<and>\n       ((\\<exists>ttas.\n            multithreaded_base.RedT (final_thread.init_fin_final final)\n             (if_heap_read_typed final r typeof_addr P)\n             (map NormalAction \\<circ> convert_RA) s ttas s' \\<and>\n            trsys.Runs\n             (multithreaded_base.redT (final_thread.init_fin_final final)\n               (if_heap_read_typed final r typeof_addr P)\n               (map NormalAction \\<circ> convert_RA))\n             s' tls) \\<or>\n        trsys.Runs\n         (multithreaded_base.redT (final_thread.init_fin_final final)\n           (multithreaded_base.init_fin final r)\n           (map NormalAction \\<circ> convert_RA))\n         s' tls)", "by blast"], ["proof (state)\nthis:\n  \\<exists>sa s' tls tl.\n     s' = sa \\<and>\n     \\<xi> = LCons tl tls \\<and>\n     multithreaded_base.redT (final_thread.init_fin_final final)\n      (multithreaded_base.init_fin final r)\n      (map NormalAction \\<circ> convert_RA) sa tl s' \\<and>\n     ((\\<exists>ttas.\n          multithreaded_base.RedT (final_thread.init_fin_final final)\n           (if_heap_read_typed final r typeof_addr P)\n           (map NormalAction \\<circ> convert_RA) s ttas s' \\<and>\n          trsys.Runs\n           (multithreaded_base.redT (final_thread.init_fin_final final)\n             (if_heap_read_typed final r typeof_addr P)\n             (map NormalAction \\<circ> convert_RA))\n           s' tls) \\<or>\n      trsys.Runs\n       (multithreaded_base.redT (final_thread.init_fin_final final)\n         (multithreaded_base.init_fin final r)\n         (map NormalAction \\<circ> convert_RA))\n       s' tls)\n\ngoal (1 subgoal):\n 1. \\<And>sa s' tls tl.\n       \\<lbrakk>s' = sa; \\<xi> = LCons tl tls;\n        multithreaded_base.redT (final_thread.init_fin_final final)\n         (if_heap_read_typed final r typeof_addr P)\n         (map NormalAction \\<circ> convert_RA) sa tl s';\n        trsys.Runs\n         (multithreaded_base.redT (final_thread.init_fin_final final)\n           (if_heap_read_typed final r typeof_addr P)\n           (map NormalAction \\<circ> convert_RA))\n         s' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s' = s \\<and>\n                             \\<xi> = LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> multithreaded_base.redT\n   (final_thread.init_fin_final final) (multithreaded_base.init_fin final r)\n   (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n                         (\\<exists>sa s' tls tl.\n                             s' = sa \\<and>\n                             \\<xi> = LCons tl tls \\<and>\n                             multithreaded_base.redT\n                              (final_thread.init_fin_final final)\n                              (multithreaded_base.init_fin final r)\n                              (map NormalAction \\<circ> convert_RA) sa tl\n                              s' \\<and>\n                             ((\\<exists>ttas.\n                                  multithreaded_base.RedT\n                                   (final_thread.init_fin_final final)\n                                   (if_heap_read_typed final r typeof_addr\n                                     P)\n                                   (map NormalAction \\<circ> convert_RA) s\n                                   ttas s' \\<and>\n                                  trsys.Runs\n                                   (multithreaded_base.redT\n                                     (final_thread.init_fin_final final)\n                                     (if_heap_read_typed final r typeof_addr\n P)\n                                     (map NormalAction \\<circ> convert_RA))\n                                   s' tls) \\<or>\n                              trsys.Runs\n                               (multithreaded_base.redT\n                                 (final_thread.init_fin_final final)\n                                 (multithreaded_base.init_fin final r)\n                                 (map NormalAction \\<circ> convert_RA))\n                               s' tls))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>sa s' tls tl.\n     s' = sa \\<and>\n     \\<xi> = LCons tl tls \\<and>\n     multithreaded_base.redT (final_thread.init_fin_final final)\n      (multithreaded_base.init_fin final r)\n      (map NormalAction \\<circ> convert_RA) sa tl s' \\<and>\n     ((\\<exists>ttas.\n          multithreaded_base.RedT (final_thread.init_fin_final final)\n           (if_heap_read_typed final r typeof_addr P)\n           (map NormalAction \\<circ> convert_RA) s ttas s' \\<and>\n          trsys.Runs\n           (multithreaded_base.redT (final_thread.init_fin_final final)\n             (if_heap_read_typed final r typeof_addr P)\n             (map NormalAction \\<circ> convert_RA))\n           s' tls) \\<or>\n      trsys.Runs\n       (multithreaded_base.redT (final_thread.init_fin_final final)\n         (multithreaded_base.init_fin final r)\n         (map NormalAction \\<circ> convert_RA))\n       s' tls)\n\ngoal (1 subgoal):\n 1. (\\<exists>s.\n        s' = s \\<and>\n        \\<xi> = LNil \\<and>\n        (\\<forall>x xa.\n            \\<not> multithreaded_base.redT\n                    (final_thread.init_fin_final final)\n                    (multithreaded_base.init_fin final r)\n                    (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n    (\\<exists>sa s' tls tl.\n        s' = sa \\<and>\n        \\<xi> = LCons tl tls \\<and>\n        multithreaded_base.redT (final_thread.init_fin_final final)\n         (multithreaded_base.init_fin final r)\n         (map NormalAction \\<circ> convert_RA) sa tl s' \\<and>\n        ((\\<exists>ttas.\n             multithreaded_base.RedT (final_thread.init_fin_final final)\n              (if_heap_read_typed final r typeof_addr P)\n              (map NormalAction \\<circ> convert_RA) s ttas s' \\<and>\n             trsys.Runs\n              (multithreaded_base.redT (final_thread.init_fin_final final)\n                (if_heap_read_typed final r typeof_addr P)\n                (map NormalAction \\<circ> convert_RA))\n              s' tls) \\<or>\n         trsys.Runs\n          (multithreaded_base.redT (final_thread.init_fin_final final)\n            (multithreaded_base.init_fin final r)\n            (map NormalAction \\<circ> convert_RA))\n          s' tls))", "by(rule disjI2)"], ["proof (state)\nthis:\n  (\\<exists>s.\n      s' = s \\<and>\n      \\<xi> = LNil \\<and>\n      (\\<forall>x xa.\n          \\<not> multithreaded_base.redT (final_thread.init_fin_final final)\n                  (multithreaded_base.init_fin final r)\n                  (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n  (\\<exists>sa s' tls tl.\n      s' = sa \\<and>\n      \\<xi> = LCons tl tls \\<and>\n      multithreaded_base.redT (final_thread.init_fin_final final)\n       (multithreaded_base.init_fin final r)\n       (map NormalAction \\<circ> convert_RA) sa tl s' \\<and>\n      ((\\<exists>ttas.\n           multithreaded_base.RedT (final_thread.init_fin_final final)\n            (if_heap_read_typed final r typeof_addr P)\n            (map NormalAction \\<circ> convert_RA) s ttas s' \\<and>\n           trsys.Runs\n            (multithreaded_base.redT (final_thread.init_fin_final final)\n              (if_heap_read_typed final r typeof_addr P)\n              (map NormalAction \\<circ> convert_RA))\n            s' tls) \\<or>\n       trsys.Runs\n        (multithreaded_base.redT (final_thread.init_fin_final final)\n          (multithreaded_base.init_fin final r)\n          (map NormalAction \\<circ> convert_RA))\n        s' tls))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>s.\n      s' = s \\<and>\n      \\<xi> = LNil \\<and>\n      (\\<forall>x xa.\n          \\<not> multithreaded_base.redT (final_thread.init_fin_final final)\n                  (multithreaded_base.init_fin final r)\n                  (map NormalAction \\<circ> convert_RA) s x xa)) \\<or>\n  (\\<exists>sa s' tls tl.\n      s' = sa \\<and>\n      \\<xi> = LCons tl tls \\<and>\n      multithreaded_base.redT (final_thread.init_fin_final final)\n       (multithreaded_base.init_fin final r)\n       (map NormalAction \\<circ> convert_RA) sa tl s' \\<and>\n      ((\\<exists>ttas.\n           multithreaded_base.RedT (final_thread.init_fin_final final)\n            (if_heap_read_typed final r typeof_addr P)\n            (map NormalAction \\<circ> convert_RA) s ttas s' \\<and>\n           trsys.Runs\n            (multithreaded_base.redT (final_thread.init_fin_final final)\n              (if_heap_read_typed final r typeof_addr P)\n              (map NormalAction \\<circ> convert_RA))\n            s' tls) \\<or>\n       trsys.Runs\n        (multithreaded_base.redT (final_thread.init_fin_final final)\n          (multithreaded_base.init_fin final r)\n          (map NormalAction \\<circ> convert_RA))\n        s' tls))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trsys.Runs\n   (multithreaded_base.redT (final_thread.init_fin_final final)\n     (multithreaded_base.init_fin final r)\n     (map NormalAction \\<circ> convert_RA))\n   s' \\<xi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma heap_copy_loc_heap_read_typed:\n  \"heap_base.heap_copy_loc (heap_base.heap_read_typed (\\<lambda>_ :: 'heap. typeof_addr) heap_read P) heap_write a a' al h obs h' \\<longleftrightarrow>\n  heap_base.heap_copy_loc heap_read heap_write a a' al h obs h' \\<and>\n  (\\<forall>ad al v T. ReadMem ad al v \\<in> set obs \\<longrightarrow> heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow> heap_base'.conf TYPE('heap) typeof_addr P v T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_base.heap_copy_loc\n     (heap_base.heap_read_typed (\\<lambda>_. typeof_addr) heap_read P)\n     heap_write a a' al h obs h' =\n    (heap_base.heap_copy_loc heap_read heap_write a a' al h obs h' \\<and>\n     (\\<forall>ad al v T.\n         ReadMem ad al v \\<in> set obs \\<longrightarrow>\n         heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n          T \\<longrightarrow>\n         heap_base'.conf TYPE('heap) typeof_addr P v T))", "by(auto elim!: heap_base.heap_copy_loc.cases intro!: heap_base.heap_copy_loc.intros dest: heap_base.heap_read_typed_into_heap_read heap_base.heap_read_typed_typed intro: heap_base.heap_read_typedI simp add: heap_base'.addr_loc_type_conv_addr_loc_type heap_base'.conf_conv_conf)"], ["", "lemma heap_copies_heap_read_typed:\n  \"heap_base.heap_copies (heap_base.heap_read_typed (\\<lambda>_ :: 'heap. typeof_addr) heap_read P) heap_write a a' als h obs h' \\<longleftrightarrow>\n  heap_base.heap_copies heap_read heap_write a a' als h obs h' \\<and>\n  (\\<forall>ad al v T. ReadMem ad al v \\<in> set obs \\<longrightarrow> heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow> heap_base'.conf TYPE('heap) typeof_addr P v T)\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_base.heap_copies\n     (heap_base.heap_read_typed (\\<lambda>_. typeof_addr) heap_read P)\n     heap_write a a' als h obs h' =\n    (heap_base.heap_copies heap_read heap_write a a' als h obs h' \\<and>\n     (\\<forall>ad al v T.\n         ReadMem ad al v \\<in> set obs \\<longrightarrow>\n         heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n          T \\<longrightarrow>\n         heap_base'.conf TYPE('heap) typeof_addr P v T))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. heap_base.heap_copies\n     (heap_base.heap_read_typed (\\<lambda>_. typeof_addr) heap_read P)\n     heap_write a a' als h obs h' \\<Longrightarrow>\n    heap_base.heap_copies heap_read heap_write a a' als h obs h' \\<and>\n    (\\<forall>ad al v T.\n        ReadMem ad al v \\<in> set obs \\<longrightarrow>\n        heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n         T \\<longrightarrow>\n        heap_base'.conf TYPE('heap) typeof_addr P v T)\n 2. heap_base.heap_copies heap_read heap_write a a' als h obs h' \\<and>\n    (\\<forall>ad al v T.\n        ReadMem ad al v \\<in> set obs \\<longrightarrow>\n        heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n         T \\<longrightarrow>\n        heap_base'.conf TYPE('heap) typeof_addr P v T) \\<Longrightarrow>\n    heap_base.heap_copies\n     (heap_base.heap_read_typed (\\<lambda>_. typeof_addr) heap_read P)\n     heap_write a a' als h obs h'", "assume ?lhs"], ["proof (state)\nthis:\n  heap_base.heap_copies\n   (heap_base.heap_read_typed (\\<lambda>_. typeof_addr) heap_read P)\n   heap_write a a' als h obs h'\n\ngoal (2 subgoals):\n 1. heap_base.heap_copies\n     (heap_base.heap_read_typed (\\<lambda>_. typeof_addr) heap_read P)\n     heap_write a a' als h obs h' \\<Longrightarrow>\n    heap_base.heap_copies heap_read heap_write a a' als h obs h' \\<and>\n    (\\<forall>ad al v T.\n        ReadMem ad al v \\<in> set obs \\<longrightarrow>\n        heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n         T \\<longrightarrow>\n        heap_base'.conf TYPE('heap) typeof_addr P v T)\n 2. heap_base.heap_copies heap_read heap_write a a' als h obs h' \\<and>\n    (\\<forall>ad al v T.\n        ReadMem ad al v \\<in> set obs \\<longrightarrow>\n        heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n         T \\<longrightarrow>\n        heap_base'.conf TYPE('heap) typeof_addr P v T) \\<Longrightarrow>\n    heap_base.heap_copies\n     (heap_base.heap_read_typed (\\<lambda>_. typeof_addr) heap_read P)\n     heap_write a a' als h obs h'", "thus ?rhs"], ["proof (prove)\nusing this:\n  heap_base.heap_copies\n   (heap_base.heap_read_typed (\\<lambda>_. typeof_addr) heap_read P)\n   heap_write a a' als h obs h'\n\ngoal (1 subgoal):\n 1. heap_base.heap_copies heap_read heap_write a a' als h obs h' \\<and>\n    (\\<forall>ad al v T.\n        ReadMem ad al v \\<in> set obs \\<longrightarrow>\n        heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n         T \\<longrightarrow>\n        heap_base'.conf TYPE('heap) typeof_addr P v T)", "by(induct rule: heap_base.heap_copies.induct[consumes 1])(auto intro!: heap_base.heap_copies.intros simp add: heap_copy_loc_heap_read_typed)"], ["proof (state)\nthis:\n  heap_base.heap_copies heap_read heap_write a a' als h obs h' \\<and>\n  (\\<forall>ad al v T.\n      ReadMem ad al v \\<in> set obs \\<longrightarrow>\n      heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n       T \\<longrightarrow>\n      heap_base'.conf TYPE('heap) typeof_addr P v T)\n\ngoal (1 subgoal):\n 1. heap_base.heap_copies heap_read heap_write a a' als h obs h' \\<and>\n    (\\<forall>ad al v T.\n        ReadMem ad al v \\<in> set obs \\<longrightarrow>\n        heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n         T \\<longrightarrow>\n        heap_base'.conf TYPE('heap) typeof_addr P v T) \\<Longrightarrow>\n    heap_base.heap_copies\n     (heap_base.heap_read_typed (\\<lambda>_. typeof_addr) heap_read P)\n     heap_write a a' als h obs h'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. heap_base.heap_copies heap_read heap_write a a' als h obs h' \\<and>\n    (\\<forall>ad al v T.\n        ReadMem ad al v \\<in> set obs \\<longrightarrow>\n        heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n         T \\<longrightarrow>\n        heap_base'.conf TYPE('heap) typeof_addr P v T) \\<Longrightarrow>\n    heap_base.heap_copies\n     (heap_base.heap_read_typed (\\<lambda>_. typeof_addr) heap_read P)\n     heap_write a a' als h obs h'", "assume ?rhs"], ["proof (state)\nthis:\n  heap_base.heap_copies heap_read heap_write a a' als h obs h' \\<and>\n  (\\<forall>ad al v T.\n      ReadMem ad al v \\<in> set obs \\<longrightarrow>\n      heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n       T \\<longrightarrow>\n      heap_base'.conf TYPE('heap) typeof_addr P v T)\n\ngoal (1 subgoal):\n 1. heap_base.heap_copies heap_read heap_write a a' als h obs h' \\<and>\n    (\\<forall>ad al v T.\n        ReadMem ad al v \\<in> set obs \\<longrightarrow>\n        heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n         T \\<longrightarrow>\n        heap_base'.conf TYPE('heap) typeof_addr P v T) \\<Longrightarrow>\n    heap_base.heap_copies\n     (heap_base.heap_read_typed (\\<lambda>_. typeof_addr) heap_read P)\n     heap_write a a' als h obs h'", "thus ?lhs"], ["proof (prove)\nusing this:\n  heap_base.heap_copies heap_read heap_write a a' als h obs h' \\<and>\n  (\\<forall>ad al v T.\n      ReadMem ad al v \\<in> set obs \\<longrightarrow>\n      heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n       T \\<longrightarrow>\n      heap_base'.conf TYPE('heap) typeof_addr P v T)\n\ngoal (1 subgoal):\n 1. heap_base.heap_copies\n     (heap_base.heap_read_typed (\\<lambda>_. typeof_addr) heap_read P)\n     heap_write a a' als h obs h'", "by(rule conjE)(induct rule: heap_base.heap_copies.induct[consumes 1], auto intro!: heap_base.heap_copies.intros simp add: heap_copy_loc_heap_read_typed)"], ["proof (state)\nthis:\n  heap_base.heap_copies\n   (heap_base.heap_read_typed (\\<lambda>_. typeof_addr) heap_read P)\n   heap_write a a' als h obs h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma heap_clone_heap_read_typed:\n  \"heap_base.heap_clone allocate (\\<lambda>_ :: 'heap. typeof_addr) (heap_base.heap_read_typed (\\<lambda>_ :: 'heap. typeof_addr) heap_read P) heap_write P a h h' obs \\<longleftrightarrow>\n  heap_base.heap_clone allocate (\\<lambda>_ :: 'heap. typeof_addr) heap_read heap_write P a h h' obs \\<and>\n  (\\<forall>ad al v T obs' a'. obs = \\<lfloor>(obs', a')\\<rfloor> \\<longrightarrow> ReadMem ad al v \\<in> set obs' \\<longrightarrow> heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow> heap_base'.conf TYPE('heap) typeof_addr P v T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_base.heap_clone allocate (\\<lambda>_. typeof_addr)\n     (heap_base.heap_read_typed (\\<lambda>_. typeof_addr) heap_read P)\n     heap_write P a h h' obs =\n    (heap_base.heap_clone allocate (\\<lambda>_. typeof_addr) heap_read\n      heap_write P a h h' obs \\<and>\n     (\\<forall>ad al v T obs' a'.\n         obs = \\<lfloor>(obs', a')\\<rfloor> \\<longrightarrow>\n         ReadMem ad al v \\<in> set obs' \\<longrightarrow>\n         heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n          T \\<longrightarrow>\n         heap_base'.conf TYPE('heap) typeof_addr P v T))", "by(auto elim!: heap_base.heap_clone.cases intro: heap_base.heap_clone.intros simp add: heap_copies_heap_read_typed)"], ["", "lemma red_external_heap_read_typed:\n  \"heap_base.red_external addr2thread_id thread_id2addr spurious_wakeups empty_heap allocate (\\<lambda>_ :: 'heap. typeof_addr) (heap_base.heap_read_typed (\\<lambda>_ :: 'heap. typeof_addr) heap_read P) heap_write P t h a M vs ta va h' \\<longleftrightarrow>\n   heap_base.red_external addr2thread_id thread_id2addr spurious_wakeups empty_heap allocate (\\<lambda>_ :: 'heap. typeof_addr) heap_read heap_write P t h a M vs ta va h' \\<and>\n  (\\<forall>ad al v T obs' a'. ReadMem ad al v \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<longrightarrow> heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow> heap_base'.conf TYPE('heap) typeof_addr P v T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_base.red_external (\\<lambda>x. x) (\\<lambda>x. x) spurious_wakeups\n     empty_heap allocate (\\<lambda>_. typeof_addr)\n     (heap_base.heap_read_typed (\\<lambda>_. typeof_addr) heap_read P)\n     heap_write P t h a M vs ta va h' =\n    (heap_base.red_external (\\<lambda>x. x) (\\<lambda>x. x) spurious_wakeups\n      empty_heap allocate (\\<lambda>_. typeof_addr) heap_read heap_write P t\n      h a M vs ta va h' \\<and>\n     (\\<forall>ad al v T obs' a'.\n         ReadMem ad al v\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<longrightarrow>\n         heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n          T \\<longrightarrow>\n         heap_base'.conf TYPE('heap) typeof_addr P v T))", "by(auto elim!: heap_base.red_external.cases intro: heap_base.red_external.intros simp add: heap_clone_heap_read_typed)"], ["", "lemma red_external_aggr_heap_read_typed:\n  \"(ta, va, h') \\<in> heap_base.red_external_aggr addr2thread_id thread_id2addr spurious_wakeups empty_heap allocate (\\<lambda>_ :: 'heap. typeof_addr) (heap_base.heap_read_typed (\\<lambda>_ :: 'heap. typeof_addr) heap_read P) heap_write P t h a M vs \\<longleftrightarrow>\n   (ta, va, h') \\<in> heap_base.red_external_aggr addr2thread_id thread_id2addr spurious_wakeups empty_heap allocate (\\<lambda>_ :: 'heap. typeof_addr) heap_read heap_write P t h a M vs \\<and>\n  (\\<forall>ad al v T obs' a'. ReadMem ad al v \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<longrightarrow> heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al T \\<longrightarrow> heap_base'.conf TYPE('heap) typeof_addr P v T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((ta, va, h')\n     \\<in> heap_base.red_external_aggr (\\<lambda>x. x) (\\<lambda>x. x)\n            spurious_wakeups empty_heap allocate (\\<lambda>_. typeof_addr)\n            (heap_base.heap_read_typed (\\<lambda>_. typeof_addr) heap_read\n              P)\n            heap_write P t h a M vs) =\n    ((ta, va, h')\n     \\<in> heap_base.red_external_aggr (\\<lambda>x. x) (\\<lambda>x. x)\n            spurious_wakeups empty_heap allocate (\\<lambda>_. typeof_addr)\n            heap_read heap_write P t h a M vs \\<and>\n     (\\<forall>ad al v T obs' a'.\n         ReadMem ad al v\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<longrightarrow>\n         heap_base'.addr_loc_type TYPE('heap) typeof_addr P ad al\n          T \\<longrightarrow>\n         heap_base'.conf TYPE('heap) typeof_addr P v T))", "by(auto simp add: heap_base.red_external_aggr_def heap_clone_heap_read_typed split del: if_split split: if_split_asm)"], ["", "lemma jmm'_heap_copy_locI: \n  \"\\<exists>obs h'. heap_base.heap_copy_loc (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write a a' al h obs h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>obs h'.\n       heap_base.heap_copy_loc\n        (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n        jmm_heap_write a a' al h obs h'", "by(auto intro!: heap_base.heap_copy_loc.intros jmm_heap_read_typed_default_val intro: jmm_heap_write.intros)"], ["", "lemma jmm'_heap_copiesI:\n  \"\\<exists>obs :: (addr, 'thread_id) obs_event list.\n   \\<exists>h'. heap_base.heap_copies (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write a a' als h obs h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>obs h'.\n       heap_base.heap_copies\n        (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n        jmm_heap_write a a' als h obs h'", "proof(induction als arbitrary: h)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h.\n       \\<exists>obs.\n          Ex (heap_base.heap_copies\n               (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n               jmm_heap_write a a' [] h obs)\n 2. \\<And>aa als h.\n       (\\<And>h.\n           \\<exists>obs.\n              Ex (heap_base.heap_copies\n                   (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n                   jmm_heap_write a a' als h obs)) \\<Longrightarrow>\n       \\<exists>obs.\n          Ex (heap_base.heap_copies\n               (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n               jmm_heap_write a a' (aa # als) h obs)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>h.\n       \\<exists>obs.\n          Ex (heap_base.heap_copies\n               (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n               jmm_heap_write a a' [] h obs)\n 2. \\<And>aa als h.\n       (\\<And>h.\n           \\<exists>obs.\n              Ex (heap_base.heap_copies\n                   (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n                   jmm_heap_write a a' als h obs)) \\<Longrightarrow>\n       \\<exists>obs.\n          Ex (heap_base.heap_copies\n               (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n               jmm_heap_write a a' (aa # als) h obs)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>obs b.\n       heap_base.heap_copies\n        (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n        jmm_heap_write a a' [] h obs b", "by(blast intro: heap_base.heap_copies.intros)"], ["proof (state)\nthis:\n  \\<exists>obs b.\n     heap_base.heap_copies\n      (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write\n      a a' [] h obs b\n\ngoal (1 subgoal):\n 1. \\<And>aa als h.\n       (\\<And>h.\n           \\<exists>obs.\n              Ex (heap_base.heap_copies\n                   (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n                   jmm_heap_write a a' als h obs)) \\<Longrightarrow>\n       \\<exists>obs.\n          Ex (heap_base.heap_copies\n               (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n               jmm_heap_write a a' (aa # als) h obs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa als h.\n       (\\<And>h.\n           \\<exists>obs.\n              Ex (heap_base.heap_copies\n                   (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n                   jmm_heap_write a a' als h obs)) \\<Longrightarrow>\n       \\<exists>obs.\n          Ex (heap_base.heap_copies\n               (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n               jmm_heap_write a a' (aa # als) h obs)", "case (Cons al als)"], ["proof (state)\nthis:\n  \\<exists>obs b.\n     heap_base.heap_copies\n      (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write\n      a a' als ?h obs b\n\ngoal (1 subgoal):\n 1. \\<And>aa als h.\n       (\\<And>h.\n           \\<exists>obs.\n              Ex (heap_base.heap_copies\n                   (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n                   jmm_heap_write a a' als h obs)) \\<Longrightarrow>\n       \\<exists>obs.\n          Ex (heap_base.heap_copies\n               (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n               jmm_heap_write a a' (aa # als) h obs)", "from jmm'_heap_copy_locI[of typeof_addr P a a' al h]"], ["proof (chain)\npicking this:\n  \\<exists>obs h'.\n     heap_base.heap_copy_loc\n      (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write\n      a a' al h obs h'", "obtain ob :: \"(addr, 'thread_id) obs_event list\" and h'\n    where \"heap_base.heap_copy_loc (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write a a' al h ob h'\""], ["proof (prove)\nusing this:\n  \\<exists>obs h'.\n     heap_base.heap_copy_loc\n      (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write\n      a a' al h obs h'\n\ngoal (1 subgoal):\n 1. (\\<And>ob h'.\n        heap_base.heap_copy_loc\n         (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n         jmm_heap_write a a' al h ob h' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  heap_base.heap_copy_loc\n   (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write a\n   a' al h ob h'\n\ngoal (1 subgoal):\n 1. \\<And>aa als h.\n       (\\<And>h.\n           \\<exists>obs.\n              Ex (heap_base.heap_copies\n                   (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n                   jmm_heap_write a a' als h obs)) \\<Longrightarrow>\n       \\<exists>obs.\n          Ex (heap_base.heap_copies\n               (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n               jmm_heap_write a a' (aa # als) h obs)", "with Cons.IH[of h']"], ["proof (chain)\npicking this:\n  \\<exists>obs b.\n     heap_base.heap_copies\n      (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write\n      a a' als h' obs b\n  heap_base.heap_copy_loc\n   (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write a\n   a' al h ob h'", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>obs b.\n     heap_base.heap_copies\n      (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write\n      a a' als h' obs b\n  heap_base.heap_copy_loc\n   (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write a\n   a' al h ob h'\n\ngoal (1 subgoal):\n 1. \\<exists>obs b.\n       heap_base.heap_copies\n        (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n        jmm_heap_write a a' (al # als) h obs b", "by(auto 4 4 intro: heap_base.heap_copies.intros)"], ["proof (state)\nthis:\n  \\<exists>obs b.\n     heap_base.heap_copies\n      (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write\n      a a' (al # als) h obs b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jmm'_heap_cloneI:\n  fixes obsa :: \"((addr, 'thread_id) obs_event list \\<times> addr) option\"\n  assumes \"heap_base.heap_clone allocate typeof_addr jmm_heap_read jmm_heap_write P h a h' obsa\"\n  shows \"\\<exists>h'. \\<exists>obsa :: ((addr, 'thread_id) obs_event list \\<times> addr) option. \n       heap_base.heap_clone allocate typeof_addr (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write P h a h' obsa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>h' obsa.\n       heap_base.heap_clone allocate typeof_addr\n        (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n        jmm_heap_write P h a h' obsa", "using assms"], ["proof (prove)\nusing this:\n  heap_base.heap_clone allocate typeof_addr jmm_heap_read jmm_heap_write P h\n   a h' obsa\n\ngoal (1 subgoal):\n 1. \\<exists>h' obsa.\n       heap_base.heap_clone allocate typeof_addr\n        (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n        jmm_heap_write P h a h' obsa", "proof(cases rule: heap_base.heap_clone.cases[consumes 1, case_names Fail Obj Arr])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>hT.\n       \\<lbrakk>h' = h; obsa = None; typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        allocate h hT = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' obsa.\n                            heap_base.heap_clone allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P h a h' obsa\n 2. \\<And>C h'a a' FDTs obs h''.\n       \\<lbrakk>h' = h'';\n        obsa = \\<lfloor>(NewHeapElem a' (Class_type C) # obs, a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_base.heap_copies jmm_heap_read jmm_heap_write a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a obs\n         h''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' obsa.\n                            heap_base.heap_clone allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P h a h' obsa\n 3. \\<And>T n h'a a' FDTs obs h''.\n       \\<lbrakk>h' = h'';\n        obsa =\n        \\<lfloor>(NewHeapElem a' (Array_type T n) # obs, a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_base.heap_copies jmm_heap_read jmm_heap_write a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' obsa.\n                            heap_base.heap_clone allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P h a h' obsa", "case Fail"], ["proof (state)\nthis:\n  h' = h\n  obsa = None\n  typeof_addr h a = \\<lfloor>hT_\\<rfloor>\n  allocate h hT_ = {}\n\ngoal (3 subgoals):\n 1. \\<And>hT.\n       \\<lbrakk>h' = h; obsa = None; typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        allocate h hT = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' obsa.\n                            heap_base.heap_clone allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P h a h' obsa\n 2. \\<And>C h'a a' FDTs obs h''.\n       \\<lbrakk>h' = h'';\n        obsa = \\<lfloor>(NewHeapElem a' (Class_type C) # obs, a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_base.heap_copies jmm_heap_read jmm_heap_write a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a obs\n         h''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' obsa.\n                            heap_base.heap_clone allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P h a h' obsa\n 3. \\<And>T n h'a a' FDTs obs h''.\n       \\<lbrakk>h' = h'';\n        obsa =\n        \\<lfloor>(NewHeapElem a' (Array_type T n) # obs, a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_base.heap_copies jmm_heap_read jmm_heap_write a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' obsa.\n                            heap_base.heap_clone allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P h a h' obsa", "thus ?thesis"], ["proof (prove)\nusing this:\n  h' = h\n  obsa = None\n  typeof_addr h a = \\<lfloor>hT_\\<rfloor>\n  allocate h hT_ = {}\n\ngoal (1 subgoal):\n 1. \\<exists>h' obsa.\n       heap_base.heap_clone allocate typeof_addr\n        (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n        jmm_heap_write P h a h' obsa", "by(blast intro: heap_base.heap_clone.intros)"], ["proof (state)\nthis:\n  \\<exists>h' obsa.\n     heap_base.heap_clone allocate typeof_addr\n      (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write\n      P h a h' obsa\n\ngoal (2 subgoals):\n 1. \\<And>C h'a a' FDTs obs h''.\n       \\<lbrakk>h' = h'';\n        obsa = \\<lfloor>(NewHeapElem a' (Class_type C) # obs, a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_base.heap_copies jmm_heap_read jmm_heap_write a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a obs\n         h''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' obsa.\n                            heap_base.heap_clone allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P h a h' obsa\n 2. \\<And>T n h'a a' FDTs obs h''.\n       \\<lbrakk>h' = h'';\n        obsa =\n        \\<lfloor>(NewHeapElem a' (Array_type T n) # obs, a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_base.heap_copies jmm_heap_read jmm_heap_write a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' obsa.\n                            heap_base.heap_clone allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P h a h' obsa", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C h'a a' FDTs obs h''.\n       \\<lbrakk>h' = h'';\n        obsa = \\<lfloor>(NewHeapElem a' (Class_type C) # obs, a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_base.heap_copies jmm_heap_read jmm_heap_write a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a obs\n         h''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' obsa.\n                            heap_base.heap_clone allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P h a h' obsa\n 2. \\<And>T n h'a a' FDTs obs h''.\n       \\<lbrakk>h' = h'';\n        obsa =\n        \\<lfloor>(NewHeapElem a' (Array_type T n) # obs, a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_base.heap_copies jmm_heap_read jmm_heap_write a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' obsa.\n                            heap_base.heap_clone allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P h a h' obsa", "case (Obj C h' a' FDTs obs h'')"], ["proof (state)\nthis:\n  h' = h''\n  obsa = \\<lfloor>(NewHeapElem a' (Class_type C) # obs, a')\\<rfloor>\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  (h', a') \\<in> allocate h (Class_type C)\n  P \\<turnstile> C has_fields FDTs\n  heap_base.heap_copies jmm_heap_read jmm_heap_write a a'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h' obs h''\n\ngoal (2 subgoals):\n 1. \\<And>C h'a a' FDTs obs h''.\n       \\<lbrakk>h' = h'';\n        obsa = \\<lfloor>(NewHeapElem a' (Class_type C) # obs, a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_base.heap_copies jmm_heap_read jmm_heap_write a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a obs\n         h''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' obsa.\n                            heap_base.heap_clone allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P h a h' obsa\n 2. \\<And>T n h'a a' FDTs obs h''.\n       \\<lbrakk>h' = h'';\n        obsa =\n        \\<lfloor>(NewHeapElem a' (Array_type T n) # obs, a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_base.heap_copies jmm_heap_read jmm_heap_write a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' obsa.\n                            heap_base.heap_clone allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P h a h' obsa", "with jmm'_heap_copiesI[of typeof_addr P a a' \"map (\\<lambda>((F, D), Tfm). CField D F) FDTs\" h']"], ["proof (chain)\npicking this:\n  \\<exists>obs h'.\n     heap_base.heap_copies\n      (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write\n      a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h' obs h'\n  h' = h''\n  obsa = \\<lfloor>(NewHeapElem a' (Class_type C) # obs, a')\\<rfloor>\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  (h', a') \\<in> allocate h (Class_type C)\n  P \\<turnstile> C has_fields FDTs\n  heap_base.heap_copies jmm_heap_read jmm_heap_write a a'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h' obs h''", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>obs h'.\n     heap_base.heap_copies\n      (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write\n      a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h' obs h'\n  h' = h''\n  obsa = \\<lfloor>(NewHeapElem a' (Class_type C) # obs, a')\\<rfloor>\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  (h', a') \\<in> allocate h (Class_type C)\n  P \\<turnstile> C has_fields FDTs\n  heap_base.heap_copies jmm_heap_read jmm_heap_write a a'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h' obs h''\n\ngoal (1 subgoal):\n 1. \\<exists>h' obsa.\n       heap_base.heap_clone allocate typeof_addr\n        (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n        jmm_heap_write P h a h' obsa", "by(blast intro: heap_base.heap_clone.intros)"], ["proof (state)\nthis:\n  \\<exists>h' obsa.\n     heap_base.heap_clone allocate typeof_addr\n      (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write\n      P h a h' obsa\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a a' FDTs obs h''.\n       \\<lbrakk>h' = h'';\n        obsa =\n        \\<lfloor>(NewHeapElem a' (Array_type T n) # obs, a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_base.heap_copies jmm_heap_read jmm_heap_write a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' obsa.\n                            heap_base.heap_clone allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P h a h' obsa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T n h'a a' FDTs obs h''.\n       \\<lbrakk>h' = h'';\n        obsa =\n        \\<lfloor>(NewHeapElem a' (Array_type T n) # obs, a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_base.heap_copies jmm_heap_read jmm_heap_write a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' obsa.\n                            heap_base.heap_clone allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P h a h' obsa", "case (Arr T n h' a' FDTs obs h'')"], ["proof (state)\nthis:\n  h' = h''\n  obsa = \\<lfloor>(NewHeapElem a' (Array_type T n) # obs, a')\\<rfloor>\n  typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>\n  (h', a') \\<in> allocate h (Array_type T n)\n  P \\<turnstile> Object has_fields FDTs\n  heap_base.heap_copies jmm_heap_read jmm_heap_write a a'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) h'\n   obs h''\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a a' FDTs obs h''.\n       \\<lbrakk>h' = h'';\n        obsa =\n        \\<lfloor>(NewHeapElem a' (Array_type T n) # obs, a')\\<rfloor>;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_base.heap_copies jmm_heap_read jmm_heap_write a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obs h''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' obsa.\n                            heap_base.heap_clone allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P h a h' obsa", "with jmm'_heap_copiesI[of typeof_addr P a a' \"map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]\"]"], ["proof (chain)\npicking this:\n  \\<exists>obs h'.\n     heap_base.heap_copies\n      (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write\n      a a'\n      (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) ?h\n      obs h'\n  h' = h''\n  obsa = \\<lfloor>(NewHeapElem a' (Array_type T n) # obs, a')\\<rfloor>\n  typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>\n  (h', a') \\<in> allocate h (Array_type T n)\n  P \\<turnstile> Object has_fields FDTs\n  heap_base.heap_copies jmm_heap_read jmm_heap_write a a'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) h'\n   obs h''", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>obs h'.\n     heap_base.heap_copies\n      (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write\n      a a'\n      (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) ?h\n      obs h'\n  h' = h''\n  obsa = \\<lfloor>(NewHeapElem a' (Array_type T n) # obs, a')\\<rfloor>\n  typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>\n  (h', a') \\<in> allocate h (Array_type T n)\n  P \\<turnstile> Object has_fields FDTs\n  heap_base.heap_copies jmm_heap_read jmm_heap_write a a'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) h'\n   obs h''\n\ngoal (1 subgoal):\n 1. \\<exists>h' obsa.\n       heap_base.heap_clone allocate typeof_addr\n        (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n        jmm_heap_write P h a h' obsa", "by(blast intro: heap_base.heap_clone.intros)"], ["proof (state)\nthis:\n  \\<exists>h' obsa.\n     heap_base.heap_clone allocate typeof_addr\n      (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write\n      P h a h' obsa\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jmm'_red_externalI:\n  \"\\<And>final.\n  \\<lbrakk> heap_base.red_external addr2thread_id thread_id2addr spurious_wakeups empty_heap allocate typeof_addr jmm_heap_read jmm_heap_write P t h a M vs ta va h';\n     final_thread.actions_ok final s t ta \\<rbrakk>\n  \\<Longrightarrow> \\<exists>ta va h'. heap_base.red_external addr2thread_id thread_id2addr spurious_wakeups empty_heap allocate typeof_addr (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write P t h a M vs ta va h' \\<and> final_thread.actions_ok final s t ta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>final.\n       \\<lbrakk>heap_base.red_external (\\<lambda>x. x) (\\<lambda>x. x)\n                 spurious_wakeups empty_heap allocate typeof_addr\n                 jmm_heap_read jmm_heap_write P t h a M vs ta va h';\n        final_thread.actions_ok final s t ta\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta", "proof(erule heap_base.red_external.cases, goal_cases)"], ["proof (state)\ngoal (26 subgoals):\n 1. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = start; vs = [];\n        ta = \\<lbrace>NewThread a (C, run, a) h, ThreadStart a\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 2. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = start; vs = [];\n        ta = \\<lbrace>ThreadExists a True\\<rbrace>;\n        va =\n        RetExc\n         (heap_base.addr_of_sys_xcpt empty_heap allocate\n           IllegalThreadState);\n        h' = h; typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 3. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = join; vs = [];\n        ta = \\<lbrace>Join a, IsInterrupted t False, ThreadJoin a\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 4. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va =\n        RetExc\n         (heap_base.addr_of_sys_xcpt empty_heap allocate\n           InterruptedException);\n        h' = h; typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 5. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists a True, WakeUp a, Interrupt a,\n        ObsInterrupt a\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 6. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = interrupt;\n        vs = []; ta = \\<lbrace>ThreadExists a False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 7. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted a True, ObsInterrupted a\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 8. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = isInterrupted;\n        vs = []; ta = \\<lbrace>IsInterrupted a False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 9. \\<And>final.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = wait; vs = [];\n        ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n        ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n        va =\n        RetExc\n         (heap_base.addr_of_sys_xcpt empty_heap allocate\n           InterruptedException);\n        h' = h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 10. \\<And>final.\n        \\<lbrakk>final_thread.actions_ok final s t ta; M = wait; vs = [];\n         ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n         (ReleaseAcquire, a), IsInterrupted t False, SyncUnlock a\\<rbrace>;\n         va = RetStaySame; h' = h\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ta va h'.\n                             heap_base.red_external (\\<lambda>x. x)\n                              (\\<lambda>x. x) spurious_wakeups empty_heap\n                              allocate typeof_addr\n                              (heap_base.heap_read_typed typeof_addr\n                                jmm_heap_read P)\n                              jmm_heap_write P t h a M vs ta va h' \\<and>\n                             final_thread.actions_ok final s t ta\nA total of 26 subgoals...", "case 19"], ["proof (state)\nthis:\n  final_thread.actions_ok final_ s t ta\n  M = clone\n  vs = []\n  ta = (K$ [], [], [], [], [], obs_)\n  va = RetVal (Addr a'_)\n  h' = h'_\n  heap_base.heap_clone allocate typeof_addr jmm_heap_read jmm_heap_write P h\n   a h'_ \\<lfloor>(obs_, a'_)\\<rfloor>\n\ngoal (26 subgoals):\n 1. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = start; vs = [];\n        ta = \\<lbrace>NewThread a (C, run, a) h, ThreadStart a\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 2. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = start; vs = [];\n        ta = \\<lbrace>ThreadExists a True\\<rbrace>;\n        va =\n        RetExc\n         (heap_base.addr_of_sys_xcpt empty_heap allocate\n           IllegalThreadState);\n        h' = h; typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 3. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = join; vs = [];\n        ta = \\<lbrace>Join a, IsInterrupted t False, ThreadJoin a\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 4. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va =\n        RetExc\n         (heap_base.addr_of_sys_xcpt empty_heap allocate\n           InterruptedException);\n        h' = h; typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 5. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists a True, WakeUp a, Interrupt a,\n        ObsInterrupt a\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 6. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = interrupt;\n        vs = []; ta = \\<lbrace>ThreadExists a False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 7. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted a True, ObsInterrupted a\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 8. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = isInterrupted;\n        vs = []; ta = \\<lbrace>IsInterrupted a False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 9. \\<And>final.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = wait; vs = [];\n        ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n        ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n        va =\n        RetExc\n         (heap_base.addr_of_sys_xcpt empty_heap allocate\n           InterruptedException);\n        h' = h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 10. \\<And>final.\n        \\<lbrakk>final_thread.actions_ok final s t ta; M = wait; vs = [];\n         ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n         (ReleaseAcquire, a), IsInterrupted t False, SyncUnlock a\\<rbrace>;\n         va = RetStaySame; h' = h\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ta va h'.\n                             heap_base.red_external (\\<lambda>x. x)\n                              (\\<lambda>x. x) spurious_wakeups empty_heap\n                              allocate typeof_addr\n                              (heap_base.heap_read_typed typeof_addr\n                                jmm_heap_read P)\n                              jmm_heap_write P t h a M vs ta va h' \\<and>\n                             final_thread.actions_ok final s t ta\nA total of 26 subgoals...", "(* RedClone *)"], ["proof (state)\nthis:\n  final_thread.actions_ok final_ s t ta\n  M = clone\n  vs = []\n  ta = (K$ [], [], [], [], [], obs_)\n  va = RetVal (Addr a'_)\n  h' = h'_\n  heap_base.heap_clone allocate typeof_addr jmm_heap_read jmm_heap_write P h\n   a h'_ \\<lfloor>(obs_, a'_)\\<rfloor>\n\ngoal (26 subgoals):\n 1. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = start; vs = [];\n        ta = \\<lbrace>NewThread a (C, run, a) h, ThreadStart a\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 2. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = start; vs = [];\n        ta = \\<lbrace>ThreadExists a True\\<rbrace>;\n        va =\n        RetExc\n         (heap_base.addr_of_sys_xcpt empty_heap allocate\n           IllegalThreadState);\n        h' = h; typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 3. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = join; vs = [];\n        ta = \\<lbrace>Join a, IsInterrupted t False, ThreadJoin a\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 4. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va =\n        RetExc\n         (heap_base.addr_of_sys_xcpt empty_heap allocate\n           InterruptedException);\n        h' = h; typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 5. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists a True, WakeUp a, Interrupt a,\n        ObsInterrupt a\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 6. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = interrupt;\n        vs = []; ta = \\<lbrace>ThreadExists a False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 7. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted a True, ObsInterrupted a\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 8. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = isInterrupted;\n        vs = []; ta = \\<lbrace>IsInterrupted a False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 9. \\<And>final.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = wait; vs = [];\n        ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n        ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n        va =\n        RetExc\n         (heap_base.addr_of_sys_xcpt empty_heap allocate\n           InterruptedException);\n        h' = h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 10. \\<And>final.\n        \\<lbrakk>final_thread.actions_ok final s t ta; M = wait; vs = [];\n         ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n         (ReleaseAcquire, a), IsInterrupted t False, SyncUnlock a\\<rbrace>;\n         va = RetStaySame; h' = h\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ta va h'.\n                             heap_base.red_external (\\<lambda>x. x)\n                              (\\<lambda>x. x) spurious_wakeups empty_heap\n                              allocate typeof_addr\n                              (heap_base.heap_read_typed typeof_addr\n                                jmm_heap_read P)\n                              jmm_heap_write P t h a M vs ta va h' \\<and>\n                             final_thread.actions_ok final s t ta\nA total of 26 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  final_thread.actions_ok final_ s t ta\n  M = clone\n  vs = []\n  ta = (K$ [], [], [], [], [], obs_)\n  va = RetVal (Addr a'_)\n  h' = h'_\n  heap_base.heap_clone allocate typeof_addr jmm_heap_read jmm_heap_write P h\n   a h'_ \\<lfloor>(obs_, a'_)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>ta va h'.\n       heap_base.red_external (\\<lambda>x. x) (\\<lambda>x. x)\n        spurious_wakeups empty_heap allocate typeof_addr\n        (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n        jmm_heap_write P t h a M vs ta va h' \\<and>\n       final_thread.actions_ok final_ s t ta", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>final_thread.actions_ok final_ s t ta; M = clone; vs = [];\n     ta = (K$ [], [], [], [], [], obs_); va = RetVal (Addr a'_); h' = h'_;\n     heap_base.heap_clone allocate typeof_addr jmm_heap_read jmm_heap_write\n      P h a h'_ \\<lfloor>(obs_, a'_)\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         heap_base.red_external (\\<lambda>x. x)\n                          (\\<lambda>x. x) spurious_wakeups empty_heap\n                          allocate typeof_addr\n                          (heap_base.heap_read_typed typeof_addr\n                            jmm_heap_read P)\n                          jmm_heap_write P t h a M vs ta va h' \\<and>\n                         final_thread.actions_ok final_ s t ta", "apply(drule jmm'_heap_cloneI, clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h'b obsa.\n       \\<lbrakk>final_thread.actions_ok final_ s t\n                 (K$ [], [], [], [], [], obs_);\n        vs = []; ta = (K$ [], [], [], [], [], obs_); va = RetVal (Addr a'_);\n        h' = h'_; M = clone;\n        heap_base.heap_clone allocate typeof_addr\n         (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n         jmm_heap_write P h a h'b obsa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a clone [] ta va h' \\<and>\n                            final_thread.actions_ok final_ s t ta", "apply(rename_tac obsa', case_tac obsa')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h'b obsa'.\n       \\<lbrakk>final_thread.actions_ok final_ s t\n                 (K$ [], [], [], [], [], obs_);\n        vs = []; ta = (K$ [], [], [], [], [], obs_); va = RetVal (Addr a'_);\n        h' = h'_; M = clone;\n        heap_base.heap_clone allocate typeof_addr\n         (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n         jmm_heap_write P h a h'b obsa';\n        obsa' = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a clone [] ta va h' \\<and>\n                            final_thread.actions_ok final_ s t ta\n 2. \\<And>h'b obsa' aa.\n       \\<lbrakk>final_thread.actions_ok final_ s t\n                 (K$ [], [], [], [], [], obs_);\n        vs = []; ta = (K$ [], [], [], [], [], obs_); va = RetVal (Addr a'_);\n        h' = h'_; M = clone;\n        heap_base.heap_clone allocate typeof_addr\n         (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n         jmm_heap_write P h a h'b obsa';\n        obsa' = \\<lfloor>aa\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a clone [] ta va h' \\<and>\n                            final_thread.actions_ok final_ s t ta", "by(auto 4 4 intro: heap_base.red_external.intros simp add: final_thread.actions_ok_iff simp del: split_paired_Ex)"], ["proof (state)\nthis:\n  \\<exists>ta va h'.\n     heap_base.red_external (\\<lambda>x. x) (\\<lambda>x. x) spurious_wakeups\n      empty_heap allocate typeof_addr\n      (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write\n      P t h a M vs ta va h' \\<and>\n     final_thread.actions_ok final_ s t ta\n\ngoal (25 subgoals):\n 1. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = start; vs = [];\n        ta = \\<lbrace>NewThread a (C, run, a) h, ThreadStart a\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 2. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = start; vs = [];\n        ta = \\<lbrace>ThreadExists a True\\<rbrace>;\n        va =\n        RetExc\n         (heap_base.addr_of_sys_xcpt empty_heap allocate\n           IllegalThreadState);\n        h' = h; typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 3. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = join; vs = [];\n        ta = \\<lbrace>Join a, IsInterrupted t False, ThreadJoin a\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 4. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va =\n        RetExc\n         (heap_base.addr_of_sys_xcpt empty_heap allocate\n           InterruptedException);\n        h' = h; typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 5. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists a True, WakeUp a, Interrupt a,\n        ObsInterrupt a\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 6. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = interrupt;\n        vs = []; ta = \\<lbrace>ThreadExists a False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 7. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted a True, ObsInterrupted a\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 8. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = isInterrupted;\n        vs = []; ta = \\<lbrace>IsInterrupted a False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 9. \\<And>final.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = wait; vs = [];\n        ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n        ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n        va =\n        RetExc\n         (heap_base.addr_of_sys_xcpt empty_heap allocate\n           InterruptedException);\n        h' = h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 10. \\<And>final.\n        \\<lbrakk>final_thread.actions_ok final s t ta; M = wait; vs = [];\n         ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n         (ReleaseAcquire, a), IsInterrupted t False, SyncUnlock a\\<rbrace>;\n         va = RetStaySame; h' = h\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ta va h'.\n                             heap_base.red_external (\\<lambda>x. x)\n                              (\\<lambda>x. x) spurious_wakeups empty_heap\n                              allocate typeof_addr\n                              (heap_base.heap_read_typed typeof_addr\n                                jmm_heap_read P)\n                              jmm_heap_write P t h a M vs ta va h' \\<and>\n                             final_thread.actions_ok final s t ta\nA total of 25 subgoals...", "next"], ["proof (state)\ngoal (25 subgoals):\n 1. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = start; vs = [];\n        ta = \\<lbrace>NewThread a (C, run, a) h, ThreadStart a\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 2. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = start; vs = [];\n        ta = \\<lbrace>ThreadExists a True\\<rbrace>;\n        va =\n        RetExc\n         (heap_base.addr_of_sys_xcpt empty_heap allocate\n           IllegalThreadState);\n        h' = h; typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 3. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = join; vs = [];\n        ta = \\<lbrace>Join a, IsInterrupted t False, ThreadJoin a\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 4. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va =\n        RetExc\n         (heap_base.addr_of_sys_xcpt empty_heap allocate\n           InterruptedException);\n        h' = h; typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 5. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists a True, WakeUp a, Interrupt a,\n        ObsInterrupt a\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 6. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = interrupt;\n        vs = []; ta = \\<lbrace>ThreadExists a False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 7. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted a True, ObsInterrupted a\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 8. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = isInterrupted;\n        vs = []; ta = \\<lbrace>IsInterrupted a False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 9. \\<And>final.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = wait; vs = [];\n        ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n        ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n        va =\n        RetExc\n         (heap_base.addr_of_sys_xcpt empty_heap allocate\n           InterruptedException);\n        h' = h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 10. \\<And>final.\n        \\<lbrakk>final_thread.actions_ok final s t ta; M = wait; vs = [];\n         ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n         (ReleaseAcquire, a), IsInterrupted t False, SyncUnlock a\\<rbrace>;\n         va = RetStaySame; h' = h\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ta va h'.\n                             heap_base.red_external (\\<lambda>x. x)\n                              (\\<lambda>x. x) spurious_wakeups empty_heap\n                              allocate typeof_addr\n                              (heap_base.heap_read_typed typeof_addr\n                                jmm_heap_read P)\n                              jmm_heap_write P t h a M vs ta va h' \\<and>\n                             final_thread.actions_ok final s t ta\nA total of 25 subgoals...", "case 20"], ["proof (state)\nthis:\n  final_thread.actions_ok final_ s t ta\n  M = clone\n  vs = []\n  ta = \\<lbrace>\\<rbrace>\n  va = RetExc (heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory)\n  h' = h'_\n  heap_base.heap_clone allocate typeof_addr jmm_heap_read jmm_heap_write P h\n   a h'_ None\n\ngoal (25 subgoals):\n 1. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = start; vs = [];\n        ta = \\<lbrace>NewThread a (C, run, a) h, ThreadStart a\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 2. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = start; vs = [];\n        ta = \\<lbrace>ThreadExists a True\\<rbrace>;\n        va =\n        RetExc\n         (heap_base.addr_of_sys_xcpt empty_heap allocate\n           IllegalThreadState);\n        h' = h; typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 3. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = join; vs = [];\n        ta = \\<lbrace>Join a, IsInterrupted t False, ThreadJoin a\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 4. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va =\n        RetExc\n         (heap_base.addr_of_sys_xcpt empty_heap allocate\n           InterruptedException);\n        h' = h; typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 5. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists a True, WakeUp a, Interrupt a,\n        ObsInterrupt a\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 6. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = interrupt;\n        vs = []; ta = \\<lbrace>ThreadExists a False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 7. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted a True, ObsInterrupted a\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 8. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = isInterrupted;\n        vs = []; ta = \\<lbrace>IsInterrupted a False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 9. \\<And>final.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = wait; vs = [];\n        ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n        ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n        va =\n        RetExc\n         (heap_base.addr_of_sys_xcpt empty_heap allocate\n           InterruptedException);\n        h' = h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 10. \\<And>final.\n        \\<lbrakk>final_thread.actions_ok final s t ta; M = wait; vs = [];\n         ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n         (ReleaseAcquire, a), IsInterrupted t False, SyncUnlock a\\<rbrace>;\n         va = RetStaySame; h' = h\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ta va h'.\n                             heap_base.red_external (\\<lambda>x. x)\n                              (\\<lambda>x. x) spurious_wakeups empty_heap\n                              allocate typeof_addr\n                              (heap_base.heap_read_typed typeof_addr\n                                jmm_heap_read P)\n                              jmm_heap_write P t h a M vs ta va h' \\<and>\n                             final_thread.actions_ok final s t ta\nA total of 25 subgoals...", "(* RedCloneFail *)"], ["proof (state)\nthis:\n  final_thread.actions_ok final_ s t ta\n  M = clone\n  vs = []\n  ta = \\<lbrace>\\<rbrace>\n  va = RetExc (heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory)\n  h' = h'_\n  heap_base.heap_clone allocate typeof_addr jmm_heap_read jmm_heap_write P h\n   a h'_ None\n\ngoal (25 subgoals):\n 1. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = start; vs = [];\n        ta = \\<lbrace>NewThread a (C, run, a) h, ThreadStart a\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 2. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = start; vs = [];\n        ta = \\<lbrace>ThreadExists a True\\<rbrace>;\n        va =\n        RetExc\n         (heap_base.addr_of_sys_xcpt empty_heap allocate\n           IllegalThreadState);\n        h' = h; typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 3. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = join; vs = [];\n        ta = \\<lbrace>Join a, IsInterrupted t False, ThreadJoin a\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 4. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va =\n        RetExc\n         (heap_base.addr_of_sys_xcpt empty_heap allocate\n           InterruptedException);\n        h' = h; typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 5. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists a True, WakeUp a, Interrupt a,\n        ObsInterrupt a\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 6. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = interrupt;\n        vs = []; ta = \\<lbrace>ThreadExists a False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 7. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted a True, ObsInterrupted a\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 8. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = isInterrupted;\n        vs = []; ta = \\<lbrace>IsInterrupted a False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 9. \\<And>final.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = wait; vs = [];\n        ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n        ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n        va =\n        RetExc\n         (heap_base.addr_of_sys_xcpt empty_heap allocate\n           InterruptedException);\n        h' = h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 10. \\<And>final.\n        \\<lbrakk>final_thread.actions_ok final s t ta; M = wait; vs = [];\n         ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n         (ReleaseAcquire, a), IsInterrupted t False, SyncUnlock a\\<rbrace>;\n         va = RetStaySame; h' = h\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ta va h'.\n                             heap_base.red_external (\\<lambda>x. x)\n                              (\\<lambda>x. x) spurious_wakeups empty_heap\n                              allocate typeof_addr\n                              (heap_base.heap_read_typed typeof_addr\n                                jmm_heap_read P)\n                              jmm_heap_write P t h a M vs ta va h' \\<and>\n                             final_thread.actions_ok final s t ta\nA total of 25 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  final_thread.actions_ok final_ s t ta\n  M = clone\n  vs = []\n  ta = \\<lbrace>\\<rbrace>\n  va = RetExc (heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory)\n  h' = h'_\n  heap_base.heap_clone allocate typeof_addr jmm_heap_read jmm_heap_write P h\n   a h'_ None\n\ngoal (1 subgoal):\n 1. \\<exists>ta va h'.\n       heap_base.red_external (\\<lambda>x. x) (\\<lambda>x. x)\n        spurious_wakeups empty_heap allocate typeof_addr\n        (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n        jmm_heap_write P t h a M vs ta va h' \\<and>\n       final_thread.actions_ok final_ s t ta", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>final_thread.actions_ok final_ s t ta; M = clone; vs = [];\n     ta = \\<lbrace>\\<rbrace>;\n     va =\n     RetExc (heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory);\n     h' = h'_;\n     heap_base.heap_clone allocate typeof_addr jmm_heap_read jmm_heap_write\n      P h a h'_ None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta va h'.\n                         heap_base.red_external (\\<lambda>x. x)\n                          (\\<lambda>x. x) spurious_wakeups empty_heap\n                          allocate typeof_addr\n                          (heap_base.heap_read_typed typeof_addr\n                            jmm_heap_read P)\n                          jmm_heap_write P t h a M vs ta va h' \\<and>\n                         final_thread.actions_ok final_ s t ta", "apply(drule jmm'_heap_cloneI, clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h'b obsa.\n       \\<lbrakk>final_thread.actions_ok final_ s t \\<lbrace>\\<rbrace>;\n        vs = []; ta = \\<lbrace>\\<rbrace>;\n        va =\n        RetExc (heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory);\n        h' = h'_; M = clone;\n        heap_base.heap_clone allocate typeof_addr\n         (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n         jmm_heap_write P h a h'b obsa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a clone [] ta va h' \\<and>\n                            final_thread.actions_ok final_ s t ta", "apply(rename_tac obsa', case_tac obsa')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h'b obsa'.\n       \\<lbrakk>final_thread.actions_ok final_ s t \\<lbrace>\\<rbrace>;\n        vs = []; ta = \\<lbrace>\\<rbrace>;\n        va =\n        RetExc (heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory);\n        h' = h'_; M = clone;\n        heap_base.heap_clone allocate typeof_addr\n         (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n         jmm_heap_write P h a h'b obsa';\n        obsa' = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a clone [] ta va h' \\<and>\n                            final_thread.actions_ok final_ s t ta\n 2. \\<And>h'b obsa' aa.\n       \\<lbrakk>final_thread.actions_ok final_ s t \\<lbrace>\\<rbrace>;\n        vs = []; ta = \\<lbrace>\\<rbrace>;\n        va =\n        RetExc (heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory);\n        h' = h'_; M = clone;\n        heap_base.heap_clone allocate typeof_addr\n         (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n         jmm_heap_write P h a h'b obsa';\n        obsa' = \\<lfloor>aa\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a clone [] ta va h' \\<and>\n                            final_thread.actions_ok final_ s t ta", "by(auto 4 4 intro: heap_base.red_external.intros simp add: final_thread.actions_ok_iff simp del: split_paired_Ex)"], ["proof (state)\nthis:\n  \\<exists>ta va h'.\n     heap_base.red_external (\\<lambda>x. x) (\\<lambda>x. x) spurious_wakeups\n      empty_heap allocate typeof_addr\n      (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write\n      P t h a M vs ta va h' \\<and>\n     final_thread.actions_ok final_ s t ta\n\ngoal (24 subgoals):\n 1. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = start; vs = [];\n        ta = \\<lbrace>NewThread a (C, run, a) h, ThreadStart a\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 2. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = start; vs = [];\n        ta = \\<lbrace>ThreadExists a True\\<rbrace>;\n        va =\n        RetExc\n         (heap_base.addr_of_sys_xcpt empty_heap allocate\n           IllegalThreadState);\n        h' = h; typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 3. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = join; vs = [];\n        ta = \\<lbrace>Join a, IsInterrupted t False, ThreadJoin a\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 4. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = join; vs = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va =\n        RetExc\n         (heap_base.addr_of_sys_xcpt empty_heap allocate\n           InterruptedException);\n        h' = h; typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 5. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = interrupt;\n        vs = [];\n        ta = \\<lbrace>ThreadExists a True, WakeUp a, Interrupt a,\n        ObsInterrupt a\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 6. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = interrupt;\n        vs = []; ta = \\<lbrace>ThreadExists a False\\<rbrace>;\n        va = RetVal Unit; h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 7. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = isInterrupted;\n        vs = [];\n        ta = \\<lbrace>IsInterrupted a True, ObsInterrupted a\\<rbrace>;\n        va = RetVal (Bool True); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 8. \\<And>final C.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = isInterrupted;\n        vs = []; ta = \\<lbrace>IsInterrupted a False\\<rbrace>;\n        va = RetVal (Bool False); h' = h;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 9. \\<And>final.\n       \\<lbrakk>final_thread.actions_ok final s t ta; M = wait; vs = [];\n        ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n        ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n        va =\n        RetExc\n         (heap_base.addr_of_sys_xcpt empty_heap allocate\n           InterruptedException);\n        h' = h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta va h'.\n                            heap_base.red_external (\\<lambda>x. x)\n                             (\\<lambda>x. x) spurious_wakeups empty_heap\n                             allocate typeof_addr\n                             (heap_base.heap_read_typed typeof_addr\n                               jmm_heap_read P)\n                             jmm_heap_write P t h a M vs ta va h' \\<and>\n                            final_thread.actions_ok final s t ta\n 10. \\<And>final.\n        \\<lbrakk>final_thread.actions_ok final s t ta; M = wait; vs = [];\n         ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n         (ReleaseAcquire, a), IsInterrupted t False, SyncUnlock a\\<rbrace>;\n         va = RetStaySame; h' = h\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ta va h'.\n                             heap_base.red_external (\\<lambda>x. x)\n                              (\\<lambda>x. x) spurious_wakeups empty_heap\n                              allocate typeof_addr\n                              (heap_base.heap_read_typed typeof_addr\n                                jmm_heap_read P)\n                              jmm_heap_write P t h a M vs ta va h' \\<and>\n                             final_thread.actions_ok final s t ta\nA total of 24 subgoals...", "qed(blast intro: heap_base.red_external.intros)+"], ["", "lemma red_external_aggr_heap_read_typedI:\n  \"\\<And>final.\n  \\<lbrakk> (ta, vah') \\<in> heap_base.red_external_aggr addr2thread_id thread_id2addr spurious_wakeups empty_heap allocate typeof_addr jmm_heap_read jmm_heap_write P t h a M vs;\n    final_thread.actions_ok final s t ta\n  \\<rbrakk>\n  \\<Longrightarrow> \\<exists>ta vah'. (ta, vah') \\<in> heap_base.red_external_aggr addr2thread_id thread_id2addr spurious_wakeups empty_heap allocate typeof_addr (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write P t h a M vs \\<and> final_thread.actions_ok final s t ta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>final.\n       \\<lbrakk>(ta, vah')\n                \\<in> heap_base.red_external_aggr (\\<lambda>x. x)\n                       (\\<lambda>x. x) spurious_wakeups empty_heap allocate\n                       typeof_addr jmm_heap_read jmm_heap_write P t h a M\n                       vs;\n        final_thread.actions_ok final s t ta\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta vah'.\n                            (ta, vah')\n                            \\<in> heap_base.red_external_aggr\n                                   (\\<lambda>x. x) (\\<lambda>x. x)\n                                   spurious_wakeups empty_heap allocate\n                                   typeof_addr\n                                   (heap_base.heap_read_typed typeof_addr\n                                     jmm_heap_read P)\n                                   jmm_heap_write P t h a M vs \\<and>\n                            final_thread.actions_ok final s t ta", "apply(simp add: heap_base.red_external_aggr_def split_beta split del: if_split split: if_split_asm del: split_paired_Ex)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>final.\n       \\<lbrakk>final_thread.actions_ok final s t ta; a = wait;\n        spurious_wakeups;\n        ta = \\<lbrace>(Unlock, h), (Lock, h), IsInterrupted t True,\n        ClearInterrupt t, ObsInterrupted t\\<rbrace> \\<and>\n        vah' =\n        (RetExc\n          (heap_base.addr_of_sys_xcpt empty_heap allocate\n            InterruptedException),\n         vs) \\<or>\n        ta = \\<lbrace>Suspend h, (Unlock, h), (Lock, h),\n        (ReleaseAcquire, h), IsInterrupted t False,\n        SyncUnlock h\\<rbrace> \\<and>\n        vah' = (RetStaySame, vs) \\<or>\n        ta = \\<lbrace>(UnlockFail, h)\\<rbrace> \\<and>\n        vah' =\n        (RetExc\n          (heap_base.addr_of_sys_xcpt empty_heap allocate\n            IllegalMonitorState),\n         vs) \\<or>\n        ta = \\<lbrace>Notified\\<rbrace> \\<and>\n        vah' = (RetVal Unit, vs) \\<or>\n        ta = \\<lbrace>WokenUp, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace> \\<and>\n        vah' =\n        (RetExc\n          (heap_base.addr_of_sys_xcpt empty_heap allocate\n            InterruptedException),\n         vs) \\<or>\n        ta = \\<lbrace>(Unlock, h), (Lock, h), (ReleaseAcquire, h),\n        IsInterrupted t False, SyncUnlock h\\<rbrace> \\<and>\n        vah' = (RetVal Unit, vs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            (\\<exists>vah'.\n                                ta = \\<lbrace>(Unlock, h), (Lock, h),\n                                IsInterrupted t True, ClearInterrupt t,\n                                ObsInterrupted t\\<rbrace> \\<and>\n                                vah' =\n                                (RetExc\n                                  (heap_base.addr_of_sys_xcpt empty_heap\n                                    allocate InterruptedException),\n                                 vs) \\<or>\n                                ta = \\<lbrace>Suspend h, (Unlock, h),\n                                (Lock, h), (ReleaseAcquire, h),\n                                IsInterrupted t False,\n                                SyncUnlock h\\<rbrace> \\<and>\n                                vah' = (RetStaySame, vs) \\<or>\n                                ta =\n                                \\<lbrace>(UnlockFail, h)\\<rbrace> \\<and>\n                                vah' =\n                                (RetExc\n                                  (heap_base.addr_of_sys_xcpt empty_heap\n                                    allocate IllegalMonitorState),\n                                 vs) \\<or>\n                                ta = \\<lbrace>Notified\\<rbrace> \\<and>\n                                vah' = (RetVal Unit, vs) \\<or>\n                                ta = \\<lbrace>WokenUp, ClearInterrupt t,\n                                ObsInterrupted t\\<rbrace> \\<and>\n                                vah' =\n                                (RetExc\n                                  (heap_base.addr_of_sys_xcpt empty_heap\n                                    allocate InterruptedException),\n                                 vs) \\<or>\n                                ta = \\<lbrace>(Unlock, h), (Lock, h),\n                                (ReleaseAcquire, h), IsInterrupted t False,\n                                SyncUnlock h\\<rbrace> \\<and>\n                                vah' = (RetVal Unit, vs)) \\<and>\n                            final_thread.actions_ok final s t ta\n 2. \\<And>final.\n       \\<lbrakk>final_thread.actions_ok final s t ta; a = wait;\n        \\<not> spurious_wakeups;\n        ta = \\<lbrace>(Unlock, h), (Lock, h), IsInterrupted t True,\n        ClearInterrupt t, ObsInterrupted t\\<rbrace> \\<and>\n        vah' =\n        (RetExc\n          (heap_base.addr_of_sys_xcpt empty_heap allocate\n            InterruptedException),\n         vs) \\<or>\n        ta = \\<lbrace>Suspend h, (Unlock, h), (Lock, h),\n        (ReleaseAcquire, h), IsInterrupted t False,\n        SyncUnlock h\\<rbrace> \\<and>\n        vah' = (RetStaySame, vs) \\<or>\n        ta = \\<lbrace>(UnlockFail, h)\\<rbrace> \\<and>\n        vah' =\n        (RetExc\n          (heap_base.addr_of_sys_xcpt empty_heap allocate\n            IllegalMonitorState),\n         vs) \\<or>\n        ta = \\<lbrace>Notified\\<rbrace> \\<and>\n        vah' = (RetVal Unit, vs) \\<or>\n        ta = \\<lbrace>WokenUp, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace> \\<and>\n        vah' =\n        (RetExc\n          (heap_base.addr_of_sys_xcpt empty_heap allocate\n            InterruptedException),\n         vs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            (\\<exists>vah'.\n                                ta = \\<lbrace>(Unlock, h), (Lock, h),\n                                IsInterrupted t True, ClearInterrupt t,\n                                ObsInterrupted t\\<rbrace> \\<and>\n                                vah' =\n                                (RetExc\n                                  (heap_base.addr_of_sys_xcpt empty_heap\n                                    allocate InterruptedException),\n                                 vs) \\<or>\n                                ta = \\<lbrace>Suspend h, (Unlock, h),\n                                (Lock, h), (ReleaseAcquire, h),\n                                IsInterrupted t False,\n                                SyncUnlock h\\<rbrace> \\<and>\n                                vah' = (RetStaySame, vs) \\<or>\n                                ta =\n                                \\<lbrace>(UnlockFail, h)\\<rbrace> \\<and>\n                                vah' =\n                                (RetExc\n                                  (heap_base.addr_of_sys_xcpt empty_heap\n                                    allocate IllegalMonitorState),\n                                 vs) \\<or>\n                                ta = \\<lbrace>Notified\\<rbrace> \\<and>\n                                vah' = (RetVal Unit, vs) \\<or>\n                                ta = \\<lbrace>WokenUp, ClearInterrupt t,\n                                ObsInterrupted t\\<rbrace> \\<and>\n                                vah' =\n                                (RetExc\n                                  (heap_base.addr_of_sys_xcpt empty_heap\n                                    allocate InterruptedException),\n                                 vs)) \\<and>\n                            final_thread.actions_ok final s t ta\n 3. \\<And>final.\n       \\<lbrakk>final_thread.actions_ok final s t ta; a = notify;\n        ta = \\<lbrace>Notify h, (Unlock, h), (Lock, h)\\<rbrace> \\<and>\n        vah' = (RetVal Unit, vs) \\<or>\n        ta = \\<lbrace>(UnlockFail, h)\\<rbrace> \\<and>\n        vah' =\n        (RetExc\n          (heap_base.addr_of_sys_xcpt empty_heap allocate\n            IllegalMonitorState),\n         vs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            (\\<exists>vah'.\n                                ta = \\<lbrace>Notify h, (Unlock, h),\n                                (Lock, h)\\<rbrace> \\<and>\n                                vah' = (RetVal Unit, vs) \\<or>\n                                ta =\n                                \\<lbrace>(UnlockFail, h)\\<rbrace> \\<and>\n                                vah' =\n                                (RetExc\n                                  (heap_base.addr_of_sys_xcpt empty_heap\n                                    allocate IllegalMonitorState),\n                                 vs)) \\<and>\n                            final_thread.actions_ok final s t ta\n 4. \\<And>final.\n       \\<lbrakk>final_thread.actions_ok final s t ta; a = notifyAll;\n        ta = \\<lbrace>NotifyAll h, (Unlock, h), (Lock, h)\\<rbrace> \\<and>\n        vah' = (RetVal Unit, vs) \\<or>\n        ta = \\<lbrace>(UnlockFail, h)\\<rbrace> \\<and>\n        vah' =\n        (RetExc\n          (heap_base.addr_of_sys_xcpt empty_heap allocate\n            IllegalMonitorState),\n         vs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            (\\<exists>vah'.\n                                ta = \\<lbrace>NotifyAll h, (Unlock, h),\n                                (Lock, h)\\<rbrace> \\<and>\n                                vah' = (RetVal Unit, vs) \\<or>\n                                ta =\n                                \\<lbrace>(UnlockFail, h)\\<rbrace> \\<and>\n                                vah' =\n                                (RetExc\n                                  (heap_base.addr_of_sys_xcpt empty_heap\n                                    allocate IllegalMonitorState),\n                                 vs)) \\<and>\n                            final_thread.actions_ok final s t ta\n 5. \\<And>final.\n       \\<lbrakk>final_thread.actions_ok final s t ta; a = clone;\n        (\\<exists>obs.\n            ta = (K$ [], [], [], [], [], obs) \\<and>\n            (\\<exists>a' h'.\n                vah' = (RetVal (Addr a'), h') \\<and>\n                heap_base.heap_clone allocate typeof_addr jmm_heap_read\n                 jmm_heap_write P vs h h'\n                 \\<lfloor>(obs, a')\\<rfloor>)) \\<or>\n        ta = \\<lbrace>\\<rbrace> \\<and>\n        (\\<exists>h'.\n            vah' =\n            (RetExc\n              (heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory),\n             h') \\<and>\n            heap_base.heap_clone allocate typeof_addr jmm_heap_read\n             jmm_heap_write P vs h h' None)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            (\\<exists>vah'.\n                                (\\<exists>obs.\n                                    ta = (K$ [], [], [], [], [], obs) \\<and>\n                                    (\\<exists>a' h'.\n  vah' = (RetVal (Addr a'), h') \\<and>\n  heap_base.heap_clone allocate typeof_addr\n   (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write P\n   vs h h' \\<lfloor>(obs, a')\\<rfloor>)) \\<or>\n                                ta = \\<lbrace>\\<rbrace> \\<and>\n                                (\\<exists>h'.\n                                    vah' =\n                                    (RetExc\n(heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory),\n                                     h') \\<and>\n                                    heap_base.heap_clone allocate\n                                     typeof_addr\n                                     (heap_base.heap_read_typed typeof_addr\n jmm_heap_read P)\n                                     jmm_heap_write P vs h h' None)) \\<and>\n                            final_thread.actions_ok final s t ta\n 6. \\<And>final.\n       \\<lbrakk>final_thread.actions_ok final s t ta; a = interrupted;\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace> \\<and>\n        vah' = (RetVal (Bool True), vs) \\<or>\n        ta = \\<lbrace>IsInterrupted t False\\<rbrace> \\<and>\n        vah' = (RetVal (Bool False), vs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            (\\<exists>vah'.\n                                ta = \\<lbrace>IsInterrupted t True,\n                                ClearInterrupt t,\n                                ObsInterrupted t\\<rbrace> \\<and>\n                                vah' = (RetVal (Bool True), vs) \\<or>\n                                ta =\n                                \\<lbrace>IsInterrupted t\n    False\\<rbrace> \\<and>\n                                vah' = (RetVal (Bool False), vs)) \\<and>\n                            final_thread.actions_ok final s t ta\n 7. \\<And>final.\n       \\<lbrakk>final_thread.actions_ok final s t ta;\n        P \\<turnstile> ty_of_htype\n                        (the (typeof_addr vs h)) \\<le> Class Thread;\n        a = start;\n        ta =\n        \\<lbrace>NewThread h\n                  (the_Class (ty_of_htype (the (typeof_addr vs h))), run, h)\n                  vs,\n        ThreadStart h\\<rbrace> \\<and>\n        vah' = (RetVal Unit, vs) \\<or>\n        ta = \\<lbrace>ThreadExists h True\\<rbrace> \\<and>\n        vah' =\n        (RetExc\n          (heap_base.addr_of_sys_xcpt empty_heap allocate\n            IllegalThreadState),\n         vs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            (\\<exists>vah'.\n                                ta =\n                                \\<lbrace>NewThread h\n    (the_Class (ty_of_htype (the (typeof_addr vs h))), run, h) vs,\n                                ThreadStart h\\<rbrace> \\<and>\n                                vah' = (RetVal Unit, vs) \\<or>\n                                ta =\n                                \\<lbrace>ThreadExists h True\\<rbrace> \\<and>\n                                vah' =\n                                (RetExc\n                                  (heap_base.addr_of_sys_xcpt empty_heap\n                                    allocate IllegalThreadState),\n                                 vs)) \\<and>\n                            final_thread.actions_ok final s t ta\n 8. \\<And>final.\n       \\<lbrakk>final_thread.actions_ok final s t ta;\n        P \\<turnstile> ty_of_htype\n                        (the (typeof_addr vs h)) \\<le> Class Thread;\n        a = join;\n        ta = \\<lbrace>Join h, IsInterrupted t False,\n        ThreadJoin h\\<rbrace> \\<and>\n        vah' = (RetVal Unit, vs) \\<or>\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace> \\<and>\n        vah' =\n        (RetExc\n          (heap_base.addr_of_sys_xcpt empty_heap allocate\n            InterruptedException),\n         vs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            (\\<exists>vah'.\n                                ta = \\<lbrace>Join h, IsInterrupted t False,\n                                ThreadJoin h\\<rbrace> \\<and>\n                                vah' = (RetVal Unit, vs) \\<or>\n                                ta = \\<lbrace>IsInterrupted t True,\n                                ClearInterrupt t,\n                                ObsInterrupted t\\<rbrace> \\<and>\n                                vah' =\n                                (RetExc\n                                  (heap_base.addr_of_sys_xcpt empty_heap\n                                    allocate InterruptedException),\n                                 vs)) \\<and>\n                            final_thread.actions_ok final s t ta\n 9. \\<And>final.\n       \\<lbrakk>final_thread.actions_ok final s t ta;\n        P \\<turnstile> ty_of_htype\n                        (the (typeof_addr vs h)) \\<le> Class Thread;\n        a = interrupt;\n        ta = \\<lbrace>ThreadExists h True, WakeUp h, Interrupt h,\n        ObsInterrupt h\\<rbrace> \\<and>\n        vah' = (RetVal Unit, vs) \\<or>\n        ta = \\<lbrace>ThreadExists h False\\<rbrace> \\<and>\n        vah' = (RetVal Unit, vs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            (\\<exists>vah'.\n                                ta = \\<lbrace>ThreadExists h True, WakeUp h,\n                                Interrupt h, ObsInterrupt h\\<rbrace> \\<and>\n                                vah' = (RetVal Unit, vs) \\<or>\n                                ta =\n                                \\<lbrace>ThreadExists h\n    False\\<rbrace> \\<and>\n                                vah' = (RetVal Unit, vs)) \\<and>\n                            final_thread.actions_ok final s t ta\n 10. \\<And>final.\n        \\<lbrakk>final_thread.actions_ok final s t ta;\n         P \\<turnstile> ty_of_htype\n                         (the (typeof_addr vs h)) \\<le> Class Thread;\n         a = isInterrupted;\n         ta = \\<lbrace>IsInterrupted h False\\<rbrace> \\<and>\n         vah' = (RetVal (Bool False), vs) \\<or>\n         ta = \\<lbrace>IsInterrupted h True,\n         ObsInterrupted h\\<rbrace> \\<and>\n         vah' = (RetVal (Bool True), vs)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ta.\n                             (\\<exists>vah'.\n                                 ta =\n                                 \\<lbrace>IsInterrupted h\n     False\\<rbrace> \\<and>\n                                 vah' = (RetVal (Bool False), vs) \\<or>\n                                 ta = \\<lbrace>IsInterrupted h True,\n                                 ObsInterrupted h\\<rbrace> \\<and>\n                                 vah' = (RetVal (Bool True), vs)) \\<and>\n                             final_thread.actions_ok final s t ta", "apply(auto simp del: split_paired_Ex)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>final obs a' h'.\n       \\<lbrakk>final_thread.actions_ok final s t\n                 (K$ [], [], [], [], [], obs);\n        a = clone; ta = (K$ [], [], [], [], [], obs);\n        vah' = (RetVal (Addr a'), h');\n        heap_base.heap_clone allocate typeof_addr jmm_heap_read\n         jmm_heap_write P vs h h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            (\\<exists>vah'.\n                                (\\<exists>obs.\n                                    ta = (K$ [], [], [], [], [], obs) \\<and>\n                                    (\\<exists>a' h'.\n  vah' = (RetVal (Addr a'), h') \\<and>\n  heap_base.heap_clone allocate typeof_addr\n   (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write P\n   vs h h' \\<lfloor>(obs, a')\\<rfloor>)) \\<or>\n                                ta = \\<lbrace>\\<rbrace> \\<and>\n                                (\\<exists>h'.\n                                    vah' =\n                                    (RetExc\n(heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory),\n                                     h') \\<and>\n                                    heap_base.heap_clone allocate\n                                     typeof_addr\n                                     (heap_base.heap_read_typed typeof_addr\n jmm_heap_read P)\n                                     jmm_heap_write P vs h h' None)) \\<and>\n                            final_thread.actions_ok final s t ta\n 2. \\<And>final h'.\n       \\<lbrakk>final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        a = clone; ta = \\<lbrace>\\<rbrace>;\n        vah' =\n        (RetExc\n          (heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory),\n         h');\n        heap_base.heap_clone allocate typeof_addr jmm_heap_read\n         jmm_heap_write P vs h h' None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            (\\<exists>vah'.\n                                (\\<exists>obs.\n                                    ta = (K$ [], [], [], [], [], obs) \\<and>\n                                    (\\<exists>a' h'.\n  vah' = (RetVal (Addr a'), h') \\<and>\n  heap_base.heap_clone allocate typeof_addr\n   (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write P\n   vs h h' \\<lfloor>(obs, a')\\<rfloor>)) \\<or>\n                                ta = \\<lbrace>\\<rbrace> \\<and>\n                                (\\<exists>h'.\n                                    vah' =\n                                    (RetExc\n(heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory),\n                                     h') \\<and>\n                                    heap_base.heap_clone allocate\n                                     typeof_addr\n                                     (heap_base.heap_read_typed typeof_addr\n jmm_heap_read P)\n                                     jmm_heap_write P vs h h' None)) \\<and>\n                            final_thread.actions_ok final s t ta", "apply(drule jmm'_heap_cloneI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>final obs a' h'.\n       \\<lbrakk>final_thread.actions_ok final s t\n                 (K$ [], [], [], [], [], obs);\n        a = clone; ta = (K$ [], [], [], [], [], obs);\n        vah' = (RetVal (Addr a'), h');\n        \\<exists>h' obsa.\n           heap_base.heap_clone allocate typeof_addr\n            (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n            jmm_heap_write P vs h h' obsa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            (\\<exists>vah'.\n                                (\\<exists>obs.\n                                    ta = (K$ [], [], [], [], [], obs) \\<and>\n                                    (\\<exists>a' h'.\n  vah' = (RetVal (Addr a'), h') \\<and>\n  heap_base.heap_clone allocate typeof_addr\n   (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write P\n   vs h h' \\<lfloor>(obs, a')\\<rfloor>)) \\<or>\n                                ta = \\<lbrace>\\<rbrace> \\<and>\n                                (\\<exists>h'.\n                                    vah' =\n                                    (RetExc\n(heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory),\n                                     h') \\<and>\n                                    heap_base.heap_clone allocate\n                                     typeof_addr\n                                     (heap_base.heap_read_typed typeof_addr\n jmm_heap_read P)\n                                     jmm_heap_write P vs h h' None)) \\<and>\n                            final_thread.actions_ok final s t ta\n 2. \\<And>final h'.\n       \\<lbrakk>final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        a = clone; ta = \\<lbrace>\\<rbrace>;\n        vah' =\n        (RetExc\n          (heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory),\n         h');\n        heap_base.heap_clone allocate typeof_addr jmm_heap_read\n         jmm_heap_write P vs h h' None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            (\\<exists>vah'.\n                                (\\<exists>obs.\n                                    ta = (K$ [], [], [], [], [], obs) \\<and>\n                                    (\\<exists>a' h'.\n  vah' = (RetVal (Addr a'), h') \\<and>\n  heap_base.heap_clone allocate typeof_addr\n   (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write P\n   vs h h' \\<lfloor>(obs, a')\\<rfloor>)) \\<or>\n                                ta = \\<lbrace>\\<rbrace> \\<and>\n                                (\\<exists>h'.\n                                    vah' =\n                                    (RetExc\n(heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory),\n                                     h') \\<and>\n                                    heap_base.heap_clone allocate\n                                     typeof_addr\n                                     (heap_base.heap_read_typed typeof_addr\n jmm_heap_read P)\n                                     jmm_heap_write P vs h h' None)) \\<and>\n                            final_thread.actions_ok final s t ta", "apply(clarify)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>final obs a' h' h'a obsa.\n       \\<lbrakk>final_thread.actions_ok final s t\n                 (K$ [], [], [], [], [], obs);\n        a = clone; ta = (K$ [], [], [], [], [], obs);\n        vah' = (RetVal (Addr a'), h');\n        heap_base.heap_clone allocate typeof_addr\n         (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n         jmm_heap_write P vs h h'a obsa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            (\\<exists>vah'.\n                                (\\<exists>obs.\n                                    ta = (K$ [], [], [], [], [], obs) \\<and>\n                                    (\\<exists>a' h'.\n  vah' = (RetVal (Addr a'), h') \\<and>\n  heap_base.heap_clone allocate typeof_addr\n   (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write P\n   vs h h' \\<lfloor>(obs, a')\\<rfloor>)) \\<or>\n                                ta = \\<lbrace>\\<rbrace> \\<and>\n                                (\\<exists>h'.\n                                    vah' =\n                                    (RetExc\n(heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory),\n                                     h') \\<and>\n                                    heap_base.heap_clone allocate\n                                     typeof_addr\n                                     (heap_base.heap_read_typed typeof_addr\n jmm_heap_read P)\n                                     jmm_heap_write P vs h h' None)) \\<and>\n                            final_thread.actions_ok final s t ta\n 2. \\<And>final h'.\n       \\<lbrakk>final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        a = clone; ta = \\<lbrace>\\<rbrace>;\n        vah' =\n        (RetExc\n          (heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory),\n         h');\n        heap_base.heap_clone allocate typeof_addr jmm_heap_read\n         jmm_heap_write P vs h h' None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            (\\<exists>vah'.\n                                (\\<exists>obs.\n                                    ta = (K$ [], [], [], [], [], obs) \\<and>\n                                    (\\<exists>a' h'.\n  vah' = (RetVal (Addr a'), h') \\<and>\n  heap_base.heap_clone allocate typeof_addr\n   (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write P\n   vs h h' \\<lfloor>(obs, a')\\<rfloor>)) \\<or>\n                                ta = \\<lbrace>\\<rbrace> \\<and>\n                                (\\<exists>h'.\n                                    vah' =\n                                    (RetExc\n(heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory),\n                                     h') \\<and>\n                                    heap_base.heap_clone allocate\n                                     typeof_addr\n                                     (heap_base.heap_read_typed typeof_addr\n jmm_heap_read P)\n                                     jmm_heap_write P vs h h' None)) \\<and>\n                            final_thread.actions_ok final s t ta", "apply(rename_tac obsa, case_tac obsa)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>final obs a' h' h'a obsa.\n       \\<lbrakk>final_thread.actions_ok final s t\n                 (K$ [], [], [], [], [], obs);\n        a = clone; ta = (K$ [], [], [], [], [], obs);\n        vah' = (RetVal (Addr a'), h');\n        heap_base.heap_clone allocate typeof_addr\n         (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n         jmm_heap_write P vs h h'a obsa;\n        obsa = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            (\\<exists>vah'.\n                                (\\<exists>obs.\n                                    ta = (K$ [], [], [], [], [], obs) \\<and>\n                                    (\\<exists>a' h'.\n  vah' = (RetVal (Addr a'), h') \\<and>\n  heap_base.heap_clone allocate typeof_addr\n   (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write P\n   vs h h' \\<lfloor>(obs, a')\\<rfloor>)) \\<or>\n                                ta = \\<lbrace>\\<rbrace> \\<and>\n                                (\\<exists>h'.\n                                    vah' =\n                                    (RetExc\n(heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory),\n                                     h') \\<and>\n                                    heap_base.heap_clone allocate\n                                     typeof_addr\n                                     (heap_base.heap_read_typed typeof_addr\n jmm_heap_read P)\n                                     jmm_heap_write P vs h h' None)) \\<and>\n                            final_thread.actions_ok final s t ta\n 2. \\<And>final obs a' h' h'a obsa aa.\n       \\<lbrakk>final_thread.actions_ok final s t\n                 (K$ [], [], [], [], [], obs);\n        a = clone; ta = (K$ [], [], [], [], [], obs);\n        vah' = (RetVal (Addr a'), h');\n        heap_base.heap_clone allocate typeof_addr\n         (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n         jmm_heap_write P vs h h'a obsa;\n        obsa = \\<lfloor>aa\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            (\\<exists>vah'.\n                                (\\<exists>obs.\n                                    ta = (K$ [], [], [], [], [], obs) \\<and>\n                                    (\\<exists>a' h'.\n  vah' = (RetVal (Addr a'), h') \\<and>\n  heap_base.heap_clone allocate typeof_addr\n   (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write P\n   vs h h' \\<lfloor>(obs, a')\\<rfloor>)) \\<or>\n                                ta = \\<lbrace>\\<rbrace> \\<and>\n                                (\\<exists>h'.\n                                    vah' =\n                                    (RetExc\n(heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory),\n                                     h') \\<and>\n                                    heap_base.heap_clone allocate\n                                     typeof_addr\n                                     (heap_base.heap_read_typed typeof_addr\n jmm_heap_read P)\n                                     jmm_heap_write P vs h h' None)) \\<and>\n                            final_thread.actions_ok final s t ta\n 3. \\<And>final h'.\n       \\<lbrakk>final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        a = clone; ta = \\<lbrace>\\<rbrace>;\n        vah' =\n        (RetExc\n          (heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory),\n         h');\n        heap_base.heap_clone allocate typeof_addr jmm_heap_read\n         jmm_heap_write P vs h h' None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            (\\<exists>vah'.\n                                (\\<exists>obs.\n                                    ta = (K$ [], [], [], [], [], obs) \\<and>\n                                    (\\<exists>a' h'.\n  vah' = (RetVal (Addr a'), h') \\<and>\n  heap_base.heap_clone allocate typeof_addr\n   (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write P\n   vs h h' \\<lfloor>(obs, a')\\<rfloor>)) \\<or>\n                                ta = \\<lbrace>\\<rbrace> \\<and>\n                                (\\<exists>h'.\n                                    vah' =\n                                    (RetExc\n(heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory),\n                                     h') \\<and>\n                                    heap_base.heap_clone allocate\n                                     typeof_addr\n                                     (heap_base.heap_read_typed typeof_addr\n jmm_heap_read P)\n                                     jmm_heap_write P vs h h' None)) \\<and>\n                            final_thread.actions_ok final s t ta", "apply(force simp add: final_thread.actions_ok_iff del: disjCI intro: disjI1 disjI2 simp del: split_paired_Ex)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>final obs a' h' h'a obsa aa.\n       \\<lbrakk>final_thread.actions_ok final s t\n                 (K$ [], [], [], [], [], obs);\n        a = clone; ta = (K$ [], [], [], [], [], obs);\n        vah' = (RetVal (Addr a'), h');\n        heap_base.heap_clone allocate typeof_addr\n         (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n         jmm_heap_write P vs h h'a obsa;\n        obsa = \\<lfloor>aa\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            (\\<exists>vah'.\n                                (\\<exists>obs.\n                                    ta = (K$ [], [], [], [], [], obs) \\<and>\n                                    (\\<exists>a' h'.\n  vah' = (RetVal (Addr a'), h') \\<and>\n  heap_base.heap_clone allocate typeof_addr\n   (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write P\n   vs h h' \\<lfloor>(obs, a')\\<rfloor>)) \\<or>\n                                ta = \\<lbrace>\\<rbrace> \\<and>\n                                (\\<exists>h'.\n                                    vah' =\n                                    (RetExc\n(heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory),\n                                     h') \\<and>\n                                    heap_base.heap_clone allocate\n                                     typeof_addr\n                                     (heap_base.heap_read_typed typeof_addr\n jmm_heap_read P)\n                                     jmm_heap_write P vs h h' None)) \\<and>\n                            final_thread.actions_ok final s t ta\n 2. \\<And>final h'.\n       \\<lbrakk>final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        a = clone; ta = \\<lbrace>\\<rbrace>;\n        vah' =\n        (RetExc\n          (heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory),\n         h');\n        heap_base.heap_clone allocate typeof_addr jmm_heap_read\n         jmm_heap_write P vs h h' None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            (\\<exists>vah'.\n                                (\\<exists>obs.\n                                    ta = (K$ [], [], [], [], [], obs) \\<and>\n                                    (\\<exists>a' h'.\n  vah' = (RetVal (Addr a'), h') \\<and>\n  heap_base.heap_clone allocate typeof_addr\n   (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write P\n   vs h h' \\<lfloor>(obs, a')\\<rfloor>)) \\<or>\n                                ta = \\<lbrace>\\<rbrace> \\<and>\n                                (\\<exists>h'.\n                                    vah' =\n                                    (RetExc\n(heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory),\n                                     h') \\<and>\n                                    heap_base.heap_clone allocate\n                                     typeof_addr\n                                     (heap_base.heap_read_typed typeof_addr\n jmm_heap_read P)\n                                     jmm_heap_write P vs h h' None)) \\<and>\n                            final_thread.actions_ok final s t ta", "apply(force simp add: final_thread.actions_ok_iff del: disjCI intro: disjI1 disjI2 simp del: split_paired_Ex)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>final h'.\n       \\<lbrakk>final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        a = clone; ta = \\<lbrace>\\<rbrace>;\n        vah' =\n        (RetExc\n          (heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory),\n         h');\n        heap_base.heap_clone allocate typeof_addr jmm_heap_read\n         jmm_heap_write P vs h h' None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            (\\<exists>vah'.\n                                (\\<exists>obs.\n                                    ta = (K$ [], [], [], [], [], obs) \\<and>\n                                    (\\<exists>a' h'.\n  vah' = (RetVal (Addr a'), h') \\<and>\n  heap_base.heap_clone allocate typeof_addr\n   (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write P\n   vs h h' \\<lfloor>(obs, a')\\<rfloor>)) \\<or>\n                                ta = \\<lbrace>\\<rbrace> \\<and>\n                                (\\<exists>h'.\n                                    vah' =\n                                    (RetExc\n(heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory),\n                                     h') \\<and>\n                                    heap_base.heap_clone allocate\n                                     typeof_addr\n                                     (heap_base.heap_read_typed typeof_addr\n jmm_heap_read P)\n                                     jmm_heap_write P vs h h' None)) \\<and>\n                            final_thread.actions_ok final s t ta", "apply(drule jmm'_heap_cloneI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>final h'.\n       \\<lbrakk>final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        a = clone; ta = \\<lbrace>\\<rbrace>;\n        vah' =\n        (RetExc\n          (heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory),\n         h');\n        \\<exists>h' obsa.\n           heap_base.heap_clone allocate typeof_addr\n            (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n            jmm_heap_write P vs h h' obsa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            (\\<exists>vah'.\n                                (\\<exists>obs.\n                                    ta = (K$ [], [], [], [], [], obs) \\<and>\n                                    (\\<exists>a' h'.\n  vah' = (RetVal (Addr a'), h') \\<and>\n  heap_base.heap_clone allocate typeof_addr\n   (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write P\n   vs h h' \\<lfloor>(obs, a')\\<rfloor>)) \\<or>\n                                ta = \\<lbrace>\\<rbrace> \\<and>\n                                (\\<exists>h'.\n                                    vah' =\n                                    (RetExc\n(heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory),\n                                     h') \\<and>\n                                    heap_base.heap_clone allocate\n                                     typeof_addr\n                                     (heap_base.heap_read_typed typeof_addr\n jmm_heap_read P)\n                                     jmm_heap_write P vs h h' None)) \\<and>\n                            final_thread.actions_ok final s t ta", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>final h' h'a obsa.\n       \\<lbrakk>final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        a = clone; ta = \\<lbrace>\\<rbrace>;\n        vah' =\n        (RetExc\n          (heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory),\n         h');\n        heap_base.heap_clone allocate typeof_addr\n         (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n         jmm_heap_write P vs h h'a obsa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            (\\<exists>vah'.\n                                (\\<exists>obs.\n                                    ta = (K$ [], [], [], [], [], obs) \\<and>\n                                    (\\<exists>a' h'.\n  vah' = (RetVal (Addr a'), h') \\<and>\n  heap_base.heap_clone allocate typeof_addr\n   (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write P\n   vs h h' \\<lfloor>(obs, a')\\<rfloor>)) \\<or>\n                                ta = \\<lbrace>\\<rbrace> \\<and>\n                                (\\<exists>h'.\n                                    vah' =\n                                    (RetExc\n(heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory),\n                                     h') \\<and>\n                                    heap_base.heap_clone allocate\n                                     typeof_addr\n                                     (heap_base.heap_read_typed typeof_addr\n jmm_heap_read P)\n                                     jmm_heap_write P vs h h' None)) \\<and>\n                            final_thread.actions_ok final s t ta", "apply(rename_tac obsa, case_tac obsa)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>final h' h'a obsa.\n       \\<lbrakk>final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        a = clone; ta = \\<lbrace>\\<rbrace>;\n        vah' =\n        (RetExc\n          (heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory),\n         h');\n        heap_base.heap_clone allocate typeof_addr\n         (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n         jmm_heap_write P vs h h'a obsa;\n        obsa = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            (\\<exists>vah'.\n                                (\\<exists>obs.\n                                    ta = (K$ [], [], [], [], [], obs) \\<and>\n                                    (\\<exists>a' h'.\n  vah' = (RetVal (Addr a'), h') \\<and>\n  heap_base.heap_clone allocate typeof_addr\n   (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write P\n   vs h h' \\<lfloor>(obs, a')\\<rfloor>)) \\<or>\n                                ta = \\<lbrace>\\<rbrace> \\<and>\n                                (\\<exists>h'.\n                                    vah' =\n                                    (RetExc\n(heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory),\n                                     h') \\<and>\n                                    heap_base.heap_clone allocate\n                                     typeof_addr\n                                     (heap_base.heap_read_typed typeof_addr\n jmm_heap_read P)\n                                     jmm_heap_write P vs h h' None)) \\<and>\n                            final_thread.actions_ok final s t ta\n 2. \\<And>final h' h'a obsa aa.\n       \\<lbrakk>final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        a = clone; ta = \\<lbrace>\\<rbrace>;\n        vah' =\n        (RetExc\n          (heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory),\n         h');\n        heap_base.heap_clone allocate typeof_addr\n         (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n         jmm_heap_write P vs h h'a obsa;\n        obsa = \\<lfloor>aa\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            (\\<exists>vah'.\n                                (\\<exists>obs.\n                                    ta = (K$ [], [], [], [], [], obs) \\<and>\n                                    (\\<exists>a' h'.\n  vah' = (RetVal (Addr a'), h') \\<and>\n  heap_base.heap_clone allocate typeof_addr\n   (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write P\n   vs h h' \\<lfloor>(obs, a')\\<rfloor>)) \\<or>\n                                ta = \\<lbrace>\\<rbrace> \\<and>\n                                (\\<exists>h'.\n                                    vah' =\n                                    (RetExc\n(heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory),\n                                     h') \\<and>\n                                    heap_base.heap_clone allocate\n                                     typeof_addr\n                                     (heap_base.heap_read_typed typeof_addr\n jmm_heap_read P)\n                                     jmm_heap_write P vs h h' None)) \\<and>\n                            final_thread.actions_ok final s t ta", "apply(force simp add: final_thread.actions_ok_iff del: disjCI intro: disjI1 disjI2 simp del: split_paired_Ex)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>final h' h'a obsa aa.\n       \\<lbrakk>final_thread.actions_ok final s t \\<lbrace>\\<rbrace>;\n        a = clone; ta = \\<lbrace>\\<rbrace>;\n        vah' =\n        (RetExc\n          (heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory),\n         h');\n        heap_base.heap_clone allocate typeof_addr\n         (heap_base.heap_read_typed typeof_addr jmm_heap_read P)\n         jmm_heap_write P vs h h'a obsa;\n        obsa = \\<lfloor>aa\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            (\\<exists>vah'.\n                                (\\<exists>obs.\n                                    ta = (K$ [], [], [], [], [], obs) \\<and>\n                                    (\\<exists>a' h'.\n  vah' = (RetVal (Addr a'), h') \\<and>\n  heap_base.heap_clone allocate typeof_addr\n   (heap_base.heap_read_typed typeof_addr jmm_heap_read P) jmm_heap_write P\n   vs h h' \\<lfloor>(obs, a')\\<rfloor>)) \\<or>\n                                ta = \\<lbrace>\\<rbrace> \\<and>\n                                (\\<exists>h'.\n                                    vah' =\n                                    (RetExc\n(heap_base.addr_of_sys_xcpt empty_heap allocate OutOfMemory),\n                                     h') \\<and>\n                                    heap_base.heap_clone allocate\n                                     typeof_addr\n                                     (heap_base.heap_read_typed typeof_addr\n jmm_heap_read P)\n                                     jmm_heap_write P vs h h' None)) \\<and>\n                            final_thread.actions_ok final s t ta", "apply(force simp add: final_thread.actions_ok_iff del: disjCI intro: disjI1 disjI2 simp del: split_paired_Ex)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}