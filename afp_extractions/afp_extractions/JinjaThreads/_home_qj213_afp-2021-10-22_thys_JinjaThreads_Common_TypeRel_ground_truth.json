{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Common/TypeRel.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma subcls1D:\n  \"P \\<turnstile> C \\<prec>\\<^sup>1 D \\<Longrightarrow> C \\<noteq> Object \\<and> (\\<exists>fs ms. class P C = Some (D,fs,ms))\"", "lemma Object_subcls1 [iff]: \"\\<not> P \\<turnstile> Object \\<prec>\\<^sup>1 C\"", "lemma Object_subcls_conv [iff]: \"(P \\<turnstile> Object \\<preceq>\\<^sup>* C) = (C = Object)\"", "lemma finite_subcls1: \"finite {(C, D). P \\<turnstile> C \\<prec>\\<^sup>1 D}\"", "lemma finite_subcls1':\n  \"finite ({(D, C). P \\<turnstile> C \\<prec>\\<^sup>1 D})\"", "lemma subcls_is_class: \"(subcls1 P)\\<^sup>+\\<^sup>+ C D \\<Longrightarrow> is_class P C\"", "lemma subcls_is_class1: \"\\<lbrakk> P \\<turnstile> C \\<preceq>\\<^sup>* D; is_class P D \\<rbrakk> \\<Longrightarrow> is_class P C\"", "lemma [iff]: \"(P \\<turnstile> T \\<le> Void) = (T = Void)\"", "lemma [iff]: \"(P \\<turnstile> T \\<le> Boolean) = (T = Boolean)\"", "lemma [iff]: \"(P \\<turnstile> T \\<le> Integer) = (T = Integer)\"", "lemma [iff]: \"(P \\<turnstile> Void \\<le> T) = (T = Void)\"", "lemma [iff]: \"(P \\<turnstile> Boolean \\<le> T) = (T = Boolean)\"", "lemma [iff]: \"(P \\<turnstile> Integer \\<le> T) = (T = Integer)\"", "lemma Class_widen: \"P \\<turnstile> Class C \\<le> T  \\<Longrightarrow>  \\<exists>D. T = Class D\"", "lemma Array_Array_widen:\n  \"P \\<turnstile> Array T \\<le> Array U \\<Longrightarrow> P \\<turnstile> T \\<le> U\"", "lemma widen_Array: \"(P \\<turnstile> T \\<le> U\\<lfloor>\\<rceil>) \\<longleftrightarrow> (T = NT \\<or> (\\<exists>V. T = V\\<lfloor>\\<rceil> \\<and> P \\<turnstile> V \\<le> U))\"", "lemma Array_widen: \"P \\<turnstile> Array A \\<le> T \\<Longrightarrow> (\\<exists>B. T = Array B \\<and> P \\<turnstile> A \\<le> B) \\<or> T = Class Object\"", "lemma [iff]: \"(P \\<turnstile> T \\<le> NT) = (T = NT)\"", "lemma Class_widen_Class [iff]: \"(P \\<turnstile> Class C \\<le> Class D) = (P \\<turnstile> C \\<preceq>\\<^sup>* D)\"", "lemma widen_Class: \"(P \\<turnstile> T \\<le> Class C) = (T = NT \\<or> (\\<exists>D. T = Class D \\<and> P \\<turnstile> D \\<preceq>\\<^sup>* C) \\<or> (C = Object \\<and> (\\<exists>A. T = Array A)))\"", "lemma NT_widen:\n  \"P \\<turnstile> NT \\<le> T = (T = NT \\<or> (\\<exists>C. T = Class C) \\<or> (\\<exists>U. T = U\\<lfloor>\\<rceil>))\"", "lemma Class_widen2: \"P \\<turnstile> Class C \\<le> T = (\\<exists>D. T = Class D \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* D)\"", "lemma Object_widen: \"P \\<turnstile> Class Object \\<le> T \\<Longrightarrow> T = Class Object\"", "lemma NT_Array_widen_Object:\n  \"is_NT_Array T \\<Longrightarrow>  P \\<turnstile> T \\<le> Class Object\"", "lemma widen_trans[trans]: \n  assumes \"P \\<turnstile> S \\<le> U\" \"P \\<turnstile> U \\<le> T\"\n  shows \"P \\<turnstile> S \\<le> T\"", "lemma widens_trans: \"\\<lbrakk>P \\<turnstile> Ss [\\<le>] Ts; P \\<turnstile> Ts [\\<le>] Us\\<rbrakk> \\<Longrightarrow> P \\<turnstile> Ss [\\<le>] Us\"", "lemma class_type_of'_widenD:\n  \"class_type_of' T = \\<lfloor>C\\<rfloor> \\<Longrightarrow> P \\<turnstile> T \\<le> Class C\"", "lemma widen_is_class_type_of:\n  assumes \"class_type_of' T = \\<lfloor>C\\<rfloor>\" \"P \\<turnstile> T' \\<le> T\" \"T' \\<noteq> NT\"\n  obtains C' where \"class_type_of' T' = \\<lfloor>C'\\<rfloor>\" \"P \\<turnstile> C' \\<preceq>\\<^sup>* C\"", "lemma widens_refl: \"P \\<turnstile> Ts [\\<le>] Ts\"", "lemma widen_append1:\n  \"P \\<turnstile> (xs @ ys) [\\<le>] Ts = (\\<exists>Ts1 Ts2. Ts = Ts1 @ Ts2 \\<and> length xs = length Ts1 \\<and> length ys = length Ts2 \\<and> P \\<turnstile> xs [\\<le>] Ts1 \\<and> P \\<turnstile> ys [\\<le>] Ts2)\"", "lemmas widens_Cons [iff] = list_all2_Cons1 [of \"widen P\"] for P", "lemma widens_lengthD:\n  \"P \\<turnstile> xs [\\<le>] ys \\<Longrightarrow> length xs = length ys\"", "lemma widen_refT: \"\\<lbrakk> is_refT T; P \\<turnstile> U \\<le> T \\<rbrakk> \\<Longrightarrow> is_refT U\"", "lemma refT_widen: \"\\<lbrakk> is_refT T; P \\<turnstile> T \\<le> U \\<rbrakk> \\<Longrightarrow> is_refT U\"", "lemma is_lub_upper:\n  \"P \\<turnstile> lub(U, V) = T \\<Longrightarrow> P \\<turnstile> U \\<le> T \\<and> P \\<turnstile> V \\<le> T\"", "lemma is_lub_least:\n  \"\\<lbrakk> P \\<turnstile> lub(U, V) = T; P \\<turnstile> U \\<le> T'; P \\<turnstile> V \\<le> T' \\<rbrakk> \\<Longrightarrow> P \\<turnstile> T \\<le> T'\"", "lemma is_lub_Void [iff]:\n  \"P \\<turnstile> lub(Void, Void) = T \\<longleftrightarrow> T = Void\"", "lemma is_lubI [code_pred_intro]:\n  \"\\<lbrakk>P \\<turnstile> U \\<le> T; P \\<turnstile> V \\<le> T; \\<forall>T'. P \\<turnstile> U \\<le> T' \\<longrightarrow> P \\<turnstile> V \\<le> T' \\<longrightarrow> P \\<turnstile> T \\<le> T'\\<rbrakk> \\<Longrightarrow> P \\<turnstile> lub(U, V) = T\"", "lemma sees_methods_fun:\n  assumes \"P \\<turnstile> C sees_methods Mm\"\n  shows \"P \\<turnstile> C sees_methods Mm' \\<Longrightarrow> Mm' = Mm\"", "lemma visible_methods_exist:\n  \"P \\<turnstile> C sees_methods Mm \\<Longrightarrow> Mm M = Some(m,D) \\<Longrightarrow>\n   (\\<exists>D' fs ms. class P D = Some(D',fs,ms) \\<and> map_of ms M = Some m)\"", "lemma sees_methods_decl_above:\n  assumes \"P \\<turnstile> C sees_methods Mm\"\n  shows \"Mm M = Some(m,D) \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\"", "lemma sees_methods_idemp:\n  assumes \"P \\<turnstile> C sees_methods Mm\" and \"Mm M = Some(m,D)\"\n  shows \"\\<exists>Mm'. (P \\<turnstile> D sees_methods Mm') \\<and> Mm' M = Some(m,D)\"", "lemma sees_methods_decl_mono:\n  assumes sub: \"P \\<turnstile> C' \\<preceq>\\<^sup>* C\" and \"P \\<turnstile> C sees_methods Mm\"\n  shows \"\\<exists>Mm' Mm\\<^sub>2. P \\<turnstile> C' sees_methods Mm' \\<and> Mm' = Mm ++ Mm\\<^sub>2 \\<and> (\\<forall>M m D. Mm\\<^sub>2 M = Some(m,D) \\<longrightarrow> P \\<turnstile> D \\<preceq>\\<^sup>* C)\"\n      (is \"\\<exists>Mm' Mm2. ?Q C' C Mm' Mm2\")", "lemma has_methodI:\n  \"P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in D \\<Longrightarrow> P \\<turnstile> C has M\"", "lemma sees_method_fun:\n  \"\\<lbrakk>P \\<turnstile> C sees M:TS\\<rightarrow>T = m in D; P \\<turnstile> C sees M:TS'\\<rightarrow>T' = m' in D' \\<rbrakk>\n   \\<Longrightarrow> TS' = TS \\<and> T' = T \\<and> m' = m \\<and> D' = D\"", "lemma sees_method_decl_above:\n  \"P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in D \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\"", "lemma visible_method_exists:\n  \"P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n  \\<exists>D' fs ms. class P D = Some(D',fs,ms) \\<and> map_of ms M = Some(Ts,T,m)\"", "lemma sees_method_idemp:\n  \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=m in D \\<Longrightarrow> P \\<turnstile> D sees M:Ts\\<rightarrow>T=m in D\"", "lemma sees_method_decl_mono:\n  \"\\<lbrakk> P \\<turnstile> C' \\<preceq>\\<^sup>* C; P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in D;\n     P \\<turnstile> C' sees M:Ts'\\<rightarrow>T' = m' in D' \\<rbrakk> \\<Longrightarrow> P \\<turnstile> D' \\<preceq>\\<^sup>* D\"", "lemma sees_method_is_class:\n  \"P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in D \\<Longrightarrow> is_class P C\"", "lemma has_fields_fun:\n  assumes \"P \\<turnstile> C has_fields FDTs\" and \"P \\<turnstile> C has_fields FDTs'\"\n  shows \"FDTs' = FDTs\"", "lemma all_fields_in_has_fields:\n  assumes \"P \\<turnstile> C has_fields FDTs\"\n  and \"P \\<turnstile> C \\<preceq>\\<^sup>* D\" \"class P D = Some(D',fs,ms)\" \"(F,Tm) \\<in> set fs\"\n  shows \"((F,D),Tm) \\<in> set FDTs\"", "lemma has_fields_decl_above:\n  assumes \"P \\<turnstile> C has_fields FDTs\" \"((F,D),Tm) \\<in> set FDTs\"\n  shows \"P \\<turnstile> C \\<preceq>\\<^sup>* D\"", "lemma subcls_notin_has_fields:\n  assumes \"P \\<turnstile> C has_fields FDTs\" \"((F,D),Tm) \\<in> set FDTs\"\n  shows \"\\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D C\"", "lemma has_fields_mono_lem:\n  assumes \"P \\<turnstile> D \\<preceq>\\<^sup>* C\" \"P \\<turnstile> C has_fields FDTs\"\n  shows \"\\<exists>pre. P \\<turnstile> D has_fields pre@FDTs \\<and> dom(map_of pre) \\<inter> dom(map_of FDTs) = {}\"", "lemma has_fields_is_class:\n  \"P \\<turnstile> C has_fields FDTs \\<Longrightarrow> is_class P C\"", "lemma Object_has_fields_Object:\n  assumes \"P \\<turnstile> Object has_fields FDTs\"\n  shows \"snd ` fst ` set FDTs \\<subseteq> {Object}\"", "lemma has_field_mono:\n  \"\\<lbrakk> P \\<turnstile> C has F:T (fm) in D; P \\<turnstile> C' \\<preceq>\\<^sup>* C \\<rbrakk> \\<Longrightarrow> P \\<turnstile> C' has F:T (fm) in D\"", "lemma has_field_is_class:\n  \"P \\<turnstile> C has M:T (fm) in D \\<Longrightarrow> is_class P C\"", "lemma has_field_decl_above:\n  \"P \\<turnstile> C has F:T (fm) in D \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\"", "lemma has_field_fun:\n  \"\\<lbrakk>P \\<turnstile> C has F:T (fm) in D; P \\<turnstile> C has F:T' (fm') in D\\<rbrakk> \\<Longrightarrow> T' = T \\<and> fm = fm'\"", "lemma map_of_remap_SomeD:\n  \"map_of (map (\\<lambda>((k,k'),x). (k,(k',x))) t) k = Some (k',x) \\<Longrightarrow> map_of t (k, k') = Some x\"", "lemma has_visible_field:\n  \"P \\<turnstile> C sees F:T (fm) in D \\<Longrightarrow> P \\<turnstile> C has F:T (fm) in D\"", "lemma sees_field_fun:\n  \"\\<lbrakk>P \\<turnstile> C sees F:T (fm) in D; P \\<turnstile> C sees F:T' (fm') in D'\\<rbrakk> \\<Longrightarrow> T' = T \\<and> D' = D \\<and> fm = fm'\"", "lemma sees_field_decl_above:\n  \"P \\<turnstile> C sees F:T (fm) in D \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\"", "lemma sees_field_idemp:\n  assumes \"P \\<turnstile> C sees F:T (fm) in D\"\n  shows \"P \\<turnstile> D sees F:T (fm) in D\"", "lemma [simp]: \"P \\<turnstile> C has_fields FDTs \\<Longrightarrow> fields P C = FDTs\"", "lemma field_def2 [simp]: \"P \\<turnstile> C sees F:T (fm) in D \\<Longrightarrow> field P C F = (D,T,fm)\"", "lemma method_def2 [simp]: \"P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow> method P C M = (D,Ts,T,m)\"", "lemma has_fields_b_fields: \n  \"P \\<turnstile> C has_fields FDTs \\<Longrightarrow> fields P C = FDTs\"", "lemma has_field_map_of_fields [simp]:\n  \"P \\<turnstile> C has F:T (fm) in D \\<Longrightarrow> map_of (fields P C) (F, D) = \\<lfloor>(T, fm)\\<rfloor>\"", "lemma subcls_conv_subcls' [code_unfold]:\n  \"(subcls1 P)^** = subcls' P\"", "lemma widen_array_object_code:\n  \"C = Object \\<Longrightarrow> P \\<turnstile> Array A \\<le> Class C\"", "lemmas [code_pred_intro] =\n  widen_refl widen_subcls widen_null widen_null_array widen_array_object_code widen_array_array", "lemmas widen_i_i_i'_equation [code] = widen.equation[folded widen_i_i_i'_def]", "lemma widen_i_i_i_code [code]:\n  \"widen_i_i_i P T T' = (if P \\<turnstile> T \\<le> T' then Predicate.single () else bot)\"", "lemma eval_Method_i_i_i_o_o_o_o_conv:\n  \"Predicate.eval (Method_i_i_i_o_o_o_o P C M) = (\\<lambda>(Ts, T, m, D). P \\<turnstile> C sees M:Ts\\<rightarrow>T=m in D)\"", "lemma method_code [code]:\n  \"method P C M = \n  Predicate.the (Predicate.bind (Method_i_i_i_o_o_o_o P C M) (\\<lambda>(Ts, T, m, D). Predicate.single (D, Ts, T, m)))\"", "lemma eval_sees_field_i_i_i_o_o_o_conv:\n  \"Predicate.eval (sees_field_i_i_i_o_o_o P C F) = (\\<lambda>(T, fm, D). P \\<turnstile> C sees F:T (fm) in D)\"", "lemma eval_sees_field_i_i_i_o_i_conv:\n  \"Predicate.eval (sees_field_i_i_i_o_o_i P C F D) = (\\<lambda>(T, fm). P \\<turnstile> C sees F:T (fm) in D)\"", "lemma field_code [code]:\n  \"field P C F = Predicate.the (Predicate.bind (sees_field_i_i_i_o_o_o P C F) (\\<lambda>(T, fm, D). Predicate.single (D, T, fm)))\"", "lemma eval_Fields_conv:\n  \"Predicate.eval (Fields_i_i_o P C) = (\\<lambda>FDTs. P \\<turnstile> C has_fields FDTs)\"", "lemma fields_code [code]:\n  \"fields P C = Predicate.the (Fields_i_i_o P C)\""], "translations": [["", "lemma subcls1D:\n  \"P \\<turnstile> C \\<prec>\\<^sup>1 D \\<Longrightarrow> C \\<noteq> Object \\<and> (\\<exists>fs ms. class P C = Some (D,fs,ms))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C \\<prec>\\<^sup>1 D \\<Longrightarrow>\n    C \\<noteq> Object \\<and>\n    (\\<exists>fs ms. class P C = \\<lfloor>(D, fs, ms)\\<rfloor>)", "by(auto elim: subcls1.cases)"], ["", "lemma Object_subcls1 [iff]: \"\\<not> P \\<turnstile> Object \\<prec>\\<^sup>1 C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> P \\<turnstile> Object \\<prec>\\<^sup>1 C", "by(simp add: subcls1.simps)"], ["", "lemma Object_subcls_conv [iff]: \"(P \\<turnstile> Object \\<preceq>\\<^sup>* C) = (C = Object)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Object \\<preceq>\\<^sup>* C = (C = Object)", "by(auto elim: converse_rtranclpE)"], ["", "lemma finite_subcls1: \"finite {(C, D). P \\<turnstile> C \\<prec>\\<^sup>1 D}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {(C, D). P \\<turnstile> C \\<prec>\\<^sup>1 D}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {(C, D). P \\<turnstile> C \\<prec>\\<^sup>1 D}", "let ?A = \"SIGMA C:{C. is_class P C}. {D. C\\<noteq>Object \\<and> fst (the (class P C))=D}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite {(C, D). P \\<turnstile> C \\<prec>\\<^sup>1 D}", "have \"finite ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (SIGMA C:{C. is_class P C}.\n         {D. C \\<noteq> Object \\<and> fst (the (class P C)) = D})", "by(rule finite_SigmaI [OF finite_is_class]) auto"], ["proof (state)\nthis:\n  finite\n   (SIGMA C:{C. is_class P C}.\n       {D. C \\<noteq> Object \\<and> fst (the (class P C)) = D})\n\ngoal (1 subgoal):\n 1. finite {(C, D). P \\<turnstile> C \\<prec>\\<^sup>1 D}", "also"], ["proof (state)\nthis:\n  finite\n   (SIGMA C:{C. is_class P C}.\n       {D. C \\<noteq> Object \\<and> fst (the (class P C)) = D})\n\ngoal (1 subgoal):\n 1. finite {(C, D). P \\<turnstile> C \\<prec>\\<^sup>1 D}", "have \"?A = {(C, D). P \\<turnstile> C \\<prec>\\<^sup>1 D}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SIGMA C:{C. is_class P C}.\n        {D. C \\<noteq> Object \\<and> fst (the (class P C)) = D}) =\n    {(C, D). P \\<turnstile> C \\<prec>\\<^sup>1 D}", "by(fastforce simp:is_class_def dest: subcls1D elim: subcls1I)"], ["proof (state)\nthis:\n  (SIGMA C:{C. is_class P C}.\n      {D. C \\<noteq> Object \\<and> fst (the (class P C)) = D}) =\n  {(C, D). P \\<turnstile> C \\<prec>\\<^sup>1 D}\n\ngoal (1 subgoal):\n 1. finite {(C, D). P \\<turnstile> C \\<prec>\\<^sup>1 D}", "finally"], ["proof (chain)\npicking this:\n  finite {(C, D). P \\<turnstile> C \\<prec>\\<^sup>1 D}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {(C, D). P \\<turnstile> C \\<prec>\\<^sup>1 D}\n\ngoal (1 subgoal):\n 1. finite {(C, D). P \\<turnstile> C \\<prec>\\<^sup>1 D}", "."], ["proof (state)\nthis:\n  finite {(C, D). P \\<turnstile> C \\<prec>\\<^sup>1 D}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_subcls1':\n  \"finite ({(D, C). P \\<turnstile> C \\<prec>\\<^sup>1 D})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {(D, C). P \\<turnstile> C \\<prec>\\<^sup>1 D}", "by(subst finite_converse[symmetric])\n  (simp add: converse_unfold finite_subcls1 del: finite_converse)"], ["", "lemma subcls_is_class: \"(subcls1 P)\\<^sup>+\\<^sup>+ C D \\<Longrightarrow> is_class P C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (subcls1 P)\\<^sup>+\\<^sup>+ C D \\<Longrightarrow> is_class P C", "by(auto elim: converse_tranclpE dest!: subcls1D simp add: is_class_def)"], ["", "lemma subcls_is_class1: \"\\<lbrakk> P \\<turnstile> C \\<preceq>\\<^sup>* D; is_class P D \\<rbrakk> \\<Longrightarrow> is_class P C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D; is_class P D\\<rbrakk>\n    \\<Longrightarrow> is_class P C", "by(auto elim: converse_rtranclpE dest!: subcls1D simp add: is_class_def)"], ["", "subsection\\<open>The subtype relations\\<close>"], ["", "inductive widen :: \"'m prog \\<Rightarrow> ty \\<Rightarrow> ty \\<Rightarrow> bool\" (\"_ \\<turnstile> _ \\<le> _\"   [71,71,71] 70)\n  for P :: \"'m prog\"\nwhere \n  widen_refl[iff]: \"P \\<turnstile> T \\<le> T\"\n| widen_subcls: \"P \\<turnstile> C \\<preceq>\\<^sup>* D  \\<Longrightarrow>  P \\<turnstile> Class C \\<le> Class D\"\n| widen_null[iff]: \"P \\<turnstile> NT \\<le> Class C\"\n| widen_null_array[iff]: \"P \\<turnstile> NT \\<le> Array A\"\n| widen_array_object: \"P \\<turnstile> Array A \\<le> Class Object\"\n| widen_array_array: \"P \\<turnstile> A \\<le> B \\<Longrightarrow> P \\<turnstile> Array A \\<le> Array B\""], ["", "abbreviation\n  widens :: \"'m prog \\<Rightarrow> ty list \\<Rightarrow> ty list \\<Rightarrow> bool\" (\"_ \\<turnstile> _ [\\<le>] _\" [71,71,71] 70)\nwhere\n  \"P \\<turnstile> Ts [\\<le>] Ts' == list_all2 (widen P) Ts Ts'\""], ["", "lemma [iff]: \"(P \\<turnstile> T \\<le> Void) = (T = Void)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> Void = (T = Void)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> Void = (T = Void)", "by (auto elim: widen.cases)"], ["", "(*>*)"], ["", "lemma [iff]: \"(P \\<turnstile> T \\<le> Boolean) = (T = Boolean)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> Boolean = (T = Boolean)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> Boolean = (T = Boolean)", "by (auto elim: widen.cases)"], ["", "(*>*)"], ["", "lemma [iff]: \"(P \\<turnstile> T \\<le> Integer) = (T = Integer)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> Integer = (T = Integer)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> Integer = (T = Integer)", "by (auto elim: widen.cases)"], ["", "(*>*)"], ["", "lemma [iff]: \"(P \\<turnstile> Void \\<le> T) = (T = Void)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Void \\<le> T = (T = Void)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Void \\<le> T = (T = Void)", "by (auto elim: widen.cases)"], ["", "(*>*)"], ["", "lemma [iff]: \"(P \\<turnstile> Boolean \\<le> T) = (T = Boolean)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Boolean \\<le> T = (T = Boolean)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Boolean \\<le> T = (T = Boolean)", "by (auto elim: widen.cases)"], ["", "(*>*)"], ["", "lemma [iff]: \"(P \\<turnstile> Integer \\<le> T) = (T = Integer)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Integer \\<le> T = (T = Integer)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Integer \\<le> T = (T = Integer)", "by (auto elim: widen.cases)"], ["", "(*>*)"], ["", "lemma Class_widen: \"P \\<turnstile> Class C \\<le> T  \\<Longrightarrow>  \\<exists>D. T = Class D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Class C \\<le> T \\<Longrightarrow> \\<exists>D. T = Class D", "by(erule widen.cases, auto)"], ["", "lemma Array_Array_widen:\n  \"P \\<turnstile> Array T \\<le> Array U \\<Longrightarrow> P \\<turnstile> T \\<le> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T\\<lfloor>\\<rceil> \\<le> U\\<lfloor>\\<rceil> \\<Longrightarrow>\n    P \\<turnstile> T \\<le> U", "by(auto elim: widen.cases)"], ["", "lemma widen_Array: \"(P \\<turnstile> T \\<le> U\\<lfloor>\\<rceil>) \\<longleftrightarrow> (T = NT \\<or> (\\<exists>V. T = V\\<lfloor>\\<rceil> \\<and> P \\<turnstile> V \\<le> U))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> U\\<lfloor>\\<rceil> =\n    (T = NT \\<or>\n     (\\<exists>V. T = V\\<lfloor>\\<rceil> \\<and> P \\<turnstile> V \\<le> U))", "by(induct T)(auto dest: Array_Array_widen elim: widen.cases intro: widen_array_array)"], ["", "lemma Array_widen: \"P \\<turnstile> Array A \\<le> T \\<Longrightarrow> (\\<exists>B. T = Array B \\<and> P \\<turnstile> A \\<le> B) \\<or> T = Class Object\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T \\<Longrightarrow>\n    (\\<exists>B.\n        T = B\\<lfloor>\\<rceil> \\<and> P \\<turnstile> A \\<le> B) \\<or>\n    T = Class Object", "by(auto elim: widen.cases)"], ["", "lemma [iff]: \"(P \\<turnstile> T \\<le> NT) = (T = NT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> NT = (T = NT)", "by(induct T)(auto dest:Class_widen Array_widen)"], ["", "lemma Class_widen_Class [iff]: \"(P \\<turnstile> Class C \\<le> Class D) = (P \\<turnstile> C \\<preceq>\\<^sup>* D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Class C \\<le> Class D =\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "by (auto elim: widen_subcls widen.cases)"], ["", "lemma widen_Class: \"(P \\<turnstile> T \\<le> Class C) = (T = NT \\<or> (\\<exists>D. T = Class D \\<and> P \\<turnstile> D \\<preceq>\\<^sup>* C) \\<or> (C = Object \\<and> (\\<exists>A. T = Array A)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> Class C =\n    (T = NT \\<or>\n     (\\<exists>D.\n         T = Class D \\<and> P \\<turnstile> D \\<preceq>\\<^sup>* C) \\<or>\n     C = Object \\<and> (\\<exists>A. T = A\\<lfloor>\\<rceil>))", "by(induct T)(auto dest: Array_widen intro: widen_array_object)"], ["", "lemma NT_widen:\n  \"P \\<turnstile> NT \\<le> T = (T = NT \\<or> (\\<exists>C. T = Class C) \\<or> (\\<exists>U. T = U\\<lfloor>\\<rceil>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> NT \\<le> T =\n    (T = NT \\<or>\n     (\\<exists>C. T = Class C) \\<or> (\\<exists>U. T = U\\<lfloor>\\<rceil>))", "by(cases T) auto"], ["", "lemma Class_widen2: \"P \\<turnstile> Class C \\<le> T = (\\<exists>D. T = Class D \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Class C \\<le> T =\n    (\\<exists>D. T = Class D \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* D)", "by (cases T, auto elim: widen.cases)"], ["", "lemma Object_widen: \"P \\<turnstile> Class Object \\<le> T \\<Longrightarrow> T = Class Object\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Class Object \\<le> T \\<Longrightarrow> T = Class Object", "by(cases T, auto elim: widen.cases)"], ["", "lemma NT_Array_widen_Object:\n  \"is_NT_Array T \\<Longrightarrow>  P \\<turnstile> T \\<le> Class Object\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_NT_Array T \\<Longrightarrow> P \\<turnstile> T \\<le> Class Object", "by(induct T, auto intro: widen_array_object)"], ["", "lemma widen_trans[trans]: \n  assumes \"P \\<turnstile> S \\<le> U\" \"P \\<turnstile> U \\<le> T\"\n  shows \"P \\<turnstile> S \\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> S \\<le> T", "using assms"], ["proof (prove)\nusing this:\n  P \\<turnstile> S \\<le> U\n  P \\<turnstile> U \\<le> T\n\ngoal (1 subgoal):\n 1. P \\<turnstile> S \\<le> T", "proof(induct arbitrary: T)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>T Ta.\n       P \\<turnstile> T \\<le> Ta \\<Longrightarrow> P \\<turnstile> T \\<le> Ta\n 2. \\<And>C D T.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        P \\<turnstile> Class D \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Class C \\<le> T\n 3. \\<And>C T.\n       P \\<turnstile> Class C \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T\n 4. \\<And>A T.\n       P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T\n 5. \\<And>A T.\n       P \\<turnstile> Class Object \\<le> T \\<Longrightarrow>\n       P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T\n 6. \\<And>A B T.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        \\<And>T.\n           P \\<turnstile> B \\<le> T \\<Longrightarrow>\n           P \\<turnstile> A \\<le> T;\n        P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T", "case (widen_refl T T')"], ["proof (state)\nthis:\n  P \\<turnstile> T \\<le> T'\n\ngoal (6 subgoals):\n 1. \\<And>T Ta.\n       P \\<turnstile> T \\<le> Ta \\<Longrightarrow> P \\<turnstile> T \\<le> Ta\n 2. \\<And>C D T.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        P \\<turnstile> Class D \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Class C \\<le> T\n 3. \\<And>C T.\n       P \\<turnstile> Class C \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T\n 4. \\<And>A T.\n       P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T\n 5. \\<And>A T.\n       P \\<turnstile> Class Object \\<le> T \\<Longrightarrow>\n       P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T\n 6. \\<And>A B T.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        \\<And>T.\n           P \\<turnstile> B \\<le> T \\<Longrightarrow>\n           P \\<turnstile> A \\<le> T;\n        P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T", "thus \"P \\<turnstile> T \\<le> T'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> T \\<le> T'\n\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> T'", "."], ["proof (state)\nthis:\n  P \\<turnstile> T \\<le> T'\n\ngoal (5 subgoals):\n 1. \\<And>C D T.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        P \\<turnstile> Class D \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Class C \\<le> T\n 2. \\<And>C T.\n       P \\<turnstile> Class C \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T\n 3. \\<And>A T.\n       P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T\n 4. \\<And>A T.\n       P \\<turnstile> Class Object \\<le> T \\<Longrightarrow>\n       P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T\n 5. \\<And>A B T.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        \\<And>T.\n           P \\<turnstile> B \\<le> T \\<Longrightarrow>\n           P \\<turnstile> A \\<le> T;\n        P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>C D T.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        P \\<turnstile> Class D \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Class C \\<le> T\n 2. \\<And>C T.\n       P \\<turnstile> Class C \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T\n 3. \\<And>A T.\n       P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T\n 4. \\<And>A T.\n       P \\<turnstile> Class Object \\<le> T \\<Longrightarrow>\n       P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T\n 5. \\<And>A B T.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        \\<And>T.\n           P \\<turnstile> B \\<le> T \\<Longrightarrow>\n           P \\<turnstile> A \\<le> T;\n        P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T", "case (widen_subcls C D T)"], ["proof (state)\nthis:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  P \\<turnstile> Class D \\<le> T\n\ngoal (5 subgoals):\n 1. \\<And>C D T.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        P \\<turnstile> Class D \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Class C \\<le> T\n 2. \\<And>C T.\n       P \\<turnstile> Class C \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T\n 3. \\<And>A T.\n       P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T\n 4. \\<And>A T.\n       P \\<turnstile> Class Object \\<le> T \\<Longrightarrow>\n       P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T\n 5. \\<And>A B T.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        \\<And>T.\n           P \\<turnstile> B \\<le> T \\<Longrightarrow>\n           P \\<turnstile> A \\<le> T;\n        P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  P \\<turnstile> Class D \\<le> T", "obtain E where \"T = Class E\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  P \\<turnstile> Class D \\<le> T\n\ngoal (1 subgoal):\n 1. (\\<And>E. T = Class E \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (blast dest: Class_widen)"], ["proof (state)\nthis:\n  T = Class E\n\ngoal (5 subgoals):\n 1. \\<And>C D T.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        P \\<turnstile> Class D \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Class C \\<le> T\n 2. \\<And>C T.\n       P \\<turnstile> Class C \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T\n 3. \\<And>A T.\n       P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T\n 4. \\<And>A T.\n       P \\<turnstile> Class Object \\<le> T \\<Longrightarrow>\n       P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T\n 5. \\<And>A B T.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        \\<And>T.\n           P \\<turnstile> B \\<le> T \\<Longrightarrow>\n           P \\<turnstile> A \\<le> T;\n        P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T", "with widen_subcls"], ["proof (chain)\npicking this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  P \\<turnstile> Class D \\<le> T\n  T = Class E", "show \"P \\<turnstile> Class C \\<le> T\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  P \\<turnstile> Class D \\<le> T\n  T = Class E\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Class C \\<le> T", "by (auto elim: rtrancl_trans)"], ["proof (state)\nthis:\n  P \\<turnstile> Class C \\<le> T\n\ngoal (4 subgoals):\n 1. \\<And>C T.\n       P \\<turnstile> Class C \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T\n 2. \\<And>A T.\n       P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T\n 3. \\<And>A T.\n       P \\<turnstile> Class Object \\<le> T \\<Longrightarrow>\n       P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T\n 4. \\<And>A B T.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        \\<And>T.\n           P \\<turnstile> B \\<le> T \\<Longrightarrow>\n           P \\<turnstile> A \\<le> T;\n        P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>C T.\n       P \\<turnstile> Class C \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T\n 2. \\<And>A T.\n       P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T\n 3. \\<And>A T.\n       P \\<turnstile> Class Object \\<le> T \\<Longrightarrow>\n       P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T\n 4. \\<And>A B T.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        \\<And>T.\n           P \\<turnstile> B \\<le> T \\<Longrightarrow>\n           P \\<turnstile> A \\<le> T;\n        P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T", "case (widen_null C RT)"], ["proof (state)\nthis:\n  P \\<turnstile> Class C \\<le> RT\n\ngoal (4 subgoals):\n 1. \\<And>C T.\n       P \\<turnstile> Class C \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T\n 2. \\<And>A T.\n       P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T\n 3. \\<And>A T.\n       P \\<turnstile> Class Object \\<le> T \\<Longrightarrow>\n       P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T\n 4. \\<And>A B T.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        \\<And>T.\n           P \\<turnstile> B \\<le> T \\<Longrightarrow>\n           P \\<turnstile> A \\<le> T;\n        P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> Class C \\<le> RT", "obtain D where \"RT = Class D\""], ["proof (prove)\nusing this:\n  P \\<turnstile> Class C \\<le> RT\n\ngoal (1 subgoal):\n 1. (\\<And>D. RT = Class D \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: Class_widen)"], ["proof (state)\nthis:\n  RT = Class D\n\ngoal (4 subgoals):\n 1. \\<And>C T.\n       P \\<turnstile> Class C \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T\n 2. \\<And>A T.\n       P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T\n 3. \\<And>A T.\n       P \\<turnstile> Class Object \\<le> T \\<Longrightarrow>\n       P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T\n 4. \\<And>A B T.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        \\<And>T.\n           P \\<turnstile> B \\<le> T \\<Longrightarrow>\n           P \\<turnstile> A \\<le> T;\n        P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T", "thus \"P \\<turnstile> NT \\<le> RT\""], ["proof (prove)\nusing this:\n  RT = Class D\n\ngoal (1 subgoal):\n 1. P \\<turnstile> NT \\<le> RT", "by auto"], ["proof (state)\nthis:\n  P \\<turnstile> NT \\<le> RT\n\ngoal (3 subgoals):\n 1. \\<And>A T.\n       P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T\n 2. \\<And>A T.\n       P \\<turnstile> Class Object \\<le> T \\<Longrightarrow>\n       P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T\n 3. \\<And>A B T.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        \\<And>T.\n           P \\<turnstile> B \\<le> T \\<Longrightarrow>\n           P \\<turnstile> A \\<le> T;\n        P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>A T.\n       P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T\n 2. \\<And>A T.\n       P \\<turnstile> Class Object \\<le> T \\<Longrightarrow>\n       P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T\n 3. \\<And>A B T.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        \\<And>T.\n           P \\<turnstile> B \\<le> T \\<Longrightarrow>\n           P \\<turnstile> A \\<le> T;\n        P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T", "case widen_null_array"], ["proof (state)\nthis:\n  P \\<turnstile> A_\\<lfloor>\\<rceil> \\<le> T\n\ngoal (3 subgoals):\n 1. \\<And>A T.\n       P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T\n 2. \\<And>A T.\n       P \\<turnstile> Class Object \\<le> T \\<Longrightarrow>\n       P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T\n 3. \\<And>A B T.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        \\<And>T.\n           P \\<turnstile> B \\<le> T \\<Longrightarrow>\n           P \\<turnstile> A \\<le> T;\n        P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T", "thus ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> A_\\<lfloor>\\<rceil> \\<le> T\n\ngoal (1 subgoal):\n 1. P \\<turnstile> NT \\<le> T", "by(auto dest: Array_widen)"], ["proof (state)\nthis:\n  P \\<turnstile> NT \\<le> T\n\ngoal (2 subgoals):\n 1. \\<And>A T.\n       P \\<turnstile> Class Object \\<le> T \\<Longrightarrow>\n       P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T\n 2. \\<And>A B T.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        \\<And>T.\n           P \\<turnstile> B \\<le> T \\<Longrightarrow>\n           P \\<turnstile> A \\<le> T;\n        P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A T.\n       P \\<turnstile> Class Object \\<le> T \\<Longrightarrow>\n       P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T\n 2. \\<And>A B T.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        \\<And>T.\n           P \\<turnstile> B \\<le> T \\<Longrightarrow>\n           P \\<turnstile> A \\<le> T;\n        P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T", "case (widen_array_object A T)"], ["proof (state)\nthis:\n  P \\<turnstile> Class Object \\<le> T\n\ngoal (2 subgoals):\n 1. \\<And>A T.\n       P \\<turnstile> Class Object \\<le> T \\<Longrightarrow>\n       P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T\n 2. \\<And>A B T.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        \\<And>T.\n           P \\<turnstile> B \\<le> T \\<Longrightarrow>\n           P \\<turnstile> A \\<le> T;\n        P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T", "hence \"T = Class Object\""], ["proof (prove)\nusing this:\n  P \\<turnstile> Class Object \\<le> T\n\ngoal (1 subgoal):\n 1. T = Class Object", "by(rule Object_widen)"], ["proof (state)\nthis:\n  T = Class Object\n\ngoal (2 subgoals):\n 1. \\<And>A T.\n       P \\<turnstile> Class Object \\<le> T \\<Longrightarrow>\n       P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T\n 2. \\<And>A B T.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        \\<And>T.\n           P \\<turnstile> B \\<le> T \\<Longrightarrow>\n           P \\<turnstile> A \\<le> T;\n        P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T", "with widen_array_object"], ["proof (chain)\npicking this:\n  P \\<turnstile> Class Object \\<le> T\n  T = Class Object", "show \"P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T\""], ["proof (prove)\nusing this:\n  P \\<turnstile> Class Object \\<le> T\n  T = Class Object\n\ngoal (1 subgoal):\n 1. P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T", "by(auto intro: widen.widen_array_object)"], ["proof (state)\nthis:\n  P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>A B T.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        \\<And>T.\n           P \\<turnstile> B \\<le> T \\<Longrightarrow>\n           P \\<turnstile> A \\<le> T;\n        P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A B T.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        \\<And>T.\n           P \\<turnstile> B \\<le> T \\<Longrightarrow>\n           P \\<turnstile> A \\<le> T;\n        P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T", "case widen_array_array"], ["proof (state)\nthis:\n  P \\<turnstile> A_ \\<le> B_\n  P \\<turnstile> B_ \\<le> ?T \\<Longrightarrow> P \\<turnstile> A_ \\<le> ?T\n  P \\<turnstile> B_\\<lfloor>\\<rceil> \\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>A B T.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        \\<And>T.\n           P \\<turnstile> B \\<le> T \\<Longrightarrow>\n           P \\<turnstile> A \\<le> T;\n        P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> T", "thus ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> A_ \\<le> B_\n  P \\<turnstile> B_ \\<le> ?T \\<Longrightarrow> P \\<turnstile> A_ \\<le> ?T\n  P \\<turnstile> B_\\<lfloor>\\<rceil> \\<le> T\n\ngoal (1 subgoal):\n 1. P \\<turnstile> A_\\<lfloor>\\<rceil> \\<le> T", "by(auto dest!: Array_widen intro: widen.widen_array_array widen_array_object)"], ["proof (state)\nthis:\n  P \\<turnstile> A_\\<lfloor>\\<rceil> \\<le> T\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma widens_trans: \"\\<lbrakk>P \\<turnstile> Ss [\\<le>] Ts; P \\<turnstile> Ts [\\<le>] Us\\<rbrakk> \\<Longrightarrow> P \\<turnstile> Ss [\\<le>] Us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> Ss [\\<le>] Ts;\n     P \\<turnstile> Ts [\\<le>] Us\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> Ss [\\<le>] Us", "by (rule list_all2_trans)(rule widen_trans)"], ["", "lemma class_type_of'_widenD:\n  \"class_type_of' T = \\<lfloor>C\\<rfloor> \\<Longrightarrow> P \\<turnstile> T \\<le> Class C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class_type_of' T = \\<lfloor>C\\<rfloor> \\<Longrightarrow>\n    P \\<turnstile> T \\<le> Class C", "by(cases T)(auto intro: widen_array_object)"], ["", "lemma widen_is_class_type_of:\n  assumes \"class_type_of' T = \\<lfloor>C\\<rfloor>\" \"P \\<turnstile> T' \\<le> T\" \"T' \\<noteq> NT\"\n  obtains C' where \"class_type_of' T' = \\<lfloor>C'\\<rfloor>\" \"P \\<turnstile> C' \\<preceq>\\<^sup>* C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C'.\n        \\<lbrakk>class_type_of' T' = \\<lfloor>C'\\<rfloor>;\n         P \\<turnstile> C' \\<preceq>\\<^sup>* C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  class_type_of' T = \\<lfloor>C\\<rfloor>\n  P \\<turnstile> T' \\<le> T\n  T' \\<noteq> NT\n\ngoal (1 subgoal):\n 1. (\\<And>C'.\n        \\<lbrakk>class_type_of' T' = \\<lfloor>C'\\<rfloor>;\n         P \\<turnstile> C' \\<preceq>\\<^sup>* C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases T)(auto simp add: widen_Class widen_Array)"], ["", "lemma widens_refl: \"P \\<turnstile> Ts [\\<le>] Ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Ts [\\<le>] Ts", "by(rule list_all2_refl[OF widen_refl])"], ["", "lemma widen_append1:\n  \"P \\<turnstile> (xs @ ys) [\\<le>] Ts = (\\<exists>Ts1 Ts2. Ts = Ts1 @ Ts2 \\<and> length xs = length Ts1 \\<and> length ys = length Ts2 \\<and> P \\<turnstile> xs [\\<le>] Ts1 \\<and> P \\<turnstile> ys [\\<le>] Ts2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> (xs @ ys) [\\<le>] Ts =\n    (\\<exists>Ts1 Ts2.\n        Ts = Ts1 @ Ts2 \\<and>\n        length xs = length Ts1 \\<and>\n        length ys = length Ts2 \\<and>\n        P \\<turnstile> xs [\\<le>] Ts1 \\<and> P \\<turnstile> ys [\\<le>] Ts2)", "unfolding list_all2_append1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>us vs.\n        Ts = us @ vs \\<and>\n        length us = length xs \\<and>\n        length vs = length ys \\<and>\n        P \\<turnstile> xs [\\<le>] us \\<and> P \\<turnstile> ys [\\<le>] vs) =\n    (\\<exists>Ts1 Ts2.\n        Ts = Ts1 @ Ts2 \\<and>\n        length xs = length Ts1 \\<and>\n        length ys = length Ts2 \\<and>\n        P \\<turnstile> xs [\\<le>] Ts1 \\<and> P \\<turnstile> ys [\\<le>] Ts2)", "by fastforce"], ["", "lemmas widens_Cons [iff] = list_all2_Cons1 [of \"widen P\"] for P"], ["", "lemma widens_lengthD:\n  \"P \\<turnstile> xs [\\<le>] ys \\<Longrightarrow> length xs = length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> xs [\\<le>] ys \\<Longrightarrow> length xs = length ys", "by(rule list_all2_lengthD)"], ["", "lemma widen_refT: \"\\<lbrakk> is_refT T; P \\<turnstile> U \\<le> T \\<rbrakk> \\<Longrightarrow> is_refT U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_refT T; P \\<turnstile> U \\<le> T\\<rbrakk>\n    \\<Longrightarrow> is_refT U", "by(erule refTE)(auto simp add: widen_Class widen_Array)"], ["", "lemma refT_widen: \"\\<lbrakk> is_refT T; P \\<turnstile> T \\<le> U \\<rbrakk> \\<Longrightarrow> is_refT U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_refT T; P \\<turnstile> T \\<le> U\\<rbrakk>\n    \\<Longrightarrow> is_refT U", "by(erule widen.cases) auto"], ["", "inductive is_lub :: \"'m prog \\<Rightarrow> ty \\<Rightarrow> ty \\<Rightarrow> ty \\<Rightarrow> bool\" (\"_ \\<turnstile> lub'((_,/ _)') = _\" [51,51,51,51] 50)\nfor P :: \"'m prog\" and U :: ty and V :: ty and T ::  ty\nwhere \n  \"\\<lbrakk> P \\<turnstile> U \\<le> T; P \\<turnstile> V \\<le> T;\n     \\<And>T'. \\<lbrakk> P \\<turnstile> U \\<le> T'; P \\<turnstile> V \\<le> T' \\<rbrakk> \\<Longrightarrow> P \\<turnstile> T \\<le> T' \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> lub(U, V) = T\""], ["", "lemma is_lub_upper:\n  \"P \\<turnstile> lub(U, V) = T \\<Longrightarrow> P \\<turnstile> U \\<le> T \\<and> P \\<turnstile> V \\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> lub(U, V) = T \\<Longrightarrow>\n    P \\<turnstile> U \\<le> T \\<and> P \\<turnstile> V \\<le> T", "by(auto elim: is_lub.cases)"], ["", "lemma is_lub_least:\n  \"\\<lbrakk> P \\<turnstile> lub(U, V) = T; P \\<turnstile> U \\<le> T'; P \\<turnstile> V \\<le> T' \\<rbrakk> \\<Longrightarrow> P \\<turnstile> T \\<le> T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> lub(U, V) = T; P \\<turnstile> U \\<le> T';\n     P \\<turnstile> V \\<le> T'\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T \\<le> T'", "by(auto elim: is_lub.cases)"], ["", "lemma is_lub_Void [iff]:\n  \"P \\<turnstile> lub(Void, Void) = T \\<longleftrightarrow> T = Void\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<turnstile> lub(Void, Void) = T) = (T = Void)", "by(auto intro: is_lub.intros elim: is_lub.cases)"], ["", "lemma is_lubI [code_pred_intro]:\n  \"\\<lbrakk>P \\<turnstile> U \\<le> T; P \\<turnstile> V \\<le> T; \\<forall>T'. P \\<turnstile> U \\<le> T' \\<longrightarrow> P \\<turnstile> V \\<le> T' \\<longrightarrow> P \\<turnstile> T \\<le> T'\\<rbrakk> \\<Longrightarrow> P \\<turnstile> lub(U, V) = T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> U \\<le> T; P \\<turnstile> V \\<le> T;\n     \\<forall>T'.\n        P \\<turnstile> U \\<le> T' \\<longrightarrow>\n        P \\<turnstile> V \\<le> T' \\<longrightarrow>\n        P \\<turnstile> T \\<le> T'\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> lub(U, V) = T", "by(blast intro: is_lub.intros)"], ["", "subsection\\<open>Method lookup\\<close>"], ["", "inductive Methods :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> (mname \\<rightharpoonup> (ty list \\<times> ty \\<times> 'm option) \\<times> cname) \\<Rightarrow> bool\" \n  (\"_ \\<turnstile> _ sees'_methods _\" [51,51,51] 50)\n  for P :: \"'m prog\"\nwhere \nsees_methods_Object:\n \"\\<lbrakk> class P Object = Some(D,fs,ms); Mm = map_option (\\<lambda>m. (m,Object)) \\<circ> map_of ms \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> Object sees_methods Mm\"\n| sees_methods_rec:\n \"\\<lbrakk> class P C = Some(D,fs,ms); C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n    Mm' = Mm ++ (map_option (\\<lambda>m. (m,C)) \\<circ> map_of ms) \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> C sees_methods Mm'\""], ["", "lemma sees_methods_fun:\n  assumes \"P \\<turnstile> C sees_methods Mm\"\n  shows \"P \\<turnstile> C sees_methods Mm' \\<Longrightarrow> Mm' = Mm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees_methods Mm' \\<Longrightarrow> Mm' = Mm", "using assms"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees_methods Mm\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees_methods Mm' \\<Longrightarrow> Mm' = Mm", "proof(induction arbitrary: Mm')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm Mm'.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        P \\<turnstile> Object sees_methods Mm'\\<rbrakk>\n       \\<Longrightarrow> Mm' = Mm\n 2. \\<And>C D fs ms Mm Mm' Mm'a.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        \\<And>Mm'.\n           P \\<turnstile> D sees_methods Mm' \\<Longrightarrow> Mm' = Mm;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        P \\<turnstile> C sees_methods Mm'a\\<rbrakk>\n       \\<Longrightarrow> Mm'a = Mm'", "case sees_methods_Object"], ["proof (state)\nthis:\n  class P Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  Mm_ = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms_\n  P \\<turnstile> Object sees_methods Mm'\n\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm Mm'.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        P \\<turnstile> Object sees_methods Mm'\\<rbrakk>\n       \\<Longrightarrow> Mm' = Mm\n 2. \\<And>C D fs ms Mm Mm' Mm'a.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        \\<And>Mm'.\n           P \\<turnstile> D sees_methods Mm' \\<Longrightarrow> Mm' = Mm;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        P \\<turnstile> C sees_methods Mm'a\\<rbrakk>\n       \\<Longrightarrow> Mm'a = Mm'", "thus ?case"], ["proof (prove)\nusing this:\n  class P Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  Mm_ = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms_\n  P \\<turnstile> Object sees_methods Mm'\n\ngoal (1 subgoal):\n 1. Mm' = Mm_", "by(auto elim: Methods.cases)"], ["proof (state)\nthis:\n  Mm' = Mm_\n\ngoal (1 subgoal):\n 1. \\<And>C D fs ms Mm Mm' Mm'a.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        \\<And>Mm'.\n           P \\<turnstile> D sees_methods Mm' \\<Longrightarrow> Mm' = Mm;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        P \\<turnstile> C sees_methods Mm'a\\<rbrakk>\n       \\<Longrightarrow> Mm'a = Mm'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms Mm Mm' Mm'a.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        \\<And>Mm'.\n           P \\<turnstile> D sees_methods Mm' \\<Longrightarrow> Mm' = Mm;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        P \\<turnstile> C sees_methods Mm'a\\<rbrakk>\n       \\<Longrightarrow> Mm'a = Mm'", "case (sees_methods_rec C D fs ms Dres Cres Cres')"], ["proof (state)\nthis:\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C \\<noteq> Object\n  P \\<turnstile> D sees_methods Dres\n  Cres = Dres ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\n  P \\<turnstile> D sees_methods ?Mm' \\<Longrightarrow> ?Mm' = Dres\n  P \\<turnstile> C sees_methods Cres'\n\ngoal (1 subgoal):\n 1. \\<And>C D fs ms Mm Mm' Mm'a.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        \\<And>Mm'.\n           P \\<turnstile> D sees_methods Mm' \\<Longrightarrow> Mm' = Mm;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        P \\<turnstile> C sees_methods Mm'a\\<rbrakk>\n       \\<Longrightarrow> Mm'a = Mm'", "from \\<open>P \\<turnstile> C sees_methods Cres'\\<close> \\<open>C \\<noteq> Object\\<close> \\<open>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees_methods Cres'\n  C \\<noteq> Object\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>", "obtain Dres' where Dmethods': \"P \\<turnstile> D sees_methods Dres'\"\n    and Cres': \"Cres' = Dres' ++ (map_option (\\<lambda>m. (m,C)) \\<circ> map_of ms)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees_methods Cres'\n  C \\<noteq> Object\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>Dres'.\n        \\<lbrakk>P \\<turnstile> D sees_methods Dres';\n         Cres' =\n         Dres' ++\n         (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  P \\<turnstile> D sees_methods Dres'\n  Cres' = Dres' ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\n\ngoal (1 subgoal):\n 1. \\<And>C D fs ms Mm Mm' Mm'a.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        \\<And>Mm'.\n           P \\<turnstile> D sees_methods Mm' \\<Longrightarrow> Mm' = Mm;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        P \\<turnstile> C sees_methods Mm'a\\<rbrakk>\n       \\<Longrightarrow> Mm'a = Mm'", "from sees_methods_rec.IH[OF Dmethods'] \\<open>Cres = Dres ++ (map_option (\\<lambda>m. (m,C)) \\<circ> map_of ms)\\<close> Cres'"], ["proof (chain)\npicking this:\n  Dres' = Dres\n  Cres = Dres ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\n  Cres' = Dres' ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)", "show ?case"], ["proof (prove)\nusing this:\n  Dres' = Dres\n  Cres = Dres ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\n  Cres' = Dres' ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\n\ngoal (1 subgoal):\n 1. Cres' = Cres", "by simp"], ["proof (state)\nthis:\n  Cres' = Cres\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma visible_methods_exist:\n  \"P \\<turnstile> C sees_methods Mm \\<Longrightarrow> Mm M = Some(m,D) \\<Longrightarrow>\n   (\\<exists>D' fs ms. class P D = Some(D',fs,ms) \\<and> map_of ms M = Some m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C sees_methods Mm;\n     Mm M = \\<lfloor>(m, D)\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>D' fs ms.\n                         class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n                         map_of ms M = \\<lfloor>m\\<rfloor>", "by(induct rule:Methods.induct) auto"], ["", "lemma sees_methods_decl_above:\n  assumes \"P \\<turnstile> C sees_methods Mm\"\n  shows \"Mm M = Some(m,D) \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "using assms"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees_methods Mm\n\ngoal (1 subgoal):\n 1. Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "by induct(auto elim: converse_rtranclp_into_rtranclp[where r = \"subcls1 P\", OF subcls1I])"], ["", "lemma sees_methods_idemp:\n  assumes \"P \\<turnstile> C sees_methods Mm\" and \"Mm M = Some(m,D)\"\n  shows \"\\<exists>Mm'. (P \\<turnstile> D sees_methods Mm') \\<and> Mm' M = Some(m,D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Mm'.\n       P \\<turnstile> D sees_methods Mm' \\<and>\n       Mm' M = \\<lfloor>(m, D)\\<rfloor>", "using assms"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees_methods Mm\n  Mm M = \\<lfloor>(m, D)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>Mm'.\n       P \\<turnstile> D sees_methods Mm' \\<and>\n       Mm' M = \\<lfloor>(m, D)\\<rfloor>", "by(induct arbitrary: m D)(fastforce dest: Methods.intros)+"], ["", "lemma sees_methods_decl_mono:\n  assumes sub: \"P \\<turnstile> C' \\<preceq>\\<^sup>* C\" and \"P \\<turnstile> C sees_methods Mm\"\n  shows \"\\<exists>Mm' Mm\\<^sub>2. P \\<turnstile> C' sees_methods Mm' \\<and> Mm' = Mm ++ Mm\\<^sub>2 \\<and> (\\<forall>M m D. Mm\\<^sub>2 M = Some(m,D) \\<longrightarrow> P \\<turnstile> D \\<preceq>\\<^sup>* C)\"\n      (is \"\\<exists>Mm' Mm2. ?Q C' C Mm' Mm2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Mm' Mm\\<^sub>2.\n       P \\<turnstile> C' sees_methods Mm' \\<and>\n       Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n       (\\<forall>M m D.\n           Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n           P \\<turnstile> D \\<preceq>\\<^sup>* C)", "using assms"], ["proof (prove)\nusing this:\n  P \\<turnstile> C' \\<preceq>\\<^sup>* C\n  P \\<turnstile> C sees_methods Mm\n\ngoal (1 subgoal):\n 1. \\<exists>Mm' Mm\\<^sub>2.\n       P \\<turnstile> C' sees_methods Mm' \\<and>\n       Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n       (\\<forall>M m D.\n           Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n           P \\<turnstile> D \\<preceq>\\<^sup>* C)", "proof (induction rule: converse_rtranclp_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n    \\<exists>Mm' Mm\\<^sub>2.\n       P \\<turnstile> C sees_methods Mm' \\<and>\n       Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n       (\\<forall>M m D.\n           Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n           P \\<turnstile> D \\<preceq>\\<^sup>* C)\n 2. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "case base"], ["proof (state)\nthis:\n  P \\<turnstile> C sees_methods Mm\n\ngoal (2 subgoals):\n 1. P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n    \\<exists>Mm' Mm\\<^sub>2.\n       P \\<turnstile> C sees_methods Mm' \\<and>\n       Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n       (\\<forall>M m D.\n           Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n           P \\<turnstile> D \\<preceq>\\<^sup>* C)\n 2. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "hence \"?Q C C Mm Map.empty\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees_methods Mm\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees_methods Mm \\<and>\n    Mm = Mm ++ Map.empty \\<and>\n    (\\<forall>M m D.\n        None = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n        P \\<turnstile> D \\<preceq>\\<^sup>* C)", "by simp"], ["proof (state)\nthis:\n  P \\<turnstile> C sees_methods Mm \\<and>\n  Mm = Mm ++ Map.empty \\<and>\n  (\\<forall>M m D.\n      None = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n      P \\<turnstile> D \\<preceq>\\<^sup>* C)\n\ngoal (2 subgoals):\n 1. P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n    \\<exists>Mm' Mm\\<^sub>2.\n       P \\<turnstile> C sees_methods Mm' \\<and>\n       Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n       (\\<forall>M m D.\n           Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n           P \\<turnstile> D \\<preceq>\\<^sup>* C)\n 2. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "thus \"\\<exists>Mm' Mm2. ?Q C C Mm' Mm2\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees_methods Mm \\<and>\n  Mm = Mm ++ Map.empty \\<and>\n  (\\<forall>M m D.\n      None = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n      P \\<turnstile> D \\<preceq>\\<^sup>* C)\n\ngoal (1 subgoal):\n 1. \\<exists>Mm' Mm2.\n       P \\<turnstile> C sees_methods Mm' \\<and>\n       Mm' = Mm ++ Mm2 \\<and>\n       (\\<forall>M m D.\n           Mm2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n           P \\<turnstile> D \\<preceq>\\<^sup>* C)", "by blast"], ["proof (state)\nthis:\n  \\<exists>Mm' Mm2.\n     P \\<turnstile> C sees_methods Mm' \\<and>\n     Mm' = Mm ++ Mm2 \\<and>\n     (\\<forall>M m D.\n         Mm2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n         P \\<turnstile> D \\<preceq>\\<^sup>* C)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "case (step C'' C')"], ["proof (state)\nthis:\n  P \\<turnstile> C'' \\<prec>\\<^sup>1 C'\n  P \\<turnstile> C' \\<preceq>\\<^sup>* C\n  P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n  \\<exists>Mm' Mm\\<^sub>2.\n     P \\<turnstile> C' sees_methods Mm' \\<and>\n     Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n     (\\<forall>M m D.\n         Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n         P \\<turnstile> D \\<preceq>\\<^sup>* C)\n  P \\<turnstile> C sees_methods Mm\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "note sub1 = \\<open>P \\<turnstile> C'' \\<prec>\\<^sup>1 C'\\<close> and sub = \\<open>P \\<turnstile> C' \\<preceq>\\<^sup>* C\\<close>\n    and Csees = \\<open>P \\<turnstile> C sees_methods Mm\\<close>"], ["proof (state)\nthis:\n  P \\<turnstile> C'' \\<prec>\\<^sup>1 C'\n  P \\<turnstile> C' \\<preceq>\\<^sup>* C\n  P \\<turnstile> C sees_methods Mm\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "from step.IH[OF Csees]"], ["proof (chain)\npicking this:\n  \\<exists>Mm' Mm\\<^sub>2.\n     P \\<turnstile> C' sees_methods Mm' \\<and>\n     Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n     (\\<forall>M m D.\n         Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n         P \\<turnstile> D \\<preceq>\\<^sup>* C)", "obtain Mm' Mm2 where C'sees: \"P \\<turnstile> C' sees_methods Mm'\"\n    and Mm': \"Mm' = Mm ++ Mm2\"\n    and subC: \"\\<forall>M m D. Mm2 M = Some(m,D) \\<longrightarrow> P \\<turnstile> D \\<preceq>\\<^sup>* C\""], ["proof (prove)\nusing this:\n  \\<exists>Mm' Mm\\<^sub>2.\n     P \\<turnstile> C' sees_methods Mm' \\<and>\n     Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n     (\\<forall>M m D.\n         Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n         P \\<turnstile> D \\<preceq>\\<^sup>* C)\n\ngoal (1 subgoal):\n 1. (\\<And>Mm' Mm2.\n        \\<lbrakk>P \\<turnstile> C' sees_methods Mm'; Mm' = Mm ++ Mm2;\n         \\<forall>M m D.\n            Mm2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n            P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  P \\<turnstile> C' sees_methods Mm'\n  Mm' = Mm ++ Mm2\n  \\<forall>M m D.\n     Mm2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n     P \\<turnstile> D \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "obtain fs ms where \"class\": \"class P C'' = Some(C',fs,ms)\" \"C'' \\<noteq> Object\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fs ms.\n        \\<lbrakk>class P C'' = \\<lfloor>(C', fs, ms)\\<rfloor>;\n         C'' \\<noteq> Object\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using subcls1D[OF sub1]"], ["proof (prove)\nusing this:\n  C'' \\<noteq> Object \\<and>\n  (\\<exists>fs ms. class P C'' = \\<lfloor>(C', fs, ms)\\<rfloor>)\n\ngoal (1 subgoal):\n 1. (\\<And>fs ms.\n        \\<lbrakk>class P C'' = \\<lfloor>(C', fs, ms)\\<rfloor>;\n         C'' \\<noteq> Object\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  class P C'' = \\<lfloor>(C', fs, ms)\\<rfloor>\n  C'' \\<noteq> Object\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "let ?Mm3 = \"map_option (\\<lambda>m. (m,C'')) \\<circ> map_of ms\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "have \"P \\<turnstile> C'' sees_methods (Mm ++ Mm2) ++ ?Mm3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C'' sees_methods Mm ++ Mm2 ++\n                                    (map_option\n(\\<lambda>m. (m, C'')) \\<circ>\n                                     map_of ms)", "using sees_methods_rec[OF \"class\" C'sees refl] Mm'"], ["proof (prove)\nusing this:\n  P \\<turnstile> C'' sees_methods Mm' ++\n                                  (map_option (\\<lambda>m. (m, C'')) \\<circ>\n                                   map_of ms)\n  Mm' = Mm ++ Mm2\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C'' sees_methods Mm ++ Mm2 ++\n                                    (map_option\n(\\<lambda>m. (m, C'')) \\<circ>\n                                     map_of ms)", "by simp"], ["proof (state)\nthis:\n  P \\<turnstile> C'' sees_methods Mm ++ Mm2 ++\n                                  (map_option (\\<lambda>m. (m, C'')) \\<circ>\n                                   map_of ms)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "hence \"?Q C'' C ((Mm ++ Mm2) ++ ?Mm3) (Mm2++?Mm3)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C'' sees_methods Mm ++ Mm2 ++\n                                  (map_option (\\<lambda>m. (m, C'')) \\<circ>\n                                   map_of ms)\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C'' sees_methods Mm ++ Mm2 ++\n                                    (map_option\n(\\<lambda>m. (m, C'')) \\<circ>\n                                     map_of ms) \\<and>\n    Mm ++ Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms) =\n    Mm ++\n    (Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms)) \\<and>\n    (\\<forall>M m D.\n        (Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms)) M =\n        \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n        P \\<turnstile> D \\<preceq>\\<^sup>* C)", "using converse_rtranclp_into_rtranclp[OF sub1 sub]"], ["proof (prove)\nusing this:\n  P \\<turnstile> C'' sees_methods Mm ++ Mm2 ++\n                                  (map_option (\\<lambda>m. (m, C'')) \\<circ>\n                                   map_of ms)\n  P \\<turnstile> C'' \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C'' sees_methods Mm ++ Mm2 ++\n                                    (map_option\n(\\<lambda>m. (m, C'')) \\<circ>\n                                     map_of ms) \\<and>\n    Mm ++ Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms) =\n    Mm ++\n    (Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms)) \\<and>\n    (\\<forall>M m D.\n        (Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms)) M =\n        \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n        P \\<turnstile> D \\<preceq>\\<^sup>* C)", "by simp (simp add:map_add_def subC split:option.split)"], ["proof (state)\nthis:\n  P \\<turnstile> C'' sees_methods Mm ++ Mm2 ++\n                                  (map_option (\\<lambda>m. (m, C'')) \\<circ>\n                                   map_of ms) \\<and>\n  Mm ++ Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms) =\n  Mm ++\n  (Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms)) \\<and>\n  (\\<forall>M m D.\n      (Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms)) M =\n      \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n      P \\<turnstile> D \\<preceq>\\<^sup>* C)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "thus \"\\<exists>Mm' Mm2. ?Q C'' C Mm' Mm2\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C'' sees_methods Mm ++ Mm2 ++\n                                  (map_option (\\<lambda>m. (m, C'')) \\<circ>\n                                   map_of ms) \\<and>\n  Mm ++ Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms) =\n  Mm ++\n  (Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms)) \\<and>\n  (\\<forall>M m D.\n      (Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms)) M =\n      \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n      P \\<turnstile> D \\<preceq>\\<^sup>* C)\n\ngoal (1 subgoal):\n 1. \\<exists>Mm' Mm2.\n       P \\<turnstile> C'' sees_methods Mm' \\<and>\n       Mm' = Mm ++ Mm2 \\<and>\n       (\\<forall>M m D.\n           Mm2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n           P \\<turnstile> D \\<preceq>\\<^sup>* C)", "by blast"], ["proof (state)\nthis:\n  \\<exists>Mm' Mm2.\n     P \\<turnstile> C'' sees_methods Mm' \\<and>\n     Mm' = Mm ++ Mm2 \\<and>\n     (\\<forall>M m D.\n         Mm2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n         P \\<turnstile> D \\<preceq>\\<^sup>* C)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition Method :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> mname \\<Rightarrow> ty list \\<Rightarrow> ty \\<Rightarrow> 'm option \\<Rightarrow> cname \\<Rightarrow> bool\"\n            (\"_ \\<turnstile> _ sees _: _\\<rightarrow>_ = _ in _\" [51,51,51,51,51,51,51] 50)\nwhere\n  \"P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D  \\<equiv>\n  \\<exists>Mm. P \\<turnstile> C sees_methods Mm \\<and> Mm M = Some((Ts,T,m),D)\""], ["", "text \\<open>\n  Output translation to replace @{term \"None\"} with its notation \\<open>Native\\<close>\n  when used as method body in @{term \"Method\"}.\n\\<close>"], ["", "abbreviation (output)\n  Method_native :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> mname \\<Rightarrow> ty list \\<Rightarrow> ty \\<Rightarrow> cname \\<Rightarrow> bool\"\n  (\"_ \\<turnstile> _ sees _: _\\<rightarrow>_ = Native in _\" [51,51,51,51,51,51] 50)\nwhere \"Method_native P C M Ts T D \\<equiv> Method P C M Ts T Native D\""], ["", "definition has_method :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> mname \\<Rightarrow> bool\" (\"_ \\<turnstile> _ has _\" [51,0,51] 50)\nwhere\n  \"P \\<turnstile> C has M \\<equiv> \\<exists>Ts T m D. P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in D\""], ["", "lemma has_methodI:\n  \"P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in D \\<Longrightarrow> P \\<turnstile> C has M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    P \\<turnstile> C has M", "by (unfold has_method_def) blast"], ["", "lemma sees_method_fun:\n  \"\\<lbrakk>P \\<turnstile> C sees M:TS\\<rightarrow>T = m in D; P \\<turnstile> C sees M:TS'\\<rightarrow>T' = m' in D' \\<rbrakk>\n   \\<Longrightarrow> TS' = TS \\<and> T' = T \\<and> m' = m \\<and> D' = D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C sees M: TS\\<rightarrow>T = m in D;\n     P \\<turnstile> C sees M: TS'\\<rightarrow>T' = m' in D'\\<rbrakk>\n    \\<Longrightarrow> TS' = TS \\<and> T' = T \\<and> m' = m \\<and> D' = D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C sees M: TS\\<rightarrow>T = m in D;\n     P \\<turnstile> C sees M: TS'\\<rightarrow>T' = m' in D'\\<rbrakk>\n    \\<Longrightarrow> TS' = TS \\<and> T' = T \\<and> m' = m \\<and> D' = D", "by(fastforce dest: sees_methods_fun simp:Method_def)"], ["", "(*>*)"], ["", "lemma sees_method_decl_above:\n  \"P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in D \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "by(clarsimp simp:Method_def sees_methods_decl_above)"], ["", "(*>*)"], ["", "lemma visible_method_exists:\n  \"P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n  \\<exists>D' fs ms. class P D = Some(D',fs,ms) \\<and> map_of ms M = Some(Ts,T,m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    \\<exists>D' fs ms.\n       class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n       map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    \\<exists>D' fs ms.\n       class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n       map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>", "by(fastforce simp:Method_def dest!: visible_methods_exist)"], ["", "(*>*)"], ["", "lemma sees_method_idemp:\n  \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=m in D \\<Longrightarrow> P \\<turnstile> D sees M:Ts\\<rightarrow>T=m in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    P \\<turnstile> D sees M: Ts\\<rightarrow>T = m in D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    P \\<turnstile> D sees M: Ts\\<rightarrow>T = m in D", "by(fastforce simp: Method_def intro:sees_methods_idemp)"], ["", "(*>*)"], ["", "lemma sees_method_decl_mono:\n  \"\\<lbrakk> P \\<turnstile> C' \\<preceq>\\<^sup>* C; P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in D;\n     P \\<turnstile> C' sees M:Ts'\\<rightarrow>T' = m' in D' \\<rbrakk> \\<Longrightarrow> P \\<turnstile> D' \\<preceq>\\<^sup>* D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C' \\<preceq>\\<^sup>* C;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D;\n     P \\<turnstile> C' sees M: Ts'\\<rightarrow>T' = m' in D'\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> D' \\<preceq>\\<^sup>* D", "apply(frule sees_method_decl_above)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C' \\<preceq>\\<^sup>* C;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D;\n     P \\<turnstile> C' sees M: Ts'\\<rightarrow>T' = m' in D';\n     P \\<turnstile> C \\<preceq>\\<^sup>* D\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> D' \\<preceq>\\<^sup>* D", "apply(unfold Method_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C' \\<preceq>\\<^sup>* C;\n     \\<exists>Mm.\n        P \\<turnstile> C sees_methods Mm \\<and>\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n     \\<exists>Mm.\n        P \\<turnstile> C' sees_methods Mm \\<and>\n        Mm M = \\<lfloor>((Ts', T', m'), D')\\<rfloor>;\n     P \\<turnstile> C \\<preceq>\\<^sup>* D\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> D' \\<preceq>\\<^sup>* D", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Mm Mma.\n       \\<lbrakk>P \\<turnstile> C' \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        P \\<turnstile> C sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> C' sees_methods Mma;\n        Mma M = \\<lfloor>((Ts', T', m'), D')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> D' \\<preceq>\\<^sup>* D", "apply(drule (1) sees_methods_decl_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Mm Mma.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        P \\<turnstile> C sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> C' sees_methods Mma;\n        Mma M = \\<lfloor>((Ts', T', m'), D')\\<rfloor>;\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> C' sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> D' \\<preceq>\\<^sup>* D", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Mm Mma Mm\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        P \\<turnstile> C sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> C' sees_methods Mma;\n        Mma M = \\<lfloor>((Ts', T', m'), D')\\<rfloor>;\n        P \\<turnstile> C' sees_methods Mm ++ Mm\\<^sub>2;\n        \\<forall>M a aa b D.\n           Mm\\<^sub>2 M =\n           \\<lfloor>((a, aa, b), D)\\<rfloor> \\<longrightarrow>\n           P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> D' \\<preceq>\\<^sup>* D", "apply(drule (1) sees_methods_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Mm Mma Mm\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        P \\<turnstile> C sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        Mma M = \\<lfloor>((Ts', T', m'), D')\\<rfloor>;\n        P \\<turnstile> C' sees_methods Mm ++ Mm\\<^sub>2;\n        \\<forall>M a aa b D.\n           Mm\\<^sub>2 M =\n           \\<lfloor>((a, aa, b), D)\\<rfloor> \\<longrightarrow>\n           P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        Mm ++ Mm\\<^sub>2 = Mma\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> D' \\<preceq>\\<^sup>* D", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Mm Mm\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        P \\<turnstile> C sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> C' sees_methods Mm ++ Mm\\<^sub>2;\n        \\<forall>M a aa b D.\n           Mm\\<^sub>2 M =\n           \\<lfloor>((a, aa, b), D)\\<rfloor> \\<longrightarrow>\n           P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        Mm\\<^sub>2 M = \\<lfloor>((Ts', T', m'), D')\\<rfloor> \\<or>\n        Mm\\<^sub>2 M = None \\<and>\n        Ts = Ts' \\<and> T = T' \\<and> m = m' \\<and> D = D'\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> D' \\<preceq>\\<^sup>* D", "apply(blast intro:rtranclp_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sees_method_is_class:\n  \"P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in D \\<Longrightarrow> is_class P C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    is_class P C", "by (auto simp add: is_class_def Method_def elim: Methods.cases)"], ["", "subsection\\<open>Field lookup\\<close>"], ["", "inductive Fields :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> ((vname \\<times> cname) \\<times> (ty \\<times> fmod)) list \\<Rightarrow> bool\"\n  (\"_ \\<turnstile> _ has'_fields _\" [51,51,51] 50)\n  for P :: \"'m prog\"\nwhere \n  has_fields_rec:\n  \"\\<lbrakk> class P C = Some(D,fs,ms); C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n     FDTs' = map (\\<lambda>(F,Tm). ((F,C),Tm)) fs @ FDTs \\<rbrakk>\n   \\<Longrightarrow> P \\<turnstile> C has_fields FDTs'\"\n\n| has_fields_Object:\n  \"\\<lbrakk> class P Object = Some(D,fs,ms); FDTs = map (\\<lambda>(F,T). ((F,Object),T)) fs \\<rbrakk>\n   \\<Longrightarrow> P \\<turnstile> Object has_fields FDTs\""], ["", "lemma has_fields_fun:\n  assumes \"P \\<turnstile> C has_fields FDTs\" and \"P \\<turnstile> C has_fields FDTs'\"\n  shows \"FDTs' = FDTs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FDTs' = FDTs", "using assms"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n  P \\<turnstile> C has_fields FDTs'\n\ngoal (1 subgoal):\n 1. FDTs' = FDTs", "proof(induction arbitrary: FDTs')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs' FDTs'a.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        \\<And>FDTs'.\n           P \\<turnstile> D has_fields FDTs' \\<Longrightarrow> FDTs' = FDTs;\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs;\n        P \\<turnstile> C has_fields FDTs'a\\<rbrakk>\n       \\<Longrightarrow> FDTs'a = FDTs'\n 2. \\<And>D fs ms FDTs FDTs'.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs;\n        P \\<turnstile> Object has_fields FDTs'\\<rbrakk>\n       \\<Longrightarrow> FDTs' = FDTs", "case has_fields_Object"], ["proof (state)\nthis:\n  class P Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  FDTs_ = map (\\<lambda>(F, T). ((F, Object), T)) fs_\n  P \\<turnstile> Object has_fields FDTs'\n\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs' FDTs'a.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        \\<And>FDTs'.\n           P \\<turnstile> D has_fields FDTs' \\<Longrightarrow> FDTs' = FDTs;\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs;\n        P \\<turnstile> C has_fields FDTs'a\\<rbrakk>\n       \\<Longrightarrow> FDTs'a = FDTs'\n 2. \\<And>D fs ms FDTs FDTs'.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs;\n        P \\<turnstile> Object has_fields FDTs'\\<rbrakk>\n       \\<Longrightarrow> FDTs' = FDTs", "thus ?case"], ["proof (prove)\nusing this:\n  class P Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  FDTs_ = map (\\<lambda>(F, T). ((F, Object), T)) fs_\n  P \\<turnstile> Object has_fields FDTs'\n\ngoal (1 subgoal):\n 1. FDTs' = FDTs_", "by(auto elim: Fields.cases)"], ["proof (state)\nthis:\n  FDTs' = FDTs_\n\ngoal (1 subgoal):\n 1. \\<And>C D fs ms FDTs FDTs' FDTs'a.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        \\<And>FDTs'.\n           P \\<turnstile> D has_fields FDTs' \\<Longrightarrow> FDTs' = FDTs;\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs;\n        P \\<turnstile> C has_fields FDTs'a\\<rbrakk>\n       \\<Longrightarrow> FDTs'a = FDTs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms FDTs FDTs' FDTs'a.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        \\<And>FDTs'.\n           P \\<turnstile> D has_fields FDTs' \\<Longrightarrow> FDTs' = FDTs;\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs;\n        P \\<turnstile> C has_fields FDTs'a\\<rbrakk>\n       \\<Longrightarrow> FDTs'a = FDTs'", "case (has_fields_rec C D fs ms Dres Cres Cres')"], ["proof (state)\nthis:\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C \\<noteq> Object\n  P \\<turnstile> D has_fields Dres\n  Cres = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ Dres\n  P \\<turnstile> D has_fields ?FDTs' \\<Longrightarrow> ?FDTs' = Dres\n  P \\<turnstile> C has_fields Cres'\n\ngoal (1 subgoal):\n 1. \\<And>C D fs ms FDTs FDTs' FDTs'a.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        \\<And>FDTs'.\n           P \\<turnstile> D has_fields FDTs' \\<Longrightarrow> FDTs' = FDTs;\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs;\n        P \\<turnstile> C has_fields FDTs'a\\<rbrakk>\n       \\<Longrightarrow> FDTs'a = FDTs'", "from \\<open>P \\<turnstile> C has_fields Cres'\\<close> \\<open>C \\<noteq> Object\\<close> \\<open>class P C = Some (D, fs, ms)\\<close>"], ["proof (chain)\npicking this:\n  P \\<turnstile> C has_fields Cres'\n  C \\<noteq> Object\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>", "obtain Dres' where DFields': \"P \\<turnstile> D has_fields Dres'\"\n    and Cres': \"Cres' = map (\\<lambda>(F,Tm). ((F,C),Tm)) fs @ Dres'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields Cres'\n  C \\<noteq> Object\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>Dres'.\n        \\<lbrakk>P \\<turnstile> D has_fields Dres';\n         Cres' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ Dres'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  P \\<turnstile> D has_fields Dres'\n  Cres' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ Dres'\n\ngoal (1 subgoal):\n 1. \\<And>C D fs ms FDTs FDTs' FDTs'a.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        \\<And>FDTs'.\n           P \\<turnstile> D has_fields FDTs' \\<Longrightarrow> FDTs' = FDTs;\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs;\n        P \\<turnstile> C has_fields FDTs'a\\<rbrakk>\n       \\<Longrightarrow> FDTs'a = FDTs'", "from has_fields_rec.IH[OF DFields'] \\<open>Cres = map (\\<lambda>(F,Tm). ((F,C),Tm)) fs @ Dres\\<close> Cres'"], ["proof (chain)\npicking this:\n  Dres' = Dres\n  Cres = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ Dres\n  Cres' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ Dres'", "show ?case"], ["proof (prove)\nusing this:\n  Dres' = Dres\n  Cres = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ Dres\n  Cres' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ Dres'\n\ngoal (1 subgoal):\n 1. Cres' = Cres", "by simp"], ["proof (state)\nthis:\n  Cres' = Cres\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma all_fields_in_has_fields:\n  assumes \"P \\<turnstile> C has_fields FDTs\"\n  and \"P \\<turnstile> C \\<preceq>\\<^sup>* D\" \"class P D = Some(D',fs,ms)\" \"(F,Tm) \\<in> set fs\"\n  shows \"((F,D),Tm) \\<in> set FDTs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((F, D), Tm) \\<in> set FDTs", "using assms"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  class P D = \\<lfloor>(D', fs, ms)\\<rfloor>\n  (F, Tm) \\<in> set fs\n\ngoal (1 subgoal):\n 1. ((F, D), Tm) \\<in> set FDTs", "by induct (auto 4 3 elim: converse_rtranclpE dest: subcls1D)"], ["", "lemma has_fields_decl_above:\n  assumes \"P \\<turnstile> C has_fields FDTs\" \"((F,D),Tm) \\<in> set FDTs\"\n  shows \"P \\<turnstile> C \\<preceq>\\<^sup>* D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C \\<preceq>\\<^sup>* D", "using assms"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n  ((F, D), Tm) \\<in> set FDTs\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C \\<preceq>\\<^sup>* D", "by induct (auto intro: converse_rtranclp_into_rtranclp subcls1I)"], ["", "lemma subcls_notin_has_fields:\n  assumes \"P \\<turnstile> C has_fields FDTs\" \"((F,D),Tm) \\<in> set FDTs\"\n  shows \"\\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D C", "using assms"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n  ((F, D), Tm) \\<in> set FDTs\n\ngoal (1 subgoal):\n 1. \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D C", "apply(induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C Da fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), Tm) \\<in> set FDTs \\<Longrightarrow>\n        \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D Da;\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs;\n        ((F, D), Tm) \\<in> set FDTs'\\<rbrakk>\n       \\<Longrightarrow> \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D C\n 2. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs;\n        ((F, D), Tm) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D Object", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs;\n        ((F, D), Tm) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D Object\n 2. \\<And>C Da fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), Tm) \\<in> set FDTs \\<Longrightarrow>\n        \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D Da;\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs;\n        ((F, D), Tm) \\<in> set FDTs'\\<rbrakk>\n       \\<Longrightarrow> \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D C", "apply(fastforce dest: tranclpD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C Da fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), Tm) \\<in> set FDTs \\<Longrightarrow>\n        \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D Da;\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs;\n        ((F, D), Tm) \\<in> set FDTs'\\<rbrakk>\n       \\<Longrightarrow> \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D C", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C Da fs ms FDTs.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), Tm) \\<in> set FDTs \\<Longrightarrow>\n        \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D Da;\n        ((F, D), Tm)\n        \\<in> (\\<lambda>x. case x of (F, x) \\<Rightarrow> ((F, C), x)) `\n              set fs \\<or>\n        ((F, D), Tm) \\<in> set FDTs;\n        (subcls1 P)\\<^sup>+\\<^sup>+ D C\\<rbrakk>\n       \\<Longrightarrow> False", "apply(erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C Da fs ms FDTs.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), Tm) \\<in> set FDTs \\<Longrightarrow>\n        \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D Da;\n        (subcls1 P)\\<^sup>+\\<^sup>+ D C;\n        ((F, D), Tm)\n        \\<in> (\\<lambda>x. case x of (F, x) \\<Rightarrow> ((F, C), x)) `\n              set fs\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>C Da fs ms FDTs.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), Tm) \\<in> set FDTs \\<Longrightarrow>\n        \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D Da;\n        (subcls1 P)\\<^sup>+\\<^sup>+ D C;\n        ((F, D), Tm) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> False", "apply(clarsimp simp add:image_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Da fs ms FDTs aa b.\n       \\<lbrakk>class P D = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        D \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), aa, b) \\<in> set FDTs \\<Longrightarrow>\n        \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D Da;\n        (subcls1 P)\\<^sup>+\\<^sup>+ D D; (F, aa, b) \\<in> set fs;\n        Tm = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>C Da fs ms FDTs.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), Tm) \\<in> set FDTs \\<Longrightarrow>\n        \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D Da;\n        (subcls1 P)\\<^sup>+\\<^sup>+ D C;\n        ((F, D), Tm) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> False", "apply(drule tranclpD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Da fs ms FDTs aa b.\n       \\<lbrakk>class P D = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        D \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), aa, b) \\<in> set FDTs \\<Longrightarrow>\n        \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D Da;\n        (F, aa, b) \\<in> set fs; Tm = (aa, b);\n        \\<exists>z.\n           P \\<turnstile> D \\<prec>\\<^sup>1 z \\<and>\n           P \\<turnstile> z \\<preceq>\\<^sup>* D\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>C Da fs ms FDTs.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), Tm) \\<in> set FDTs \\<Longrightarrow>\n        \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D Da;\n        (subcls1 P)\\<^sup>+\\<^sup>+ D C;\n        ((F, D), Tm) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> False", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Da fs ms FDTs aa b z.\n       \\<lbrakk>class P D = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        D \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), aa, b) \\<in> set FDTs \\<Longrightarrow>\n        \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D Da;\n        (F, aa, b) \\<in> set fs; Tm = (aa, b);\n        P \\<turnstile> D \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* D\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>C Da fs ms FDTs.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), Tm) \\<in> set FDTs \\<Longrightarrow>\n        \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D Da;\n        (subcls1 P)\\<^sup>+\\<^sup>+ D C;\n        ((F, D), Tm) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> False", "apply(frule subcls1D)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Da fs ms FDTs aa b z.\n       \\<lbrakk>class P D = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        D \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), aa, b) \\<in> set FDTs \\<Longrightarrow>\n        \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D Da;\n        (F, aa, b) \\<in> set fs; Tm = (aa, b);\n        P \\<turnstile> D \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* D;\n        D \\<noteq> Object \\<and>\n        (\\<exists>fs ms. class P D = \\<lfloor>(z, fs, ms)\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>C Da fs ms FDTs.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), Tm) \\<in> set FDTs \\<Longrightarrow>\n        \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D Da;\n        (subcls1 P)\\<^sup>+\\<^sup>+ D C;\n        ((F, D), Tm) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> False", "apply(fastforce dest:tranclpD all_fields_in_has_fields)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C Da fs ms FDTs.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), Tm) \\<in> set FDTs \\<Longrightarrow>\n        \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D Da;\n        (subcls1 P)\\<^sup>+\\<^sup>+ D C;\n        ((F, D), Tm) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> False", "apply(blast dest:subcls1I tranclp.trancl_into_trancl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma has_fields_mono_lem:\n  assumes \"P \\<turnstile> D \\<preceq>\\<^sup>* C\" \"P \\<turnstile> C has_fields FDTs\"\n  shows \"\\<exists>pre. P \\<turnstile> D has_fields pre@FDTs \\<and> dom(map_of pre) \\<inter> dom(map_of FDTs) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>pre.\n       P \\<turnstile> D has_fields pre @ FDTs \\<and>\n       dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "using assms"], ["proof (prove)\nusing this:\n  P \\<turnstile> D \\<preceq>\\<^sup>* C\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. \\<exists>pre.\n       P \\<turnstile> D has_fields pre @ FDTs \\<and>\n       dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "apply(induct rule:converse_rtranclp_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    \\<exists>pre.\n       P \\<turnstile> C has_fields pre @ FDTs \\<and>\n       dom (map_of pre) \\<inter> dom (map_of FDTs) = {}\n 2. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n        \\<exists>pre.\n           P \\<turnstile> z has_fields pre @ FDTs \\<and>\n           dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        P \\<turnstile> C has_fields FDTs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> y has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "apply(rule_tac x = \"[]\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    P \\<turnstile> C has_fields [] @ FDTs \\<and>\n    dom (map_of []) \\<inter> dom (map_of FDTs) = {}\n 2. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n        \\<exists>pre.\n           P \\<turnstile> z has_fields pre @ FDTs \\<and>\n           dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        P \\<turnstile> C has_fields FDTs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> y has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n        \\<exists>pre.\n           P \\<turnstile> z has_fields pre @ FDTs \\<and>\n           dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        P \\<turnstile> C has_fields FDTs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> y has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z pre.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> z has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> y has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "apply(rename_tac D' D pre)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D' D pre.\n       \\<lbrakk>P \\<turnstile> D' \\<prec>\\<^sup>1 D;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> D has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> D' has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "apply(subgoal_tac \"(subcls1 P)^++ D' C\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D' D pre.\n       \\<lbrakk>P \\<turnstile> D' \\<prec>\\<^sup>1 D;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> D has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        (subcls1 P)\\<^sup>+\\<^sup>+ D' C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> D' has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}\n 2. \\<And>D' D pre.\n       \\<lbrakk>P \\<turnstile> D' \\<prec>\\<^sup>1 D;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> D has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {}\\<rbrakk>\n       \\<Longrightarrow> (subcls1 P)\\<^sup>+\\<^sup>+ D' C", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D' D pre.\n       \\<lbrakk>P \\<turnstile> D' \\<prec>\\<^sup>1 D;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> D has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {}\\<rbrakk>\n       \\<Longrightarrow> (subcls1 P)\\<^sup>+\\<^sup>+ D' C\n 2. \\<And>D' D pre.\n       \\<lbrakk>P \\<turnstile> D' \\<prec>\\<^sup>1 D;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> D has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        (subcls1 P)\\<^sup>+\\<^sup>+ D' C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> D' has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "apply(erule (1) rtranclp_into_tranclp2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D' D pre.\n       \\<lbrakk>P \\<turnstile> D' \\<prec>\\<^sup>1 D;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> D has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        (subcls1 P)\\<^sup>+\\<^sup>+ D' C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> D' has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "apply(drule subcls1D)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D' D pre.\n       \\<lbrakk>P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> D has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        (subcls1 P)\\<^sup>+\\<^sup>+ D' C;\n        D' \\<noteq> Object \\<and>\n        (\\<exists>fs ms.\n            class P D' = \\<lfloor>(D, fs, ms)\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> D' has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D' D pre fs ms.\n       \\<lbrakk>P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> D has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        (subcls1 P)\\<^sup>+\\<^sup>+ D' C; D' \\<noteq> Object;\n        class P D' = \\<lfloor>(D, fs, ms)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> D' has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "apply(rename_tac fs ms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D' D pre fs ms.\n       \\<lbrakk>P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> D has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        (subcls1 P)\\<^sup>+\\<^sup>+ D' C; D' \\<noteq> Object;\n        class P D' = \\<lfloor>(D, fs, ms)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> D' has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "apply(drule (2) has_fields_rec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D' D pre fs ms.\n       \\<lbrakk>P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> D has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        (subcls1 P)\\<^sup>+\\<^sup>+ D' C; D' \\<noteq> Object\\<rbrakk>\n       \\<Longrightarrow> ?FDTs'14 D' D pre fs ms =\n                         map (\\<lambda>(F, Tm). ((F, D'), Tm)) fs @\n                         pre @ FDTs\n 2. \\<And>D' D pre fs ms.\n       \\<lbrakk>P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> D has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        (subcls1 P)\\<^sup>+\\<^sup>+ D' C; D' \\<noteq> Object;\n        P \\<turnstile> D' has_fields ?FDTs'14 D' D pre fs ms\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> D' has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "apply(rule refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D' D pre fs ms.\n       \\<lbrakk>P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> D has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        (subcls1 P)\\<^sup>+\\<^sup>+ D' C; D' \\<noteq> Object;\n        P \\<turnstile> D' has_fields map (\\<lambda>(F, Tm). ((F, D'), Tm))\nfs @\n                                     pre @ FDTs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> D' has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "apply(rule_tac x = \"map (\\<lambda>(F,Tm). ((F,D'),Tm)) fs @ pre\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D' D pre fs ms.\n       \\<lbrakk>P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> D has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        (subcls1 P)\\<^sup>+\\<^sup>+ D' C; D' \\<noteq> Object;\n        P \\<turnstile> D' has_fields map (\\<lambda>(F, Tm). ((F, D'), Tm))\nfs @\n                                     pre @ FDTs\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> D' has_fields (map\n                  (\\<lambda>(F, Tm). ((F, D'), Tm)) fs @\n                 pre) @\n                FDTs \\<and>\n                         dom (map_of\n                               (map (\\<lambda>(F, Tm). ((F, D'), Tm)) fs @\n                                pre)) \\<inter>\n                         dom (map_of FDTs) =\n                         {}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D' D pre fs.\n       \\<lbrakk>P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> D has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        (subcls1 P)\\<^sup>+\\<^sup>+ D' C; D' \\<noteq> Object;\n        P \\<turnstile> D' has_fields map (\\<lambda>(F, y). ((F, D'), y))\nfs @\n                                     pre @ FDTs\\<rbrakk>\n       \\<Longrightarrow> (dom (map_of\n                                (map (\\<lambda>(F, y). ((F, D'), y))\n                                  fs)) \\<union>\n                          dom (map_of pre)) \\<inter>\n                         dom (map_of FDTs) =\n                         {}", "apply(simp add:Int_Un_distrib2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D' D pre fs.\n       \\<lbrakk>P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> D has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        (subcls1 P)\\<^sup>+\\<^sup>+ D' C; D' \\<noteq> Object;\n        P \\<turnstile> D' has_fields map (\\<lambda>(F, y). ((F, D'), y))\nfs @\n                                     pre @ FDTs\\<rbrakk>\n       \\<Longrightarrow> dom (map_of\n                               (map (\\<lambda>(F, y). ((F, D'), y))\n                                 fs)) \\<inter>\n                         dom (map_of FDTs) =\n                         {}", "apply(rule equals0I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D' D pre fs y.\n       \\<lbrakk>P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> D has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        (subcls1 P)\\<^sup>+\\<^sup>+ D' C; D' \\<noteq> Object;\n        P \\<turnstile> D' has_fields map (\\<lambda>(F, y). ((F, D'), y))\nfs @\n                                     pre @ FDTs;\n        y \\<in> dom (map_of\n                      (map (\\<lambda>(F, y). ((F, D'), y)) fs)) \\<inter>\n                dom (map_of FDTs)\\<rbrakk>\n       \\<Longrightarrow> False", "apply(auto dest: subcls_notin_has_fields simp:dom_map_of_conv_image_fst image_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma has_fields_is_class:\n  \"P \\<turnstile> C has_fields FDTs \\<Longrightarrow> is_class P C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow> is_class P C", "by (auto simp add: is_class_def elim: Fields.cases)"], ["", "lemma Object_has_fields_Object:\n  assumes \"P \\<turnstile> Object has_fields FDTs\"\n  shows \"snd ` fst ` set FDTs \\<subseteq> {Object}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ` fst ` set FDTs \\<subseteq> {Object}", "using assms"], ["proof (prove)\nusing this:\n  P \\<turnstile> Object has_fields FDTs\n\ngoal (1 subgoal):\n 1. snd ` fst ` set FDTs \\<subseteq> {Object}", "by cases auto"], ["", "definition\n  has_field :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> vname \\<Rightarrow> ty \\<Rightarrow> fmod \\<Rightarrow> cname \\<Rightarrow> bool\"\n                   (\"_ \\<turnstile> _ has _:_ '(_') in _\" [51,51,51,51,51,51] 50)\nwhere\n  \"P \\<turnstile> C has F:T (fm) in D  \\<equiv>\n  \\<exists>FDTs. P \\<turnstile> C has_fields FDTs \\<and> map_of FDTs (F,D) = Some (T, fm)\""], ["", "lemma has_field_mono:\n  \"\\<lbrakk> P \\<turnstile> C has F:T (fm) in D; P \\<turnstile> C' \\<preceq>\\<^sup>* C \\<rbrakk> \\<Longrightarrow> P \\<turnstile> C' has F:T (fm) in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C has F:T (fm) in D;\n     P \\<turnstile> C' \\<preceq>\\<^sup>* C\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> C' has F:T (fm) in D", "by(fastforce simp:has_field_def map_add_def dest: has_fields_mono_lem)"], ["", "lemma has_field_is_class:\n  \"P \\<turnstile> C has M:T (fm) in D \\<Longrightarrow> is_class P C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has M:T (fm) in D \\<Longrightarrow> is_class P C", "by (auto simp add: is_class_def has_field_def elim: Fields.cases)"], ["", "lemma has_field_decl_above:\n  \"P \\<turnstile> C has F:T (fm) in D \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has F:T (fm) in D \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "unfolding has_field_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>FDTs.\n       P \\<turnstile> C has_fields FDTs \\<and>\n       map_of FDTs (F, D) = \\<lfloor>(T, fm)\\<rfloor> \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "by(auto dest: map_of_SomeD has_fields_decl_above)"], ["", "lemma has_field_fun:\n  \"\\<lbrakk>P \\<turnstile> C has F:T (fm) in D; P \\<turnstile> C has F:T' (fm') in D\\<rbrakk> \\<Longrightarrow> T' = T \\<and> fm = fm'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C has F:T (fm) in D;\n     P \\<turnstile> C has F:T' (fm') in D\\<rbrakk>\n    \\<Longrightarrow> T' = T \\<and> fm = fm'", "by(auto simp:has_field_def dest:has_fields_fun)"], ["", "definition\n  sees_field :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> vname \\<Rightarrow> ty \\<Rightarrow> fmod \\<Rightarrow> cname \\<Rightarrow> bool\"\n                  (\"_ \\<turnstile> _ sees _:_ '(_') in _\" [51,51,51,51,51,51] 50)\nwhere\n  \"P \\<turnstile> C sees F:T (fm) in D  \\<equiv>\n  \\<exists>FDTs. P \\<turnstile> C has_fields FDTs \\<and>\n            map_of (map (\\<lambda>((F,D),Tm). (F,(D,Tm))) FDTs) F = Some(D,T,fm)\""], ["", "lemma map_of_remap_SomeD:\n  \"map_of (map (\\<lambda>((k,k'),x). (k,(k',x))) t) k = Some (k',x) \\<Longrightarrow> map_of t (k, k') = Some x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>((k, k'), x). (k, k', x)) t) k =\n    \\<lfloor>(k', x)\\<rfloor> \\<Longrightarrow>\n    map_of t (k, k') = \\<lfloor>x\\<rfloor>", "by (induct t) (auto simp:fun_upd_apply split: if_split_asm)"], ["", "lemma has_visible_field:\n  \"P \\<turnstile> C sees F:T (fm) in D \\<Longrightarrow> P \\<turnstile> C has F:T (fm) in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees F:T (fm) in D \\<Longrightarrow>\n    P \\<turnstile> C has F:T (fm) in D", "by(auto simp add:has_field_def sees_field_def map_of_remap_SomeD)"], ["", "lemma sees_field_fun:\n  \"\\<lbrakk>P \\<turnstile> C sees F:T (fm) in D; P \\<turnstile> C sees F:T' (fm') in D'\\<rbrakk> \\<Longrightarrow> T' = T \\<and> D' = D \\<and> fm = fm'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C sees F:T (fm) in D;\n     P \\<turnstile> C sees F:T' (fm') in D'\\<rbrakk>\n    \\<Longrightarrow> T' = T \\<and> D' = D \\<and> fm = fm'", "by(fastforce simp:sees_field_def dest:has_fields_fun)"], ["", "lemma sees_field_decl_above:\n  \"P \\<turnstile> C sees F:T (fm) in D \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees F:T (fm) in D \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "by(clarsimp simp add: sees_field_def)\n  (blast intro: has_fields_decl_above map_of_SomeD map_of_remap_SomeD)"], ["", "lemma sees_field_idemp:\n  assumes \"P \\<turnstile> C sees F:T (fm) in D\"\n  shows \"P \\<turnstile> D sees F:T (fm) in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> D sees F:T (fm) in D", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<turnstile> D sees F:T (fm) in D", "from assms"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees F:T (fm) in D", "obtain FDTs where has: \"P \\<turnstile> C has_fields FDTs\"\n    and F: \"map_of (map (\\<lambda>((F, D), Tm). (F, D, Tm)) FDTs) F = \\<lfloor>(D, T, fm)\\<rfloor>\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees F:T (fm) in D\n\ngoal (1 subgoal):\n 1. (\\<And>FDTs.\n        \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n         map_of (map (\\<lambda>((F, D), Tm). (F, D, Tm)) FDTs) F =\n         \\<lfloor>(D, T, fm)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding sees_field_def"], ["proof (prove)\nusing this:\n  \\<exists>FDTs.\n     P \\<turnstile> C has_fields FDTs \\<and>\n     map_of (map (\\<lambda>((F, D), Tm). (F, D, Tm)) FDTs) F =\n     \\<lfloor>(D, T, fm)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>FDTs.\n        \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n         map_of (map (\\<lambda>((F, D), Tm). (F, D, Tm)) FDTs) F =\n         \\<lfloor>(D, T, fm)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  P \\<turnstile> C has_fields FDTs\n  map_of (map (\\<lambda>((F, D), Tm). (F, D, Tm)) FDTs) F =\n  \\<lfloor>(D, T, fm)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D sees F:T (fm) in D", "thus ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n  map_of (map (\\<lambda>((F, D), Tm). (F, D, Tm)) FDTs) F =\n  \\<lfloor>(D, T, fm)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D sees F:T (fm) in D", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C Da fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        map_of (map (\\<lambda>((F, D), Tm). (F, D, Tm)) FDTs) F =\n        \\<lfloor>(D, T, fm)\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> D sees F:T (fm) in D;\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs;\n        map_of (map (\\<lambda>((F, D), Tm). (F, D, Tm)) FDTs') F =\n        \\<lfloor>(D, T, fm)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> D sees F:T (fm) in D\n 2. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs;\n        map_of (map (\\<lambda>((F, D), Tm). (F, D, Tm)) FDTs) F =\n        \\<lfloor>(D, T, fm)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> D sees F:T (fm) in D", "case has_fields_rec"], ["proof (state)\nthis:\n  class P C_ = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  C_ \\<noteq> Object\n  P \\<turnstile> D_ has_fields FDTs_\n  map_of\n   (map (\\<lambda>a.\n            case a of\n            (a, b) \\<Rightarrow>\n              (case a of (F, D) \\<Rightarrow> \\<lambda>Tm. (F, D, Tm)) b)\n     FDTs_)\n   F =\n  \\<lfloor>(D, T, fm)\\<rfloor> \\<Longrightarrow>\n  P \\<turnstile> D sees F:T (fm) in D\n  FDTs'_ = map (\\<lambda>(F, Tm). ((F, C_), Tm)) fs_ @ FDTs_\n  map_of\n   (map (\\<lambda>a.\n            case a of\n            (a, b) \\<Rightarrow>\n              (case a of (F, D) \\<Rightarrow> \\<lambda>Tm. (F, D, Tm)) b)\n     FDTs'_)\n   F =\n  \\<lfloor>(D, T, fm)\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>C Da fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        map_of (map (\\<lambda>((F, D), Tm). (F, D, Tm)) FDTs) F =\n        \\<lfloor>(D, T, fm)\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> D sees F:T (fm) in D;\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs;\n        map_of (map (\\<lambda>((F, D), Tm). (F, D, Tm)) FDTs') F =\n        \\<lfloor>(D, T, fm)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> D sees F:T (fm) in D\n 2. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs;\n        map_of (map (\\<lambda>((F, D), Tm). (F, D, Tm)) FDTs) F =\n        \\<lfloor>(D, T, fm)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> D sees F:T (fm) in D", "thus ?case"], ["proof (prove)\nusing this:\n  class P C_ = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  C_ \\<noteq> Object\n  P \\<turnstile> D_ has_fields FDTs_\n  map_of\n   (map (\\<lambda>a.\n            case a of\n            (a, b) \\<Rightarrow>\n              (case a of (F, D) \\<Rightarrow> \\<lambda>Tm. (F, D, Tm)) b)\n     FDTs_)\n   F =\n  \\<lfloor>(D, T, fm)\\<rfloor> \\<Longrightarrow>\n  P \\<turnstile> D sees F:T (fm) in D\n  FDTs'_ = map (\\<lambda>(F, Tm). ((F, C_), Tm)) fs_ @ FDTs_\n  map_of\n   (map (\\<lambda>a.\n            case a of\n            (a, b) \\<Rightarrow>\n              (case a of (F, D) \\<Rightarrow> \\<lambda>Tm. (F, D, Tm)) b)\n     FDTs'_)\n   F =\n  \\<lfloor>(D, T, fm)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D sees F:T (fm) in D", "unfolding sees_field_def"], ["proof (prove)\nusing this:\n  class P C_ = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  C_ \\<noteq> Object\n  P \\<turnstile> D_ has_fields FDTs_\n  map_of\n   (map (\\<lambda>a.\n            case a of\n            (a, b) \\<Rightarrow>\n              (case a of (F, D) \\<Rightarrow> \\<lambda>Tm. (F, D, Tm)) b)\n     FDTs_)\n   F =\n  \\<lfloor>(D, T, fm)\\<rfloor> \\<Longrightarrow>\n  \\<exists>FDTs.\n     P \\<turnstile> D has_fields FDTs \\<and>\n     map_of (map (\\<lambda>((F, D), Tm). (F, D, Tm)) FDTs) F =\n     \\<lfloor>(D, T, fm)\\<rfloor>\n  FDTs'_ = map (\\<lambda>(F, Tm). ((F, C_), Tm)) fs_ @ FDTs_\n  map_of\n   (map (\\<lambda>a.\n            case a of\n            (a, b) \\<Rightarrow>\n              (case a of (F, D) \\<Rightarrow> \\<lambda>Tm. (F, D, Tm)) b)\n     FDTs'_)\n   F =\n  \\<lfloor>(D, T, fm)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>FDTs.\n       P \\<turnstile> D has_fields FDTs \\<and>\n       map_of (map (\\<lambda>((F, D), Tm). (F, D, Tm)) FDTs) F =\n       \\<lfloor>(D, T, fm)\\<rfloor>", "by(auto)(fastforce dest: map_of_SomeD intro!: exI intro: Fields.has_fields_rec)"], ["proof (state)\nthis:\n  P \\<turnstile> D sees F:T (fm) in D\n\ngoal (1 subgoal):\n 1. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs;\n        map_of (map (\\<lambda>((F, D), Tm). (F, D, Tm)) FDTs) F =\n        \\<lfloor>(D, T, fm)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> D sees F:T (fm) in D", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs;\n        map_of (map (\\<lambda>((F, D), Tm). (F, D, Tm)) FDTs) F =\n        \\<lfloor>(D, T, fm)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> D sees F:T (fm) in D", "case has_fields_Object"], ["proof (state)\nthis:\n  class P Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  FDTs_ = map (\\<lambda>(F, T). ((F, Object), T)) fs_\n  map_of\n   (map (\\<lambda>a.\n            case a of\n            (a, b) \\<Rightarrow>\n              (case a of (F, D) \\<Rightarrow> \\<lambda>Tm. (F, D, Tm)) b)\n     FDTs_)\n   F =\n  \\<lfloor>(D, T, fm)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs;\n        map_of (map (\\<lambda>((F, D), Tm). (F, D, Tm)) FDTs) F =\n        \\<lfloor>(D, T, fm)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> D sees F:T (fm) in D", "thus ?case"], ["proof (prove)\nusing this:\n  class P Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  FDTs_ = map (\\<lambda>(F, T). ((F, Object), T)) fs_\n  map_of\n   (map (\\<lambda>a.\n            case a of\n            (a, b) \\<Rightarrow>\n              (case a of (F, D) \\<Rightarrow> \\<lambda>Tm. (F, D, Tm)) b)\n     FDTs_)\n   F =\n  \\<lfloor>(D, T, fm)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D sees F:T (fm) in D", "unfolding sees_field_def"], ["proof (prove)\nusing this:\n  class P Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  FDTs_ = map (\\<lambda>(F, T). ((F, Object), T)) fs_\n  map_of\n   (map (\\<lambda>a.\n            case a of\n            (a, b) \\<Rightarrow>\n              (case a of (F, D) \\<Rightarrow> \\<lambda>Tm. (F, D, Tm)) b)\n     FDTs_)\n   F =\n  \\<lfloor>(D, T, fm)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>FDTs.\n       P \\<turnstile> D has_fields FDTs \\<and>\n       map_of (map (\\<lambda>((F, D), Tm). (F, D, Tm)) FDTs) F =\n       \\<lfloor>(D, T, fm)\\<rfloor>", "by(fastforce dest: map_of_SomeD intro: Fields.has_fields_Object intro!: exI)"], ["proof (state)\nthis:\n  P \\<turnstile> D sees F:T (fm) in D\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P \\<turnstile> D sees F:T (fm) in D\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Functional lookup\""], ["", "definition \"method\" :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> mname \\<Rightarrow> cname \\<times> ty list \\<times> ty \\<times> 'm option\"\nwhere \"method P C M  \\<equiv>  THE (D,Ts,T,m). P \\<turnstile> C sees M:Ts \\<rightarrow> T = m in D\""], ["", "definition field  :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> vname \\<Rightarrow> cname \\<times> ty \\<times> fmod\"\nwhere \"field P C F  \\<equiv>  THE (D,T,fm). P \\<turnstile> C sees F:T (fm) in D\""], ["", "definition fields :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> ((vname \\<times> cname) \\<times> (ty \\<times> fmod)) list\" \nwhere \"fields P C  \\<equiv>  THE FDTs. P \\<turnstile> C has_fields FDTs\""], ["", "lemma [simp]: \"P \\<turnstile> C has_fields FDTs \\<Longrightarrow> fields P C = FDTs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    TypeRel.fields P C = FDTs", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    TypeRel.fields P C = FDTs", "by (unfold fields_def) (auto dest: has_fields_fun)"], ["", "(*>*)"], ["", "lemma field_def2 [simp]: \"P \\<turnstile> C sees F:T (fm) in D \\<Longrightarrow> field P C F = (D,T,fm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees F:T (fm) in D \\<Longrightarrow>\n    field P C F = (D, T, fm)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees F:T (fm) in D \\<Longrightarrow>\n    field P C F = (D, T, fm)", "by (unfold field_def) (auto dest: sees_field_fun)"], ["", "(*>*)"], ["", "lemma method_def2 [simp]: \"P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow> method P C M = (D,Ts,T,m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    method P C M = (D, Ts, T, m)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    method P C M = (D, Ts, T, m)", "by (unfold method_def) (auto dest: sees_method_fun)"], ["", "(*>*)"], ["", "lemma has_fields_b_fields: \n  \"P \\<turnstile> C has_fields FDTs \\<Longrightarrow> fields P C = FDTs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    TypeRel.fields P C = FDTs", "unfolding fields_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    (THE FDTs. P \\<turnstile> C has_fields FDTs) = FDTs", "by (blast intro: the_equality has_fields_fun)"], ["", "lemma has_field_map_of_fields [simp]:\n  \"P \\<turnstile> C has F:T (fm) in D \\<Longrightarrow> map_of (fields P C) (F, D) = \\<lfloor>(T, fm)\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has F:T (fm) in D \\<Longrightarrow>\n    map_of (TypeRel.fields P C) (F, D) = \\<lfloor>(T, fm)\\<rfloor>", "by(auto simp add: has_field_def)"], ["", "subsection \\<open>Code generation\\<close>"], ["", "text \\<open>New introduction rules for subcls1\\<close>"], ["", "code_pred\n  \\<comment> \\<open>Disallow mode @{text \"i_o_o\"} to force @{text code_pred} in subsequent predicates not to use this inefficient mode\\<close>\n  (modes: i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> bool, i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> bool) \n  subcls1"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text \\<open>\n  Introduce proper constant \\<open>subcls'\\<close> for @{term \"subcls\"}\n  and generate executable equation for \\<open>subcls'\\<close> \n\\<close>"], ["", "definition subcls' where \"subcls' = subcls\""], ["", "code_pred\n  (modes: i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> bool, i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> bool)\n  [inductify]\n  subcls'"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma subcls_conv_subcls' [code_unfold]:\n  \"(subcls1 P)^** = subcls' P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subcls P = subcls' P", "by(simp add: subcls'_def)"], ["", "text \\<open>\n  Change rule @{thm widen_array_object} such that predicate compiler\n  tests on class @{term Object} first. Otherwise \\<open>widen_i_o_i\\<close> never terminates.\n\\<close>"], ["", "lemma widen_array_object_code:\n  \"C = Object \\<Longrightarrow> P \\<turnstile> Array A \\<le> Class C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C = Object \\<Longrightarrow>\n    P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> Class C", "by(auto intro: widen.intros)"], ["", "lemmas [code_pred_intro] =\n  widen_refl widen_subcls widen_null widen_null_array widen_array_object_code widen_array_array"], ["", "code_pred \n  (modes: i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> bool)\n  widen"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<turnstile> xa \\<le> xb;\n     \\<And>P T.\n        \\<lbrakk>x = P; xa = T; xb = T\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<And>Pa_ C_ D_.\n        \\<lbrakk>x = Pa_; xa = Class C_; xb = Class D_;\n         Pa_ \\<turnstile> C_ \\<preceq>\\<^sup>* D_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>Pa_ C_.\n        \\<lbrakk>x = Pa_; xa = NT; xb = Class C_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>Pa_ A_.\n        \\<lbrakk>x = Pa_; xa = NT; xb = A_\\<lfloor>\\<rceil>\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>Pa_ A_ C_.\n        \\<lbrakk>x = Pa_; xa = A_\\<lfloor>\\<rceil>; xb = Class C_;\n         C_ = Object\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>Pa_ A_ B_.\n        \\<lbrakk>x = Pa_; xa = A_\\<lfloor>\\<rceil>;\n         xb = B_\\<lfloor>\\<rceil>; Pa_ \\<turnstile> A_ \\<le> B_\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(erule widen.cases) auto"], ["", "text \\<open>\n  Readjust the code equations for @{term widen} such that @{term widen_i_i_i} is guaranteed to\n  contain @{term \"()\"} at most once (even in the code representation!). This is important\n  for the scheduler and the small-step semantics because of the weaker code equations\n  for @{term \"the\"}.\n\n  A similar problem cannot hit the subclass relation because, for acyclic subclass hierarchies, \n  the paths in the hieararchy are unique and cycle-free.\n\\<close>"], ["", "definition widen_i_i_i' where \"widen_i_i_i' = widen_i_i_i\""], ["", "declare widen.equation [code del]"], ["", "lemmas widen_i_i_i'_equation [code] = widen.equation[folded widen_i_i_i'_def]"], ["", "lemma widen_i_i_i_code [code]:\n  \"widen_i_i_i P T T' = (if P \\<turnstile> T \\<le> T' then Predicate.single () else bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. widen_i_i_i P T T' =\n    (if P \\<turnstile> T \\<le> T' then Predicate.single () else bot)", "by(auto intro!: pred_eqI intro: widen_i_i_iI elim: widen_i_i_iE)"], ["", "code_pred \n  (modes: i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> bool, i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> bool)\n  Methods"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "code_pred \n  (modes: i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> o \\<Rightarrow> o \\<Rightarrow> o \\<Rightarrow> bool, i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> o \\<Rightarrow> o \\<Rightarrow> i \\<Rightarrow> bool)\n  [inductify]\n  Method"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "code_pred \n  (modes: i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> bool)\n  [inductify]\n  has_method"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "(* FIXME: Necessary only because of bug in code_pred *)"], ["", "declare fun_upd_def [code_pred_inline]"], ["", "code_pred \n  (modes: i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> bool)\n  Fields"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "code_pred\n  (modes: i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> o \\<Rightarrow> i \\<Rightarrow> bool)\n  [inductify, skip_proof]\n  has_field"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "code_pred\n  (modes: i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> o \\<Rightarrow> o \\<Rightarrow> bool, i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> o \\<Rightarrow> i \\<Rightarrow> bool)\n  [inductify, skip_proof]\n  sees_field"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma eval_Method_i_i_i_o_o_o_o_conv:\n  \"Predicate.eval (Method_i_i_i_o_o_o_o P C M) = (\\<lambda>(Ts, T, m, D). P \\<turnstile> C sees M:Ts\\<rightarrow>T=m in D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred.eval (Method_i_i_i_o_o_o_o P C M) =\n    (\\<lambda>(Ts, T, m, D).\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D)", "by(auto intro: Method_i_i_i_o_o_o_oI elim: Method_i_i_i_o_o_o_oE intro!: ext)"], ["", "lemma method_code [code]:\n  \"method P C M = \n  Predicate.the (Predicate.bind (Method_i_i_i_o_o_o_o P C M) (\\<lambda>(Ts, T, m, D). Predicate.single (D, Ts, T, m)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. method P C M =\n    Predicate.the\n     (Method_i_i_i_o_o_o_o P C M \\<bind>\n      (\\<lambda>(Ts, T, m, D). Predicate.single (D, Ts, T, m)))", "apply (rule sym, rule the_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE x.\n        pred.eval\n         (Method_i_i_i_o_o_o_o P C M \\<bind>\n          (\\<lambda>(Ts, T, m, D). Predicate.single (D, Ts, T, m)))\n         x) =\n    method P C M", "apply (simp add: method_def eval_Method_i_i_i_o_o_o_o_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE x.\n        \\<exists>a aa ab b.\n           P \\<turnstile> C sees M: a\\<rightarrow>aa = ab in b \\<and>\n           (b, a, aa, ab) = x) =\n    (THE (D, Ts, T, m). P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D)", "apply (rule arg_cong [where f=The])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        \\<exists>a aa ab b.\n           P \\<turnstile> C sees M: a\\<rightarrow>aa = ab in b \\<and>\n           (b, a, aa, ab) = x) =\n    (\\<lambda>(D, Ts, T, m).\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D)", "apply (auto simp add: Sup_fun_def Sup_bool_def fun_eq_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma eval_sees_field_i_i_i_o_o_o_conv:\n  \"Predicate.eval (sees_field_i_i_i_o_o_o P C F) = (\\<lambda>(T, fm, D). P \\<turnstile> C sees F:T (fm) in D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred.eval (sees_field_i_i_i_o_o_o P C F) =\n    (\\<lambda>(T, fm, D). P \\<turnstile> C sees F:T (fm) in D)", "by(auto intro!: ext intro: sees_field_i_i_i_o_o_oI elim: sees_field_i_i_i_o_o_oE)"], ["", "lemma eval_sees_field_i_i_i_o_i_conv:\n  \"Predicate.eval (sees_field_i_i_i_o_o_i P C F D) = (\\<lambda>(T, fm). P \\<turnstile> C sees F:T (fm) in D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred.eval (sees_field_i_i_i_o_o_i P C F D) =\n    (\\<lambda>(T, fm). P \\<turnstile> C sees F:T (fm) in D)", "by(auto intro!: ext intro: sees_field_i_i_i_o_o_iI elim: sees_field_i_i_i_o_o_iE)"], ["", "lemma field_code [code]:\n  \"field P C F = Predicate.the (Predicate.bind (sees_field_i_i_i_o_o_o P C F) (\\<lambda>(T, fm, D). Predicate.single (D, T, fm)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. field P C F =\n    Predicate.the\n     (sees_field_i_i_i_o_o_o P C F \\<bind>\n      (\\<lambda>(T, fm, D). Predicate.single (D, T, fm)))", "apply (rule sym, rule the_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE x.\n        pred.eval\n         (sees_field_i_i_i_o_o_o P C F \\<bind>\n          (\\<lambda>(T, fm, D). Predicate.single (D, T, fm)))\n         x) =\n    field P C F", "apply (simp add: field_def eval_sees_field_i_i_i_o_o_o_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE x.\n        \\<exists>a aa b.\n           P \\<turnstile> C sees F:a (aa) in b \\<and> (b, a, aa) = x) =\n    (THE (D, T, fm). P \\<turnstile> C sees F:T (fm) in D)", "apply (rule arg_cong [where f=The])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        \\<exists>a aa b.\n           P \\<turnstile> C sees F:a (aa) in b \\<and> (b, a, aa) = x) =\n    (\\<lambda>(D, T, fm). P \\<turnstile> C sees F:T (fm) in D)", "apply (auto simp add: Sup_fun_def Sup_bool_def fun_eq_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma eval_Fields_conv:\n  \"Predicate.eval (Fields_i_i_o P C) = (\\<lambda>FDTs. P \\<turnstile> C has_fields FDTs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred.eval (Fields_i_i_o P C) = Fields P C", "by(auto intro: Fields_i_i_oI elim: Fields_i_i_oE intro!: ext)"], ["", "lemma fields_code [code]:\n  \"fields P C = Predicate.the (Fields_i_i_o P C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TypeRel.fields P C = Predicate.the (Fields_i_i_o P C)", "by(simp add: fields_def Predicate.the_def eval_Fields_conv)"], ["", "code_identifier\n  code_module TypeRel \\<rightharpoonup>\n    (SML) TypeRel and (Haskell) TypeRel and (OCaml) TypeRel\n| code_module Decl \\<rightharpoonup>\n    (SML) TypeRel and (Haskell) TypeRel and (OCaml) TypeRel"], ["", "end"]]}