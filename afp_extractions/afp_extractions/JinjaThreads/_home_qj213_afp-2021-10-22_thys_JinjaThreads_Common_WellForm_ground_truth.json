{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Common/WellForm.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma wf_prog_def2:\n  \"wf_prog wf_md P \\<longleftrightarrow> wf_syscls P \\<and> (\\<forall>C rest. class P C = \\<lfloor>rest\\<rfloor> \\<longrightarrow> wf_cdecl wf_md P (C, rest)) \\<and> distinct_fst (classes P)\"", "lemma wf_prog_wf_syscls: \"wf_prog wf_md P \\<Longrightarrow> wf_syscls P\"", "lemma class_wf: \n  \"\\<lbrakk>class P C = Some c; wf_prog wf_md P\\<rbrakk> \\<Longrightarrow> wf_cdecl wf_md P (C,c)\"", "lemma [simp]:\n  assumes \"wf_prog wf_md P\"\n  shows class_Object: \"\\<exists>C fs ms. class P Object = Some (C,fs,ms)\"\n  and class_Thread:  \"\\<exists>C fs ms. class P Thread = Some (C,fs,ms)\"", "lemma [simp]:\n  assumes \"wf_prog wf_md P\"\n  shows is_class_Object: \"is_class P Object\"\n  and is_class_Thread: \"is_class P Thread\"", "lemma xcpt_subcls_Throwable:\n  \"\\<lbrakk> C \\<in> sys_xcpts; wf_prog wf_md P \\<rbrakk> \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* Throwable\"", "lemma is_class_Throwable:\n  \"wf_prog wf_md P \\<Longrightarrow> is_class P Throwable\"", "lemma is_class_sub_Throwable:\n  \"\\<lbrakk> wf_prog wf_md P; P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<rbrakk> \\<Longrightarrow> is_class P C\"", "lemma is_class_xcpt:\n  \"\\<lbrakk> C \\<in> sys_xcpts; wf_prog wf_md P \\<rbrakk> \\<Longrightarrow> is_class P C\"", "lemma wf_preallocatedE:\n  assumes \"wf_prog wf_md P\"\n  and \"preallocated h\"\n  and \"C \\<in> sys_xcpts\"\n  obtains \"typeof_addr h (addr_of_sys_xcpt C) = \\<lfloor>Class_type C\\<rfloor>\" \"P \\<turnstile> C \\<preceq>\\<^sup>* Throwable\"", "lemma wf_preallocatedD:\n  assumes \"wf_prog wf_md P\"\n  and \"preallocated h\"\n  and \"C \\<in> sys_xcpts\"\n  shows \"typeof_addr h (addr_of_sys_xcpt C) = \\<lfloor>Class_type C\\<rfloor> \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* Throwable\"", "lemma (in heap_conf) hconf_start_heap:\n  \"wf_prog wf_md P \\<Longrightarrow> hconf start_heap\"", "lemma subcls1_wfD:\n  \"\\<lbrakk> P \\<turnstile> C \\<prec>\\<^sup>1 D; wf_prog wf_md P \\<rbrakk> \\<Longrightarrow> D \\<noteq> C \\<and> \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D C\"", "lemma wf_cdecl_supD: \n  \"\\<lbrakk>wf_cdecl wf_md P (C,D,r); C \\<noteq> Object\\<rbrakk> \\<Longrightarrow> is_class P D\"", "lemma subcls_asym:\n  \"\\<lbrakk> wf_prog wf_md P; (subcls1 P)\\<^sup>+\\<^sup>+ C D \\<rbrakk> \\<Longrightarrow> \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D C\"", "lemma subcls_irrefl:\n  \"\\<lbrakk> wf_prog wf_md P; (subcls1 P)\\<^sup>+\\<^sup>+ C D\\<rbrakk> \\<Longrightarrow> C \\<noteq> D\"", "lemma acyclicP_def:\n  \"acyclicP r \\<longleftrightarrow> (\\<forall>x. \\<not> r^++ x x)\"", "lemma acyclic_subcls1:\n  \"wf_prog wf_md P \\<Longrightarrow> acyclicP (subcls1 P)\"", "lemma finite_conversep: \"finite {(x, y). r\\<inverse>\\<inverse> x y} = finite {(x, y). r x y}\"", "lemma acyclicP_wf_subcls1:\n  \"acyclicP (subcls1 P) \\<Longrightarrow> wfP ((subcls1 P)\\<inverse>\\<inverse>)\"", "lemma wf_subcls1:\n  \"wf_prog wf_md P \\<Longrightarrow> wfP ((subcls1 P)\\<inverse>\\<inverse>)\"", "lemma single_valued_subcls1:\n  \"wf_prog wf_md G \\<Longrightarrow> single_valuedp (subcls1 G)\"", "lemma subcls_induct: \n  \"\\<lbrakk> wf_prog wf_md P; \\<And>C. \\<forall>D. (subcls1 P)\\<^sup>+\\<^sup>+ C D \\<longrightarrow> Q D \\<Longrightarrow> Q C \\<rbrakk> \\<Longrightarrow> Q C\"\n(*<*)\n  (is \"?A \\<Longrightarrow> PROP ?P \\<Longrightarrow> _\")", "lemma subcls1_induct_aux:\n  \"\\<lbrakk> is_class P C; wf_prog wf_md P; Q Object;\n    \\<And>C D fs ms.\n    \\<lbrakk> C \\<noteq> Object; is_class P C; class P C = Some (D,fs,ms) \\<and>\n      wf_cdecl wf_md P (C,D,fs,ms) \\<and> P \\<turnstile> C \\<prec>\\<^sup>1 D \\<and> is_class P D \\<and> Q D\\<rbrakk> \\<Longrightarrow> Q C \\<rbrakk>\n  \\<Longrightarrow> Q C\"\n(*<*)\n  (is \"?A \\<Longrightarrow> ?B \\<Longrightarrow> ?C \\<Longrightarrow> PROP ?P \\<Longrightarrow> _\")", "lemma subcls1_induct [consumes 2, case_names Object Subcls]:\n  \"\\<lbrakk> wf_prog wf_md P; is_class P C; Q Object;\n    \\<And>C D. \\<lbrakk>C \\<noteq> Object; P \\<turnstile> C \\<prec>\\<^sup>1 D; is_class P D; Q D\\<rbrakk> \\<Longrightarrow> Q C \\<rbrakk>\n  \\<Longrightarrow> Q C\"", "lemma subcls_C_Object:\n  \"\\<lbrakk> is_class P C; wf_prog wf_md P \\<rbrakk> \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* Object\"", "lemma converse_subcls_is_class:\n  assumes wf: \"wf_prog wf_md P\"\n  shows \"\\<lbrakk> P \\<turnstile> C \\<preceq>\\<^sup>* D; is_class P C \\<rbrakk> \\<Longrightarrow> is_class P D\"", "lemma is_class_is_subcls:\n  \"wf_prog m P \\<Longrightarrow> is_class P C = P \\<turnstile> C \\<preceq>\\<^sup>* Object\"", "lemma subcls_antisym:\n  \"\\<lbrakk>wf_prog m P; P \\<turnstile> C \\<preceq>\\<^sup>* D; P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk> \\<Longrightarrow> C = D\"", "lemma is_type_pTs:\n  \"\\<lbrakk> wf_prog wf_md P; class P C = \\<lfloor>(S,fs,ms)\\<rfloor>; (M,Ts,T,m) \\<in> set ms \\<rbrakk> \\<Longrightarrow> set Ts \\<subseteq> types P\"", "lemma widen_asym_1: \n  assumes wfP: \"wf_prog wf_md P\"\n  shows \"P \\<turnstile> C \\<le> D \\<Longrightarrow> C = D \\<or> \\<not> (P \\<turnstile> D \\<le> C)\"", "lemma widen_asym: \"\\<lbrakk> wf_prog wf_md P; P \\<turnstile> C \\<le> D; C \\<noteq> D \\<rbrakk> \\<Longrightarrow> \\<not> (P \\<turnstile> D \\<le> C)\"", "lemma widen_antisym:\n  \"\\<lbrakk> wf_prog m P; P \\<turnstile> T \\<le> U; P \\<turnstile> U \\<le> T \\<rbrakk> \\<Longrightarrow> T = U\"", "lemma widen_C_Object: \"\\<lbrakk> wf_prog wf_md P; is_class P C \\<rbrakk> \\<Longrightarrow> P \\<turnstile> Class C \\<le> Class Object\"", "lemma is_refType_widen_Object:\n  assumes wfP: \"wf_prog wfmc P\"\n  shows \"\\<lbrakk> is_type P A; is_refT A \\<rbrakk> \\<Longrightarrow> P \\<turnstile> A \\<le> Class Object\"", "lemma is_lub_unique:\n  assumes wf: \"wf_prog wf_md P\"\n  shows \"\\<lbrakk> P \\<turnstile> lub(U, V) = T; P \\<turnstile> lub(U, V) = T' \\<rbrakk> \\<Longrightarrow> T = T'\"", "lemma sees_wf_mdecl:\n  \"\\<lbrakk> wf_prog wf_md P; P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in D \\<rbrakk> \\<Longrightarrow> wf_mdecl wf_md P D (M,Ts,T,m)\"", "lemma sees_method_mono [rule_format (no_asm)]: \n  \"\\<lbrakk> P \\<turnstile> C' \\<preceq>\\<^sup>* C; wf_prog wf_md P \\<rbrakk> \\<Longrightarrow>\n  \\<forall>D Ts T m. P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in D \\<longrightarrow>\n     (\\<exists>D' Ts' T' m'. P \\<turnstile> C' sees M:Ts'\\<rightarrow>T' = m' in D' \\<and> P \\<turnstile> Ts [\\<le>] Ts' \\<and> P \\<turnstile> T' \\<le> T)\"", "lemma sees_method_mono2:\n  \"\\<lbrakk> P \\<turnstile> C' \\<preceq>\\<^sup>* C; wf_prog wf_md P;\n     P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in D; P \\<turnstile> C' sees M:Ts'\\<rightarrow>T' = m' in D' \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> Ts [\\<le>] Ts' \\<and> P \\<turnstile> T' \\<le> T\"", "lemma mdecls_visible:\n  assumes wf: \"wf_prog wf_md P\" and \"class\": \"is_class P C\"\n  shows \"\\<And>D fs ms. class P C = Some(D,fs,ms)\n         \\<Longrightarrow> \\<exists>Mm. P \\<turnstile> C sees_methods Mm \\<and> (\\<forall>(M,Ts,T,m) \\<in> set ms. Mm M = Some((Ts,T,m),C))\"", "lemma mdecl_visible:\n  assumes wf: \"wf_prog wf_md P\" and C: \"class P C = \\<lfloor>(S,fs,ms)\\<rfloor>\" and  m: \"(M,Ts,T,m) \\<in> set ms\"\n  shows \"P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in C\"", "lemma sees_wf_native:\n  \"\\<lbrakk> wf_prog wf_md P; P \\<turnstile> C sees M:Ts\\<rightarrow>T=Native in D \\<rbrakk> \\<Longrightarrow> D\\<bullet>M(Ts) :: T\"", "lemma Call_lemma:\n  \"\\<lbrakk> P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in D; P \\<turnstile> C' \\<preceq>\\<^sup>* C; wf_prog wf_md P \\<rbrakk>\n  \\<Longrightarrow> \\<exists>D' Ts' T' m'.\n       P \\<turnstile> C' sees M:Ts'\\<rightarrow>T' = m' in D' \\<and> P \\<turnstile> Ts [\\<le>] Ts' \\<and> P \\<turnstile> T' \\<le> T \\<and> P \\<turnstile> C' \\<preceq>\\<^sup>* D'\n       \\<and> is_type P T' \\<and> (\\<forall>T\\<in>set Ts'. is_type P T) \\<and> (m' \\<noteq> Native \\<longrightarrow> wf_md P D' (M,Ts',T',the m'))\"", "lemma sub_Thread_sees_run:\n  assumes wf: \"wf_prog wf_md P\"\n  and PCThread: \"P \\<turnstile> C \\<preceq>\\<^sup>* Thread\"\n  shows \"\\<exists>D mthd. P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>mthd\\<rfloor> in D\"", "lemma wf_prog_lift:\n  assumes wf: \"wf_prog (\\<lambda>P C bd. A P C bd) P\"\n  and rule:\n  \"\\<And>wf_md C M Ts C T m.\n   \\<lbrakk> wf_prog wf_md P; P \\<turnstile> C sees M:Ts\\<rightarrow>T = \\<lfloor>m\\<rfloor> in C; is_class P C; set Ts \\<subseteq> types P; A P C (M,Ts,T,m) \\<rbrakk>\n   \\<Longrightarrow> B P C (M,Ts,T,m)\"\n  shows \"wf_prog (\\<lambda>P C bd. B P C bd) P\"", "lemma wf_Fields_Ex:\n  \"\\<lbrakk> wf_prog wf_md P; is_class P C \\<rbrakk> \\<Longrightarrow> \\<exists>FDTs. P \\<turnstile> C has_fields FDTs\"", "lemma has_fields_types:\n  \"\\<lbrakk> P \\<turnstile> C has_fields FDTs; (FD, T, fm) \\<in> set FDTs; wf_prog wf_md P \\<rbrakk> \\<Longrightarrow> is_type P T\"", "lemma sees_field_is_type:\n  \"\\<lbrakk> P \\<turnstile> C sees F:T (fm) in D; wf_prog wf_md P \\<rbrakk> \\<Longrightarrow> is_type P T\"", "lemma wf_has_field_mono2:\n  assumes wf: \"wf_prog wf_md P\"\n  and has: \"P \\<turnstile> C has F:T (fm) in E\"\n  shows \"\\<lbrakk> P \\<turnstile> C \\<preceq>\\<^sup>* D; P \\<turnstile> D \\<preceq>\\<^sup>* E \\<rbrakk> \\<Longrightarrow> P \\<turnstile> D has F:T (fm) in E\"", "lemma wf_has_field_idemp:\n  \"\\<lbrakk> wf_prog wf_md P; P \\<turnstile> C has F:T (fm) in D \\<rbrakk> \\<Longrightarrow> P \\<turnstile> D has F:T (fm) in D\"", "lemma map_of_remap_conv:\n  \"\\<lbrakk> distinct_fst fs; map_of (map (\\<lambda>(F, y). ((F, D), y)) fs) (F, D) = \\<lfloor>T\\<rfloor> \\<rbrakk>\n  \\<Longrightarrow> map_of (map (\\<lambda>((F, D), T). (F, D, T)) (map (\\<lambda>(F, y). ((F, D), y)) fs)) F = \\<lfloor>(D, T)\\<rfloor>\"", "lemma has_field_idemp_sees_field:\n  assumes wf: \"wf_prog wf_md P\"\n  and has: \"P \\<turnstile> D has F:T (fm) in D\"\n  shows \"P \\<turnstile> D sees F:T (fm) in D\"", "lemma has_fields_distinct:\n  assumes wf: \"wf_prog wf_md P\"\n  and \"P \\<turnstile> C has_fields FDTs\"\n  shows \"distinct (map fst FDTs)\"", "lemma acyclic_class_hierarchy_code [code]:\n  \"acyclic_class_hierarchy P \\<longleftrightarrow> (\\<forall>(C, D, fs, ml) \\<in> set (classes P). C \\<noteq> Object \\<longrightarrow> \\<not> subcls' P D C)\"", "lemma wf_cdecl'_code [code]:\n  \"wf_cdecl' wf_md P = (\\<lambda>(C,(D,fs,ms)).\n  (\\<forall>f\\<in>set fs. wf_fdecl P f) \\<and>  distinct_fst fs \\<and>\n  (\\<forall>m\\<in>set ms. wf_mdecl wf_md P C m) \\<and>\n  distinct_fst ms \\<and>\n  (C \\<noteq> Object \\<longrightarrow> is_class P D \\<and> (\\<forall>m\\<in>set ms. wf_overriding P D m)) \\<and>\n  (C = Thread \\<longrightarrow> ((run, [], Void) \\<in> set (map (\\<lambda>(M, Ts, T, b). (M, Ts, T)) ms))))\"", "lemma wf_prog_code [code]:\n  \"wf_prog wf_md P \\<longleftrightarrow>\n   acyclic_class_hierarchy P \\<and>\n   wf_syscls P \\<and> distinct_fst (classes P) \\<and>\n   (\\<forall>c \\<in> set (classes P). wf_cdecl' wf_md P c)\""], "translations": [["", "lemma wf_prog_def2:\n  \"wf_prog wf_md P \\<longleftrightarrow> wf_syscls P \\<and> (\\<forall>C rest. class P C = \\<lfloor>rest\\<rfloor> \\<longrightarrow> wf_cdecl wf_md P (C, rest)) \\<and> distinct_fst (classes P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_md P =\n    (wf_syscls P \\<and>\n     (\\<forall>C rest.\n         class P C = \\<lfloor>rest\\<rfloor> \\<longrightarrow>\n         wf_cdecl wf_md P (C, rest)) \\<and>\n     distinct_fst (classes P))", "by(cases P)(auto simp add: wf_prog_def dest: map_of_SomeD map_of_SomeI)"], ["", "subsection\\<open>Well-formedness lemmas\\<close>"], ["", "lemma wf_prog_wf_syscls: \"wf_prog wf_md P \\<Longrightarrow> wf_syscls P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_md P \\<Longrightarrow> wf_syscls P", "by(simp add: wf_prog_def)"], ["", "lemma class_wf: \n  \"\\<lbrakk>class P C = Some c; wf_prog wf_md P\\<rbrakk> \\<Longrightarrow> wf_cdecl wf_md P (C,c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>class P C = \\<lfloor>c\\<rfloor>; wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> wf_cdecl wf_md P (C, c)", "by (cases P) (fastforce dest: map_of_SomeD simp add: wf_prog_def)"], ["", "lemma [simp]:\n  assumes \"wf_prog wf_md P\"\n  shows class_Object: \"\\<exists>C fs ms. class P Object = Some (C,fs,ms)\"\n  and class_Thread:  \"\\<exists>C fs ms. class P Thread = Some (C,fs,ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C fs ms. class P Object = \\<lfloor>(C, fs, ms)\\<rfloor> &&&\n    \\<exists>C fs ms. class P Thread = \\<lfloor>(C, fs, ms)\\<rfloor>", "using wf_prog_wf_syscls[OF assms]"], ["proof (prove)\nusing this:\n  wf_syscls P\n\ngoal (1 subgoal):\n 1. \\<exists>C fs ms. class P Object = \\<lfloor>(C, fs, ms)\\<rfloor> &&&\n    \\<exists>C fs ms. class P Thread = \\<lfloor>(C, fs, ms)\\<rfloor>", "by(rule wf_syscls_class_Object wf_syscls_class_Thread)+"], ["", "lemma [simp]:\n  assumes \"wf_prog wf_md P\"\n  shows is_class_Object: \"is_class P Object\"\n  and is_class_Thread: \"is_class P Thread\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_class P Object &&& is_class P Thread", "using wf_prog_wf_syscls[OF assms]"], ["proof (prove)\nusing this:\n  wf_syscls P\n\ngoal (1 subgoal):\n 1. is_class P Object &&& is_class P Thread", "by simp_all"], ["", "lemma xcpt_subcls_Throwable:\n  \"\\<lbrakk> C \\<in> sys_xcpts; wf_prog wf_md P \\<rbrakk> \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* Throwable\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> sys_xcpts; wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* Throwable", "by(simp add: wf_prog_wf_syscls wf_syscls_xcpt_subcls_Throwable)"], ["", "lemma is_class_Throwable:\n  \"wf_prog wf_md P \\<Longrightarrow> is_class P Throwable\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_md P \\<Longrightarrow> is_class P Throwable", "by(rule wf_prog_wf_syscls wf_syscls_is_class_Throwable)+"], ["", "lemma is_class_sub_Throwable:\n  \"\\<lbrakk> wf_prog wf_md P; P \\<turnstile> C \\<preceq>\\<^sup>* Throwable \\<rbrakk> \\<Longrightarrow> is_class P C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P;\n     P \\<turnstile> C \\<preceq>\\<^sup>* Throwable\\<rbrakk>\n    \\<Longrightarrow> is_class P C", "by(rule wf_syscls_is_class_sub_Throwable[OF wf_prog_wf_syscls])"], ["", "lemma is_class_xcpt:\n  \"\\<lbrakk> C \\<in> sys_xcpts; wf_prog wf_md P \\<rbrakk> \\<Longrightarrow> is_class P C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> sys_xcpts; wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> is_class P C", "by(rule wf_syscls_is_class_xcpt[OF _ wf_prog_wf_syscls])"], ["", "context heap_base begin"], ["", "lemma wf_preallocatedE:\n  assumes \"wf_prog wf_md P\"\n  and \"preallocated h\"\n  and \"C \\<in> sys_xcpts\"\n  obtains \"typeof_addr h (addr_of_sys_xcpt C) = \\<lfloor>Class_type C\\<rfloor>\" \"P \\<turnstile> C \\<preceq>\\<^sup>* Throwable\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>typeof_addr h (addr_of_sys_xcpt C) =\n              \\<lfloor>Class_type C\\<rfloor>;\n      P \\<turnstile> C \\<preceq>\\<^sup>* Throwable\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lbrakk>typeof_addr h (addr_of_sys_xcpt C) =\n              \\<lfloor>Class_type C\\<rfloor>;\n      P \\<turnstile> C \\<preceq>\\<^sup>* Throwable\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>preallocated h\\<close> \\<open>C \\<in> sys_xcpts\\<close>"], ["proof (chain)\npicking this:\n  preallocated h\n  C \\<in> sys_xcpts", "have \"typeof_addr h (addr_of_sys_xcpt C) = \\<lfloor>Class_type C\\<rfloor>\""], ["proof (prove)\nusing this:\n  preallocated h\n  C \\<in> sys_xcpts\n\ngoal (1 subgoal):\n 1. typeof_addr h (addr_of_sys_xcpt C) = \\<lfloor>Class_type C\\<rfloor>", "by(rule typeof_addr_sys_xcp)"], ["proof (state)\nthis:\n  typeof_addr h (addr_of_sys_xcpt C) = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>typeof_addr h (addr_of_sys_xcpt C) =\n              \\<lfloor>Class_type C\\<rfloor>;\n      P \\<turnstile> C \\<preceq>\\<^sup>* Throwable\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  typeof_addr h (addr_of_sys_xcpt C) = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>typeof_addr h (addr_of_sys_xcpt C) =\n              \\<lfloor>Class_type C\\<rfloor>;\n      P \\<turnstile> C \\<preceq>\\<^sup>* Throwable\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>C \\<in> sys_xcpts\\<close> \\<open>wf_prog wf_md P\\<close>"], ["proof (chain)\npicking this:\n  C \\<in> sys_xcpts\n  wf_prog wf_md P", "have \"P \\<turnstile> C \\<preceq>\\<^sup>* Throwable\""], ["proof (prove)\nusing this:\n  C \\<in> sys_xcpts\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C \\<preceq>\\<^sup>* Throwable", "by(rule xcpt_subcls_Throwable)"], ["proof (state)\nthis:\n  P \\<turnstile> C \\<preceq>\\<^sup>* Throwable\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>typeof_addr h (addr_of_sys_xcpt C) =\n              \\<lfloor>Class_type C\\<rfloor>;\n      P \\<turnstile> C \\<preceq>\\<^sup>* Throwable\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  typeof_addr h (addr_of_sys_xcpt C) = \\<lfloor>Class_type C\\<rfloor>\n  P \\<turnstile> C \\<preceq>\\<^sup>* Throwable", "show thesis"], ["proof (prove)\nusing this:\n  typeof_addr h (addr_of_sys_xcpt C) = \\<lfloor>Class_type C\\<rfloor>\n  P \\<turnstile> C \\<preceq>\\<^sup>* Throwable\n\ngoal (1 subgoal):\n 1. thesis", "by(rule that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_preallocatedD:\n  assumes \"wf_prog wf_md P\"\n  and \"preallocated h\"\n  and \"C \\<in> sys_xcpts\"\n  shows \"typeof_addr h (addr_of_sys_xcpt C) = \\<lfloor>Class_type C\\<rfloor> \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* Throwable\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof_addr h (addr_of_sys_xcpt C) =\n    \\<lfloor>Class_type C\\<rfloor> \\<and>\n    P \\<turnstile> C \\<preceq>\\<^sup>* Throwable", "using assms"], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  preallocated h\n  C \\<in> sys_xcpts\n\ngoal (1 subgoal):\n 1. typeof_addr h (addr_of_sys_xcpt C) =\n    \\<lfloor>Class_type C\\<rfloor> \\<and>\n    P \\<turnstile> C \\<preceq>\\<^sup>* Throwable", "by(rule wf_preallocatedE) blast"], ["", "end"], ["", "lemma (in heap_conf) hconf_start_heap:\n  \"wf_prog wf_md P \\<Longrightarrow> hconf start_heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_md P \\<Longrightarrow> hconf start_heap", "unfolding start_heap_def start_heap_data_def initialization_list_def sys_xcpts_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_md P \\<Longrightarrow>\n    hconf\n     (fst (foldl create_initial_object (empty_heap, [], True)\n            [Thread, NullPointer, ClassCast, OutOfMemory,\n             ArrayIndexOutOfBounds, ArrayStore, NegativeArraySize,\n             ArithmeticException, IllegalMonitorState, IllegalThreadState,\n             InterruptedException]))", "using hconf_empty"], ["proof (prove)\nusing this:\n  hconf empty_heap\n\ngoal (1 subgoal):\n 1. wf_prog wf_md P \\<Longrightarrow>\n    hconf\n     (fst (foldl create_initial_object (empty_heap, [], True)\n            [Thread, NullPointer, ClassCast, OutOfMemory,\n             ArrayIndexOutOfBounds, ArrayStore, NegativeArraySize,\n             ArithmeticException, IllegalMonitorState, IllegalThreadState,\n             InterruptedException]))", "by -(simp add: create_initial_object_simps del: hconf_empty, clarsimp split: prod.split elim!: not_empty_pairE simp del: hconf_empty, drule (1) allocate_Eps, drule (1) hconf_allocate_mono, simp add: is_class_xcpt)+"], ["", "lemma subcls1_wfD:\n  \"\\<lbrakk> P \\<turnstile> C \\<prec>\\<^sup>1 D; wf_prog wf_md P \\<rbrakk> \\<Longrightarrow> D \\<noteq> C \\<and> \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C \\<prec>\\<^sup>1 D; wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> D \\<noteq> C \\<and>\n                      \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D C", "apply( frule tranclp.r_into_trancl[where r=\"subcls1 P\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C \\<prec>\\<^sup>1 D; wf_prog wf_md P;\n     (subcls1 P)\\<^sup>+\\<^sup>+ C D\\<rbrakk>\n    \\<Longrightarrow> D \\<noteq> C \\<and>\n                      \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D C", "apply( drule subcls1D)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; (subcls1 P)\\<^sup>+\\<^sup>+ C D;\n     C \\<noteq> Object \\<and>\n     (\\<exists>fs ms. class P C = \\<lfloor>(D, fs, ms)\\<rfloor>)\\<rbrakk>\n    \\<Longrightarrow> D \\<noteq> C \\<and>\n                      \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D C", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fs ms.\n       \\<lbrakk>wf_prog wf_md P; (subcls1 P)\\<^sup>+\\<^sup>+ C D;\n        C \\<noteq> Object;\n        class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> D \\<noteq> C \\<and>\n                         \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D C", "apply( drule (1) class_wf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fs ms.\n       \\<lbrakk>wf_prog wf_md P; (subcls1 P)\\<^sup>+\\<^sup>+ C D;\n        C \\<noteq> Object; wf_cdecl wf_md P (C, D, fs, ms)\\<rbrakk>\n       \\<Longrightarrow> D \\<noteq> C \\<and>\n                         \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D C", "apply( unfold wf_cdecl_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fs ms.\n       \\<lbrakk>wf_prog wf_md P; (subcls1 P)\\<^sup>+\\<^sup>+ C D;\n        C \\<noteq> Object;\n        case (C, D, fs, ms) of\n        (C, D, fs, ms) \\<Rightarrow>\n          (\\<forall>f\\<in>set fs. wf_fdecl P f) \\<and>\n          distinct_fst fs \\<and>\n          (\\<forall>m\\<in>set ms. wf_mdecl wf_md P C m) \\<and>\n          distinct_fst ms \\<and>\n          (C \\<noteq> Object \\<longrightarrow>\n           is_class P D \\<and>\n           \\<not> P \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n           (\\<forall>m\\<in>set ms. wf_overriding P D m)) \\<and>\n          (C = Thread \\<longrightarrow>\n           (\\<exists>m. (run, [], Void, m) \\<in> set ms))\\<rbrakk>\n       \\<Longrightarrow> D \\<noteq> C \\<and>\n                         \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D C", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>fs ms.\n       \\<lbrakk>wf_prog wf_md P; (subcls1 P)\\<^sup>+\\<^sup>+ C D;\n        C \\<noteq> Object;\n        case (C, D, fs, ms) of\n        (C, D, fs, ms) \\<Rightarrow>\n          (\\<forall>f\\<in>set fs. wf_fdecl P f) \\<and>\n          distinct_fst fs \\<and>\n          (\\<forall>m\\<in>set ms. wf_mdecl wf_md P C m) \\<and>\n          distinct_fst ms \\<and>\n          (C \\<noteq> Object \\<longrightarrow>\n           is_class P D \\<and>\n           \\<not> P \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n           (\\<forall>m\\<in>set ms. wf_overriding P D m)) \\<and>\n          (C = Thread \\<longrightarrow>\n           (\\<exists>m. (run, [], Void, m) \\<in> set ms))\\<rbrakk>\n       \\<Longrightarrow> D \\<noteq> C\n 2. \\<And>fs ms.\n       \\<lbrakk>wf_prog wf_md P; (subcls1 P)\\<^sup>+\\<^sup>+ C D;\n        C \\<noteq> Object;\n        case (C, D, fs, ms) of\n        (C, D, fs, ms) \\<Rightarrow>\n          (\\<forall>f\\<in>set fs. wf_fdecl P f) \\<and>\n          distinct_fst fs \\<and>\n          (\\<forall>m\\<in>set ms. wf_mdecl wf_md P C m) \\<and>\n          distinct_fst ms \\<and>\n          (C \\<noteq> Object \\<longrightarrow>\n           is_class P D \\<and>\n           \\<not> P \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n           (\\<forall>m\\<in>set ms. wf_overriding P D m)) \\<and>\n          (C = Thread \\<longrightarrow>\n           (\\<exists>m. (run, [], Void, m) \\<in> set ms))\\<rbrakk>\n       \\<Longrightarrow> \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D C", "apply(force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fs ms.\n       \\<lbrakk>wf_prog wf_md P; (subcls1 P)\\<^sup>+\\<^sup>+ C D;\n        C \\<noteq> Object;\n        case (C, D, fs, ms) of\n        (C, D, fs, ms) \\<Rightarrow>\n          (\\<forall>f\\<in>set fs. wf_fdecl P f) \\<and>\n          distinct_fst fs \\<and>\n          (\\<forall>m\\<in>set ms. wf_mdecl wf_md P C m) \\<and>\n          distinct_fst ms \\<and>\n          (C \\<noteq> Object \\<longrightarrow>\n           is_class P D \\<and>\n           \\<not> P \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n           (\\<forall>m\\<in>set ms. wf_overriding P D m)) \\<and>\n          (C = Thread \\<longrightarrow>\n           (\\<exists>m. (run, [], Void, m) \\<in> set ms))\\<rbrakk>\n       \\<Longrightarrow> \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D C", "apply(unfold reflclp_tranclp[symmetric, where r=\"subcls1 P\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fs ms.\n       \\<lbrakk>wf_prog wf_md P; (subcls1 P)\\<^sup>+\\<^sup>+ C D;\n        C \\<noteq> Object;\n        case (C, D, fs, ms) of\n        (C, D, fs, ms) \\<Rightarrow>\n          (\\<forall>f\\<in>set fs. wf_fdecl P f) \\<and>\n          distinct_fst fs \\<and>\n          (\\<forall>m\\<in>set ms. wf_mdecl wf_md P C m) \\<and>\n          distinct_fst ms \\<and>\n          (C \\<noteq> Object \\<longrightarrow>\n           is_class P D \\<and>\n           \\<not> (subcls1 P)\\<^sup>+\\<^sup>+\\<^sup>=\\<^sup>= D C \\<and>\n           (\\<forall>m\\<in>set ms. wf_overriding P D m)) \\<and>\n          (C = Thread \\<longrightarrow>\n           (\\<exists>m. (run, [], Void, m) \\<in> set ms))\\<rbrakk>\n       \\<Longrightarrow> \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D C", "apply(blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wf_cdecl_supD: \n  \"\\<lbrakk>wf_cdecl wf_md P (C,D,r); C \\<noteq> Object\\<rbrakk> \\<Longrightarrow> is_class P D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_cdecl wf_md P (C, D, r); C \\<noteq> Object\\<rbrakk>\n    \\<Longrightarrow> is_class P D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_cdecl wf_md P (C, D, r); C \\<noteq> Object\\<rbrakk>\n    \\<Longrightarrow> is_class P D", "by (auto simp: wf_cdecl_def)"], ["", "(*>*)"], ["", "lemma subcls_asym:\n  \"\\<lbrakk> wf_prog wf_md P; (subcls1 P)\\<^sup>+\\<^sup>+ C D \\<rbrakk> \\<Longrightarrow> \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; (subcls1 P)\\<^sup>+\\<^sup>+ C D\\<rbrakk>\n    \\<Longrightarrow> \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D C", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; (subcls1 P)\\<^sup>+\\<^sup>+ C D\\<rbrakk>\n    \\<Longrightarrow> \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D C", "apply(erule tranclp.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>wf_prog wf_md P; C = a; D = b;\n        P \\<turnstile> a \\<prec>\\<^sup>1 b\\<rbrakk>\n       \\<Longrightarrow> \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D C\n 2. \\<And>a b c.\n       \\<lbrakk>wf_prog wf_md P; C = a; D = c;\n        (subcls1 P)\\<^sup>+\\<^sup>+ a b;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c\\<rbrakk>\n       \\<Longrightarrow> \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D C", "apply(fast dest!: subcls1_wfD )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>wf_prog wf_md P; C = a; D = c;\n        (subcls1 P)\\<^sup>+\\<^sup>+ a b;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c\\<rbrakk>\n       \\<Longrightarrow> \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ D C", "apply(fast dest!: subcls1_wfD intro: tranclp_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma subcls_irrefl:\n  \"\\<lbrakk> wf_prog wf_md P; (subcls1 P)\\<^sup>+\\<^sup>+ C D\\<rbrakk> \\<Longrightarrow> C \\<noteq> D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; (subcls1 P)\\<^sup>+\\<^sup>+ C D\\<rbrakk>\n    \\<Longrightarrow> C \\<noteq> D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; (subcls1 P)\\<^sup>+\\<^sup>+ C D\\<rbrakk>\n    \\<Longrightarrow> C \\<noteq> D", "apply (erule tranclp_trans_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>wf_prog wf_md P; P \\<turnstile> x \\<prec>\\<^sup>1 y\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> y\n 2. \\<And>x y z.\n       \\<lbrakk>wf_prog wf_md P; (subcls1 P)\\<^sup>+\\<^sup>+ x y;\n        x \\<noteq> y; (subcls1 P)\\<^sup>+\\<^sup>+ y z; y \\<noteq> z\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> z", "apply  (auto dest: subcls1_wfD subcls_asym)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma acyclicP_def:\n  \"acyclicP r \\<longleftrightarrow> (\\<forall>x. \\<not> r^++ x x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclicP r = (\\<forall>x. \\<not> r\\<^sup>+\\<^sup>+ x x)", "unfolding acyclic_def trancl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x.\n        (x, x)\n        \\<notin> {(x, y).\n                  (\\<lambda>x xa.\n                      (x, xa) \\<in> {(x, y). r x y})\\<^sup>+\\<^sup>+\n                   x y}) =\n    (\\<forall>x. \\<not> r\\<^sup>+\\<^sup>+ x x)", "by(auto)"], ["", "lemma acyclic_subcls1:\n  \"wf_prog wf_md P \\<Longrightarrow> acyclicP (subcls1 P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_md P \\<Longrightarrow> acyclicP (subcls1 P)", "by(unfold acyclicP_def)(fast dest: subcls_irrefl)"], ["", "lemma finite_conversep: \"finite {(x, y). r\\<inverse>\\<inverse> x y} = finite {(x, y). r x y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {(x, y). r\\<inverse>\\<inverse> x y} = finite {(x, y). r x y}", "by(subst finite_converse[unfolded converse_unfold, symmetric]) simp"], ["", "lemma acyclicP_wf_subcls1:\n  \"acyclicP (subcls1 P) \\<Longrightarrow> wfP ((subcls1 P)\\<inverse>\\<inverse>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclicP (subcls1 P) \\<Longrightarrow>\n    wfP (subcls1 P)\\<inverse>\\<inverse>", "unfolding wfP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclicP (subcls1 P) \\<Longrightarrow>\n    wf {(x, y). (subcls1 P)\\<inverse>\\<inverse> x y}", "by(rule finite_acyclic_wf)(simp_all only: finite_conversep finite_subcls1 acyclicP_converse)"], ["", "lemma wf_subcls1:\n  \"wf_prog wf_md P \\<Longrightarrow> wfP ((subcls1 P)\\<inverse>\\<inverse>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_md P \\<Longrightarrow> wfP (subcls1 P)\\<inverse>\\<inverse>", "by(rule acyclicP_wf_subcls1)(rule acyclic_subcls1)"], ["", "lemma single_valued_subcls1:\n  \"wf_prog wf_md G \\<Longrightarrow> single_valuedp (subcls1 G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_md G \\<Longrightarrow> single_valuedp (subcls1 G)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_md G \\<Longrightarrow> single_valuedp (subcls1 G)", "by(auto simp:wf_prog_def distinct_fst_def single_valuedp_def dest!:subcls1D)"], ["", "(*>*)"], ["", "lemma subcls_induct: \n  \"\\<lbrakk> wf_prog wf_md P; \\<And>C. \\<forall>D. (subcls1 P)\\<^sup>+\\<^sup>+ C D \\<longrightarrow> Q D \\<Longrightarrow> Q C \\<rbrakk> \\<Longrightarrow> Q C\"\n(*<*)\n  (is \"?A \\<Longrightarrow> PROP ?P \\<Longrightarrow> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P;\n     \\<And>C.\n        \\<forall>D.\n           (subcls1 P)\\<^sup>+\\<^sup>+ C D \\<longrightarrow>\n           Q D \\<Longrightarrow>\n        Q C\\<rbrakk>\n    \\<Longrightarrow> Q C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P;\n     \\<And>C.\n        \\<forall>D.\n           (subcls1 P)\\<^sup>+\\<^sup>+ C D \\<longrightarrow>\n           Q D \\<Longrightarrow>\n        Q C\\<rbrakk>\n    \\<Longrightarrow> Q C", "assume p: \"PROP ?P\""], ["proof (state)\nthis:\n  \\<forall>D.\n     (subcls1 P)\\<^sup>+\\<^sup>+ ?C D \\<longrightarrow>\n     Q D \\<Longrightarrow>\n  Q ?C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P;\n     \\<And>C.\n        \\<forall>D.\n           (subcls1 P)\\<^sup>+\\<^sup>+ C D \\<longrightarrow>\n           Q D \\<Longrightarrow>\n        Q C\\<rbrakk>\n    \\<Longrightarrow> Q C", "assume ?A"], ["proof (state)\nthis:\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P;\n     \\<And>C.\n        \\<forall>D.\n           (subcls1 P)\\<^sup>+\\<^sup>+ C D \\<longrightarrow>\n           Q D \\<Longrightarrow>\n        Q C\\<rbrakk>\n    \\<Longrightarrow> Q C", "thus ?thesis"], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. Q C", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_md P \\<Longrightarrow> Q C", "apply(drule wf_subcls1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP (subcls1 P)\\<inverse>\\<inverse> \\<Longrightarrow> Q C", "apply(drule wfP_trancl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP (subcls1 P)\\<inverse>\\<inverse>\\<^sup>+\\<^sup>+ \\<Longrightarrow>\n    Q C", "apply(simp only: tranclp_converse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP (subcls1 P)\\<^sup>+\\<^sup>+\\<inverse>\\<inverse> \\<Longrightarrow>\n    Q C", "apply(erule_tac a = C in wfP_induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (subcls1 P)\\<^sup>+\\<^sup>+\\<inverse>\\<inverse> y\n           x \\<longrightarrow>\n          Q y \\<Longrightarrow>\n       Q x", "apply(rule p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (subcls1 P)\\<^sup>+\\<^sup>+\\<inverse>\\<inverse> y\n           x \\<longrightarrow>\n          Q y \\<Longrightarrow>\n       \\<forall>D. (subcls1 P)\\<^sup>+\\<^sup>+ x D \\<longrightarrow> Q D", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Q C\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma subcls1_induct_aux:\n  \"\\<lbrakk> is_class P C; wf_prog wf_md P; Q Object;\n    \\<And>C D fs ms.\n    \\<lbrakk> C \\<noteq> Object; is_class P C; class P C = Some (D,fs,ms) \\<and>\n      wf_cdecl wf_md P (C,D,fs,ms) \\<and> P \\<turnstile> C \\<prec>\\<^sup>1 D \\<and> is_class P D \\<and> Q D\\<rbrakk> \\<Longrightarrow> Q C \\<rbrakk>\n  \\<Longrightarrow> Q C\"\n(*<*)\n  (is \"?A \\<Longrightarrow> ?B \\<Longrightarrow> ?C \\<Longrightarrow> PROP ?P \\<Longrightarrow> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_class P C; wf_prog wf_md P; Q Object;\n     \\<And>C D fs ms.\n        \\<lbrakk>C \\<noteq> Object; is_class P C;\n         class P C = \\<lfloor>(D, fs, ms)\\<rfloor> \\<and>\n         wf_cdecl wf_md P (C, D, fs, ms) \\<and>\n         P \\<turnstile> C \\<prec>\\<^sup>1 D \\<and>\n         is_class P D \\<and> Q D\\<rbrakk>\n        \\<Longrightarrow> Q C\\<rbrakk>\n    \\<Longrightarrow> Q C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_class P C; wf_prog wf_md P; Q Object;\n     \\<And>C D fs ms.\n        \\<lbrakk>C \\<noteq> Object; is_class P C;\n         class P C = \\<lfloor>(D, fs, ms)\\<rfloor> \\<and>\n         wf_cdecl wf_md P (C, D, fs, ms) \\<and>\n         P \\<turnstile> C \\<prec>\\<^sup>1 D \\<and>\n         is_class P D \\<and> Q D\\<rbrakk>\n        \\<Longrightarrow> Q C\\<rbrakk>\n    \\<Longrightarrow> Q C", "assume p: \"PROP ?P\""], ["proof (state)\nthis:\n  \\<lbrakk>?C \\<noteq> Object; is_class P ?C;\n   class P ?C = \\<lfloor>(?D, ?fs, ?ms)\\<rfloor> \\<and>\n   wf_cdecl wf_md P (?C, ?D, ?fs, ?ms) \\<and>\n   P \\<turnstile> ?C \\<prec>\\<^sup>1 ?D \\<and>\n   is_class P ?D \\<and> Q ?D\\<rbrakk>\n  \\<Longrightarrow> Q ?C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_class P C; wf_prog wf_md P; Q Object;\n     \\<And>C D fs ms.\n        \\<lbrakk>C \\<noteq> Object; is_class P C;\n         class P C = \\<lfloor>(D, fs, ms)\\<rfloor> \\<and>\n         wf_cdecl wf_md P (C, D, fs, ms) \\<and>\n         P \\<turnstile> C \\<prec>\\<^sup>1 D \\<and>\n         is_class P D \\<and> Q D\\<rbrakk>\n        \\<Longrightarrow> Q C\\<rbrakk>\n    \\<Longrightarrow> Q C", "assume ?A ?B ?C"], ["proof (state)\nthis:\n  is_class P C\n  wf_prog wf_md P\n  Q Object\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_class P C; wf_prog wf_md P; Q Object;\n     \\<And>C D fs ms.\n        \\<lbrakk>C \\<noteq> Object; is_class P C;\n         class P C = \\<lfloor>(D, fs, ms)\\<rfloor> \\<and>\n         wf_cdecl wf_md P (C, D, fs, ms) \\<and>\n         P \\<turnstile> C \\<prec>\\<^sup>1 D \\<and>\n         is_class P D \\<and> Q D\\<rbrakk>\n        \\<Longrightarrow> Q C\\<rbrakk>\n    \\<Longrightarrow> Q C", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_class P C\n  wf_prog wf_md P\n  Q Object\n\ngoal (1 subgoal):\n 1. Q C", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_class P C; wf_prog wf_md P; Q Object\\<rbrakk>\n    \\<Longrightarrow> Q C", "apply(unfold is_class_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>class P C \\<noteq> None; wf_prog wf_md P; Q Object\\<rbrakk>\n    \\<Longrightarrow> Q C", "apply( rule impE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>class P C \\<noteq> None; wf_prog wf_md P; Q Object\\<rbrakk>\n    \\<Longrightarrow> ?P3 \\<longrightarrow> ?Q3\n 2. \\<lbrakk>class P C \\<noteq> None; wf_prog wf_md P; Q Object\\<rbrakk>\n    \\<Longrightarrow> ?P3\n 3. \\<lbrakk>class P C \\<noteq> None; wf_prog wf_md P; Q Object;\n     ?Q3\\<rbrakk>\n    \\<Longrightarrow> Q C", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>class P C \\<noteq> None; wf_prog wf_md P; Q Object\\<rbrakk>\n    \\<Longrightarrow> ?P3\n 2. \\<lbrakk>class P C \\<noteq> None; wf_prog wf_md P; Q Object\\<rbrakk>\n    \\<Longrightarrow> ?P3 \\<longrightarrow> ?Q3\n 3. \\<lbrakk>class P C \\<noteq> None; wf_prog wf_md P; Q Object;\n     ?Q3\\<rbrakk>\n    \\<Longrightarrow> Q C", "apply(   assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>class P C \\<noteq> None; wf_prog wf_md P; Q Object\\<rbrakk>\n    \\<Longrightarrow> class P C \\<noteq> None \\<longrightarrow> ?Q3\n 2. \\<lbrakk>class P C \\<noteq> None; wf_prog wf_md P; Q Object;\n     ?Q3\\<rbrakk>\n    \\<Longrightarrow> Q C", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>class P C \\<noteq> None; wf_prog wf_md P; Q Object;\n     ?Q3\\<rbrakk>\n    \\<Longrightarrow> Q C\n 2. \\<lbrakk>class P C \\<noteq> None; wf_prog wf_md P; Q Object\\<rbrakk>\n    \\<Longrightarrow> class P C \\<noteq> None \\<longrightarrow> ?Q3", "apply(  assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>class P C \\<noteq> None; wf_prog wf_md P; Q Object\\<rbrakk>\n    \\<Longrightarrow> class P C \\<noteq> None \\<longrightarrow> Q C", "apply( erule thin_rl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; Q Object\\<rbrakk>\n    \\<Longrightarrow> class P C \\<noteq> None \\<longrightarrow> Q C", "apply( rule subcls_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_prog wf_md P; Q Object\\<rbrakk>\n    \\<Longrightarrow> wf_prog ?wf_md9 ?P9\n 2. \\<And>C.\n       \\<lbrakk>wf_prog wf_md P; Q Object;\n        \\<forall>D.\n           (subcls1 ?P9)\\<^sup>+\\<^sup>+ C D \\<longrightarrow>\n           class P D \\<noteq> None \\<longrightarrow> Q D\\<rbrakk>\n       \\<Longrightarrow> class P C \\<noteq> None \\<longrightarrow> Q C", "apply(  assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>wf_prog wf_md P; Q Object;\n        \\<forall>D.\n           (subcls1 P)\\<^sup>+\\<^sup>+ C D \\<longrightarrow>\n           class P D \\<noteq> None \\<longrightarrow> Q D\\<rbrakk>\n       \\<Longrightarrow> class P C \\<noteq> None \\<longrightarrow> Q C", "apply( rule impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>wf_prog wf_md P; Q Object;\n        \\<forall>D.\n           (subcls1 P)\\<^sup>+\\<^sup>+ C D \\<longrightarrow>\n           class P D \\<noteq> None \\<longrightarrow> Q D;\n        class P C \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Q C", "apply( case_tac \"C = Object\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>wf_prog wf_md P; Q Object;\n        \\<forall>D.\n           (subcls1 P)\\<^sup>+\\<^sup>+ C D \\<longrightarrow>\n           class P D \\<noteq> None \\<longrightarrow> Q D;\n        class P C \\<noteq> None; C = Object\\<rbrakk>\n       \\<Longrightarrow> Q C\n 2. \\<And>C.\n       \\<lbrakk>wf_prog wf_md P; Q Object;\n        \\<forall>D.\n           (subcls1 P)\\<^sup>+\\<^sup>+ C D \\<longrightarrow>\n           class P D \\<noteq> None \\<longrightarrow> Q D;\n        class P C \\<noteq> None; C \\<noteq> Object\\<rbrakk>\n       \\<Longrightarrow> Q C", "apply(  fast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>wf_prog wf_md P; Q Object;\n        \\<forall>D.\n           (subcls1 P)\\<^sup>+\\<^sup>+ C D \\<longrightarrow>\n           class P D \\<noteq> None \\<longrightarrow> Q D;\n        class P C \\<noteq> None; C \\<noteq> Object\\<rbrakk>\n       \\<Longrightarrow> Q C", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C a aa b.\n       \\<lbrakk>wf_prog wf_md P; Q Object;\n        \\<forall>D.\n           (subcls1 P)\\<^sup>+\\<^sup>+ C D \\<longrightarrow>\n           class P D \\<noteq> None \\<longrightarrow> Q D;\n        C \\<noteq> Object; class P C = \\<lfloor>(a, aa, b)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> Q C", "apply( frule (1) class_wf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C a aa b.\n       \\<lbrakk>wf_prog wf_md P; Q Object;\n        \\<forall>D.\n           (subcls1 P)\\<^sup>+\\<^sup>+ C D \\<longrightarrow>\n           class P D \\<noteq> None \\<longrightarrow> Q D;\n        C \\<noteq> Object; class P C = \\<lfloor>(a, aa, b)\\<rfloor>;\n        wf_cdecl wf_md P (C, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> Q C", "apply( frule (1) wf_cdecl_supD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C a aa b.\n       \\<lbrakk>wf_prog wf_md P; Q Object;\n        \\<forall>D.\n           (subcls1 P)\\<^sup>+\\<^sup>+ C D \\<longrightarrow>\n           class P D \\<noteq> None \\<longrightarrow> Q D;\n        C \\<noteq> Object; class P C = \\<lfloor>(a, aa, b)\\<rfloor>;\n        wf_cdecl wf_md P (C, a, aa, b); is_class P a\\<rbrakk>\n       \\<Longrightarrow> Q C", "apply( subgoal_tac \"P \\<turnstile> C \\<prec>\\<^sup>1 a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C a aa b.\n       \\<lbrakk>wf_prog wf_md P; Q Object;\n        \\<forall>D.\n           (subcls1 P)\\<^sup>+\\<^sup>+ C D \\<longrightarrow>\n           class P D \\<noteq> None \\<longrightarrow> Q D;\n        C \\<noteq> Object; class P C = \\<lfloor>(a, aa, b)\\<rfloor>;\n        wf_cdecl wf_md P (C, a, aa, b); is_class P a;\n        P \\<turnstile> C \\<prec>\\<^sup>1 a\\<rbrakk>\n       \\<Longrightarrow> Q C\n 2. \\<And>C a aa b.\n       \\<lbrakk>wf_prog wf_md P; Q Object;\n        \\<forall>D.\n           (subcls1 P)\\<^sup>+\\<^sup>+ C D \\<longrightarrow>\n           class P D \\<noteq> None \\<longrightarrow> Q D;\n        C \\<noteq> Object; class P C = \\<lfloor>(a, aa, b)\\<rfloor>;\n        wf_cdecl wf_md P (C, a, aa, b); is_class P a\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C \\<prec>\\<^sup>1 a", "apply( erule_tac [2] subcls1I)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C a aa b.\n       \\<lbrakk>wf_prog wf_md P; Q Object;\n        \\<forall>D.\n           (subcls1 P)\\<^sup>+\\<^sup>+ C D \\<longrightarrow>\n           class P D \\<noteq> None \\<longrightarrow> Q D;\n        C \\<noteq> Object; class P C = \\<lfloor>(a, aa, b)\\<rfloor>;\n        wf_cdecl wf_md P (C, a, aa, b); is_class P a;\n        P \\<turnstile> C \\<prec>\\<^sup>1 a\\<rbrakk>\n       \\<Longrightarrow> Q C\n 2. \\<And>C a aa b.\n       \\<lbrakk>wf_prog wf_md P; Q Object;\n        \\<forall>D.\n           (subcls1 P)\\<^sup>+\\<^sup>+ C D \\<longrightarrow>\n           class P D \\<noteq> None \\<longrightarrow> Q D;\n        C \\<noteq> Object; wf_cdecl wf_md P (C, a, aa, b);\n        is_class P a\\<rbrakk>\n       \\<Longrightarrow> C \\<noteq> Object", "apply(  rule p)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>C a aa b.\n       \\<lbrakk>wf_prog wf_md P; Q Object;\n        \\<forall>D.\n           (subcls1 P)\\<^sup>+\\<^sup>+ C D \\<longrightarrow>\n           class P D \\<noteq> None \\<longrightarrow> Q D;\n        C \\<noteq> Object; class P C = \\<lfloor>(a, aa, b)\\<rfloor>;\n        wf_cdecl wf_md P (C, a, aa, b); is_class P a;\n        P \\<turnstile> C \\<prec>\\<^sup>1 a\\<rbrakk>\n       \\<Longrightarrow> C \\<noteq> Object\n 2. \\<And>C a aa b.\n       \\<lbrakk>wf_prog wf_md P; Q Object;\n        \\<forall>D.\n           (subcls1 P)\\<^sup>+\\<^sup>+ C D \\<longrightarrow>\n           class P D \\<noteq> None \\<longrightarrow> Q D;\n        C \\<noteq> Object; class P C = \\<lfloor>(a, aa, b)\\<rfloor>;\n        wf_cdecl wf_md P (C, a, aa, b); is_class P a;\n        P \\<turnstile> C \\<prec>\\<^sup>1 a\\<rbrakk>\n       \\<Longrightarrow> is_class P C\n 3. \\<And>C a aa b.\n       \\<lbrakk>wf_prog wf_md P; Q Object;\n        \\<forall>D.\n           (subcls1 P)\\<^sup>+\\<^sup>+ C D \\<longrightarrow>\n           class P D \\<noteq> None \\<longrightarrow> Q D;\n        C \\<noteq> Object; class P C = \\<lfloor>(a, aa, b)\\<rfloor>;\n        wf_cdecl wf_md P (C, a, aa, b); is_class P a;\n        P \\<turnstile> C \\<prec>\\<^sup>1 a\\<rbrakk>\n       \\<Longrightarrow> class P C =\n                         \\<lfloor>(?D28 C a aa b, ?fs28 C a aa b,\n                                   ?ms28 C a aa b)\\<rfloor> \\<and>\n                         wf_cdecl wf_md P\n                          (C, ?D28 C a aa b, ?fs28 C a aa b,\n                           ?ms28 C a aa b) \\<and>\n                         P \\<turnstile> C \\<prec>\\<^sup>1 ?D28 C a aa\n                     b \\<and>\n                         is_class P (?D28 C a aa b) \\<and> Q (?D28 C a aa b)\n 4. \\<And>C a aa b.\n       \\<lbrakk>wf_prog wf_md P; Q Object;\n        \\<forall>D.\n           (subcls1 P)\\<^sup>+\\<^sup>+ C D \\<longrightarrow>\n           class P D \\<noteq> None \\<longrightarrow> Q D;\n        C \\<noteq> Object; wf_cdecl wf_md P (C, a, aa, b);\n        is_class P a\\<rbrakk>\n       \\<Longrightarrow> C \\<noteq> Object", "apply (unfold is_class_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>C a aa b.\n       \\<lbrakk>wf_prog wf_md P; Q Object;\n        \\<forall>D.\n           (subcls1 P)\\<^sup>+\\<^sup>+ C D \\<longrightarrow>\n           class P D \\<noteq> None \\<longrightarrow> Q D;\n        C \\<noteq> Object; class P C = \\<lfloor>(a, aa, b)\\<rfloor>;\n        wf_cdecl wf_md P (C, a, aa, b); class P a \\<noteq> None;\n        P \\<turnstile> C \\<prec>\\<^sup>1 a\\<rbrakk>\n       \\<Longrightarrow> C \\<noteq> Object\n 2. \\<And>C a aa b.\n       \\<lbrakk>wf_prog wf_md P; Q Object;\n        \\<forall>D.\n           (subcls1 P)\\<^sup>+\\<^sup>+ C D \\<longrightarrow>\n           class P D \\<noteq> None \\<longrightarrow> Q D;\n        C \\<noteq> Object; class P C = \\<lfloor>(a, aa, b)\\<rfloor>;\n        wf_cdecl wf_md P (C, a, aa, b); class P a \\<noteq> None;\n        P \\<turnstile> C \\<prec>\\<^sup>1 a\\<rbrakk>\n       \\<Longrightarrow> class P C \\<noteq> None\n 3. \\<And>C a aa b.\n       \\<lbrakk>wf_prog wf_md P; Q Object;\n        \\<forall>D.\n           (subcls1 P)\\<^sup>+\\<^sup>+ C D \\<longrightarrow>\n           class P D \\<noteq> None \\<longrightarrow> Q D;\n        C \\<noteq> Object; class P C = \\<lfloor>(a, aa, b)\\<rfloor>;\n        wf_cdecl wf_md P (C, a, aa, b); class P a \\<noteq> None;\n        P \\<turnstile> C \\<prec>\\<^sup>1 a\\<rbrakk>\n       \\<Longrightarrow> class P C =\n                         \\<lfloor>(?D28 C a aa b, ?fs28 C a aa b,\n                                   ?ms28 C a aa b)\\<rfloor> \\<and>\n                         wf_cdecl wf_md P\n                          (C, ?D28 C a aa b, ?fs28 C a aa b,\n                           ?ms28 C a aa b) \\<and>\n                         P \\<turnstile> C \\<prec>\\<^sup>1 ?D28 C a aa\n                     b \\<and>\n                         class P (?D28 C a aa b) \\<noteq> None \\<and>\n                         Q (?D28 C a aa b)\n 4. \\<And>C a aa b.\n       \\<lbrakk>wf_prog wf_md P; Q Object;\n        \\<forall>D.\n           (subcls1 P)\\<^sup>+\\<^sup>+ C D \\<longrightarrow>\n           class P D \\<noteq> None \\<longrightarrow> Q D;\n        C \\<noteq> Object; wf_cdecl wf_md P (C, a, aa, b);\n        class P a \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> C \\<noteq> Object", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Q C\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma subcls1_induct [consumes 2, case_names Object Subcls]:\n  \"\\<lbrakk> wf_prog wf_md P; is_class P C; Q Object;\n    \\<And>C D. \\<lbrakk>C \\<noteq> Object; P \\<turnstile> C \\<prec>\\<^sup>1 D; is_class P D; Q D\\<rbrakk> \\<Longrightarrow> Q C \\<rbrakk>\n  \\<Longrightarrow> Q C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; is_class P C; Q Object;\n     \\<And>C D.\n        \\<lbrakk>C \\<noteq> Object; P \\<turnstile> C \\<prec>\\<^sup>1 D;\n         is_class P D; Q D\\<rbrakk>\n        \\<Longrightarrow> Q C\\<rbrakk>\n    \\<Longrightarrow> Q C", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; is_class P C; Q Object;\n     \\<And>C D.\n        \\<lbrakk>C \\<noteq> Object; P \\<turnstile> C \\<prec>\\<^sup>1 D;\n         is_class P D; Q D\\<rbrakk>\n        \\<Longrightarrow> Q C\\<rbrakk>\n    \\<Longrightarrow> Q C", "apply (erule subcls1_induct_aux, assumption, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms.\n       \\<lbrakk>wf_prog wf_md P; Q Object;\n        \\<And>C D.\n           \\<lbrakk>C \\<noteq> Object; P \\<turnstile> C \\<prec>\\<^sup>1 D;\n            is_class P D; Q D\\<rbrakk>\n           \\<Longrightarrow> Q C;\n        C \\<noteq> Object; is_class P C;\n        class P C = \\<lfloor>(D, fs, ms)\\<rfloor> \\<and>\n        wf_cdecl wf_md P (C, D, fs, ms) \\<and>\n        P \\<turnstile> C \\<prec>\\<^sup>1 D \\<and>\n        is_class P D \\<and> Q D\\<rbrakk>\n       \\<Longrightarrow> Q C", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma subcls_C_Object:\n  \"\\<lbrakk> is_class P C; wf_prog wf_md P \\<rbrakk> \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* Object\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_class P C; wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* Object", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_class P C; wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* Object", "apply(erule (1) subcls1_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_class P C \\<Longrightarrow>\n    P \\<turnstile> Object \\<preceq>\\<^sup>* Object\n 2. \\<And>Ca D.\n       \\<lbrakk>is_class P C; Ca \\<noteq> Object;\n        P \\<turnstile> Ca \\<prec>\\<^sup>1 D; is_class P D;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Object\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Ca \\<preceq>\\<^sup>* Object", "apply( fast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ca D.\n       \\<lbrakk>is_class P C; Ca \\<noteq> Object;\n        P \\<turnstile> Ca \\<prec>\\<^sup>1 D; is_class P D;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Object\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Ca \\<preceq>\\<^sup>* Object", "apply(erule (1) converse_rtranclp_into_rtranclp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma converse_subcls_is_class:\n  assumes wf: \"wf_prog wf_md P\"\n  shows \"\\<lbrakk> P \\<turnstile> C \\<preceq>\\<^sup>* D; is_class P C \\<rbrakk> \\<Longrightarrow> is_class P D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D; is_class P C\\<rbrakk>\n    \\<Longrightarrow> is_class P D", "proof(induct rule: rtranclp_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_class P C \\<Longrightarrow> is_class P C\n 2. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* y;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        is_class P C \\<Longrightarrow> is_class P y; is_class P C\\<rbrakk>\n       \\<Longrightarrow> is_class P z", "assume \"is_class P C\""], ["proof (state)\nthis:\n  is_class P C\n\ngoal (2 subgoals):\n 1. is_class P C \\<Longrightarrow> is_class P C\n 2. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* y;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        is_class P C \\<Longrightarrow> is_class P y; is_class P C\\<rbrakk>\n       \\<Longrightarrow> is_class P z", "thus \"is_class P C\""], ["proof (prove)\nusing this:\n  is_class P C\n\ngoal (1 subgoal):\n 1. is_class P C", "."], ["proof (state)\nthis:\n  is_class P C\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* y;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        is_class P C \\<Longrightarrow> is_class P y; is_class P C\\<rbrakk>\n       \\<Longrightarrow> is_class P z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* y;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        is_class P C \\<Longrightarrow> is_class P y; is_class P C\\<rbrakk>\n       \\<Longrightarrow> is_class P z", "fix D E"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* y;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        is_class P C \\<Longrightarrow> is_class P y; is_class P C\\<rbrakk>\n       \\<Longrightarrow> is_class P z", "assume PDE: \"P \\<turnstile> D \\<prec>\\<^sup>1 E\"\n    and IH: \"is_class P C \\<Longrightarrow> is_class P D\"\n    and iPC: \"is_class P C\""], ["proof (state)\nthis:\n  P \\<turnstile> D \\<prec>\\<^sup>1 E\n  is_class P C \\<Longrightarrow> is_class P D\n  is_class P C\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* y;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        is_class P C \\<Longrightarrow> is_class P y; is_class P C\\<rbrakk>\n       \\<Longrightarrow> is_class P z", "have \"is_class P D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_class P D", "by (rule IH[OF iPC])"], ["proof (state)\nthis:\n  is_class P D\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* y;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        is_class P C \\<Longrightarrow> is_class P y; is_class P C\\<rbrakk>\n       \\<Longrightarrow> is_class P z", "with PDE"], ["proof (chain)\npicking this:\n  P \\<turnstile> D \\<prec>\\<^sup>1 E\n  is_class P D", "obtain fsD MsD where classD: \"class P D = \\<lfloor>(E, fsD, MsD)\\<rfloor>\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D \\<prec>\\<^sup>1 E\n  is_class P D\n\ngoal (1 subgoal):\n 1. (\\<And>fsD MsD.\n        class P D = \\<lfloor>(E, fsD, MsD)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: is_class_def elim!: subcls1.cases)"], ["proof (state)\nthis:\n  class P D = \\<lfloor>(E, fsD, MsD)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* y;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        is_class P C \\<Longrightarrow> is_class P y; is_class P C\\<rbrakk>\n       \\<Longrightarrow> is_class P z", "thus \"is_class P E\""], ["proof (prove)\nusing this:\n  class P D = \\<lfloor>(E, fsD, MsD)\\<rfloor>\n\ngoal (1 subgoal):\n 1. is_class P E", "using wf PDE"], ["proof (prove)\nusing this:\n  class P D = \\<lfloor>(E, fsD, MsD)\\<rfloor>\n  wf_prog wf_md P\n  P \\<turnstile> D \\<prec>\\<^sup>1 E\n\ngoal (1 subgoal):\n 1. is_class P E", "by(auto elim!: subcls1.cases dest: class_wf simp: wf_cdecl_def)"], ["proof (state)\nthis:\n  is_class P E\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_class_is_subcls:\n  \"wf_prog m P \\<Longrightarrow> is_class P C = P \\<turnstile> C \\<preceq>\\<^sup>* Object\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog m P \\<Longrightarrow>\n    is_class P C = P \\<turnstile> C \\<preceq>\\<^sup>* Object", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog m P \\<Longrightarrow>\n    is_class P C = P \\<turnstile> C \\<preceq>\\<^sup>* Object", "by (fastforce simp:is_class_def\n                  elim: subcls_C_Object converse_rtranclpE subcls1I\n                  dest: subcls1D)"], ["", "(*>*)"], ["", "lemma subcls_antisym:\n  \"\\<lbrakk>wf_prog m P; P \\<turnstile> C \\<preceq>\\<^sup>* D; P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk> \\<Longrightarrow> C = D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog m P; P \\<turnstile> C \\<preceq>\\<^sup>* D;\n     P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n    \\<Longrightarrow> C = D", "apply(drule acyclic_subcls1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n     P \\<turnstile> D \\<preceq>\\<^sup>* C; acyclicP (subcls1 P)\\<rbrakk>\n    \\<Longrightarrow> C = D", "apply(drule acyclic_impl_antisym_rtrancl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n     P \\<turnstile> D \\<preceq>\\<^sup>* C;\n     antisym ({(x, y). P \\<turnstile> x \\<prec>\\<^sup>1 y}\\<^sup>*)\\<rbrakk>\n    \\<Longrightarrow> C = D", "apply(drule antisymD)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n     P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n    \\<Longrightarrow> (?a4, ?b4)\n                      \\<in> {(x, y).\n                             P \\<turnstile> x \\<prec>\\<^sup>1 y}\\<^sup>*\n 2. \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n     P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n    \\<Longrightarrow> (?b4, ?a4)\n                      \\<in> {(x, y).\n                             P \\<turnstile> x \\<prec>\\<^sup>1 y}\\<^sup>*\n 3. \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n     P \\<turnstile> D \\<preceq>\\<^sup>* C; ?a4 = ?b4\\<rbrakk>\n    \\<Longrightarrow> C = D", "apply(unfold Transitive_Closure.rtrancl_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n     P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n    \\<Longrightarrow> (?a4, ?b4)\n                      \\<in> {(x, y).\n                             (\\<lambda>x xa.\n                                 (x, xa)\n                                 \\<in> {(x, y).\n  P \\<turnstile> x \\<prec>\\<^sup>1 y})\\<^sup>*\\<^sup>*\n                              x y}\n 2. \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n     P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n    \\<Longrightarrow> (?b4, ?a4)\n                      \\<in> {(x, y).\n                             (\\<lambda>x xa.\n                                 (x, xa)\n                                 \\<in> {(x, y).\n  P \\<turnstile> x \\<prec>\\<^sup>1 y})\\<^sup>*\\<^sup>*\n                              x y}\n 3. \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n     P \\<turnstile> D \\<preceq>\\<^sup>* C; ?a4 = ?b4\\<rbrakk>\n    \\<Longrightarrow> C = D", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_type_pTs:\n  \"\\<lbrakk> wf_prog wf_md P; class P C = \\<lfloor>(S,fs,ms)\\<rfloor>; (M,Ts,T,m) \\<in> set ms \\<rbrakk> \\<Longrightarrow> set Ts \\<subseteq> types P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; class P C = \\<lfloor>(S, fs, ms)\\<rfloor>;\n     (M, Ts, T, m) \\<in> set ms\\<rbrakk>\n    \\<Longrightarrow> set Ts \\<subseteq> types P", "by(fastforce dest: class_wf simp add: wf_cdecl_def wf_mdecl_def)"], ["", "lemma widen_asym_1: \n  assumes wfP: \"wf_prog wf_md P\"\n  shows \"P \\<turnstile> C \\<le> D \\<Longrightarrow> C = D \\<or> \\<not> (P \\<turnstile> D \\<le> C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C \\<le> D \\<Longrightarrow>\n    C = D \\<or> \\<not> P \\<turnstile> D \\<le> C", "proof (erule widen.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>T. T = T \\<or> \\<not> P \\<turnstile> T \\<le> T\n 2. \\<And>C D.\n       P \\<turnstile> C \\<preceq>\\<^sup>* D \\<Longrightarrow>\n       Class C = Class D \\<or> \\<not> P \\<turnstile> Class D \\<le> Class C\n 3. \\<And>C. NT = Class C \\<or> \\<not> P \\<turnstile> Class C \\<le> NT\n 4. \\<And>A.\n       NT = A\\<lfloor>\\<rceil> \\<or>\n       \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n 5. \\<And>A.\n       A\\<lfloor>\\<rceil> = Class Object \\<or>\n       \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n 6. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "fix T"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>T. T = T \\<or> \\<not> P \\<turnstile> T \\<le> T\n 2. \\<And>C D.\n       P \\<turnstile> C \\<preceq>\\<^sup>* D \\<Longrightarrow>\n       Class C = Class D \\<or> \\<not> P \\<turnstile> Class D \\<le> Class C\n 3. \\<And>C. NT = Class C \\<or> \\<not> P \\<turnstile> Class C \\<le> NT\n 4. \\<And>A.\n       NT = A\\<lfloor>\\<rceil> \\<or>\n       \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n 5. \\<And>A.\n       A\\<lfloor>\\<rceil> = Class Object \\<or>\n       \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n 6. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "show \"T = T \\<or> \\<not> (P \\<turnstile> T \\<le> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T = T \\<or> \\<not> P \\<turnstile> T \\<le> T", "by simp"], ["proof (state)\nthis:\n  T = T \\<or> \\<not> P \\<turnstile> T \\<le> T\n\ngoal (5 subgoals):\n 1. \\<And>C D.\n       P \\<turnstile> C \\<preceq>\\<^sup>* D \\<Longrightarrow>\n       Class C = Class D \\<or> \\<not> P \\<turnstile> Class D \\<le> Class C\n 2. \\<And>C. NT = Class C \\<or> \\<not> P \\<turnstile> Class C \\<le> NT\n 3. \\<And>A.\n       NT = A\\<lfloor>\\<rceil> \\<or>\n       \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n 4. \\<And>A.\n       A\\<lfloor>\\<rceil> = Class Object \\<or>\n       \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n 5. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>C D.\n       P \\<turnstile> C \\<preceq>\\<^sup>* D \\<Longrightarrow>\n       Class C = Class D \\<or> \\<not> P \\<turnstile> Class D \\<le> Class C\n 2. \\<And>C. NT = Class C \\<or> \\<not> P \\<turnstile> Class C \\<le> NT\n 3. \\<And>A.\n       NT = A\\<lfloor>\\<rceil> \\<or>\n       \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n 4. \\<And>A.\n       A\\<lfloor>\\<rceil> = Class Object \\<or>\n       \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n 5. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "fix C D"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>C D.\n       P \\<turnstile> C \\<preceq>\\<^sup>* D \\<Longrightarrow>\n       Class C = Class D \\<or> \\<not> P \\<turnstile> Class D \\<le> Class C\n 2. \\<And>C. NT = Class C \\<or> \\<not> P \\<turnstile> Class C \\<le> NT\n 3. \\<And>A.\n       NT = A\\<lfloor>\\<rceil> \\<or>\n       \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n 4. \\<And>A.\n       A\\<lfloor>\\<rceil> = Class Object \\<or>\n       \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n 5. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "assume CscD: \"P \\<turnstile> C \\<preceq>\\<^sup>* D\""], ["proof (state)\nthis:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n\ngoal (5 subgoals):\n 1. \\<And>C D.\n       P \\<turnstile> C \\<preceq>\\<^sup>* D \\<Longrightarrow>\n       Class C = Class D \\<or> \\<not> P \\<turnstile> Class D \\<le> Class C\n 2. \\<And>C. NT = Class C \\<or> \\<not> P \\<turnstile> Class C \\<le> NT\n 3. \\<And>A.\n       NT = A\\<lfloor>\\<rceil> \\<or>\n       \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n 4. \\<And>A.\n       A\\<lfloor>\\<rceil> = Class Object \\<or>\n       \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n 5. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D", "have CpscD: \"C = D \\<or> (C \\<noteq> D \\<and> (subcls1 P)\\<^sup>+\\<^sup>+ C D)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. C = D \\<or> C \\<noteq> D \\<and> (subcls1 P)\\<^sup>+\\<^sup>+ C D", "by (simp add: rtranclpD)"], ["proof (state)\nthis:\n  C = D \\<or> C \\<noteq> D \\<and> (subcls1 P)\\<^sup>+\\<^sup>+ C D\n\ngoal (5 subgoals):\n 1. \\<And>C D.\n       P \\<turnstile> C \\<preceq>\\<^sup>* D \\<Longrightarrow>\n       Class C = Class D \\<or> \\<not> P \\<turnstile> Class D \\<le> Class C\n 2. \\<And>C. NT = Class C \\<or> \\<not> P \\<turnstile> Class C \\<le> NT\n 3. \\<And>A.\n       NT = A\\<lfloor>\\<rceil> \\<or>\n       \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n 4. \\<And>A.\n       A\\<lfloor>\\<rceil> = Class Object \\<or>\n       \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n 5. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "{"], ["proof (state)\nthis:\n  C = D \\<or> C \\<noteq> D \\<and> (subcls1 P)\\<^sup>+\\<^sup>+ C D\n\ngoal (5 subgoals):\n 1. \\<And>C D.\n       P \\<turnstile> C \\<preceq>\\<^sup>* D \\<Longrightarrow>\n       Class C = Class D \\<or> \\<not> P \\<turnstile> Class D \\<le> Class C\n 2. \\<And>C. NT = Class C \\<or> \\<not> P \\<turnstile> Class C \\<le> NT\n 3. \\<And>A.\n       NT = A\\<lfloor>\\<rceil> \\<or>\n       \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n 4. \\<And>A.\n       A\\<lfloor>\\<rceil> = Class Object \\<or>\n       \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n 5. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "assume \"P \\<turnstile> D \\<preceq>\\<^sup>* C\""], ["proof (state)\nthis:\n  P \\<turnstile> D \\<preceq>\\<^sup>* C\n\ngoal (5 subgoals):\n 1. \\<And>C D.\n       P \\<turnstile> C \\<preceq>\\<^sup>* D \\<Longrightarrow>\n       Class C = Class D \\<or> \\<not> P \\<turnstile> Class D \\<le> Class C\n 2. \\<And>C. NT = Class C \\<or> \\<not> P \\<turnstile> Class C \\<le> NT\n 3. \\<And>A.\n       NT = A\\<lfloor>\\<rceil> \\<or>\n       \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n 4. \\<And>A.\n       A\\<lfloor>\\<rceil> = Class Object \\<or>\n       \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n 5. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> D \\<preceq>\\<^sup>* C", "have DpscC: \"D = C \\<or> (D \\<noteq> C \\<and> (subcls1 P)\\<^sup>+\\<^sup>+ D C)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. D = C \\<or> D \\<noteq> C \\<and> (subcls1 P)\\<^sup>+\\<^sup>+ D C", "by (simp add: rtranclpD)"], ["proof (state)\nthis:\n  D = C \\<or> D \\<noteq> C \\<and> (subcls1 P)\\<^sup>+\\<^sup>+ D C\n\ngoal (5 subgoals):\n 1. \\<And>C D.\n       P \\<turnstile> C \\<preceq>\\<^sup>* D \\<Longrightarrow>\n       Class C = Class D \\<or> \\<not> P \\<turnstile> Class D \\<le> Class C\n 2. \\<And>C. NT = Class C \\<or> \\<not> P \\<turnstile> Class C \\<le> NT\n 3. \\<And>A.\n       NT = A\\<lfloor>\\<rceil> \\<or>\n       \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n 4. \\<And>A.\n       A\\<lfloor>\\<rceil> = Class Object \\<or>\n       \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n 5. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "{"], ["proof (state)\nthis:\n  D = C \\<or> D \\<noteq> C \\<and> (subcls1 P)\\<^sup>+\\<^sup>+ D C\n\ngoal (5 subgoals):\n 1. \\<And>C D.\n       P \\<turnstile> C \\<preceq>\\<^sup>* D \\<Longrightarrow>\n       Class C = Class D \\<or> \\<not> P \\<turnstile> Class D \\<le> Class C\n 2. \\<And>C. NT = Class C \\<or> \\<not> P \\<turnstile> Class C \\<le> NT\n 3. \\<And>A.\n       NT = A\\<lfloor>\\<rceil> \\<or>\n       \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n 4. \\<And>A.\n       A\\<lfloor>\\<rceil> = Class Object \\<or>\n       \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n 5. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "assume \"(subcls1 P)\\<^sup>+\\<^sup>+ D C\""], ["proof (state)\nthis:\n  (subcls1 P)\\<^sup>+\\<^sup>+ D C\n\ngoal (5 subgoals):\n 1. \\<And>C D.\n       P \\<turnstile> C \\<preceq>\\<^sup>* D \\<Longrightarrow>\n       Class C = Class D \\<or> \\<not> P \\<turnstile> Class D \\<le> Class C\n 2. \\<And>C. NT = Class C \\<or> \\<not> P \\<turnstile> Class C \\<le> NT\n 3. \\<And>A.\n       NT = A\\<lfloor>\\<rceil> \\<or>\n       \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n 4. \\<And>A.\n       A\\<lfloor>\\<rceil> = Class Object \\<or>\n       \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n 5. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "with wfP"], ["proof (chain)\npicking this:\n  wf_prog wf_md P\n  (subcls1 P)\\<^sup>+\\<^sup>+ D C", "have CnscD: \"\\<not> (subcls1 P)\\<^sup>+\\<^sup>+ C D\""], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  (subcls1 P)\\<^sup>+\\<^sup>+ D C\n\ngoal (1 subgoal):\n 1. \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ C D", "by (rule subcls_asym)"], ["proof (state)\nthis:\n  \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ C D\n\ngoal (5 subgoals):\n 1. \\<And>C D.\n       P \\<turnstile> C \\<preceq>\\<^sup>* D \\<Longrightarrow>\n       Class C = Class D \\<or> \\<not> P \\<turnstile> Class D \\<le> Class C\n 2. \\<And>C. NT = Class C \\<or> \\<not> P \\<turnstile> Class C \\<le> NT\n 3. \\<And>A.\n       NT = A\\<lfloor>\\<rceil> \\<or>\n       \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n 4. \\<And>A.\n       A\\<lfloor>\\<rceil> = Class Object \\<or>\n       \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n 5. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "with CpscD"], ["proof (chain)\npicking this:\n  C = D \\<or> C \\<noteq> D \\<and> (subcls1 P)\\<^sup>+\\<^sup>+ C D\n  \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ C D", "have \"C = D\""], ["proof (prove)\nusing this:\n  C = D \\<or> C \\<noteq> D \\<and> (subcls1 P)\\<^sup>+\\<^sup>+ C D\n  \\<not> (subcls1 P)\\<^sup>+\\<^sup>+ C D\n\ngoal (1 subgoal):\n 1. C = D", "by simp"], ["proof (state)\nthis:\n  C = D\n\ngoal (5 subgoals):\n 1. \\<And>C D.\n       P \\<turnstile> C \\<preceq>\\<^sup>* D \\<Longrightarrow>\n       Class C = Class D \\<or> \\<not> P \\<turnstile> Class D \\<le> Class C\n 2. \\<And>C. NT = Class C \\<or> \\<not> P \\<turnstile> Class C \\<le> NT\n 3. \\<And>A.\n       NT = A\\<lfloor>\\<rceil> \\<or>\n       \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n 4. \\<And>A.\n       A\\<lfloor>\\<rceil> = Class Object \\<or>\n       \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n 5. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "}"], ["proof (state)\nthis:\n  (subcls1 P)\\<^sup>+\\<^sup>+ D C \\<Longrightarrow> C = D\n\ngoal (5 subgoals):\n 1. \\<And>C D.\n       P \\<turnstile> C \\<preceq>\\<^sup>* D \\<Longrightarrow>\n       Class C = Class D \\<or> \\<not> P \\<turnstile> Class D \\<le> Class C\n 2. \\<And>C. NT = Class C \\<or> \\<not> P \\<turnstile> Class C \\<le> NT\n 3. \\<And>A.\n       NT = A\\<lfloor>\\<rceil> \\<or>\n       \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n 4. \\<And>A.\n       A\\<lfloor>\\<rceil> = Class Object \\<or>\n       \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n 5. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "with DpscC"], ["proof (chain)\npicking this:\n  D = C \\<or> D \\<noteq> C \\<and> (subcls1 P)\\<^sup>+\\<^sup>+ D C\n  (subcls1 P)\\<^sup>+\\<^sup>+ D C \\<Longrightarrow> C = D", "have \"C = D\""], ["proof (prove)\nusing this:\n  D = C \\<or> D \\<noteq> C \\<and> (subcls1 P)\\<^sup>+\\<^sup>+ D C\n  (subcls1 P)\\<^sup>+\\<^sup>+ D C \\<Longrightarrow> C = D\n\ngoal (1 subgoal):\n 1. C = D", "by blast"], ["proof (state)\nthis:\n  C = D\n\ngoal (5 subgoals):\n 1. \\<And>C D.\n       P \\<turnstile> C \\<preceq>\\<^sup>* D \\<Longrightarrow>\n       Class C = Class D \\<or> \\<not> P \\<turnstile> Class D \\<le> Class C\n 2. \\<And>C. NT = Class C \\<or> \\<not> P \\<turnstile> Class C \\<le> NT\n 3. \\<And>A.\n       NT = A\\<lfloor>\\<rceil> \\<or>\n       \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n 4. \\<And>A.\n       A\\<lfloor>\\<rceil> = Class Object \\<or>\n       \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n 5. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "}"], ["proof (state)\nthis:\n  P \\<turnstile> D \\<preceq>\\<^sup>* C \\<Longrightarrow> C = D\n\ngoal (5 subgoals):\n 1. \\<And>C D.\n       P \\<turnstile> C \\<preceq>\\<^sup>* D \\<Longrightarrow>\n       Class C = Class D \\<or> \\<not> P \\<turnstile> Class D \\<le> Class C\n 2. \\<And>C. NT = Class C \\<or> \\<not> P \\<turnstile> Class C \\<le> NT\n 3. \\<And>A.\n       NT = A\\<lfloor>\\<rceil> \\<or>\n       \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n 4. \\<And>A.\n       A\\<lfloor>\\<rceil> = Class Object \\<or>\n       \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n 5. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "hence \"Class C = Class D \\<or> \\<not> (P \\<turnstile> D \\<preceq>\\<^sup>* C)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D \\<preceq>\\<^sup>* C \\<Longrightarrow> C = D\n\ngoal (1 subgoal):\n 1. Class C = Class D \\<or> \\<not> P \\<turnstile> D \\<preceq>\\<^sup>* C", "by blast"], ["proof (state)\nthis:\n  Class C = Class D \\<or> \\<not> P \\<turnstile> D \\<preceq>\\<^sup>* C\n\ngoal (5 subgoals):\n 1. \\<And>C D.\n       P \\<turnstile> C \\<preceq>\\<^sup>* D \\<Longrightarrow>\n       Class C = Class D \\<or> \\<not> P \\<turnstile> Class D \\<le> Class C\n 2. \\<And>C. NT = Class C \\<or> \\<not> P \\<turnstile> Class C \\<le> NT\n 3. \\<And>A.\n       NT = A\\<lfloor>\\<rceil> \\<or>\n       \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n 4. \\<And>A.\n       A\\<lfloor>\\<rceil> = Class Object \\<or>\n       \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n 5. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "thus \"Class C = Class D \\<or> \\<not> P \\<turnstile> Class D \\<le> Class C\""], ["proof (prove)\nusing this:\n  Class C = Class D \\<or> \\<not> P \\<turnstile> D \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. Class C = Class D \\<or> \\<not> P \\<turnstile> Class D \\<le> Class C", "by simp"], ["proof (state)\nthis:\n  Class C = Class D \\<or> \\<not> P \\<turnstile> Class D \\<le> Class C\n\ngoal (4 subgoals):\n 1. \\<And>C. NT = Class C \\<or> \\<not> P \\<turnstile> Class C \\<le> NT\n 2. \\<And>A.\n       NT = A\\<lfloor>\\<rceil> \\<or>\n       \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n 3. \\<And>A.\n       A\\<lfloor>\\<rceil> = Class Object \\<or>\n       \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n 4. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>C. NT = Class C \\<or> \\<not> P \\<turnstile> Class C \\<le> NT\n 2. \\<And>A.\n       NT = A\\<lfloor>\\<rceil> \\<or>\n       \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n 3. \\<And>A.\n       A\\<lfloor>\\<rceil> = Class Object \\<or>\n       \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n 4. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "fix C"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>C. NT = Class C \\<or> \\<not> P \\<turnstile> Class C \\<le> NT\n 2. \\<And>A.\n       NT = A\\<lfloor>\\<rceil> \\<or>\n       \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n 3. \\<And>A.\n       A\\<lfloor>\\<rceil> = Class Object \\<or>\n       \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n 4. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "show \"NT = Class C \\<or> \\<not> P \\<turnstile> Class C \\<le> NT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NT = Class C \\<or> \\<not> P \\<turnstile> Class C \\<le> NT", "by simp"], ["proof (state)\nthis:\n  NT = Class C \\<or> \\<not> P \\<turnstile> Class C \\<le> NT\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       NT = A\\<lfloor>\\<rceil> \\<or>\n       \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n 2. \\<And>A.\n       A\\<lfloor>\\<rceil> = Class Object \\<or>\n       \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n 3. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>A.\n       NT = A\\<lfloor>\\<rceil> \\<or>\n       \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n 2. \\<And>A.\n       A\\<lfloor>\\<rceil> = Class Object \\<or>\n       \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n 3. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "fix A"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>A.\n       NT = A\\<lfloor>\\<rceil> \\<or>\n       \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n 2. \\<And>A.\n       A\\<lfloor>\\<rceil> = Class Object \\<or>\n       \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n 3. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "{"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>A.\n       NT = A\\<lfloor>\\<rceil> \\<or>\n       \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n 2. \\<And>A.\n       A\\<lfloor>\\<rceil> = Class Object \\<or>\n       \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n 3. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "assume \"P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\""], ["proof (state)\nthis:\n  P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       NT = A\\<lfloor>\\<rceil> \\<or>\n       \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n 2. \\<And>A.\n       A\\<lfloor>\\<rceil> = Class Object \\<or>\n       \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n 3. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "hence \"A\\<lfloor>\\<rceil> = NT\""], ["proof (prove)\nusing this:\n  P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n\ngoal (1 subgoal):\n 1. A\\<lfloor>\\<rceil> = NT", "by fastforce"], ["proof (state)\nthis:\n  A\\<lfloor>\\<rceil> = NT\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       NT = A\\<lfloor>\\<rceil> \\<or>\n       \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n 2. \\<And>A.\n       A\\<lfloor>\\<rceil> = Class Object \\<or>\n       \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n 3. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "hence \"False\""], ["proof (prove)\nusing this:\n  A\\<lfloor>\\<rceil> = NT\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       NT = A\\<lfloor>\\<rceil> \\<or>\n       \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n 2. \\<And>A.\n       A\\<lfloor>\\<rceil> = Class Object \\<or>\n       \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n 3. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "}"], ["proof (state)\nthis:\n  P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT \\<Longrightarrow> False\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       NT = A\\<lfloor>\\<rceil> \\<or>\n       \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n 2. \\<And>A.\n       A\\<lfloor>\\<rceil> = Class Object \\<or>\n       \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n 3. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "hence \"\\<not> (P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT", "by blast"], ["proof (state)\nthis:\n  \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       NT = A\\<lfloor>\\<rceil> \\<or>\n       \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n 2. \\<And>A.\n       A\\<lfloor>\\<rceil> = Class Object \\<or>\n       \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n 3. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "thus \"NT = A\\<lfloor>\\<rceil> \\<or> \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\""], ["proof (prove)\nusing this:\n  \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n\ngoal (1 subgoal):\n 1. NT = A\\<lfloor>\\<rceil> \\<or>\n    \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT", "by simp"], ["proof (state)\nthis:\n  NT = A\\<lfloor>\\<rceil> \\<or>\n  \\<not> P \\<turnstile> A\\<lfloor>\\<rceil> \\<le> NT\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       A\\<lfloor>\\<rceil> = Class Object \\<or>\n       \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n 2. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       A\\<lfloor>\\<rceil> = Class Object \\<or>\n       \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n 2. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "fix A"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       A\\<lfloor>\\<rceil> = Class Object \\<or>\n       \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n 2. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "show \"A\\<lfloor>\\<rceil> = Class Object \\<or> \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A\\<lfloor>\\<rceil> = Class Object \\<or>\n    \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>", "by(auto dest: Object_widen)"], ["proof (state)\nthis:\n  A\\<lfloor>\\<rceil> = Class Object \\<or>\n  \\<not> P \\<turnstile> Class Object \\<le> A\\<lfloor>\\<rceil>\n\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "fix A B"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "assume AsU: \"P \\<turnstile> A \\<le> B\" and BnpscA: \"A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\""], ["proof (state)\nthis:\n  P \\<turnstile> A \\<le> B\n  A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\n\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "{"], ["proof (state)\nthis:\n  P \\<turnstile> A \\<le> B\n  A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\n\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "assume \"P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>\""], ["proof (state)\nthis:\n  P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>\n\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "hence \"P \\<turnstile> B \\<le> A\""], ["proof (prove)\nusing this:\n  P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> B \\<le> A", "by (auto dest: Array_Array_widen)"], ["proof (state)\nthis:\n  P \\<turnstile> B \\<le> A\n\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "with BnpscA"], ["proof (chain)\npicking this:\n  A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\n  P \\<turnstile> B \\<le> A", "have \"A = B\""], ["proof (prove)\nusing this:\n  A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\n  P \\<turnstile> B \\<le> A\n\ngoal (1 subgoal):\n 1. A = B", "by blast"], ["proof (state)\nthis:\n  A = B\n\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "hence \"A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil>\""], ["proof (prove)\nusing this:\n  A = B\n\ngoal (1 subgoal):\n 1. A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil>", "by simp"], ["proof (state)\nthis:\n  A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil>\n\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "}"], ["proof (state)\nthis:\n  P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil> \\<Longrightarrow>\n  A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil>\n\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>P \\<turnstile> A \\<le> B;\n        A = B \\<or> \\<not> P \\<turnstile> B \\<le> A\\<rbrakk>\n       \\<Longrightarrow> A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n                         \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "thus \"A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or> \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>\""], ["proof (prove)\nusing this:\n  P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil> \\<Longrightarrow>\n  A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil>\n\ngoal (1 subgoal):\n 1. A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n    \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>", "by blast"], ["proof (state)\nthis:\n  A\\<lfloor>\\<rceil> = B\\<lfloor>\\<rceil> \\<or>\n  \\<not> P \\<turnstile> B\\<lfloor>\\<rceil> \\<le> A\\<lfloor>\\<rceil>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma widen_asym: \"\\<lbrakk> wf_prog wf_md P; P \\<turnstile> C \\<le> D; C \\<noteq> D \\<rbrakk> \\<Longrightarrow> \\<not> (P \\<turnstile> D \\<le> C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; P \\<turnstile> C \\<le> D;\n     C \\<noteq> D\\<rbrakk>\n    \\<Longrightarrow> \\<not> P \\<turnstile> D \\<le> C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; P \\<turnstile> C \\<le> D;\n     C \\<noteq> D\\<rbrakk>\n    \\<Longrightarrow> \\<not> P \\<turnstile> D \\<le> C", "assume wfP: \"wf_prog wf_md P\" and CsD: \"P \\<turnstile> C \\<le> D\" and CneqD: \"C \\<noteq> D\""], ["proof (state)\nthis:\n  wf_prog wf_md P\n  P \\<turnstile> C \\<le> D\n  C \\<noteq> D\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; P \\<turnstile> C \\<le> D;\n     C \\<noteq> D\\<rbrakk>\n    \\<Longrightarrow> \\<not> P \\<turnstile> D \\<le> C", "from wfP CsD"], ["proof (chain)\npicking this:\n  wf_prog wf_md P\n  P \\<turnstile> C \\<le> D", "have \"C = D \\<or> \\<not> (P \\<turnstile> D \\<le> C)\""], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  P \\<turnstile> C \\<le> D\n\ngoal (1 subgoal):\n 1. C = D \\<or> \\<not> P \\<turnstile> D \\<le> C", "by (rule widen_asym_1)"], ["proof (state)\nthis:\n  C = D \\<or> \\<not> P \\<turnstile> D \\<le> C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; P \\<turnstile> C \\<le> D;\n     C \\<noteq> D\\<rbrakk>\n    \\<Longrightarrow> \\<not> P \\<turnstile> D \\<le> C", "with CneqD"], ["proof (chain)\npicking this:\n  C \\<noteq> D\n  C = D \\<or> \\<not> P \\<turnstile> D \\<le> C", "show ?thesis"], ["proof (prove)\nusing this:\n  C \\<noteq> D\n  C = D \\<or> \\<not> P \\<turnstile> D \\<le> C\n\ngoal (1 subgoal):\n 1. \\<not> P \\<turnstile> D \\<le> C", "by simp"], ["proof (state)\nthis:\n  \\<not> P \\<turnstile> D \\<le> C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma widen_antisym:\n  \"\\<lbrakk> wf_prog m P; P \\<turnstile> T \\<le> U; P \\<turnstile> U \\<le> T \\<rbrakk> \\<Longrightarrow> T = U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog m P; P \\<turnstile> T \\<le> U;\n     P \\<turnstile> U \\<le> T\\<rbrakk>\n    \\<Longrightarrow> T = U", "by(auto dest: widen_asym)"], ["", "lemma widen_C_Object: \"\\<lbrakk> wf_prog wf_md P; is_class P C \\<rbrakk> \\<Longrightarrow> P \\<turnstile> Class C \\<le> Class Object\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; is_class P C\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> Class C \\<le> Class Object", "by(simp add: subcls_C_Object)"], ["", "lemma is_refType_widen_Object:\n  assumes wfP: \"wf_prog wfmc P\"\n  shows \"\\<lbrakk> is_type P A; is_refT A \\<rbrakk> \\<Longrightarrow> P \\<turnstile> A \\<le> Class Object\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_type P A; is_refT A\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> A \\<le> Class Object", "by(induct A)(auto elim: refTE intro: subcls_C_Object[OF _ wfP] widen_array_object)"], ["", "lemma is_lub_unique:\n  assumes wf: \"wf_prog wf_md P\"\n  shows \"\\<lbrakk> P \\<turnstile> lub(U, V) = T; P \\<turnstile> lub(U, V) = T' \\<rbrakk> \\<Longrightarrow> T = T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> lub(U, V) = T;\n     P \\<turnstile> lub(U, V) = T'\\<rbrakk>\n    \\<Longrightarrow> T = T'", "by(auto elim!: is_lub.cases intro: widen_antisym[OF wf])"], ["", "subsection\\<open>Well-formedness and method lookup\\<close>"], ["", "lemma sees_wf_mdecl:\n  \"\\<lbrakk> wf_prog wf_md P; P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in D \\<rbrakk> \\<Longrightarrow> wf_mdecl wf_md P D (M,Ts,T,m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D\\<rbrakk>\n    \\<Longrightarrow> wf_mdecl wf_md P D (M, Ts, T, m)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D\\<rbrakk>\n    \\<Longrightarrow> wf_mdecl wf_md P D (M, Ts, T, m)", "apply(drule visible_method_exists)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P;\n     \\<exists>D' fs ms.\n        class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n        map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> wf_mdecl wf_md P D (M, Ts, T, m)", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D' fs ms.\n       \\<lbrakk>wf_prog wf_md P; class P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n        map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> wf_mdecl wf_md P D (M, Ts, T, m)", "apply(drule class_wf, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D' fs ms.\n       \\<lbrakk>wf_prog wf_md P; map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>;\n        wf_cdecl wf_md P (D, D', fs, ms)\\<rbrakk>\n       \\<Longrightarrow> wf_mdecl wf_md P D (M, Ts, T, m)", "apply(drule map_of_SomeD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D' fs ms.\n       \\<lbrakk>wf_prog wf_md P; wf_cdecl wf_md P (D, D', fs, ms);\n        (M, Ts, T, m) \\<in> set ms\\<rbrakk>\n       \\<Longrightarrow> wf_mdecl wf_md P D (M, Ts, T, m)", "apply(auto simp add: wf_cdecl_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma sees_method_mono [rule_format (no_asm)]: \n  \"\\<lbrakk> P \\<turnstile> C' \\<preceq>\\<^sup>* C; wf_prog wf_md P \\<rbrakk> \\<Longrightarrow>\n  \\<forall>D Ts T m. P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in D \\<longrightarrow>\n     (\\<exists>D' Ts' T' m'. P \\<turnstile> C' sees M:Ts'\\<rightarrow>T' = m' in D' \\<and> P \\<turnstile> Ts [\\<le>] Ts' \\<and> P \\<turnstile> T' \\<le> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C' \\<preceq>\\<^sup>* C; wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> \\<forall>D Ts T m.\n                         P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<longrightarrow>\n                         (\\<exists>D' Ts' T' m'.\n                             P \\<turnstile> C' sees M: Ts'\\<rightarrow>T' = m' in D' \\<and>\n                             P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                             P \\<turnstile> T' \\<le> T)", "apply( drule rtranclpD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P;\n     C' = C \\<or>\n     C' \\<noteq> C \\<and> (subcls1 P)\\<^sup>+\\<^sup>+ C' C\\<rbrakk>\n    \\<Longrightarrow> \\<forall>D Ts T m.\n                         P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<longrightarrow>\n                         (\\<exists>D' Ts' T' m'.\n                             P \\<turnstile> C' sees M: Ts'\\<rightarrow>T' = m' in D' \\<and>\n                             P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                             P \\<turnstile> T' \\<le> T)", "apply( erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_prog wf_md P; C' = C\\<rbrakk>\n    \\<Longrightarrow> \\<forall>D Ts T m.\n                         P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<longrightarrow>\n                         (\\<exists>D' Ts' T' m'.\n                             P \\<turnstile> C' sees M: Ts'\\<rightarrow>T' = m' in D' \\<and>\n                             P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                             P \\<turnstile> T' \\<le> T)\n 2. \\<lbrakk>wf_prog wf_md P;\n     C' \\<noteq> C \\<and> (subcls1 P)\\<^sup>+\\<^sup>+ C' C\\<rbrakk>\n    \\<Longrightarrow> \\<forall>D Ts T m.\n                         P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<longrightarrow>\n                         (\\<exists>D' Ts' T' m'.\n                             P \\<turnstile> C' sees M: Ts'\\<rightarrow>T' = m' in D' \\<and>\n                             P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                             P \\<turnstile> T' \\<le> T)", "apply(  fastforce intro: widen_refl widens_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P;\n     C' \\<noteq> C \\<and> (subcls1 P)\\<^sup>+\\<^sup>+ C' C\\<rbrakk>\n    \\<Longrightarrow> \\<forall>D Ts T m.\n                         P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<longrightarrow>\n                         (\\<exists>D' Ts' T' m'.\n                             P \\<turnstile> C' sees M: Ts'\\<rightarrow>T' = m' in D' \\<and>\n                             P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                             P \\<turnstile> T' \\<le> T)", "apply( erule conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C;\n     (subcls1 P)\\<^sup>+\\<^sup>+ C' C\\<rbrakk>\n    \\<Longrightarrow> \\<forall>D Ts T m.\n                         P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<longrightarrow>\n                         (\\<exists>D' Ts' T' m'.\n                             P \\<turnstile> C' sees M: Ts'\\<rightarrow>T' = m' in D' \\<and>\n                             P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                             P \\<turnstile> T' \\<le> T)", "apply( erule tranclp_trans_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C;\n        P \\<turnstile> x \\<prec>\\<^sup>1 y\\<rbrakk>\n       \\<Longrightarrow> \\<forall>D Ts T m.\n                            P \\<turnstile> y sees M: Ts\\<rightarrow>T = m in D \\<longrightarrow>\n                            (\\<exists>D' Ts' T' m'.\n                                P \\<turnstile> x sees M: Ts'\\<rightarrow>T' = m' in D' \\<and>\n                                P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                                P \\<turnstile> T' \\<le> T)\n 2. \\<And>x y z.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C;\n        (subcls1 P)\\<^sup>+\\<^sup>+ x y;\n        \\<forall>D Ts T m.\n           P \\<turnstile> y sees M: Ts\\<rightarrow>T = m in D \\<longrightarrow>\n           (\\<exists>D' Ts' T' m'.\n               P \\<turnstile> x sees M: Ts'\\<rightarrow>T' = m' in D' \\<and>\n               P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n               P \\<turnstile> T' \\<le> T);\n        (subcls1 P)\\<^sup>+\\<^sup>+ y z;\n        \\<forall>D Ts T m.\n           P \\<turnstile> z sees M: Ts\\<rightarrow>T = m in D \\<longrightarrow>\n           (\\<exists>D' Ts' T' m'.\n               P \\<turnstile> y sees M: Ts'\\<rightarrow>T' = m' in D' \\<and>\n               P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n               P \\<turnstile> T' \\<le> T)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>D Ts T m.\n                            P \\<turnstile> z sees M: Ts\\<rightarrow>T = m in D \\<longrightarrow>\n                            (\\<exists>D' Ts' T' m'.\n                                P \\<turnstile> x sees M: Ts'\\<rightarrow>T' = m' in D' \\<and>\n                                P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                                P \\<turnstile> T' \\<le> T)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C;\n        (subcls1 P)\\<^sup>+\\<^sup>+ x y;\n        \\<forall>D Ts T m.\n           P \\<turnstile> y sees M: Ts\\<rightarrow>T = m in D \\<longrightarrow>\n           (\\<exists>D' Ts' T' m'.\n               P \\<turnstile> x sees M: Ts'\\<rightarrow>T' = m' in D' \\<and>\n               P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n               P \\<turnstile> T' \\<le> T);\n        (subcls1 P)\\<^sup>+\\<^sup>+ y z;\n        \\<forall>D Ts T m.\n           P \\<turnstile> z sees M: Ts\\<rightarrow>T = m in D \\<longrightarrow>\n           (\\<exists>D' Ts' T' m'.\n               P \\<turnstile> y sees M: Ts'\\<rightarrow>T' = m' in D' \\<and>\n               P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n               P \\<turnstile> T' \\<le> T)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>D Ts T m.\n                            P \\<turnstile> z sees M: Ts\\<rightarrow>T = m in D \\<longrightarrow>\n                            (\\<exists>D' Ts' T' m'.\n                                P \\<turnstile> x sees M: Ts'\\<rightarrow>T' = m' in D' \\<and>\n                                P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                                P \\<turnstile> T' \\<le> T)\n 2. \\<And>x y.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C;\n        P \\<turnstile> x \\<prec>\\<^sup>1 y\\<rbrakk>\n       \\<Longrightarrow> \\<forall>D Ts T m.\n                            P \\<turnstile> y sees M: Ts\\<rightarrow>T = m in D \\<longrightarrow>\n                            (\\<exists>D' Ts' T' m'.\n                                P \\<turnstile> x sees M: Ts'\\<rightarrow>T' = m' in D' \\<and>\n                                P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                                P \\<turnstile> T' \\<le> T)", "apply(  clarify)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z D Ts T m.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C;\n        (subcls1 P)\\<^sup>+\\<^sup>+ x y;\n        \\<forall>D Ts T m.\n           P \\<turnstile> y sees M: Ts\\<rightarrow>T = m in D \\<longrightarrow>\n           (\\<exists>D' Ts' T' m'.\n               P \\<turnstile> x sees M: Ts'\\<rightarrow>T' = m' in D' \\<and>\n               P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n               P \\<turnstile> T' \\<le> T);\n        (subcls1 P)\\<^sup>+\\<^sup>+ y z;\n        \\<forall>D Ts T m.\n           P \\<turnstile> z sees M: Ts\\<rightarrow>T = m in D \\<longrightarrow>\n           (\\<exists>D' Ts' T' m'.\n               P \\<turnstile> y sees M: Ts'\\<rightarrow>T' = m' in D' \\<and>\n               P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n               P \\<turnstile> T' \\<le> T);\n        P \\<turnstile> z sees M: Ts\\<rightarrow>T = m in D\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D' Ts' T' m'.\n                            P \\<turnstile> x sees M: Ts'\\<rightarrow>T' = m' in D' \\<and>\n                            P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                            P \\<turnstile> T' \\<le> T\n 2. \\<And>x y.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C;\n        P \\<turnstile> x \\<prec>\\<^sup>1 y\\<rbrakk>\n       \\<Longrightarrow> \\<forall>D Ts T m.\n                            P \\<turnstile> y sees M: Ts\\<rightarrow>T = m in D \\<longrightarrow>\n                            (\\<exists>D' Ts' T' m'.\n                                P \\<turnstile> x sees M: Ts'\\<rightarrow>T' = m' in D' \\<and>\n                                P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                                P \\<turnstile> T' \\<le> T)", "apply(  drule spec, drule spec, drule spec, drule spec, erule (1) impE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z D Ts T m.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C;\n        (subcls1 P)\\<^sup>+\\<^sup>+ x y;\n        \\<forall>D Ts T m.\n           P \\<turnstile> y sees M: Ts\\<rightarrow>T = m in D \\<longrightarrow>\n           (\\<exists>D' Ts' T' m'.\n               P \\<turnstile> x sees M: Ts'\\<rightarrow>T' = m' in D' \\<and>\n               P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n               P \\<turnstile> T' \\<le> T);\n        (subcls1 P)\\<^sup>+\\<^sup>+ y z;\n        P \\<turnstile> z sees M: Ts\\<rightarrow>T = m in D;\n        \\<exists>D' Ts' T' m'.\n           P \\<turnstile> y sees M: Ts'\\<rightarrow>T' = m' in D' \\<and>\n           P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n           P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D' Ts' T' m'.\n                            P \\<turnstile> x sees M: Ts'\\<rightarrow>T' = m' in D' \\<and>\n                            P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                            P \\<turnstile> T' \\<le> T\n 2. \\<And>x y.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C;\n        P \\<turnstile> x \\<prec>\\<^sup>1 y\\<rbrakk>\n       \\<Longrightarrow> \\<forall>D Ts T m.\n                            P \\<turnstile> y sees M: Ts\\<rightarrow>T = m in D \\<longrightarrow>\n                            (\\<exists>D' Ts' T' m'.\n                                P \\<turnstile> x sees M: Ts'\\<rightarrow>T' = m' in D' \\<and>\n                                P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                                P \\<turnstile> T' \\<le> T)", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z D Ts T m D' Ts' T' m'.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C;\n        (subcls1 P)\\<^sup>+\\<^sup>+ x y;\n        \\<forall>D Ts T m.\n           P \\<turnstile> y sees M: Ts\\<rightarrow>T = m in D \\<longrightarrow>\n           (\\<exists>D' Ts' T' m'.\n               P \\<turnstile> x sees M: Ts'\\<rightarrow>T' = m' in D' \\<and>\n               P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n               P \\<turnstile> T' \\<le> T);\n        (subcls1 P)\\<^sup>+\\<^sup>+ y z;\n        P \\<turnstile> z sees M: Ts\\<rightarrow>T = m in D;\n        P \\<turnstile> y sees M: Ts'\\<rightarrow>T' = m' in D';\n        P \\<turnstile> Ts [\\<le>] Ts'; P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D' Ts' T' m'.\n                            P \\<turnstile> x sees M: Ts'\\<rightarrow>T' = m' in D' \\<and>\n                            P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                            P \\<turnstile> T' \\<le> T\n 2. \\<And>x y.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C;\n        P \\<turnstile> x \\<prec>\\<^sup>1 y\\<rbrakk>\n       \\<Longrightarrow> \\<forall>D Ts T m.\n                            P \\<turnstile> y sees M: Ts\\<rightarrow>T = m in D \\<longrightarrow>\n                            (\\<exists>D' Ts' T' m'.\n                                P \\<turnstile> x sees M: Ts'\\<rightarrow>T' = m' in D' \\<and>\n                                P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                                P \\<turnstile> T' \\<le> T)", "apply(  fast elim: widen_trans widens_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C;\n        P \\<turnstile> x \\<prec>\\<^sup>1 y\\<rbrakk>\n       \\<Longrightarrow> \\<forall>D Ts T m.\n                            P \\<turnstile> y sees M: Ts\\<rightarrow>T = m in D \\<longrightarrow>\n                            (\\<exists>D' Ts' T' m'.\n                                P \\<turnstile> x sees M: Ts'\\<rightarrow>T' = m' in D' \\<and>\n                                P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                                P \\<turnstile> T' \\<le> T)", "apply( clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y D Ts T m.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C;\n        P \\<turnstile> x \\<prec>\\<^sup>1 y;\n        P \\<turnstile> y sees M: Ts\\<rightarrow>T = m in D\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D' Ts' T' m'.\n                            P \\<turnstile> x sees M: Ts'\\<rightarrow>T' = m' in D' \\<and>\n                            P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                            P \\<turnstile> T' \\<le> T", "apply( drule subcls1D)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y D Ts T m.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C;\n        P \\<turnstile> y sees M: Ts\\<rightarrow>T = m in D;\n        x \\<noteq> Object \\<and>\n        (\\<exists>fs ms. class P x = \\<lfloor>(y, fs, ms)\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D' Ts' T' m'.\n                            P \\<turnstile> x sees M: Ts'\\<rightarrow>T' = m' in D' \\<and>\n                            P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                            P \\<turnstile> T' \\<le> T", "apply( clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y D Ts T m fs ms.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C;\n        P \\<turnstile> y sees M: Ts\\<rightarrow>T = m in D;\n        x \\<noteq> Object;\n        class P x = \\<lfloor>(y, fs, ms)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D' Ts' T' m'.\n                            P \\<turnstile> x sees M: Ts'\\<rightarrow>T' = m' in D' \\<and>\n                            P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                            P \\<turnstile> T' \\<le> T", "apply(clarsimp simp:Method_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y D Ts T m fs ms Mm.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C; x \\<noteq> Object;\n        class P x = \\<lfloor>(y, fs, ms)\\<rfloor>;\n        P \\<turnstile> y sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D' Ts' T'.\n                            (\\<exists>m' Mm.\n                                P \\<turnstile> x sees_methods Mm \\<and>\n                                Mm M =\n                                \\<lfloor>((Ts', T', m'),\n    D')\\<rfloor>) \\<and>\n                            P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                            P \\<turnstile> T' \\<le> T", "apply(frule (2) sees_methods_rec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y D Ts T m fs ms Mm.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C; x \\<noteq> Object;\n        class P x = \\<lfloor>(y, fs, ms)\\<rfloor>;\n        P \\<turnstile> y sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> ?Mm'87 x y D Ts T m fs ms Mm =\n                         Mm ++\n                         (map_option (\\<lambda>m. (m, x)) \\<circ> map_of ms)\n 2. \\<And>x y D Ts T m fs ms Mm.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C; x \\<noteq> Object;\n        class P x = \\<lfloor>(y, fs, ms)\\<rfloor>;\n        P \\<turnstile> y sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> x sees_methods ?Mm'87 x y D Ts T m fs ms Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D' Ts' T'.\n                            (\\<exists>m' Mm.\n                                P \\<turnstile> x sees_methods Mm \\<and>\n                                Mm M =\n                                \\<lfloor>((Ts', T', m'),\n    D')\\<rfloor>) \\<and>\n                            P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                            P \\<turnstile> T' \\<le> T", "apply(rule refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y D Ts T m fs ms Mm.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C; x \\<noteq> Object;\n        class P x = \\<lfloor>(y, fs, ms)\\<rfloor>;\n        P \\<turnstile> y sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> x sees_methods Mm ++\n(map_option (\\<lambda>m. (m, x)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D' Ts' T'.\n                            (\\<exists>m' Mm.\n                                P \\<turnstile> x sees_methods Mm \\<and>\n                                Mm M =\n                                \\<lfloor>((Ts', T', m'),\n    D')\\<rfloor>) \\<and>\n                            P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                            P \\<turnstile> T' \\<le> T", "apply(case_tac \"map_of ms M\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y D Ts T m fs ms Mm.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C; x \\<noteq> Object;\n        class P x = \\<lfloor>(y, fs, ms)\\<rfloor>;\n        P \\<turnstile> y sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> x sees_methods Mm ++\n(map_option (\\<lambda>m. (m, x)) \\<circ> map_of ms);\n        map_of ms M = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D' Ts' T'.\n                            (\\<exists>m' Mm.\n                                P \\<turnstile> x sees_methods Mm \\<and>\n                                Mm M =\n                                \\<lfloor>((Ts', T', m'),\n    D')\\<rfloor>) \\<and>\n                            P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                            P \\<turnstile> T' \\<le> T\n 2. \\<And>x y D Ts T m fs ms Mm a.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C; x \\<noteq> Object;\n        class P x = \\<lfloor>(y, fs, ms)\\<rfloor>;\n        P \\<turnstile> y sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> x sees_methods Mm ++\n(map_option (\\<lambda>m. (m, x)) \\<circ> map_of ms);\n        map_of ms M = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D' Ts' T'.\n                            (\\<exists>m' Mm.\n                                P \\<turnstile> x sees_methods Mm \\<and>\n                                Mm M =\n                                \\<lfloor>((Ts', T', m'),\n    D')\\<rfloor>) \\<and>\n                            P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                            P \\<turnstile> T' \\<le> T", "apply(rule_tac x = D in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y D Ts T m fs ms Mm.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C; x \\<noteq> Object;\n        class P x = \\<lfloor>(y, fs, ms)\\<rfloor>;\n        P \\<turnstile> y sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> x sees_methods Mm ++\n(map_option (\\<lambda>m. (m, x)) \\<circ> map_of ms);\n        map_of ms M = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts' T'.\n                            (\\<exists>m' Mm.\n                                P \\<turnstile> x sees_methods Mm \\<and>\n                                Mm M =\n                                \\<lfloor>((Ts', T', m'), D)\\<rfloor>) \\<and>\n                            P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                            P \\<turnstile> T' \\<le> T\n 2. \\<And>x y D Ts T m fs ms Mm a.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C; x \\<noteq> Object;\n        class P x = \\<lfloor>(y, fs, ms)\\<rfloor>;\n        P \\<turnstile> y sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> x sees_methods Mm ++\n(map_option (\\<lambda>m. (m, x)) \\<circ> map_of ms);\n        map_of ms M = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D' Ts' T'.\n                            (\\<exists>m' Mm.\n                                P \\<turnstile> x sees_methods Mm \\<and>\n                                Mm M =\n                                \\<lfloor>((Ts', T', m'),\n    D')\\<rfloor>) \\<and>\n                            P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                            P \\<turnstile> T' \\<le> T", "apply(rule_tac x = Ts in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y D Ts T m fs ms Mm.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C; x \\<noteq> Object;\n        class P x = \\<lfloor>(y, fs, ms)\\<rfloor>;\n        P \\<turnstile> y sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> x sees_methods Mm ++\n(map_option (\\<lambda>m. (m, x)) \\<circ> map_of ms);\n        map_of ms M = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T'.\n                            (\\<exists>m' Mm.\n                                P \\<turnstile> x sees_methods Mm \\<and>\n                                Mm M =\n                                \\<lfloor>((Ts, T', m'), D)\\<rfloor>) \\<and>\n                            P \\<turnstile> Ts [\\<le>] Ts \\<and>\n                            P \\<turnstile> T' \\<le> T\n 2. \\<And>x y D Ts T m fs ms Mm a.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C; x \\<noteq> Object;\n        class P x = \\<lfloor>(y, fs, ms)\\<rfloor>;\n        P \\<turnstile> y sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> x sees_methods Mm ++\n(map_option (\\<lambda>m. (m, x)) \\<circ> map_of ms);\n        map_of ms M = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D' Ts' T'.\n                            (\\<exists>m' Mm.\n                                P \\<turnstile> x sees_methods Mm \\<and>\n                                Mm M =\n                                \\<lfloor>((Ts', T', m'),\n    D')\\<rfloor>) \\<and>\n                            P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                            P \\<turnstile> T' \\<le> T", "apply(rule_tac x = T in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y D Ts T m fs ms Mm.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C; x \\<noteq> Object;\n        class P x = \\<lfloor>(y, fs, ms)\\<rfloor>;\n        P \\<turnstile> y sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> x sees_methods Mm ++\n(map_option (\\<lambda>m. (m, x)) \\<circ> map_of ms);\n        map_of ms M = None\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>m' Mm.\n                             P \\<turnstile> x sees_methods Mm \\<and>\n                             Mm M =\n                             \\<lfloor>((Ts, T, m'), D)\\<rfloor>) \\<and>\n                         P \\<turnstile> Ts [\\<le>] Ts \\<and>\n                         P \\<turnstile> T \\<le> T\n 2. \\<And>x y D Ts T m fs ms Mm a.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C; x \\<noteq> Object;\n        class P x = \\<lfloor>(y, fs, ms)\\<rfloor>;\n        P \\<turnstile> y sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> x sees_methods Mm ++\n(map_option (\\<lambda>m. (m, x)) \\<circ> map_of ms);\n        map_of ms M = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D' Ts' T'.\n                            (\\<exists>m' Mm.\n                                P \\<turnstile> x sees_methods Mm \\<and>\n                                Mm M =\n                                \\<lfloor>((Ts', T', m'),\n    D')\\<rfloor>) \\<and>\n                            P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                            P \\<turnstile> T' \\<le> T", "apply(clarsimp simp add: widens_refl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y D Ts T m fs ms Mm.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C; x \\<noteq> Object;\n        class P x = \\<lfloor>(y, fs, ms)\\<rfloor>;\n        P \\<turnstile> y sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> x sees_methods Mm ++\n(map_option (\\<lambda>m. (m, x)) \\<circ> map_of ms);\n        map_of ms M = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m' Mm.\n                            P \\<turnstile> x sees_methods Mm \\<and>\n                            Mm M = \\<lfloor>((Ts, T, m'), D)\\<rfloor>\n 2. \\<And>x y D Ts T m fs ms Mm a.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C; x \\<noteq> Object;\n        class P x = \\<lfloor>(y, fs, ms)\\<rfloor>;\n        P \\<turnstile> y sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> x sees_methods Mm ++\n(map_option (\\<lambda>m. (m, x)) \\<circ> map_of ms);\n        map_of ms M = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D' Ts' T'.\n                            (\\<exists>m' Mm.\n                                P \\<turnstile> x sees_methods Mm \\<and>\n                                Mm M =\n                                \\<lfloor>((Ts', T', m'),\n    D')\\<rfloor>) \\<and>\n                            P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                            P \\<turnstile> T' \\<le> T", "apply(rule_tac x = m in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y D Ts T m fs ms Mm.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C; x \\<noteq> Object;\n        class P x = \\<lfloor>(y, fs, ms)\\<rfloor>;\n        P \\<turnstile> y sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> x sees_methods Mm ++\n(map_option (\\<lambda>m. (m, x)) \\<circ> map_of ms);\n        map_of ms M = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm.\n                            P \\<turnstile> x sees_methods Mm \\<and>\n                            Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>\n 2. \\<And>x y D Ts T m fs ms Mm a.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C; x \\<noteq> Object;\n        class P x = \\<lfloor>(y, fs, ms)\\<rfloor>;\n        P \\<turnstile> y sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> x sees_methods Mm ++\n(map_option (\\<lambda>m. (m, x)) \\<circ> map_of ms);\n        map_of ms M = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D' Ts' T'.\n                            (\\<exists>m' Mm.\n                                P \\<turnstile> x sees_methods Mm \\<and>\n                                Mm M =\n                                \\<lfloor>((Ts', T', m'),\n    D')\\<rfloor>) \\<and>\n                            P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                            P \\<turnstile> T' \\<le> T", "apply(fastforce simp add:map_add_def split:option.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y D Ts T m fs ms Mm a.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C; x \\<noteq> Object;\n        class P x = \\<lfloor>(y, fs, ms)\\<rfloor>;\n        P \\<turnstile> y sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> x sees_methods Mm ++\n(map_option (\\<lambda>m. (m, x)) \\<circ> map_of ms);\n        map_of ms M = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D' Ts' T'.\n                            (\\<exists>m' Mm.\n                                P \\<turnstile> x sees_methods Mm \\<and>\n                                Mm M =\n                                \\<lfloor>((Ts', T', m'),\n    D')\\<rfloor>) \\<and>\n                            P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                            P \\<turnstile> T' \\<le> T", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y D Ts T m fs ms Mm a aa b.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C; x \\<noteq> Object;\n        class P x = \\<lfloor>(y, fs, ms)\\<rfloor>;\n        P \\<turnstile> y sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> x sees_methods Mm ++\n(map_option (\\<lambda>m. (m, x)) \\<circ> map_of ms);\n        map_of ms M = \\<lfloor>(a, aa, b)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D' Ts' T'.\n                            (\\<exists>m' Mm.\n                                P \\<turnstile> x sees_methods Mm \\<and>\n                                Mm M =\n                                \\<lfloor>((Ts', T', m'),\n    D')\\<rfloor>) \\<and>\n                            P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                            P \\<turnstile> T' \\<le> T", "apply(rename_tac Ts' T' m')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y D Ts T m fs ms Mm Ts' T' m'.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C; x \\<noteq> Object;\n        class P x = \\<lfloor>(y, fs, ms)\\<rfloor>;\n        P \\<turnstile> y sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> x sees_methods Mm ++\n(map_option (\\<lambda>m. (m, x)) \\<circ> map_of ms);\n        map_of ms M = \\<lfloor>(Ts', T', m')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D' Ts' T'.\n                            (\\<exists>m' Mm.\n                                P \\<turnstile> x sees_methods Mm \\<and>\n                                Mm M =\n                                \\<lfloor>((Ts', T', m'),\n    D')\\<rfloor>) \\<and>\n                            P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                            P \\<turnstile> T' \\<le> T", "apply( drule (1) class_wf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y D Ts T m fs ms Mm Ts' T' m'.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C; x \\<noteq> Object;\n        P \\<turnstile> y sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> x sees_methods Mm ++\n(map_option (\\<lambda>m. (m, x)) \\<circ> map_of ms);\n        map_of ms M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        wf_cdecl wf_md P (x, y, fs, ms)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D' Ts' T'.\n                            (\\<exists>m' Mm.\n                                P \\<turnstile> x sees_methods Mm \\<and>\n                                Mm M =\n                                \\<lfloor>((Ts', T', m'),\n    D')\\<rfloor>) \\<and>\n                            P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                            P \\<turnstile> T' \\<le> T", "apply( unfold wf_cdecl_def Method_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y D Ts T m fs ms Mm Ts' T' m'.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C; x \\<noteq> Object;\n        P \\<turnstile> y sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> x sees_methods Mm ++\n(map_option (\\<lambda>m. (m, x)) \\<circ> map_of ms);\n        map_of ms M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        case (x, y, fs, ms) of\n        (C, D, fs, ms) \\<Rightarrow>\n          (\\<forall>f\\<in>set fs. wf_fdecl P f) \\<and>\n          distinct_fst fs \\<and>\n          (\\<forall>m\\<in>set ms. wf_mdecl wf_md P C m) \\<and>\n          distinct_fst ms \\<and>\n          (C \\<noteq> Object \\<longrightarrow>\n           is_class P D \\<and>\n           \\<not> P \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n           (\\<forall>m\\<in>set ms. wf_overriding P D m)) \\<and>\n          (C = Thread \\<longrightarrow>\n           (\\<exists>m. (run, [], Void, m) \\<in> set ms))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D' Ts' T'.\n                            (\\<exists>m' Mm.\n                                P \\<turnstile> x sees_methods Mm \\<and>\n                                Mm M =\n                                \\<lfloor>((Ts', T', m'),\n    D')\\<rfloor>) \\<and>\n                            P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                            P \\<turnstile> T' \\<le> T", "apply( frule map_of_SomeD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y D Ts T m fs ms Mm Ts' T' m'.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C; x \\<noteq> Object;\n        P \\<turnstile> y sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> x sees_methods Mm ++\n(map_option (\\<lambda>m. (m, x)) \\<circ> map_of ms);\n        map_of ms M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        case (x, y, fs, ms) of\n        (C, D, fs, ms) \\<Rightarrow>\n          (\\<forall>f\\<in>set fs. wf_fdecl P f) \\<and>\n          distinct_fst fs \\<and>\n          (\\<forall>m\\<in>set ms. wf_mdecl wf_md P C m) \\<and>\n          distinct_fst ms \\<and>\n          (C \\<noteq> Object \\<longrightarrow>\n           is_class P D \\<and>\n           \\<not> P \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n           (\\<forall>m\\<in>set ms. wf_overriding P D m)) \\<and>\n          (C = Thread \\<longrightarrow>\n           (\\<exists>m. (run, [], Void, m) \\<in> set ms));\n        (M, Ts', T', m') \\<in> set ms\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D' Ts' T'.\n                            (\\<exists>m' Mm.\n                                P \\<turnstile> x sees_methods Mm \\<and>\n                                Mm M =\n                                \\<lfloor>((Ts', T', m'),\n    D')\\<rfloor>) \\<and>\n                            P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                            P \\<turnstile> T' \\<le> T", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y D Ts T m fs ms Mm Ts' T' m'.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C; x \\<noteq> Object;\n        P \\<turnstile> y sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> x sees_methods Mm ++\n(map_option (\\<lambda>m. (m, x)) \\<circ> map_of ms);\n        map_of ms M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        (M, Ts', T', m') \\<in> set ms; \\<forall>x\\<in>set fs. wf_fdecl P x;\n        distinct_fst fs; \\<forall>xa\\<in>set ms. wf_mdecl wf_md P x xa;\n        distinct_fst ms; is_class P y;\n        \\<not> P \\<turnstile> y \\<preceq>\\<^sup>* x;\n        \\<forall>x\\<in>set ms. wf_overriding P y x;\n        x = Thread \\<longrightarrow>\n        (\\<exists>m. (run, [], Void, m) \\<in> set ms)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D' Ts' T'.\n                            (\\<exists>m' Mm.\n                                P \\<turnstile> x sees_methods Mm \\<and>\n                                Mm M =\n                                \\<lfloor>((Ts', T', m'),\n    D')\\<rfloor>) \\<and>\n                            P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                            P \\<turnstile> T' \\<le> T", "apply(drule (1) bspec)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y D Ts T m fs ms Mm Ts' T' m'.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C; x \\<noteq> Object;\n        P \\<turnstile> y sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> x sees_methods Mm ++\n(map_option (\\<lambda>m. (m, x)) \\<circ> map_of ms);\n        map_of ms M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        (M, Ts', T', m') \\<in> set ms; \\<forall>x\\<in>set fs. wf_fdecl P x;\n        distinct_fst fs; distinct_fst ms; is_class P y;\n        \\<not> P \\<turnstile> y \\<preceq>\\<^sup>* x;\n        x = Thread \\<longrightarrow>\n        (\\<exists>m. (run, [], Void, m) \\<in> set ms);\n        wf_mdecl wf_md P x (M, Ts', T', m');\n        wf_overriding P y (M, Ts', T', m')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D' Ts' T'.\n                            (\\<exists>m' Mm.\n                                P \\<turnstile> x sees_methods Mm \\<and>\n                                Mm M =\n                                \\<lfloor>((Ts', T', m'),\n    D')\\<rfloor>) \\<and>\n                            P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                            P \\<turnstile> T' \\<le> T", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y D Ts T m fs ms Mm Ts' T' m'.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C; x \\<noteq> Object;\n        P \\<turnstile> y sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> x sees_methods Mm ++\n(map_option (\\<lambda>m. (m, x)) \\<circ> map_of ms);\n        map_of ms M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        (M, Ts', T', m') \\<in> set ms; \\<forall>x\\<in>set fs. wf_fdecl P x;\n        distinct_fst fs; distinct_fst ms; is_class P y;\n        \\<not> P \\<turnstile> y \\<preceq>\\<^sup>* x;\n        x = Thread \\<longrightarrow>\n        (\\<exists>m. (run, [], Void, m) \\<in> set ms);\n        wf_mdecl wf_md P x (M, Ts', T', m');\n        \\<forall>D' Ts'a T'a.\n           (\\<exists>m'.\n               P \\<turnstile> y sees M: Ts'a\\<rightarrow>T'a = m' in D') \\<longrightarrow>\n           P \\<turnstile> Ts'a [\\<le>] Ts' \\<and>\n           P \\<turnstile> T' \\<le> T'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D' Ts' T'.\n                            (\\<exists>m' Mm.\n                                P \\<turnstile> x sees_methods Mm \\<and>\n                                Mm M =\n                                \\<lfloor>((Ts', T', m'),\n    D')\\<rfloor>) \\<and>\n                            P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                            P \\<turnstile> T' \\<le> T", "apply(erule_tac x=D in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y D Ts T m fs ms Mm Ts' T' m'.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C; x \\<noteq> Object;\n        P \\<turnstile> y sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> x sees_methods Mm ++\n(map_option (\\<lambda>m. (m, x)) \\<circ> map_of ms);\n        map_of ms M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        (M, Ts', T', m') \\<in> set ms; \\<forall>x\\<in>set fs. wf_fdecl P x;\n        distinct_fst fs; distinct_fst ms; is_class P y;\n        \\<not> P \\<turnstile> y \\<preceq>\\<^sup>* x;\n        x = Thread \\<longrightarrow>\n        (\\<exists>m. (run, [], Void, m) \\<in> set ms);\n        wf_mdecl wf_md P x (M, Ts', T', m');\n        \\<forall>Ts'a T'a.\n           (\\<exists>m'.\n               P \\<turnstile> y sees M: Ts'a\\<rightarrow>T'a = m' in D) \\<longrightarrow>\n           P \\<turnstile> Ts'a [\\<le>] Ts' \\<and>\n           P \\<turnstile> T' \\<le> T'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D' Ts' T'.\n                            (\\<exists>m' Mm.\n                                P \\<turnstile> x sees_methods Mm \\<and>\n                                Mm M =\n                                \\<lfloor>((Ts', T', m'),\n    D')\\<rfloor>) \\<and>\n                            P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                            P \\<turnstile> T' \\<le> T", "apply(erule_tac x=Ts in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y D Ts T m fs ms Mm Ts' T' m'.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C; x \\<noteq> Object;\n        P \\<turnstile> y sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> x sees_methods Mm ++\n(map_option (\\<lambda>m. (m, x)) \\<circ> map_of ms);\n        map_of ms M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        (M, Ts', T', m') \\<in> set ms; \\<forall>x\\<in>set fs. wf_fdecl P x;\n        distinct_fst fs; distinct_fst ms; is_class P y;\n        \\<not> P \\<turnstile> y \\<preceq>\\<^sup>* x;\n        x = Thread \\<longrightarrow>\n        (\\<exists>m. (run, [], Void, m) \\<in> set ms);\n        wf_mdecl wf_md P x (M, Ts', T', m');\n        \\<forall>T'a.\n           (\\<exists>m'.\n               P \\<turnstile> y sees M: Ts\\<rightarrow>T'a = m' in D) \\<longrightarrow>\n           P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n           P \\<turnstile> T' \\<le> T'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D' Ts' T'.\n                            (\\<exists>m' Mm.\n                                P \\<turnstile> x sees_methods Mm \\<and>\n                                Mm M =\n                                \\<lfloor>((Ts', T', m'),\n    D')\\<rfloor>) \\<and>\n                            P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                            P \\<turnstile> T' \\<le> T", "apply(rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y D Ts T m fs ms Mm Ts' T' m'.\n       \\<lbrakk>\\<forall>T'a.\n                   (\\<exists>m'.\n                       P \\<turnstile> y sees M: Ts\\<rightarrow>T'a = m' in D) \\<longrightarrow>\n                   P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                   P \\<turnstile> T' \\<le> T'a;\n        wf_prog wf_md P; C' \\<noteq> C; x \\<noteq> Object;\n        P \\<turnstile> y sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> x sees_methods Mm ++\n(map_option (\\<lambda>m. (m, x)) \\<circ> map_of ms);\n        map_of ms M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        (M, Ts', T', m') \\<in> set ms; \\<forall>x\\<in>set fs. wf_fdecl P x;\n        distinct_fst fs; distinct_fst ms; is_class P y;\n        \\<not> P \\<turnstile> y \\<preceq>\\<^sup>* x;\n        x = Thread \\<longrightarrow>\n        (\\<exists>m. (run, [], Void, m) \\<in> set ms);\n        wf_mdecl wf_md P x (M, Ts', T', m')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D' Ts' T'.\n                            (\\<exists>m' Mm.\n                                P \\<turnstile> x sees_methods Mm \\<and>\n                                Mm M =\n                                \\<lfloor>((Ts', T', m'),\n    D')\\<rfloor>) \\<and>\n                            P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                            P \\<turnstile> T' \\<le> T", "apply(erule_tac x=T in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y D Ts T m fs ms Mm Ts' T' m'.\n       \\<lbrakk>wf_prog wf_md P; C' \\<noteq> C; x \\<noteq> Object;\n        P \\<turnstile> y sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> x sees_methods Mm ++\n(map_option (\\<lambda>m. (m, x)) \\<circ> map_of ms);\n        map_of ms M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        (M, Ts', T', m') \\<in> set ms; \\<forall>x\\<in>set fs. wf_fdecl P x;\n        distinct_fst fs; distinct_fst ms; is_class P y;\n        \\<not> P \\<turnstile> y \\<preceq>\\<^sup>* x;\n        x = Thread \\<longrightarrow>\n        (\\<exists>m. (run, [], Void, m) \\<in> set ms);\n        wf_mdecl wf_md P x (M, Ts', T', m');\n        (\\<exists>m'.\n            P \\<turnstile> y sees M: Ts\\<rightarrow>T = m' in D) \\<longrightarrow>\n        P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D' Ts' T'.\n                            (\\<exists>m' Mm.\n                                P \\<turnstile> x sees_methods Mm \\<and>\n                                Mm M =\n                                \\<lfloor>((Ts', T', m'),\n    D')\\<rfloor>) \\<and>\n                            P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                            P \\<turnstile> T' \\<le> T", "apply(fastforce simp:map_add_def Method_def split:option.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma sees_method_mono2:\n  \"\\<lbrakk> P \\<turnstile> C' \\<preceq>\\<^sup>* C; wf_prog wf_md P;\n     P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in D; P \\<turnstile> C' sees M:Ts'\\<rightarrow>T' = m' in D' \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> Ts [\\<le>] Ts' \\<and> P \\<turnstile> T' \\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C' \\<preceq>\\<^sup>* C; wf_prog wf_md P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D;\n     P \\<turnstile> C' sees M: Ts'\\<rightarrow>T' = m' in D'\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                      P \\<turnstile> T' \\<le> T", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C' \\<preceq>\\<^sup>* C; wf_prog wf_md P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D;\n     P \\<turnstile> C' sees M: Ts'\\<rightarrow>T' = m' in D'\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                      P \\<turnstile> T' \\<le> T", "by(blast dest:sees_method_mono sees_method_fun)"], ["", "(*>*)"], ["", "lemma mdecls_visible:\n  assumes wf: \"wf_prog wf_md P\" and \"class\": \"is_class P C\"\n  shows \"\\<And>D fs ms. class P C = Some(D,fs,ms)\n         \\<Longrightarrow> \\<exists>Mm. P \\<turnstile> C sees_methods Mm \\<and> (\\<forall>(M,Ts,T,m) \\<in> set ms. Mm M = Some((Ts,T,m),C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D fs ms.\n       class P C = \\<lfloor>(D, fs, ms)\\<rfloor> \\<Longrightarrow>\n       \\<exists>Mm.\n          P \\<turnstile> C sees_methods Mm \\<and>\n          (\\<forall>(M, Ts, T, m)\\<in>set ms.\n              Mm M = \\<lfloor>((Ts, T, m), C)\\<rfloor>)", "using wf \"class\""], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  is_class P C\n\ngoal (1 subgoal):\n 1. \\<And>D fs ms.\n       class P C = \\<lfloor>(D, fs, ms)\\<rfloor> \\<Longrightarrow>\n       \\<exists>Mm.\n          P \\<turnstile> C sees_methods Mm \\<and>\n          (\\<forall>(M, Ts, T, m)\\<in>set ms.\n              Mm M = \\<lfloor>((Ts, T, m), C)\\<rfloor>)", "proof (induct rule:subcls1_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>D fs ms.\n       class P Object = \\<lfloor>(D, fs, ms)\\<rfloor> \\<Longrightarrow>\n       \\<exists>Mm.\n          P \\<turnstile> Object sees_methods Mm \\<and>\n          (\\<forall>(M, Ts, T, m)\\<in>set ms.\n              Mm M = \\<lfloor>((Ts, T, m), Object)\\<rfloor>)\n 2. \\<And>C D Da fs ms.\n       \\<lbrakk>C \\<noteq> Object; P \\<turnstile> C \\<prec>\\<^sup>1 D;\n        is_class P D;\n        \\<And>Da fs ms.\n           class P D = \\<lfloor>(Da, fs, ms)\\<rfloor> \\<Longrightarrow>\n           \\<exists>Mm.\n              P \\<turnstile> D sees_methods Mm \\<and>\n              (\\<forall>(M, Ts, T, m)\\<in>set ms.\n                  Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>);\n        class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm.\n                            P \\<turnstile> C sees_methods Mm \\<and>\n                            (\\<forall>(M, Ts, T, m)\\<in>set ms.\n                                Mm M = \\<lfloor>((Ts, T, m), C)\\<rfloor>)", "case Object"], ["proof (state)\nthis:\n  class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>D fs ms.\n       class P Object = \\<lfloor>(D, fs, ms)\\<rfloor> \\<Longrightarrow>\n       \\<exists>Mm.\n          P \\<turnstile> Object sees_methods Mm \\<and>\n          (\\<forall>(M, Ts, T, m)\\<in>set ms.\n              Mm M = \\<lfloor>((Ts, T, m), Object)\\<rfloor>)\n 2. \\<And>C D Da fs ms.\n       \\<lbrakk>C \\<noteq> Object; P \\<turnstile> C \\<prec>\\<^sup>1 D;\n        is_class P D;\n        \\<And>Da fs ms.\n           class P D = \\<lfloor>(Da, fs, ms)\\<rfloor> \\<Longrightarrow>\n           \\<exists>Mm.\n              P \\<turnstile> D sees_methods Mm \\<and>\n              (\\<forall>(M, Ts, T, m)\\<in>set ms.\n                  Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>);\n        class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm.\n                            P \\<turnstile> C sees_methods Mm \\<and>\n                            (\\<forall>(M, Ts, T, m)\\<in>set ms.\n                                Mm M = \\<lfloor>((Ts, T, m), C)\\<rfloor>)", "with wf"], ["proof (chain)\npicking this:\n  wf_prog wf_md P\n  class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>", "have \"distinct_fst ms\""], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. distinct_fst ms", "by(auto dest: class_wf simp add: wf_cdecl_def)"], ["proof (state)\nthis:\n  distinct_fst ms\n\ngoal (2 subgoals):\n 1. \\<And>D fs ms.\n       class P Object = \\<lfloor>(D, fs, ms)\\<rfloor> \\<Longrightarrow>\n       \\<exists>Mm.\n          P \\<turnstile> Object sees_methods Mm \\<and>\n          (\\<forall>(M, Ts, T, m)\\<in>set ms.\n              Mm M = \\<lfloor>((Ts, T, m), Object)\\<rfloor>)\n 2. \\<And>C D Da fs ms.\n       \\<lbrakk>C \\<noteq> Object; P \\<turnstile> C \\<prec>\\<^sup>1 D;\n        is_class P D;\n        \\<And>Da fs ms.\n           class P D = \\<lfloor>(Da, fs, ms)\\<rfloor> \\<Longrightarrow>\n           \\<exists>Mm.\n              P \\<turnstile> D sees_methods Mm \\<and>\n              (\\<forall>(M, Ts, T, m)\\<in>set ms.\n                  Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>);\n        class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm.\n                            P \\<turnstile> C sees_methods Mm \\<and>\n                            (\\<forall>(M, Ts, T, m)\\<in>set ms.\n                                Mm M = \\<lfloor>((Ts, T, m), C)\\<rfloor>)", "with Object"], ["proof (chain)\npicking this:\n  class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  distinct_fst ms", "show ?case"], ["proof (prove)\nusing this:\n  class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  distinct_fst ms\n\ngoal (1 subgoal):\n 1. \\<exists>Mm.\n       P \\<turnstile> Object sees_methods Mm \\<and>\n       (\\<forall>a\\<in>set ms.\n           case a of\n           (M, Ts, T, m) \\<Rightarrow>\n             Mm M = \\<lfloor>((Ts, T, m), Object)\\<rfloor>)", "by(fastforce intro!: sees_methods_Object map_of_SomeI)"], ["proof (state)\nthis:\n  \\<exists>Mm.\n     P \\<turnstile> Object sees_methods Mm \\<and>\n     (\\<forall>a\\<in>set ms.\n         case a of\n         (M, Ts, T, m) \\<Rightarrow>\n           Mm M = \\<lfloor>((Ts, T, m), Object)\\<rfloor>)\n\ngoal (1 subgoal):\n 1. \\<And>C D Da fs ms.\n       \\<lbrakk>C \\<noteq> Object; P \\<turnstile> C \\<prec>\\<^sup>1 D;\n        is_class P D;\n        \\<And>Da fs ms.\n           class P D = \\<lfloor>(Da, fs, ms)\\<rfloor> \\<Longrightarrow>\n           \\<exists>Mm.\n              P \\<turnstile> D sees_methods Mm \\<and>\n              (\\<forall>(M, Ts, T, m)\\<in>set ms.\n                  Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>);\n        class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm.\n                            P \\<turnstile> C sees_methods Mm \\<and>\n                            (\\<forall>(M, Ts, T, m)\\<in>set ms.\n                                Mm M = \\<lfloor>((Ts, T, m), C)\\<rfloor>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C D Da fs ms.\n       \\<lbrakk>C \\<noteq> Object; P \\<turnstile> C \\<prec>\\<^sup>1 D;\n        is_class P D;\n        \\<And>Da fs ms.\n           class P D = \\<lfloor>(Da, fs, ms)\\<rfloor> \\<Longrightarrow>\n           \\<exists>Mm.\n              P \\<turnstile> D sees_methods Mm \\<and>\n              (\\<forall>(M, Ts, T, m)\\<in>set ms.\n                  Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>);\n        class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm.\n                            P \\<turnstile> C sees_methods Mm \\<and>\n                            (\\<forall>(M, Ts, T, m)\\<in>set ms.\n                                Mm M = \\<lfloor>((Ts, T, m), C)\\<rfloor>)", "case Subcls"], ["proof (state)\nthis:\n  C_ \\<noteq> Object\n  P \\<turnstile> C_ \\<prec>\\<^sup>1 D_\n  is_class P D_\n  class P D_ = \\<lfloor>(?D, ?fs, ?ms)\\<rfloor> \\<Longrightarrow>\n  \\<exists>Mm.\n     P \\<turnstile> D_ sees_methods Mm \\<and>\n     (\\<forall>a\\<in>set ?ms.\n         case a of\n         (M, Ts, T, m) \\<Rightarrow>\n           Mm M = \\<lfloor>((Ts, T, m), D_)\\<rfloor>)\n  class P C_ = \\<lfloor>(D, fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>C D Da fs ms.\n       \\<lbrakk>C \\<noteq> Object; P \\<turnstile> C \\<prec>\\<^sup>1 D;\n        is_class P D;\n        \\<And>Da fs ms.\n           class P D = \\<lfloor>(Da, fs, ms)\\<rfloor> \\<Longrightarrow>\n           \\<exists>Mm.\n              P \\<turnstile> D sees_methods Mm \\<and>\n              (\\<forall>(M, Ts, T, m)\\<in>set ms.\n                  Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>);\n        class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm.\n                            P \\<turnstile> C sees_methods Mm \\<and>\n                            (\\<forall>(M, Ts, T, m)\\<in>set ms.\n                                Mm M = \\<lfloor>((Ts, T, m), C)\\<rfloor>)", "with wf"], ["proof (chain)\npicking this:\n  wf_prog wf_md P\n  C_ \\<noteq> Object\n  P \\<turnstile> C_ \\<prec>\\<^sup>1 D_\n  is_class P D_\n  class P D_ = \\<lfloor>(?D, ?fs, ?ms)\\<rfloor> \\<Longrightarrow>\n  \\<exists>Mm.\n     P \\<turnstile> D_ sees_methods Mm \\<and>\n     (\\<forall>a\\<in>set ?ms.\n         case a of\n         (M, Ts, T, m) \\<Rightarrow>\n           Mm M = \\<lfloor>((Ts, T, m), D_)\\<rfloor>)\n  class P C_ = \\<lfloor>(D, fs, ms)\\<rfloor>", "have \"distinct_fst ms\""], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  C_ \\<noteq> Object\n  P \\<turnstile> C_ \\<prec>\\<^sup>1 D_\n  is_class P D_\n  class P D_ = \\<lfloor>(?D, ?fs, ?ms)\\<rfloor> \\<Longrightarrow>\n  \\<exists>Mm.\n     P \\<turnstile> D_ sees_methods Mm \\<and>\n     (\\<forall>a\\<in>set ?ms.\n         case a of\n         (M, Ts, T, m) \\<Rightarrow>\n           Mm M = \\<lfloor>((Ts, T, m), D_)\\<rfloor>)\n  class P C_ = \\<lfloor>(D, fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. distinct_fst ms", "by(auto dest: class_wf simp add: wf_cdecl_def)"], ["proof (state)\nthis:\n  distinct_fst ms\n\ngoal (1 subgoal):\n 1. \\<And>C D Da fs ms.\n       \\<lbrakk>C \\<noteq> Object; P \\<turnstile> C \\<prec>\\<^sup>1 D;\n        is_class P D;\n        \\<And>Da fs ms.\n           class P D = \\<lfloor>(Da, fs, ms)\\<rfloor> \\<Longrightarrow>\n           \\<exists>Mm.\n              P \\<turnstile> D sees_methods Mm \\<and>\n              (\\<forall>(M, Ts, T, m)\\<in>set ms.\n                  Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>);\n        class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm.\n                            P \\<turnstile> C sees_methods Mm \\<and>\n                            (\\<forall>(M, Ts, T, m)\\<in>set ms.\n                                Mm M = \\<lfloor>((Ts, T, m), C)\\<rfloor>)", "with Subcls"], ["proof (chain)\npicking this:\n  C_ \\<noteq> Object\n  P \\<turnstile> C_ \\<prec>\\<^sup>1 D_\n  is_class P D_\n  class P D_ = \\<lfloor>(?D, ?fs, ?ms)\\<rfloor> \\<Longrightarrow>\n  \\<exists>Mm.\n     P \\<turnstile> D_ sees_methods Mm \\<and>\n     (\\<forall>a\\<in>set ?ms.\n         case a of\n         (M, Ts, T, m) \\<Rightarrow>\n           Mm M = \\<lfloor>((Ts, T, m), D_)\\<rfloor>)\n  class P C_ = \\<lfloor>(D, fs, ms)\\<rfloor>\n  distinct_fst ms", "show ?case"], ["proof (prove)\nusing this:\n  C_ \\<noteq> Object\n  P \\<turnstile> C_ \\<prec>\\<^sup>1 D_\n  is_class P D_\n  class P D_ = \\<lfloor>(?D, ?fs, ?ms)\\<rfloor> \\<Longrightarrow>\n  \\<exists>Mm.\n     P \\<turnstile> D_ sees_methods Mm \\<and>\n     (\\<forall>a\\<in>set ?ms.\n         case a of\n         (M, Ts, T, m) \\<Rightarrow>\n           Mm M = \\<lfloor>((Ts, T, m), D_)\\<rfloor>)\n  class P C_ = \\<lfloor>(D, fs, ms)\\<rfloor>\n  distinct_fst ms\n\ngoal (1 subgoal):\n 1. \\<exists>Mm.\n       P \\<turnstile> C_ sees_methods Mm \\<and>\n       (\\<forall>a\\<in>set ms.\n           case a of\n           (M, Ts, T, m) \\<Rightarrow>\n             Mm M = \\<lfloor>((Ts, T, m), C_)\\<rfloor>)", "by(fastforce elim:sees_methods_rec dest:subcls1D map_of_SomeI\n                simp:is_class_def)"], ["proof (state)\nthis:\n  \\<exists>Mm.\n     P \\<turnstile> C_ sees_methods Mm \\<and>\n     (\\<forall>a\\<in>set ms.\n         case a of\n         (M, Ts, T, m) \\<Rightarrow>\n           Mm M = \\<lfloor>((Ts, T, m), C_)\\<rfloor>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mdecl_visible:\n  assumes wf: \"wf_prog wf_md P\" and C: \"class P C = \\<lfloor>(S,fs,ms)\\<rfloor>\" and  m: \"(M,Ts,T,m) \\<in> set ms\"\n  shows \"P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in C", "from C"], ["proof (chain)\npicking this:\n  class P C = \\<lfloor>(S, fs, ms)\\<rfloor>", "have \"is_class P C\""], ["proof (prove)\nusing this:\n  class P C = \\<lfloor>(S, fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. is_class P C", "by(auto simp:is_class_def)"], ["proof (state)\nthis:\n  is_class P C\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in C", "with assms"], ["proof (chain)\npicking this:\n  wf_prog wf_md P\n  class P C = \\<lfloor>(S, fs, ms)\\<rfloor>\n  (M, Ts, T, m) \\<in> set ms\n  is_class P C", "show ?thesis"], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  class P C = \\<lfloor>(S, fs, ms)\\<rfloor>\n  (M, Ts, T, m) \\<in> set ms\n  is_class P C\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in C", "by(bestsimp simp:Method_def dest:mdecls_visible)"], ["proof (state)\nthis:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sees_wf_native:\n  \"\\<lbrakk> wf_prog wf_md P; P \\<turnstile> C sees M:Ts\\<rightarrow>T=Native in D \\<rbrakk> \\<Longrightarrow> D\\<bullet>M(Ts) :: T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = Native in D\\<rbrakk>\n    \\<Longrightarrow> D\\<bullet>M(Ts) :: T", "apply(drule (1) sees_wf_mdecl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C sees M: Ts\\<rightarrow>T = Native in D;\n     wf_mdecl wf_md P D (M, Ts, T, None)\\<rbrakk>\n    \\<Longrightarrow> D\\<bullet>M(Ts) :: T", "apply(simp add: wf_mdecl_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Call_lemma:\n  \"\\<lbrakk> P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in D; P \\<turnstile> C' \\<preceq>\\<^sup>* C; wf_prog wf_md P \\<rbrakk>\n  \\<Longrightarrow> \\<exists>D' Ts' T' m'.\n       P \\<turnstile> C' sees M:Ts'\\<rightarrow>T' = m' in D' \\<and> P \\<turnstile> Ts [\\<le>] Ts' \\<and> P \\<turnstile> T' \\<le> T \\<and> P \\<turnstile> C' \\<preceq>\\<^sup>* D'\n       \\<and> is_type P T' \\<and> (\\<forall>T\\<in>set Ts'. is_type P T) \\<and> (m' \\<noteq> Native \\<longrightarrow> wf_md P D' (M,Ts',T',the m'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D;\n     P \\<turnstile> C' \\<preceq>\\<^sup>* C; wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> \\<exists>D' Ts' T' m'.\n                         P \\<turnstile> C' sees M: Ts'\\<rightarrow>T' = m' in D' \\<and>\n                         P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                         P \\<turnstile> T' \\<le> T \\<and>\n                         P \\<turnstile> C' \\<preceq>\\<^sup>* D' \\<and>\n                         is_type P T' \\<and>\n                         (\\<forall>T\\<in>set Ts'. is_type P T) \\<and>\n                         (m' \\<noteq> None \\<longrightarrow>\n                          wf_md P D' (M, Ts', T', the m'))", "apply(frule (2) sees_method_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D;\n     P \\<turnstile> C' \\<preceq>\\<^sup>* C; wf_prog wf_md P;\n     \\<exists>D' Ts' T' m'.\n        P \\<turnstile> C' sees M: Ts'\\<rightarrow>T' = m' in D' \\<and>\n        P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n    \\<Longrightarrow> \\<exists>D' Ts' T' m'.\n                         P \\<turnstile> C' sees M: Ts'\\<rightarrow>T' = m' in D' \\<and>\n                         P \\<turnstile> Ts [\\<le>] Ts' \\<and>\n                         P \\<turnstile> T' \\<le> T \\<and>\n                         P \\<turnstile> C' \\<preceq>\\<^sup>* D' \\<and>\n                         is_type P T' \\<and>\n                         (\\<forall>T\\<in>set Ts'. is_type P T) \\<and>\n                         (m' \\<noteq> None \\<longrightarrow>\n                          wf_md P D' (M, Ts', T', the m'))", "apply(fastforce intro:sees_method_decl_above dest:sees_wf_mdecl\n               simp: wf_mdecl_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sub_Thread_sees_run:\n  assumes wf: \"wf_prog wf_md P\"\n  and PCThread: \"P \\<turnstile> C \\<preceq>\\<^sup>* Thread\"\n  shows \"\\<exists>D mthd. P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>mthd\\<rfloor> in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>D mthd.\n       P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>mthd\\<rfloor> in D", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>D mthd.\n       P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>mthd\\<rfloor> in D", "from class_Thread[OF wf]"], ["proof (chain)\npicking this:\n  \\<exists>C fs ms. class P Thread = \\<lfloor>(C, fs, ms)\\<rfloor>", "obtain T' fsT MsT\n    where classT: \"class P Thread = \\<lfloor>(T', fsT, MsT)\\<rfloor>\""], ["proof (prove)\nusing this:\n  \\<exists>C fs ms. class P Thread = \\<lfloor>(C, fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>T' fsT MsT.\n        class P Thread = \\<lfloor>(T', fsT, MsT)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  class P Thread = \\<lfloor>(T', fsT, MsT)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>D mthd.\n       P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>mthd\\<rfloor> in D", "hence wfcThread: \"wf_cdecl wf_md P (Thread, T', fsT, MsT)\""], ["proof (prove)\nusing this:\n  class P Thread = \\<lfloor>(T', fsT, MsT)\\<rfloor>\n\ngoal (1 subgoal):\n 1. wf_cdecl wf_md P (Thread, T', fsT, MsT)", "using wf"], ["proof (prove)\nusing this:\n  class P Thread = \\<lfloor>(T', fsT, MsT)\\<rfloor>\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. wf_cdecl wf_md P (Thread, T', fsT, MsT)", "by(rule class_wf)"], ["proof (state)\nthis:\n  wf_cdecl wf_md P (Thread, T', fsT, MsT)\n\ngoal (1 subgoal):\n 1. \\<exists>D mthd.\n       P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>mthd\\<rfloor> in D", "then"], ["proof (chain)\npicking this:\n  wf_cdecl wf_md P (Thread, T', fsT, MsT)", "obtain mrunT where runThread: \"(run, [], Void, mrunT) \\<in> set MsT\""], ["proof (prove)\nusing this:\n  wf_cdecl wf_md P (Thread, T', fsT, MsT)\n\ngoal (1 subgoal):\n 1. (\\<And>mrunT.\n        (run, [], Void, mrunT) \\<in> set MsT \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: wf_cdecl_def)"], ["proof (state)\nthis:\n  (run, [], Void, mrunT) \\<in> set MsT\n\ngoal (1 subgoal):\n 1. \\<exists>D mthd.\n       P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>mthd\\<rfloor> in D", "moreover"], ["proof (state)\nthis:\n  (run, [], Void, mrunT) \\<in> set MsT\n\ngoal (1 subgoal):\n 1. \\<exists>D mthd.\n       P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>mthd\\<rfloor> in D", "have \"\\<exists>MmT. P \\<turnstile> Thread sees_methods MmT \\<and>\n                       (\\<forall>(M,Ts,T,m) \\<in> set MsT. MmT M = Some((Ts,T,m),Thread))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>MmT.\n       P \\<turnstile> Thread sees_methods MmT \\<and>\n       (\\<forall>(M, Ts, T, m)\\<in>set MsT.\n           MmT M = \\<lfloor>((Ts, T, m), Thread)\\<rfloor>)", "by(rule mdecls_visible[OF wf is_class_Thread[OF wf] classT])"], ["proof (state)\nthis:\n  \\<exists>MmT.\n     P \\<turnstile> Thread sees_methods MmT \\<and>\n     (\\<forall>(M, Ts, T, m)\\<in>set MsT.\n         MmT M = \\<lfloor>((Ts, T, m), Thread)\\<rfloor>)\n\ngoal (1 subgoal):\n 1. \\<exists>D mthd.\n       P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>mthd\\<rfloor> in D", "then"], ["proof (chain)\npicking this:\n  \\<exists>MmT.\n     P \\<turnstile> Thread sees_methods MmT \\<and>\n     (\\<forall>(M, Ts, T, m)\\<in>set MsT.\n         MmT M = \\<lfloor>((Ts, T, m), Thread)\\<rfloor>)", "obtain MmT where ThreadMmT: \"P \\<turnstile> Thread sees_methods MmT\"\n    and MmT: \"\\<forall>(M,Ts,T,m) \\<in> set MsT. MmT M = Some((Ts,T,m),Thread)\""], ["proof (prove)\nusing this:\n  \\<exists>MmT.\n     P \\<turnstile> Thread sees_methods MmT \\<and>\n     (\\<forall>(M, Ts, T, m)\\<in>set MsT.\n         MmT M = \\<lfloor>((Ts, T, m), Thread)\\<rfloor>)\n\ngoal (1 subgoal):\n 1. (\\<And>MmT.\n        \\<lbrakk>P \\<turnstile> Thread sees_methods MmT;\n         \\<forall>(M, Ts, T, m)\\<in>set MsT.\n            MmT M = \\<lfloor>((Ts, T, m), Thread)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  P \\<turnstile> Thread sees_methods MmT\n  \\<forall>(M, Ts, T, m)\\<in>set MsT.\n     MmT M = \\<lfloor>((Ts, T, m), Thread)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>D mthd.\n       P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>mthd\\<rfloor> in D", "ultimately"], ["proof (chain)\npicking this:\n  (run, [], Void, mrunT) \\<in> set MsT\n  P \\<turnstile> Thread sees_methods MmT\n  \\<forall>(M, Ts, T, m)\\<in>set MsT.\n     MmT M = \\<lfloor>((Ts, T, m), Thread)\\<rfloor>", "obtain mthd\n    where \"MmT run = \\<lfloor>(([], Void, mthd), Thread)\\<rfloor>\""], ["proof (prove)\nusing this:\n  (run, [], Void, mrunT) \\<in> set MsT\n  P \\<turnstile> Thread sees_methods MmT\n  \\<forall>(M, Ts, T, m)\\<in>set MsT.\n     MmT M = \\<lfloor>((Ts, T, m), Thread)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>mthd.\n        MmT run =\n        \\<lfloor>(([], Void, mthd), Thread)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce)"], ["proof (state)\nthis:\n  MmT run = \\<lfloor>(([], Void, mthd), Thread)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>D mthd.\n       P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>mthd\\<rfloor> in D", "with ThreadMmT"], ["proof (chain)\npicking this:\n  P \\<turnstile> Thread sees_methods MmT\n  MmT run = \\<lfloor>(([], Void, mthd), Thread)\\<rfloor>", "have Tseesrun: \"P \\<turnstile> Thread sees run: []\\<rightarrow>Void = mthd in Thread\""], ["proof (prove)\nusing this:\n  P \\<turnstile> Thread sees_methods MmT\n  MmT run = \\<lfloor>(([], Void, mthd), Thread)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Thread sees run: []\\<rightarrow>Void = mthd in Thread", "by(auto simp add: Method_def)"], ["proof (state)\nthis:\n  P \\<turnstile> Thread sees run: []\\<rightarrow>Void = mthd in Thread\n\ngoal (1 subgoal):\n 1. \\<exists>D mthd.\n       P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>mthd\\<rfloor> in D", "from sees_method_mono[OF PCThread wf Tseesrun]"], ["proof (chain)\npicking this:\n  \\<exists>D' Ts' T' m'.\n     P \\<turnstile> C sees run: Ts'\\<rightarrow>T' = m' in D' \\<and>\n     P \\<turnstile> [] [\\<le>] Ts' \\<and> P \\<turnstile> T' \\<le> Void", "obtain D' m' where \"P \\<turnstile> C sees run: []\\<rightarrow>Void = m' in D'\""], ["proof (prove)\nusing this:\n  \\<exists>D' Ts' T' m'.\n     P \\<turnstile> C sees run: Ts'\\<rightarrow>T' = m' in D' \\<and>\n     P \\<turnstile> [] [\\<le>] Ts' \\<and> P \\<turnstile> T' \\<le> Void\n\ngoal (1 subgoal):\n 1. (\\<And>m' D'.\n        P \\<turnstile> C sees run: []\\<rightarrow>Void = m' in D' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P \\<turnstile> C sees run: []\\<rightarrow>Void = m' in D'\n\ngoal (1 subgoal):\n 1. \\<exists>D mthd.\n       P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>mthd\\<rfloor> in D", "moreover"], ["proof (state)\nthis:\n  P \\<turnstile> C sees run: []\\<rightarrow>Void = m' in D'\n\ngoal (1 subgoal):\n 1. \\<exists>D mthd.\n       P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>mthd\\<rfloor> in D", "have \"m' \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<noteq> None", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. m' = None \\<Longrightarrow> False", "assume \"m' = None\""], ["proof (state)\nthis:\n  m' = None\n\ngoal (1 subgoal):\n 1. m' = None \\<Longrightarrow> False", "with wf \\<open>P \\<turnstile> C sees run: []\\<rightarrow>Void = m' in D'\\<close>"], ["proof (chain)\npicking this:\n  wf_prog wf_md P\n  P \\<turnstile> C sees run: []\\<rightarrow>Void = m' in D'\n  m' = None", "have \"D'\\<bullet>run([]) :: Void\""], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  P \\<turnstile> C sees run: []\\<rightarrow>Void = m' in D'\n  m' = None\n\ngoal (1 subgoal):\n 1. D'\\<bullet>run([]) :: Void", "by(auto intro: sees_wf_native)"], ["proof (state)\nthis:\n  D'\\<bullet>run([]) :: Void\n\ngoal (1 subgoal):\n 1. m' = None \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  D'\\<bullet>run([]) :: Void\n\ngoal (1 subgoal):\n 1. False", "by cases auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m' \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<exists>D mthd.\n       P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>mthd\\<rfloor> in D", "ultimately"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees run: []\\<rightarrow>Void = m' in D'\n  m' \\<noteq> None", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees run: []\\<rightarrow>Void = m' in D'\n  m' \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<exists>D mthd.\n       P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>mthd\\<rfloor> in D", "by auto"], ["proof (state)\nthis:\n  \\<exists>D mthd.\n     P \\<turnstile> C sees run: []\\<rightarrow>Void = \\<lfloor>mthd\\<rfloor> in D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_prog_lift:\n  assumes wf: \"wf_prog (\\<lambda>P C bd. A P C bd) P\"\n  and rule:\n  \"\\<And>wf_md C M Ts C T m.\n   \\<lbrakk> wf_prog wf_md P; P \\<turnstile> C sees M:Ts\\<rightarrow>T = \\<lfloor>m\\<rfloor> in C; is_class P C; set Ts \\<subseteq> types P; A P C (M,Ts,T,m) \\<rbrakk>\n   \\<Longrightarrow> B P C (M,Ts,T,m)\"\n  shows \"wf_prog (\\<lambda>P C bd. B P C bd) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog B P", "proof(cases P)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. P = Program x \\<Longrightarrow> wf_prog B P", "case (Program P')"], ["proof (state)\nthis:\n  P = Program P'\n\ngoal (1 subgoal):\n 1. \\<And>x. P = Program x \\<Longrightarrow> wf_prog B P", "thus ?thesis"], ["proof (prove)\nusing this:\n  P = Program P'\n\ngoal (1 subgoal):\n 1. wf_prog B P", "using wf"], ["proof (prove)\nusing this:\n  P = Program P'\n  wf_prog A P\n\ngoal (1 subgoal):\n 1. wf_prog B P", "apply(clarsimp simp add: wf_prog_def wf_cdecl_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab b.\n       \\<lbrakk>P = Program P'; (a, aa, ab, b) \\<in> set P';\n        wf_syscls (Program P'); distinct_fst P';\n        \\<forall>x\\<in>set P'.\n           case x of\n           (C, D, fs, ms) \\<Rightarrow>\n             (\\<forall>x\\<in>set fs. wf_fdecl (Program P') x) \\<and>\n             distinct_fst fs \\<and>\n             (\\<forall>x\\<in>set ms. wf_mdecl A (Program P') C x) \\<and>\n             distinct_fst ms \\<and>\n             (C \\<noteq> Object \\<longrightarrow>\n              is_class (Program P') D \\<and>\n              \\<not> Program P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n              (\\<forall>x\\<in>set ms.\n                  wf_overriding (Program P') D x)) \\<and>\n             (C = Thread \\<longrightarrow>\n              (\\<exists>m. (run, [], Void, m) \\<in> set ms))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>set ab.\n                             wf_fdecl (Program P') x) \\<and>\n                         distinct_fst ab \\<and>\n                         (\\<forall>x\\<in>set b.\n                             wf_mdecl B (Program P') a x) \\<and>\n                         distinct_fst b \\<and>\n                         (a \\<noteq> Object \\<longrightarrow>\n                          is_class (Program P') aa \\<and>\n                          \\<not> Program\n                                  P' \\<turnstile> aa \\<preceq>\\<^sup>* a \\<and>\n                          (\\<forall>x\\<in>set b.\n                              wf_overriding (Program P') aa x)) \\<and>\n                         (a = Thread \\<longrightarrow>\n                          (\\<exists>m. (run, [], Void, m) \\<in> set b))", "apply(drule (1) bspec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab b.\n       \\<lbrakk>P = Program P'; (a, aa, ab, b) \\<in> set P';\n        wf_syscls (Program P'); distinct_fst P';\n        case (a, aa, ab, b) of\n        (C, D, fs, ms) \\<Rightarrow>\n          (\\<forall>x\\<in>set fs. wf_fdecl (Program P') x) \\<and>\n          distinct_fst fs \\<and>\n          (\\<forall>x\\<in>set ms. wf_mdecl A (Program P') C x) \\<and>\n          distinct_fst ms \\<and>\n          (C \\<noteq> Object \\<longrightarrow>\n           is_class (Program P') D \\<and>\n           \\<not> Program P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n           (\\<forall>x\\<in>set ms. wf_overriding (Program P') D x)) \\<and>\n          (C = Thread \\<longrightarrow>\n           (\\<exists>m. (run, [], Void, m) \\<in> set ms))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>set ab.\n                             wf_fdecl (Program P') x) \\<and>\n                         distinct_fst ab \\<and>\n                         (\\<forall>x\\<in>set b.\n                             wf_mdecl B (Program P') a x) \\<and>\n                         distinct_fst b \\<and>\n                         (a \\<noteq> Object \\<longrightarrow>\n                          is_class (Program P') aa \\<and>\n                          \\<not> Program\n                                  P' \\<turnstile> aa \\<preceq>\\<^sup>* a \\<and>\n                          (\\<forall>x\\<in>set b.\n                              wf_overriding (Program P') aa x)) \\<and>\n                         (a = Thread \\<longrightarrow>\n                          (\\<exists>m. (run, [], Void, m) \\<in> set b))", "apply(rename_tac C D fs ms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms.\n       \\<lbrakk>P = Program P'; (C, D, fs, ms) \\<in> set P';\n        wf_syscls (Program P'); distinct_fst P';\n        case (C, D, fs, ms) of\n        (C, D, fs, ms) \\<Rightarrow>\n          (\\<forall>x\\<in>set fs. wf_fdecl (Program P') x) \\<and>\n          distinct_fst fs \\<and>\n          (\\<forall>x\\<in>set ms. wf_mdecl A (Program P') C x) \\<and>\n          distinct_fst ms \\<and>\n          (C \\<noteq> Object \\<longrightarrow>\n           is_class (Program P') D \\<and>\n           \\<not> Program P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n           (\\<forall>x\\<in>set ms. wf_overriding (Program P') D x)) \\<and>\n          (C = Thread \\<longrightarrow>\n           (\\<exists>m. (run, [], Void, m) \\<in> set ms))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>set fs.\n                             wf_fdecl (Program P') x) \\<and>\n                         distinct_fst fs \\<and>\n                         (\\<forall>x\\<in>set ms.\n                             wf_mdecl B (Program P') C x) \\<and>\n                         distinct_fst ms \\<and>\n                         (C \\<noteq> Object \\<longrightarrow>\n                          is_class (Program P') D \\<and>\n                          \\<not> Program\n                                  P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n                          (\\<forall>x\\<in>set ms.\n                              wf_overriding (Program P') D x)) \\<and>\n                         (C = Thread \\<longrightarrow>\n                          (\\<exists>m. (run, [], Void, m) \\<in> set ms))", "apply(subgoal_tac \"is_class P C\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C D fs ms.\n       \\<lbrakk>P = Program P'; (C, D, fs, ms) \\<in> set P';\n        wf_syscls (Program P'); distinct_fst P';\n        case (C, D, fs, ms) of\n        (C, D, fs, ms) \\<Rightarrow>\n          (\\<forall>x\\<in>set fs. wf_fdecl (Program P') x) \\<and>\n          distinct_fst fs \\<and>\n          (\\<forall>x\\<in>set ms. wf_mdecl A (Program P') C x) \\<and>\n          distinct_fst ms \\<and>\n          (C \\<noteq> Object \\<longrightarrow>\n           is_class (Program P') D \\<and>\n           \\<not> Program P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n           (\\<forall>x\\<in>set ms. wf_overriding (Program P') D x)) \\<and>\n          (C = Thread \\<longrightarrow>\n           (\\<exists>m. (run, [], Void, m) \\<in> set ms));\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>set fs.\n                             wf_fdecl (Program P') x) \\<and>\n                         distinct_fst fs \\<and>\n                         (\\<forall>x\\<in>set ms.\n                             wf_mdecl B (Program P') C x) \\<and>\n                         distinct_fst ms \\<and>\n                         (C \\<noteq> Object \\<longrightarrow>\n                          is_class (Program P') D \\<and>\n                          \\<not> Program\n                                  P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n                          (\\<forall>x\\<in>set ms.\n                              wf_overriding (Program P') D x)) \\<and>\n                         (C = Thread \\<longrightarrow>\n                          (\\<exists>m. (run, [], Void, m) \\<in> set ms))\n 2. \\<And>C D fs ms.\n       \\<lbrakk>P = Program P'; (C, D, fs, ms) \\<in> set P';\n        wf_syscls (Program P'); distinct_fst P';\n        case (C, D, fs, ms) of\n        (C, D, fs, ms) \\<Rightarrow>\n          (\\<forall>x\\<in>set fs. wf_fdecl (Program P') x) \\<and>\n          distinct_fst fs \\<and>\n          (\\<forall>x\\<in>set ms. wf_mdecl A (Program P') C x) \\<and>\n          distinct_fst ms \\<and>\n          (C \\<noteq> Object \\<longrightarrow>\n           is_class (Program P') D \\<and>\n           \\<not> Program P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n           (\\<forall>x\\<in>set ms. wf_overriding (Program P') D x)) \\<and>\n          (C = Thread \\<longrightarrow>\n           (\\<exists>m. (run, [], Void, m) \\<in> set ms))\\<rbrakk>\n       \\<Longrightarrow> is_class P C", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C D fs ms.\n       \\<lbrakk>P = Program P'; (C, D, fs, ms) \\<in> set P';\n        wf_syscls (Program P'); distinct_fst P';\n        case (C, D, fs, ms) of\n        (C, D, fs, ms) \\<Rightarrow>\n          (\\<forall>x\\<in>set fs. wf_fdecl (Program P') x) \\<and>\n          distinct_fst fs \\<and>\n          (\\<forall>x\\<in>set ms. wf_mdecl A (Program P') C x) \\<and>\n          distinct_fst ms \\<and>\n          (C \\<noteq> Object \\<longrightarrow>\n           is_class (Program P') D \\<and>\n           \\<not> Program P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n           (\\<forall>x\\<in>set ms. wf_overriding (Program P') D x)) \\<and>\n          (C = Thread \\<longrightarrow>\n           (\\<exists>m. (run, [], Void, m) \\<in> set ms))\\<rbrakk>\n       \\<Longrightarrow> is_class P C\n 2. \\<And>C D fs ms.\n       \\<lbrakk>P = Program P'; (C, D, fs, ms) \\<in> set P';\n        wf_syscls (Program P'); distinct_fst P';\n        case (C, D, fs, ms) of\n        (C, D, fs, ms) \\<Rightarrow>\n          (\\<forall>x\\<in>set fs. wf_fdecl (Program P') x) \\<and>\n          distinct_fst fs \\<and>\n          (\\<forall>x\\<in>set ms. wf_mdecl A (Program P') C x) \\<and>\n          distinct_fst ms \\<and>\n          (C \\<noteq> Object \\<longrightarrow>\n           is_class (Program P') D \\<and>\n           \\<not> Program P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n           (\\<forall>x\\<in>set ms. wf_overriding (Program P') D x)) \\<and>\n          (C = Thread \\<longrightarrow>\n           (\\<exists>m. (run, [], Void, m) \\<in> set ms));\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>set fs.\n                             wf_fdecl (Program P') x) \\<and>\n                         distinct_fst fs \\<and>\n                         (\\<forall>x\\<in>set ms.\n                             wf_mdecl B (Program P') C x) \\<and>\n                         distinct_fst ms \\<and>\n                         (C \\<noteq> Object \\<longrightarrow>\n                          is_class (Program P') D \\<and>\n                          \\<not> Program\n                                  P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n                          (\\<forall>x\\<in>set ms.\n                              wf_overriding (Program P') D x)) \\<and>\n                         (C = Thread \\<longrightarrow>\n                          (\\<exists>m. (run, [], Void, m) \\<in> set ms))", "apply(simp add: is_class_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C D fs ms.\n       \\<lbrakk>P = Program P'; (C, D, fs, ms) \\<in> set P';\n        wf_syscls (Program P'); distinct_fst P';\n        (\\<forall>x\\<in>set fs. wf_fdecl (Program P') x) \\<and>\n        distinct_fst fs \\<and>\n        (\\<forall>x\\<in>set ms. wf_mdecl A (Program P') C x) \\<and>\n        distinct_fst ms \\<and>\n        (C \\<noteq> Object \\<longrightarrow>\n         (\\<exists>a aa b.\n             map_of P' D = \\<lfloor>(a, aa, b)\\<rfloor>) \\<and>\n         \\<not> Program P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n         (\\<forall>x\\<in>set ms. wf_overriding (Program P') D x)) \\<and>\n        (C = Thread \\<longrightarrow>\n         (\\<exists>m. (run, [], Void, m) \\<in> set ms))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            map_of P' C = \\<lfloor>(a, aa, b)\\<rfloor>\n 2. \\<And>C D fs ms.\n       \\<lbrakk>P = Program P'; (C, D, fs, ms) \\<in> set P';\n        wf_syscls (Program P'); distinct_fst P';\n        case (C, D, fs, ms) of\n        (C, D, fs, ms) \\<Rightarrow>\n          (\\<forall>x\\<in>set fs. wf_fdecl (Program P') x) \\<and>\n          distinct_fst fs \\<and>\n          (\\<forall>x\\<in>set ms. wf_mdecl A (Program P') C x) \\<and>\n          distinct_fst ms \\<and>\n          (C \\<noteq> Object \\<longrightarrow>\n           is_class (Program P') D \\<and>\n           \\<not> Program P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n           (\\<forall>x\\<in>set ms. wf_overriding (Program P') D x)) \\<and>\n          (C = Thread \\<longrightarrow>\n           (\\<exists>m. (run, [], Void, m) \\<in> set ms));\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>set fs.\n                             wf_fdecl (Program P') x) \\<and>\n                         distinct_fst fs \\<and>\n                         (\\<forall>x\\<in>set ms.\n                             wf_mdecl B (Program P') C x) \\<and>\n                         distinct_fst ms \\<and>\n                         (C \\<noteq> Object \\<longrightarrow>\n                          is_class (Program P') D \\<and>\n                          \\<not> Program\n                                  P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n                          (\\<forall>x\\<in>set ms.\n                              wf_overriding (Program P') D x)) \\<and>\n                         (C = Thread \\<longrightarrow>\n                          (\\<exists>m. (run, [], Void, m) \\<in> set ms))", "apply(drule weak_map_of_SomeI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C D fs ms.\n       \\<lbrakk>P = Program P'; wf_syscls (Program P'); distinct_fst P';\n        (\\<forall>x\\<in>set fs. wf_fdecl (Program P') x) \\<and>\n        distinct_fst fs \\<and>\n        (\\<forall>x\\<in>set ms. wf_mdecl A (Program P') C x) \\<and>\n        distinct_fst ms \\<and>\n        (C \\<noteq> Object \\<longrightarrow>\n         (\\<exists>a aa b.\n             map_of P' D = \\<lfloor>(a, aa, b)\\<rfloor>) \\<and>\n         \\<not> Program P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n         (\\<forall>x\\<in>set ms. wf_overriding (Program P') D x)) \\<and>\n        (C = Thread \\<longrightarrow>\n         (\\<exists>m. (run, [], Void, m) \\<in> set ms));\n        \\<exists>x. map_of P' C = \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            map_of P' C = \\<lfloor>(a, aa, b)\\<rfloor>\n 2. \\<And>C D fs ms.\n       \\<lbrakk>P = Program P'; (C, D, fs, ms) \\<in> set P';\n        wf_syscls (Program P'); distinct_fst P';\n        case (C, D, fs, ms) of\n        (C, D, fs, ms) \\<Rightarrow>\n          (\\<forall>x\\<in>set fs. wf_fdecl (Program P') x) \\<and>\n          distinct_fst fs \\<and>\n          (\\<forall>x\\<in>set ms. wf_mdecl A (Program P') C x) \\<and>\n          distinct_fst ms \\<and>\n          (C \\<noteq> Object \\<longrightarrow>\n           is_class (Program P') D \\<and>\n           \\<not> Program P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n           (\\<forall>x\\<in>set ms. wf_overriding (Program P') D x)) \\<and>\n          (C = Thread \\<longrightarrow>\n           (\\<exists>m. (run, [], Void, m) \\<in> set ms));\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>set fs.\n                             wf_fdecl (Program P') x) \\<and>\n                         distinct_fst fs \\<and>\n                         (\\<forall>x\\<in>set ms.\n                             wf_mdecl B (Program P') C x) \\<and>\n                         distinct_fst ms \\<and>\n                         (C \\<noteq> Object \\<longrightarrow>\n                          is_class (Program P') D \\<and>\n                          \\<not> Program\n                                  P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n                          (\\<forall>x\\<in>set ms.\n                              wf_overriding (Program P') D x)) \\<and>\n                         (C = Thread \\<longrightarrow>\n                          (\\<exists>m. (run, [], Void, m) \\<in> set ms))", "apply(simp add: Program)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms.\n       \\<lbrakk>P = Program P'; (C, D, fs, ms) \\<in> set P';\n        wf_syscls (Program P'); distinct_fst P';\n        case (C, D, fs, ms) of\n        (C, D, fs, ms) \\<Rightarrow>\n          (\\<forall>x\\<in>set fs. wf_fdecl (Program P') x) \\<and>\n          distinct_fst fs \\<and>\n          (\\<forall>x\\<in>set ms. wf_mdecl A (Program P') C x) \\<and>\n          distinct_fst ms \\<and>\n          (C \\<noteq> Object \\<longrightarrow>\n           is_class (Program P') D \\<and>\n           \\<not> Program P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n           (\\<forall>x\\<in>set ms. wf_overriding (Program P') D x)) \\<and>\n          (C = Thread \\<longrightarrow>\n           (\\<exists>m. (run, [], Void, m) \\<in> set ms));\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>set fs.\n                             wf_fdecl (Program P') x) \\<and>\n                         distinct_fst fs \\<and>\n                         (\\<forall>x\\<in>set ms.\n                             wf_mdecl B (Program P') C x) \\<and>\n                         distinct_fst ms \\<and>\n                         (C \\<noteq> Object \\<longrightarrow>\n                          is_class (Program P') D \\<and>\n                          \\<not> Program\n                                  P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n                          (\\<forall>x\\<in>set ms.\n                              wf_overriding (Program P') D x)) \\<and>\n                         (C = Thread \\<longrightarrow>\n                          (\\<exists>m. (run, [], Void, m) \\<in> set ms))", "apply(clarsimp simp add: Program wf_mdecl_def split del: option.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms a aa aaa b.\n       \\<lbrakk>is_class (Program P') C; (C, D, fs, ms) \\<in> set P';\n        wf_syscls (Program P'); distinct_fst P';\n        \\<forall>x\\<in>set fs. wf_fdecl (Program P') x; distinct_fst fs;\n        \\<forall>x\\<in>set ms.\n           case x of\n           (M, Ts, ab) \\<Rightarrow>\n             (\\<forall>x\\<in>set Ts. is_type (Program P') x) \\<and>\n             (case ab of\n              (T, m) \\<Rightarrow>\n                ((\\<exists>y. m = \\<lfloor>y\\<rfloor>) \\<or>\n                 is_type (Program P') T \\<and> C\\<bullet>M(Ts) :: T) \\<and>\n                (\\<forall>x2.\n                    m = \\<lfloor>x2\\<rfloor> \\<longrightarrow>\n                    is_type (Program P') T \\<and>\n                    A (Program P') C (M, Ts, T, x2)));\n        distinct_fst ms;\n        C \\<noteq> Object \\<longrightarrow>\n        is_class (Program P') D \\<and>\n        \\<not> Program P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n        (\\<forall>x\\<in>set ms. wf_overriding (Program P') D x);\n        C = Thread \\<longrightarrow>\n        (\\<exists>m. (run, [], Void, m) \\<in> set ms);\n        (a, aa, aaa, b) \\<in> set ms\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>set aa.\n                             is_type (Program P') x) \\<and>\n                         is_type (Program P') aaa \\<and>\n                         (case b of\n                          None \\<Rightarrow> C\\<bullet>a(aa) :: aaa\n                          | \\<lfloor>mb\\<rfloor> \\<Rightarrow>\n                              B (Program P') C (a, aa, aaa, mb))", "apply(drule (1) bspec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms a aa ab b.\n       \\<lbrakk>is_class (Program P') C; (C, D, fs, ms) \\<in> set P';\n        wf_syscls (Program P'); distinct_fst P';\n        \\<forall>x\\<in>set fs. wf_fdecl (Program P') x; distinct_fst fs;\n        distinct_fst ms;\n        C \\<noteq> Object \\<longrightarrow>\n        is_class (Program P') D \\<and>\n        \\<not> Program P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n        (\\<forall>x\\<in>set ms. wf_overriding (Program P') D x);\n        C = Thread \\<longrightarrow>\n        (\\<exists>m. (run, [], Void, m) \\<in> set ms);\n        (a, aa, ab, b) \\<in> set ms;\n        case (a, aa, ab, b) of\n        (M, Ts, ab) \\<Rightarrow>\n          (\\<forall>x\\<in>set Ts. is_type (Program P') x) \\<and>\n          (case ab of\n           (T, m) \\<Rightarrow>\n             ((\\<exists>y. m = \\<lfloor>y\\<rfloor>) \\<or>\n              is_type (Program P') T \\<and> C\\<bullet>M(Ts) :: T) \\<and>\n             (\\<forall>x2.\n                 m = \\<lfloor>x2\\<rfloor> \\<longrightarrow>\n                 is_type (Program P') T \\<and>\n                 A (Program P') C (M, Ts, T, x2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>set aa.\n                             is_type (Program P') x) \\<and>\n                         is_type (Program P') ab \\<and>\n                         (case b of None \\<Rightarrow> C\\<bullet>a(aa) :: ab\n                          | \\<lfloor>mb\\<rfloor> \\<Rightarrow>\n                              B (Program P') C (a, aa, ab, mb))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms a aa ab b.\n       \\<lbrakk>is_class (Program P') C; (C, D, fs, ms) \\<in> set P';\n        wf_syscls (Program P'); distinct_fst P';\n        \\<forall>x\\<in>set fs. wf_fdecl (Program P') x; distinct_fst fs;\n        distinct_fst ms;\n        C \\<noteq> Object \\<longrightarrow>\n        is_class (Program P') D \\<and>\n        \\<not> Program P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n        (\\<forall>x\\<in>set ms. wf_overriding (Program P') D x);\n        C = Thread \\<longrightarrow>\n        (\\<exists>m. (run, [], Void, m) \\<in> set ms);\n        (a, aa, ab, b) \\<in> set ms;\n        \\<forall>x\\<in>set aa. is_type (Program P') x;\n        (\\<exists>y. b = \\<lfloor>y\\<rfloor>) \\<or>\n        is_type (Program P') ab \\<and> C\\<bullet>a(aa) :: ab;\n        \\<forall>x2.\n           b = \\<lfloor>x2\\<rfloor> \\<longrightarrow>\n           is_type (Program P') ab \\<and>\n           A (Program P') C (a, aa, ab, x2)\\<rbrakk>\n       \\<Longrightarrow> (b = None \\<longrightarrow>\n                          is_type (Program P') ab \\<and>\n                          C\\<bullet>a(aa) :: ab) \\<and>\n                         (\\<forall>x2.\n                             b = \\<lfloor>x2\\<rfloor> \\<longrightarrow>\n                             B (Program P') C (a, aa, ab, x2))", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C D fs ms a aa ab b.\n       \\<lbrakk>is_class (Program P') C; (C, D, fs, ms) \\<in> set P';\n        wf_syscls (Program P'); distinct_fst P';\n        \\<forall>x\\<in>set fs. wf_fdecl (Program P') x; distinct_fst fs;\n        distinct_fst ms;\n        C \\<noteq> Object \\<longrightarrow>\n        is_class (Program P') D \\<and>\n        \\<not> Program P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n        (\\<forall>x\\<in>set ms. wf_overriding (Program P') D x);\n        C = Thread \\<longrightarrow>\n        (\\<exists>m. (run, [], Void, m) \\<in> set ms);\n        (a, aa, ab, b) \\<in> set ms;\n        \\<forall>x\\<in>set aa. is_type (Program P') x;\n        (\\<exists>y. b = \\<lfloor>y\\<rfloor>) \\<or>\n        is_type (Program P') ab \\<and> C\\<bullet>a(aa) :: ab;\n        \\<forall>x2.\n           b = \\<lfloor>x2\\<rfloor> \\<longrightarrow>\n           is_type (Program P') ab \\<and>\n           A (Program P') C (a, aa, ab, x2)\\<rbrakk>\n       \\<Longrightarrow> b = None \\<longrightarrow>\n                         is_type (Program P') ab \\<and>\n                         C\\<bullet>a(aa) :: ab\n 2. \\<And>C D fs ms a aa ab b.\n       \\<lbrakk>is_class (Program P') C; (C, D, fs, ms) \\<in> set P';\n        wf_syscls (Program P'); distinct_fst P';\n        \\<forall>x\\<in>set fs. wf_fdecl (Program P') x; distinct_fst fs;\n        distinct_fst ms;\n        C \\<noteq> Object \\<longrightarrow>\n        is_class (Program P') D \\<and>\n        \\<not> Program P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n        (\\<forall>x\\<in>set ms. wf_overriding (Program P') D x);\n        C = Thread \\<longrightarrow>\n        (\\<exists>m. (run, [], Void, m) \\<in> set ms);\n        (a, aa, ab, b) \\<in> set ms;\n        \\<forall>x\\<in>set aa. is_type (Program P') x;\n        (\\<exists>y. b = \\<lfloor>y\\<rfloor>) \\<or>\n        is_type (Program P') ab \\<and> C\\<bullet>a(aa) :: ab;\n        \\<forall>x2.\n           b = \\<lfloor>x2\\<rfloor> \\<longrightarrow>\n           is_type (Program P') ab \\<and>\n           A (Program P') C (a, aa, ab, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x2.\n                            b = \\<lfloor>x2\\<rfloor> \\<longrightarrow>\n                            B (Program P') C (a, aa, ab, x2)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms a aa ab b.\n       \\<lbrakk>is_class (Program P') C; (C, D, fs, ms) \\<in> set P';\n        wf_syscls (Program P'); distinct_fst P';\n        \\<forall>x\\<in>set fs. wf_fdecl (Program P') x; distinct_fst fs;\n        distinct_fst ms;\n        C \\<noteq> Object \\<longrightarrow>\n        is_class (Program P') D \\<and>\n        \\<not> Program P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n        (\\<forall>x\\<in>set ms. wf_overriding (Program P') D x);\n        C = Thread \\<longrightarrow>\n        (\\<exists>m. (run, [], Void, m) \\<in> set ms);\n        (a, aa, ab, b) \\<in> set ms;\n        \\<forall>x\\<in>set aa. is_type (Program P') x;\n        (\\<exists>y. b = \\<lfloor>y\\<rfloor>) \\<or>\n        is_type (Program P') ab \\<and> C\\<bullet>a(aa) :: ab;\n        \\<forall>x2.\n           b = \\<lfloor>x2\\<rfloor> \\<longrightarrow>\n           is_type (Program P') ab \\<and>\n           A (Program P') C (a, aa, ab, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x2.\n                            b = \\<lfloor>x2\\<rfloor> \\<longrightarrow>\n                            B (Program P') C (a, aa, ab, x2)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms a aa ab x2.\n       \\<lbrakk>is_class (Program P') C; (C, D, fs, ms) \\<in> set P';\n        wf_syscls (Program P'); distinct_fst P';\n        \\<forall>x\\<in>set fs. wf_fdecl (Program P') x; distinct_fst fs;\n        distinct_fst ms;\n        C \\<noteq> Object \\<longrightarrow>\n        is_class (Program P') D \\<and>\n        \\<not> Program P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n        (\\<forall>x\\<in>set ms. wf_overriding (Program P') D x);\n        C = Thread \\<longrightarrow>\n        (\\<exists>m. (run, [], Void, m) \\<in> set ms);\n        (a, aa, ab, \\<lfloor>x2\\<rfloor>) \\<in> set ms;\n        \\<forall>x\\<in>set aa. is_type (Program P') x;\n        is_type (Program P') ab; A (Program P') C (a, aa, ab, x2)\\<rbrakk>\n       \\<Longrightarrow> B (Program P') C (a, aa, ab, x2)", "apply(frule (1) map_of_SomeI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms a aa ab x2.\n       \\<lbrakk>is_class (Program P') C; (C, D, fs, ms) \\<in> set P';\n        wf_syscls (Program P'); distinct_fst P';\n        \\<forall>x\\<in>set fs. wf_fdecl (Program P') x; distinct_fst fs;\n        distinct_fst ms;\n        C \\<noteq> Object \\<longrightarrow>\n        is_class (Program P') D \\<and>\n        \\<not> Program P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n        (\\<forall>x\\<in>set ms. wf_overriding (Program P') D x);\n        C = Thread \\<longrightarrow>\n        (\\<exists>m. (run, [], Void, m) \\<in> set ms);\n        (a, aa, ab, \\<lfloor>x2\\<rfloor>) \\<in> set ms;\n        \\<forall>x\\<in>set aa. is_type (Program P') x;\n        is_type (Program P') ab; A (Program P') C (a, aa, ab, x2);\n        map_of P' C = \\<lfloor>(D, fs, ms)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> B (Program P') C (a, aa, ab, x2)", "apply(rule rule[OF wf, unfolded Program])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>C D fs ms a aa ab x2.\n       \\<lbrakk>is_class (Program P') C; (C, D, fs, ms) \\<in> set P';\n        wf_syscls (Program P'); distinct_fst P';\n        \\<forall>x\\<in>set fs. wf_fdecl (Program P') x; distinct_fst fs;\n        distinct_fst ms;\n        C \\<noteq> Object \\<longrightarrow>\n        is_class (Program P') D \\<and>\n        \\<not> Program P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n        (\\<forall>x\\<in>set ms. wf_overriding (Program P') D x);\n        C = Thread \\<longrightarrow>\n        (\\<exists>m. (run, [], Void, m) \\<in> set ms);\n        (a, aa, ab, \\<lfloor>x2\\<rfloor>) \\<in> set ms;\n        \\<forall>x\\<in>set aa. is_type (Program P') x;\n        is_type (Program P') ab; A (Program P') C (a, aa, ab, x2);\n        map_of P' C = \\<lfloor>(D, fs, ms)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> Program\n                          P' \\<turnstile> C sees a: aa\\<rightarrow>ab = \\<lfloor>x2\\<rfloor> in C\n 2. \\<And>C D fs ms a aa ab x2.\n       \\<lbrakk>is_class (Program P') C; (C, D, fs, ms) \\<in> set P';\n        wf_syscls (Program P'); distinct_fst P';\n        \\<forall>x\\<in>set fs. wf_fdecl (Program P') x; distinct_fst fs;\n        distinct_fst ms;\n        C \\<noteq> Object \\<longrightarrow>\n        is_class (Program P') D \\<and>\n        \\<not> Program P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n        (\\<forall>x\\<in>set ms. wf_overriding (Program P') D x);\n        C = Thread \\<longrightarrow>\n        (\\<exists>m. (run, [], Void, m) \\<in> set ms);\n        (a, aa, ab, \\<lfloor>x2\\<rfloor>) \\<in> set ms;\n        \\<forall>x\\<in>set aa. is_type (Program P') x;\n        is_type (Program P') ab; A (Program P') C (a, aa, ab, x2);\n        map_of P' C = \\<lfloor>(D, fs, ms)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> is_class (Program P') C\n 3. \\<And>C D fs ms a aa ab x2.\n       \\<lbrakk>is_class (Program P') C; (C, D, fs, ms) \\<in> set P';\n        wf_syscls (Program P'); distinct_fst P';\n        \\<forall>x\\<in>set fs. wf_fdecl (Program P') x; distinct_fst fs;\n        distinct_fst ms;\n        C \\<noteq> Object \\<longrightarrow>\n        is_class (Program P') D \\<and>\n        \\<not> Program P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n        (\\<forall>x\\<in>set ms. wf_overriding (Program P') D x);\n        C = Thread \\<longrightarrow>\n        (\\<exists>m. (run, [], Void, m) \\<in> set ms);\n        (a, aa, ab, \\<lfloor>x2\\<rfloor>) \\<in> set ms;\n        \\<forall>x\\<in>set aa. is_type (Program P') x;\n        is_type (Program P') ab; A (Program P') C (a, aa, ab, x2);\n        map_of P' C = \\<lfloor>(D, fs, ms)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> set aa \\<subseteq> types (Program P')\n 4. \\<And>C D fs ms a aa ab x2.\n       \\<lbrakk>is_class (Program P') C; (C, D, fs, ms) \\<in> set P';\n        wf_syscls (Program P'); distinct_fst P';\n        \\<forall>x\\<in>set fs. wf_fdecl (Program P') x; distinct_fst fs;\n        distinct_fst ms;\n        C \\<noteq> Object \\<longrightarrow>\n        is_class (Program P') D \\<and>\n        \\<not> Program P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n        (\\<forall>x\\<in>set ms. wf_overriding (Program P') D x);\n        C = Thread \\<longrightarrow>\n        (\\<exists>m. (run, [], Void, m) \\<in> set ms);\n        (a, aa, ab, \\<lfloor>x2\\<rfloor>) \\<in> set ms;\n        \\<forall>x\\<in>set aa. is_type (Program P') x;\n        is_type (Program P') ab; A (Program P') C (a, aa, ab, x2);\n        map_of P' C = \\<lfloor>(D, fs, ms)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> A (Program P') C (a, aa, ab, x2)", "apply(clarsimp simp add: is_class_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>C D fs ms a aa ab x2.\n       \\<lbrakk>(C, D, fs, ms) \\<in> set P'; wf_syscls (Program P');\n        distinct_fst P'; \\<forall>x\\<in>set fs. wf_fdecl (Program P') x;\n        distinct_fst fs; distinct_fst ms;\n        C \\<noteq> Object \\<longrightarrow>\n        (\\<exists>a aa b. map_of P' D = \\<lfloor>(a, aa, b)\\<rfloor>) \\<and>\n        \\<not> Program P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n        (\\<forall>x\\<in>set ms. wf_overriding (Program P') D x);\n        C = Thread \\<longrightarrow>\n        (\\<exists>m. (run, [], Void, m) \\<in> set ms);\n        (a, aa, ab, \\<lfloor>x2\\<rfloor>) \\<in> set ms;\n        \\<forall>x\\<in>set aa. is_type (Program P') x;\n        is_type (Program P') ab; A (Program P') C (a, aa, ab, x2);\n        map_of P' C = \\<lfloor>(D, fs, ms)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> Program\n                          P' \\<turnstile> C sees a: aa\\<rightarrow>ab = \\<lfloor>x2\\<rfloor> in C\n 2. \\<And>C D fs ms a aa ab x2.\n       \\<lbrakk>is_class (Program P') C; (C, D, fs, ms) \\<in> set P';\n        wf_syscls (Program P'); distinct_fst P';\n        \\<forall>x\\<in>set fs. wf_fdecl (Program P') x; distinct_fst fs;\n        distinct_fst ms;\n        C \\<noteq> Object \\<longrightarrow>\n        is_class (Program P') D \\<and>\n        \\<not> Program P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n        (\\<forall>x\\<in>set ms. wf_overriding (Program P') D x);\n        C = Thread \\<longrightarrow>\n        (\\<exists>m. (run, [], Void, m) \\<in> set ms);\n        (a, aa, ab, \\<lfloor>x2\\<rfloor>) \\<in> set ms;\n        \\<forall>x\\<in>set aa. is_type (Program P') x;\n        is_type (Program P') ab; A (Program P') C (a, aa, ab, x2);\n        map_of P' C = \\<lfloor>(D, fs, ms)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> is_class (Program P') C\n 3. \\<And>C D fs ms a aa ab x2.\n       \\<lbrakk>is_class (Program P') C; (C, D, fs, ms) \\<in> set P';\n        wf_syscls (Program P'); distinct_fst P';\n        \\<forall>x\\<in>set fs. wf_fdecl (Program P') x; distinct_fst fs;\n        distinct_fst ms;\n        C \\<noteq> Object \\<longrightarrow>\n        is_class (Program P') D \\<and>\n        \\<not> Program P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n        (\\<forall>x\\<in>set ms. wf_overriding (Program P') D x);\n        C = Thread \\<longrightarrow>\n        (\\<exists>m. (run, [], Void, m) \\<in> set ms);\n        (a, aa, ab, \\<lfloor>x2\\<rfloor>) \\<in> set ms;\n        \\<forall>x\\<in>set aa. is_type (Program P') x;\n        is_type (Program P') ab; A (Program P') C (a, aa, ab, x2);\n        map_of P' C = \\<lfloor>(D, fs, ms)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> set aa \\<subseteq> types (Program P')\n 4. \\<And>C D fs ms a aa ab x2.\n       \\<lbrakk>is_class (Program P') C; (C, D, fs, ms) \\<in> set P';\n        wf_syscls (Program P'); distinct_fst P';\n        \\<forall>x\\<in>set fs. wf_fdecl (Program P') x; distinct_fst fs;\n        distinct_fst ms;\n        C \\<noteq> Object \\<longrightarrow>\n        is_class (Program P') D \\<and>\n        \\<not> Program P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n        (\\<forall>x\\<in>set ms. wf_overriding (Program P') D x);\n        C = Thread \\<longrightarrow>\n        (\\<exists>m. (run, [], Void, m) \\<in> set ms);\n        (a, aa, ab, \\<lfloor>x2\\<rfloor>) \\<in> set ms;\n        \\<forall>x\\<in>set aa. is_type (Program P') x;\n        is_type (Program P') ab; A (Program P') C (a, aa, ab, x2);\n        map_of P' C = \\<lfloor>(D, fs, ms)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> A (Program P') C (a, aa, ab, x2)", "apply(rule mdecl_visible[OF wf[unfolded Program]])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>C D fs ms a aa ab x2.\n       \\<lbrakk>(C, D, fs, ms) \\<in> set P'; wf_syscls (Program P');\n        distinct_fst P'; \\<forall>x\\<in>set fs. wf_fdecl (Program P') x;\n        distinct_fst fs; distinct_fst ms;\n        C \\<noteq> Object \\<longrightarrow>\n        (\\<exists>a aa b. map_of P' D = \\<lfloor>(a, aa, b)\\<rfloor>) \\<and>\n        \\<not> Program P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n        (\\<forall>x\\<in>set ms. wf_overriding (Program P') D x);\n        C = Thread \\<longrightarrow>\n        (\\<exists>m. (run, [], Void, m) \\<in> set ms);\n        (a, aa, ab, \\<lfloor>x2\\<rfloor>) \\<in> set ms;\n        \\<forall>x\\<in>set aa. is_type (Program P') x;\n        is_type (Program P') ab; A (Program P') C (a, aa, ab, x2);\n        map_of P' C = \\<lfloor>(D, fs, ms)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> class (Program P') C =\n                         \\<lfloor>(?S84 C D fs ms a aa ab x2,\n                                   ?fs84 C D fs ms a aa ab x2,\n                                   ?ms84 C D fs ms a aa ab x2)\\<rfloor>\n 2. \\<And>C D fs ms a aa ab x2.\n       \\<lbrakk>(C, D, fs, ms) \\<in> set P'; wf_syscls (Program P');\n        distinct_fst P'; \\<forall>x\\<in>set fs. wf_fdecl (Program P') x;\n        distinct_fst fs; distinct_fst ms;\n        C \\<noteq> Object \\<longrightarrow>\n        (\\<exists>a aa b. map_of P' D = \\<lfloor>(a, aa, b)\\<rfloor>) \\<and>\n        \\<not> Program P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n        (\\<forall>x\\<in>set ms. wf_overriding (Program P') D x);\n        C = Thread \\<longrightarrow>\n        (\\<exists>m. (run, [], Void, m) \\<in> set ms);\n        (a, aa, ab, \\<lfloor>x2\\<rfloor>) \\<in> set ms;\n        \\<forall>x\\<in>set aa. is_type (Program P') x;\n        is_type (Program P') ab; A (Program P') C (a, aa, ab, x2);\n        map_of P' C = \\<lfloor>(D, fs, ms)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (a, aa, ab, \\<lfloor>x2\\<rfloor>)\n                         \\<in> set (?ms84 C D fs ms a aa ab x2)\n 3. \\<And>C D fs ms a aa ab x2.\n       \\<lbrakk>is_class (Program P') C; (C, D, fs, ms) \\<in> set P';\n        wf_syscls (Program P'); distinct_fst P';\n        \\<forall>x\\<in>set fs. wf_fdecl (Program P') x; distinct_fst fs;\n        distinct_fst ms;\n        C \\<noteq> Object \\<longrightarrow>\n        is_class (Program P') D \\<and>\n        \\<not> Program P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n        (\\<forall>x\\<in>set ms. wf_overriding (Program P') D x);\n        C = Thread \\<longrightarrow>\n        (\\<exists>m. (run, [], Void, m) \\<in> set ms);\n        (a, aa, ab, \\<lfloor>x2\\<rfloor>) \\<in> set ms;\n        \\<forall>x\\<in>set aa. is_type (Program P') x;\n        is_type (Program P') ab; A (Program P') C (a, aa, ab, x2);\n        map_of P' C = \\<lfloor>(D, fs, ms)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> is_class (Program P') C\n 4. \\<And>C D fs ms a aa ab x2.\n       \\<lbrakk>is_class (Program P') C; (C, D, fs, ms) \\<in> set P';\n        wf_syscls (Program P'); distinct_fst P';\n        \\<forall>x\\<in>set fs. wf_fdecl (Program P') x; distinct_fst fs;\n        distinct_fst ms;\n        C \\<noteq> Object \\<longrightarrow>\n        is_class (Program P') D \\<and>\n        \\<not> Program P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n        (\\<forall>x\\<in>set ms. wf_overriding (Program P') D x);\n        C = Thread \\<longrightarrow>\n        (\\<exists>m. (run, [], Void, m) \\<in> set ms);\n        (a, aa, ab, \\<lfloor>x2\\<rfloor>) \\<in> set ms;\n        \\<forall>x\\<in>set aa. is_type (Program P') x;\n        is_type (Program P') ab; A (Program P') C (a, aa, ab, x2);\n        map_of P' C = \\<lfloor>(D, fs, ms)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> set aa \\<subseteq> types (Program P')\n 5. \\<And>C D fs ms a aa ab x2.\n       \\<lbrakk>is_class (Program P') C; (C, D, fs, ms) \\<in> set P';\n        wf_syscls (Program P'); distinct_fst P';\n        \\<forall>x\\<in>set fs. wf_fdecl (Program P') x; distinct_fst fs;\n        distinct_fst ms;\n        C \\<noteq> Object \\<longrightarrow>\n        is_class (Program P') D \\<and>\n        \\<not> Program P' \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n        (\\<forall>x\\<in>set ms. wf_overriding (Program P') D x);\n        C = Thread \\<longrightarrow>\n        (\\<exists>m. (run, [], Void, m) \\<in> set ms);\n        (a, aa, ab, \\<lfloor>x2\\<rfloor>) \\<in> set ms;\n        \\<forall>x\\<in>set aa. is_type (Program P') x;\n        is_type (Program P') ab; A (Program P') C (a, aa, ab, x2);\n        map_of P' C = \\<lfloor>(D, fs, ms)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> A (Program P') C (a, aa, ab, x2)", "apply(fastforce intro: is_type_pTs [OF wf, unfolded Program])+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  wf_prog B P\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Well-formedness and field lookup\\<close>"], ["", "lemma wf_Fields_Ex:\n  \"\\<lbrakk> wf_prog wf_md P; is_class P C \\<rbrakk> \\<Longrightarrow> \\<exists>FDTs. P \\<turnstile> C has_fields FDTs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; is_class P C\\<rbrakk>\n    \\<Longrightarrow> \\<exists>FDTs. P \\<turnstile> C has_fields FDTs", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; is_class P C\\<rbrakk>\n    \\<Longrightarrow> \\<exists>FDTs. P \\<turnstile> C has_fields FDTs", "apply(frule class_Object)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; is_class P C;\n     \\<exists>C fs ms.\n        class P Object = \\<lfloor>(C, fs, ms)\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>FDTs. P \\<turnstile> C has_fields FDTs", "apply(erule (1) subcls1_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_class P C;\n     \\<exists>C fs ms.\n        class P Object = \\<lfloor>(C, fs, ms)\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>FDTs. P \\<turnstile> Object has_fields FDTs\n 2. \\<And>Ca D.\n       \\<lbrakk>is_class P C;\n        \\<exists>C fs ms. class P Object = \\<lfloor>(C, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object; P \\<turnstile> Ca \\<prec>\\<^sup>1 D;\n        is_class P D;\n        \\<exists>FDTs. P \\<turnstile> D has_fields FDTs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>FDTs. P \\<turnstile> Ca has_fields FDTs", "apply(blast intro:has_fields_Object)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ca D.\n       \\<lbrakk>is_class P C;\n        \\<exists>C fs ms. class P Object = \\<lfloor>(C, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object; P \\<turnstile> Ca \\<prec>\\<^sup>1 D;\n        is_class P D;\n        \\<exists>FDTs. P \\<turnstile> D has_fields FDTs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>FDTs. P \\<turnstile> Ca has_fields FDTs", "apply(blast intro:has_fields_rec dest:subcls1D)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma has_fields_types:\n  \"\\<lbrakk> P \\<turnstile> C has_fields FDTs; (FD, T, fm) \\<in> set FDTs; wf_prog wf_md P \\<rbrakk> \\<Longrightarrow> is_type P T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C has_fields FDTs; (FD, T, fm) \\<in> set FDTs;\n     wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> is_type P T", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C has_fields FDTs; (FD, T, fm) \\<in> set FDTs;\n     wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> is_type P T", "apply(induct rule:Fields.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        \\<lbrakk>(FD, T, fm) \\<in> set FDTs; wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> is_type P T;\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs;\n        (FD, T, fm) \\<in> set FDTs'; wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 2. \\<And>D fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs;\n        (FD, T, fm) \\<in> set FDTs; wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> is_type P T", "apply(fastforce dest!: class_wf simp: wf_cdecl_def wf_fdecl_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs;\n        (FD, T, fm) \\<in> set FDTs; wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> is_type P T", "apply(fastforce dest!: class_wf simp: wf_cdecl_def wf_fdecl_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma sees_field_is_type:\n  \"\\<lbrakk> P \\<turnstile> C sees F:T (fm) in D; wf_prog wf_md P \\<rbrakk> \\<Longrightarrow> is_type P T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C sees F:T (fm) in D; wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> is_type P T", "by(fastforce simp: sees_field_def\n            elim: has_fields_types map_of_SomeD[OF map_of_remap_SomeD])"], ["", "lemma wf_has_field_mono2:\n  assumes wf: \"wf_prog wf_md P\"\n  and has: \"P \\<turnstile> C has F:T (fm) in E\"\n  shows \"\\<lbrakk> P \\<turnstile> C \\<preceq>\\<^sup>* D; P \\<turnstile> D \\<preceq>\\<^sup>* E \\<rbrakk> \\<Longrightarrow> P \\<turnstile> D has F:T (fm) in E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n     P \\<turnstile> D \\<preceq>\\<^sup>* E\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> D has F:T (fm) in E", "proof(induct rule: rtranclp_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. P \\<turnstile> C \\<preceq>\\<^sup>* E \\<Longrightarrow>\n    P \\<turnstile> C has F:T (fm) in E\n 2. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* y;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> y \\<preceq>\\<^sup>* E \\<Longrightarrow>\n        P \\<turnstile> y has F:T (fm) in E;\n        P \\<turnstile> z \\<preceq>\\<^sup>* E\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> z has F:T (fm) in E", "case base"], ["proof (state)\nthis:\n  P \\<turnstile> C \\<preceq>\\<^sup>* E\n\ngoal (2 subgoals):\n 1. P \\<turnstile> C \\<preceq>\\<^sup>* E \\<Longrightarrow>\n    P \\<turnstile> C has F:T (fm) in E\n 2. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* y;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> y \\<preceq>\\<^sup>* E \\<Longrightarrow>\n        P \\<turnstile> y has F:T (fm) in E;\n        P \\<turnstile> z \\<preceq>\\<^sup>* E\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> z has F:T (fm) in E", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has F:T (fm) in E", "using has"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has F:T (fm) in E\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C has F:T (fm) in E", "."], ["proof (state)\nthis:\n  P \\<turnstile> C has F:T (fm) in E\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* y;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> y \\<preceq>\\<^sup>* E \\<Longrightarrow>\n        P \\<turnstile> y has F:T (fm) in E;\n        P \\<turnstile> z \\<preceq>\\<^sup>* E\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> z has F:T (fm) in E", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* y;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> y \\<preceq>\\<^sup>* E \\<Longrightarrow>\n        P \\<turnstile> y has F:T (fm) in E;\n        P \\<turnstile> z \\<preceq>\\<^sup>* E\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> z has F:T (fm) in E", "case (step D D')"], ["proof (state)\nthis:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  P \\<turnstile> D \\<prec>\\<^sup>1 D'\n  P \\<turnstile> D \\<preceq>\\<^sup>* E \\<Longrightarrow>\n  P \\<turnstile> D has F:T (fm) in E\n  P \\<turnstile> D' \\<preceq>\\<^sup>* E\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* y;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> y \\<preceq>\\<^sup>* E \\<Longrightarrow>\n        P \\<turnstile> y has F:T (fm) in E;\n        P \\<turnstile> z \\<preceq>\\<^sup>* E\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> z has F:T (fm) in E", "note DsubD' = \\<open>P \\<turnstile> D \\<prec>\\<^sup>1 D'\\<close>"], ["proof (state)\nthis:\n  P \\<turnstile> D \\<prec>\\<^sup>1 D'\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* y;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> y \\<preceq>\\<^sup>* E \\<Longrightarrow>\n        P \\<turnstile> y has F:T (fm) in E;\n        P \\<turnstile> z \\<preceq>\\<^sup>* E\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> z has F:T (fm) in E", "from DsubD'"], ["proof (chain)\npicking this:\n  P \\<turnstile> D \\<prec>\\<^sup>1 D'", "obtain rest where classD: \"class P D = \\<lfloor>(D', rest)\\<rfloor>\"\n    and DObj: \"D \\<noteq> Object\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D \\<prec>\\<^sup>1 D'\n\ngoal (1 subgoal):\n 1. (\\<And>rest.\n        \\<lbrakk>class P D = \\<lfloor>(D', rest)\\<rfloor>;\n         D \\<noteq> Object\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim!: subcls1.cases)"], ["proof (state)\nthis:\n  class P D = \\<lfloor>(D', rest)\\<rfloor>\n  D \\<noteq> Object\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* y;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> y \\<preceq>\\<^sup>* E \\<Longrightarrow>\n        P \\<turnstile> y has F:T (fm) in E;\n        P \\<turnstile> z \\<preceq>\\<^sup>* E\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> z has F:T (fm) in E", "from DsubD' \\<open>P \\<turnstile> D' \\<preceq>\\<^sup>* E\\<close>"], ["proof (chain)\npicking this:\n  P \\<turnstile> D \\<prec>\\<^sup>1 D'\n  P \\<turnstile> D' \\<preceq>\\<^sup>* E", "have DsubE: \"P \\<turnstile> D \\<preceq>\\<^sup>* E\" and DsubE2: \"(subcls1 P)^++ D E\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D \\<prec>\\<^sup>1 D'\n  P \\<turnstile> D' \\<preceq>\\<^sup>* E\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D \\<preceq>\\<^sup>* E &&& (subcls1 P)\\<^sup>+\\<^sup>+ D E", "by(rule converse_rtranclp_into_rtranclp rtranclp_into_tranclp2)+"], ["proof (state)\nthis:\n  P \\<turnstile> D \\<preceq>\\<^sup>* E\n  (subcls1 P)\\<^sup>+\\<^sup>+ D E\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* y;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> y \\<preceq>\\<^sup>* E \\<Longrightarrow>\n        P \\<turnstile> y has F:T (fm) in E;\n        P \\<turnstile> z \\<preceq>\\<^sup>* E\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> z has F:T (fm) in E", "from wf DsubE2"], ["proof (chain)\npicking this:\n  wf_prog wf_md P\n  (subcls1 P)\\<^sup>+\\<^sup>+ D E", "have DnE: \"D \\<noteq> E\""], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  (subcls1 P)\\<^sup>+\\<^sup>+ D E\n\ngoal (1 subgoal):\n 1. D \\<noteq> E", "by(rule subcls_irrefl)"], ["proof (state)\nthis:\n  D \\<noteq> E\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* y;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> y \\<preceq>\\<^sup>* E \\<Longrightarrow>\n        P \\<turnstile> y has F:T (fm) in E;\n        P \\<turnstile> z \\<preceq>\\<^sup>* E\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> z has F:T (fm) in E", "from DsubE"], ["proof (chain)\npicking this:\n  P \\<turnstile> D \\<preceq>\\<^sup>* E", "have hasD: \"P \\<turnstile> D has F:T (fm) in E\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D \\<preceq>\\<^sup>* E\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D has F:T (fm) in E", "by(rule \\<open>P \\<turnstile> D \\<preceq>\\<^sup>* E \\<Longrightarrow> P \\<turnstile> D has F:T (fm) in E\\<close>)"], ["proof (state)\nthis:\n  P \\<turnstile> D has F:T (fm) in E\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* y;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> y \\<preceq>\\<^sup>* E \\<Longrightarrow>\n        P \\<turnstile> y has F:T (fm) in E;\n        P \\<turnstile> z \\<preceq>\\<^sup>* E\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> z has F:T (fm) in E", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> D has F:T (fm) in E", "obtain FDTs where hasf: \"P \\<turnstile> D has_fields FDTs\" and FE: \"map_of FDTs (F, E) = \\<lfloor>(T, fm)\\<rfloor>\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D has F:T (fm) in E\n\ngoal (1 subgoal):\n 1. (\\<And>FDTs.\n        \\<lbrakk>P \\<turnstile> D has_fields FDTs;\n         map_of FDTs (F, E) = \\<lfloor>(T, fm)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding has_field_def"], ["proof (prove)\nusing this:\n  \\<exists>FDTs.\n     P \\<turnstile> D has_fields FDTs \\<and>\n     map_of FDTs (F, E) = \\<lfloor>(T, fm)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>FDTs.\n        \\<lbrakk>P \\<turnstile> D has_fields FDTs;\n         map_of FDTs (F, E) = \\<lfloor>(T, fm)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  P \\<turnstile> D has_fields FDTs\n  map_of FDTs (F, E) = \\<lfloor>(T, fm)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* y;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> y \\<preceq>\\<^sup>* E \\<Longrightarrow>\n        P \\<turnstile> y has F:T (fm) in E;\n        P \\<turnstile> z \\<preceq>\\<^sup>* E\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> z has F:T (fm) in E", "from hasf"], ["proof (chain)\npicking this:\n  P \\<turnstile> D has_fields FDTs", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> D has_fields FDTs\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D' has F:T (fm) in E", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>D fs ms FDTsa.\n       \\<lbrakk>class P D = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        D \\<noteq> Object; P \\<turnstile> D has_fields FDTsa;\n        FDTs = map (\\<lambda>(F, y). ((F, D), y)) fs @ FDTsa\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> D' has F:T (fm) in E\n 2. \\<And>D fs ms.\n       \\<lbrakk>D = Object; class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, y). ((F, Object), y)) fs\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> D' has F:T (fm) in E", "case has_fields_Object"], ["proof (state)\nthis:\n  D = Object\n  class P Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  FDTs = map (\\<lambda>(F, y). ((F, Object), y)) fs_\n\ngoal (2 subgoals):\n 1. \\<And>D fs ms FDTsa.\n       \\<lbrakk>class P D = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        D \\<noteq> Object; P \\<turnstile> D has_fields FDTsa;\n        FDTs = map (\\<lambda>(F, y). ((F, D), y)) fs @ FDTsa\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> D' has F:T (fm) in E\n 2. \\<And>D fs ms.\n       \\<lbrakk>D = Object; class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, y). ((F, Object), y)) fs\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> D' has F:T (fm) in E", "with DObj"], ["proof (chain)\npicking this:\n  D \\<noteq> Object\n  D = Object\n  class P Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  FDTs = map (\\<lambda>(F, y). ((F, Object), y)) fs_", "show ?thesis"], ["proof (prove)\nusing this:\n  D \\<noteq> Object\n  D = Object\n  class P Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  FDTs = map (\\<lambda>(F, y). ((F, Object), y)) fs_\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D' has F:T (fm) in E", "by simp"], ["proof (state)\nthis:\n  P \\<turnstile> D' has F:T (fm) in E\n\ngoal (1 subgoal):\n 1. \\<And>D fs ms FDTsa.\n       \\<lbrakk>class P D = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        D \\<noteq> Object; P \\<turnstile> D has_fields FDTsa;\n        FDTs = map (\\<lambda>(F, y). ((F, D), y)) fs @ FDTsa\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> D' has F:T (fm) in E", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>D fs ms FDTsa.\n       \\<lbrakk>class P D = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        D \\<noteq> Object; P \\<turnstile> D has_fields FDTsa;\n        FDTs = map (\\<lambda>(F, y). ((F, D), y)) fs @ FDTsa\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> D' has F:T (fm) in E", "case (has_fields_rec DD' fs ms FDTs')"], ["proof (state)\nthis:\n  class P D = \\<lfloor>(DD', fs, ms)\\<rfloor>\n  D \\<noteq> Object\n  P \\<turnstile> DD' has_fields FDTs'\n  FDTs = map (\\<lambda>(F, y). ((F, D), y)) fs @ FDTs'\n\ngoal (1 subgoal):\n 1. \\<And>D fs ms FDTsa.\n       \\<lbrakk>class P D = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        D \\<noteq> Object; P \\<turnstile> D has_fields FDTsa;\n        FDTs = map (\\<lambda>(F, y). ((F, D), y)) fs @ FDTsa\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> D' has F:T (fm) in E", "with classD"], ["proof (chain)\npicking this:\n  class P D = \\<lfloor>(D', rest)\\<rfloor>\n  class P D = \\<lfloor>(DD', fs, ms)\\<rfloor>\n  D \\<noteq> Object\n  P \\<turnstile> DD' has_fields FDTs'\n  FDTs = map (\\<lambda>(F, y). ((F, D), y)) fs @ FDTs'", "have [simp]: \"DD' = D'\" \"rest = (fs, ms)\"\n      and hasf': \"P \\<turnstile> D' has_fields FDTs'\"\n      and FDTs: \"FDTs = map (\\<lambda>(F, Tm). ((F, D), Tm)) fs @ FDTs'\""], ["proof (prove)\nusing this:\n  class P D = \\<lfloor>(D', rest)\\<rfloor>\n  class P D = \\<lfloor>(DD', fs, ms)\\<rfloor>\n  D \\<noteq> Object\n  P \\<turnstile> DD' has_fields FDTs'\n  FDTs = map (\\<lambda>(F, y). ((F, D), y)) fs @ FDTs'\n\ngoal (1 subgoal):\n 1. (DD' = D' &&& rest = (fs, ms)) &&&\n    P \\<turnstile> D' has_fields FDTs' &&&\n    FDTs = map (\\<lambda>(F, Tm). ((F, D), Tm)) fs @ FDTs'", "by auto"], ["proof (state)\nthis:\n  DD' = D'\n  rest = (fs, ms)\n  P \\<turnstile> D' has_fields FDTs'\n  FDTs = map (\\<lambda>(F, Tm). ((F, D), Tm)) fs @ FDTs'\n\ngoal (1 subgoal):\n 1. \\<And>D fs ms FDTsa.\n       \\<lbrakk>class P D = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        D \\<noteq> Object; P \\<turnstile> D has_fields FDTsa;\n        FDTs = map (\\<lambda>(F, y). ((F, D), y)) fs @ FDTsa\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> D' has F:T (fm) in E", "from FDTs FE DnE hasf'"], ["proof (chain)\npicking this:\n  FDTs = map (\\<lambda>(F, Tm). ((F, D), Tm)) fs @ FDTs'\n  map_of FDTs (F, E) = \\<lfloor>(T, fm)\\<rfloor>\n  D \\<noteq> E\n  P \\<turnstile> D' has_fields FDTs'", "show ?thesis"], ["proof (prove)\nusing this:\n  FDTs = map (\\<lambda>(F, Tm). ((F, D), Tm)) fs @ FDTs'\n  map_of FDTs (F, E) = \\<lfloor>(T, fm)\\<rfloor>\n  D \\<noteq> E\n  P \\<turnstile> D' has_fields FDTs'\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D' has F:T (fm) in E", "by(auto dest: map_of_SomeD simp add: has_field_def)"], ["proof (state)\nthis:\n  P \\<turnstile> D' has F:T (fm) in E\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P \\<turnstile> D' has F:T (fm) in E\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_has_field_idemp:\n  \"\\<lbrakk> wf_prog wf_md P; P \\<turnstile> C has F:T (fm) in D \\<rbrakk> \\<Longrightarrow> P \\<turnstile> D has F:T (fm) in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; P \\<turnstile> C has F:T (fm) in D\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> D has F:T (fm) in D", "apply(frule has_field_decl_above)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; P \\<turnstile> C has F:T (fm) in D;\n     P \\<turnstile> C \\<preceq>\\<^sup>* D\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> D has F:T (fm) in D", "apply(erule (2) wf_has_field_mono2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C has F:T (fm) in D;\n     P \\<turnstile> C \\<preceq>\\<^sup>* D\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> D \\<preceq>\\<^sup>* D", "apply(rule rtranclp.rtrancl_refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_of_remap_conv:\n  \"\\<lbrakk> distinct_fst fs; map_of (map (\\<lambda>(F, y). ((F, D), y)) fs) (F, D) = \\<lfloor>T\\<rfloor> \\<rbrakk>\n  \\<Longrightarrow> map_of (map (\\<lambda>((F, D), T). (F, D, T)) (map (\\<lambda>(F, y). ((F, D), y)) fs)) F = \\<lfloor>(D, T)\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct_fst fs;\n     map_of (map (\\<lambda>(F, y). ((F, D), y)) fs) (F, D) =\n     \\<lfloor>T\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map (\\<lambda>((F, D), T). (F, D, T))\n                         (map (\\<lambda>(F, y). ((F, D), y)) fs))\n                       F =\n                      \\<lfloor>(D, T)\\<rfloor>", "apply(induct fs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct_fst [];\n     map_of (map (\\<lambda>(F, y). ((F, D), y)) []) (F, D) =\n     \\<lfloor>T\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map (\\<lambda>((F, D), T). (F, D, T))\n                         (map (\\<lambda>(F, y). ((F, D), y)) []))\n                       F =\n                      \\<lfloor>(D, T)\\<rfloor>\n 2. \\<And>a fs.\n       \\<lbrakk>\\<lbrakk>distinct_fst fs;\n                 map_of (map (\\<lambda>(F, y). ((F, D), y)) fs) (F, D) =\n                 \\<lfloor>T\\<rfloor>\\<rbrakk>\n                \\<Longrightarrow> map_of\n                                   (map (\\<lambda>((F, D), T). (F, D, T))\n                                     (map (\\<lambda>(F, y). ((F, D), y))\n fs))\n                                   F =\n                                  \\<lfloor>(D, T)\\<rfloor>;\n        distinct_fst (a # fs);\n        map_of (map (\\<lambda>(F, y). ((F, D), y)) (a # fs)) (F, D) =\n        \\<lfloor>T\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (map (\\<lambda>((F, D), T). (F, D, T))\n                            (map (\\<lambda>(F, y). ((F, D), y)) (a # fs)))\n                          F =\n                         \\<lfloor>(D, T)\\<rfloor>", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma has_field_idemp_sees_field:\n  assumes wf: \"wf_prog wf_md P\"\n  and has: \"P \\<turnstile> D has F:T (fm) in D\"\n  shows \"P \\<turnstile> D sees F:T (fm) in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> D sees F:T (fm) in D", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<turnstile> D sees F:T (fm) in D", "from has"], ["proof (chain)\npicking this:\n  P \\<turnstile> D has F:T (fm) in D", "obtain FDTs where hasf: \"P \\<turnstile> D has_fields FDTs\"\n    and FD: \"map_of FDTs (F, D) = \\<lfloor>(T, fm)\\<rfloor>\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D has F:T (fm) in D\n\ngoal (1 subgoal):\n 1. (\\<And>FDTs.\n        \\<lbrakk>P \\<turnstile> D has_fields FDTs;\n         map_of FDTs (F, D) = \\<lfloor>(T, fm)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding has_field_def"], ["proof (prove)\nusing this:\n  \\<exists>FDTs.\n     P \\<turnstile> D has_fields FDTs \\<and>\n     map_of FDTs (F, D) = \\<lfloor>(T, fm)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>FDTs.\n        \\<lbrakk>P \\<turnstile> D has_fields FDTs;\n         map_of FDTs (F, D) = \\<lfloor>(T, fm)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  P \\<turnstile> D has_fields FDTs\n  map_of FDTs (F, D) = \\<lfloor>(T, fm)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D sees F:T (fm) in D", "from hasf"], ["proof (chain)\npicking this:\n  P \\<turnstile> D has_fields FDTs", "have \"map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs) F = \\<lfloor>(D, T, fm)\\<rfloor>\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D has_fields FDTs\n\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs) F =\n    \\<lfloor>(D, T, fm)\\<rfloor>", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Da fs ms FDTsa.\n       \\<lbrakk>class P D = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        D \\<noteq> Object; P \\<turnstile> Da has_fields FDTsa;\n        FDTs = map (\\<lambda>(F, y). ((F, D), y)) fs @ FDTsa\\<rbrakk>\n       \\<Longrightarrow> map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs)\n                          F =\n                         \\<lfloor>(D, T, fm)\\<rfloor>\n 2. \\<And>Da fs ms.\n       \\<lbrakk>D = Object; class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, y). ((F, Object), y)) fs\\<rbrakk>\n       \\<Longrightarrow> map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs)\n                          F =\n                         \\<lfloor>(D, T, fm)\\<rfloor>", "case (has_fields_Object D' fs ms)"], ["proof (state)\nthis:\n  D = Object\n  class P Object = \\<lfloor>(D', fs, ms)\\<rfloor>\n  FDTs = map (\\<lambda>(F, y). ((F, Object), y)) fs\n\ngoal (2 subgoals):\n 1. \\<And>Da fs ms FDTsa.\n       \\<lbrakk>class P D = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        D \\<noteq> Object; P \\<turnstile> Da has_fields FDTsa;\n        FDTs = map (\\<lambda>(F, y). ((F, D), y)) fs @ FDTsa\\<rbrakk>\n       \\<Longrightarrow> map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs)\n                          F =\n                         \\<lfloor>(D, T, fm)\\<rfloor>\n 2. \\<And>Da fs ms.\n       \\<lbrakk>D = Object; class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, y). ((F, Object), y)) fs\\<rbrakk>\n       \\<Longrightarrow> map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs)\n                          F =\n                         \\<lfloor>(D, T, fm)\\<rfloor>", "from \\<open>class P Object = \\<lfloor>(D', fs, ms)\\<rfloor>\\<close> wf"], ["proof (chain)\npicking this:\n  class P Object = \\<lfloor>(D', fs, ms)\\<rfloor>\n  wf_prog wf_md P", "have \"wf_cdecl wf_md P (Object, D', fs, ms)\""], ["proof (prove)\nusing this:\n  class P Object = \\<lfloor>(D', fs, ms)\\<rfloor>\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. wf_cdecl wf_md P (Object, D', fs, ms)", "by(rule class_wf)"], ["proof (state)\nthis:\n  wf_cdecl wf_md P (Object, D', fs, ms)\n\ngoal (2 subgoals):\n 1. \\<And>Da fs ms FDTsa.\n       \\<lbrakk>class P D = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        D \\<noteq> Object; P \\<turnstile> Da has_fields FDTsa;\n        FDTs = map (\\<lambda>(F, y). ((F, D), y)) fs @ FDTsa\\<rbrakk>\n       \\<Longrightarrow> map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs)\n                          F =\n                         \\<lfloor>(D, T, fm)\\<rfloor>\n 2. \\<And>Da fs ms.\n       \\<lbrakk>D = Object; class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, y). ((F, Object), y)) fs\\<rbrakk>\n       \\<Longrightarrow> map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs)\n                          F =\n                         \\<lfloor>(D, T, fm)\\<rfloor>", "hence \"distinct_fst fs\""], ["proof (prove)\nusing this:\n  wf_cdecl wf_md P (Object, D', fs, ms)\n\ngoal (1 subgoal):\n 1. distinct_fst fs", "by(simp add: wf_cdecl_def)"], ["proof (state)\nthis:\n  distinct_fst fs\n\ngoal (2 subgoals):\n 1. \\<And>Da fs ms FDTsa.\n       \\<lbrakk>class P D = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        D \\<noteq> Object; P \\<turnstile> Da has_fields FDTsa;\n        FDTs = map (\\<lambda>(F, y). ((F, D), y)) fs @ FDTsa\\<rbrakk>\n       \\<Longrightarrow> map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs)\n                          F =\n                         \\<lfloor>(D, T, fm)\\<rfloor>\n 2. \\<And>Da fs ms.\n       \\<lbrakk>D = Object; class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, y). ((F, Object), y)) fs\\<rbrakk>\n       \\<Longrightarrow> map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs)\n                          F =\n                         \\<lfloor>(D, T, fm)\\<rfloor>", "with FD has_fields_Object"], ["proof (chain)\npicking this:\n  map_of FDTs (F, D) = \\<lfloor>(T, fm)\\<rfloor>\n  D = Object\n  class P Object = \\<lfloor>(D', fs, ms)\\<rfloor>\n  FDTs = map (\\<lambda>(F, y). ((F, Object), y)) fs\n  distinct_fst fs", "show ?thesis"], ["proof (prove)\nusing this:\n  map_of FDTs (F, D) = \\<lfloor>(T, fm)\\<rfloor>\n  D = Object\n  class P Object = \\<lfloor>(D', fs, ms)\\<rfloor>\n  FDTs = map (\\<lambda>(F, y). ((F, Object), y)) fs\n  distinct_fst fs\n\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs) F =\n    \\<lfloor>(D, T, fm)\\<rfloor>", "by(auto intro: map_of_remap_conv simp del: map_map)"], ["proof (state)\nthis:\n  map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs) F =\n  \\<lfloor>(D, T, fm)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>Da fs ms FDTsa.\n       \\<lbrakk>class P D = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        D \\<noteq> Object; P \\<turnstile> Da has_fields FDTsa;\n        FDTs = map (\\<lambda>(F, y). ((F, D), y)) fs @ FDTsa\\<rbrakk>\n       \\<Longrightarrow> map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs)\n                          F =\n                         \\<lfloor>(D, T, fm)\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Da fs ms FDTsa.\n       \\<lbrakk>class P D = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        D \\<noteq> Object; P \\<turnstile> Da has_fields FDTsa;\n        FDTs = map (\\<lambda>(F, y). ((F, D), y)) fs @ FDTsa\\<rbrakk>\n       \\<Longrightarrow> map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs)\n                          F =\n                         \\<lfloor>(D, T, fm)\\<rfloor>", "case (has_fields_rec D' fs ms FDTs')"], ["proof (state)\nthis:\n  class P D = \\<lfloor>(D', fs, ms)\\<rfloor>\n  D \\<noteq> Object\n  P \\<turnstile> D' has_fields FDTs'\n  FDTs = map (\\<lambda>(F, y). ((F, D), y)) fs @ FDTs'\n\ngoal (1 subgoal):\n 1. \\<And>Da fs ms FDTsa.\n       \\<lbrakk>class P D = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        D \\<noteq> Object; P \\<turnstile> Da has_fields FDTsa;\n        FDTs = map (\\<lambda>(F, y). ((F, D), y)) fs @ FDTsa\\<rbrakk>\n       \\<Longrightarrow> map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs)\n                          F =\n                         \\<lfloor>(D, T, fm)\\<rfloor>", "hence [simp]: \"FDTs = map (\\<lambda>(F, Tm). ((F, D), Tm)) fs @ FDTs'\"\n      and classD: \"class P D = \\<lfloor>(D', fs, ms)\\<rfloor>\" and DnObj: \"D \\<noteq> Object\"\n      and hasf': \"P \\<turnstile> D' has_fields FDTs'\""], ["proof (prove)\nusing this:\n  class P D = \\<lfloor>(D', fs, ms)\\<rfloor>\n  D \\<noteq> Object\n  P \\<turnstile> D' has_fields FDTs'\n  FDTs = map (\\<lambda>(F, y). ((F, D), y)) fs @ FDTs'\n\ngoal (1 subgoal):\n 1. (FDTs = map (\\<lambda>(F, Tm). ((F, D), Tm)) fs @ FDTs' &&&\n     class P D = \\<lfloor>(D', fs, ms)\\<rfloor>) &&&\n    D \\<noteq> Object &&& P \\<turnstile> D' has_fields FDTs'", "by auto"], ["proof (state)\nthis:\n  FDTs = map (\\<lambda>(F, Tm). ((F, D), Tm)) fs @ FDTs'\n  class P D = \\<lfloor>(D', fs, ms)\\<rfloor>\n  D \\<noteq> Object\n  P \\<turnstile> D' has_fields FDTs'\n\ngoal (1 subgoal):\n 1. \\<And>Da fs ms FDTsa.\n       \\<lbrakk>class P D = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        D \\<noteq> Object; P \\<turnstile> Da has_fields FDTsa;\n        FDTs = map (\\<lambda>(F, y). ((F, D), y)) fs @ FDTsa\\<rbrakk>\n       \\<Longrightarrow> map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs)\n                          F =\n                         \\<lfloor>(D, T, fm)\\<rfloor>", "from \\<open>class P D = \\<lfloor>(D', fs, ms)\\<rfloor>\\<close> wf"], ["proof (chain)\npicking this:\n  class P D = \\<lfloor>(D', fs, ms)\\<rfloor>\n  wf_prog wf_md P", "have \"wf_cdecl wf_md P (D, D', fs, ms)\""], ["proof (prove)\nusing this:\n  class P D = \\<lfloor>(D', fs, ms)\\<rfloor>\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. wf_cdecl wf_md P (D, D', fs, ms)", "by(rule class_wf)"], ["proof (state)\nthis:\n  wf_cdecl wf_md P (D, D', fs, ms)\n\ngoal (1 subgoal):\n 1. \\<And>Da fs ms FDTsa.\n       \\<lbrakk>class P D = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        D \\<noteq> Object; P \\<turnstile> Da has_fields FDTsa;\n        FDTs = map (\\<lambda>(F, y). ((F, D), y)) fs @ FDTsa\\<rbrakk>\n       \\<Longrightarrow> map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs)\n                          F =\n                         \\<lfloor>(D, T, fm)\\<rfloor>", "hence \"distinct_fst fs\""], ["proof (prove)\nusing this:\n  wf_cdecl wf_md P (D, D', fs, ms)\n\ngoal (1 subgoal):\n 1. distinct_fst fs", "by(simp add: wf_cdecl_def)"], ["proof (state)\nthis:\n  distinct_fst fs\n\ngoal (1 subgoal):\n 1. \\<And>Da fs ms FDTsa.\n       \\<lbrakk>class P D = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        D \\<noteq> Object; P \\<turnstile> Da has_fields FDTsa;\n        FDTs = map (\\<lambda>(F, y). ((F, D), y)) fs @ FDTsa\\<rbrakk>\n       \\<Longrightarrow> map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs)\n                          F =\n                         \\<lfloor>(D, T, fm)\\<rfloor>", "moreover"], ["proof (state)\nthis:\n  distinct_fst fs\n\ngoal (1 subgoal):\n 1. \\<And>Da fs ms FDTsa.\n       \\<lbrakk>class P D = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        D \\<noteq> Object; P \\<turnstile> Da has_fields FDTsa;\n        FDTs = map (\\<lambda>(F, y). ((F, D), y)) fs @ FDTsa\\<rbrakk>\n       \\<Longrightarrow> map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs)\n                          F =\n                         \\<lfloor>(D, T, fm)\\<rfloor>", "have \"map_of FDTs' (F, D) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of FDTs' (F, D) = None", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of FDTs' (F, D) \\<noteq> None \\<Longrightarrow> False", "assume \"map_of FDTs' (F, D) \\<noteq> None\""], ["proof (state)\nthis:\n  map_of FDTs' (F, D) \\<noteq> None\n\ngoal (1 subgoal):\n 1. map_of FDTs' (F, D) \\<noteq> None \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  map_of FDTs' (F, D) \\<noteq> None", "obtain T' fm' where \"map_of FDTs' (F, D) = \\<lfloor>(T', fm')\\<rfloor>\""], ["proof (prove)\nusing this:\n  map_of FDTs' (F, D) \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>T' fm'.\n        map_of FDTs' (F, D) = \\<lfloor>(T', fm')\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto)"], ["proof (state)\nthis:\n  map_of FDTs' (F, D) = \\<lfloor>(T', fm')\\<rfloor>\n\ngoal (1 subgoal):\n 1. map_of FDTs' (F, D) \\<noteq> None \\<Longrightarrow> False", "with hasf'"], ["proof (chain)\npicking this:\n  P \\<turnstile> D' has_fields FDTs'\n  map_of FDTs' (F, D) = \\<lfloor>(T', fm')\\<rfloor>", "have \"P \\<turnstile> D' \\<preceq>\\<^sup>* D\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D' has_fields FDTs'\n  map_of FDTs' (F, D) = \\<lfloor>(T', fm')\\<rfloor>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D' \\<preceq>\\<^sup>* D", "by(auto dest!: map_of_SomeD intro: has_fields_decl_above)"], ["proof (state)\nthis:\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. map_of FDTs' (F, D) \\<noteq> None \\<Longrightarrow> False", "with classD DnObj"], ["proof (chain)\npicking this:\n  class P D = \\<lfloor>(D', fs, ms)\\<rfloor>\n  D \\<noteq> Object\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D", "have \"(subcls1 P)^++ D D\""], ["proof (prove)\nusing this:\n  class P D = \\<lfloor>(D', fs, ms)\\<rfloor>\n  D \\<noteq> Object\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. (subcls1 P)\\<^sup>+\\<^sup>+ D D", "by(auto intro: subcls1.intros rtranclp_into_tranclp2)"], ["proof (state)\nthis:\n  (subcls1 P)\\<^sup>+\\<^sup>+ D D\n\ngoal (1 subgoal):\n 1. map_of FDTs' (F, D) \\<noteq> None \\<Longrightarrow> False", "with wf"], ["proof (chain)\npicking this:\n  wf_prog wf_md P\n  (subcls1 P)\\<^sup>+\\<^sup>+ D D", "show False"], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  (subcls1 P)\\<^sup>+\\<^sup>+ D D\n\ngoal (1 subgoal):\n 1. False", "by(auto dest: subcls_irrefl)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_of FDTs' (F, D) = None\n\ngoal (1 subgoal):\n 1. \\<And>Da fs ms FDTsa.\n       \\<lbrakk>class P D = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        D \\<noteq> Object; P \\<turnstile> Da has_fields FDTsa;\n        FDTs = map (\\<lambda>(F, y). ((F, D), y)) fs @ FDTsa\\<rbrakk>\n       \\<Longrightarrow> map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs)\n                          F =\n                         \\<lfloor>(D, T, fm)\\<rfloor>", "ultimately"], ["proof (chain)\npicking this:\n  distinct_fst fs\n  map_of FDTs' (F, D) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct_fst fs\n  map_of FDTs' (F, D) = None\n\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs) F =\n    \\<lfloor>(D, T, fm)\\<rfloor>", "using FD hasf'"], ["proof (prove)\nusing this:\n  distinct_fst fs\n  map_of FDTs' (F, D) = None\n  map_of FDTs (F, D) = \\<lfloor>(T, fm)\\<rfloor>\n  P \\<turnstile> D' has_fields FDTs'\n\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs) F =\n    \\<lfloor>(D, T, fm)\\<rfloor>", "by(auto simp add: map_add_Some_iff intro: map_of_remap_conv simp del: map_map)"], ["proof (state)\nthis:\n  map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs) F =\n  \\<lfloor>(D, T, fm)\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs) F =\n  \\<lfloor>(D, T, fm)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D sees F:T (fm) in D", "with hasf"], ["proof (chain)\npicking this:\n  P \\<turnstile> D has_fields FDTs\n  map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs) F =\n  \\<lfloor>(D, T, fm)\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> D has_fields FDTs\n  map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs) F =\n  \\<lfloor>(D, T, fm)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D sees F:T (fm) in D", "unfolding sees_field_def"], ["proof (prove)\nusing this:\n  P \\<turnstile> D has_fields FDTs\n  map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs) F =\n  \\<lfloor>(D, T, fm)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>FDTs.\n       P \\<turnstile> D has_fields FDTs \\<and>\n       map_of (map (\\<lambda>((F, D), Tm). (F, D, Tm)) FDTs) F =\n       \\<lfloor>(D, T, fm)\\<rfloor>", "by blast"], ["proof (state)\nthis:\n  P \\<turnstile> D sees F:T (fm) in D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma has_fields_distinct:\n  assumes wf: \"wf_prog wf_md P\"\n  and \"P \\<turnstile> C has_fields FDTs\"\n  shows \"distinct (map fst FDTs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst FDTs)", "using \\<open>P \\<turnstile> C has_fields FDTs\\<close>"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. distinct (map fst FDTs)", "proof(induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        distinct (map fst FDTs);\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst FDTs')\n 2. \\<And>D fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst FDTs)", "case (has_fields_Object D fs ms FDTs)"], ["proof (state)\nthis:\n  class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs\n\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        distinct (map fst FDTs);\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst FDTs')\n 2. \\<And>D fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst FDTs)", "have eq: \"map (fst \\<circ> (\\<lambda>(F, y). ((F, Object), y))) fs = map ((\\<lambda>F. (F, Object)) \\<circ> fst) fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (fst \\<circ> (\\<lambda>(F, y). ((F, Object), y))) fs =\n    map ((\\<lambda>F. (F, Object)) \\<circ> fst) fs", "by(auto)"], ["proof (state)\nthis:\n  map (fst \\<circ> (\\<lambda>(F, y). ((F, Object), y))) fs =\n  map ((\\<lambda>F. (F, Object)) \\<circ> fst) fs\n\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        distinct (map fst FDTs);\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst FDTs')\n 2. \\<And>D fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst FDTs)", "from \\<open>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>\\<close> wf"], ["proof (chain)\npicking this:\n  class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  wf_prog wf_md P", "have \"wf_cdecl wf_md P (Object, D, fs, ms)\""], ["proof (prove)\nusing this:\n  class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. wf_cdecl wf_md P (Object, D, fs, ms)", "by(rule class_wf)"], ["proof (state)\nthis:\n  wf_cdecl wf_md P (Object, D, fs, ms)\n\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        distinct (map fst FDTs);\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst FDTs')\n 2. \\<And>D fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst FDTs)", "hence \"distinct (map fst fs)\""], ["proof (prove)\nusing this:\n  wf_cdecl wf_md P (Object, D, fs, ms)\n\ngoal (1 subgoal):\n 1. distinct (map fst fs)", "by(simp add: wf_cdecl_def distinct_fst_def)"], ["proof (state)\nthis:\n  distinct (map fst fs)\n\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        distinct (map fst FDTs);\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst FDTs')\n 2. \\<And>D fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst FDTs)", "hence \"distinct (map (fst \\<circ> (\\<lambda>(F, y). ((F, Object), y))) fs)\""], ["proof (prove)\nusing this:\n  distinct (map fst fs)\n\ngoal (1 subgoal):\n 1. distinct (map (fst \\<circ> (\\<lambda>(F, y). ((F, Object), y))) fs)", "unfolding eq distinct_map"], ["proof (prove)\nusing this:\n  distinct fs \\<and> inj_on fst (set fs)\n\ngoal (1 subgoal):\n 1. distinct fs \\<and>\n    inj_on ((\\<lambda>F. (F, Object)) \\<circ> fst) (set fs)", "by(auto intro: comp_inj_on inj_onI)"], ["proof (state)\nthis:\n  distinct (map (fst \\<circ> (\\<lambda>(F, y). ((F, Object), y))) fs)\n\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        distinct (map fst FDTs);\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst FDTs')\n 2. \\<And>D fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst FDTs)", "thus ?case"], ["proof (prove)\nusing this:\n  distinct (map (fst \\<circ> (\\<lambda>(F, y). ((F, Object), y))) fs)\n\ngoal (1 subgoal):\n 1. distinct (map fst FDTs)", "using \\<open>FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs\\<close>"], ["proof (prove)\nusing this:\n  distinct (map (fst \\<circ> (\\<lambda>(F, y). ((F, Object), y))) fs)\n  FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs\n\ngoal (1 subgoal):\n 1. distinct (map fst FDTs)", "by(simp)"], ["proof (state)\nthis:\n  distinct (map fst FDTs)\n\ngoal (1 subgoal):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        distinct (map fst FDTs);\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst FDTs')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        distinct (map fst FDTs);\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst FDTs')", "case (has_fields_rec C D fs ms FDTs FDTs')"], ["proof (state)\nthis:\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C \\<noteq> Object\n  P \\<turnstile> D has_fields FDTs\n  distinct (map fst FDTs)\n  FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs\n\ngoal (1 subgoal):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        distinct (map fst FDTs);\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst FDTs')", "have eq: \"map (fst \\<circ> (\\<lambda>(F, y). ((F, C), y))) fs = map ((\\<lambda>F. (F, C)) \\<circ> fst) fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (fst \\<circ> (\\<lambda>(F, y). ((F, C), y))) fs =\n    map ((\\<lambda>F. (F, C)) \\<circ> fst) fs", "by(auto)"], ["proof (state)\nthis:\n  map (fst \\<circ> (\\<lambda>(F, y). ((F, C), y))) fs =\n  map ((\\<lambda>F. (F, C)) \\<circ> fst) fs\n\ngoal (1 subgoal):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        distinct (map fst FDTs);\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst FDTs')", "from \\<open>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\\<close> wf"], ["proof (chain)\npicking this:\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  wf_prog wf_md P", "have \"wf_cdecl wf_md P (C, D, fs, ms)\""], ["proof (prove)\nusing this:\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. wf_cdecl wf_md P (C, D, fs, ms)", "by(rule class_wf)"], ["proof (state)\nthis:\n  wf_cdecl wf_md P (C, D, fs, ms)\n\ngoal (1 subgoal):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        distinct (map fst FDTs);\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst FDTs')", "hence \"distinct (map fst fs)\""], ["proof (prove)\nusing this:\n  wf_cdecl wf_md P (C, D, fs, ms)\n\ngoal (1 subgoal):\n 1. distinct (map fst fs)", "by(simp add: wf_cdecl_def distinct_fst_def)"], ["proof (state)\nthis:\n  distinct (map fst fs)\n\ngoal (1 subgoal):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        distinct (map fst FDTs);\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst FDTs')", "hence \"distinct (map (fst \\<circ> (\\<lambda>(F, y). ((F, C), y))) fs)\""], ["proof (prove)\nusing this:\n  distinct (map fst fs)\n\ngoal (1 subgoal):\n 1. distinct (map (fst \\<circ> (\\<lambda>(F, y). ((F, C), y))) fs)", "unfolding eq distinct_map"], ["proof (prove)\nusing this:\n  distinct fs \\<and> inj_on fst (set fs)\n\ngoal (1 subgoal):\n 1. distinct fs \\<and> inj_on ((\\<lambda>F. (F, C)) \\<circ> fst) (set fs)", "by(auto intro: comp_inj_on inj_onI)"], ["proof (state)\nthis:\n  distinct (map (fst \\<circ> (\\<lambda>(F, y). ((F, C), y))) fs)\n\ngoal (1 subgoal):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        distinct (map fst FDTs);\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst FDTs')", "moreover"], ["proof (state)\nthis:\n  distinct (map (fst \\<circ> (\\<lambda>(F, y). ((F, C), y))) fs)\n\ngoal (1 subgoal):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        distinct (map fst FDTs);\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst FDTs')", "from \\<open>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\\<close> \\<open>C \\<noteq> Object\\<close>"], ["proof (chain)\npicking this:\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C \\<noteq> Object", "have \"P \\<turnstile> C \\<prec>\\<^sup>1 D\""], ["proof (prove)\nusing this:\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C \\<noteq> Object\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C \\<prec>\\<^sup>1 D", "by(rule subcls1.intros)"], ["proof (state)\nthis:\n  P \\<turnstile> C \\<prec>\\<^sup>1 D\n\ngoal (1 subgoal):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        distinct (map fst FDTs);\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst FDTs')", "with \\<open>P \\<turnstile> D has_fields FDTs\\<close>"], ["proof (chain)\npicking this:\n  P \\<turnstile> D has_fields FDTs\n  P \\<turnstile> C \\<prec>\\<^sup>1 D", "have \"(fst \\<circ> (\\<lambda>(F, y). ((F, C), y))) ` set fs \\<inter> fst ` set FDTs = {}\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D has_fields FDTs\n  P \\<turnstile> C \\<prec>\\<^sup>1 D\n\ngoal (1 subgoal):\n 1. (fst \\<circ> (\\<lambda>(F, y). ((F, C), y))) ` set fs \\<inter>\n    fst ` set FDTs =\n    {}", "by(auto dest: subcls_notin_has_fields)"], ["proof (state)\nthis:\n  (fst \\<circ> (\\<lambda>(F, y). ((F, C), y))) ` set fs \\<inter>\n  fst ` set FDTs =\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        distinct (map fst FDTs);\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst FDTs')", "ultimately"], ["proof (chain)\npicking this:\n  distinct (map (fst \\<circ> (\\<lambda>(F, y). ((F, C), y))) fs)\n  (fst \\<circ> (\\<lambda>(F, y). ((F, C), y))) ` set fs \\<inter>\n  fst ` set FDTs =\n  {}", "show ?case"], ["proof (prove)\nusing this:\n  distinct (map (fst \\<circ> (\\<lambda>(F, y). ((F, C), y))) fs)\n  (fst \\<circ> (\\<lambda>(F, y). ((F, C), y))) ` set fs \\<inter>\n  fst ` set FDTs =\n  {}\n\ngoal (1 subgoal):\n 1. distinct (map fst FDTs')", "using \\<open>FDTs' = map (\\<lambda>(F, T). ((F, C), T)) fs @ FDTs\\<close> \\<open>distinct (map fst FDTs)\\<close>"], ["proof (prove)\nusing this:\n  distinct (map (fst \\<circ> (\\<lambda>(F, y). ((F, C), y))) fs)\n  (fst \\<circ> (\\<lambda>(F, y). ((F, C), y))) ` set fs \\<inter>\n  fst ` set FDTs =\n  {}\n  FDTs' = map (\\<lambda>(F, T). ((F, C), T)) fs @ FDTs\n  distinct (map fst FDTs)\n\ngoal (1 subgoal):\n 1. distinct (map fst FDTs')", "by simp"], ["proof (state)\nthis:\n  distinct (map fst FDTs')\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Code generation\\<close>"], ["", "code_pred\n  (modes: i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> bool)\n  [inductify]\n  wf_overriding"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text \\<open>\n  Separate subclass acycilicity from class declaration check.\n  Otherwise, cyclic class hierarchies might lead to non-termination\n  as @{term \"Methods\"} recurses over the class hierarchy.\n\\<close>"], ["", "definition acyclic_class_hierarchy :: \"'m prog \\<Rightarrow> bool\"\nwhere\n  \"acyclic_class_hierarchy P \\<longleftrightarrow> \n  (\\<forall>(C, D, fs, ml) \\<in> set (classes P). C \\<noteq> Object \\<longrightarrow> \\<not> P \\<turnstile> D \\<preceq>\\<^sup>* C)\""], ["", "definition wf_cdecl' :: \"'m wf_mdecl_test \\<Rightarrow> 'm prog \\<Rightarrow> 'm cdecl \\<Rightarrow> bool\"\nwhere\n  \"wf_cdecl' wf_md P = (\\<lambda>(C,(D,fs,ms)).\n  (\\<forall>f\\<in>set fs. wf_fdecl P f) \\<and> distinct_fst fs \\<and>\n  (\\<forall>m\\<in>set ms. wf_mdecl wf_md P C m) \\<and>\n  distinct_fst ms \\<and>\n  (C \\<noteq> Object \\<longrightarrow> is_class P D \\<and> (\\<forall>m\\<in>set ms. wf_overriding P D m)) \\<and>\n  (C = Thread \\<longrightarrow> (\\<exists>m. (run, [], Void, m) \\<in> set ms)))\""], ["", "lemma acyclic_class_hierarchy_code [code]:\n  \"acyclic_class_hierarchy P \\<longleftrightarrow> (\\<forall>(C, D, fs, ml) \\<in> set (classes P). C \\<noteq> Object \\<longrightarrow> \\<not> subcls' P D C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_class_hierarchy P =\n    (\\<forall>(C, D, fs, ml)\\<in>set (classes P).\n        C \\<noteq> Object \\<longrightarrow> \\<not> subcls' P D C)", "by(simp add: acyclic_class_hierarchy_def subcls'_def)"], ["", "lemma wf_cdecl'_code [code]:\n  \"wf_cdecl' wf_md P = (\\<lambda>(C,(D,fs,ms)).\n  (\\<forall>f\\<in>set fs. wf_fdecl P f) \\<and>  distinct_fst fs \\<and>\n  (\\<forall>m\\<in>set ms. wf_mdecl wf_md P C m) \\<and>\n  distinct_fst ms \\<and>\n  (C \\<noteq> Object \\<longrightarrow> is_class P D \\<and> (\\<forall>m\\<in>set ms. wf_overriding P D m)) \\<and>\n  (C = Thread \\<longrightarrow> ((run, [], Void) \\<in> set (map (\\<lambda>(M, Ts, T, b). (M, Ts, T)) ms))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_cdecl' wf_md P =\n    (\\<lambda>(C, D, fs, ms).\n        (\\<forall>f\\<in>set fs. wf_fdecl P f) \\<and>\n        distinct_fst fs \\<and>\n        (\\<forall>m\\<in>set ms. wf_mdecl wf_md P C m) \\<and>\n        distinct_fst ms \\<and>\n        (C \\<noteq> Object \\<longrightarrow>\n         is_class P D \\<and>\n         (\\<forall>m\\<in>set ms. wf_overriding P D m)) \\<and>\n        (C = Thread \\<longrightarrow>\n         (run, [], Void)\n         \\<in> set (map (\\<lambda>(M, Ts, T, b). (M, Ts, T)) ms)))", "by(auto simp add: wf_cdecl'_def intro!: ext intro: rev_image_eqI)"], ["", "declare set_append [symmetric, code_unfold]"], ["", "lemma wf_prog_code [code]:\n  \"wf_prog wf_md P \\<longleftrightarrow>\n   acyclic_class_hierarchy P \\<and>\n   wf_syscls P \\<and> distinct_fst (classes P) \\<and>\n   (\\<forall>c \\<in> set (classes P). wf_cdecl' wf_md P c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_md P =\n    (acyclic_class_hierarchy P \\<and>\n     wf_syscls P \\<and>\n     distinct_fst (classes P) \\<and>\n     (\\<forall>c\\<in>set (classes P). wf_cdecl' wf_md P c))", "unfolding wf_prog_def wf_cdecl_def wf_cdecl'_def acyclic_class_hierarchy_def split_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (wf_syscls P \\<and>\n     distinct_fst (classes P) \\<and>\n     (\\<forall>p\\<in>set (classes P).\n         Ball (set (fst (snd (snd p)))) (wf_fdecl P) \\<and>\n         distinct_fst (fst (snd (snd p))) \\<and>\n         Ball (set (snd (snd (snd p)))) (wf_mdecl wf_md P (fst p)) \\<and>\n         distinct_fst (snd (snd (snd p))) \\<and>\n         (fst p \\<noteq> Object \\<longrightarrow>\n          is_class P (fst (snd p)) \\<and>\n          \\<not> P \\<turnstile> fst (snd p) \\<preceq>\\<^sup>* fst p \\<and>\n          Ball (set (snd (snd (snd p))))\n           (wf_overriding P (fst (snd p)))) \\<and>\n         (fst p = Thread \\<longrightarrow>\n          (\\<exists>m.\n              (run, [], Void, m) \\<in> set (snd (snd (snd p))))))) =\n    ((\\<forall>p\\<in>set (classes P).\n         fst p \\<noteq> Object \\<longrightarrow>\n         \\<not> P \\<turnstile> fst (snd p) \\<preceq>\\<^sup>* fst p) \\<and>\n     wf_syscls P \\<and>\n     distinct_fst (classes P) \\<and>\n     (\\<forall>c\\<in>set (classes P).\n         Ball (set (fst (snd (snd c)))) (wf_fdecl P) \\<and>\n         distinct_fst (fst (snd (snd c))) \\<and>\n         Ball (set (snd (snd (snd c)))) (wf_mdecl wf_md P (fst c)) \\<and>\n         distinct_fst (snd (snd (snd c))) \\<and>\n         (fst c \\<noteq> Object \\<longrightarrow>\n          is_class P (fst (snd c)) \\<and>\n          Ball (set (snd (snd (snd c))))\n           (wf_overriding P (fst (snd c)))) \\<and>\n         (fst c = Thread \\<longrightarrow>\n          (\\<exists>m. (run, [], Void, m) \\<in> set (snd (snd (snd c)))))))", "by blast"], ["", "end"]]}