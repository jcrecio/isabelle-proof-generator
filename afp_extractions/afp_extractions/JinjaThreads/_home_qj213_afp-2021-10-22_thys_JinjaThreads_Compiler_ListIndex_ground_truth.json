{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Compiler/ListIndex.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma [simp]: \"index (xs @ [x]) x = size xs\"", "lemma [simp]: \"(index (xs @ [x]) y = size xs) = (x = y)\"", "lemma [simp]: \"x \\<in> set xs \\<Longrightarrow> xs ! index xs x = x\"", "lemma [simp]: \"x \\<notin> set xs \\<Longrightarrow> index xs x = size xs\"", "lemma index_size_conv[simp]: \"(index xs x = size xs) = (x \\<notin> set xs)\"", "lemma size_index_conv[simp]: \"(size xs = index xs x) = (x \\<notin> set xs)\"", "lemma \"(index xs x < size xs) = (x \\<in> set xs)\"", "lemma [simp]: \"\\<lbrakk> y \\<in> set xs; x \\<noteq> y \\<rbrakk> \\<Longrightarrow> index (xs @ [x]) y = index xs y\"", "lemma index_less_size[simp]: \"x \\<in> set xs \\<Longrightarrow> index xs x < size xs\"", "lemma index_less_aux: \"\\<lbrakk>x \\<in> set xs; size xs \\<le> n\\<rbrakk> \\<Longrightarrow> index xs x < n\"", "lemma [simp]: \"x \\<in> set xs \\<or> y \\<in> set xs \\<Longrightarrow> (index xs x = index xs y) = (x = y)\"", "lemma inj_on_index: \"inj_on (index xs) (set xs)\"", "lemma index_drop: \"\\<And>x i. \\<lbrakk> x \\<in> set xs; index xs x < i \\<rbrakk> \\<Longrightarrow> x \\<notin> set(drop i xs)\"", "lemma hidden_index: \"x \\<in> set xs \\<Longrightarrow> hidden (xs @ [x]) (index xs x)\"", "lemma hidden_inacc: \"hidden xs i \\<Longrightarrow> index xs x \\<noteq> i\"", "lemma [simp]: \"hidden xs i \\<Longrightarrow> hidden (xs@[x]) i\"", "lemma fun_upds_apply: \"\\<And>m ys.\n  (m(xs[\\<mapsto>]ys)) x =\n  (let xs' = take (size ys) xs\n   in if x \\<in> set xs' then Some(ys ! index xs' x) else m x)\"", "lemma map_upds_apply_eq_Some:\n  \"((m(xs[\\<mapsto>]ys)) x = Some y) =\n  (let xs' = take (size ys) xs\n   in if x \\<in> set xs' then ys ! index xs' x = y else m x = Some y)\"", "lemma map_upds_upd_conv_index:\n  \"\\<lbrakk>x \\<in> set xs; size xs \\<le> size ys \\<rbrakk>\n  \\<Longrightarrow> m(xs[\\<mapsto>]ys)(x\\<mapsto>y) = m(xs[\\<mapsto>]ys[index xs x := y])\"", "lemma image_index:\n  \"A \\<subseteq> set(xs@[x]) \\<Longrightarrow> index (xs @ [x]) ` A =\n  (if x \\<in> A then insert (size xs) (index xs ` (A-{x})) else index xs ` A)\"", "lemma index_le_lengthD: \"index xs x < length xs \\<Longrightarrow> x \\<in> set xs\"", "lemma not_hidden_index_nth: \"\\<lbrakk> i < length Vs; \\<not> hidden Vs i \\<rbrakk> \\<Longrightarrow> index Vs (Vs ! i) = i\"", "lemma hidden_snoc_nth:\n  assumes len: \"i < length Vs\"\n  shows \"hidden (Vs @ [Vs ! i]) i\"", "lemma map_upds_Some_eq_nth_index:\n  assumes \"[Vs [\\<mapsto>] vs] V = Some v\" \"length Vs \\<le> length vs\"\n  shows \"vs ! index Vs V = v\""], "translations": [["", "lemma [simp]: \"index (xs @ [x]) x = size xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index (xs @ [x]) x = length xs", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. index (xs @ [x]) x = length xs", "by(induct xs) simp_all"], ["", "(*>*)"], ["", "lemma [simp]: \"(index (xs @ [x]) y = size xs) = (x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (index (xs @ [x]) y = length xs) = (x = y)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (index (xs @ [x]) y = length xs) = (x = y)", "by(induct xs) auto"], ["", "(*>*)"], ["", "lemma [simp]: \"x \\<in> set xs \\<Longrightarrow> xs ! index xs x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> xs ! index xs x = x", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> xs ! index xs x = x", "by(induct xs) auto"], ["", "(*>*)"], ["", "lemma [simp]: \"x \\<notin> set xs \\<Longrightarrow> index xs x = size xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set xs \\<Longrightarrow> index xs x = length xs", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set xs \\<Longrightarrow> index xs x = length xs", "by(induct xs) auto"], ["", "(*>*)"], ["", "lemma index_size_conv[simp]: \"(index xs x = size xs) = (x \\<notin> set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (index xs x = length xs) = (x \\<notin> set xs)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (index xs x = length xs) = (x \\<notin> set xs)", "by(induct xs) auto"], ["", "(*>*)"], ["", "lemma size_index_conv[simp]: \"(size xs = index xs x) = (x \\<notin> set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (length xs = index xs x) = (x \\<notin> set xs)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length xs = index xs x) = (x \\<notin> set xs)", "by(induct xs) auto"], ["", "(*>*)"], ["", "lemma \"(index xs x < size xs) = (x \\<in> set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (index xs x < length xs) = (x \\<in> set xs)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (index xs x < length xs) = (x \\<in> set xs)", "by(induct xs) auto"], ["", "(*>*)"], ["", "lemma [simp]: \"\\<lbrakk> y \\<in> set xs; x \\<noteq> y \\<rbrakk> \\<Longrightarrow> index (xs @ [x]) y = index xs y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> set xs; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> index (xs @ [x]) y = index xs y", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> set xs; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> index (xs @ [x]) y = index xs y", "by(induct xs) auto"], ["", "(*>*)"], ["", "lemma index_less_size[simp]: \"x \\<in> set xs \\<Longrightarrow> index xs x < size xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> index xs x < length xs", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> index xs x < length xs", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> set [] \\<Longrightarrow> index [] x < length []\n 2. \\<And>a xs.\n       \\<lbrakk>x \\<in> set xs \\<Longrightarrow> index xs x < length xs;\n        x \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> index (a # xs) x < length (a # xs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>x \\<in> set xs \\<Longrightarrow> index xs x < length xs;\n        x \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> index (a # xs) x < length (a # xs)", "apply(fastforce)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma index_less_aux: \"\\<lbrakk>x \\<in> set xs; size xs \\<le> n\\<rbrakk> \\<Longrightarrow> index xs x < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set xs; length xs \\<le> n\\<rbrakk>\n    \\<Longrightarrow> index xs x < n", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set xs; length xs \\<le> n\\<rbrakk>\n    \\<Longrightarrow> index xs x < n", "apply(subgoal_tac \"index xs x < size xs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> set xs; length xs \\<le> n;\n     index xs x < length xs\\<rbrakk>\n    \\<Longrightarrow> index xs x < n\n 2. \\<lbrakk>x \\<in> set xs; length xs \\<le> n\\<rbrakk>\n    \\<Longrightarrow> index xs x < length xs", "apply(simp (no_asm_simp))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set xs; length xs \\<le> n\\<rbrakk>\n    \\<Longrightarrow> index xs x < length xs", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma [simp]: \"x \\<in> set xs \\<or> y \\<in> set xs \\<Longrightarrow> (index xs x = index xs y) = (x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<or> y \\<in> set xs \\<Longrightarrow>\n    (index xs x = index xs y) = (x = y)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<or> y \\<in> set xs \\<Longrightarrow>\n    (index xs x = index xs y) = (x = y)", "by (induct xs) auto"], ["", "(*>*)"], ["", "lemma inj_on_index: \"inj_on (index xs) (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (index xs) (set xs)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (index xs) (set xs)", "by(simp add:inj_on_def)"], ["", "(*>*)"], ["", "lemma index_drop: \"\\<And>x i. \\<lbrakk> x \\<in> set xs; index xs x < i \\<rbrakk> \\<Longrightarrow> x \\<notin> set(drop i xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>x \\<in> set xs; index xs x < i\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> set (drop i xs)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>x \\<in> set xs; index xs x < i\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> set (drop i xs)", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x i.\n       \\<lbrakk>x \\<in> set []; index [] x < i\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> set (drop i [])\n 2. \\<And>a xs x i.\n       \\<lbrakk>\\<And>x i.\n                   \\<lbrakk>x \\<in> set xs; index xs x < i\\<rbrakk>\n                   \\<Longrightarrow> x \\<notin> set (drop i xs);\n        x \\<in> set (a # xs); index (a # xs) x < i\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> set (drop i (a # xs))", "apply (auto simp:drop_Cons split:if_split_asm nat.splits dest:in_set_dropD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "subsection \\<open>@{term hidden}\\<close>"], ["", "lemma hidden_index: \"x \\<in> set xs \\<Longrightarrow> hidden (xs @ [x]) (index xs x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> hidden (xs @ [x]) (index xs x)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> hidden (xs @ [x]) (index xs x)", "apply(auto simp add:hidden_def index_less_aux nth_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set xs;\n     x \\<notin> set (drop (Suc (index xs x) - length xs) [x])\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set (drop (Suc (index xs x)) xs)", "apply(drule index_less_size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> set (drop (Suc (index xs x) - length xs) [x]);\n     index xs x < length xs\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set (drop (Suc (index xs x)) xs)", "apply(simp del:index_less_size)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma hidden_inacc: \"hidden xs i \\<Longrightarrow> index xs x \\<noteq> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hidden xs i \\<Longrightarrow> index xs x \\<noteq> i", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hidden xs i \\<Longrightarrow> index xs x \\<noteq> i", "apply(case_tac \"x \\<in> set xs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>hidden xs i; x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> index xs x \\<noteq> i\n 2. \\<lbrakk>hidden xs i; x \\<notin> set xs\\<rbrakk>\n    \\<Longrightarrow> index xs x \\<noteq> i", "apply(auto simp add:hidden_def index_less_aux nth_append index_drop)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma [simp]: \"hidden xs i \\<Longrightarrow> hidden (xs@[x]) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hidden xs i \\<Longrightarrow> hidden (xs @ [x]) i", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hidden xs i \\<Longrightarrow> hidden (xs @ [x]) i", "by(auto simp add:hidden_def nth_append)"], ["", "(*>*)"], ["", "lemma fun_upds_apply: \"\\<And>m ys.\n  (m(xs[\\<mapsto>]ys)) x =\n  (let xs' = take (size ys) xs\n   in if x \\<in> set xs' then Some(ys ! index xs' x) else m x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m ys.\n       (m(xs [\\<mapsto>] ys)) x =\n       (let xs' = take (length ys) xs\n        in if x \\<in> set xs' then Some (ys ! index xs' x) else m x)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m ys.\n       (m(xs [\\<mapsto>] ys)) x =\n       (let xs' = take (length ys) xs\n        in if x \\<in> set xs' then Some (ys ! index xs' x) else m x)", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m ys.\n       (m([] [\\<mapsto>] ys)) x =\n       (let xs' = take (length ys) []\n        in if x \\<in> set xs' then Some (ys ! index xs' x) else m x)\n 2. \\<And>a xs m ys.\n       (\\<And>m ys.\n           (m(xs [\\<mapsto>] ys)) x =\n           (let xs' = take (length ys) xs\n            in if x \\<in> set xs' then Some (ys ! index xs' x)\n               else m x)) \\<Longrightarrow>\n       (m(a # xs [\\<mapsto>] ys)) x =\n       (let xs' = take (length ys) (a # xs)\n        in if x \\<in> set xs' then Some (ys ! index xs' x) else m x)", "apply (simp add:Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs m ys.\n       (\\<And>m ys.\n           (m(xs [\\<mapsto>] ys)) x =\n           (let xs' = take (length ys) xs\n            in if x \\<in> set xs' then Some (ys ! index xs' x)\n               else m x)) \\<Longrightarrow>\n       (m(a # xs [\\<mapsto>] ys)) x =\n       (let xs' = take (length ys) (a # xs)\n        in if x \\<in> set xs' then Some (ys ! index xs' x) else m x)", "apply(case_tac ys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs m ys.\n       \\<lbrakk>\\<And>m ys.\n                   (m(xs [\\<mapsto>] ys)) x =\n                   (let xs' = take (length ys) xs\n                    in if x \\<in> set xs' then Some (ys ! index xs' x)\n                       else m x);\n        ys = []\\<rbrakk>\n       \\<Longrightarrow> (m(a # xs [\\<mapsto>] ys)) x =\n                         (let xs' = take (length ys) (a # xs)\n                          in if x \\<in> set xs' then Some (ys ! index xs' x)\n                             else m x)\n 2. \\<And>a xs m ys aa list.\n       \\<lbrakk>\\<And>m ys.\n                   (m(xs [\\<mapsto>] ys)) x =\n                   (let xs' = take (length ys) xs\n                    in if x \\<in> set xs' then Some (ys ! index xs' x)\n                       else m x);\n        ys = aa # list\\<rbrakk>\n       \\<Longrightarrow> (m(a # xs [\\<mapsto>] ys)) x =\n                         (let xs' = take (length ys) (a # xs)\n                          in if x \\<in> set xs' then Some (ys ! index xs' x)\n                             else m x)", "apply (simp add:Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs m ys aa list.\n       \\<lbrakk>\\<And>m ys.\n                   (m(xs [\\<mapsto>] ys)) x =\n                   (let xs' = take (length ys) xs\n                    in if x \\<in> set xs' then Some (ys ! index xs' x)\n                       else m x);\n        ys = aa # list\\<rbrakk>\n       \\<Longrightarrow> (m(a # xs [\\<mapsto>] ys)) x =\n                         (let xs' = take (length ys) (a # xs)\n                          in if x \\<in> set xs' then Some (ys ! index xs' x)\n                             else m x)", "apply (simp add:Let_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma map_upds_apply_eq_Some:\n  \"((m(xs[\\<mapsto>]ys)) x = Some y) =\n  (let xs' = take (size ys) xs\n   in if x \\<in> set xs' then ys ! index xs' x = y else m x = Some y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((m(xs [\\<mapsto>] ys)) x = Some y) =\n    (let xs' = take (length ys) xs\n     in if x \\<in> set xs' then ys ! index xs' x = y else m x = Some y)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((m(xs [\\<mapsto>] ys)) x = Some y) =\n    (let xs' = take (length ys) xs\n     in if x \\<in> set xs' then ys ! index xs' x = y else m x = Some y)", "by(simp add:fun_upds_apply Let_def)"], ["", "(*>*)"], ["", "lemma map_upds_upd_conv_index:\n  \"\\<lbrakk>x \\<in> set xs; size xs \\<le> size ys \\<rbrakk>\n  \\<Longrightarrow> m(xs[\\<mapsto>]ys)(x\\<mapsto>y) = m(xs[\\<mapsto>]ys[index xs x := y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set xs; length xs \\<le> length ys\\<rbrakk>\n    \\<Longrightarrow> m(xs [\\<mapsto>] ys, x \\<mapsto> y) = m(xs [\\<mapsto>]\n                      ys[index xs x := y])", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set xs; length xs \\<le> length ys\\<rbrakk>\n    \\<Longrightarrow> m(xs [\\<mapsto>] ys, x \\<mapsto> y) = m(xs [\\<mapsto>]\n                      ys[index xs x := y])", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>x \\<in> set xs; length xs \\<le> length ys\\<rbrakk>\n       \\<Longrightarrow> (m(xs [\\<mapsto>] ys, x \\<mapsto> y)) xa =\n                         (m(xs [\\<mapsto>] ys[index xs x := y])) xa", "apply(simp add:fun_upds_apply index_less_aux eq_sym_conv Let_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma image_index:\n  \"A \\<subseteq> set(xs@[x]) \\<Longrightarrow> index (xs @ [x]) ` A =\n  (if x \\<in> A then insert (size xs) (index xs ` (A-{x})) else index xs ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> set (xs @ [x]) \\<Longrightarrow>\n    index (xs @ [x]) ` A =\n    (if x \\<in> A then insert (length xs) (index xs ` (A - {x}))\n     else index xs ` A)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> set (xs @ [x]) \\<Longrightarrow>\n    index (xs @ [x]) ` A =\n    (if x \\<in> A then insert (length xs) (index xs ` (A - {x}))\n     else index xs ` A)", "apply(auto simp:image_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<in> A\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xa\\<in>A. length xs = index (xs @ [x]) xa\n 2. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<in> A; xa \\<in> A;\n        \\<forall>xb\\<in>A. index xs xa \\<noteq> index (xs @ [x]) xb\\<rbrakk>\n       \\<Longrightarrow> xa = x\n 3. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>A.\n                            index (xs @ [x]) xa = index xs xb\n 4. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>A.\n                            index xs xa = index (xs @ [x]) xb", "apply(rule bexI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<in> A\\<rbrakk>\n    \\<Longrightarrow> length xs = index (xs @ [x]) ?x50\n 2. \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<in> A\\<rbrakk>\n    \\<Longrightarrow> ?x50 \\<in> A\n 3. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<in> A; xa \\<in> A;\n        \\<forall>xb\\<in>A. index xs xa \\<noteq> index (xs @ [x]) xb\\<rbrakk>\n       \\<Longrightarrow> xa = x\n 4. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>A.\n                            index (xs @ [x]) xa = index xs xb\n 5. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>A.\n                            index xs xa = index (xs @ [x]) xb", "prefer 2"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<in> A\\<rbrakk>\n    \\<Longrightarrow> ?x50 \\<in> A\n 2. \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<in> A\\<rbrakk>\n    \\<Longrightarrow> length xs = index (xs @ [x]) ?x50\n 3. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<in> A; xa \\<in> A;\n        \\<forall>xb\\<in>A. index xs xa \\<noteq> index (xs @ [x]) xb\\<rbrakk>\n       \\<Longrightarrow> xa = x\n 4. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>A.\n                            index (xs @ [x]) xa = index xs xb\n 5. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>A.\n                            index xs xa = index (xs @ [x]) xb", "apply blast"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<in> A\\<rbrakk>\n    \\<Longrightarrow> length xs = index (xs @ [x]) x\n 2. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<in> A; xa \\<in> A;\n        \\<forall>xb\\<in>A. index xs xa \\<noteq> index (xs @ [x]) xb\\<rbrakk>\n       \\<Longrightarrow> xa = x\n 3. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>A.\n                            index (xs @ [x]) xa = index xs xb\n 4. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>A.\n                            index xs xa = index (xs @ [x]) xb", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<in> A; xa \\<in> A;\n        \\<forall>xb\\<in>A. index xs xa \\<noteq> index (xs @ [x]) xb\\<rbrakk>\n       \\<Longrightarrow> xa = x\n 2. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>A.\n                            index (xs @ [x]) xa = index xs xb\n 3. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>A.\n                            index xs xa = index (xs @ [x]) xb", "apply(rule ccontr)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<in> A; xa \\<in> A;\n        \\<forall>xb\\<in>A. index xs xa \\<noteq> index (xs @ [x]) xb;\n        xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>A.\n                            index (xs @ [x]) xa = index xs xb\n 3. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>A.\n                            index xs xa = index (xs @ [x]) xb", "apply(erule_tac x=xa in ballE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<in> A; xa \\<in> A;\n        xa \\<noteq> x; index xs xa \\<noteq> index (xs @ [x]) xa\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<in> A; xa \\<in> A;\n        xa \\<noteq> x; xa \\<notin> A\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>A.\n                            index (xs @ [x]) xa = index xs xb\n 4. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>A.\n                            index xs xa = index (xs @ [x]) xb", "prefer 2"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<in> A; xa \\<in> A;\n        xa \\<noteq> x; xa \\<notin> A\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<in> A; xa \\<in> A;\n        xa \\<noteq> x; index xs xa \\<noteq> index (xs @ [x]) xa\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>A.\n                            index (xs @ [x]) xa = index xs xb\n 4. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>A.\n                            index xs xa = index (xs @ [x]) xb", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<in> A; xa \\<in> A;\n        xa \\<noteq> x; index xs xa \\<noteq> index (xs @ [x]) xa\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>A.\n                            index (xs @ [x]) xa = index xs xb\n 3. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>A.\n                            index xs xa = index (xs @ [x]) xb", "apply(fastforce simp add:neq_commute)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>A.\n                            index (xs @ [x]) xa = index xs xb\n 2. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>A.\n                            index xs xa = index (xs @ [x]) xb", "apply(subgoal_tac \"x \\<noteq> xa\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A; xa \\<in> A;\n        x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>A.\n                            index (xs @ [x]) xa = index xs xb\n 2. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> xa\n 3. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>A.\n                            index xs xa = index (xs @ [x]) xb", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> xa\n 2. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A; xa \\<in> A;\n        x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>A.\n                            index (xs @ [x]) xa = index xs xb\n 3. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>A.\n                            index xs xa = index (xs @ [x]) xb", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A; xa \\<in> A;\n        x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>A.\n                            index (xs @ [x]) xa = index xs xb\n 2. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>A.\n                            index xs xa = index (xs @ [x]) xb", "apply(fastforce simp add:neq_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>A.\n                            index xs xa = index (xs @ [x]) xb", "apply(subgoal_tac \"x \\<noteq> xa\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A; xa \\<in> A;\n        x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>A.\n                            index xs xa = index (xs @ [x]) xb\n 2. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> xa", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> xa\n 2. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A; xa \\<in> A;\n        x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>A.\n                            index xs xa = index (xs @ [x]) xb", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>A \\<subseteq> insert x (set xs); x \\<notin> A; xa \\<in> A;\n        x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>A.\n                            index xs xa = index (xs @ [x]) xb", "apply(force)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma index_le_lengthD: \"index xs x < length xs \\<Longrightarrow> x \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index xs x < length xs \\<Longrightarrow> x \\<in> set xs", "by(erule contrapos_pp)(simp)"], ["", "lemma not_hidden_index_nth: \"\\<lbrakk> i < length Vs; \\<not> hidden Vs i \\<rbrakk> \\<Longrightarrow> index Vs (Vs ! i) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length Vs; \\<not> hidden Vs i\\<rbrakk>\n    \\<Longrightarrow> index Vs (Vs ! i) = i", "by(induct Vs arbitrary: i)(auto split: if_split_asm nat.split_asm simp add: nth_Cons hidden_def)"], ["", "lemma hidden_snoc_nth:\n  assumes len: \"i < length Vs\"\n  shows \"hidden (Vs @ [Vs ! i]) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hidden (Vs @ [Vs ! i]) i", "proof(cases \"hidden Vs i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. hidden Vs i \\<Longrightarrow> hidden (Vs @ [Vs ! i]) i\n 2. \\<not> hidden Vs i \\<Longrightarrow> hidden (Vs @ [Vs ! i]) i", "case True"], ["proof (state)\nthis:\n  hidden Vs i\n\ngoal (2 subgoals):\n 1. hidden Vs i \\<Longrightarrow> hidden (Vs @ [Vs ! i]) i\n 2. \\<not> hidden Vs i \\<Longrightarrow> hidden (Vs @ [Vs ! i]) i", "thus ?thesis"], ["proof (prove)\nusing this:\n  hidden Vs i\n\ngoal (1 subgoal):\n 1. hidden (Vs @ [Vs ! i]) i", "by simp"], ["proof (state)\nthis:\n  hidden (Vs @ [Vs ! i]) i\n\ngoal (1 subgoal):\n 1. \\<not> hidden Vs i \\<Longrightarrow> hidden (Vs @ [Vs ! i]) i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> hidden Vs i \\<Longrightarrow> hidden (Vs @ [Vs ! i]) i", "case False"], ["proof (state)\nthis:\n  \\<not> hidden Vs i\n\ngoal (1 subgoal):\n 1. \\<not> hidden Vs i \\<Longrightarrow> hidden (Vs @ [Vs ! i]) i", "with len"], ["proof (chain)\npicking this:\n  i < length Vs\n  \\<not> hidden Vs i", "have \"index Vs (Vs ! i) = i\""], ["proof (prove)\nusing this:\n  i < length Vs\n  \\<not> hidden Vs i\n\ngoal (1 subgoal):\n 1. index Vs (Vs ! i) = i", "by(rule not_hidden_index_nth)"], ["proof (state)\nthis:\n  index Vs (Vs ! i) = i\n\ngoal (1 subgoal):\n 1. \\<not> hidden Vs i \\<Longrightarrow> hidden (Vs @ [Vs ! i]) i", "moreover"], ["proof (state)\nthis:\n  index Vs (Vs ! i) = i\n\ngoal (1 subgoal):\n 1. \\<not> hidden Vs i \\<Longrightarrow> hidden (Vs @ [Vs ! i]) i", "from len"], ["proof (chain)\npicking this:\n  i < length Vs", "have \"hidden (Vs @ [Vs ! i]) (index Vs (Vs ! i))\""], ["proof (prove)\nusing this:\n  i < length Vs\n\ngoal (1 subgoal):\n 1. hidden (Vs @ [Vs ! i]) (index Vs (Vs ! i))", "by(auto intro: hidden_index)"], ["proof (state)\nthis:\n  hidden (Vs @ [Vs ! i]) (index Vs (Vs ! i))\n\ngoal (1 subgoal):\n 1. \\<not> hidden Vs i \\<Longrightarrow> hidden (Vs @ [Vs ! i]) i", "ultimately"], ["proof (chain)\npicking this:\n  index Vs (Vs ! i) = i\n  hidden (Vs @ [Vs ! i]) (index Vs (Vs ! i))", "show ?thesis"], ["proof (prove)\nusing this:\n  index Vs (Vs ! i) = i\n  hidden (Vs @ [Vs ! i]) (index Vs (Vs ! i))\n\ngoal (1 subgoal):\n 1. hidden (Vs @ [Vs ! i]) i", "by simp"], ["proof (state)\nthis:\n  hidden (Vs @ [Vs ! i]) i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_upds_Some_eq_nth_index:\n  assumes \"[Vs [\\<mapsto>] vs] V = Some v\" \"length Vs \\<le> length vs\"\n  shows \"vs ! index Vs V = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs ! index Vs V = v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vs ! index Vs V = v", "from \\<open>[Vs [\\<mapsto>] vs] V = Some v\\<close>"], ["proof (chain)\npicking this:\n  [Vs [\\<mapsto>] vs] V = Some v", "have \"V \\<in> set Vs\""], ["proof (prove)\nusing this:\n  [Vs [\\<mapsto>] vs] V = Some v\n\ngoal (1 subgoal):\n 1. V \\<in> set Vs", "by -(rule classical, auto)"], ["proof (state)\nthis:\n  V \\<in> set Vs\n\ngoal (1 subgoal):\n 1. vs ! index Vs V = v", "with \\<open>[Vs [\\<mapsto>] vs] V = Some v\\<close> \\<open>length Vs \\<le> length vs\\<close>"], ["proof (chain)\npicking this:\n  [Vs [\\<mapsto>] vs] V = Some v\n  length Vs \\<le> length vs\n  V \\<in> set Vs", "show ?thesis"], ["proof (prove)\nusing this:\n  [Vs [\\<mapsto>] vs] V = Some v\n  length Vs \\<le> length vs\n  V \\<in> set Vs\n\ngoal (1 subgoal):\n 1. vs ! index Vs V = v", "proof(induct Vs arbitrary: vs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs.\n       \\<lbrakk>[[] [\\<mapsto>] vs] V = Some v; length [] \\<le> length vs;\n        V \\<in> set []\\<rbrakk>\n       \\<Longrightarrow> vs ! index [] V = v\n 2. \\<And>a Vs vs.\n       \\<lbrakk>\\<And>vs.\n                   \\<lbrakk>[Vs [\\<mapsto>] vs] V = Some v;\n                    length Vs \\<le> length vs; V \\<in> set Vs\\<rbrakk>\n                   \\<Longrightarrow> vs ! index Vs V = v;\n        [a # Vs [\\<mapsto>] vs] V = Some v; length (a # Vs) \\<le> length vs;\n        V \\<in> set (a # Vs)\\<rbrakk>\n       \\<Longrightarrow> vs ! index (a # Vs) V = v", "case Nil"], ["proof (state)\nthis:\n  [[] [\\<mapsto>] vs] V = Some v\n  length [] \\<le> length vs\n  V \\<in> set []\n\ngoal (2 subgoals):\n 1. \\<And>vs.\n       \\<lbrakk>[[] [\\<mapsto>] vs] V = Some v; length [] \\<le> length vs;\n        V \\<in> set []\\<rbrakk>\n       \\<Longrightarrow> vs ! index [] V = v\n 2. \\<And>a Vs vs.\n       \\<lbrakk>\\<And>vs.\n                   \\<lbrakk>[Vs [\\<mapsto>] vs] V = Some v;\n                    length Vs \\<le> length vs; V \\<in> set Vs\\<rbrakk>\n                   \\<Longrightarrow> vs ! index Vs V = v;\n        [a # Vs [\\<mapsto>] vs] V = Some v; length (a # Vs) \\<le> length vs;\n        V \\<in> set (a # Vs)\\<rbrakk>\n       \\<Longrightarrow> vs ! index (a # Vs) V = v", "thus ?case"], ["proof (prove)\nusing this:\n  [[] [\\<mapsto>] vs] V = Some v\n  length [] \\<le> length vs\n  V \\<in> set []\n\ngoal (1 subgoal):\n 1. vs ! index [] V = v", "by simp"], ["proof (state)\nthis:\n  vs ! index [] V = v\n\ngoal (1 subgoal):\n 1. \\<And>a Vs vs.\n       \\<lbrakk>\\<And>vs.\n                   \\<lbrakk>[Vs [\\<mapsto>] vs] V = Some v;\n                    length Vs \\<le> length vs; V \\<in> set Vs\\<rbrakk>\n                   \\<Longrightarrow> vs ! index Vs V = v;\n        [a # Vs [\\<mapsto>] vs] V = Some v; length (a # Vs) \\<le> length vs;\n        V \\<in> set (a # Vs)\\<rbrakk>\n       \\<Longrightarrow> vs ! index (a # Vs) V = v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Vs vs.\n       \\<lbrakk>\\<And>vs.\n                   \\<lbrakk>[Vs [\\<mapsto>] vs] V = Some v;\n                    length Vs \\<le> length vs; V \\<in> set Vs\\<rbrakk>\n                   \\<Longrightarrow> vs ! index Vs V = v;\n        [a # Vs [\\<mapsto>] vs] V = Some v; length (a # Vs) \\<le> length vs;\n        V \\<in> set (a # Vs)\\<rbrakk>\n       \\<Longrightarrow> vs ! index (a # Vs) V = v", "case (Cons x xs ys)"], ["proof (state)\nthis:\n  \\<lbrakk>[xs [\\<mapsto>] ?vs] V = Some v; length xs \\<le> length ?vs;\n   V \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> ?vs ! index xs V = v\n  [x # xs [\\<mapsto>] ys] V = Some v\n  length (x # xs) \\<le> length ys\n  V \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a Vs vs.\n       \\<lbrakk>\\<And>vs.\n                   \\<lbrakk>[Vs [\\<mapsto>] vs] V = Some v;\n                    length Vs \\<le> length vs; V \\<in> set Vs\\<rbrakk>\n                   \\<Longrightarrow> vs ! index Vs V = v;\n        [a # Vs [\\<mapsto>] vs] V = Some v; length (a # Vs) \\<le> length vs;\n        V \\<in> set (a # Vs)\\<rbrakk>\n       \\<Longrightarrow> vs ! index (a # Vs) V = v", "note IH = \\<open>\\<And>vs. \\<lbrakk> [xs [\\<mapsto>] vs] V = Some v; length xs \\<le> length vs; V \\<in> set xs \\<rbrakk> \\<Longrightarrow> vs ! index xs V = v\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>[xs [\\<mapsto>] ?vs] V = Some v; length xs \\<le> length ?vs;\n   V \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> ?vs ! index xs V = v\n\ngoal (1 subgoal):\n 1. \\<And>a Vs vs.\n       \\<lbrakk>\\<And>vs.\n                   \\<lbrakk>[Vs [\\<mapsto>] vs] V = Some v;\n                    length Vs \\<le> length vs; V \\<in> set Vs\\<rbrakk>\n                   \\<Longrightarrow> vs ! index Vs V = v;\n        [a # Vs [\\<mapsto>] vs] V = Some v; length (a # Vs) \\<le> length vs;\n        V \\<in> set (a # Vs)\\<rbrakk>\n       \\<Longrightarrow> vs ! index (a # Vs) V = v", "from \\<open>[x # xs [\\<mapsto>] ys] V = Some v\\<close>"], ["proof (chain)\npicking this:\n  [x # xs [\\<mapsto>] ys] V = Some v", "obtain y Ys where \"ys = y # Ys\""], ["proof (prove)\nusing this:\n  [x # xs [\\<mapsto>] ys] V = Some v\n\ngoal (1 subgoal):\n 1. (\\<And>y Ys. ys = y # Ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases ys, auto)"], ["proof (state)\nthis:\n  ys = y # Ys\n\ngoal (1 subgoal):\n 1. \\<And>a Vs vs.\n       \\<lbrakk>\\<And>vs.\n                   \\<lbrakk>[Vs [\\<mapsto>] vs] V = Some v;\n                    length Vs \\<le> length vs; V \\<in> set Vs\\<rbrakk>\n                   \\<Longrightarrow> vs ! index Vs V = v;\n        [a # Vs [\\<mapsto>] vs] V = Some v; length (a # Vs) \\<le> length vs;\n        V \\<in> set (a # Vs)\\<rbrakk>\n       \\<Longrightarrow> vs ! index (a # Vs) V = v", "with \\<open>length (x # xs) \\<le> length ys\\<close>"], ["proof (chain)\npicking this:\n  length (x # xs) \\<le> length ys\n  ys = y # Ys", "have \"length xs \\<le> length Ys\""], ["proof (prove)\nusing this:\n  length (x # xs) \\<le> length ys\n  ys = y # Ys\n\ngoal (1 subgoal):\n 1. length xs \\<le> length Ys", "by simp"], ["proof (state)\nthis:\n  length xs \\<le> length Ys\n\ngoal (1 subgoal):\n 1. \\<And>a Vs vs.\n       \\<lbrakk>\\<And>vs.\n                   \\<lbrakk>[Vs [\\<mapsto>] vs] V = Some v;\n                    length Vs \\<le> length vs; V \\<in> set Vs\\<rbrakk>\n                   \\<Longrightarrow> vs ! index Vs V = v;\n        [a # Vs [\\<mapsto>] vs] V = Some v; length (a # Vs) \\<le> length vs;\n        V \\<in> set (a # Vs)\\<rbrakk>\n       \\<Longrightarrow> vs ! index (a # Vs) V = v", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ys ! index (x # xs) V = v", "proof(cases \"V \\<in> set xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. V \\<in> set xs \\<Longrightarrow> ys ! index (x # xs) V = v\n 2. V \\<notin> set xs \\<Longrightarrow> ys ! index (x # xs) V = v", "case True"], ["proof (state)\nthis:\n  V \\<in> set xs\n\ngoal (2 subgoals):\n 1. V \\<in> set xs \\<Longrightarrow> ys ! index (x # xs) V = v\n 2. V \\<notin> set xs \\<Longrightarrow> ys ! index (x # xs) V = v", "with \\<open>[x # xs [\\<mapsto>] ys] V = Some v\\<close> \\<open>length xs \\<le> length Ys\\<close> \\<open>ys = y # Ys\\<close>"], ["proof (chain)\npicking this:\n  [x # xs [\\<mapsto>] ys] V = Some v\n  length xs \\<le> length Ys\n  ys = y # Ys\n  V \\<in> set xs", "have \"[xs [\\<mapsto>] Ys] V = Some v\""], ["proof (prove)\nusing this:\n  [x # xs [\\<mapsto>] ys] V = Some v\n  length xs \\<le> length Ys\n  ys = y # Ys\n  V \\<in> set xs\n\ngoal (1 subgoal):\n 1. [xs [\\<mapsto>] Ys] V = Some v", "apply(auto simp add: map_upds_def map_of_eq_None_iff set_zip image_Collect split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs \\<le> length Ys; ys = v # Ys; x \\<in> set xs;\n     \\<forall>i. x = xs ! i \\<longrightarrow> \\<not> i < length xs; V = x;\n     y = v\\<rbrakk>\n    \\<Longrightarrow> map_of (rev (zip xs Ys)) x = Some v", "apply(clarsimp simp add: in_set_conv_decomp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ysa zs.\n       \\<lbrakk>Suc (length ysa + length zs) \\<le> length Ys; ys = v # Ys;\n        \\<forall>i.\n           x = (ysa @ x # zs) ! i \\<longrightarrow>\n           \\<not> i < Suc (length ysa + length zs);\n        V = x; y = v; xs = ysa @ x # zs\\<rbrakk>\n       \\<Longrightarrow> map_of (rev (zip (ysa @ x # zs) Ys)) x = Some v", "apply(hypsubst_thin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>Suc (length ys + length zs) \\<le> length Ys;\n        \\<forall>i.\n           x = (ys @ x # zs) ! i \\<longrightarrow>\n           \\<not> i < Suc (length ys + length zs)\\<rbrakk>\n       \\<Longrightarrow> map_of (rev (zip (ys @ x # zs) Ys)) x = Some v", "apply(erule_tac x=\"length ys\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>Suc (length ys + length zs) \\<le> length Ys;\n        x = (ys @ x # zs) ! length ys \\<longrightarrow>\n        \\<not> length ys < Suc (length ys + length zs)\\<rbrakk>\n       \\<Longrightarrow> map_of (rev (zip (ys @ x # zs) Ys)) x = Some v", "by(simp)"], ["proof (state)\nthis:\n  [xs [\\<mapsto>] Ys] V = Some v\n\ngoal (2 subgoals):\n 1. V \\<in> set xs \\<Longrightarrow> ys ! index (x # xs) V = v\n 2. V \\<notin> set xs \\<Longrightarrow> ys ! index (x # xs) V = v", "with IH[OF this \\<open>length xs \\<le> length Ys\\<close> True] \\<open>ys = y # Ys\\<close> True"], ["proof (chain)\npicking this:\n  Ys ! index xs V = v\n  ys = y # Ys\n  V \\<in> set xs\n  [xs [\\<mapsto>] Ys] V = Some v", "show ?thesis"], ["proof (prove)\nusing this:\n  Ys ! index xs V = v\n  ys = y # Ys\n  V \\<in> set xs\n  [xs [\\<mapsto>] Ys] V = Some v\n\ngoal (1 subgoal):\n 1. ys ! index (x # xs) V = v", "by(simp)"], ["proof (state)\nthis:\n  ys ! index (x # xs) V = v\n\ngoal (1 subgoal):\n 1. V \\<notin> set xs \\<Longrightarrow> ys ! index (x # xs) V = v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. V \\<notin> set xs \\<Longrightarrow> ys ! index (x # xs) V = v", "case False"], ["proof (state)\nthis:\n  V \\<notin> set xs\n\ngoal (1 subgoal):\n 1. V \\<notin> set xs \\<Longrightarrow> ys ! index (x # xs) V = v", "with \\<open>V \\<in> set (x # xs)\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> set (x # xs)\n  V \\<notin> set xs", "have \"x = V\""], ["proof (prove)\nusing this:\n  V \\<in> set (x # xs)\n  V \\<notin> set xs\n\ngoal (1 subgoal):\n 1. x = V", "by auto"], ["proof (state)\nthis:\n  x = V\n\ngoal (1 subgoal):\n 1. V \\<notin> set xs \\<Longrightarrow> ys ! index (x # xs) V = v", "with False \\<open>[x # xs [\\<mapsto>] ys] V = Some v\\<close> \\<open>ys = y # Ys\\<close>"], ["proof (chain)\npicking this:\n  V \\<notin> set xs\n  [x # xs [\\<mapsto>] ys] V = Some v\n  ys = y # Ys\n  x = V", "have \"y = v\""], ["proof (prove)\nusing this:\n  V \\<notin> set xs\n  [x # xs [\\<mapsto>] ys] V = Some v\n  ys = y # Ys\n  x = V\n\ngoal (1 subgoal):\n 1. y = v", "by(auto)"], ["proof (state)\nthis:\n  y = v\n\ngoal (1 subgoal):\n 1. V \\<notin> set xs \\<Longrightarrow> ys ! index (x # xs) V = v", "with False \\<open>x = V\\<close> \\<open>ys = y # Ys\\<close>"], ["proof (chain)\npicking this:\n  V \\<notin> set xs\n  x = V\n  ys = y # Ys\n  y = v", "show ?thesis"], ["proof (prove)\nusing this:\n  V \\<notin> set xs\n  x = V\n  ys = y # Ys\n  y = v\n\ngoal (1 subgoal):\n 1. ys ! index (x # xs) V = v", "by(simp)"], ["proof (state)\nthis:\n  ys ! index (x # xs) V = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ys ! index (x # xs) V = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vs ! index Vs V = v\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}