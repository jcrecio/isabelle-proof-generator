{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Compiler/PCompiler.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma map_of_map4:\n  \"map_of (map (\\<lambda>(x,a,b,c).(x,a,b,f x a b c)) ts) =\n  (\\<lambda>x. map_option (\\<lambda>(a,b,c).(a,b,f x a b c)) (map_of ts x))\"", "lemma class_compP:\n  \"class P C = Some (D, fs, ms)\n  \\<Longrightarrow> class (compP f P) C = Some (D, fs, map (compM (f C)) ms)\"", "lemma class_compPD:\n  \"class (compP f P) C = Some (D, fs, cms)\n  \\<Longrightarrow> \\<exists>ms. class P C = Some(D,fs,ms) \\<and> cms = map (compM (f C)) ms\"", "lemma [simp]: \"is_class (compP f P) C = is_class P C\"", "lemma [simp]: \"class (compP f P) C = map_option (\\<lambda>c. snd(compC f (C,c))) (class P C)\"", "lemma sees_methods_compP:\n  \"P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n  compP f P \\<turnstile> C sees_methods (\\<lambda>M. map_option (\\<lambda>((Ts,T,m),D). ((Ts,T,map_option (f D M Ts T) m),D)) (Mm M))\"", "lemma sees_method_compP:\n  \"P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n  compP f P \\<turnstile> C sees M: Ts\\<rightarrow>T = map_option (f D M Ts T) m in D\"", "lemma [simp]:\n  \"P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n  method (compP f P) C M = (D,Ts,T,map_option (f D M Ts T) m)\"", "lemma sees_methods_compPD:\n  \"\\<lbrakk> cP \\<turnstile> C sees_methods Mm'; cP = compP f P \\<rbrakk> \\<Longrightarrow>\n  \\<exists>Mm. P \\<turnstile> C sees_methods Mm \\<and>\n        Mm' = (\\<lambda>M. map_option (\\<lambda>((Ts,T,m),D). ((Ts,T,map_option (f D M Ts T) m),D)) (Mm M))\"", "lemma sees_method_compPD:\n  \"compP f P \\<turnstile> C sees M: Ts\\<rightarrow>T = fm in D \\<Longrightarrow>\n  \\<exists>m. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<and> map_option (f D M Ts T) m = fm\"", "lemma sees_method_native_compP [simp]:\n  \"compP f P \\<turnstile> C sees M:Ts \\<rightarrow> T = Native in D \\<longleftrightarrow> P \\<turnstile> C sees M:Ts \\<rightarrow> T = Native in D\"", "lemma [simp]: \"subcls1(compP f P) = subcls1 P\"", "lemma [simp]: \"is_type (compP f P) T = is_type P T\"", "lemma is_type_compP [simp]: \"is_type (compP f P) = is_type P\"", "lemma compP_widen[simp]:\n  \"(compP f P \\<turnstile> T \\<le> T') = (P \\<turnstile> T \\<le> T')\"", "lemma [simp]: \"(compP f P \\<turnstile> Ts [\\<le>] Ts') = (P \\<turnstile> Ts [\\<le>] Ts')\"", "lemma is_lub_compP [simp]:\n  \"is_lub (compP f P) = is_lub P\"", "lemma [simp]:\n  fixes f :: \"cname \\<Rightarrow> mname \\<Rightarrow> ty list \\<Rightarrow> ty \\<Rightarrow> 'a \\<Rightarrow> 'b\"\n  shows \"(compP f P \\<turnstile> C has_fields FDTs) = (P \\<turnstile> C has_fields FDTs)\"\n(*<*)\n (is \"?A = ?B\")", "lemma [simp]: \"fields (compP f P) C = fields P C\"", "lemma [simp]: \"(compP f P \\<turnstile> C sees F:T (fm) in D) = (P \\<turnstile> C sees F:T (fm) in D)\"", "lemma [simp]: \"field (compP f P) F D = field P F D\"", "lemma [iff]: \"distinct_fst (classes (compP f P)) = distinct_fst (classes P)\"", "lemma [iff]: \"distinct_fst (map (compM f) ms) = distinct_fst ms\"", "lemma [iff]: \"wf_syscls (compP f P) = wf_syscls P\"", "lemma [iff]: \"wf_fdecl (compP f P) = wf_fdecl P\"", "lemma set_compP:\n \"(class (compP f P) C = \\<lfloor>(D,fs,ms')\\<rfloor>) \\<longleftrightarrow> \n  (\\<exists>ms. class P C = \\<lfloor>(D,fs,ms)\\<rfloor> \\<and> ms' = map (compM (f C)) ms)\"", "lemma compP_has_method: \"compP f P \\<turnstile> C has M \\<longleftrightarrow> P \\<turnstile> C has M\"", "lemma is_native_compP [simp]: \"is_native (compP f P) = is_native P\"", "lemma \\<tau>external_compP [simp]:\n  \"\\<tau>external (compP f P) = \\<tau>external P\"", "lemma heap_clone_compP [simp]: \n  \"heap_clone (compP f P) = heap_clone P\"", "lemma red_external_compP [simp]:\n  \"compP f P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle> \\<longleftrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>\"", "lemma \\<tau>external'_compP [simp]:\n  \"\\<tau>external' (compP f P) = \\<tau>external' P\"", "lemma wf_overriding_compP [simp]: \"wf_overriding (compP f P) D (compM (f C) m) = wf_overriding P D m\"", "lemma wf_cdecl_compPI:\n  assumes wf1_imp_wf2: \n    \"\\<And>C M Ts T m. \\<lbrakk> wf_mdecl wf\\<^sub>1 P C (M,Ts,T,\\<lfloor>m\\<rfloor>); P \\<turnstile> C sees M:Ts\\<rightarrow>T = \\<lfloor>m\\<rfloor> in C \\<rbrakk>\n    \\<Longrightarrow> wf_mdecl wf\\<^sub>2 (compP f P) C (M,Ts,T, \\<lfloor>f C M Ts T m\\<rfloor>)\"\n  and wfcP1: \"\\<forall>C rest. class P C = \\<lfloor>rest\\<rfloor> \\<longrightarrow> wf_cdecl wf\\<^sub>1 P (C, rest)\"\n  and xcomp: \"class (compP f P) C = \\<lfloor>rest'\\<rfloor>\"\n  and wf: \"wf_prog p P\"\n  shows \"wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')\"", "lemma wf_prog_compPI:\nassumes lift: \n  \"\\<And>C M Ts T m. \n    \\<lbrakk> P \\<turnstile> C sees M:Ts\\<rightarrow>T = \\<lfloor>m\\<rfloor> in C; wf_mdecl wf\\<^sub>1 P C (M,Ts,T,\\<lfloor>m\\<rfloor>) \\<rbrakk>\n    \\<Longrightarrow> wf_mdecl wf\\<^sub>2 (compP f P) C (M,Ts,T, \\<lfloor>f C M Ts T m\\<rfloor>)\"\nand wf: \"wf_prog wf\\<^sub>1 P\"\nshows \"wf_prog wf\\<^sub>2 (compP f P)\"", "lemma wf_cdecl_compPD:\n  assumes wf1_imp_wf2: \n    \"\\<And>C M Ts T m. \\<lbrakk> wf_mdecl wf\\<^sub>1 (compP f P) C (M,Ts,T,\\<lfloor>f C M Ts T m\\<rfloor>); compP f P \\<turnstile> C sees M:Ts\\<rightarrow>T = \\<lfloor>f C M Ts T m\\<rfloor> in C \\<rbrakk>\n    \\<Longrightarrow> wf_mdecl wf\\<^sub>2 P C (M,Ts,T, \\<lfloor>m\\<rfloor>)\"\n  and wfcP1: \"\\<forall>C rest. class (compP f P) C = \\<lfloor>rest\\<rfloor> \\<longrightarrow> wf_cdecl wf\\<^sub>1 (compP f P) (C, rest)\"\n  and xcomp: \"class P C = \\<lfloor>rest\\<rfloor>\"\n  and wf: \"wf_prog wf_md (compP f P)\"\n  shows \"wf_cdecl wf\\<^sub>2 P (C, rest)\"", "lemma wf_prog_compPD:\nassumes wf: \"wf_prog wf1 (compP f P)\"\nand lift: \n  \"\\<And>C M Ts T m. \n    \\<lbrakk> compP f P \\<turnstile> C sees M:Ts\\<rightarrow>T = \\<lfloor>f C M Ts T m\\<rfloor> in C; wf_mdecl wf1 (compP f P) C (M,Ts,T, \\<lfloor>f C M Ts T m\\<rfloor>) \\<rbrakk>\n    \\<Longrightarrow> wf_mdecl wf2 P C (M,Ts,T,\\<lfloor>m\\<rfloor>)\"\nshows \"wf_prog wf2 P\"", "lemma WT_binop_compP [simp]: \"compP f P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 :: T \\<longleftrightarrow> P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 :: T\"", "lemma WTrt_binop_compP [simp]: \"compP f P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T \\<longleftrightarrow> P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T\"", "lemma binop_relevant_class_compP [simp]: \"binop_relevant_class bop (compP f P) = binop_relevant_class bop P\"", "lemma is_class_compP [simp]:\n  \"is_class (compP f P) = is_class P\"", "lemma has_field_compP [simp]:\n  \"compP f P \\<turnstile> C has F:T (fm) in D \\<longleftrightarrow> P \\<turnstile> C has F:T (fm) in D\"", "lemma compP_addr_loc_type [simp]:\n  \"addr_loc_type (compP f P) = addr_loc_type P\"", "lemma conf_compP [simp]:\n  \"compP f P,h \\<turnstile> v :\\<le> T \\<longleftrightarrow> P,h \\<turnstile> v :\\<le> T\"", "lemma compP_conf: \"conf (compP f P) = conf P\"", "lemma compP_confs: \"compP f P,h \\<turnstile> vs [:\\<le>] Ts \\<longleftrightarrow> P,h \\<turnstile> vs [:\\<le>] Ts\"", "lemma tconf_compP [simp]: \"compP f P, h \\<turnstile> t \\<surd>t \\<longleftrightarrow> P,h \\<turnstile> t \\<surd>t\"", "lemma wf_start_state_compP [simp]:\n  \"wf_start_state (compP f P) = wf_start_state P\"", "lemma compP_addr_conv:\n  \"addr_conv addr2thread_id thread_id2addr typeof_addr (compP f P) = addr_conv addr2thread_id thread_id2addr typeof_addr P\"", "lemma compP_heap:\n  \"heap addr2thead_id thread_id2addr allocate typeof_addr heap_write (compP f P) =\n  heap addr2thead_id thread_id2addr allocate typeof_addr heap_write P\"", "lemma compP_heap_conf:\n  \"heap_conf addr2thead_id thread_id2addr empty_heap allocate typeof_addr heap_write hconf (compP f P) =\n   heap_conf addr2thead_id thread_id2addr empty_heap allocate typeof_addr heap_write hconf P\"", "lemma compP_heap_conf_read:\n  \"heap_conf_read addr2thead_id thread_id2addr empty_heap allocate typeof_addr heap_read heap_write hconf (compP f P) =\n   heap_conf_read addr2thead_id thread_id2addr empty_heap allocate typeof_addr heap_read heap_write hconf P\"", "lemma compM_compM:\n  \"compM f (compM g md) = compM (\\<lambda>M Ts T. f M Ts T \\<circ> g M Ts T) md\"", "lemma compC_compC:\n  \"compC f (compC g cd) = compC (\\<lambda>C M Ts T. f C M Ts T \\<circ> g C M Ts T) cd\"", "lemma compP_compP:\n  \"compP f (compP g P) = compP (\\<lambda>C M Ts T. f C M Ts T \\<circ> g C M Ts T) P\""], "translations": [["", "lemma map_of_map4:\n  \"map_of (map (\\<lambda>(x,a,b,c).(x,a,b,f x a b c)) ts) =\n  (\\<lambda>x. map_option (\\<lambda>(a,b,c).(a,b,f x a b c)) (map_of ts x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>(x, a, b, c). (x, a, b, f x a b c)) ts) =\n    (\\<lambda>x.\n        map_option (\\<lambda>(a, b, c). (a, b, f x a b c)) (map_of ts x))", "apply(induct ts)"], ["proof (prove)\ngoal (2 subgoals):\n 1. map_of\n     (map (\\<lambda>a.\n              case a of\n              (x, aa, ba, c) \\<Rightarrow> (x, aa, ba, f x aa ba c))\n       []) =\n    (\\<lambda>x.\n        map_option\n         (\\<lambda>a.\n             case a of (a, ba, c) \\<Rightarrow> (a, ba, f x a ba c))\n         (map_of [] x))\n 2. \\<And>a ts.\n       map_of\n        (map (\\<lambda>a.\n                 case a of\n                 (x, aa, ba, c) \\<Rightarrow> (x, aa, ba, f x aa ba c))\n          ts) =\n       (\\<lambda>x.\n           map_option\n            (\\<lambda>a.\n                case a of (a, ba, c) \\<Rightarrow> (a, ba, f x a ba c))\n            (map_of ts x)) \\<Longrightarrow>\n       map_of\n        (map (\\<lambda>a.\n                 case a of\n                 (x, aa, ba, c) \\<Rightarrow> (x, aa, ba, f x aa ba c))\n          (a # ts)) =\n       (\\<lambda>x.\n           map_option\n            (\\<lambda>a.\n                case a of (a, ba, c) \\<Rightarrow> (a, ba, f x a ba c))\n            (map_of (a # ts) x))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ts.\n       map_of\n        (map (\\<lambda>a.\n                 case a of\n                 (x, aa, ba, c) \\<Rightarrow> (x, aa, ba, f x aa ba c))\n          ts) =\n       (\\<lambda>x.\n           map_option\n            (\\<lambda>a.\n                case a of (a, ba, c) \\<Rightarrow> (a, ba, f x a ba c))\n            (map_of ts x)) \\<Longrightarrow>\n       map_of\n        (map (\\<lambda>a.\n                 case a of\n                 (x, aa, ba, c) \\<Rightarrow> (x, aa, ba, f x aa ba c))\n          (a # ts)) =\n       (\\<lambda>x.\n           map_option\n            (\\<lambda>a.\n                case a of (a, ba, c) \\<Rightarrow> (a, ba, f x a ba c))\n            (map_of (a # ts) x))", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ts x.\n       map_of\n        (map (\\<lambda>a.\n                 case a of\n                 (x, aa, ba, c) \\<Rightarrow> (x, aa, ba, f x aa ba c))\n          ts) =\n       (\\<lambda>x.\n           map_option\n            (\\<lambda>a.\n                case a of (a, ba, c) \\<Rightarrow> (a, ba, f x a ba c))\n            (map_of ts x)) \\<Longrightarrow>\n       map_of\n        (map (\\<lambda>a.\n                 case a of\n                 (x, aa, ba, c) \\<Rightarrow> (x, aa, ba, f x aa ba c))\n          (a # ts))\n        x =\n       map_option\n        (\\<lambda>a. case a of (a, ba, c) \\<Rightarrow> (a, ba, f x a ba c))\n        (map_of (a # ts) x)", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma class_compP:\n  \"class P C = Some (D, fs, ms)\n  \\<Longrightarrow> class (compP f P) C = Some (D, fs, map (compM (f C)) ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class P C = \\<lfloor>(D, fs, ms)\\<rfloor> \\<Longrightarrow>\n    class (compP f P) C = \\<lfloor>(D, fs, map (compM (f C)) ms)\\<rfloor>", "by(cases P)(simp add:class_def compP_def compC_def map_of_map4)"], ["", "lemma class_compPD:\n  \"class (compP f P) C = Some (D, fs, cms)\n  \\<Longrightarrow> \\<exists>ms. class P C = Some(D,fs,ms) \\<and> cms = map (compM (f C)) ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class (compP f P) C = \\<lfloor>(D, fs, cms)\\<rfloor> \\<Longrightarrow>\n    \\<exists>ms.\n       class P C = \\<lfloor>(D, fs, ms)\\<rfloor> \\<and>\n       cms = map (compM (f C)) ms", "by(cases P)(clarsimp simp add:class_def compP_def compC_def map_of_map4)"], ["", "lemma [simp]: \"is_class (compP f P) C = is_class P C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_class (compP f P) C = is_class P C", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_class (compP f P) C = is_class P C", "by(auto simp:is_class_def dest: class_compP class_compPD)"], ["", "(*>*)"], ["", "lemma [simp]: \"class (compP f P) C = map_option (\\<lambda>c. snd(compC f (C,c))) (class P C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class (compP f P) C =\n    map_option (\\<lambda>c. snd (compC f (C, c))) (class P C)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. class (compP f P) C =\n    map_option (\\<lambda>c. snd (compC f (C, c))) (class P C)", "apply(cases P)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       P = Program x \\<Longrightarrow>\n       class (compP f P) C =\n       map_option (\\<lambda>c. snd (compC f (C, c))) (class P C)", "apply(simp add:compC_def class_def map_of_map4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       P = Program x \\<Longrightarrow>\n       map_option\n        (\\<lambda>(D, Fdecls, Mdecls).\n            (D, Fdecls, map (compM (f C)) Mdecls))\n        (map_of x C) =\n       map_option\n        (\\<lambda>c.\n            snd (case c of\n                 (D, Fdecls, Mdecls) \\<Rightarrow>\n                   (C, D, Fdecls, map (compM (f C)) Mdecls)))\n        (map_of x C)", "apply(simp add:split_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma sees_methods_compP:\n  \"P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n  compP f P \\<turnstile> C sees_methods (\\<lambda>M. map_option (\\<lambda>((Ts,T,m),D). ((Ts,T,map_option (f D M Ts T) m),D)) (Mm M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n    compP f\n     P \\<turnstile> C sees_methods (\\<lambda>M.\n map_option\n  (\\<lambda>((Ts, T, m), D). ((Ts, T, map_option (f D M Ts T) m), D))\n  (Mm M))", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n    compP f\n     P \\<turnstile> C sees_methods (\\<lambda>M.\n map_option\n  (\\<lambda>((Ts, T, m), D). ((Ts, T, map_option (f D M Ts T) m), D))\n  (Mm M))", "apply(erule Methods.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms\\<rbrakk>\n       \\<Longrightarrow> compP f\n                          P \\<turnstile> Object sees_methods (\\<lambda>M.\n                           map_option\n                            (\\<lambda>a.\n                                case a of\n                                (a, b) \\<Rightarrow>\n                                  (case a of\n                                   (Ts, a) \\<Rightarrow>\n                                     case a of\n                                     (T, m) \\<Rightarrow>\n \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n                                   b)\n                            (Mm M))\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods (\\<lambda>M.\n     map_option\n      (\\<lambda>a.\n          case a of\n          (a, b) \\<Rightarrow>\n            (case a of\n             (Ts, a) \\<Rightarrow>\n               case a of\n               (T, m) \\<Rightarrow>\n                 \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n             b)\n      (Mm M));\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> compP f\n                          P \\<turnstile> C sees_methods (\\<lambda>M.\n                      map_option\n                       (\\<lambda>a.\n                           case a of\n                           (a, b) \\<Rightarrow>\n                             (case a of\n                              (Ts, a) \\<Rightarrow>\n                                case a of\n                                (T, m) \\<Rightarrow>\n                                  \\<lambda>D.\n                                     ((Ts, T, map_option (f D M Ts T) m),\nD))\n                              b)\n                       (Mm' M))", "apply(rule sees_methods_Object)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>D fs ms Mm.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms\\<rbrakk>\n       \\<Longrightarrow> class (compP f P) Object =\n                         \\<lfloor>(?D4 D fs ms Mm, ?fs4 D fs ms Mm,\n                                   ?ms4 D fs ms Mm)\\<rfloor>\n 2. \\<And>D fs ms Mm.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>M.\n                             map_option\n                              (\\<lambda>a.\n                                  case a of\n                                  (a, b) \\<Rightarrow>\n                                    (case a of\n                                     (Ts, a) \\<Rightarrow>\n case a of\n (T, m) \\<Rightarrow> \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n                                     b)\n                              (Mm M)) =\n                         map_option (\\<lambda>m. (m, Object)) \\<circ>\n                         map_of (?ms4 D fs ms Mm)\n 3. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods (\\<lambda>M.\n     map_option\n      (\\<lambda>a.\n          case a of\n          (a, b) \\<Rightarrow>\n            (case a of\n             (Ts, a) \\<Rightarrow>\n               case a of\n               (T, m) \\<Rightarrow>\n                 \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n             b)\n      (Mm M));\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> compP f\n                          P \\<turnstile> C sees_methods (\\<lambda>M.\n                      map_option\n                       (\\<lambda>a.\n                           case a of\n                           (a, b) \\<Rightarrow>\n                             (case a of\n                              (Ts, a) \\<Rightarrow>\n                                case a of\n                                (T, m) \\<Rightarrow>\n                                  \\<lambda>D.\n                                     ((Ts, T, map_option (f D M Ts T) m),\nD))\n                              b)\n                       (Mm' M))", "apply(erule class_compP)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>M.\n                             map_option\n                              (\\<lambda>a.\n                                  case a of\n                                  (a, b) \\<Rightarrow>\n                                    (case a of\n                                     (Ts, a) \\<Rightarrow>\n case a of\n (T, m) \\<Rightarrow> \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n                                     b)\n                              (Mm M)) =\n                         map_option (\\<lambda>m. (m, Object)) \\<circ>\n                         map_of (map (compM (f Object)) ms)\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods (\\<lambda>M.\n     map_option\n      (\\<lambda>a.\n          case a of\n          (a, b) \\<Rightarrow>\n            (case a of\n             (Ts, a) \\<Rightarrow>\n               case a of\n               (T, m) \\<Rightarrow>\n                 \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n             b)\n      (Mm M));\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> compP f\n                          P \\<turnstile> C sees_methods (\\<lambda>M.\n                      map_option\n                       (\\<lambda>a.\n                           case a of\n                           (a, b) \\<Rightarrow>\n                             (case a of\n                              (Ts, a) \\<Rightarrow>\n                                case a of\n                                (T, m) \\<Rightarrow>\n                                  \\<lambda>D.\n                                     ((Ts, T, map_option (f D M Ts T) m),\nD))\n                              b)\n                       (Mm' M))", "apply(rule ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm M.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms\\<rbrakk>\n       \\<Longrightarrow> map_option\n                          (\\<lambda>a.\n                              case a of\n                              (a, b) \\<Rightarrow>\n                                (case a of\n                                 (Ts, a) \\<Rightarrow>\n                                   case a of\n                                   (T, m) \\<Rightarrow>\n                                     \\<lambda>D.\n  ((Ts, T, map_option (f D M Ts T) m), D))\n                                 b)\n                          (Mm M) =\n                         (map_option (\\<lambda>m. (m, Object)) \\<circ>\n                          map_of (map (compM (f Object)) ms))\n                          M\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods (\\<lambda>M.\n     map_option\n      (\\<lambda>a.\n          case a of\n          (a, b) \\<Rightarrow>\n            (case a of\n             (Ts, a) \\<Rightarrow>\n               case a of\n               (T, m) \\<Rightarrow>\n                 \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n             b)\n      (Mm M));\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> compP f\n                          P \\<turnstile> C sees_methods (\\<lambda>M.\n                      map_option\n                       (\\<lambda>a.\n                           case a of\n                           (a, b) \\<Rightarrow>\n                             (case a of\n                              (Ts, a) \\<Rightarrow>\n                                case a of\n                                (T, m) \\<Rightarrow>\n                                  \\<lambda>D.\n                                     ((Ts, T, map_option (f D M Ts T) m),\nD))\n                              b)\n                       (Mm' M))", "apply(simp add:compM_def map_of_map4 option.map_comp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm M.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms\\<rbrakk>\n       \\<Longrightarrow> map_option\n                          ((\\<lambda>((Ts, T, m), D).\n                               ((Ts, T, map_option (f D M Ts T) m),\n                                D)) \\<circ>\n                           (\\<lambda>m. (m, Object)))\n                          (map_of ms M) =\n                         map_option\n                          ((\\<lambda>m. (m, Object)) \\<circ>\n                           (\\<lambda>(Ts, T, m).\n                               (Ts, T, map_option (f Object M Ts T) m)))\n                          (map_of ms M)\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods (\\<lambda>M.\n     map_option\n      (\\<lambda>a.\n          case a of\n          (a, b) \\<Rightarrow>\n            (case a of\n             (Ts, a) \\<Rightarrow>\n               case a of\n               (T, m) \\<Rightarrow>\n                 \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n             b)\n      (Mm M));\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> compP f\n                          P \\<turnstile> C sees_methods (\\<lambda>M.\n                      map_option\n                       (\\<lambda>a.\n                           case a of\n                           (a, b) \\<Rightarrow>\n                             (case a of\n                              (Ts, a) \\<Rightarrow>\n                                case a of\n                                (T, m) \\<Rightarrow>\n                                  \\<lambda>D.\n                                     ((Ts, T, map_option (f D M Ts T) m),\nD))\n                              b)\n                       (Mm' M))", "apply(case_tac \"map_of ms M\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>D fs ms Mm M.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        map_of ms M = None\\<rbrakk>\n       \\<Longrightarrow> map_option\n                          ((\\<lambda>((Ts, T, m), D).\n                               ((Ts, T, map_option (f D M Ts T) m),\n                                D)) \\<circ>\n                           (\\<lambda>m. (m, Object)))\n                          (map_of ms M) =\n                         map_option\n                          ((\\<lambda>m. (m, Object)) \\<circ>\n                           (\\<lambda>(Ts, T, m).\n                               (Ts, T, map_option (f Object M Ts T) m)))\n                          (map_of ms M)\n 2. \\<And>D fs ms Mm M a.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        map_of ms M = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> map_option\n                          ((\\<lambda>((Ts, T, m), D).\n                               ((Ts, T, map_option (f D M Ts T) m),\n                                D)) \\<circ>\n                           (\\<lambda>m. (m, Object)))\n                          (map_of ms M) =\n                         map_option\n                          ((\\<lambda>m. (m, Object)) \\<circ>\n                           (\\<lambda>(Ts, T, m).\n                               (Ts, T, map_option (f Object M Ts T) m)))\n                          (map_of ms M)\n 3. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods (\\<lambda>M.\n     map_option\n      (\\<lambda>a.\n          case a of\n          (a, b) \\<Rightarrow>\n            (case a of\n             (Ts, a) \\<Rightarrow>\n               case a of\n               (T, m) \\<Rightarrow>\n                 \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n             b)\n      (Mm M));\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> compP f\n                          P \\<turnstile> C sees_methods (\\<lambda>M.\n                      map_option\n                       (\\<lambda>a.\n                           case a of\n                           (a, b) \\<Rightarrow>\n                             (case a of\n                              (Ts, a) \\<Rightarrow>\n                                case a of\n                                (T, m) \\<Rightarrow>\n                                  \\<lambda>D.\n                                     ((Ts, T, map_option (f D M Ts T) m),\nD))\n                              b)\n                       (Mm' M))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm M a.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        map_of ms M = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> map_option\n                          ((\\<lambda>((Ts, T, m), D).\n                               ((Ts, T, map_option (f D M Ts T) m),\n                                D)) \\<circ>\n                           (\\<lambda>m. (m, Object)))\n                          (map_of ms M) =\n                         map_option\n                          ((\\<lambda>m. (m, Object)) \\<circ>\n                           (\\<lambda>(Ts, T, m).\n                               (Ts, T, map_option (f Object M Ts T) m)))\n                          (map_of ms M)\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods (\\<lambda>M.\n     map_option\n      (\\<lambda>a.\n          case a of\n          (a, b) \\<Rightarrow>\n            (case a of\n             (Ts, a) \\<Rightarrow>\n               case a of\n               (T, m) \\<Rightarrow>\n                 \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n             b)\n      (Mm M));\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> compP f\n                          P \\<turnstile> C sees_methods (\\<lambda>M.\n                      map_option\n                       (\\<lambda>a.\n                           case a of\n                           (a, b) \\<Rightarrow>\n                             (case a of\n                              (Ts, a) \\<Rightarrow>\n                                case a of\n                                (T, m) \\<Rightarrow>\n                                  \\<lambda>D.\n                                     ((Ts, T, map_option (f D M Ts T) m),\nD))\n                              b)\n                       (Mm' M))", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods (\\<lambda>M.\n     map_option\n      (\\<lambda>a.\n          case a of\n          (a, b) \\<Rightarrow>\n            (case a of\n             (Ts, a) \\<Rightarrow>\n               case a of\n               (T, m) \\<Rightarrow>\n                 \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n             b)\n      (Mm M));\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> compP f\n                          P \\<turnstile> C sees_methods (\\<lambda>M.\n                      map_option\n                       (\\<lambda>a.\n                           case a of\n                           (a, b) \\<Rightarrow>\n                             (case a of\n                              (Ts, a) \\<Rightarrow>\n                                case a of\n                                (T, m) \\<Rightarrow>\n                                  \\<lambda>D.\n                                     ((Ts, T, map_option (f D M Ts T) m),\nD))\n                              b)\n                       (Mm' M))", "apply(rule sees_methods_rec)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods (\\<lambda>M.\n     map_option\n      (\\<lambda>a.\n          case a of\n          (a, b) \\<Rightarrow>\n            (case a of\n             (Ts, a) \\<Rightarrow>\n               case a of\n               (T, m) \\<Rightarrow>\n                 \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n             b)\n      (Mm M));\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> class (compP f P) C =\n                         \\<lfloor>(?D14 C D fs ms Mm Mm',\n                                   ?fs14 C D fs ms Mm Mm',\n                                   ?ms14 C D fs ms Mm Mm')\\<rfloor>\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods (\\<lambda>M.\n     map_option\n      (\\<lambda>a.\n          case a of\n          (a, b) \\<Rightarrow>\n            (case a of\n             (Ts, a) \\<Rightarrow>\n               case a of\n               (T, m) \\<Rightarrow>\n                 \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n             b)\n      (Mm M));\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> C \\<noteq> Object\n 3. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods (\\<lambda>M.\n     map_option\n      (\\<lambda>a.\n          case a of\n          (a, b) \\<Rightarrow>\n            (case a of\n             (Ts, a) \\<Rightarrow>\n               case a of\n               (T, m) \\<Rightarrow>\n                 \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n             b)\n      (Mm M));\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> compP f\n                          P \\<turnstile> ?D14 C D fs ms Mm\n    Mm' sees_methods ?Mm14 C D fs ms Mm Mm'\n 4. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods (\\<lambda>M.\n     map_option\n      (\\<lambda>a.\n          case a of\n          (a, b) \\<Rightarrow>\n            (case a of\n             (Ts, a) \\<Rightarrow>\n               case a of\n               (T, m) \\<Rightarrow>\n                 \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n             b)\n      (Mm M));\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>M.\n                             map_option\n                              (\\<lambda>a.\n                                  case a of\n                                  (a, b) \\<Rightarrow>\n                                    (case a of\n                                     (Ts, a) \\<Rightarrow>\n case a of\n (T, m) \\<Rightarrow> \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n                                     b)\n                              (Mm' M)) =\n                         ?Mm14 C D fs ms Mm Mm' ++\n                         (map_option (\\<lambda>m. (m, C)) \\<circ>\n                          map_of (?ms14 C D fs ms Mm Mm'))", "apply(erule class_compP)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods (\\<lambda>M.\n     map_option\n      (\\<lambda>a.\n          case a of\n          (a, b) \\<Rightarrow>\n            (case a of\n             (Ts, a) \\<Rightarrow>\n               case a of\n               (T, m) \\<Rightarrow>\n                 \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n             b)\n      (Mm M));\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> C \\<noteq> Object\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods (\\<lambda>M.\n     map_option\n      (\\<lambda>a.\n          case a of\n          (a, b) \\<Rightarrow>\n            (case a of\n             (Ts, a) \\<Rightarrow>\n               case a of\n               (T, m) \\<Rightarrow>\n                 \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n             b)\n      (Mm M));\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> compP f\n                          P \\<turnstile> D sees_methods ?Mm14 C D fs ms Mm\n                   Mm'\n 3. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods (\\<lambda>M.\n     map_option\n      (\\<lambda>a.\n          case a of\n          (a, b) \\<Rightarrow>\n            (case a of\n             (Ts, a) \\<Rightarrow>\n               case a of\n               (T, m) \\<Rightarrow>\n                 \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n             b)\n      (Mm M));\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>M.\n                             map_option\n                              (\\<lambda>a.\n                                  case a of\n                                  (a, b) \\<Rightarrow>\n                                    (case a of\n                                     (Ts, a) \\<Rightarrow>\n case a of\n (T, m) \\<Rightarrow> \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n                                     b)\n                              (Mm' M)) =\n                         ?Mm14 C D fs ms Mm Mm' ++\n                         (map_option (\\<lambda>m. (m, C)) \\<circ>\n                          map_of (map (compM (f C)) ms))", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods (\\<lambda>M.\n     map_option\n      (\\<lambda>a.\n          case a of\n          (a, b) \\<Rightarrow>\n            (case a of\n             (Ts, a) \\<Rightarrow>\n               case a of\n               (T, m) \\<Rightarrow>\n                 \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n             b)\n      (Mm M));\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> compP f\n                          P \\<turnstile> D sees_methods ?Mm14 C D fs ms Mm\n                   Mm'\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods (\\<lambda>M.\n     map_option\n      (\\<lambda>a.\n          case a of\n          (a, b) \\<Rightarrow>\n            (case a of\n             (Ts, a) \\<Rightarrow>\n               case a of\n               (T, m) \\<Rightarrow>\n                 \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n             b)\n      (Mm M));\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>M.\n                             map_option\n                              (\\<lambda>a.\n                                  case a of\n                                  (a, b) \\<Rightarrow>\n                                    (case a of\n                                     (Ts, a) \\<Rightarrow>\n case a of\n (T, m) \\<Rightarrow> \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n                                     b)\n                              (Mm' M)) =\n                         ?Mm14 C D fs ms Mm Mm' ++\n                         (map_option (\\<lambda>m. (m, C)) \\<circ>\n                          map_of (map (compM (f C)) ms))", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods (\\<lambda>M.\n     map_option\n      (\\<lambda>a.\n          case a of\n          (a, b) \\<Rightarrow>\n            (case a of\n             (Ts, a) \\<Rightarrow>\n               case a of\n               (T, m) \\<Rightarrow>\n                 \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n             b)\n      (Mm M));\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>M.\n                             map_option\n                              (\\<lambda>a.\n                                  case a of\n                                  (a, b) \\<Rightarrow>\n                                    (case a of\n                                     (Ts, a) \\<Rightarrow>\n case a of\n (T, m) \\<Rightarrow> \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n                                     b)\n                              (Mm' M)) =\n                         (\\<lambda>M.\n                             map_option\n                              (\\<lambda>a.\n                                  case a of\n                                  (a, b) \\<Rightarrow>\n                                    (case a of\n                                     (Ts, a) \\<Rightarrow>\n case a of\n (T, m) \\<Rightarrow> \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n                                     b)\n                              (Mm M)) ++\n                         (map_option (\\<lambda>m. (m, C)) \\<circ>\n                          map_of (map (compM (f C)) ms))", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms Mm Mm' M.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods (\\<lambda>M.\n     map_option\n      (\\<lambda>a.\n          case a of\n          (a, b) \\<Rightarrow>\n            (case a of\n             (Ts, a) \\<Rightarrow>\n               case a of\n               (T, m) \\<Rightarrow>\n                 \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n             b)\n      (Mm M));\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> map_option\n                          (\\<lambda>a.\n                              case a of\n                              (a, b) \\<Rightarrow>\n                                (case a of\n                                 (Ts, a) \\<Rightarrow>\n                                   case a of\n                                   (T, m) \\<Rightarrow>\n                                     \\<lambda>D.\n  ((Ts, T, map_option (f D M Ts T) m), D))\n                                 b)\n                          (Mm' M) =\n                         ((\\<lambda>M.\n                              map_option\n                               (\\<lambda>a.\n                                   case a of\n                                   (a, b) \\<Rightarrow>\n                                     (case a of\n(Ts, a) \\<Rightarrow>\n  case a of\n  (T, m) \\<Rightarrow> \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\nb)\n                               (Mm M)) ++\n                          (map_option (\\<lambda>m. (m, C)) \\<circ>\n                           map_of (map (compM (f C)) ms)))\n                          M", "apply(simp add:map_add_def compM_def map_of_map4 option.map_comp split:option.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma sees_method_compP:\n  \"P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n  compP f P \\<turnstile> C sees M: Ts\\<rightarrow>T = map_option (f D M Ts T) m in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    compP f\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = map_option (f D M Ts T)\n            m in D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    compP f\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = map_option (f D M Ts T)\n            m in D", "by(fastforce elim:sees_methods_compP simp add:Method_def)"], ["", "(*>*)"], ["", "lemma [simp]:\n  \"P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n  method (compP f P) C M = (D,Ts,T,map_option (f D M Ts T) m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    method (compP f P) C M = (D, Ts, T, map_option (f D M Ts T) m)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    method (compP f P) C M = (D, Ts, T, map_option (f D M Ts T) m)", "apply(drule sees_method_compP)"], ["proof (prove)\ngoal (1 subgoal):\n 1. compP ?f\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = map_option (?f D M Ts T)\n            m in D \\<Longrightarrow>\n    method (compP f P) C M = (D, Ts, T, map_option (f D M Ts T) m)", "apply(simp add:method_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. compP ?f\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = map_option (?f D M Ts T)\n            m in D \\<Longrightarrow>\n    (THE (D, Ts, T, m).\n        compP f P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D) =\n    (D, Ts, T, map_option (f D M Ts T) m)", "apply(rule the_equality)"], ["proof (prove)\ngoal (2 subgoals):\n 1. compP ?f\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = map_option (?f D M Ts T)\n            m in D \\<Longrightarrow>\n    case (D, Ts, T, map_option (f D M Ts T) m) of\n    (D, Ts, T, m) \\<Rightarrow>\n      compP f P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D\n 2. \\<And>x.\n       \\<lbrakk>compP ?f\n                 P \\<turnstile> C sees M: Ts\\<rightarrow>T = map_option\n                        (?f D M Ts T) m in D;\n        case x of\n        (D, Ts, T, m) \\<Rightarrow>\n          compP f\n           P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D\\<rbrakk>\n       \\<Longrightarrow> x = (D, Ts, T, map_option (f D M Ts T) m)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>compP f\n                 P \\<turnstile> C sees M: Ts\\<rightarrow>T = map_option\n                        (f D M Ts T) m in D;\n        case x of\n        (D, Ts, T, m) \\<Rightarrow>\n          compP f\n           P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D\\<rbrakk>\n       \\<Longrightarrow> x = (D, Ts, T, map_option (f D M Ts T) m)", "apply(fastforce dest:sees_method_fun)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma sees_methods_compPD:\n  \"\\<lbrakk> cP \\<turnstile> C sees_methods Mm'; cP = compP f P \\<rbrakk> \\<Longrightarrow>\n  \\<exists>Mm. P \\<turnstile> C sees_methods Mm \\<and>\n        Mm' = (\\<lambda>M. map_option (\\<lambda>((Ts,T,m),D). ((Ts,T,map_option (f D M Ts T) m),D)) (Mm M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cP \\<turnstile> C sees_methods Mm'; cP = compP f P\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Mm.\n                         P \\<turnstile> C sees_methods Mm \\<and>\n                         Mm' =\n                         (\\<lambda>M.\n                             map_option\n                              (\\<lambda>((Ts, T, m), D).\n                                  ((Ts, T, map_option (f D M Ts T) m), D))\n                              (Mm M))", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cP \\<turnstile> C sees_methods Mm'; cP = compP f P\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Mm.\n                         P \\<turnstile> C sees_methods Mm \\<and>\n                         Mm' =\n                         (\\<lambda>M.\n                             map_option\n                              (\\<lambda>((Ts, T, m), D).\n                                  ((Ts, T, map_option (f D M Ts T) m), D))\n                              (Mm M))", "apply(erule Methods.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm.\n       \\<lbrakk>cP = compP f P;\n        class cP Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mma.\n                            P \\<turnstile> Object sees_methods Mma \\<and>\n                            Mm =\n                            (\\<lambda>M.\n                                map_option\n                                 (\\<lambda>a.\n                                     case a of\n                                     (a, b) \\<Rightarrow>\n (case a of\n  (Ts, a) \\<Rightarrow>\n    case a of\n    (T, m) \\<Rightarrow>\n      \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n  b)\n                                 (Mma M))\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>cP = compP f P; class cP C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; cP \\<turnstile> D sees_methods Mm;\n        \\<exists>Mma.\n           P \\<turnstile> D sees_methods Mma \\<and>\n           Mm =\n           (\\<lambda>M.\n               map_option\n                (\\<lambda>a.\n                    case a of\n                    (a, b) \\<Rightarrow>\n                      (case a of\n                       (Ts, a) \\<Rightarrow>\n                         case a of\n                         (T, m) \\<Rightarrow>\n                           \\<lambda>D.\n                              ((Ts, T, map_option (f D M Ts T) m), D))\n                       b)\n                (Mma M));\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm.\n                            P \\<turnstile> C sees_methods Mm \\<and>\n                            Mm' =\n                            (\\<lambda>M.\n                                map_option\n                                 (\\<lambda>a.\n                                     case a of\n                                     (a, b) \\<Rightarrow>\n (case a of\n  (Ts, a) \\<Rightarrow>\n    case a of\n    (T, m) \\<Rightarrow>\n      \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n  b)\n                                 (Mm M))", "apply(clarsimp simp:compC_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D fs b.\n       \\<lbrakk>cP = compP f P;\n        class P Object = \\<lfloor>(D, fs, b)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm.\n                            P \\<turnstile> Object sees_methods Mm \\<and>\n                            (\\<lambda>a.\n                                map_option (\\<lambda>m. (m, Object))\n                                 (map_of (map (compM (f Object)) b) a)) =\n                            (\\<lambda>M.\n                                map_option\n                                 (\\<lambda>((Ts, T, m), D).\n                                     ((Ts, T, map_option (f D M Ts T) m),\nD))\n                                 (Mm M))\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>cP = compP f P; class cP C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; cP \\<turnstile> D sees_methods Mm;\n        \\<exists>Mma.\n           P \\<turnstile> D sees_methods Mma \\<and>\n           Mm =\n           (\\<lambda>M.\n               map_option\n                (\\<lambda>a.\n                    case a of\n                    (a, b) \\<Rightarrow>\n                      (case a of\n                       (Ts, a) \\<Rightarrow>\n                         case a of\n                         (T, m) \\<Rightarrow>\n                           \\<lambda>D.\n                              ((Ts, T, map_option (f D M Ts T) m), D))\n                       b)\n                (Mma M));\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm.\n                            P \\<turnstile> C sees_methods Mm \\<and>\n                            Mm' =\n                            (\\<lambda>M.\n                                map_option\n                                 (\\<lambda>a.\n                                     case a of\n                                     (a, b) \\<Rightarrow>\n (case a of\n  (Ts, a) \\<Rightarrow>\n    case a of\n    (T, m) \\<Rightarrow>\n      \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n  b)\n                                 (Mm M))", "apply(rule exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D fs b.\n       \\<lbrakk>cP = compP f P;\n        class P Object = \\<lfloor>(D, fs, b)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Object sees_methods ?Mm12 D fs\n                       b \\<and>\n                         (\\<lambda>a.\n                             map_option (\\<lambda>m. (m, Object))\n                              (map_of (map (compM (f Object)) b) a)) =\n                         (\\<lambda>M.\n                             map_option\n                              (\\<lambda>((Ts, T, m), D).\n                                  ((Ts, T, map_option (f D M Ts T) m), D))\n                              (?Mm12 D fs b M))\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>cP = compP f P; class cP C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; cP \\<turnstile> D sees_methods Mm;\n        \\<exists>Mma.\n           P \\<turnstile> D sees_methods Mma \\<and>\n           Mm =\n           (\\<lambda>M.\n               map_option\n                (\\<lambda>a.\n                    case a of\n                    (a, b) \\<Rightarrow>\n                      (case a of\n                       (Ts, a) \\<Rightarrow>\n                         case a of\n                         (T, m) \\<Rightarrow>\n                           \\<lambda>D.\n                              ((Ts, T, map_option (f D M Ts T) m), D))\n                       b)\n                (Mma M));\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm.\n                            P \\<turnstile> C sees_methods Mm \\<and>\n                            Mm' =\n                            (\\<lambda>M.\n                                map_option\n                                 (\\<lambda>a.\n                                     case a of\n                                     (a, b) \\<Rightarrow>\n (case a of\n  (Ts, a) \\<Rightarrow>\n    case a of\n    (T, m) \\<Rightarrow>\n      \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n  b)\n                                 (Mm M))", "apply(rule conjI, erule sees_methods_Object)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>D fs b.\n       cP = compP f P \\<Longrightarrow>\n       ?Mm12 D fs b = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of b\n 2. \\<And>D fs b.\n       \\<lbrakk>cP = compP f P;\n        class P Object = \\<lfloor>(D, fs, b)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>a.\n                             map_option (\\<lambda>m. (m, Object))\n                              (map_of (map (compM (f Object)) b) a)) =\n                         (\\<lambda>M.\n                             map_option\n                              (\\<lambda>((Ts, T, m), D).\n                                  ((Ts, T, map_option (f D M Ts T) m), D))\n                              (?Mm12 D fs b M))\n 3. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>cP = compP f P; class cP C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; cP \\<turnstile> D sees_methods Mm;\n        \\<exists>Mma.\n           P \\<turnstile> D sees_methods Mma \\<and>\n           Mm =\n           (\\<lambda>M.\n               map_option\n                (\\<lambda>a.\n                    case a of\n                    (a, b) \\<Rightarrow>\n                      (case a of\n                       (Ts, a) \\<Rightarrow>\n                         case a of\n                         (T, m) \\<Rightarrow>\n                           \\<lambda>D.\n                              ((Ts, T, map_option (f D M Ts T) m), D))\n                       b)\n                (Mma M));\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm.\n                            P \\<turnstile> C sees_methods Mm \\<and>\n                            Mm' =\n                            (\\<lambda>M.\n                                map_option\n                                 (\\<lambda>a.\n                                     case a of\n                                     (a, b) \\<Rightarrow>\n (case a of\n  (Ts, a) \\<Rightarrow>\n    case a of\n    (T, m) \\<Rightarrow>\n      \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n  b)\n                                 (Mm M))", "apply(rule refl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D fs b.\n       \\<lbrakk>cP = compP f P;\n        class P Object = \\<lfloor>(D, fs, b)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>a.\n                             map_option (\\<lambda>m. (m, Object))\n                              (map_of (map (compM (f Object)) b) a)) =\n                         (\\<lambda>M.\n                             map_option\n                              (\\<lambda>((Ts, T, m), D).\n                                  ((Ts, T, map_option (f D M Ts T) m), D))\n                              ((map_option (\\<lambda>m. (m, Object)) \\<circ>\n                                map_of b)\n                                M))\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>cP = compP f P; class cP C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; cP \\<turnstile> D sees_methods Mm;\n        \\<exists>Mma.\n           P \\<turnstile> D sees_methods Mma \\<and>\n           Mm =\n           (\\<lambda>M.\n               map_option\n                (\\<lambda>a.\n                    case a of\n                    (a, b) \\<Rightarrow>\n                      (case a of\n                       (Ts, a) \\<Rightarrow>\n                         case a of\n                         (T, m) \\<Rightarrow>\n                           \\<lambda>D.\n                              ((Ts, T, map_option (f D M Ts T) m), D))\n                       b)\n                (Mma M));\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm.\n                            P \\<turnstile> C sees_methods Mm \\<and>\n                            Mm' =\n                            (\\<lambda>M.\n                                map_option\n                                 (\\<lambda>a.\n                                     case a of\n                                     (a, b) \\<Rightarrow>\n (case a of\n  (Ts, a) \\<Rightarrow>\n    case a of\n    (T, m) \\<Rightarrow>\n      \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n  b)\n                                 (Mm M))", "apply(rule ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D fs b M.\n       \\<lbrakk>cP = compP f P;\n        class P Object = \\<lfloor>(D, fs, b)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> map_option (\\<lambda>m. (m, Object))\n                          (map_of (map (compM (f Object)) b) M) =\n                         map_option\n                          (\\<lambda>((Ts, T, m), D).\n                              ((Ts, T, map_option (f D M Ts T) m), D))\n                          ((map_option (\\<lambda>m. (m, Object)) \\<circ>\n                            map_of b)\n                            M)\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>cP = compP f P; class cP C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; cP \\<turnstile> D sees_methods Mm;\n        \\<exists>Mma.\n           P \\<turnstile> D sees_methods Mma \\<and>\n           Mm =\n           (\\<lambda>M.\n               map_option\n                (\\<lambda>a.\n                    case a of\n                    (a, b) \\<Rightarrow>\n                      (case a of\n                       (Ts, a) \\<Rightarrow>\n                         case a of\n                         (T, m) \\<Rightarrow>\n                           \\<lambda>D.\n                              ((Ts, T, map_option (f D M Ts T) m), D))\n                       b)\n                (Mma M));\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm.\n                            P \\<turnstile> C sees_methods Mm \\<and>\n                            Mm' =\n                            (\\<lambda>M.\n                                map_option\n                                 (\\<lambda>a.\n                                     case a of\n                                     (a, b) \\<Rightarrow>\n (case a of\n  (Ts, a) \\<Rightarrow>\n    case a of\n    (T, m) \\<Rightarrow>\n      \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n  b)\n                                 (Mm M))", "apply(simp add:compM_def map_of_map4 option.map_comp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D fs b M.\n       \\<lbrakk>cP = compP f P;\n        class P Object = \\<lfloor>(D, fs, b)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> map_option\n                          ((\\<lambda>m. (m, Object)) \\<circ>\n                           (\\<lambda>(Ts, T, m).\n                               (Ts, T, map_option (f Object M Ts T) m)))\n                          (map_of b M) =\n                         map_option\n                          ((\\<lambda>((Ts, T, m), D).\n                               ((Ts, T, map_option (f D M Ts T) m),\n                                D)) \\<circ>\n                           (\\<lambda>m. (m, Object)))\n                          (map_of b M)\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>cP = compP f P; class cP C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; cP \\<turnstile> D sees_methods Mm;\n        \\<exists>Mma.\n           P \\<turnstile> D sees_methods Mma \\<and>\n           Mm =\n           (\\<lambda>M.\n               map_option\n                (\\<lambda>a.\n                    case a of\n                    (a, b) \\<Rightarrow>\n                      (case a of\n                       (Ts, a) \\<Rightarrow>\n                         case a of\n                         (T, m) \\<Rightarrow>\n                           \\<lambda>D.\n                              ((Ts, T, map_option (f D M Ts T) m), D))\n                       b)\n                (Mma M));\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm.\n                            P \\<turnstile> C sees_methods Mm \\<and>\n                            Mm' =\n                            (\\<lambda>M.\n                                map_option\n                                 (\\<lambda>a.\n                                     case a of\n                                     (a, b) \\<Rightarrow>\n (case a of\n  (Ts, a) \\<Rightarrow>\n    case a of\n    (T, m) \\<Rightarrow>\n      \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n  b)\n                                 (Mm M))", "apply(case_tac \"map_of b M\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>D fs b M.\n       \\<lbrakk>cP = compP f P;\n        class P Object = \\<lfloor>(D, fs, b)\\<rfloor>;\n        map_of b M = None\\<rbrakk>\n       \\<Longrightarrow> map_option\n                          ((\\<lambda>m. (m, Object)) \\<circ>\n                           (\\<lambda>(Ts, T, m).\n                               (Ts, T, map_option (f Object M Ts T) m)))\n                          (map_of b M) =\n                         map_option\n                          ((\\<lambda>((Ts, T, m), D).\n                               ((Ts, T, map_option (f D M Ts T) m),\n                                D)) \\<circ>\n                           (\\<lambda>m. (m, Object)))\n                          (map_of b M)\n 2. \\<And>D fs b M a.\n       \\<lbrakk>cP = compP f P;\n        class P Object = \\<lfloor>(D, fs, b)\\<rfloor>;\n        map_of b M = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> map_option\n                          ((\\<lambda>m. (m, Object)) \\<circ>\n                           (\\<lambda>(Ts, T, m).\n                               (Ts, T, map_option (f Object M Ts T) m)))\n                          (map_of b M) =\n                         map_option\n                          ((\\<lambda>((Ts, T, m), D).\n                               ((Ts, T, map_option (f D M Ts T) m),\n                                D)) \\<circ>\n                           (\\<lambda>m. (m, Object)))\n                          (map_of b M)\n 3. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>cP = compP f P; class cP C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; cP \\<turnstile> D sees_methods Mm;\n        \\<exists>Mma.\n           P \\<turnstile> D sees_methods Mma \\<and>\n           Mm =\n           (\\<lambda>M.\n               map_option\n                (\\<lambda>a.\n                    case a of\n                    (a, b) \\<Rightarrow>\n                      (case a of\n                       (Ts, a) \\<Rightarrow>\n                         case a of\n                         (T, m) \\<Rightarrow>\n                           \\<lambda>D.\n                              ((Ts, T, map_option (f D M Ts T) m), D))\n                       b)\n                (Mma M));\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm.\n                            P \\<turnstile> C sees_methods Mm \\<and>\n                            Mm' =\n                            (\\<lambda>M.\n                                map_option\n                                 (\\<lambda>a.\n                                     case a of\n                                     (a, b) \\<Rightarrow>\n (case a of\n  (Ts, a) \\<Rightarrow>\n    case a of\n    (T, m) \\<Rightarrow>\n      \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n  b)\n                                 (Mm M))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D fs b M a.\n       \\<lbrakk>cP = compP f P;\n        class P Object = \\<lfloor>(D, fs, b)\\<rfloor>;\n        map_of b M = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> map_option\n                          ((\\<lambda>m. (m, Object)) \\<circ>\n                           (\\<lambda>(Ts, T, m).\n                               (Ts, T, map_option (f Object M Ts T) m)))\n                          (map_of b M) =\n                         map_option\n                          ((\\<lambda>((Ts, T, m), D).\n                               ((Ts, T, map_option (f D M Ts T) m),\n                                D)) \\<circ>\n                           (\\<lambda>m. (m, Object)))\n                          (map_of b M)\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>cP = compP f P; class cP C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; cP \\<turnstile> D sees_methods Mm;\n        \\<exists>Mma.\n           P \\<turnstile> D sees_methods Mma \\<and>\n           Mm =\n           (\\<lambda>M.\n               map_option\n                (\\<lambda>a.\n                    case a of\n                    (a, b) \\<Rightarrow>\n                      (case a of\n                       (Ts, a) \\<Rightarrow>\n                         case a of\n                         (T, m) \\<Rightarrow>\n                           \\<lambda>D.\n                              ((Ts, T, map_option (f D M Ts T) m), D))\n                       b)\n                (Mma M));\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm.\n                            P \\<turnstile> C sees_methods Mm \\<and>\n                            Mm' =\n                            (\\<lambda>M.\n                                map_option\n                                 (\\<lambda>a.\n                                     case a of\n                                     (a, b) \\<Rightarrow>\n (case a of\n  (Ts, a) \\<Rightarrow>\n    case a of\n    (T, m) \\<Rightarrow>\n      \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n  b)\n                                 (Mm M))", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>cP = compP f P; class cP C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; cP \\<turnstile> D sees_methods Mm;\n        \\<exists>Mma.\n           P \\<turnstile> D sees_methods Mma \\<and>\n           Mm =\n           (\\<lambda>M.\n               map_option\n                (\\<lambda>a.\n                    case a of\n                    (a, b) \\<Rightarrow>\n                      (case a of\n                       (Ts, a) \\<Rightarrow>\n                         case a of\n                         (T, m) \\<Rightarrow>\n                           \\<lambda>D.\n                              ((Ts, T, map_option (f D M Ts T) m), D))\n                       b)\n                (Mma M));\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm.\n                            P \\<turnstile> C sees_methods Mm \\<and>\n                            Mm' =\n                            (\\<lambda>M.\n                                map_option\n                                 (\\<lambda>a.\n                                     case a of\n                                     (a, b) \\<Rightarrow>\n (case a of\n  (Ts, a) \\<Rightarrow>\n    case a of\n    (T, m) \\<Rightarrow>\n      \\<lambda>D. ((Ts, T, map_option (f D M Ts T) m), D))\n  b)\n                                 (Mm M))", "apply(clarsimp simp:compC_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs b Mma.\n       \\<lbrakk>cP = compP f P; C \\<noteq> Object;\n        compP f\n         P \\<turnstile> D sees_methods (\\<lambda>M.\n     map_option\n      (\\<lambda>((Ts, T, m), D). ((Ts, T, map_option (f D M Ts T) m), D))\n      (Mma M));\n        class P C = \\<lfloor>(D, fs, b)\\<rfloor>;\n        P \\<turnstile> D sees_methods Mma\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm.\n                            P \\<turnstile> C sees_methods Mm \\<and>\n                            (\\<lambda>M.\n                                map_option\n                                 (\\<lambda>((Ts, T, m), D).\n                                     ((Ts, T, map_option (f D M Ts T) m),\nD))\n                                 (Mma M)) ++\n                            (map_option (\\<lambda>m. (m, C)) \\<circ>\n                             map_of (map (compM (f C)) b)) =\n                            (\\<lambda>M.\n                                map_option\n                                 (\\<lambda>((Ts, T, m), D).\n                                     ((Ts, T, map_option (f D M Ts T) m),\nD))\n                                 (Mm M))", "apply(rule exI, rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C D fs b Mma.\n       \\<lbrakk>cP = compP f P; C \\<noteq> Object;\n        compP f\n         P \\<turnstile> D sees_methods (\\<lambda>M.\n     map_option\n      (\\<lambda>((Ts, T, m), D). ((Ts, T, map_option (f D M Ts T) m), D))\n      (Mma M));\n        class P C = \\<lfloor>(D, fs, b)\\<rfloor>;\n        P \\<turnstile> D sees_methods Mma\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C sees_methods ?Mm32 C D fs b Mma\n 2. \\<And>C D fs b Mma.\n       \\<lbrakk>cP = compP f P; C \\<noteq> Object;\n        compP f\n         P \\<turnstile> D sees_methods (\\<lambda>M.\n     map_option\n      (\\<lambda>((Ts, T, m), D). ((Ts, T, map_option (f D M Ts T) m), D))\n      (Mma M));\n        class P C = \\<lfloor>(D, fs, b)\\<rfloor>;\n        P \\<turnstile> D sees_methods Mma\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>M.\n                             map_option\n                              (\\<lambda>((Ts, T, m), D).\n                                  ((Ts, T, map_option (f D M Ts T) m), D))\n                              (Mma M)) ++\n                         (map_option (\\<lambda>m. (m, C)) \\<circ>\n                          map_of (map (compM (f C)) b)) =\n                         (\\<lambda>M.\n                             map_option\n                              (\\<lambda>((Ts, T, m), D).\n                                  ((Ts, T, map_option (f D M Ts T) m), D))\n                              (?Mm32 C D fs b Mma M))", "apply(erule (2) sees_methods_rec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C D fs b Mma.\n       \\<lbrakk>cP = compP f P; C \\<noteq> Object;\n        compP f\n         P \\<turnstile> D sees_methods (\\<lambda>M.\n     map_option\n      (\\<lambda>((Ts, T, m), D). ((Ts, T, map_option (f D M Ts T) m), D))\n      (Mma M));\n        P \\<turnstile> D sees_methods Mma\\<rbrakk>\n       \\<Longrightarrow> ?Mm32 C D fs b Mma =\n                         Mma ++\n                         (map_option (\\<lambda>m. (m, C)) \\<circ> map_of b)\n 2. \\<And>C D fs b Mma.\n       \\<lbrakk>cP = compP f P; C \\<noteq> Object;\n        compP f\n         P \\<turnstile> D sees_methods (\\<lambda>M.\n     map_option\n      (\\<lambda>((Ts, T, m), D). ((Ts, T, map_option (f D M Ts T) m), D))\n      (Mma M));\n        class P C = \\<lfloor>(D, fs, b)\\<rfloor>;\n        P \\<turnstile> D sees_methods Mma\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>M.\n                             map_option\n                              (\\<lambda>((Ts, T, m), D).\n                                  ((Ts, T, map_option (f D M Ts T) m), D))\n                              (Mma M)) ++\n                         (map_option (\\<lambda>m. (m, C)) \\<circ>\n                          map_of (map (compM (f C)) b)) =\n                         (\\<lambda>M.\n                             map_option\n                              (\\<lambda>((Ts, T, m), D).\n                                  ((Ts, T, map_option (f D M Ts T) m), D))\n                              (?Mm32 C D fs b Mma M))", "apply(rule refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs b Mma.\n       \\<lbrakk>cP = compP f P; C \\<noteq> Object;\n        compP f\n         P \\<turnstile> D sees_methods (\\<lambda>M.\n     map_option\n      (\\<lambda>((Ts, T, m), D). ((Ts, T, map_option (f D M Ts T) m), D))\n      (Mma M));\n        class P C = \\<lfloor>(D, fs, b)\\<rfloor>;\n        P \\<turnstile> D sees_methods Mma\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>M.\n                             map_option\n                              (\\<lambda>((Ts, T, m), D).\n                                  ((Ts, T, map_option (f D M Ts T) m), D))\n                              (Mma M)) ++\n                         (map_option (\\<lambda>m. (m, C)) \\<circ>\n                          map_of (map (compM (f C)) b)) =\n                         (\\<lambda>M.\n                             map_option\n                              (\\<lambda>((Ts, T, m), D).\n                                  ((Ts, T, map_option (f D M Ts T) m), D))\n                              ((Mma ++\n                                (map_option (\\<lambda>m. (m, C)) \\<circ>\n                                 map_of b))\n                                M))", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs b Mma M.\n       \\<lbrakk>cP = compP f P; C \\<noteq> Object;\n        compP f\n         P \\<turnstile> D sees_methods (\\<lambda>M.\n     map_option\n      (\\<lambda>((Ts, T, m), D). ((Ts, T, map_option (f D M Ts T) m), D))\n      (Mma M));\n        class P C = \\<lfloor>(D, fs, b)\\<rfloor>;\n        P \\<turnstile> D sees_methods Mma\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>M.\n                              map_option\n                               (\\<lambda>((Ts, T, m), D).\n                                   ((Ts, T, map_option (f D M Ts T) m), D))\n                               (Mma M)) ++\n                          (map_option (\\<lambda>m. (m, C)) \\<circ>\n                           map_of (map (compM (f C)) b)))\n                          M =\n                         map_option\n                          (\\<lambda>((Ts, T, m), D).\n                              ((Ts, T, map_option (f D M Ts T) m), D))\n                          ((Mma ++\n                            (map_option (\\<lambda>m. (m, C)) \\<circ>\n                             map_of b))\n                            M)", "apply(simp add:map_add_def compM_def map_of_map4 option.map_comp split:option.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma sees_method_compPD:\n  \"compP f P \\<turnstile> C sees M: Ts\\<rightarrow>T = fm in D \\<Longrightarrow>\n  \\<exists>m. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<and> map_option (f D M Ts T) m = fm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compP f\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = fm in D \\<Longrightarrow>\n    \\<exists>m.\n       P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<and>\n       map_option (f D M Ts T) m = fm", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. compP f\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = fm in D \\<Longrightarrow>\n    \\<exists>m.\n       P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<and>\n       map_option (f D M Ts T) m = fm", "apply(simp add:Method_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Mm.\n       compP f P \\<turnstile> C sees_methods Mm \\<and>\n       Mm M = \\<lfloor>((Ts, T, fm), D)\\<rfloor> \\<Longrightarrow>\n    \\<exists>m.\n       (\\<exists>Mm.\n           P \\<turnstile> C sees_methods Mm \\<and>\n           Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>) \\<and>\n       map_option (f D M Ts T) m = fm", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Mm.\n       \\<lbrakk>compP f P \\<turnstile> C sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, fm), D)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            (\\<exists>Mm.\n                                P \\<turnstile> C sees_methods Mm \\<and>\n                                Mm M =\n                                \\<lfloor>((Ts, T, m), D)\\<rfloor>) \\<and>\n                            map_option (f D M Ts T) m = fm", "apply(drule sees_methods_compPD[OF _ refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Mm.\n       \\<lbrakk>Mm M = \\<lfloor>((Ts, T, fm), D)\\<rfloor>;\n        \\<exists>Mma.\n           P \\<turnstile> C sees_methods Mma \\<and>\n           Mm =\n           (\\<lambda>M.\n               map_option\n                (\\<lambda>((Ts, T, m), D).\n                    ((Ts, T, map_option (f D M Ts T) m), D))\n                (Mma M))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            (\\<exists>Mm.\n                                P \\<turnstile> C sees_methods Mm \\<and>\n                                Mm M =\n                                \\<lfloor>((Ts, T, m), D)\\<rfloor>) \\<and>\n                            map_option (f D M Ts T) m = fm", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Mma b.\n       \\<lbrakk>P \\<turnstile> C sees_methods Mma;\n        Mma M = \\<lfloor>((Ts, T, b), D)\\<rfloor>;\n        fm = map_option (f D M Ts T) b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            (\\<exists>Mm.\n                                P \\<turnstile> C sees_methods Mm \\<and>\n                                Mm M =\n                                \\<lfloor>((Ts, T, m), D)\\<rfloor>) \\<and>\n                            map_option (f D M Ts T) m =\n                            map_option (f D M Ts T) b", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma sees_method_native_compP [simp]:\n  \"compP f P \\<turnstile> C sees M:Ts \\<rightarrow> T = Native in D \\<longleftrightarrow> P \\<turnstile> C sees M:Ts \\<rightarrow> T = Native in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (compP f P \\<turnstile> C sees M: Ts\\<rightarrow>T = Native in D) =\n    (P \\<turnstile> C sees M: Ts\\<rightarrow>T = Native in D)", "by(auto dest: sees_method_compPD sees_method_compP)"], ["", "lemma [simp]: \"subcls1(compP f P) = subcls1 P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subcls1 (compP f P) = subcls1 P", "by(fastforce simp add: is_class_def compC_def intro:subcls1I order_antisym dest:subcls1D)"], ["", "lemma [simp]: \"is_type (compP f P) T = is_type P T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_type (compP f P) T = is_type P T", "by(induct T)(auto cong: ty.case_cong)"], ["", "lemma is_type_compP [simp]: \"is_type (compP f P) = is_type P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_type (compP f P) = is_type P", "by auto"], ["", "lemma compP_widen[simp]:\n  \"(compP f P \\<turnstile> T \\<le> T') = (P \\<turnstile> T \\<le> T')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compP f P \\<turnstile> T \\<le> T' = P \\<turnstile> T \\<le> T'", "by(induct T' arbitrary: T)(simp_all add: widen_Class widen_Array)"], ["", "lemma [simp]: \"(compP f P \\<turnstile> Ts [\\<le>] Ts') = (P \\<turnstile> Ts [\\<le>] Ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compP f P \\<turnstile> Ts [\\<le>] Ts' = P \\<turnstile> Ts [\\<le>] Ts'", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. compP f P \\<turnstile> Ts [\\<le>] Ts' = P \\<turnstile> Ts [\\<le>] Ts'", "apply(induct Ts)"], ["proof (prove)\ngoal (2 subgoals):\n 1. compP f P \\<turnstile> [] [\\<le>] Ts' = P \\<turnstile> [] [\\<le>] Ts'\n 2. \\<And>a Ts.\n       compP f P \\<turnstile> Ts [\\<le>] Ts' =\n       P \\<turnstile> Ts [\\<le>] Ts' \\<Longrightarrow>\n       compP f P \\<turnstile> (a # Ts) [\\<le>] Ts' =\n       P \\<turnstile> (a # Ts) [\\<le>] Ts'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a Ts.\n       compP f P \\<turnstile> Ts [\\<le>] Ts' =\n       P \\<turnstile> Ts [\\<le>] Ts' \\<Longrightarrow>\n       compP f P \\<turnstile> (a # Ts) [\\<le>] Ts' =\n       P \\<turnstile> (a # Ts) [\\<le>] Ts'", "apply(cases Ts')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a Ts.\n       \\<lbrakk>compP f P \\<turnstile> Ts [\\<le>] Ts' =\n                P \\<turnstile> Ts [\\<le>] Ts';\n        Ts' = []\\<rbrakk>\n       \\<Longrightarrow> compP f P \\<turnstile> (a # Ts) [\\<le>] Ts' =\n                         P \\<turnstile> (a # Ts) [\\<le>] Ts'\n 2. \\<And>a Ts aa list.\n       \\<lbrakk>compP f P \\<turnstile> Ts [\\<le>] Ts' =\n                P \\<turnstile> Ts [\\<le>] Ts';\n        Ts' = aa # list\\<rbrakk>\n       \\<Longrightarrow> compP f P \\<turnstile> (a # Ts) [\\<le>] Ts' =\n                         P \\<turnstile> (a # Ts) [\\<le>] Ts'", "apply(auto simp:fun_of_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma is_lub_compP [simp]:\n  \"is_lub (compP f P) = is_lub P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_lub (compP f P) = is_lub P", "by(auto intro!: ext elim!: is_lub.cases intro: is_lub.intros)"], ["", "lemma [simp]:\n  fixes f :: \"cname \\<Rightarrow> mname \\<Rightarrow> ty list \\<Rightarrow> ty \\<Rightarrow> 'a \\<Rightarrow> 'b\"\n  shows \"(compP f P \\<turnstile> C has_fields FDTs) = (P \\<turnstile> C has_fields FDTs)\"\n(*<*)\n (is \"?A = ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (compP f P \\<turnstile> C has_fields FDTs) =\n    (P \\<turnstile> C has_fields FDTs)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. compP f P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    P \\<turnstile> C has_fields FDTs\n 2. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    compP f P \\<turnstile> C has_fields FDTs", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. compP f P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    P \\<turnstile> C has_fields FDTs\n 2. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    compP f P \\<turnstile> C has_fields FDTs", "fix cP::\"'b prog\""], ["proof (state)\ngoal (2 subgoals):\n 1. compP f P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    P \\<turnstile> C has_fields FDTs\n 2. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    compP f P \\<turnstile> C has_fields FDTs", "assume \"cP \\<turnstile> C has_fields FDTs\""], ["proof (state)\nthis:\n  cP \\<turnstile> C has_fields FDTs\n\ngoal (2 subgoals):\n 1. compP f P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    P \\<turnstile> C has_fields FDTs\n 2. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    compP f P \\<turnstile> C has_fields FDTs", "hence \"cP = compP f P \\<Longrightarrow> P \\<turnstile> C has_fields FDTs\""], ["proof (prove)\nusing this:\n  cP \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. cP = compP f P \\<Longrightarrow> P \\<turnstile> C has_fields FDTs", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class cP C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; cP \\<turnstile> D has_fields FDTs;\n        cP = compP f P \\<Longrightarrow> P \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs;\n        cP = compP f P\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C has_fields FDTs'\n 2. \\<And>D fs ms FDTs.\n       \\<lbrakk>class cP Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs;\n        cP = compP f P\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Object has_fields FDTs", "case has_fields_Object"], ["proof (state)\nthis:\n  class cP Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  FDTs_ = map (\\<lambda>(F, T). ((F, Object), T)) fs_\n  cP = compP f P\n\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class cP C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; cP \\<turnstile> D has_fields FDTs;\n        cP = compP f P \\<Longrightarrow> P \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs;\n        cP = compP f P\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C has_fields FDTs'\n 2. \\<And>D fs ms FDTs.\n       \\<lbrakk>class cP Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs;\n        cP = compP f P\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Object has_fields FDTs", "thus ?case"], ["proof (prove)\nusing this:\n  class cP Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  FDTs_ = map (\\<lambda>(F, T). ((F, Object), T)) fs_\n  cP = compP f P\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Object has_fields FDTs_", "by(fast intro:Fields.has_fields_Object dest:class_compPD)"], ["proof (state)\nthis:\n  P \\<turnstile> Object has_fields FDTs_\n\ngoal (1 subgoal):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class cP C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; cP \\<turnstile> D has_fields FDTs;\n        cP = compP f P \\<Longrightarrow> P \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs;\n        cP = compP f P\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C has_fields FDTs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class cP C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; cP \\<turnstile> D has_fields FDTs;\n        cP = compP f P \\<Longrightarrow> P \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs;\n        cP = compP f P\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C has_fields FDTs'", "case has_fields_rec"], ["proof (state)\nthis:\n  class cP C_ = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  C_ \\<noteq> Object\n  cP \\<turnstile> D_ has_fields FDTs_\n  cP = compP f P \\<Longrightarrow> P \\<turnstile> D_ has_fields FDTs_\n  FDTs'_ = map (\\<lambda>(F, Tm). ((F, C_), Tm)) fs_ @ FDTs_\n  cP = compP f P\n\ngoal (1 subgoal):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class cP C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; cP \\<turnstile> D has_fields FDTs;\n        cP = compP f P \\<Longrightarrow> P \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs;\n        cP = compP f P\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C has_fields FDTs'", "thus ?case"], ["proof (prove)\nusing this:\n  class cP C_ = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  C_ \\<noteq> Object\n  cP \\<turnstile> D_ has_fields FDTs_\n  cP = compP f P \\<Longrightarrow> P \\<turnstile> D_ has_fields FDTs_\n  FDTs'_ = map (\\<lambda>(F, Tm). ((F, C_), Tm)) fs_ @ FDTs_\n  cP = compP f P\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C_ has_fields FDTs'_", "by(fast intro:Fields.has_fields_rec dest:class_compPD)"], ["proof (state)\nthis:\n  P \\<turnstile> C_ has_fields FDTs'_\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cP = compP f P \\<Longrightarrow> P \\<turnstile> C has_fields FDTs\n\ngoal (2 subgoals):\n 1. compP f P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    P \\<turnstile> C has_fields FDTs\n 2. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    compP f P \\<turnstile> C has_fields FDTs", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?cP2 \\<turnstile> C has_fields FDTs; ?cP2 = compP f P\\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> C has_fields FDTs\n\ngoal (2 subgoals):\n 1. compP f P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    P \\<turnstile> C has_fields FDTs\n 2. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    compP f P \\<turnstile> C has_fields FDTs", "note lem = this"], ["proof (state)\nthis:\n  \\<lbrakk>?cP2 \\<turnstile> C has_fields FDTs; ?cP2 = compP f P\\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> C has_fields FDTs\n\ngoal (2 subgoals):\n 1. compP f P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    P \\<turnstile> C has_fields FDTs\n 2. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    compP f P \\<turnstile> C has_fields FDTs", "assume ?A"], ["proof (state)\nthis:\n  compP f P \\<turnstile> C has_fields FDTs\n\ngoal (2 subgoals):\n 1. compP f P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    P \\<turnstile> C has_fields FDTs\n 2. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    compP f P \\<turnstile> C has_fields FDTs", "with lem"], ["proof (chain)\npicking this:\n  \\<lbrakk>?cP2 \\<turnstile> C has_fields FDTs; ?cP2 = compP f P\\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> C has_fields FDTs\n  compP f P \\<turnstile> C has_fields FDTs", "show ?B"], ["proof (prove)\nusing this:\n  \\<lbrakk>?cP2 \\<turnstile> C has_fields FDTs; ?cP2 = compP f P\\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> C has_fields FDTs\n  compP f P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs", "by blast"], ["proof (state)\nthis:\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    compP f P \\<turnstile> C has_fields FDTs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    compP f P \\<turnstile> C has_fields FDTs", "assume ?B"], ["proof (state)\nthis:\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    compP f P \\<turnstile> C has_fields FDTs", "thus ?A"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. compP f P \\<turnstile> C has_fields FDTs", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        compP f P \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> compP f P \\<turnstile> C has_fields FDTs'\n 2. \\<And>D fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs\\<rbrakk>\n       \\<Longrightarrow> compP f P \\<turnstile> Object has_fields FDTs", "case has_fields_Object"], ["proof (state)\nthis:\n  class P Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  FDTs_ = map (\\<lambda>(F, T). ((F, Object), T)) fs_\n\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        compP f P \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> compP f P \\<turnstile> C has_fields FDTs'\n 2. \\<And>D fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs\\<rbrakk>\n       \\<Longrightarrow> compP f P \\<turnstile> Object has_fields FDTs", "thus ?case"], ["proof (prove)\nusing this:\n  class P Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  FDTs_ = map (\\<lambda>(F, T). ((F, Object), T)) fs_\n\ngoal (1 subgoal):\n 1. compP f P \\<turnstile> Object has_fields FDTs_", "by(fast intro:Fields.has_fields_Object class_compP)"], ["proof (state)\nthis:\n  compP f P \\<turnstile> Object has_fields FDTs_\n\ngoal (1 subgoal):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        compP f P \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> compP f P \\<turnstile> C has_fields FDTs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        compP f P \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> compP f P \\<turnstile> C has_fields FDTs'", "case has_fields_rec"], ["proof (state)\nthis:\n  class P C_ = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  C_ \\<noteq> Object\n  P \\<turnstile> D_ has_fields FDTs_\n  compP f P \\<turnstile> D_ has_fields FDTs_\n  FDTs'_ = map (\\<lambda>(F, Tm). ((F, C_), Tm)) fs_ @ FDTs_\n\ngoal (1 subgoal):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        compP f P \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, Tm). ((F, C), Tm)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> compP f P \\<turnstile> C has_fields FDTs'", "thus ?case"], ["proof (prove)\nusing this:\n  class P C_ = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  C_ \\<noteq> Object\n  P \\<turnstile> D_ has_fields FDTs_\n  compP f P \\<turnstile> D_ has_fields FDTs_\n  FDTs'_ = map (\\<lambda>(F, Tm). ((F, C_), Tm)) fs_ @ FDTs_\n\ngoal (1 subgoal):\n 1. compP f P \\<turnstile> C_ has_fields FDTs'_", "by(fast intro:Fields.has_fields_rec class_compP)"], ["proof (state)\nthis:\n  compP f P \\<turnstile> C_ has_fields FDTs'_\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  compP f P \\<turnstile> C has_fields FDTs\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma [simp]: \"fields (compP f P) C = fields P C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TypeRel.fields (compP f P) C = TypeRel.fields P C", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. TypeRel.fields (compP f P) C = TypeRel.fields P C", "by(simp add:fields_def)"], ["", "(*>*)"], ["", "lemma [simp]: \"(compP f P \\<turnstile> C sees F:T (fm) in D) = (P \\<turnstile> C sees F:T (fm) in D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (compP f P \\<turnstile> C sees F:T (fm) in D) =\n    (P \\<turnstile> C sees F:T (fm) in D)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (compP f P \\<turnstile> C sees F:T (fm) in D) =\n    (P \\<turnstile> C sees F:T (fm) in D)", "by(simp add:sees_field_def)"], ["", "(*>*)"], ["", "lemma [simp]: \"field (compP f P) F D = field P F D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. field (compP f P) F D = field P F D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. field (compP f P) F D = field P F D", "by(simp add:field_def)"], ["", "(*>*)"], ["", "subsection\\<open>Invariance of @{term wf_prog} under compilation\\<close>"], ["", "lemma [iff]: \"distinct_fst (classes (compP f P)) = distinct_fst (classes P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_fst (classes (compP f P)) = distinct_fst (classes P)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_fst (classes (compP f P)) = distinct_fst (classes P)", "apply(cases P)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       P = Program x \\<Longrightarrow>\n       distinct_fst (classes (compP f P)) = distinct_fst (classes P)", "apply(simp add:distinct_fst_def compP_def compC_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       P = Program x \\<Longrightarrow>\n       distinct\n        (map (fst \\<circ>\n              (\\<lambda>(C, D, Fdecls, Mdecls).\n                  (C, D, Fdecls, map (compM (f C)) Mdecls)))\n          x) =\n       distinct (map fst x)", "apply(rename_tac list)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list.\n       P = Program list \\<Longrightarrow>\n       distinct\n        (map (fst \\<circ>\n              (\\<lambda>(C, D, Fdecls, Mdecls).\n                  (C, D, Fdecls, map (compM (f C)) Mdecls)))\n          list) =\n       distinct (map fst list)", "apply(induct_tac list)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>list.\n       P = Program list \\<Longrightarrow>\n       distinct\n        (map (fst \\<circ>\n              (\\<lambda>a.\n                  case a of\n                  (C, D, Fdecls, Mdecls) \\<Rightarrow>\n                    (C, D, Fdecls, map (compM (f C)) Mdecls)))\n          []) =\n       distinct (map fst [])\n 2. \\<And>list a lista.\n       \\<lbrakk>P = Program list;\n        distinct\n         (map (fst \\<circ>\n               (\\<lambda>a.\n                   case a of\n                   (C, D, Fdecls, Mdecls) \\<Rightarrow>\n                     (C, D, Fdecls, map (compM (f C)) Mdecls)))\n           lista) =\n        distinct (map fst lista)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map (fst \\<circ>\n                                (\\<lambda>a.\n                                    case a of\n                                    (C, D, Fdecls, Mdecls) \\<Rightarrow>\n(C, D, Fdecls, map (compM (f C)) Mdecls)))\n                            (a # lista)) =\n                         distinct (map fst (a # lista))", "apply (auto simp:image_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma [iff]: \"distinct_fst (map (compM f) ms) = distinct_fst ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_fst (map (compM f) ms) = distinct_fst ms", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_fst (map (compM f) ms) = distinct_fst ms", "apply(simp add:distinct_fst_def compM_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map (fst \\<circ>\n           (\\<lambda>(M, Ts, T, m). (M, Ts, T, map_option (f M Ts T) m)))\n       ms) =\n    distinct (map fst ms)", "apply(induct ms)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct\n     (map (fst \\<circ>\n           (\\<lambda>a.\n               case a of\n               (M, Ts, T, m) \\<Rightarrow>\n                 (M, Ts, T, map_option (f M Ts T) m)))\n       []) =\n    distinct (map fst [])\n 2. \\<And>a ms.\n       distinct\n        (map (fst \\<circ>\n              (\\<lambda>a.\n                  case a of\n                  (M, Ts, T, m) \\<Rightarrow>\n                    (M, Ts, T, map_option (f M Ts T) m)))\n          ms) =\n       distinct (map fst ms) \\<Longrightarrow>\n       distinct\n        (map (fst \\<circ>\n              (\\<lambda>a.\n                  case a of\n                  (M, Ts, T, m) \\<Rightarrow>\n                    (M, Ts, T, map_option (f M Ts T) m)))\n          (a # ms)) =\n       distinct (map fst (a # ms))", "apply (auto simp:image_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma [iff]: \"wf_syscls (compP f P) = wf_syscls P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_syscls (compP f P) = wf_syscls P", "unfolding wf_syscls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>C\\<in>{Object, Throwable, Thread}.\n         is_class (compP f P) C) \\<and>\n     (\\<forall>C\\<in>sys_xcpts.\n         compP f P \\<turnstile> C \\<preceq>\\<^sup>* Throwable)) =\n    ((\\<forall>C\\<in>{Object, Throwable, Thread}. is_class P C) \\<and>\n     (\\<forall>C\\<in>sys_xcpts.\n         P \\<turnstile> C \\<preceq>\\<^sup>* Throwable))", "by auto"], ["", "lemma [iff]: \"wf_fdecl (compP f P) = wf_fdecl P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_fdecl (compP f P) = wf_fdecl P", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_fdecl (compP f P) = wf_fdecl P", "by(simp add:wf_fdecl_def)"], ["", "(*>*)"], ["", "lemma set_compP:\n \"(class (compP f P) C = \\<lfloor>(D,fs,ms')\\<rfloor>) \\<longleftrightarrow> \n  (\\<exists>ms. class P C = \\<lfloor>(D,fs,ms)\\<rfloor> \\<and> ms' = map (compM (f C)) ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (class (compP f P) C = \\<lfloor>(D, fs, ms')\\<rfloor>) =\n    (\\<exists>ms.\n        class P C = \\<lfloor>(D, fs, ms)\\<rfloor> \\<and>\n        ms' = map (compM (f C)) ms)", "by(cases P)(auto simp add: compC_def image_iff map_of_map4)"], ["", "lemma compP_has_method: \"compP f P \\<turnstile> C has M \\<longleftrightarrow> P \\<turnstile> C has M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (compP f P \\<turnstile> C has M) = (P \\<turnstile> C has M)", "unfolding has_method_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>Ts T m D.\n        compP f P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D) =\n    (\\<exists>Ts T m D. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D)", "by(fastforce dest: sees_method_compPD intro: sees_method_compP)"], ["", "lemma is_native_compP [simp]: \"is_native (compP f P) = is_native P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_native (compP f P) = is_native P", "by(auto simp add: fun_eq_iff is_native.simps)"], ["", "lemma \\<tau>external_compP [simp]:\n  \"\\<tau>external (compP f P) = \\<tau>external P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>external (compP f P) = \\<tau>external P", "by(auto intro!: ext simp add: \\<tau>external_def)"], ["", "context heap_base begin"], ["", "lemma heap_clone_compP [simp]: \n  \"heap_clone (compP f P) = heap_clone P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_clone (compP f P) = heap_clone P", "by(intro ext)(auto elim!: heap_clone.cases intro: heap_clone.intros)"], ["", "lemma red_external_compP [simp]:\n  \"compP f P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle> \\<longleftrightarrow> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compP f\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                      h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n               h'\\<rangle> =\n    P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                     h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>", "by(auto elim!: red_external.cases intro: red_external.intros)"], ["", "lemma \\<tau>external'_compP [simp]:\n  \"\\<tau>external' (compP f P) = \\<tau>external' P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>external' (compP f P) = \\<tau>external' P", "by(simp add: \\<tau>external'_def [abs_def])"], ["", "end"], ["", "lemma wf_overriding_compP [simp]: \"wf_overriding (compP f P) D (compM (f C) m) = wf_overriding P D m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_overriding (compP f P) D (compM (f C) m) = wf_overriding P D m", "by(cases m)(fastforce intro: sees_method_compP[where f=f] dest: sees_method_compPD[where f=f] simp add: compM_def)"], ["", "lemma wf_cdecl_compPI:\n  assumes wf1_imp_wf2: \n    \"\\<And>C M Ts T m. \\<lbrakk> wf_mdecl wf\\<^sub>1 P C (M,Ts,T,\\<lfloor>m\\<rfloor>); P \\<turnstile> C sees M:Ts\\<rightarrow>T = \\<lfloor>m\\<rfloor> in C \\<rbrakk>\n    \\<Longrightarrow> wf_mdecl wf\\<^sub>2 (compP f P) C (M,Ts,T, \\<lfloor>f C M Ts T m\\<rfloor>)\"\n  and wfcP1: \"\\<forall>C rest. class P C = \\<lfloor>rest\\<rfloor> \\<longrightarrow> wf_cdecl wf\\<^sub>1 P (C, rest)\"\n  and xcomp: \"class (compP f P) C = \\<lfloor>rest'\\<rfloor>\"\n  and wf: \"wf_prog p P\"\n  shows \"wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "obtain D fs ms' where x: \"rest' = (D, fs, ms')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>D fs ms'.\n        rest' = (D, fs, ms') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases rest')"], ["proof (state)\nthis:\n  rest' = (D, fs, ms')\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "with xcomp"], ["proof (chain)\npicking this:\n  class (compP f P) C = \\<lfloor>rest'\\<rfloor>\n  rest' = (D, fs, ms')", "obtain ms where xsrc: \"class P C = \\<lfloor>(D,fs,ms)\\<rfloor>\"\n    and ms': \"ms' = map (compM (f C)) ms\""], ["proof (prove)\nusing this:\n  class (compP f P) C = \\<lfloor>rest'\\<rfloor>\n  rest' = (D, fs, ms')\n\ngoal (1 subgoal):\n 1. (\\<And>ms.\n        \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n         ms' = map (compM (f C)) ms\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: set_compP compC_def)"], ["proof (state)\nthis:\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  ms' = map (compM (f C)) ms\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "from xsrc wfcP1"], ["proof (chain)\npicking this:\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  \\<forall>C rest.\n     class P C = \\<lfloor>rest\\<rfloor> \\<longrightarrow>\n     wf_cdecl wf\\<^sub>1 P (C, rest)", "have wf1: \"wf_cdecl wf\\<^sub>1 P (C,D,fs,ms)\""], ["proof (prove)\nusing this:\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  \\<forall>C rest.\n     class P C = \\<lfloor>rest\\<rfloor> \\<longrightarrow>\n     wf_cdecl wf\\<^sub>1 P (C, rest)\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>1 P (C, D, fs, ms)", "by blast"], ["proof (state)\nthis:\n  wf_cdecl wf\\<^sub>1 P (C, D, fs, ms)\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "{"], ["proof (state)\nthis:\n  wf_cdecl wf\\<^sub>1 P (C, D, fs, ms)\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "fix field"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "assume \"field \\<in> set fs\""], ["proof (state)\nthis:\n  field \\<in> set fs\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "with wf1"], ["proof (chain)\npicking this:\n  wf_cdecl wf\\<^sub>1 P (C, D, fs, ms)\n  field \\<in> set fs", "have \"wf_fdecl (compP f P) field\""], ["proof (prove)\nusing this:\n  wf_cdecl wf\\<^sub>1 P (C, D, fs, ms)\n  field \\<in> set fs\n\ngoal (1 subgoal):\n 1. wf_fdecl (compP f P) field", "by(simp add: wf_cdecl_def)"], ["proof (state)\nthis:\n  wf_fdecl (compP f P) field\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "}"], ["proof (state)\nthis:\n  ?field2 \\<in> set fs \\<Longrightarrow> wf_fdecl (compP f P) ?field2\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "moreover"], ["proof (state)\nthis:\n  ?field2 \\<in> set fs \\<Longrightarrow> wf_fdecl (compP f P) ?field2\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "from wf1"], ["proof (chain)\npicking this:\n  wf_cdecl wf\\<^sub>1 P (C, D, fs, ms)", "have \"distinct_fst fs\""], ["proof (prove)\nusing this:\n  wf_cdecl wf\\<^sub>1 P (C, D, fs, ms)\n\ngoal (1 subgoal):\n 1. distinct_fst fs", "by(simp add: wf_cdecl_def)"], ["proof (state)\nthis:\n  distinct_fst fs\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "moreover"], ["proof (state)\nthis:\n  distinct_fst fs\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "{"], ["proof (state)\nthis:\n  distinct_fst fs\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "assume mset': \"m \\<in> set ms'\""], ["proof (state)\nthis:\n  m \\<in> set ms'\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "obtain M Ts' T' body' where m: \"m = (M, Ts', T', body')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>M Ts' T' body'.\n        m = (M, Ts', T', body') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases m)"], ["proof (state)\nthis:\n  m = (M, Ts', T', body')\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "with ms'"], ["proof (chain)\npicking this:\n  ms' = map (compM (f C)) ms\n  m = (M, Ts', T', body')", "obtain body where mf: \"body' = map_option (f C M Ts' T') body\"\n      and mset: \"(M, Ts', T', body) \\<in> set ms\""], ["proof (prove)\nusing this:\n  ms' = map (compM (f C)) ms\n  m = (M, Ts', T', body')\n\ngoal (1 subgoal):\n 1. (\\<And>body.\n        \\<lbrakk>body' = map_option (f C M Ts' T') body;\n         (M, Ts', T', body) \\<in> set ms\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using mset'"], ["proof (prove)\nusing this:\n  ms' = map (compM (f C)) ms\n  m = (M, Ts', T', body')\n  m \\<in> set ms'\n\ngoal (1 subgoal):\n 1. (\\<And>body.\n        \\<lbrakk>body' = map_option (f C M Ts' T') body;\n         (M, Ts', T', body) \\<in> set ms\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(clarsimp simp add: image_iff compM_def)"], ["proof (state)\nthis:\n  body' = map_option (f C M Ts' T') body\n  (M, Ts', T', body) \\<in> set ms\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "moreover"], ["proof (state)\nthis:\n  body' = map_option (f C M Ts' T') body\n  (M, Ts', T', body) \\<in> set ms\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "from mset xsrc wfcP1"], ["proof (chain)\npicking this:\n  (M, Ts', T', body) \\<in> set ms\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  \\<forall>C rest.\n     class P C = \\<lfloor>rest\\<rfloor> \\<longrightarrow>\n     wf_cdecl wf\\<^sub>1 P (C, rest)", "have \"wf_mdecl wf\\<^sub>1 P C (M,Ts',T',body)\""], ["proof (prove)\nusing this:\n  (M, Ts', T', body) \\<in> set ms\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  \\<forall>C rest.\n     class P C = \\<lfloor>rest\\<rfloor> \\<longrightarrow>\n     wf_cdecl wf\\<^sub>1 P (C, rest)\n\ngoal (1 subgoal):\n 1. wf_mdecl wf\\<^sub>1 P C (M, Ts', T', body)", "by(fastforce simp add: wf_cdecl_def)"], ["proof (state)\nthis:\n  wf_mdecl wf\\<^sub>1 P C (M, Ts', T', body)\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "moreover"], ["proof (state)\nthis:\n  wf_mdecl wf\\<^sub>1 P C (M, Ts', T', body)\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "from wf xsrc mset x"], ["proof (chain)\npicking this:\n  wf_prog p P\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  (M, Ts', T', body) \\<in> set ms\n  rest' = (D, fs, ms')", "have \"P \\<turnstile> C sees M:Ts'\\<rightarrow>T' = body in C\""], ["proof (prove)\nusing this:\n  wf_prog p P\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  (M, Ts', T', body) \\<in> set ms\n  rest' = (D, fs, ms')\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts'\\<rightarrow>T' = body in C", "by(auto intro: mdecl_visible)"], ["proof (state)\nthis:\n  P \\<turnstile> C sees M: Ts'\\<rightarrow>T' = body in C\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "ultimately"], ["proof (chain)\npicking this:\n  body' = map_option (f C M Ts' T') body\n  (M, Ts', T', body) \\<in> set ms\n  wf_mdecl wf\\<^sub>1 P C (M, Ts', T', body)\n  P \\<turnstile> C sees M: Ts'\\<rightarrow>T' = body in C", "have \"wf_mdecl wf\\<^sub>2 (compP f P) C m\""], ["proof (prove)\nusing this:\n  body' = map_option (f C M Ts' T') body\n  (M, Ts', T', body) \\<in> set ms\n  wf_mdecl wf\\<^sub>1 P C (M, Ts', T', body)\n  P \\<turnstile> C sees M: Ts'\\<rightarrow>T' = body in C\n\ngoal (1 subgoal):\n 1. wf_mdecl wf\\<^sub>2 (compP f P) C m", "using m"], ["proof (prove)\nusing this:\n  body' = map_option (f C M Ts' T') body\n  (M, Ts', T', body) \\<in> set ms\n  wf_mdecl wf\\<^sub>1 P C (M, Ts', T', body)\n  P \\<turnstile> C sees M: Ts'\\<rightarrow>T' = body in C\n  m = (M, Ts', T', body')\n\ngoal (1 subgoal):\n 1. wf_mdecl wf\\<^sub>2 (compP f P) C m", "by(cases body)(simp add: wf_mdecl_def, auto intro: wf1_imp_wf2)"], ["proof (state)\nthis:\n  wf_mdecl wf\\<^sub>2 (compP f P) C m\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "}"], ["proof (state)\nthis:\n  ?m2 \\<in> set ms' \\<Longrightarrow> wf_mdecl wf\\<^sub>2 (compP f P) C ?m2\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "moreover"], ["proof (state)\nthis:\n  ?m2 \\<in> set ms' \\<Longrightarrow> wf_mdecl wf\\<^sub>2 (compP f P) C ?m2\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "from wf1"], ["proof (chain)\npicking this:\n  wf_cdecl wf\\<^sub>1 P (C, D, fs, ms)", "have \"distinct_fst ms\""], ["proof (prove)\nusing this:\n  wf_cdecl wf\\<^sub>1 P (C, D, fs, ms)\n\ngoal (1 subgoal):\n 1. distinct_fst ms", "by(simp add: wf_cdecl_def)"], ["proof (state)\nthis:\n  distinct_fst ms\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "with ms'"], ["proof (chain)\npicking this:\n  ms' = map (compM (f C)) ms\n  distinct_fst ms", "have \"distinct_fst ms'\""], ["proof (prove)\nusing this:\n  ms' = map (compM (f C)) ms\n  distinct_fst ms\n\ngoal (1 subgoal):\n 1. distinct_fst ms'", "by(auto)"], ["proof (state)\nthis:\n  distinct_fst ms'\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "moreover"], ["proof (state)\nthis:\n  distinct_fst ms'\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "{"], ["proof (state)\nthis:\n  distinct_fst ms'\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "assume CObj: \"C \\<noteq> Object\""], ["proof (state)\nthis:\n  C \\<noteq> Object\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "with xsrc wfcP1"], ["proof (chain)\npicking this:\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  \\<forall>C rest.\n     class P C = \\<lfloor>rest\\<rfloor> \\<longrightarrow>\n     wf_cdecl wf\\<^sub>1 P (C, rest)\n  C \\<noteq> Object", "have part1: \"is_class (compP f P) D\" \"\\<not> compP f P \\<turnstile> D \\<preceq>\\<^sup>* C\""], ["proof (prove)\nusing this:\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  \\<forall>C rest.\n     class P C = \\<lfloor>rest\\<rfloor> \\<longrightarrow>\n     wf_cdecl wf\\<^sub>1 P (C, rest)\n  C \\<noteq> Object\n\ngoal (1 subgoal):\n 1. is_class (compP f P) D &&&\n    \\<not> compP f P \\<turnstile> D \\<preceq>\\<^sup>* C", "by(auto simp add: wf_cdecl_def)"], ["proof (state)\nthis:\n  is_class (compP f P) D\n  \\<not> compP f P \\<turnstile> D \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "{"], ["proof (state)\nthis:\n  is_class (compP f P) D\n  \\<not> compP f P \\<turnstile> D \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "assume mset': \"m \\<in> set ms'\""], ["proof (state)\nthis:\n  m \\<in> set ms'\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "obtain M Ts T body' where m: \"m = (M, Ts, T, body')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>M Ts T body'.\n        m = (M, Ts, T, body') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases m)"], ["proof (state)\nthis:\n  m = (M, Ts, T, body')\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "with mset' ms'"], ["proof (chain)\npicking this:\n  m \\<in> set ms'\n  ms' = map (compM (f C)) ms\n  m = (M, Ts, T, body')", "obtain body where mf: \"body' = map_option (f C M Ts T) body\"\n        and mset: \"(M, Ts, T, body) \\<in> set ms\""], ["proof (prove)\nusing this:\n  m \\<in> set ms'\n  ms' = map (compM (f C)) ms\n  m = (M, Ts, T, body')\n\ngoal (1 subgoal):\n 1. (\\<And>body.\n        \\<lbrakk>body' = map_option (f C M Ts T) body;\n         (M, Ts, T, body) \\<in> set ms\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(clarsimp simp add: image_iff compM_def)"], ["proof (state)\nthis:\n  body' = map_option (f C M Ts T) body\n  (M, Ts, T, body) \\<in> set ms\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "from wf1 CObj mset"], ["proof (chain)\npicking this:\n  wf_cdecl wf\\<^sub>1 P (C, D, fs, ms)\n  C \\<noteq> Object\n  (M, Ts, T, body) \\<in> set ms", "have \"wf_overriding P D (M, Ts, T, body)\""], ["proof (prove)\nusing this:\n  wf_cdecl wf\\<^sub>1 P (C, D, fs, ms)\n  C \\<noteq> Object\n  (M, Ts, T, body) \\<in> set ms\n\ngoal (1 subgoal):\n 1. wf_overriding P D (M, Ts, T, body)", "by(auto simp add: wf_cdecl_def simp del: wf_overriding.simps)"], ["proof (state)\nthis:\n  wf_overriding P D (M, Ts, T, body)\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "hence \"wf_overriding (compP f P) D m\""], ["proof (prove)\nusing this:\n  wf_overriding P D (M, Ts, T, body)\n\ngoal (1 subgoal):\n 1. wf_overriding (compP f P) D m", "unfolding m mf"], ["proof (prove)\nusing this:\n  wf_overriding P D (M, Ts, T, body)\n\ngoal (1 subgoal):\n 1. wf_overriding (compP f P) D (M, Ts, T, map_option (f C M Ts T) body)", "by(subst (asm) wf_overriding_compP[symmetric, where f=f and C=C])(simp del: wf_overriding.simps wf_overriding_compP add: compM_def)"], ["proof (state)\nthis:\n  wf_overriding (compP f P) D m\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "}"], ["proof (state)\nthis:\n  ?m2 \\<in> set ms' \\<Longrightarrow> wf_overriding (compP f P) D ?m2\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "note this part1"], ["proof (state)\nthis:\n  ?m2 \\<in> set ms' \\<Longrightarrow> wf_overriding (compP f P) D ?m2\n  is_class (compP f P) D\n  \\<not> compP f P \\<turnstile> D \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "}"], ["proof (state)\nthis:\n  \\<lbrakk>C \\<noteq> Object; ?m2 \\<in> set ms'\\<rbrakk>\n  \\<Longrightarrow> wf_overriding (compP f P) D ?m2\n  C \\<noteq> Object \\<Longrightarrow> is_class (compP f P) D\n  C \\<noteq> Object \\<Longrightarrow>\n  \\<not> compP f P \\<turnstile> D \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>C \\<noteq> Object; ?m2 \\<in> set ms'\\<rbrakk>\n  \\<Longrightarrow> wf_overriding (compP f P) D ?m2\n  C \\<noteq> Object \\<Longrightarrow> is_class (compP f P) D\n  C \\<noteq> Object \\<Longrightarrow>\n  \\<not> compP f P \\<turnstile> D \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "{"], ["proof (state)\nthis:\n  \\<lbrakk>C \\<noteq> Object; ?m2 \\<in> set ms'\\<rbrakk>\n  \\<Longrightarrow> wf_overriding (compP f P) D ?m2\n  C \\<noteq> Object \\<Longrightarrow> is_class (compP f P) D\n  C \\<noteq> Object \\<Longrightarrow>\n  \\<not> compP f P \\<turnstile> D \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "assume \"C = Thread\""], ["proof (state)\nthis:\n  C = Thread\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "with wf1 ms'"], ["proof (chain)\npicking this:\n  wf_cdecl wf\\<^sub>1 P (C, D, fs, ms)\n  ms' = map (compM (f C)) ms\n  C = Thread", "have \"\\<exists>m. (run, [], Void, m) \\<in> set ms'\""], ["proof (prove)\nusing this:\n  wf_cdecl wf\\<^sub>1 P (C, D, fs, ms)\n  ms' = map (compM (f C)) ms\n  C = Thread\n\ngoal (1 subgoal):\n 1. \\<exists>m. (run, [], Void, m) \\<in> set ms'", "by(fastforce simp add: wf_cdecl_def image_iff compM_def)+"], ["proof (state)\nthis:\n  \\<exists>m. (run, [], Void, m) \\<in> set ms'\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "}"], ["proof (state)\nthis:\n  C = Thread \\<Longrightarrow> \\<exists>m. (run, [], Void, m) \\<in> set ms'\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "ultimately"], ["proof (chain)\npicking this:\n  ?field2 \\<in> set fs \\<Longrightarrow> wf_fdecl (compP f P) ?field2\n  distinct_fst fs\n  ?m2 \\<in> set ms' \\<Longrightarrow> wf_mdecl wf\\<^sub>2 (compP f P) C ?m2\n  distinct_fst ms'\n  \\<lbrakk>C \\<noteq> Object; ?m2 \\<in> set ms'\\<rbrakk>\n  \\<Longrightarrow> wf_overriding (compP f P) D ?m2\n  C \\<noteq> Object \\<Longrightarrow> is_class (compP f P) D\n  C \\<noteq> Object \\<Longrightarrow>\n  \\<not> compP f P \\<turnstile> D \\<preceq>\\<^sup>* C\n  C = Thread \\<Longrightarrow> \\<exists>m. (run, [], Void, m) \\<in> set ms'", "show ?thesis"], ["proof (prove)\nusing this:\n  ?field2 \\<in> set fs \\<Longrightarrow> wf_fdecl (compP f P) ?field2\n  distinct_fst fs\n  ?m2 \\<in> set ms' \\<Longrightarrow> wf_mdecl wf\\<^sub>2 (compP f P) C ?m2\n  distinct_fst ms'\n  \\<lbrakk>C \\<noteq> Object; ?m2 \\<in> set ms'\\<rbrakk>\n  \\<Longrightarrow> wf_overriding (compP f P) D ?m2\n  C \\<noteq> Object \\<Longrightarrow> is_class (compP f P) D\n  C \\<noteq> Object \\<Longrightarrow>\n  \\<not> compP f P \\<turnstile> D \\<preceq>\\<^sup>* C\n  C = Thread \\<Longrightarrow> \\<exists>m. (run, [], Void, m) \\<in> set ms'\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')", "unfolding x wf_cdecl_def"], ["proof (prove)\nusing this:\n  ?field2 \\<in> set fs \\<Longrightarrow> wf_fdecl (compP f P) ?field2\n  distinct_fst fs\n  ?m2 \\<in> set ms' \\<Longrightarrow> wf_mdecl wf\\<^sub>2 (compP f P) C ?m2\n  distinct_fst ms'\n  \\<lbrakk>C \\<noteq> Object; ?m2 \\<in> set ms'\\<rbrakk>\n  \\<Longrightarrow> wf_overriding (compP f P) D ?m2\n  C \\<noteq> Object \\<Longrightarrow> is_class (compP f P) D\n  C \\<noteq> Object \\<Longrightarrow>\n  \\<not> compP f P \\<turnstile> D \\<preceq>\\<^sup>* C\n  C = Thread \\<Longrightarrow> \\<exists>m. (run, [], Void, m) \\<in> set ms'\n\ngoal (1 subgoal):\n 1. case (C, D, fs, ms') of\n    (C, D, fs, ms) \\<Rightarrow>\n      (\\<forall>fa\\<in>set fs. wf_fdecl (compP f P) fa) \\<and>\n      distinct_fst fs \\<and>\n      (\\<forall>m\\<in>set ms. wf_mdecl wf\\<^sub>2 (compP f P) C m) \\<and>\n      distinct_fst ms \\<and>\n      (C \\<noteq> Object \\<longrightarrow>\n       is_class (compP f P) D \\<and>\n       \\<not> compP f P \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n       (\\<forall>m\\<in>set ms. wf_overriding (compP f P) D m)) \\<and>\n      (C = Thread \\<longrightarrow>\n       (\\<exists>m. (run, [], Void, m) \\<in> set ms))", "by blast"], ["proof (state)\nthis:\n  wf_cdecl wf\\<^sub>2 (compP f P) (C, rest')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_prog_compPI:\nassumes lift: \n  \"\\<And>C M Ts T m. \n    \\<lbrakk> P \\<turnstile> C sees M:Ts\\<rightarrow>T = \\<lfloor>m\\<rfloor> in C; wf_mdecl wf\\<^sub>1 P C (M,Ts,T,\\<lfloor>m\\<rfloor>) \\<rbrakk>\n    \\<Longrightarrow> wf_mdecl wf\\<^sub>2 (compP f P) C (M,Ts,T, \\<lfloor>f C M Ts T m\\<rfloor>)\"\nand wf: \"wf_prog wf\\<^sub>1 P\"\nshows \"wf_prog wf\\<^sub>2 (compP f P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf\\<^sub>2 (compP f P)", "using wf"], ["proof (prove)\nusing this:\n  wf_prog wf\\<^sub>1 P\n\ngoal (1 subgoal):\n 1. wf_prog wf\\<^sub>2 (compP f P)", "apply (clarsimp simp add:wf_prog_def2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C a aa b ab ac ba.\n       \\<lbrakk>wf_syscls P;\n        \\<forall>C a aa b.\n           class P C = \\<lfloor>(a, aa, b)\\<rfloor> \\<longrightarrow>\n           wf_cdecl wf\\<^sub>1 P (C, a, aa, b);\n        distinct_fst (classes P);\n        class P C = \\<lfloor>(ab, ac, ba)\\<rfloor>;\n        snd (compC f (C, ab, ac, ba)) = (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> wf_cdecl wf\\<^sub>2 (compP f P) (C, a, aa, b)", "apply(rule wf_cdecl_compPI[OF lift], assumption+)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>C a aa b ab ac ba.\n       \\<lbrakk>wf_syscls P;\n        \\<forall>C a aa b.\n           class P C = \\<lfloor>(a, aa, b)\\<rfloor> \\<longrightarrow>\n           wf_cdecl wf\\<^sub>1 P (C, a, aa, b);\n        distinct_fst (classes P);\n        class P C = \\<lfloor>(ab, ac, ba)\\<rfloor>;\n        snd (compC f (C, ab, ac, ba)) = (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>C rest.\n                            class P C =\n                            \\<lfloor>rest\\<rfloor> \\<longrightarrow>\n                            wf_cdecl wf\\<^sub>1 P (C, rest)\n 2. \\<And>C a aa b ab ac ba.\n       \\<lbrakk>wf_syscls P;\n        \\<forall>C a aa b.\n           class P C = \\<lfloor>(a, aa, b)\\<rfloor> \\<longrightarrow>\n           wf_cdecl wf\\<^sub>1 P (C, a, aa, b);\n        distinct_fst (classes P);\n        class P C = \\<lfloor>(ab, ac, ba)\\<rfloor>;\n        snd (compC f (C, ab, ac, ba)) = (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> class (compP f P) C = \\<lfloor>(a, aa, b)\\<rfloor>\n 3. \\<And>C a aa b ab ac ba.\n       \\<lbrakk>wf_syscls P;\n        \\<forall>C a aa b.\n           class P C = \\<lfloor>(a, aa, b)\\<rfloor> \\<longrightarrow>\n           wf_cdecl wf\\<^sub>1 P (C, a, aa, b);\n        distinct_fst (classes P);\n        class P C = \\<lfloor>(ab, ac, ba)\\<rfloor>;\n        snd (compC f (C, ab, ac, ba)) = (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> wf_prog (?p14 C a aa b ab ac ba) P", "apply(auto intro: wf)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wf_cdecl_compPD:\n  assumes wf1_imp_wf2: \n    \"\\<And>C M Ts T m. \\<lbrakk> wf_mdecl wf\\<^sub>1 (compP f P) C (M,Ts,T,\\<lfloor>f C M Ts T m\\<rfloor>); compP f P \\<turnstile> C sees M:Ts\\<rightarrow>T = \\<lfloor>f C M Ts T m\\<rfloor> in C \\<rbrakk>\n    \\<Longrightarrow> wf_mdecl wf\\<^sub>2 P C (M,Ts,T, \\<lfloor>m\\<rfloor>)\"\n  and wfcP1: \"\\<forall>C rest. class (compP f P) C = \\<lfloor>rest\\<rfloor> \\<longrightarrow> wf_cdecl wf\\<^sub>1 (compP f P) (C, rest)\"\n  and xcomp: \"class P C = \\<lfloor>rest\\<rfloor>\"\n  and wf: \"wf_prog wf_md (compP f P)\"\n  shows \"wf_cdecl wf\\<^sub>2 P (C, rest)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "obtain D fs ms' where x: \"rest = (D, fs, ms')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>D fs ms'.\n        rest = (D, fs, ms') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases rest)"], ["proof (state)\nthis:\n  rest = (D, fs, ms')\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "with xcomp"], ["proof (chain)\npicking this:\n  class P C = \\<lfloor>rest\\<rfloor>\n  rest = (D, fs, ms')", "have xsrc: \"class (compP f P) C = \\<lfloor>(D,fs,map (compM (f C)) ms')\\<rfloor>\""], ["proof (prove)\nusing this:\n  class P C = \\<lfloor>rest\\<rfloor>\n  rest = (D, fs, ms')\n\ngoal (1 subgoal):\n 1. class (compP f P) C = \\<lfloor>(D, fs, map (compM (f C)) ms')\\<rfloor>", "by(auto simp add: set_compP compC_def)"], ["proof (state)\nthis:\n  class (compP f P) C = \\<lfloor>(D, fs, map (compM (f C)) ms')\\<rfloor>\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "from xsrc wfcP1"], ["proof (chain)\npicking this:\n  class (compP f P) C = \\<lfloor>(D, fs, map (compM (f C)) ms')\\<rfloor>\n  \\<forall>C rest.\n     class (compP f P) C = \\<lfloor>rest\\<rfloor> \\<longrightarrow>\n     wf_cdecl wf\\<^sub>1 (compP f P) (C, rest)", "have wf1: \"wf_cdecl wf\\<^sub>1 (compP f P) (C,D,fs,map (compM (f C)) ms')\""], ["proof (prove)\nusing this:\n  class (compP f P) C = \\<lfloor>(D, fs, map (compM (f C)) ms')\\<rfloor>\n  \\<forall>C rest.\n     class (compP f P) C = \\<lfloor>rest\\<rfloor> \\<longrightarrow>\n     wf_cdecl wf\\<^sub>1 (compP f P) (C, rest)\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>1 (compP f P) (C, D, fs, map (compM (f C)) ms')", "by blast"], ["proof (state)\nthis:\n  wf_cdecl wf\\<^sub>1 (compP f P) (C, D, fs, map (compM (f C)) ms')\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "{"], ["proof (state)\nthis:\n  wf_cdecl wf\\<^sub>1 (compP f P) (C, D, fs, map (compM (f C)) ms')\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "fix field"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "assume \"field \\<in> set fs\""], ["proof (state)\nthis:\n  field \\<in> set fs\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "with wf1"], ["proof (chain)\npicking this:\n  wf_cdecl wf\\<^sub>1 (compP f P) (C, D, fs, map (compM (f C)) ms')\n  field \\<in> set fs", "have \"wf_fdecl P field\""], ["proof (prove)\nusing this:\n  wf_cdecl wf\\<^sub>1 (compP f P) (C, D, fs, map (compM (f C)) ms')\n  field \\<in> set fs\n\ngoal (1 subgoal):\n 1. wf_fdecl P field", "by(simp add: wf_cdecl_def)"], ["proof (state)\nthis:\n  wf_fdecl P field\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "}"], ["proof (state)\nthis:\n  ?field2 \\<in> set fs \\<Longrightarrow> wf_fdecl P ?field2\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "moreover"], ["proof (state)\nthis:\n  ?field2 \\<in> set fs \\<Longrightarrow> wf_fdecl P ?field2\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "from wf1"], ["proof (chain)\npicking this:\n  wf_cdecl wf\\<^sub>1 (compP f P) (C, D, fs, map (compM (f C)) ms')", "have \"distinct_fst fs\""], ["proof (prove)\nusing this:\n  wf_cdecl wf\\<^sub>1 (compP f P) (C, D, fs, map (compM (f C)) ms')\n\ngoal (1 subgoal):\n 1. distinct_fst fs", "by(simp add: wf_cdecl_def)"], ["proof (state)\nthis:\n  distinct_fst fs\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "moreover"], ["proof (state)\nthis:\n  distinct_fst fs\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "{"], ["proof (state)\nthis:\n  distinct_fst fs\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "assume mset': \"m \\<in> set ms'\""], ["proof (state)\nthis:\n  m \\<in> set ms'\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "obtain M Ts' T' body' where m: \"m = (M, Ts', T', body')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>M Ts' T' body'.\n        m = (M, Ts', T', body') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases m)"], ["proof (state)\nthis:\n  m = (M, Ts', T', body')\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "hence mset: \"(M, Ts', T', map_option (f C M Ts' T') body') \\<in> set (map (compM (f C)) ms')\""], ["proof (prove)\nusing this:\n  m = (M, Ts', T', body')\n\ngoal (1 subgoal):\n 1. (M, Ts', T', map_option (f C M Ts' T') body')\n    \\<in> set (map (compM (f C)) ms')", "using mset'"], ["proof (prove)\nusing this:\n  m = (M, Ts', T', body')\n  m \\<in> set ms'\n\ngoal (1 subgoal):\n 1. (M, Ts', T', map_option (f C M Ts' T') body')\n    \\<in> set (map (compM (f C)) ms')", "by(auto simp add: image_iff compM_def intro: rev_bexI)"], ["proof (state)\nthis:\n  (M, Ts', T', map_option (f C M Ts' T') body')\n  \\<in> set (map (compM (f C)) ms')\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "moreover"], ["proof (state)\nthis:\n  (M, Ts', T', map_option (f C M Ts' T') body')\n  \\<in> set (map (compM (f C)) ms')\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "from wf xsrc mset x"], ["proof (chain)\npicking this:\n  wf_prog wf_md (compP f P)\n  class (compP f P) C = \\<lfloor>(D, fs, map (compM (f C)) ms')\\<rfloor>\n  (M, Ts', T', map_option (f C M Ts' T') body')\n  \\<in> set (map (compM (f C)) ms')\n  rest = (D, fs, ms')", "have \"compP f P \\<turnstile> C sees M:Ts'\\<rightarrow>T' = map_option (f C M Ts' T') body' in C\""], ["proof (prove)\nusing this:\n  wf_prog wf_md (compP f P)\n  class (compP f P) C = \\<lfloor>(D, fs, map (compM (f C)) ms')\\<rfloor>\n  (M, Ts', T', map_option (f C M Ts' T') body')\n  \\<in> set (map (compM (f C)) ms')\n  rest = (D, fs, ms')\n\ngoal (1 subgoal):\n 1. compP f\n     P \\<turnstile> C sees M: Ts'\\<rightarrow>T' = map_option (f C M Ts' T')\n              body' in C", "by(auto intro: mdecl_visible)"], ["proof (state)\nthis:\n  compP f\n   P \\<turnstile> C sees M: Ts'\\<rightarrow>T' = map_option (f C M Ts' T')\n            body' in C\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "moreover"], ["proof (state)\nthis:\n  compP f\n   P \\<turnstile> C sees M: Ts'\\<rightarrow>T' = map_option (f C M Ts' T')\n            body' in C\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "from mset wfcP1[rule_format, OF xsrc]"], ["proof (chain)\npicking this:\n  (M, Ts', T', map_option (f C M Ts' T') body')\n  \\<in> set (map (compM (f C)) ms')\n  wf_cdecl wf\\<^sub>1 (compP f P) (C, D, fs, map (compM (f C)) ms')", "have \"wf_mdecl wf\\<^sub>1 (compP f P) C (M,Ts',T',map_option (f C M Ts' T') body')\""], ["proof (prove)\nusing this:\n  (M, Ts', T', map_option (f C M Ts' T') body')\n  \\<in> set (map (compM (f C)) ms')\n  wf_cdecl wf\\<^sub>1 (compP f P) (C, D, fs, map (compM (f C)) ms')\n\ngoal (1 subgoal):\n 1. wf_mdecl wf\\<^sub>1 (compP f P) C\n     (M, Ts', T', map_option (f C M Ts' T') body')", "by(auto simp add: wf_cdecl_def)"], ["proof (state)\nthis:\n  wf_mdecl wf\\<^sub>1 (compP f P) C\n   (M, Ts', T', map_option (f C M Ts' T') body')\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "ultimately"], ["proof (chain)\npicking this:\n  (M, Ts', T', map_option (f C M Ts' T') body')\n  \\<in> set (map (compM (f C)) ms')\n  compP f\n   P \\<turnstile> C sees M: Ts'\\<rightarrow>T' = map_option (f C M Ts' T')\n            body' in C\n  wf_mdecl wf\\<^sub>1 (compP f P) C\n   (M, Ts', T', map_option (f C M Ts' T') body')", "have \"wf_mdecl wf\\<^sub>2 P C m\""], ["proof (prove)\nusing this:\n  (M, Ts', T', map_option (f C M Ts' T') body')\n  \\<in> set (map (compM (f C)) ms')\n  compP f\n   P \\<turnstile> C sees M: Ts'\\<rightarrow>T' = map_option (f C M Ts' T')\n            body' in C\n  wf_mdecl wf\\<^sub>1 (compP f P) C\n   (M, Ts', T', map_option (f C M Ts' T') body')\n\ngoal (1 subgoal):\n 1. wf_mdecl wf\\<^sub>2 P C m", "using m"], ["proof (prove)\nusing this:\n  (M, Ts', T', map_option (f C M Ts' T') body')\n  \\<in> set (map (compM (f C)) ms')\n  compP f\n   P \\<turnstile> C sees M: Ts'\\<rightarrow>T' = map_option (f C M Ts' T')\n            body' in C\n  wf_mdecl wf\\<^sub>1 (compP f P) C\n   (M, Ts', T', map_option (f C M Ts' T') body')\n  m = (M, Ts', T', body')\n\ngoal (1 subgoal):\n 1. wf_mdecl wf\\<^sub>2 P C m", "by(cases body')(simp add: wf_mdecl_def, auto intro: wf1_imp_wf2)"], ["proof (state)\nthis:\n  wf_mdecl wf\\<^sub>2 P C m\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "}"], ["proof (state)\nthis:\n  ?m2 \\<in> set ms' \\<Longrightarrow> wf_mdecl wf\\<^sub>2 P C ?m2\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "moreover"], ["proof (state)\nthis:\n  ?m2 \\<in> set ms' \\<Longrightarrow> wf_mdecl wf\\<^sub>2 P C ?m2\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "from wf1"], ["proof (chain)\npicking this:\n  wf_cdecl wf\\<^sub>1 (compP f P) (C, D, fs, map (compM (f C)) ms')", "have \"distinct_fst ms'\""], ["proof (prove)\nusing this:\n  wf_cdecl wf\\<^sub>1 (compP f P) (C, D, fs, map (compM (f C)) ms')\n\ngoal (1 subgoal):\n 1. distinct_fst ms'", "by(simp add: wf_cdecl_def)"], ["proof (state)\nthis:\n  distinct_fst ms'\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "moreover"], ["proof (state)\nthis:\n  distinct_fst ms'\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "{"], ["proof (state)\nthis:\n  distinct_fst ms'\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "assume CObj: \"C \\<noteq> Object\""], ["proof (state)\nthis:\n  C \\<noteq> Object\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "with xsrc wfcP1"], ["proof (chain)\npicking this:\n  class (compP f P) C = \\<lfloor>(D, fs, map (compM (f C)) ms')\\<rfloor>\n  \\<forall>C rest.\n     class (compP f P) C = \\<lfloor>rest\\<rfloor> \\<longrightarrow>\n     wf_cdecl wf\\<^sub>1 (compP f P) (C, rest)\n  C \\<noteq> Object", "have part1: \"is_class P D\" \"\\<not> P \\<turnstile> D \\<preceq>\\<^sup>* C\""], ["proof (prove)\nusing this:\n  class (compP f P) C = \\<lfloor>(D, fs, map (compM (f C)) ms')\\<rfloor>\n  \\<forall>C rest.\n     class (compP f P) C = \\<lfloor>rest\\<rfloor> \\<longrightarrow>\n     wf_cdecl wf\\<^sub>1 (compP f P) (C, rest)\n  C \\<noteq> Object\n\ngoal (1 subgoal):\n 1. is_class P D &&& \\<not> P \\<turnstile> D \\<preceq>\\<^sup>* C", "by(auto simp add: wf_cdecl_def)"], ["proof (state)\nthis:\n  is_class P D\n  \\<not> P \\<turnstile> D \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "{"], ["proof (state)\nthis:\n  is_class P D\n  \\<not> P \\<turnstile> D \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "assume mset': \"m \\<in> set ms'\""], ["proof (state)\nthis:\n  m \\<in> set ms'\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "with wf1 CObj"], ["proof (chain)\npicking this:\n  wf_cdecl wf\\<^sub>1 (compP f P) (C, D, fs, map (compM (f C)) ms')\n  C \\<noteq> Object\n  m \\<in> set ms'", "have \"wf_overriding (compP f P) D (compM (f C) m)\""], ["proof (prove)\nusing this:\n  wf_cdecl wf\\<^sub>1 (compP f P) (C, D, fs, map (compM (f C)) ms')\n  C \\<noteq> Object\n  m \\<in> set ms'\n\ngoal (1 subgoal):\n 1. wf_overriding (compP f P) D (compM (f C) m)", "by(simp add: wf_cdecl_def del: wf_overriding_compP)"], ["proof (state)\nthis:\n  wf_overriding (compP f P) D (compM (f C) m)\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "hence \"wf_overriding P D m\""], ["proof (prove)\nusing this:\n  wf_overriding (compP f P) D (compM (f C) m)\n\ngoal (1 subgoal):\n 1. wf_overriding P D m", "by simp"], ["proof (state)\nthis:\n  wf_overriding P D m\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "}"], ["proof (state)\nthis:\n  ?m2 \\<in> set ms' \\<Longrightarrow> wf_overriding P D ?m2\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "note this part1"], ["proof (state)\nthis:\n  ?m2 \\<in> set ms' \\<Longrightarrow> wf_overriding P D ?m2\n  is_class P D\n  \\<not> P \\<turnstile> D \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>C \\<noteq> Object; ?m2 \\<in> set ms'\\<rbrakk>\n  \\<Longrightarrow> wf_overriding P D ?m2\n  C \\<noteq> Object \\<Longrightarrow> is_class P D\n  C \\<noteq> Object \\<Longrightarrow>\n  \\<not> P \\<turnstile> D \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>C \\<noteq> Object; ?m2 \\<in> set ms'\\<rbrakk>\n  \\<Longrightarrow> wf_overriding P D ?m2\n  C \\<noteq> Object \\<Longrightarrow> is_class P D\n  C \\<noteq> Object \\<Longrightarrow>\n  \\<not> P \\<turnstile> D \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>C \\<noteq> Object; ?m2 \\<in> set ms'\\<rbrakk>\n  \\<Longrightarrow> wf_overriding P D ?m2\n  C \\<noteq> Object \\<Longrightarrow> is_class P D\n  C \\<noteq> Object \\<Longrightarrow>\n  \\<not> P \\<turnstile> D \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "assume \"C = Thread\""], ["proof (state)\nthis:\n  C = Thread\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "with wf1"], ["proof (chain)\npicking this:\n  wf_cdecl wf\\<^sub>1 (compP f P) (C, D, fs, map (compM (f C)) ms')\n  C = Thread", "have \"\\<exists>m. (run, [], Void, m) \\<in> set ms'\""], ["proof (prove)\nusing this:\n  wf_cdecl wf\\<^sub>1 (compP f P) (C, D, fs, map (compM (f C)) ms')\n  C = Thread\n\ngoal (1 subgoal):\n 1. \\<exists>m. (run, [], Void, m) \\<in> set ms'", "by(fastforce simp add: wf_cdecl_def image_iff compM_def)+"], ["proof (state)\nthis:\n  \\<exists>m. (run, [], Void, m) \\<in> set ms'\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "}"], ["proof (state)\nthis:\n  C = Thread \\<Longrightarrow> \\<exists>m. (run, [], Void, m) \\<in> set ms'\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "ultimately"], ["proof (chain)\npicking this:\n  ?field2 \\<in> set fs \\<Longrightarrow> wf_fdecl P ?field2\n  distinct_fst fs\n  ?m2 \\<in> set ms' \\<Longrightarrow> wf_mdecl wf\\<^sub>2 P C ?m2\n  distinct_fst ms'\n  \\<lbrakk>C \\<noteq> Object; ?m2 \\<in> set ms'\\<rbrakk>\n  \\<Longrightarrow> wf_overriding P D ?m2\n  C \\<noteq> Object \\<Longrightarrow> is_class P D\n  C \\<noteq> Object \\<Longrightarrow>\n  \\<not> P \\<turnstile> D \\<preceq>\\<^sup>* C\n  C = Thread \\<Longrightarrow> \\<exists>m. (run, [], Void, m) \\<in> set ms'", "show ?thesis"], ["proof (prove)\nusing this:\n  ?field2 \\<in> set fs \\<Longrightarrow> wf_fdecl P ?field2\n  distinct_fst fs\n  ?m2 \\<in> set ms' \\<Longrightarrow> wf_mdecl wf\\<^sub>2 P C ?m2\n  distinct_fst ms'\n  \\<lbrakk>C \\<noteq> Object; ?m2 \\<in> set ms'\\<rbrakk>\n  \\<Longrightarrow> wf_overriding P D ?m2\n  C \\<noteq> Object \\<Longrightarrow> is_class P D\n  C \\<noteq> Object \\<Longrightarrow>\n  \\<not> P \\<turnstile> D \\<preceq>\\<^sup>* C\n  C = Thread \\<Longrightarrow> \\<exists>m. (run, [], Void, m) \\<in> set ms'\n\ngoal (1 subgoal):\n 1. wf_cdecl wf\\<^sub>2 P (C, rest)", "unfolding x wf_cdecl_def"], ["proof (prove)\nusing this:\n  ?field2 \\<in> set fs \\<Longrightarrow> wf_fdecl P ?field2\n  distinct_fst fs\n  ?m2 \\<in> set ms' \\<Longrightarrow> wf_mdecl wf\\<^sub>2 P C ?m2\n  distinct_fst ms'\n  \\<lbrakk>C \\<noteq> Object; ?m2 \\<in> set ms'\\<rbrakk>\n  \\<Longrightarrow> wf_overriding P D ?m2\n  C \\<noteq> Object \\<Longrightarrow> is_class P D\n  C \\<noteq> Object \\<Longrightarrow>\n  \\<not> P \\<turnstile> D \\<preceq>\\<^sup>* C\n  C = Thread \\<Longrightarrow> \\<exists>m. (run, [], Void, m) \\<in> set ms'\n\ngoal (1 subgoal):\n 1. case (C, D, fs, ms') of\n    (C, D, fs, ms) \\<Rightarrow>\n      (\\<forall>f\\<in>set fs. wf_fdecl P f) \\<and>\n      distinct_fst fs \\<and>\n      (\\<forall>m\\<in>set ms. wf_mdecl wf\\<^sub>2 P C m) \\<and>\n      distinct_fst ms \\<and>\n      (C \\<noteq> Object \\<longrightarrow>\n       is_class P D \\<and>\n       \\<not> P \\<turnstile> D \\<preceq>\\<^sup>* C \\<and>\n       (\\<forall>m\\<in>set ms. wf_overriding P D m)) \\<and>\n      (C = Thread \\<longrightarrow>\n       (\\<exists>m. (run, [], Void, m) \\<in> set ms))", "by blast"], ["proof (state)\nthis:\n  wf_cdecl wf\\<^sub>2 P (C, rest)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_prog_compPD:\nassumes wf: \"wf_prog wf1 (compP f P)\"\nand lift: \n  \"\\<And>C M Ts T m. \n    \\<lbrakk> compP f P \\<turnstile> C sees M:Ts\\<rightarrow>T = \\<lfloor>f C M Ts T m\\<rfloor> in C; wf_mdecl wf1 (compP f P) C (M,Ts,T, \\<lfloor>f C M Ts T m\\<rfloor>) \\<rbrakk>\n    \\<Longrightarrow> wf_mdecl wf2 P C (M,Ts,T,\\<lfloor>m\\<rfloor>)\"\nshows \"wf_prog wf2 P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf2 P", "using wf"], ["proof (prove)\nusing this:\n  wf_prog wf1 (compP f P)\n\ngoal (1 subgoal):\n 1. wf_prog wf2 P", "apply(clarsimp simp add:wf_prog_def2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C a aa b.\n       \\<lbrakk>wf_syscls P;\n        \\<forall>C a aa b.\n           (\\<exists>ab ac ba.\n               class P C = \\<lfloor>(ab, ac, ba)\\<rfloor> \\<and>\n               snd (compC f (C, ab, ac, ba)) = (a, aa, b)) \\<longrightarrow>\n           wf_cdecl wf1 (compP f P) (C, a, aa, b);\n        distinct_fst (classes P);\n        class P C = \\<lfloor>(a, aa, b)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> wf_cdecl wf2 P (C, a, aa, b)", "apply(rule wf_cdecl_compPD[OF lift], assumption+)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>C a aa b.\n       \\<lbrakk>wf_syscls P;\n        \\<forall>C a aa b.\n           (\\<exists>ab ac ba.\n               class P C = \\<lfloor>(ab, ac, ba)\\<rfloor> \\<and>\n               snd (compC f (C, ab, ac, ba)) = (a, aa, b)) \\<longrightarrow>\n           wf_cdecl wf1 (compP f P) (C, a, aa, b);\n        distinct_fst (classes P);\n        class P C = \\<lfloor>(a, aa, b)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>C rest.\n                            class (compP f P) C =\n                            \\<lfloor>rest\\<rfloor> \\<longrightarrow>\n                            wf_cdecl wf1 (compP f P) (C, rest)\n 2. \\<And>C a aa b.\n       \\<lbrakk>wf_syscls P;\n        \\<forall>C a aa b.\n           (\\<exists>ab ac ba.\n               class P C = \\<lfloor>(ab, ac, ba)\\<rfloor> \\<and>\n               snd (compC f (C, ab, ac, ba)) = (a, aa, b)) \\<longrightarrow>\n           wf_cdecl wf1 (compP f P) (C, a, aa, b);\n        distinct_fst (classes P);\n        class P C = \\<lfloor>(a, aa, b)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> class P C = \\<lfloor>(a, aa, b)\\<rfloor>\n 3. \\<And>C a aa b.\n       \\<lbrakk>wf_syscls P;\n        \\<forall>C a aa b.\n           (\\<exists>ab ac ba.\n               class P C = \\<lfloor>(ab, ac, ba)\\<rfloor> \\<and>\n               snd (compC f (C, ab, ac, ba)) = (a, aa, b)) \\<longrightarrow>\n           wf_cdecl wf1 (compP f P) (C, a, aa, b);\n        distinct_fst (classes P);\n        class P C = \\<lfloor>(a, aa, b)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> wf_prog (?wf_md10 C a aa b) (compP f P)", "apply(auto intro: wf)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WT_binop_compP [simp]: \"compP f P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 :: T \\<longleftrightarrow> P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 :: T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (compP f P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 :: T) =\n    (P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 :: T)", "by(cases bop)(fastforce)+"], ["", "lemma WTrt_binop_compP [simp]: \"compP f P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T \\<longleftrightarrow> P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (compP f P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T) =\n    (P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 : T)", "by(cases bop)(fastforce)+"], ["", "lemma binop_relevant_class_compP [simp]: \"binop_relevant_class bop (compP f P) = binop_relevant_class bop P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. binop_relevant_class bop (compP f P) = binop_relevant_class bop P", "by(cases bop) simp_all"], ["", "lemma is_class_compP [simp]:\n  \"is_class (compP f P) = is_class P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_class (compP f P) = is_class P", "by(simp add: is_class_def fun_eq_iff)"], ["", "lemma has_field_compP [simp]:\n  \"compP f P \\<turnstile> C has F:T (fm) in D \\<longleftrightarrow> P \\<turnstile> C has F:T (fm) in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (compP f P \\<turnstile> C has F:T (fm) in D) =\n    (P \\<turnstile> C has F:T (fm) in D)", "by(auto simp add: has_field_def)"], ["", "context heap_base begin"], ["", "lemma compP_addr_loc_type [simp]:\n  \"addr_loc_type (compP f P) = addr_loc_type P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. addr_loc_type (compP f P) = addr_loc_type P", "by(auto elim!: addr_loc_type.cases intro: addr_loc_type.intros intro!: ext)"], ["", "lemma conf_compP [simp]:\n  \"compP f P,h \\<turnstile> v :\\<le> T \\<longleftrightarrow> P,h \\<turnstile> v :\\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (compP f P,h \\<turnstile> v :\\<le> T) = (P,h \\<turnstile> v :\\<le> T)", "by(simp add: conf_def)"], ["", "lemma compP_conf: \"conf (compP f P) = conf P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf (compP f P) = conf P", "by(auto simp add: conf_def intro!: ext)"], ["", "lemma compP_confs: \"compP f P,h \\<turnstile> vs [:\\<le>] Ts \\<longleftrightarrow> P,h \\<turnstile> vs [:\\<le>] Ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (compP f P,h \\<turnstile> vs [:\\<le>] Ts) =\n    (P,h \\<turnstile> vs [:\\<le>] Ts)", "by(simp add: compP_conf)"], ["", "lemma tconf_compP [simp]: \"compP f P, h \\<turnstile> t \\<surd>t \\<longleftrightarrow> P,h \\<turnstile> t \\<surd>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (compP f P,h \\<turnstile> t \\<surd>t) = (P,h \\<turnstile> t \\<surd>t)", "by(auto simp add: tconf_def)"], ["", "lemma wf_start_state_compP [simp]:\n  \"wf_start_state (compP f P) = wf_start_state P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_start_state (compP f P) = wf_start_state P", "by(auto 4 6 simp add: fun_eq_iff wf_start_state.simps compP_conf dest: sees_method_compP[where f=f] sees_method_compPD[where f=f])"], ["", "end"], ["", "lemma compP_addr_conv:\n  \"addr_conv addr2thread_id thread_id2addr typeof_addr (compP f P) = addr_conv addr2thread_id thread_id2addr typeof_addr P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. addr_conv addr2thread_id thread_id2addr typeof_addr (compP f P) =\n    addr_conv addr2thread_id thread_id2addr typeof_addr P", "unfolding addr_conv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>h a C.\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor> \\<longrightarrow>\n        compP f P \\<turnstile> C \\<preceq>\\<^sup>* Thread \\<longrightarrow>\n        thread_id2addr (addr2thread_id a) = a) =\n    (\\<forall>h a C.\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor> \\<longrightarrow>\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread \\<longrightarrow>\n        thread_id2addr (addr2thread_id a) = a)", "by simp"], ["", "lemma compP_heap:\n  \"heap addr2thead_id thread_id2addr allocate typeof_addr heap_write (compP f P) =\n  heap addr2thead_id thread_id2addr allocate typeof_addr heap_write P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap addr2thead_id thread_id2addr allocate typeof_addr heap_write\n     (compP f P) =\n    heap addr2thead_id thread_id2addr allocate typeof_addr heap_write P", "unfolding heap_def compP_addr_conv heap_axioms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (addr_conv addr2thead_id thread_id2addr typeof_addr P \\<and>\n     (\\<forall>h' a h hT.\n         (h', a) \\<in> allocate h hT \\<longrightarrow>\n         is_htype (compP f P) hT \\<longrightarrow>\n         typeof_addr h' a = \\<lfloor>hT\\<rfloor>) \\<and>\n     (\\<forall>h' h hT a.\n         (h', a) \\<in> allocate h hT \\<longrightarrow>\n         heap_base.hext typeof_addr h h') \\<and>\n     (\\<forall>h a al v h'.\n         heap_write h a al v h' \\<longrightarrow>\n         heap_base.hext typeof_addr h h')) =\n    (addr_conv addr2thead_id thread_id2addr typeof_addr P \\<and>\n     (\\<forall>h' a h hT.\n         (h', a) \\<in> allocate h hT \\<longrightarrow>\n         is_htype P hT \\<longrightarrow>\n         typeof_addr h' a = \\<lfloor>hT\\<rfloor>) \\<and>\n     (\\<forall>h' h hT a.\n         (h', a) \\<in> allocate h hT \\<longrightarrow>\n         heap_base.hext typeof_addr h h') \\<and>\n     (\\<forall>h a al v h'.\n         heap_write h a al v h' \\<longrightarrow>\n         heap_base.hext typeof_addr h h'))", "by auto"], ["", "lemma compP_heap_conf:\n  \"heap_conf addr2thead_id thread_id2addr empty_heap allocate typeof_addr heap_write hconf (compP f P) =\n   heap_conf addr2thead_id thread_id2addr empty_heap allocate typeof_addr heap_write hconf P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_conf addr2thead_id thread_id2addr empty_heap allocate typeof_addr\n     heap_write hconf (compP f P) =\n    heap_conf addr2thead_id thread_id2addr empty_heap allocate typeof_addr\n     heap_write hconf P", "unfolding heap_conf_def heap_conf_axioms_def compP_heap"], ["proof (prove)\ngoal (1 subgoal):\n 1. (heap addr2thead_id thread_id2addr allocate typeof_addr heap_write\n      P \\<and>\n     (hconf empty_heap \\<and>\n      (\\<forall>h a hT.\n          typeof_addr h a = \\<lfloor>hT\\<rfloor> \\<longrightarrow>\n          hconf h \\<longrightarrow> is_htype (compP f P) hT)) \\<and>\n     (\\<forall>h' h hT a.\n         (h', a) \\<in> allocate h hT \\<longrightarrow>\n         hconf h \\<longrightarrow>\n         is_htype (compP f P) hT \\<longrightarrow> hconf h') \\<and>\n     (\\<forall>h a al v h' T.\n         heap_write h a al v h' \\<longrightarrow>\n         hconf h \\<longrightarrow>\n         heap_base.addr_loc_type typeof_addr (compP f P) h a al\n          T \\<longrightarrow>\n         heap_base.conf typeof_addr (compP f P) h v T \\<longrightarrow>\n         hconf h')) =\n    (heap addr2thead_id thread_id2addr allocate typeof_addr heap_write\n      P \\<and>\n     (hconf empty_heap \\<and>\n      (\\<forall>h a hT.\n          typeof_addr h a = \\<lfloor>hT\\<rfloor> \\<longrightarrow>\n          hconf h \\<longrightarrow> is_htype P hT)) \\<and>\n     (\\<forall>h' h hT a.\n         (h', a) \\<in> allocate h hT \\<longrightarrow>\n         hconf h \\<longrightarrow>\n         is_htype P hT \\<longrightarrow> hconf h') \\<and>\n     (\\<forall>h a al v h' T.\n         heap_write h a al v h' \\<longrightarrow>\n         hconf h \\<longrightarrow>\n         heap_base.addr_loc_type typeof_addr P h a al T \\<longrightarrow>\n         heap_base.conf typeof_addr P h v T \\<longrightarrow> hconf h'))", "unfolding heap_base.compP_conf heap_base.compP_addr_loc_type is_type_compP is_class_compP"], ["proof (prove)\ngoal (1 subgoal):\n 1. (heap addr2thead_id thread_id2addr allocate typeof_addr heap_write\n      P \\<and>\n     (hconf empty_heap \\<and>\n      (\\<forall>h a hT.\n          typeof_addr h a = \\<lfloor>hT\\<rfloor> \\<longrightarrow>\n          hconf h \\<longrightarrow> is_htype P hT)) \\<and>\n     (\\<forall>h' h hT a.\n         (h', a) \\<in> allocate h hT \\<longrightarrow>\n         hconf h \\<longrightarrow>\n         is_htype P hT \\<longrightarrow> hconf h') \\<and>\n     (\\<forall>h a al v h' T.\n         heap_write h a al v h' \\<longrightarrow>\n         hconf h \\<longrightarrow>\n         heap_base.addr_loc_type typeof_addr P h a al T \\<longrightarrow>\n         heap_base.conf typeof_addr P h v T \\<longrightarrow> hconf h')) =\n    (heap addr2thead_id thread_id2addr allocate typeof_addr heap_write\n      P \\<and>\n     (hconf empty_heap \\<and>\n      (\\<forall>h a hT.\n          typeof_addr h a = \\<lfloor>hT\\<rfloor> \\<longrightarrow>\n          hconf h \\<longrightarrow> is_htype P hT)) \\<and>\n     (\\<forall>h' h hT a.\n         (h', a) \\<in> allocate h hT \\<longrightarrow>\n         hconf h \\<longrightarrow>\n         is_htype P hT \\<longrightarrow> hconf h') \\<and>\n     (\\<forall>h a al v h' T.\n         heap_write h a al v h' \\<longrightarrow>\n         hconf h \\<longrightarrow>\n         heap_base.addr_loc_type typeof_addr P h a al T \\<longrightarrow>\n         heap_base.conf typeof_addr P h v T \\<longrightarrow> hconf h'))", "by(rule refl)"], ["", "lemma compP_heap_conf_read:\n  \"heap_conf_read addr2thead_id thread_id2addr empty_heap allocate typeof_addr heap_read heap_write hconf (compP f P) =\n   heap_conf_read addr2thead_id thread_id2addr empty_heap allocate typeof_addr heap_read heap_write hconf P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_conf_read addr2thead_id thread_id2addr empty_heap allocate\n     typeof_addr heap_read heap_write hconf (compP f P) =\n    heap_conf_read addr2thead_id thread_id2addr empty_heap allocate\n     typeof_addr heap_read heap_write hconf P", "unfolding heap_conf_read_def heap_conf_read_axioms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (heap_conf addr2thead_id thread_id2addr empty_heap allocate typeof_addr\n      heap_write hconf (compP f P) \\<and>\n     (\\<forall>h a al v T.\n         heap_read h a al v \\<longrightarrow>\n         heap_base.addr_loc_type typeof_addr (compP f P) h a al\n          T \\<longrightarrow>\n         hconf h \\<longrightarrow>\n         heap_base.conf typeof_addr (compP f P) h v T)) =\n    (heap_conf addr2thead_id thread_id2addr empty_heap allocate typeof_addr\n      heap_write hconf P \\<and>\n     (\\<forall>h a al v T.\n         heap_read h a al v \\<longrightarrow>\n         heap_base.addr_loc_type typeof_addr P h a al T \\<longrightarrow>\n         hconf h \\<longrightarrow> heap_base.conf typeof_addr P h v T))", "unfolding compP_heap_conf heap_base.compP_conf heap_base.compP_addr_loc_type"], ["proof (prove)\ngoal (1 subgoal):\n 1. (heap_conf addr2thead_id thread_id2addr empty_heap allocate typeof_addr\n      heap_write hconf P \\<and>\n     (\\<forall>h a al v T.\n         heap_read h a al v \\<longrightarrow>\n         heap_base.addr_loc_type typeof_addr P h a al T \\<longrightarrow>\n         hconf h \\<longrightarrow> heap_base.conf typeof_addr P h v T)) =\n    (heap_conf addr2thead_id thread_id2addr empty_heap allocate typeof_addr\n      heap_write hconf P \\<and>\n     (\\<forall>h a al v T.\n         heap_read h a al v \\<longrightarrow>\n         heap_base.addr_loc_type typeof_addr P h a al T \\<longrightarrow>\n         hconf h \\<longrightarrow> heap_base.conf typeof_addr P h v T))", "by(rule refl)"], ["", "text \\<open>compiler composition\\<close>"], ["", "lemma compM_compM:\n  \"compM f (compM g md) = compM (\\<lambda>M Ts T. f M Ts T \\<circ> g M Ts T) md\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compM f (compM g md) =\n    compM (\\<lambda>M Ts T. f M Ts T \\<circ> g M Ts T) md", "by(cases md)(simp add: compM_def option.map_comp o_def)"], ["", "lemma compC_compC:\n  \"compC f (compC g cd) = compC (\\<lambda>C M Ts T. f C M Ts T \\<circ> g C M Ts T) cd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compC f (compC g cd) =\n    compC (\\<lambda>C M Ts T. f C M Ts T \\<circ> g C M Ts T) cd", "by(simp add: compC_def split_beta compM_compM)"], ["", "lemma compP_compP:\n  \"compP f (compP g P) = compP (\\<lambda>C M Ts T. f C M Ts T \\<circ> g C M Ts T) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compP f (compP g P) =\n    compP (\\<lambda>C M Ts T. f C M Ts T \\<circ> g C M Ts T) P", "by(cases P)(simp add: compC_compC)"], ["", "end"]]}