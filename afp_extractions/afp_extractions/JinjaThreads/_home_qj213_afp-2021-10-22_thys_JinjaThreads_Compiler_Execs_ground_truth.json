{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Compiler/Execs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma ci_stk_offerI:\n  \"(\\<And>ins P h stk stk' loc C M pc frs. ci ins P h stk loc C M pc frs \\<Longrightarrow> ci ins P h (stk @ stk') loc C M pc frs) \\<Longrightarrow> ci_stk_offer ci\"", "lemma ci_stk_offerD:\n  \"\\<lbrakk> ci_stk_offer ci; ci ins P h stk loc C M pc frs \\<rbrakk> \\<Longrightarrow> ci ins P h (stk @ stk') loc C M pc frs\"", "lemma check_instr'_stk_offer:\n  \"ci_stk_offer check_instr'\"", "lemma check_instr_imp_check_instr':\n  \"check_instr ins P h stk loc C M pc frs \\<Longrightarrow> check_instr' ins P h stk loc C M pc frs\"", "lemma check_instr_stk_offer:\n  \"ci_stk_offer check_instr\"", "lemma jump_ok_append [simp]:\n  \"jump_ok (xs @ xs') n n' \\<longleftrightarrow> jump_ok xs n (n' + length xs') \\<and> jump_ok xs' (n + length xs) n'\"", "lemma jump_ok_GotoD:\n  \"\\<lbrakk> jump_ok ins n n'; ins ! pc = Goto m; pc < length ins \\<rbrakk> \\<Longrightarrow> - int (pc + n) \\<le> m \\<and> m < int (length ins - pc + n')\"", "lemma jump_ok_IfFalseD:\n  \"\\<lbrakk> jump_ok ins n n'; ins ! pc = IfFalse m; pc < length ins \\<rbrakk> \\<Longrightarrow> - int (pc + n) \\<le> m \\<and> m < int (length ins - pc + n')\"", "lemma fixes e :: \"'addr expr1\" and es :: \"'addr expr1 list\"\n  shows compE2_jump_ok [intro!]: \"jump_ok (compE2 e) n (Suc n')\"\n  and compEs2_jump_ok [intro!]: \"jump_ok (compEs2 es) n (Suc n')\"", "lemma fixes e :: \"'addr expr1\" and es :: \"'addr expr1 list\"\n  shows compE1_Goto_not_same: \"\\<lbrakk> compE2 e ! pc = Goto i; pc < length (compE2 e) \\<rbrakk> \\<Longrightarrow> nat (int pc + i) \\<noteq> pc\"\n  and compEs2_Goto_not_same: \"\\<lbrakk> compEs2 es ! pc = Goto i; pc < length (compEs2 es) \\<rbrakk> \\<Longrightarrow> nat (int pc + i) \\<noteq> pc\"", "lemma wf_ciI:\n  \"\\<lbrakk> ci_stk_offer ci;\n    \\<And>ins P h stk loc C M pc frs. ci ins P h stk loc C M pc frs \\<Longrightarrow> check_instr' ins P h stk loc C M pc frs;\n    \\<And>ins P h stk loc C M pc pc' frs. \\<lbrakk> ci ins P h stk loc C M pc frs; ins_jump_ok ins pc' \\<rbrakk> \\<Longrightarrow> ci ins P h stk loc C M pc' frs \\<rbrakk>\n  \\<Longrightarrow> wf_ci ci\"", "lemma check_instr'_pc:\n  \"\\<lbrakk> check_instr' ins P h stk loc C M pc frs; ins_jump_ok ins pc' \\<rbrakk> \\<Longrightarrow> check_instr' ins P h stk loc C M pc' frs\"", "lemma wf_ci_check_instr' [iff]:\n  \"wf_ci check_instr'\"", "lemma jump_ok_ins_jump_ok:\n  \"\\<lbrakk> jump_ok ins n n'; pc < length ins \\<rbrakk> \\<Longrightarrow> ins_jump_ok (ins ! pc) (pc + n)\"", "lemma check_instr_pc:\n  \"\\<lbrakk> check_instr ins P h stk loc C M pc frs; ins_jump_ok ins pc' \\<rbrakk> \\<Longrightarrow> check_instr ins P h stk loc C M pc' frs\"", "lemma wf_ci_check_instr [iff]:\n  \"wf_ci check_instr\"", "lemma wf_ciD1: \"wf_ci ci \\<Longrightarrow> ci_stk_offer ci\"", "lemma wf_ciD2: \"\\<lbrakk> wf_ci ci; ci ins P h stk loc C M pc frs \\<rbrakk> \\<Longrightarrow> check_instr' ins P h stk loc C M pc frs\"", "lemma wf_ciD3: \"\\<lbrakk> wf_ci ci; ci ins P h stk loc C M pc frs; ins_jump_ok ins pc' \\<rbrakk> \\<Longrightarrow> ci ins P h stk loc C M pc' frs\"", "lemma check_instr'_ins_jump_ok: \"check_instr' ins P h stk loc C M pc frs \\<Longrightarrow> ins_jump_ok ins pc\"", "lemma wf_ci_ins_jump_ok:\n  assumes wf: \"wf_ci ci\"\n  and ci: \"ci ins P h stk loc C M pc frs\"\n  and pc': \"pc \\<le> pc'\"\n  shows \"ins_jump_ok ins pc'\"", "lemma wf_ciD3': \"\\<lbrakk> wf_ci ci; ci ins P h stk loc C M pc frs; pc \\<le> pc' \\<rbrakk> \\<Longrightarrow> ci ins P h stk loc C M pc' frs\"", "lemma ci_app_check_instr' [simp]: \"ci_app (Abs_check_instr check_instr') = check_instr'\"", "lemma (in JVM_heap_base) ci_app_check_instr [simp]: \"ci_app (Abs_check_instr check_instr) = check_instr\"", "lemma wf_ci_stk_offerD:\n  \"ci_app ci ins P h stk loc C M pc frs \\<Longrightarrow> ci_app ci ins P h (stk @ stk') loc C M pc frs\"", "lemma wf_ciD2_ci_app:\n  \"ci_app ci ins P h stk loc C M pc frs \\<Longrightarrow> check_instr' ins P h stk loc C M pc frs\"", "lemma wf_ciD3_ci_app:\n  \"\\<lbrakk> ci_app ci ins P h stk loc C M pc frs; ins_jump_ok ins pc' \\<rbrakk> \\<Longrightarrow> ci_app ci ins P h stk loc C M pc' frs\"", "lemma wf_ciD3'_ci_app: \"\\<lbrakk> ci_app ci ins P h stk loc C M pc frs; pc \\<le> pc' \\<rbrakk> \\<Longrightarrow> ci_app ci ins P h stk loc C M pc' frs\"", "lemma exec_meth_instr:\n  \"exec_meth ci P ins xt t h (stk, loc, pc, None) ta h' (stk', loc', pc', xcp) \\<longleftrightarrow>\n   (ta, xcp, h', [(stk', loc', undefined, undefined, pc')]) \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [] \\<and> pc < length ins \\<and> ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\"", "lemma exec_meth_xcpt:\n  \"exec_meth ci P ins xt t h (stk, loc, pc, \\<lfloor>xcp\\<rfloor>) ta h (stk', loc', pc', xcp') \\<longleftrightarrow>\n   (\\<exists>d. match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d)\\<rfloor> \\<and> ta = \\<epsilon> \\<and> stk' = (Addr xcp # drop (size stk - d) stk) \\<and> loc' = loc \\<and> xcp' = None \\<and> d \\<le> length stk)\"", "lemma exec_meth_length_compE2D [dest]:\n  \"exec_meth ci P (compE2 e) (compxE2 e 0 d) t h (stk, loc, pc, xcp) ta h' s' \\<Longrightarrow> pc < length (compE2 e)\"", "lemma exec_meth_length_compEs2D [dest]:\n  \"exec_meth ci P (compEs2 es) (compxEs2 es 0 0) t h (stk, loc, pc, xcp) ta h' s' \\<Longrightarrow> pc < length (compEs2 es)\"", "lemma exec_instr_stk_offer:\n  assumes check: \"check_instr' (ins ! pc) P h stk loc C M pc frs\"\n  and exec: \"(ta', xcp', h', (stk', loc', C, M, pc') # frs) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\"\n  shows \"(ta', xcp', h', (stk' @ stk'', loc', C, M, pc') # frs) \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc C M pc frs\"", "lemma exec_meth_stk_offer:\n  assumes exec: \"exec_meth ci P ins xt t h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  shows \"exec_meth ci P ins (stack_xlift (length stk'') xt) t h (stk @ stk'', loc, pc, xcp) ta h' (stk' @ stk'', loc', pc', xcp')\"", "lemma exec_meth_append_xt [intro]:\n  \"exec_meth ci P ins xt t h s ta h' s'\n  \\<Longrightarrow> exec_meth ci P (ins @ ins') (xt @ xt') t h s ta h' s'\"", "lemma exec_meth_append [intro]:\n  \"exec_meth ci P ins xt t h s ta h' s' \\<Longrightarrow> exec_meth ci P (ins @ ins') xt t h s ta h' s'\"", "lemma append_exec_meth_xt:\n  assumes exec: \"exec_meth ci P ins xt t h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  and jump: \"jump_ok ins 0 n\"\n  and pcs: \"pcs xt' \\<subseteq> {0..<length ins'}\"\n  shows \"exec_meth ci P (ins' @ ins) (xt' @ shift (length ins') xt) t h (stk, loc, (length ins' + pc), xcp) ta h' (stk', loc', (length ins' + pc'), xcp')\"", "lemma append_exec_meth:\n  assumes exec: \"exec_meth ci P ins xt t h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  and jump: \"jump_ok ins 0 n\"\n  shows \"exec_meth ci P (ins' @ ins) (shift (length ins') xt) t h (stk, loc, (length ins' + pc), xcp) ta h' (stk', loc', (length ins' + pc'), xcp')\"", "lemma exec_meth_take_xt':\n  \"\\<lbrakk> exec_meth ci P (ins @ ins') (xt' @ xt) t h (stk, loc, pc, xcp) ta h' s';\n    pc < length ins; pc \\<notin> pcs xt \\<rbrakk>\n  \\<Longrightarrow> exec_meth ci P ins xt' t h (stk, loc, pc, xcp) ta h' s'\"", "lemma exec_meth_take_xt:\n  \"\\<lbrakk> exec_meth ci P (ins @ ins') (xt' @ shift (length ins) xt) t h (stk, loc, pc, xcp) ta h' s';\n    pc < length ins \\<rbrakk>\n  \\<Longrightarrow> exec_meth ci P ins xt' t h (stk, loc, pc, xcp) ta h' s'\"", "lemma exec_meth_take:\n  \"\\<lbrakk> exec_meth ci P (ins @ ins') xt t h (stk, loc, pc, xcp) ta h' s';\n    pc < length ins \\<rbrakk>\n  \\<Longrightarrow> exec_meth ci P ins xt t h (stk, loc, pc, xcp) ta h' s'\"", "lemma exec_meth_drop_xt:\n  assumes exec: \"exec_meth ci P (ins @ ins') (xt @ shift (length ins) xt') t h (stk, loc, (length ins + pc), xcp) ta h' (stk', loc', pc', xcp')\"\n  and xt: \"pcs xt \\<subseteq> {..<length ins}\"\n  and jump: \"jump_ok ins' 0 n\"\n  shows \"exec_meth ci P ins' xt' t h (stk, loc, pc, xcp) ta h' (stk', loc', (pc' - length ins), xcp')\"", "lemma exec_meth_drop:\n  \"\\<lbrakk> exec_meth ci P (ins @ ins') (shift (length ins) xt) t h (stk, loc, (length ins + pc), xcp) ta h' (stk', loc', pc', xcp');\n     jump_ok ins' 0 b \\<rbrakk>\n   \\<Longrightarrow> exec_meth ci P ins' xt t h (stk, loc, pc, xcp) ta h' (stk', loc', (pc' - length ins), xcp')\"", "lemma exec_meth_drop_xt_pc:\n  assumes exec: \"exec_meth ci P (ins @ ins') (xt @ shift (length ins) xt') t h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  and pc: \"pc \\<ge> length ins\"\n  and pcs: \"pcs xt \\<subseteq> {..<length ins}\"\n  and jump: \"jump_ok ins' 0 n'\"\n  shows \"pc' \\<ge> length ins\"", "lemmas exec_meth_drop_pc = exec_meth_drop_xt_pc[where xt=\"[]\", simplified]", "lemma exec_move_newArrayI:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (newA T\\<lfloor>e\\<rceil>) h s ta h' s'\"", "lemma exec_move_newArray:\n  \"pc < length (compE2 e) \\<Longrightarrow> exec_move ci P t (newA T\\<lfloor>e\\<rceil>) h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\"", "lemma exec_move_CastI:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (Cast T e) h s ta h' s'\"", "lemma exec_move_Cast:\n  \"pc < length (compE2 e) \\<Longrightarrow> exec_move ci P t (Cast T e) h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\"", "lemma exec_move_InstanceOfI:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (e instanceof T) h s ta h' s'\"", "lemma exec_move_InstanceOf:\n  \"pc < length (compE2 e) \\<Longrightarrow> exec_move ci P t (e instanceof T) h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\"", "lemma exec_move_BinOpI1:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (e \\<guillemotleft>bop\\<guillemotright> e') h s ta h' s'\"", "lemma exec_move_BinOp1:\n  \"pc < length (compE2 e) \\<Longrightarrow> exec_move ci P t (e \\<guillemotleft>bop\\<guillemotright> e') h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\"", "lemma exec_move_BinOpI2:\n  assumes exec: \"exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  shows \"exec_move ci P t (e1 \\<guillemotleft>bop\\<guillemotright> e2) h (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h' (stk' @ [v], loc', length (compE2 e1) + pc', xcp')\"", "lemma exec_move_LAssI:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (V := e) h s ta h' s'\"", "lemma exec_move_LAss:\n  \"pc < length (compE2 e) \\<Longrightarrow> exec_move ci P t (V := e) h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\"", "lemma exec_move_AAccI1:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (e\\<lfloor>e'\\<rceil>) h s ta h' s'\"", "lemma exec_move_AAcc1:\n  \"pc < length (compE2 e) \\<Longrightarrow> exec_move ci P t (e\\<lfloor>e'\\<rceil>) h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\"", "lemma exec_move_AAccI2:\n  assumes exec: \"exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  shows \"exec_move ci P t (e1\\<lfloor>e2\\<rceil>) h (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h' (stk' @ [v], loc', length (compE2 e1) + pc', xcp')\"", "lemma exec_move_AAssI1:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (e\\<lfloor>e'\\<rceil> := e'') h s ta h' s'\"", "lemma exec_move_AAss1:\n  assumes pc: \"pc < length (compE2 e)\"\n  shows \"exec_move ci P t (e\\<lfloor>e'\\<rceil> := e'') h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\"\n  (is \"?lhs = ?rhs\")", "lemma exec_move_AAssI2:\n  assumes exec: \"exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  shows \"exec_move ci P t (e1\\<lfloor>e2\\<rceil> := e3) h (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h' (stk' @ [v], loc', length (compE2 e1) + pc', xcp')\"", "lemma exec_move_AAssI3:\n  assumes exec: \"exec_move ci P t e3 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  shows \"exec_move ci P t (e1\\<lfloor>e2\\<rceil> := e3) h (stk @ [v', v], loc, length (compE2 e1) + length (compE2 e2) + pc, xcp) ta h' (stk' @ [v', v], loc', length (compE2 e1) + length (compE2 e2) + pc', xcp')\"", "lemma exec_move_ALengthI:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (e\\<bullet>length) h s ta h' s'\"", "lemma exec_move_ALength:\n  \"pc < length (compE2 e) \\<Longrightarrow> exec_move ci P t (e\\<bullet>length) h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\"", "lemma exec_move_FAccI:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (e\\<bullet>F{D}) h s ta h' s'\"", "lemma exec_move_FAcc:\n  \"pc < length (compE2 e) \\<Longrightarrow> exec_move ci P t (e\\<bullet>F{D}) h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\"", "lemma exec_move_FAssI1:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (e\\<bullet>F{D} := e') h s ta h' s'\"", "lemma exec_move_FAss1:\n  \"pc < length (compE2 e) \\<Longrightarrow> exec_move ci P t (e\\<bullet>F{D} := e') h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\"", "lemma exec_move_FAssI2:\n  assumes exec: \"exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  shows \"exec_move ci P t (e1\\<bullet>F{D} := e2) h (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h' (stk' @ [v], loc', length (compE2 e1) + pc', xcp')\"", "lemma exec_move_CASI1:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h s ta h' s'\"", "lemma exec_move_CAS1:\n  assumes pc: \"pc < length (compE2 e)\"\n  shows \"exec_move ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\"\n  (is \"?lhs = ?rhs\")", "lemma exec_move_CASI2:\n  assumes exec: \"exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  shows \"exec_move ci P t (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) h (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h' (stk' @ [v], loc', length (compE2 e1) + pc', xcp')\"", "lemma exec_move_CASI3:\n  assumes exec: \"exec_move ci P t e3 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  shows \"exec_move ci P t (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) h (stk @ [v', v], loc, length (compE2 e1) + length (compE2 e2) + pc, xcp) ta h' (stk' @ [v', v], loc', length (compE2 e1) + length (compE2 e2) + pc', xcp')\"", "lemma exec_move_CallI1:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (e\\<bullet>M(es)) h s ta h' s'\"", "lemma exec_move_Call1:\n  \"pc < length (compE2 e) \\<Longrightarrow> exec_move ci P t (e\\<bullet>M(es)) h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\"", "lemma exec_move_CallI2:\n  assumes exec: \"exec_moves ci P t es h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  shows \"exec_move ci P t (e\\<bullet>M(es)) h (stk @ [v], loc, length (compE2 e) + pc, xcp) ta h' (stk' @ [v], loc', length (compE2 e) + pc', xcp')\"", "lemma exec_move_BlockNoneI:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t {V:T=None; e} h s ta h' s'\"", "lemma exec_move_BlockNone:\n  \"exec_move ci P t {V:T=None; e} = exec_move ci P t e\"", "lemma exec_move_BlockSomeI:\n  assumes exec: \"exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  shows \"exec_move ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h (stk, loc, Suc (Suc pc), xcp) ta h' (stk', loc', Suc (Suc pc'), xcp')\"", "lemma exec_move_BlockSome:\n  \"exec_move ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h (stk, loc, Suc (Suc pc), xcp) ta h' (stk', loc', Suc (Suc pc'), xcp') =\n   exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\" (is \"?lhs = ?rhs\")", "lemma exec_move_SyncI1:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (sync\\<^bsub>V\\<^esub> (e) e') h s ta h' s'\"", "lemma exec_move_Sync1:\n  assumes pc: \"pc < length (compE2 e)\"\n  shows \"exec_move ci P t (sync\\<^bsub>V\\<^esub> (e) e') h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\"\n  (is \"?lhs = ?rhs\")", "lemma exec_move_SyncI2:\n  assumes exec: \"exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  shows \"exec_move ci P t (sync\\<^bsub>V\\<^esub> (o') e) h (stk, loc, (Suc (Suc (Suc (length (compE2 o') + pc)))), xcp) ta h' (stk', loc', (Suc (Suc (Suc (length (compE2 o') + pc')))), xcp')\"", "lemma exec_move_SeqI1:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (e;;e') h s ta h' s'\"", "lemma exec_move_Seq1:\n  assumes pc: \"pc < length (compE2 e)\"\n  shows \"exec_move ci P t (e;;e') h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\"\n  (is \"?lhs = ?rhs\")", "lemma exec_move_SeqI2:\n  assumes exec: \"exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc' ,xcp')\"\n  shows \"exec_move ci P t (e';;e) h (stk, loc, (Suc (length (compE2 e') + pc)), xcp) ta h' (stk', loc', (Suc (length (compE2 e') + pc')), xcp')\"", "lemma exec_move_Seq2:\n  assumes pc: \"pc < length (compE2 e)\"\n  shows \"exec_move ci P t (e';;e) h (stk, loc, Suc (length (compE2 e') + pc), xcp) ta\n                                h' (stk', loc', Suc (length (compE2 e') + pc'), xcp') =\n         exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  (is \"?lhs = ?rhs\")", "lemma exec_move_CondI1:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (if (e) e1 else e2) h s ta h' s'\"", "lemma exec_move_Cond1:\n  assumes pc: \"pc < length (compE2 e)\"\n  shows \"exec_move ci P t (if (e) e1 else e2) h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\"\n  (is \"?lhs = ?rhs\")", "lemma exec_move_CondI2:\n  assumes exec: \"exec_move ci P t e1 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  shows \"exec_move ci P t (if (e) e1 else e2) h (stk, loc, (Suc (length (compE2 e) + pc)), xcp) ta h' (stk', loc', (Suc (length (compE2 e) + pc')), xcp')\"", "lemma exec_move_Cond2:\n  assumes pc: \"pc < length (compE2 e1)\"\n  shows \"exec_move ci P t (if (e) e1 else e2) h (stk, loc, (Suc (length (compE2 e) + pc)), xcp) ta h' (stk', loc', (Suc (length (compE2 e) + pc')), xcp') = exec_move ci P t e1 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  (is \"?lhs = ?rhs\")", "lemma exec_move_CondI3:\n  assumes exec: \"exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  shows \"exec_move ci P t (if (e) e1 else e2) h (stk, loc, Suc (Suc (length (compE2 e) + length (compE2 e1) + pc)), xcp) ta h' (stk', loc', Suc (Suc (length (compE2 e) + length (compE2 e1) + pc')), xcp')\"", "lemma exec_move_Cond3:\n  \"exec_move ci P t (if (e) e1 else e2) h (stk, loc, Suc (Suc (length (compE2 e) + length (compE2 e1) + pc)), xcp) ta\n                                      h' (stk', loc', Suc (Suc (length (compE2 e) + length (compE2 e1) + pc')), xcp') =\n   exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  (is \"?lhs = ?rhs\")", "lemma exec_move_WhileI1:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (while (e) e') h s ta h' s'\"", "lemma (in ab_group_add) uminus_minus_left_commute:\n  \"- a - (b + c) = - b - (a + c)\"", "lemma exec_move_While1:\n  assumes pc: \"pc < length (compE2 e)\"\n  shows \"exec_move ci P t (while (e) e') h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\"\n  (is \"?lhs = ?rhs\")", "lemma exec_move_WhileI2:\n  assumes exec: \"exec_move ci P t e1 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  shows \"exec_move ci P t (while (e) e1) h (stk, loc, (Suc (length (compE2 e) + pc)), xcp) ta h' (stk', loc', (Suc (length (compE2 e) + pc')), xcp')\"", "lemma exec_move_While2:\n  assumes pc: \"pc < length (compE2 e')\"\n  shows \"exec_move ci P t (while (e) e') h (stk, loc, (Suc (length (compE2 e) + pc)), xcp) ta\n                                    h' (stk', loc', (Suc (length (compE2 e) + pc')), xcp') =\n         exec_move ci P t e' h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  (is \"?lhs = ?rhs\")", "lemma exec_move_ThrowI:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (throw e) h s ta h' s'\"", "lemma exec_move_Throw:\n  \"pc < length (compE2 e) \\<Longrightarrow> exec_move ci P t (throw e) h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\"", "lemma exec_move_TryI1:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (try e catch(C V) e') h s ta h' s'\"", "lemma exec_move_TryI2:\n  assumes exec: \"exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  shows \"exec_move ci P t (try e' catch(C V) e) h (stk, loc, Suc (Suc (length (compE2 e') + pc)), xcp) ta h' (stk', loc', Suc (Suc (length (compE2 e') + pc')), xcp')\"", "lemma exec_move_Try2:\n  \"exec_move ci P t (try e catch(C V) e') h (stk, loc, Suc (Suc (length (compE2 e) + pc)), xcp) ta\n                                     h' (stk', loc', Suc (Suc (length (compE2 e) + pc')), xcp') =\n   exec_move ci P t e' h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  (is \"?lhs = ?rhs\")", "lemma exec_move_raise_xcp_pcD:\n  \"exec_move ci P t E h (stk, loc, pc, None) ta h' (stk', loc', pc', Some a) \\<Longrightarrow> pc' = pc\"", "lemma \\<tau>exec_methI [intro]:\n  \"\\<lbrakk> exec_meth ci P ins xt t h (stk, loc, pc, xcp) \\<epsilon> h s'; xcp = None \\<Longrightarrow> \\<tau>instr P h stk (ins ! pc) \\<rbrakk>\n   \\<Longrightarrow> \\<tau>exec_meth ci P ins xt t h (stk, loc, pc, xcp) s'\"", "lemma \\<tau>exec_methE [elim]:\n  assumes \"\\<tau>exec_meth ci P ins xt t h s s'\"\n  obtains stk loc pc xcp\n  where \"s = (stk, loc, pc, xcp)\"\n  and \"exec_meth ci P ins xt t h (stk, loc, pc, xcp) \\<epsilon> h s'\"\n  and \"xcp = None \\<Longrightarrow> \\<tau>instr P h stk (ins ! pc)\"", "lemma \\<tau>Exec_methr_refl: \"\\<tau>Exec_methr ci P ins xt t h s s\"", "lemma \\<tau>Exec_methr_step':\n  \"\\<lbrakk> \\<tau>Exec_methr ci P ins xt t h s (stk', loc', pc', xcp');\n     \\<tau>exec_meth ci P ins xt t h (stk', loc', pc', xcp') s' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>Exec_methr ci P ins xt t h s s'\"", "lemma \\<tau>Exec_methr_step:\n  \"\\<lbrakk> \\<tau>Exec_methr ci P ins xt t h s (stk', loc', pc', xcp');\n     exec_meth ci P ins xt t h (stk', loc', pc', xcp') \\<epsilon> h s';\n     xcp' = None \\<Longrightarrow> \\<tau>instr P h stk' (ins ! pc') \\<rbrakk>\n  \\<Longrightarrow> \\<tau>Exec_methr ci P ins xt t h s s'\"", "lemmas \\<tau>Exec_methr_intros = \\<tau>Exec_methr_refl \\<tau>Exec_methr_step", "lemmas \\<tau>Exec_methr1step = \\<tau>Exec_methr_step[OF \\<tau>Exec_methr_refl]", "lemmas \\<tau>Exec_methr2step = \\<tau>Exec_methr_step[OF \\<tau>Exec_methr_step, OF \\<tau>Exec_methr_refl]", "lemmas \\<tau>Exec_methr3step = \\<tau>Exec_methr_step[OF \\<tau>Exec_methr_step, OF \\<tau>Exec_methr_step, OF \\<tau>Exec_methr_refl]", "lemma \\<tau>Exec_methr_cases [consumes 1, case_names refl step]:\n  assumes \"\\<tau>Exec_methr ci P ins xt t h s s'\"\n  obtains \"s = s'\"\n  | stk' loc' pc' xcp'\n    where \"\\<tau>Exec_methr ci P ins xt t h s (stk', loc', pc', xcp')\"\n       \"exec_meth ci P ins xt t h (stk', loc', pc', xcp') \\<epsilon> h s'\"\n       \"xcp' = None \\<Longrightarrow> \\<tau>instr P h stk' (ins ! pc')\"", "lemma \\<tau>Exec_methr_induct [consumes 1, case_names refl step]:\n  \"\\<lbrakk> \\<tau>Exec_methr ci P ins xt t h s s';\n     Q s;\n     \\<And>stk loc pc xcp s'. \\<lbrakk> \\<tau>Exec_methr ci P ins xt t h s (stk, loc, pc, xcp); exec_meth ci P ins xt t h (stk, loc, pc, xcp) \\<epsilon> h s';\n                          xcp = None \\<Longrightarrow> \\<tau>instr P h stk (ins ! pc); Q (stk, loc, pc, xcp) \\<rbrakk> \\<Longrightarrow> Q s' \\<rbrakk>\n  \\<Longrightarrow> Q s'\"", "lemma \\<tau>Exec_methr_trans: \n  \"\\<lbrakk> \\<tau>Exec_methr ci P ins xt t h s s'; \\<tau>Exec_methr ci P ins xt t h s' s'' \\<rbrakk> \\<Longrightarrow> \\<tau>Exec_methr ci P ins xt t h s s''\"", "lemmas \\<tau>Exec_meth_induct_split = \\<tau>Exec_methr_induct[split_format (complete), consumes 1, case_names \\<tau>Exec_refl \\<tau>Exec_step]", "lemma \\<tau>Exec_methr_converse_cases [consumes 1, case_names refl step]:\n  assumes \"\\<tau>Exec_methr ci P ins xt t h s s'\"\n  obtains \"s = s'\"\n  | stk loc pc xcp s''\n    where \"s = (stk, loc, pc, xcp)\"\n       \"exec_meth ci P ins xt t h (stk, loc, pc, xcp) \\<epsilon> h s''\"\n       \"xcp = None \\<Longrightarrow> \\<tau>instr P h stk (ins ! pc)\"\n       \"\\<tau>Exec_methr ci P ins xt t h s'' s'\"", "lemma \\<tau>exec_moveI:\n  \"\\<lbrakk> exec_move ci P t e h (stk, loc, pc, xcp) \\<epsilon> h s'; \\<tau>move2 P h stk e pc xcp \\<rbrakk> \n  \\<Longrightarrow> \\<tau>exec_move ci P t e h (stk, loc, pc, xcp) s'\"", "lemma \\<tau>exec_moveE:\n  assumes \"\\<tau>exec_move ci P t e h (stk, loc, pc, xcp) s'\"\n  obtains \"exec_move ci P t e h (stk, loc, pc, xcp) \\<epsilon> h s'\" \"\\<tau>move2 P h stk e pc xcp\"", "lemma \\<tau>exec_movesI:\n  \"\\<lbrakk> exec_moves ci P t es h (stk, loc, pc, xcp) \\<epsilon> h s'; \\<tau>moves2 P h stk es pc xcp \\<rbrakk> \n  \\<Longrightarrow> \\<tau>exec_moves ci P t es h (stk, loc, pc, xcp) s'\"", "lemma \\<tau>exec_movesE:\n  assumes \"\\<tau>exec_moves ci P t es h (stk, loc, pc, xcp) s'\"\n  obtains \"exec_moves ci P t es h (stk, loc, pc, xcp) \\<epsilon> h s'\" \"\\<tau>moves2 P h stk es pc xcp\"", "lemma \\<tau>exec_move_conv_\\<tau>exec_meth:\n  \"\\<tau>exec_move ci P t e = \\<tau>exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t\"", "lemma \\<tau>exec_moves_conv_\\<tau>exec_meth:\n  \"\\<tau>exec_moves ci P t es = \\<tau>exec_meth ci (compP2 P) (compEs2 es) (compxEs2 es 0 0) t\"", "lemma \\<tau>Execr_refl: \"\\<tau>Exec_mover ci P t e h s s\"", "lemma \\<tau>Execsr_refl: \"\\<tau>Exec_movesr ci P t e h s s\"", "lemma \\<tau>Execr_step: \n  \"\\<lbrakk> \\<tau>Exec_mover ci P t e h s (stk', loc', pc', xcp');\n     exec_move ci P t e h (stk', loc', pc', xcp') \\<epsilon> h s';\n     \\<tau>move2 P h stk' e pc' xcp' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>Exec_mover ci P t e h s s'\"", "lemma \\<tau>Execsr_step: \n  \"\\<lbrakk> \\<tau>Exec_movesr ci P t es h s (stk', loc', pc', xcp');\n     exec_moves ci P t es h (stk', loc', pc', xcp') \\<epsilon> h s';\n     \\<tau>moves2 P h stk' es pc' xcp' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>Exec_movesr ci P t es h s s'\"", "lemma \\<tau>Exect_step:\n  \"\\<lbrakk> \\<tau>Exec_movet ci P t e h s (stk', loc', pc', xcp');\n     exec_move ci P t e h (stk', loc', pc', xcp') \\<epsilon> h s';\n     \\<tau>move2 P h stk' e pc' xcp' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>Exec_movet ci P t e h s s'\"", "lemma \\<tau>Execst_step:\n  \"\\<lbrakk> \\<tau>Exec_movest ci P t es h s (stk', loc', pc', xcp');\n     exec_moves ci P t es h (stk', loc', pc', xcp') \\<epsilon> h s';\n     \\<tau>moves2 P h stk' es pc' xcp' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>Exec_movest ci P t es h s s'\"", "lemmas \\<tau>Execr1step = \\<tau>Execr_step[OF \\<tau>Execr_refl]", "lemmas \\<tau>Execr2step = \\<tau>Execr_step[OF \\<tau>Execr_step, OF \\<tau>Execr_refl]", "lemmas \\<tau>Execr3step = \\<tau>Execr_step[OF \\<tau>Execr_step, OF \\<tau>Execr_step, OF \\<tau>Execr_refl]", "lemmas \\<tau>Execsr1step = \\<tau>Execsr_step[OF \\<tau>Execsr_refl]", "lemmas \\<tau>Execsr2step = \\<tau>Execsr_step[OF \\<tau>Execsr_step, OF \\<tau>Execsr_refl]", "lemmas \\<tau>Execsr3step = \\<tau>Execsr_step[OF \\<tau>Execsr_step, OF \\<tau>Execsr_step, OF \\<tau>Execsr_refl]", "lemma \\<tau>Exect1step:\n  \"\\<lbrakk> exec_move ci P t e h s \\<epsilon> h s';\n     \\<tau>move2 P h (fst s) e (fst (snd (snd s))) (snd (snd (snd s))) \\<rbrakk>\n  \\<Longrightarrow> \\<tau>Exec_movet ci P t e h s s'\"", "lemmas \\<tau>Exect2step = \\<tau>Exect_step[OF \\<tau>Exect1step]", "lemmas \\<tau>Exect3step = \\<tau>Exect_step[OF \\<tau>Exect_step, OF \\<tau>Exect1step]", "lemma \\<tau>Execst1step:\n  \"\\<lbrakk> exec_moves ci P t es h s \\<epsilon> h s';\n     \\<tau>moves2 P h (fst s) es (fst (snd (snd s))) (snd (snd (snd s))) \\<rbrakk>\n  \\<Longrightarrow> \\<tau>Exec_movest ci P t es h s s'\"", "lemmas \\<tau>Execst2step = \\<tau>Execst_step[OF \\<tau>Execst1step]", "lemmas \\<tau>Execst3step = \\<tau>Execst_step[OF \\<tau>Execst_step, OF \\<tau>Execst1step]", "lemma \\<tau>Execr_induct [consumes 1, case_names refl step]:\n  assumes major: \"\\<tau>Exec_mover ci P t e h (stk, loc, pc, xcp) (stk'', loc'', pc'', xcp'')\"\n  and refl: \"Q stk loc pc xcp\"\n  and step: \"\\<And>stk' loc' pc' xcp' stk'' loc'' pc'' xcp''.\n             \\<lbrakk> \\<tau>Exec_mover ci P t e h (stk, loc, pc, xcp) (stk', loc', pc', xcp');\n               \\<tau>exec_move ci P t e h (stk', loc', pc', xcp') (stk'', loc'', pc'', xcp''); Q stk' loc' pc' xcp' \\<rbrakk>\n             \\<Longrightarrow> Q stk'' loc'' pc'' xcp''\"\n  shows \"Q stk'' loc'' pc'' xcp''\"", "lemma \\<tau>Execsr_induct [consumes 1, case_names refl step]:\n  assumes major: \"\\<tau>Exec_movesr ci P t es h (stk, loc, pc, xcp) (stk'', loc'', pc'', xcp'')\"\n  and refl: \"Q stk loc pc xcp\"\n  and step: \"\\<And>stk' loc' pc' xcp' stk'' loc'' pc'' xcp''.\n             \\<lbrakk> \\<tau>Exec_movesr ci P t es h (stk, loc, pc, xcp) (stk', loc', pc', xcp');\n               \\<tau>exec_moves ci P t es h (stk', loc', pc', xcp') (stk'', loc'', pc'', xcp''); Q stk' loc' pc' xcp' \\<rbrakk>\n             \\<Longrightarrow> Q stk'' loc'' pc'' xcp''\"\n  shows \"Q stk'' loc'' pc'' xcp''\"", "lemma \\<tau>Exect_induct [consumes 1, case_names base step]:\n  assumes major: \"\\<tau>Exec_movet ci P t e h (stk, loc, pc, xcp) (stk'', loc'', pc'', xcp'')\"\n  and base: \"\\<And>stk' loc' pc' xcp'. \\<tau>exec_move ci P t e h (stk, loc, pc, xcp) (stk', loc', pc', xcp') \\<Longrightarrow> Q stk' loc' pc' xcp'\"\n  and step: \"\\<And>stk' loc' pc' xcp' stk'' loc'' pc'' xcp''.\n             \\<lbrakk> \\<tau>Exec_movet ci P t e h (stk, loc, pc, xcp) (stk', loc', pc', xcp');\n               \\<tau>exec_move ci P t e h (stk', loc', pc', xcp') (stk'', loc'', pc'', xcp''); Q stk' loc' pc' xcp' \\<rbrakk>\n             \\<Longrightarrow> Q stk'' loc'' pc'' xcp''\"\n  shows \"Q stk'' loc'' pc'' xcp''\"", "lemma \\<tau>Execst_induct [consumes 1, case_names base step]:\n  assumes major: \"\\<tau>Exec_movest ci P t es h (stk, loc, pc, xcp) (stk'', loc'', pc'', xcp'')\"\n  and base: \"\\<And>stk' loc' pc' xcp'. \\<tau>exec_moves ci P t es h (stk, loc, pc, xcp) (stk', loc', pc', xcp') \\<Longrightarrow> Q stk' loc' pc' xcp'\"\n  and step: \"\\<And>stk' loc' pc' xcp' stk'' loc'' pc'' xcp''.\n             \\<lbrakk> \\<tau>Exec_movest ci P t es h (stk, loc, pc, xcp) (stk', loc', pc', xcp');\n               \\<tau>exec_moves ci P t es h (stk', loc', pc', xcp') (stk'', loc'', pc'', xcp''); Q stk' loc' pc' xcp' \\<rbrakk>\n             \\<Longrightarrow> Q stk'' loc'' pc'' xcp''\"\n  shows \"Q stk'' loc'' pc'' xcp''\"", "lemma \\<tau>Exec_mover_\\<tau>Exec_methr:\n  \"\\<tau>Exec_mover ci P t e = \\<tau>Exec_methr ci (compP2 P) (compE2 e) (compxE2 e 0 0) t\"", "lemma \\<tau>Exec_movesr_\\<tau>Exec_methr:\n  \"\\<tau>Exec_movesr ci P t es = \\<tau>Exec_methr ci (compP2 P) (compEs2 es) (compxEs2 es 0 0) t\"", "lemma \\<tau>Exec_movet_\\<tau>Exec_metht:\n  \"\\<tau>Exec_movet ci P t e = \\<tau>Exec_metht ci (compP2 P) (compE2 e) (compxE2 e 0 0) t\"", "lemma \\<tau>Exec_movest_\\<tau>Exec_metht:\n  \"\\<tau>Exec_movest ci P t es = \\<tau>Exec_metht ci (compP2 P) (compEs2 es) (compxEs2 es 0 0) t\"", "lemma \\<tau>Exec_mover_trans: \n  \"\\<lbrakk> \\<tau>Exec_mover ci P t e h s s'; \\<tau>Exec_mover ci P t e h s' s'' \\<rbrakk> \\<Longrightarrow> \\<tau>Exec_mover ci P t e h s s''\"", "lemma \\<tau>Exec_movesr_trans: \n  \"\\<lbrakk> \\<tau>Exec_movesr ci P t es h s s'; \\<tau>Exec_movesr ci P t es h s' s'' \\<rbrakk> \\<Longrightarrow> \\<tau>Exec_movesr ci P t es h s s''\"", "lemma \\<tau>Exec_movet_trans: \n  \"\\<lbrakk> \\<tau>Exec_movet ci P t e h s s'; \\<tau>Exec_movet ci P t e h s' s'' \\<rbrakk> \\<Longrightarrow> \\<tau>Exec_movet ci P t e h s s''\"", "lemma \\<tau>Exec_movest_trans: \n  \"\\<lbrakk> \\<tau>Exec_movest ci P t es h s s'; \\<tau>Exec_movest ci P t es h s' s'' \\<rbrakk> \\<Longrightarrow> \\<tau>Exec_movest ci P t es h s s''\"", "lemma \\<tau>exec_move_into_\\<tau>exec_moves:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_moves ci P t (e # es) h s s'\"", "lemma \\<tau>Exec_mover_\\<tau>Exec_movesr:\n  \"\\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movesr ci P t (e # es) h s s'\"", "lemma \\<tau>Exec_movet_\\<tau>Exec_movest:\n  \"\\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movest ci P t (e # es) h s s'\"", "lemma exec_moves_append: \"exec_moves ci P t es h s ta h' s' \\<Longrightarrow> exec_moves ci P t (es @ es') h s ta h' s'\"", "lemma \\<tau>exec_moves_append: \"\\<tau>exec_moves ci P t es h s s' \\<Longrightarrow> \\<tau>exec_moves ci P t (es @ es') h s s'\"", "lemma \\<tau>Exec_movesr_append [intro]:\n  \"\\<tau>Exec_movesr ci P t es h s s' \\<Longrightarrow> \\<tau>Exec_movesr ci P t (es @ es') h s s'\"", "lemma \\<tau>Exec_movest_append [intro]:\n  \"\\<tau>Exec_movest ci P t es h s s' \\<Longrightarrow> \\<tau>Exec_movest ci P t (es @ es') h s s'\"", "lemma append_exec_moves:\n  assumes len: \"length vs = length es'\"\n  and exec: \"exec_moves ci P t es h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  shows \"exec_moves ci P t (es' @ es) h ((stk @ vs), loc, (length (compEs2 es') + pc), xcp) ta h' ((stk' @ vs), loc', (length (compEs2 es') + pc'), xcp')\"", "lemma append_\\<tau>exec_moves:\n  \"\\<lbrakk> length vs = length es';\n    \\<tau>exec_moves ci P t es h (stk, loc, pc, xcp) (stk', loc', pc', xcp') \\<rbrakk>\n  \\<Longrightarrow> \\<tau>exec_moves ci P t (es' @ es) h ((stk @ vs), loc, (length (compEs2 es') + pc), xcp) ((stk' @ vs), loc', (length (compEs2 es') + pc'), xcp')\"", "lemma append_\\<tau>Exec_movesr:\n  assumes len: \"length vs = length es'\"\n  shows \"\\<tau>Exec_movesr ci P t es h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_movesr ci P t (es' @ es) h ((stk @ vs), loc, (length (compEs2 es') + pc), xcp) ((stk' @ vs), loc', (length (compEs2 es') + pc'), xcp')\"", "lemma append_\\<tau>Exec_movest:\n  assumes len: \"length vs = length es'\"\n  shows \"\\<tau>Exec_movest ci P t es h  (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_movest ci P t (es' @ es) h ((stk @ vs), loc, (length (compEs2 es') + pc), xcp)  ((stk' @ vs), loc', (length (compEs2 es') + pc'), xcp')\"", "lemma NewArray_\\<tau>execI:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (newA T\\<lfloor>e\\<rceil>) h s s'\"", "lemma Cast_\\<tau>execI:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (Cast T e) h s s'\"", "lemma InstanceOf_\\<tau>execI:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (e instanceof T) h s s'\"", "lemma BinOp_\\<tau>execI1:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (e \\<guillemotleft>bop\\<guillemotright> e') h s s'\"", "lemma BinOp_\\<tau>execI2:\n  \"\\<tau>exec_move ci P t e' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>exec_move ci P t (e \\<guillemotleft>bop\\<guillemotright> e') h ((stk @ [v]), loc, (length (compE2 e) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 e) + pc'), xcp')\"", "lemma LAss_\\<tau>execI:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (V := e) h s s'\"", "lemma AAcc_\\<tau>execI1:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (e\\<lfloor>i\\<rceil>) h s s'\"", "lemma AAcc_\\<tau>execI2:\n  \"\\<tau>exec_move ci P t e' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>exec_move ci P t (e\\<lfloor>e'\\<rceil>) h ((stk @ [v]), loc, (length (compE2 e) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 e) + pc'), xcp')\"", "lemma AAss_\\<tau>execI1:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (e\\<lfloor>i\\<rceil> := e') h s s'\"", "lemma AAss_\\<tau>execI2:\n  \"\\<tau>exec_move ci P t e' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>exec_move ci P t (e\\<lfloor>e'\\<rceil> := e'') h ((stk @ [v]), loc, (length (compE2 e) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 e) + pc'), xcp')\"", "lemma AAss_\\<tau>execI3:\n  \"\\<tau>exec_move ci P t e'' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>exec_move ci P t (e\\<lfloor>e'\\<rceil> := e'') h ((stk @ [v, v']), loc, (length (compE2 e) + length (compE2 e') + pc), xcp) ((stk' @ [v, v']), loc', (length (compE2 e) + length (compE2 e') + pc'), xcp')\"", "lemma ALength_\\<tau>execI:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (e\\<bullet>length) h s s'\"", "lemma FAcc_\\<tau>execI:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (e\\<bullet>F{D}) h s s'\"", "lemma FAss_\\<tau>execI1:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (e\\<bullet>F{D} := e') h s s'\"", "lemma FAss_\\<tau>execI2:\n  \"\\<tau>exec_move ci P t e' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>exec_move ci P t (e\\<bullet>F{D} := e') h ((stk @ [v]), loc, (length (compE2 e) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 e) + pc'), xcp')\"", "lemma CAS_\\<tau>execI1:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h s s'\"", "lemma CAS_\\<tau>execI2:\n  \"\\<tau>exec_move ci P t e' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>exec_move ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h ((stk @ [v]), loc, (length (compE2 e) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 e) + pc'), xcp')\"", "lemma CAS_\\<tau>execI3:\n  \"\\<tau>exec_move ci P t e'' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>exec_move ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h ((stk @ [v, v']), loc, (length (compE2 e) + length (compE2 e') + pc), xcp) ((stk' @ [v, v']), loc', (length (compE2 e) + length (compE2 e') + pc'), xcp')\"", "lemma Call_\\<tau>execI1:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (e\\<bullet>M(es)) h s s'\"", "lemma Call_\\<tau>execI2:\n  \"\\<tau>exec_moves ci P t es h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>exec_move ci P t (e\\<bullet>M(es)) h ((stk @ [v]), loc, (length (compE2 e) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 e) + pc'), xcp')\"", "lemma Block_\\<tau>execI_Some:\n  \"\\<tau>exec_move ci P t e h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>exec_move ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h (stk, loc, Suc (Suc pc), xcp) (stk', loc', Suc (Suc pc'), xcp')\"", "lemma Block_\\<tau>execI_None:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t {V:T=None; e} h s s'\"", "lemma Sync_\\<tau>execI:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (sync\\<^bsub>V\\<^esub> (e) e') h s s'\"", "lemma Insync_\\<tau>execI:\n  \"\\<tau>exec_move ci P t e' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>exec_move ci P t (sync\\<^bsub>V\\<^esub> (e) e') h (stk, loc, Suc (Suc (Suc (length (compE2 e) + pc))), xcp) (stk', loc', Suc (Suc (Suc (length (compE2 e) + pc'))), xcp')\"", "lemma Seq_\\<tau>execI1:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (e;; e') h s s'\"", "lemma Seq_\\<tau>execI2:\n  \"\\<tau>exec_move ci P t e' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>exec_move ci P t (e;; e') h (stk, loc, Suc (length (compE2 e) + pc), xcp) (stk', loc', Suc (length (compE2 e) + pc'), xcp')\"", "lemma Cond_\\<tau>execI1:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (if (e) e' else e'') h s s'\"", "lemma Cond_\\<tau>execI2:\n  \"\\<tau>exec_move ci P t e' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>exec_move ci P t (if (e) e' else e'') h (stk, loc, Suc (length (compE2 e) + pc), xcp) (stk', loc', Suc (length (compE2 e) + pc'), xcp')\"", "lemma Cond_\\<tau>execI3:\n  \"\\<tau>exec_move ci P t e'' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>exec_move ci P t (if (e) e' else e'') h (stk, loc, Suc (Suc (length (compE2 e) + length (compE2 e') + pc)), xcp) (stk', loc', Suc (Suc (length (compE2 e) + length (compE2 e') + pc')), xcp')\"", "lemma While_\\<tau>execI1:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (while (e) e') h s s'\"", "lemma While_\\<tau>execI2:\n  \"\\<tau>exec_move ci P t e' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>exec_move ci P t (while (e) e') h (stk, loc, Suc (length (compE2 e) + pc), xcp) (stk', loc', Suc (length (compE2 e) + pc'), xcp')\"", "lemma Throw_\\<tau>execI:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (throw e) h s s'\"", "lemma Try_\\<tau>execI1:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (try e catch(C V) e') h s s'\"", "lemma Try_\\<tau>execI2:\n  \"\\<tau>exec_move ci P t e' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>exec_move ci P t (try e catch(C V) e') h (stk, loc, Suc (Suc (length (compE2 e) + pc)), xcp) (stk', loc', Suc (Suc (length (compE2 e) + pc')), xcp')\"", "lemma NewArray_\\<tau>ExecrI:\n  \"\\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (newA T\\<lfloor>e\\<rceil>) h s s'\"", "lemma Cast_\\<tau>ExecrI:\n  \"\\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (Cast T e) h s s'\"", "lemma InstanceOf_\\<tau>ExecrI:\n  \"\\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (e instanceof T) h s s'\"", "lemma BinOp_\\<tau>ExecrI1:\n  \"\\<tau>Exec_mover ci P t e1 h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (e1 \\<guillemotleft>bop\\<guillemotright> e2) h s s'\"", "lemma BinOp_\\<tau>ExecrI2:\n  \"\\<tau>Exec_mover ci P t e2 h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_mover ci P t (e \\<guillemotleft>bop\\<guillemotright> e2)  h ((stk @ [v]), loc, (length (compE2 e) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 e) + pc'), xcp')\"", "lemma LAss_\\<tau>ExecrI:\n  \"\\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (V := e) h s s'\"", "lemma AAcc_\\<tau>ExecrI1:\n  \"\\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (e\\<lfloor>i\\<rceil>) h s s'\"", "lemma AAcc_\\<tau>ExecrI2:\n  \"\\<tau>Exec_mover ci P t i h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_mover ci P t (a\\<lfloor>i\\<rceil>) h ((stk @ [v]), loc, (length (compE2 a) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 a) + pc'), xcp')\"", "lemma AAss_\\<tau>ExecrI1:\n  \"\\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (e\\<lfloor>i\\<rceil> := e') h s s'\"", "lemma AAss_\\<tau>ExecrI2:\n  \"\\<tau>Exec_mover ci P t i h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_mover ci P t (a\\<lfloor>i\\<rceil> := e) h ((stk @ [v]), loc, (length (compE2 a) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 a) + pc'), xcp')\"", "lemma AAss_\\<tau>ExecrI3:\n  \"\\<tau>Exec_mover ci P t e h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_mover ci P t (a\\<lfloor>i\\<rceil> := e) h ((stk @ [v, v']), loc, (length (compE2 a) + length (compE2 i) + pc), xcp) ((stk' @ [v, v']), loc', (length (compE2 a) + length (compE2 i) + pc'), xcp')\"", "lemma ALength_\\<tau>ExecrI:\n  \"\\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (e\\<bullet>length) h s s'\"", "lemma FAcc_\\<tau>ExecrI:\n  \"\\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (e\\<bullet>F{D}) h s s'\"", "lemma FAss_\\<tau>ExecrI1:\n  \"\\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (e\\<bullet>F{D} := e') h s s'\"", "lemma FAss_\\<tau>ExecrI2:\n  \"\\<tau>Exec_mover ci P t e' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_mover ci P t (e\\<bullet>F{D} := e') h ((stk @ [v]), loc, (length (compE2 e) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 e) + pc'), xcp')\"", "lemma CAS_\\<tau>ExecrI1:\n  \"\\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h s s'\"", "lemma CAS_\\<tau>ExecrI2:\n  \"\\<tau>Exec_mover ci P t e' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_mover ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h ((stk @ [v]), loc, (length (compE2 e) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 e) + pc'), xcp')\"", "lemma CAS_\\<tau>ExecrI3:\n  \"\\<tau>Exec_mover ci P t e'' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_mover ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h ((stk @ [v, v']), loc, (length (compE2 e) + length (compE2 e') + pc), xcp) ((stk' @ [v, v']), loc', (length (compE2 e) + length (compE2 e') + pc'), xcp')\"", "lemma Call_\\<tau>ExecrI1:\n  \"\\<tau>Exec_mover ci P t obj h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (obj\\<bullet>M'(es)) h s s'\"", "lemma Call_\\<tau>ExecrI2:\n  \"\\<tau>Exec_movesr ci P t es h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_mover ci P t (obj\\<bullet>M'(es)) h ((stk @ [v]), loc, (length (compE2 obj) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 obj) + pc'), xcp')\"", "lemma Block_\\<tau>ExecrI_Some:\n  \"\\<tau>Exec_mover ci P t e h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_mover ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h (stk, loc, (Suc (Suc pc)), xcp) (stk', loc', (Suc (Suc pc')), xcp')\"", "lemma Block_\\<tau>ExecrI_None:\n  \"\\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t {V:T=None; e} h s s'\"", "lemma Sync_\\<tau>ExecrI:\n  \"\\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (sync\\<^bsub>V\\<^esub> (e) e') h s s'\"", "lemma Insync_\\<tau>ExecrI:\n  \"\\<tau>Exec_mover ci P t e' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_mover ci P t (sync\\<^bsub>V\\<^esub> (e) e')  h (stk, loc, (Suc (Suc (Suc (length (compE2 e) + pc)))), xcp) (stk', loc', (Suc (Suc (Suc (length (compE2 e) + pc')))), xcp')\"", "lemma Seq_\\<tau>ExecrI1:\n  \"\\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (e;;e') h s s'\"", "lemma Seq_\\<tau>ExecrI2:\n  \"\\<tau>Exec_mover ci P t e h (stk, loc, pc, xcp) (stk', loc', pc' ,xcp') \\<Longrightarrow>\n   \\<tau>Exec_mover ci P t (e';;e) h (stk, loc, (Suc (length (compE2 e') + pc)), xcp) (stk', loc', (Suc (length (compE2 e') + pc')), xcp')\"", "lemma Cond_\\<tau>ExecrI1:\n  \"\\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (if (e) e1 else e2) h s s'\"", "lemma Cond_\\<tau>ExecrI2:\n  \"\\<tau>Exec_mover ci P t e1  h (stk, loc, pc, xcp) (stk', loc', pc', xcp') \\<Longrightarrow>\n   \\<tau>Exec_mover ci P t (if (e) e1 else e2)  h (stk, loc, (Suc (length (compE2 e) + pc)), xcp) (stk', loc', (Suc (length (compE2 e) + pc')), xcp')\"", "lemma Cond_\\<tau>ExecrI3:\n  \"\\<tau>Exec_mover ci P t e2  h (stk, loc ,pc, xcp) (stk', loc', pc', xcp') \\<Longrightarrow>\n   \\<tau>Exec_mover ci P t (if (e) e1 else e2)  h (stk, loc, (Suc (Suc (length (compE2 e) + length (compE2 e1) + pc))), xcp)  (stk', loc', (Suc (Suc (length (compE2 e) + length (compE2 e1) + pc'))), xcp')\"", "lemma While_\\<tau>ExecrI1:\n  \"\\<tau>Exec_mover ci P t c h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (while (c) e) h s s'\"", "lemma While_\\<tau>ExecrI2:\n  \"\\<tau>Exec_mover ci P t E h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_mover ci P t (while (c) E)  h (stk, loc ,(Suc (length (compE2 c) + pc)), xcp) (stk', loc', (Suc (length (compE2 c) + pc')), xcp')\"", "lemma Throw_\\<tau>ExecrI:\n  \"\\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (throw e) h s s'\"", "lemma Try_\\<tau>ExecrI1:\n  \"\\<tau>Exec_mover ci P t E h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (try E catch(C' V) e) h s s'\"", "lemma Try_\\<tau>ExecrI2:\n  \"\\<tau>Exec_mover ci P t e h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_mover ci P t (try E catch(C' V) e)  h (stk, loc, (Suc (Suc (length (compE2 E) + pc))), xcp)  (stk', loc', (Suc (Suc (length (compE2 E) + pc'))), xcp')\"", "lemma NewArray_\\<tau>ExectI:\n  \"\\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (newA T\\<lfloor>e\\<rceil>) h s s'\"", "lemma Cast_\\<tau>ExectI:\n  \"\\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (Cast T e) h s s'\"", "lemma InstanceOf_\\<tau>ExectI:\n  \"\\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (e instanceof T) h s s'\"", "lemma BinOp_\\<tau>ExectI1:\n  \"\\<tau>Exec_movet ci P t e1 h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (e1 \\<guillemotleft>bop\\<guillemotright> e2) h s s'\"", "lemma BinOp_\\<tau>ExectI2:\n  \"\\<tau>Exec_movet ci P t e2 h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_movet ci P t (e \\<guillemotleft>bop\\<guillemotright> e2)  h ((stk @ [v]), loc, (length (compE2 e) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 e) + pc'), xcp')\"", "lemma LAss_\\<tau>ExectI:\n  \"\\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (V := e) h s s'\"", "lemma AAcc_\\<tau>ExectI1:\n  \"\\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (e\\<lfloor>i\\<rceil>) h s s'\"", "lemma AAcc_\\<tau>ExectI2:\n  \"\\<tau>Exec_movet ci P t i h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_movet ci P t (a\\<lfloor>i\\<rceil>) h ((stk @ [v]), loc, (length (compE2 a) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 a) + pc'), xcp')\"", "lemma AAss_\\<tau>ExectI1:\n  \"\\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (e\\<lfloor>i\\<rceil> := e') h s s'\"", "lemma AAss_\\<tau>ExectI2:\n  \"\\<tau>Exec_movet ci P t i h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_movet ci P t (a\\<lfloor>i\\<rceil> := e) h ((stk @ [v]), loc, (length (compE2 a) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 a) + pc'), xcp')\"", "lemma AAss_\\<tau>ExectI3:\n  \"\\<tau>Exec_movet ci P t e h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_movet ci P t (a\\<lfloor>i\\<rceil> := e) h ((stk @ [v, v']), loc, (length (compE2 a) + length (compE2 i) + pc), xcp) ((stk' @ [v, v']), loc', (length (compE2 a) + length (compE2 i) + pc'), xcp')\"", "lemma ALength_\\<tau>ExectI:\n  \"\\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (e\\<bullet>length) h s s'\"", "lemma FAcc_\\<tau>ExectI:\n  \"\\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (e\\<bullet>F{D}) h s s'\"", "lemma FAss_\\<tau>ExectI1:\n  \"\\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (e\\<bullet>F{D} := e') h s s'\"", "lemma FAss_\\<tau>ExectI2:\n  \"\\<tau>Exec_movet ci P t e' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_movet ci P t (e\\<bullet>F{D} := e') h ((stk @ [v]), loc, (length (compE2 e) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 e) + pc'), xcp')\"", "lemma CAS_\\<tau>ExectI1:\n  \"\\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h s s'\"", "lemma CAS_\\<tau>ExectI2:\n  \"\\<tau>Exec_movet ci P t e' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_movet ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h ((stk @ [v]), loc, (length (compE2 e) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 e) + pc'), xcp')\"", "lemma CAS_\\<tau>ExectI3:\n  \"\\<tau>Exec_movet ci P t e'' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_movet ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h ((stk @ [v, v']), loc, (length (compE2 e) + length (compE2 e') + pc), xcp) ((stk' @ [v, v']), loc', (length (compE2 e) + length (compE2 e') + pc'), xcp')\"", "lemma Call_\\<tau>ExectI1:\n  \"\\<tau>Exec_movet ci P t obj h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (obj\\<bullet>M'(es)) h s s'\"", "lemma Call_\\<tau>ExectI2:\n  \"\\<tau>Exec_movest ci P t es h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_movet ci P t (obj\\<bullet>M'(es)) h ((stk @ [v]), loc, (length (compE2 obj) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 obj) + pc'), xcp')\"", "lemma Block_\\<tau>ExectI_Some:\n  \"\\<tau>Exec_movet ci P t e h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_movet ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h (stk, loc, (Suc (Suc pc)), xcp) (stk', loc', (Suc (Suc pc')), xcp')\"", "lemma Block_\\<tau>ExectI_None:\n  \"\\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t {V:T=None; e} h s s'\"", "lemma Sync_\\<tau>ExectI:\n  \"\\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (sync\\<^bsub>V\\<^esub> (e) e') h s s'\"", "lemma Insync_\\<tau>ExectI:\n  \"\\<tau>Exec_movet ci P t e' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_movet ci P t (sync\\<^bsub>V\\<^esub> (e) e')  h (stk, loc, (Suc (Suc (Suc (length (compE2 e) + pc)))), xcp) (stk', loc', (Suc (Suc (Suc (length (compE2 e) + pc')))), xcp')\"", "lemma Seq_\\<tau>ExectI1:\n  \"\\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (e;;e') h s s'\"", "lemma Seq_\\<tau>ExectI2:\n  \"\\<tau>Exec_movet ci P t e h (stk, loc, pc, xcp) (stk', loc', pc' ,xcp') \\<Longrightarrow>\n   \\<tau>Exec_movet ci P t (e';;e) h (stk, loc, (Suc (length (compE2 e') + pc)), xcp) (stk', loc', (Suc (length (compE2 e') + pc')), xcp')\"", "lemma Cond_\\<tau>ExectI1:\n  \"\\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (if (e) e1 else e2) h s s'\"", "lemma Cond_\\<tau>ExectI2:\n  \"\\<tau>Exec_movet ci P t e1  h (stk, loc, pc, xcp) (stk', loc', pc', xcp') \\<Longrightarrow>\n   \\<tau>Exec_movet ci P t (if (e) e1 else e2)  h (stk, loc, (Suc (length (compE2 e) + pc)), xcp) (stk', loc', (Suc (length (compE2 e) + pc')), xcp')\"", "lemma Cond_\\<tau>ExectI3:\n  \"\\<tau>Exec_movet ci P t e2  h (stk, loc ,pc, xcp) (stk', loc', pc', xcp') \\<Longrightarrow>\n   \\<tau>Exec_movet ci P t (if (e) e1 else e2)  h (stk, loc, (Suc (Suc (length (compE2 e) + length (compE2 e1) + pc))), xcp)  (stk', loc', (Suc (Suc (length (compE2 e) + length (compE2 e1) + pc'))), xcp')\"", "lemma While_\\<tau>ExectI1:\n  \"\\<tau>Exec_movet ci P t c h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (while (c) e) h s s'\"", "lemma While_\\<tau>ExectI2:\n  \"\\<tau>Exec_movet ci P t E h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_movet ci P t (while (c) E)  h (stk, loc ,(Suc (length (compE2 c) + pc)), xcp) (stk', loc', (Suc (length (compE2 c) + pc')), xcp')\"", "lemma Throw_\\<tau>ExectI:\n  \"\\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (throw e) h s s'\"", "lemma Try_\\<tau>ExectI1:\n  \"\\<tau>Exec_movet ci P t E h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (try E catch(C' V) e) h s s'\"", "lemma Try_\\<tau>ExectI2:\n  \"\\<tau>Exec_movet ci P t e h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_movet ci P t (try E catch(C' V) e)  h (stk, loc, (Suc (Suc (length (compE2 E) + pc))), xcp)  (stk', loc', (Suc (Suc (length (compE2 E) + pc'))), xcp')\"", "lemma \\<tau>Exec_movesr_map_Val:\n  \"\\<tau>Exec_movesr_a P t (map Val vs) h ([], xs, 0, None) ((rev vs), xs, (length (compEs2 (map Val vs))), None)\"", "lemma \\<tau>Exec_mover_blocks1 [simp]:\n  \"\\<tau>Exec_mover ci P t (blocks1 n Ts body) h s s' = \\<tau>Exec_mover ci P t body h s s'\"", "lemma \\<tau>Exec_movet_blocks1 [simp]:\n  \"\\<tau>Exec_movet ci P t (blocks1 n Ts body) h s s' = \\<tau>Exec_movet ci P t body h s s'\"", "lemma \\<tau>exec_1I [intro]:\n  \"\\<lbrakk> exec_1 P t \\<sigma> \\<epsilon> \\<sigma>'; \\<tau>Move2 P \\<sigma> \\<rbrakk> \\<Longrightarrow> \\<tau>exec_1 P t \\<sigma> \\<sigma>'\"", "lemma \\<tau>exec_1E [elim]:\n  assumes \"\\<tau>exec_1 P t \\<sigma> \\<sigma>'\"\n  obtains \"exec_1 P t \\<sigma> \\<epsilon> \\<sigma>'\" \"\\<tau>Move2 P \\<sigma>\"", "lemma \\<tau>exec_1_dI [intro]:\n  \"\\<lbrakk> exec_1 P t \\<sigma> \\<epsilon> \\<sigma>'; check P \\<sigma>; \\<tau>Move2 P \\<sigma> \\<rbrakk> \\<Longrightarrow> \\<tau>exec_1_d P t \\<sigma> \\<sigma>'\"", "lemma \\<tau>exec_1_dE [elim]:\n  assumes \"\\<tau>exec_1_d P t \\<sigma> \\<sigma>'\"\n  obtains \"exec_1 P t \\<sigma> \\<epsilon> \\<sigma>'\" \"check P \\<sigma>\" \"\\<tau>Move2 P \\<sigma>\"", "lemma exec_instr_frs_offer:\n  \"(ta, xcp', h', (stk', loc', C, M, pc') # frs) \\<in> exec_instr ins P t h stk loc C M pc frs\n  \\<Longrightarrow> (ta, xcp', h', (stk', loc', C, M, pc') # frs @ frs') \\<in> exec_instr ins P t h stk loc C M pc (frs @ frs')\"", "lemma check_instr_frs_offer:\n  \"\\<lbrakk> check_instr ins P h stk loc C M pc frs; ins \\<noteq> Return \\<rbrakk>\n  \\<Longrightarrow> check_instr ins P h stk loc C M pc (frs @ frs')\"", "lemma exec_instr_CM_change:\n  \"(ta, xcp', h', (stk', loc', C, M, pc') # frs) \\<in> exec_instr ins P t h stk loc C M pc frs\n  \\<Longrightarrow> (ta, xcp', h', (stk', loc', C', M', pc') # frs) \\<in> exec_instr ins P t h stk loc C' M' pc frs\"", "lemma check_instr_CM_change:\n  \"\\<lbrakk> check_instr ins P h stk loc C M pc frs; ins \\<noteq> Return \\<rbrakk>\n  \\<Longrightarrow> check_instr ins P h stk loc C' M' pc frs\"", "lemma exec_move_exec_1:\n  assumes exec: \"exec_move ci P t body h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  and sees: \"P \\<turnstile> C sees M : Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\"\n  shows \"exec_1 (compP2 P) t (xcp, h, (stk, loc, C, M, pc) # frs) ta (xcp', h', (stk', loc', C, M, pc') # frs)\"", "lemma \\<tau>exec_move_\\<tau>exec_1:\n  assumes exec: \"\\<tau>exec_move ci P t body h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\"\n  and sees: \"P \\<turnstile> C sees M : Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\"\n  shows \"\\<tau>exec_1 (compP2 P) t (xcp, h, (stk, loc, C, M, pc) # frs) (xcp', h, (stk', loc', C, M, pc') # frs)\"", "lemma \\<tau>Exec_mover_\\<tau>Exec_1r:\n  assumes move: \"\\<tau>Exec_mover ci P t body h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\"\n  and sees: \"P \\<turnstile> C sees M : Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\"\n  shows \"\\<tau>Exec_1r (compP2 P) t (xcp, h, (stk, loc, C, M, pc) # frs') (xcp', h, (stk', loc', C, M, pc') # frs')\"", "lemma \\<tau>Exec_movet_\\<tau>Exec_1t:\n  assumes move: \"\\<tau>Exec_movet ci P t body h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\"\n  and sees: \"P \\<turnstile> C sees M : Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\"\n  shows \"\\<tau>Exec_1t (compP2 P) t (xcp, h, (stk, loc, C, M, pc) # frs') (xcp', h, (stk', loc', C, M, pc') # frs')\"", "lemma \\<tau>Exec_1r_rtranclpD:\n  \"\\<tau>Exec_1r P t (xcp, h, frs) (xcp', h', frs')\n  \\<Longrightarrow> (\\<lambda>((xcp, frs), h) ((xcp', frs'), h'). exec_1 P t (xcp, h, frs) \\<epsilon> (xcp', h', frs') \\<and> \\<tau>Move2 P (xcp, h, frs))^** ((xcp, frs), h) ((xcp', frs'), h')\"", "lemma \\<tau>Exec_1t_rtranclpD:\n  \"\\<tau>Exec_1t P t (xcp, h, frs) (xcp', h', frs')\n  \\<Longrightarrow> (\\<lambda>((xcp, frs), h) ((xcp', frs'), h'). exec_1 P t (xcp, h, frs) \\<epsilon> (xcp', h', frs') \\<and> \\<tau>Move2 P (xcp, h, frs))^++ ((xcp, frs), h) ((xcp', frs'), h')\"", "lemma exec_meth_length_compE2_stack_xliftD:\n  \"exec_meth ci P (compE2 e) (stack_xlift d (compxE2 e 0 0)) t h (stk, loc, pc, xcp) ta h' s'\n  \\<Longrightarrow> pc < length (compE2 e)\"", "lemma exec_meth_length_pc_xt_Nil:\n  \"exec_meth ci P ins [] t h (stk, loc, pc, xcp) ta h' s' \\<Longrightarrow> pc < length ins\"", "lemma BinOp_exec2D:\n  assumes exec: \"exec_meth ci (compP2 P) (compE2 (e1 \\<guillemotleft>bop\\<guillemotright> e2)) (compxE2 (e1 \\<guillemotleft>bop\\<guillemotright> e2) 0 0) t h (stk @ [v1], loc, length (compE2 e1) + pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  and pc: \"pc < length (compE2 e2)\"\n  shows \"exec_meth ci (compP2 P) (compE2 e2) (stack_xlift (length [v1]) (compxE2 e2 0 0)) t h (stk @ [v1], loc, pc, xcp) ta h' (stk', loc', pc' - length (compE2 e1), xcp') \\<and> pc' \\<ge> length (compE2 e1)\"", "lemma Call_execParamD:\n  assumes exec: \"exec_meth ci (compP2 P) (compE2 (obj\\<bullet>M'(ps))) (compxE2 (obj\\<bullet>M'(ps)) 0 0) t h (stk @ [v], loc, length (compE2 obj) + pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  and pc: \"pc < length (compEs2 ps)\"\n  shows \"exec_meth ci (compP2 P) (compEs2 ps) (stack_xlift (length [v]) (compxEs2 ps 0 0)) t h (stk @ [v], loc, pc, xcp) ta h' (stk', loc', pc' - length (compE2 obj), xcp') \\<and> pc' \\<ge> length (compE2 obj)\"", "lemma exec_move_length_compE2D [dest]:\n  \"exec_move ci P t e h (stk, loc, pc, xcp) ta h' s' \\<Longrightarrow> pc < length (compE2 e)\"", "lemma exec_moves_length_compEs2D [dest]:\n  \"exec_moves ci P t es h (stk, loc, pc, xcp) ta h' s' \\<Longrightarrow> pc < length (compEs2 es)\"", "lemma exec_meth_ci_appD:\n  \"\\<lbrakk> exec_meth ci P ins xt t h (stk, loc, pc, None) ta h' fr' \\<rbrakk>\n  \\<Longrightarrow>  ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\"", "lemma exec_move_ci_appD:\n  \"exec_move ci P t E h (stk, loc, pc, None) ta h' fr'\n  \\<Longrightarrow> ci_app ci (compE2 E ! pc) (compP2 P) h stk loc undefined undefined pc []\"", "lemma exec_moves_ci_appD:\n  \"exec_moves ci P t Es h (stk, loc, pc, None) ta h' fr'\n  \\<Longrightarrow> ci_app ci (compEs2 Es ! pc) (compP2 P) h stk loc undefined undefined pc []\"", "lemma \\<tau>instr_stk_append_check:\n  \"check_instr' i P h stk loc C M pc frs \\<Longrightarrow> \\<tau>instr P h (stk @ vs) i = \\<tau>instr P h stk i\"", "lemma \\<tau>instr_stk_drop_exec_move:\n  \"exec_move ci P t e h (stk, loc, pc, None) ta h' fr'\n  \\<Longrightarrow> \\<tau>instr (compP2 P) h (stk @ vs) (compE2 e ! pc) = \\<tau>instr (compP2 P) h stk (compE2 e ! pc)\"", "lemma \\<tau>instr_stk_drop_exec_moves:\n  \"exec_moves ci P t es h (stk, loc, pc, None) ta h' fr'\n  \\<Longrightarrow> \\<tau>instr (compP2 P) h (stk @ vs) (compEs2 es ! pc) = \\<tau>instr (compP2 P) h stk (compEs2 es ! pc)\""], "translations": [["", "lemma ci_stk_offerI:\n  \"(\\<And>ins P h stk stk' loc C M pc frs. ci ins P h stk loc C M pc frs \\<Longrightarrow> ci ins P h (stk @ stk') loc C M pc frs) \\<Longrightarrow> ci_stk_offer ci\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ins P h stk stk' loc C M pc frs.\n        ci ins P h stk loc C M pc frs \\<Longrightarrow>\n        ci ins P h (stk @ stk') loc C M pc frs) \\<Longrightarrow>\n    ci_stk_offer ci", "unfolding ci_stk_offer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ins P h stk stk' loc C M pc frs.\n        ci ins P h stk loc C M pc frs \\<Longrightarrow>\n        ci ins P h (stk @ stk') loc C M pc frs) \\<Longrightarrow>\n    \\<forall>ins P h stk stk' loc C M pc frs.\n       ci ins P h stk loc C M pc frs \\<longrightarrow>\n       ci ins P h (stk @ stk') loc C M pc frs", "by blast"], ["", "lemma ci_stk_offerD:\n  \"\\<lbrakk> ci_stk_offer ci; ci ins P h stk loc C M pc frs \\<rbrakk> \\<Longrightarrow> ci ins P h (stk @ stk') loc C M pc frs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ci_stk_offer ci; ci ins P h stk loc C M pc frs\\<rbrakk>\n    \\<Longrightarrow> ci ins P h (stk @ stk') loc C M pc frs", "unfolding ci_stk_offer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>ins P h stk stk' loc C M pc frs.\n                ci ins P h stk loc C M pc frs \\<longrightarrow>\n                ci ins P h (stk @ stk') loc C M pc frs;\n     ci ins P h stk loc C M pc frs\\<rbrakk>\n    \\<Longrightarrow> ci ins P h (stk @ stk') loc C M pc frs", "by blast"], ["", "lemma check_instr'_stk_offer:\n  \"ci_stk_offer check_instr'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ci_stk_offer check_instr'", "proof(rule ci_stk_offerI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ins P h stk stk' loc C M pc frs.\n       check_instr' ins P h stk loc C M pc frs \\<Longrightarrow>\n       check_instr' ins P h (stk @ stk') loc C M pc frs", "fix ins P h stk stk' loc C M pc frs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ins P h stk stk' loc C M pc frs.\n       check_instr' ins P h stk loc C M pc frs \\<Longrightarrow>\n       check_instr' ins P h (stk @ stk') loc C M pc frs", "assume \"check_instr' ins P h stk loc C M pc frs\""], ["proof (state)\nthis:\n  check_instr' ins P h stk loc C M pc frs\n\ngoal (1 subgoal):\n 1. \\<And>ins P h stk stk' loc C M pc frs.\n       check_instr' ins P h stk loc C M pc frs \\<Longrightarrow>\n       check_instr' ins P h (stk @ stk') loc C M pc frs", "thus \"check_instr' ins P h (stk @ stk') loc C M pc frs\""], ["proof (prove)\nusing this:\n  check_instr' ins P h stk loc C M pc frs\n\ngoal (1 subgoal):\n 1. check_instr' ins P h (stk @ stk') loc C M pc frs", "by(cases ins) auto"], ["proof (state)\nthis:\n  check_instr' ins P h (stk @ stk') loc C M pc frs\n\ngoal:\nNo subgoals!", "qed"], ["", "context JVM_heap_base begin"], ["", "lemma check_instr_imp_check_instr':\n  \"check_instr ins P h stk loc C M pc frs \\<Longrightarrow> check_instr' ins P h stk loc C M pc frs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_instr ins P h stk loc C M pc frs \\<Longrightarrow>\n    check_instr' ins P h stk loc C M pc frs", "by(cases ins) auto"], ["", "lemma check_instr_stk_offer:\n  \"ci_stk_offer check_instr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ci_stk_offer check_instr", "proof(rule ci_stk_offerI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ins P h stk stk' loc C M pc frs.\n       check_instr ins P h stk loc C M pc frs \\<Longrightarrow>\n       check_instr ins P h (stk @ stk') loc C M pc frs", "fix ins P h stk stk' loc C M pc frs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ins P h stk stk' loc C M pc frs.\n       check_instr ins P h stk loc C M pc frs \\<Longrightarrow>\n       check_instr ins P h (stk @ stk') loc C M pc frs", "assume \"check_instr ins P h stk loc C M pc frs\""], ["proof (state)\nthis:\n  check_instr ins P h stk loc C M pc frs\n\ngoal (1 subgoal):\n 1. \\<And>ins P h stk stk' loc C M pc frs.\n       check_instr ins P h stk loc C M pc frs \\<Longrightarrow>\n       check_instr ins P h (stk @ stk') loc C M pc frs", "thus \"check_instr ins P h (stk @ stk') loc C M pc frs\""], ["proof (prove)\nusing this:\n  check_instr ins P h stk loc C M pc frs\n\ngoal (1 subgoal):\n 1. check_instr ins P h (stk @ stk') loc C M pc frs", "by(cases ins)(auto simp add: nth_append hd_append neq_Nil_conv tl_append split: list.split)"], ["proof (state)\nthis:\n  check_instr ins P h (stk @ stk') loc C M pc frs\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* TODO: Combine ins_jump_ok and jump_ok *)"], ["", "primrec jump_ok :: \"'addr instr list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> bool\"\nwhere \"jump_ok [] n n' = True\"\n| \"jump_ok (x # xs) n n' = (jump_ok xs (Suc n) n' \\<and> \n                           (case x of IfFalse m \\<Rightarrow> - int n \\<le> m \\<and> m \\<le> int (n' + length xs)\n                                       | Goto m \\<Rightarrow> - int n \\<le> m \\<and> m \\<le> int (n' + length xs)\n                                            | _ \\<Rightarrow> True))\""], ["", "lemma jump_ok_append [simp]:\n  \"jump_ok (xs @ xs') n n' \\<longleftrightarrow> jump_ok xs n (n' + length xs') \\<and> jump_ok xs' (n + length xs) n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump_ok (xs @ xs') n n' =\n    (jump_ok xs n (n' + length xs') \\<and> jump_ok xs' (n + length xs) n')", "apply(induct xs arbitrary: n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       jump_ok ([] @ xs') n n' =\n       (jump_ok [] n (n' + length xs') \\<and>\n        jump_ok xs' (n + length []) n')\n 2. \\<And>a xs n.\n       (\\<And>n.\n           jump_ok (xs @ xs') n n' =\n           (jump_ok xs n (n' + length xs') \\<and>\n            jump_ok xs' (n + length xs) n')) \\<Longrightarrow>\n       jump_ok ((a # xs) @ xs') n n' =\n       (jump_ok (a # xs) n (n' + length xs') \\<and>\n        jump_ok xs' (n + length (a # xs)) n')", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       (\\<And>n.\n           jump_ok (xs @ xs') n n' =\n           (jump_ok xs n (n' + length xs') \\<and>\n            jump_ok xs' (n + length xs) n')) \\<Longrightarrow>\n       jump_ok ((a # xs) @ xs') n n' =\n       (jump_ok (a # xs) n (n' + length xs') \\<and>\n        jump_ok xs' (n + length (a # xs)) n')", "apply(auto split: instr.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma jump_ok_GotoD:\n  \"\\<lbrakk> jump_ok ins n n'; ins ! pc = Goto m; pc < length ins \\<rbrakk> \\<Longrightarrow> - int (pc + n) \\<le> m \\<and> m < int (length ins - pc + n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>jump_ok ins n n'; ins ! pc = Goto m; pc < length ins\\<rbrakk>\n    \\<Longrightarrow> - int (pc + n) \\<le> m \\<and>\n                      m < int (length ins - pc + n')", "apply(induct ins arbitrary: n n' pc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n' pc.\n       \\<lbrakk>jump_ok [] n n'; [] ! pc = Goto m; pc < length []\\<rbrakk>\n       \\<Longrightarrow> - int (pc + n) \\<le> m \\<and>\n                         m < int (length [] - pc + n')\n 2. \\<And>a ins n n' pc.\n       \\<lbrakk>\\<And>n n' pc.\n                   \\<lbrakk>jump_ok ins n n'; ins ! pc = Goto m;\n                    pc < length ins\\<rbrakk>\n                   \\<Longrightarrow> - int (pc + n) \\<le> m \\<and>\n                                     m < int (length ins - pc + n');\n        jump_ok (a # ins) n n'; (a # ins) ! pc = Goto m;\n        pc < length (a # ins)\\<rbrakk>\n       \\<Longrightarrow> - int (pc + n) \\<le> m \\<and>\n                         m < int (length (a # ins) - pc + n')", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ins n n' pc.\n       \\<lbrakk>\\<And>n n' pc.\n                   \\<lbrakk>jump_ok ins n n'; ins ! pc = Goto m;\n                    pc < length ins\\<rbrakk>\n                   \\<Longrightarrow> - int (pc + n) \\<le> m \\<and>\n                                     m < int (length ins - pc + n');\n        jump_ok (a # ins) n n'; (a # ins) ! pc = Goto m;\n        pc < length (a # ins)\\<rbrakk>\n       \\<Longrightarrow> - int (pc + n) \\<le> m \\<and>\n                         m < int (length (a # ins) - pc + n')", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ins n n' pc.\n       \\<lbrakk>\\<And>n n' pc.\n                   \\<lbrakk>jump_ok ins n n'; ins ! pc = Goto m;\n                    pc < length ins\\<rbrakk>\n                   \\<Longrightarrow> - int pc - int n \\<le> m \\<and>\n                                     m < int (length ins + n' - pc);\n        (a # ins) ! pc = Goto m; pc < Suc (length ins);\n        jump_ok ins (Suc n) n';\n        case a of\n        Goto m \\<Rightarrow>\n          - int n \\<le> m \\<and> m \\<le> int (n' + length ins)\n        | IfFalse m \\<Rightarrow>\n            - int n \\<le> m \\<and> m \\<le> int (n' + length ins)\n        | _ \\<Rightarrow> True\\<rbrakk>\n       \\<Longrightarrow> - int pc - int n \\<le> m \\<and>\n                         m < int (Suc (length ins + n') - pc)", "apply(case_tac pc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ins n n' pc.\n       \\<lbrakk>\\<And>n n' pc.\n                   \\<lbrakk>jump_ok ins n n'; ins ! pc = Goto m;\n                    pc < length ins\\<rbrakk>\n                   \\<Longrightarrow> - int pc - int n \\<le> m \\<and>\n                                     m < int (length ins + n' - pc);\n        (a # ins) ! pc = Goto m; pc < Suc (length ins);\n        jump_ok ins (Suc n) n';\n        case a of\n        Goto m \\<Rightarrow>\n          - int n \\<le> m \\<and> m \\<le> int (n' + length ins)\n        | IfFalse m \\<Rightarrow>\n            - int n \\<le> m \\<and> m \\<le> int (n' + length ins)\n        | _ \\<Rightarrow> True;\n        pc = 0\\<rbrakk>\n       \\<Longrightarrow> - int pc - int n \\<le> m \\<and>\n                         m < int (Suc (length ins + n') - pc)\n 2. \\<And>a ins n n' pc nat.\n       \\<lbrakk>\\<And>n n' pc.\n                   \\<lbrakk>jump_ok ins n n'; ins ! pc = Goto m;\n                    pc < length ins\\<rbrakk>\n                   \\<Longrightarrow> - int pc - int n \\<le> m \\<and>\n                                     m < int (length ins + n' - pc);\n        (a # ins) ! pc = Goto m; pc < Suc (length ins);\n        jump_ok ins (Suc n) n';\n        case a of\n        Goto m \\<Rightarrow>\n          - int n \\<le> m \\<and> m \\<le> int (n' + length ins)\n        | IfFalse m \\<Rightarrow>\n            - int n \\<le> m \\<and> m \\<le> int (n' + length ins)\n        | _ \\<Rightarrow> True;\n        pc = Suc nat\\<rbrakk>\n       \\<Longrightarrow> - int pc - int n \\<le> m \\<and>\n                         m < int (Suc (length ins + n') - pc)", "apply(fastforce)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma jump_ok_IfFalseD:\n  \"\\<lbrakk> jump_ok ins n n'; ins ! pc = IfFalse m; pc < length ins \\<rbrakk> \\<Longrightarrow> - int (pc + n) \\<le> m \\<and> m < int (length ins - pc + n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>jump_ok ins n n'; ins ! pc = IfFalse m;\n     pc < length ins\\<rbrakk>\n    \\<Longrightarrow> - int (pc + n) \\<le> m \\<and>\n                      m < int (length ins - pc + n')", "apply(induct ins arbitrary: n n' pc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n' pc.\n       \\<lbrakk>jump_ok [] n n'; [] ! pc = IfFalse m;\n        pc < length []\\<rbrakk>\n       \\<Longrightarrow> - int (pc + n) \\<le> m \\<and>\n                         m < int (length [] - pc + n')\n 2. \\<And>a ins n n' pc.\n       \\<lbrakk>\\<And>n n' pc.\n                   \\<lbrakk>jump_ok ins n n'; ins ! pc = IfFalse m;\n                    pc < length ins\\<rbrakk>\n                   \\<Longrightarrow> - int (pc + n) \\<le> m \\<and>\n                                     m < int (length ins - pc + n');\n        jump_ok (a # ins) n n'; (a # ins) ! pc = IfFalse m;\n        pc < length (a # ins)\\<rbrakk>\n       \\<Longrightarrow> - int (pc + n) \\<le> m \\<and>\n                         m < int (length (a # ins) - pc + n')", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ins n n' pc.\n       \\<lbrakk>\\<And>n n' pc.\n                   \\<lbrakk>jump_ok ins n n'; ins ! pc = IfFalse m;\n                    pc < length ins\\<rbrakk>\n                   \\<Longrightarrow> - int (pc + n) \\<le> m \\<and>\n                                     m < int (length ins - pc + n');\n        jump_ok (a # ins) n n'; (a # ins) ! pc = IfFalse m;\n        pc < length (a # ins)\\<rbrakk>\n       \\<Longrightarrow> - int (pc + n) \\<le> m \\<and>\n                         m < int (length (a # ins) - pc + n')", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ins n n' pc.\n       \\<lbrakk>\\<And>n n' pc.\n                   \\<lbrakk>jump_ok ins n n'; ins ! pc = IfFalse m;\n                    pc < length ins\\<rbrakk>\n                   \\<Longrightarrow> - int pc - int n \\<le> m \\<and>\n                                     m < int (length ins + n' - pc);\n        (a # ins) ! pc = IfFalse m; pc < Suc (length ins);\n        jump_ok ins (Suc n) n';\n        case a of\n        Goto m \\<Rightarrow>\n          - int n \\<le> m \\<and> m \\<le> int (n' + length ins)\n        | IfFalse m \\<Rightarrow>\n            - int n \\<le> m \\<and> m \\<le> int (n' + length ins)\n        | _ \\<Rightarrow> True\\<rbrakk>\n       \\<Longrightarrow> - int pc - int n \\<le> m \\<and>\n                         m < int (Suc (length ins + n') - pc)", "apply(case_tac pc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ins n n' pc.\n       \\<lbrakk>\\<And>n n' pc.\n                   \\<lbrakk>jump_ok ins n n'; ins ! pc = IfFalse m;\n                    pc < length ins\\<rbrakk>\n                   \\<Longrightarrow> - int pc - int n \\<le> m \\<and>\n                                     m < int (length ins + n' - pc);\n        (a # ins) ! pc = IfFalse m; pc < Suc (length ins);\n        jump_ok ins (Suc n) n';\n        case a of\n        Goto m \\<Rightarrow>\n          - int n \\<le> m \\<and> m \\<le> int (n' + length ins)\n        | IfFalse m \\<Rightarrow>\n            - int n \\<le> m \\<and> m \\<le> int (n' + length ins)\n        | _ \\<Rightarrow> True;\n        pc = 0\\<rbrakk>\n       \\<Longrightarrow> - int pc - int n \\<le> m \\<and>\n                         m < int (Suc (length ins + n') - pc)\n 2. \\<And>a ins n n' pc nat.\n       \\<lbrakk>\\<And>n n' pc.\n                   \\<lbrakk>jump_ok ins n n'; ins ! pc = IfFalse m;\n                    pc < length ins\\<rbrakk>\n                   \\<Longrightarrow> - int pc - int n \\<le> m \\<and>\n                                     m < int (length ins + n' - pc);\n        (a # ins) ! pc = IfFalse m; pc < Suc (length ins);\n        jump_ok ins (Suc n) n';\n        case a of\n        Goto m \\<Rightarrow>\n          - int n \\<le> m \\<and> m \\<le> int (n' + length ins)\n        | IfFalse m \\<Rightarrow>\n            - int n \\<le> m \\<and> m \\<le> int (n' + length ins)\n        | _ \\<Rightarrow> True;\n        pc = Suc nat\\<rbrakk>\n       \\<Longrightarrow> - int pc - int n \\<le> m \\<and>\n                         m < int (Suc (length ins + n') - pc)", "apply(fastforce)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fixes e :: \"'addr expr1\" and es :: \"'addr expr1 list\"\n  shows compE2_jump_ok [intro!]: \"jump_ok (compE2 e) n (Suc n')\"\n  and compEs2_jump_ok [intro!]: \"jump_ok (compEs2 es) n (Suc n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump_ok (compE2 e) n (Suc n') &&& jump_ok (compEs2 es) n (Suc n')", "apply(induct e and es arbitrary: n n' and n n' rule: compE2.induct compEs2.induct)"], ["proof (prove)\ngoal (25 subgoals):\n 1. \\<And>x n n'. jump_ok (compE2 (new x)) n (Suc n')\n 2. \\<And>x1 x2 n n'.\n       (\\<And>n n'. jump_ok (compE2 x2) n (Suc n')) \\<Longrightarrow>\n       jump_ok (compE2 (newA x1\\<lfloor>x2\\<rceil>)) n (Suc n')\n 3. \\<And>x1 x2 n n'.\n       (\\<And>n n'. jump_ok (compE2 x2) n (Suc n')) \\<Longrightarrow>\n       jump_ok (compE2 (Cast x1 x2)) n (Suc n')\n 4. \\<And>x1 x2 n n'.\n       (\\<And>n n'. jump_ok (compE2 x1) n (Suc n')) \\<Longrightarrow>\n       jump_ok (compE2 (x1 instanceof x2)) n (Suc n')\n 5. \\<And>x n n'. jump_ok (compE2 (Val x)) n (Suc n')\n 6. \\<And>x1 x2 x3 n n'.\n       \\<lbrakk>\\<And>n n'. jump_ok (compE2 x1) n (Suc n');\n        \\<And>n n'. jump_ok (compE2 x3) n (Suc n')\\<rbrakk>\n       \\<Longrightarrow> jump_ok\n                          (compE2\n                            (x1 \\<guillemotleft>x2\\<guillemotright> x3))\n                          n (Suc n')\n 7. \\<And>x n n'. jump_ok (compE2 (Var x)) n (Suc n')\n 8. \\<And>x1 x2 n n'.\n       (\\<And>n n'. jump_ok (compE2 x2) n (Suc n')) \\<Longrightarrow>\n       jump_ok (compE2 (x1:=x2)) n (Suc n')\n 9. \\<And>x1 x2 n n'.\n       \\<lbrakk>\\<And>n n'. jump_ok (compE2 x1) n (Suc n');\n        \\<And>n n'. jump_ok (compE2 x2) n (Suc n')\\<rbrakk>\n       \\<Longrightarrow> jump_ok (compE2 (x1\\<lfloor>x2\\<rceil>)) n (Suc n')\n 10. \\<And>x1 x2 x3 n n'.\n        \\<lbrakk>\\<And>n n'. jump_ok (compE2 x1) n (Suc n');\n         \\<And>n n'. jump_ok (compE2 x2) n (Suc n');\n         \\<And>n n'. jump_ok (compE2 x3) n (Suc n')\\<rbrakk>\n        \\<Longrightarrow> jump_ok (compE2 (x1\\<lfloor>x2\\<rceil> := x3)) n\n                           (Suc n')\nA total of 25 subgoals...", "apply(auto split: bop.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fixes e :: \"'addr expr1\" and es :: \"'addr expr1 list\"\n  shows compE1_Goto_not_same: \"\\<lbrakk> compE2 e ! pc = Goto i; pc < length (compE2 e) \\<rbrakk> \\<Longrightarrow> nat (int pc + i) \\<noteq> pc\"\n  and compEs2_Goto_not_same: \"\\<lbrakk> compEs2 es ! pc = Goto i; pc < length (compEs2 es) \\<rbrakk> \\<Longrightarrow> nat (int pc + i) \\<noteq> pc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>compE2 e ! pc = Goto i; pc < length (compE2 e)\\<rbrakk>\n     \\<Longrightarrow> nat (int pc + i) \\<noteq> pc) &&&\n    (\\<lbrakk>compEs2 es ! pc = Goto i; pc < length (compEs2 es)\\<rbrakk>\n     \\<Longrightarrow> nat (int pc + i) \\<noteq> pc)", "apply(induct e and es arbitrary: pc i and pc i rule: compE2.induct compEs2.induct)"], ["proof (prove)\ngoal (25 subgoals):\n 1. \\<And>x pc i.\n       \\<lbrakk>compE2 (new x) ! pc = Goto i;\n        pc < length (compE2 (new x))\\<rbrakk>\n       \\<Longrightarrow> nat (int pc + i) \\<noteq> pc\n 2. \\<And>x1 x2 pc i.\n       \\<lbrakk>\\<And>pc i.\n                   \\<lbrakk>compE2 x2 ! pc = Goto i;\n                    pc < length (compE2 x2)\\<rbrakk>\n                   \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n        compE2 (newA x1\\<lfloor>x2\\<rceil>) ! pc = Goto i;\n        pc < length (compE2 (newA x1\\<lfloor>x2\\<rceil>))\\<rbrakk>\n       \\<Longrightarrow> nat (int pc + i) \\<noteq> pc\n 3. \\<And>x1 x2 pc i.\n       \\<lbrakk>\\<And>pc i.\n                   \\<lbrakk>compE2 x2 ! pc = Goto i;\n                    pc < length (compE2 x2)\\<rbrakk>\n                   \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n        compE2 (Cast x1 x2) ! pc = Goto i;\n        pc < length (compE2 (Cast x1 x2))\\<rbrakk>\n       \\<Longrightarrow> nat (int pc + i) \\<noteq> pc\n 4. \\<And>x1 x2 pc i.\n       \\<lbrakk>\\<And>pc i.\n                   \\<lbrakk>compE2 x1 ! pc = Goto i;\n                    pc < length (compE2 x1)\\<rbrakk>\n                   \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n        compE2 (x1 instanceof x2) ! pc = Goto i;\n        pc < length (compE2 (x1 instanceof x2))\\<rbrakk>\n       \\<Longrightarrow> nat (int pc + i) \\<noteq> pc\n 5. \\<And>x pc i.\n       \\<lbrakk>compE2 (Val x) ! pc = Goto i;\n        pc < length (compE2 (Val x))\\<rbrakk>\n       \\<Longrightarrow> nat (int pc + i) \\<noteq> pc\n 6. \\<And>x1 x2 x3 pc i.\n       \\<lbrakk>\\<And>pc i.\n                   \\<lbrakk>compE2 x1 ! pc = Goto i;\n                    pc < length (compE2 x1)\\<rbrakk>\n                   \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n        \\<And>pc i.\n           \\<lbrakk>compE2 x3 ! pc = Goto i;\n            pc < length (compE2 x3)\\<rbrakk>\n           \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n        compE2 (x1 \\<guillemotleft>x2\\<guillemotright> x3) ! pc = Goto i;\n        pc < length\n              (compE2 (x1 \\<guillemotleft>x2\\<guillemotright> x3))\\<rbrakk>\n       \\<Longrightarrow> nat (int pc + i) \\<noteq> pc\n 7. \\<And>x pc i.\n       \\<lbrakk>compE2 (Var x) ! pc = Goto i;\n        pc < length (compE2 (Var x))\\<rbrakk>\n       \\<Longrightarrow> nat (int pc + i) \\<noteq> pc\n 8. \\<And>x1 x2 pc i.\n       \\<lbrakk>\\<And>pc i.\n                   \\<lbrakk>compE2 x2 ! pc = Goto i;\n                    pc < length (compE2 x2)\\<rbrakk>\n                   \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n        compE2 (x1:=x2) ! pc = Goto i;\n        pc < length (compE2 (x1:=x2))\\<rbrakk>\n       \\<Longrightarrow> nat (int pc + i) \\<noteq> pc\n 9. \\<And>x1 x2 pc i.\n       \\<lbrakk>\\<And>pc i.\n                   \\<lbrakk>compE2 x1 ! pc = Goto i;\n                    pc < length (compE2 x1)\\<rbrakk>\n                   \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n        \\<And>pc i.\n           \\<lbrakk>compE2 x2 ! pc = Goto i;\n            pc < length (compE2 x2)\\<rbrakk>\n           \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n        compE2 (x1\\<lfloor>x2\\<rceil>) ! pc = Goto i;\n        pc < length (compE2 (x1\\<lfloor>x2\\<rceil>))\\<rbrakk>\n       \\<Longrightarrow> nat (int pc + i) \\<noteq> pc\n 10. \\<And>x1 x2 x3 pc i.\n        \\<lbrakk>\\<And>pc i.\n                    \\<lbrakk>compE2 x1 ! pc = Goto i;\n                     pc < length (compE2 x1)\\<rbrakk>\n                    \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n         \\<And>pc i.\n            \\<lbrakk>compE2 x2 ! pc = Goto i;\n             pc < length (compE2 x2)\\<rbrakk>\n            \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n         \\<And>pc i.\n            \\<lbrakk>compE2 x3 ! pc = Goto i;\n             pc < length (compE2 x3)\\<rbrakk>\n            \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n         compE2 (x1\\<lfloor>x2\\<rceil> := x3) ! pc = Goto i;\n         pc < length (compE2 (x1\\<lfloor>x2\\<rceil> := x3))\\<rbrakk>\n        \\<Longrightarrow> nat (int pc + i) \\<noteq> pc\nA total of 25 subgoals...", "apply(auto simp add: nth_Cons nth_append split: if_split_asm bop.split_asm nat.splits)"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>x1 x3 pc i.\n       \\<lbrakk>pc < Suc (length (compE2 x1) + length (compE2 x3));\n        \\<And>pc i.\n           \\<lbrakk>compE2 x1 ! pc = Goto i;\n            pc < length (compE2 x1)\\<rbrakk>\n           \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n        \\<And>pc i.\n           \\<lbrakk>compE2 x3 ! pc = Goto i;\n            pc < length (compE2 x3)\\<rbrakk>\n           \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n        \\<not> pc < length (compE2 x1);\n        pc - length (compE2 x1) < length (compE2 x3);\n        compE2 x3 ! (pc - length (compE2 x1)) = Goto i;\n        nat (int pc + i) = pc\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x1 x2 pc i.\n       \\<lbrakk>pc < Suc (length (compE2 x1) + length (compE2 x2));\n        \\<And>pc i.\n           \\<lbrakk>compE2 x1 ! pc = Goto i;\n            pc < length (compE2 x1)\\<rbrakk>\n           \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n        \\<And>pc i.\n           \\<lbrakk>compE2 x2 ! pc = Goto i;\n            pc < length (compE2 x2)\\<rbrakk>\n           \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n        \\<not> pc < length (compE2 x1);\n        pc - length (compE2 x1) < length (compE2 x2);\n        compE2 x2 ! (pc - length (compE2 x1)) = Goto i;\n        nat (int pc + i) = pc\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x1 x2 x3 pc i.\n       \\<lbrakk>pc < Suc (Suc (length (compE2 x1) +\n                               (length (compE2 x2) + length (compE2 x3))));\n        \\<And>pc i.\n           \\<lbrakk>compE2 x1 ! pc = Goto i;\n            pc < length (compE2 x1)\\<rbrakk>\n           \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n        \\<And>pc i.\n           \\<lbrakk>compE2 x2 ! pc = Goto i;\n            pc < length (compE2 x2)\\<rbrakk>\n           \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n        \\<And>pc i.\n           \\<lbrakk>compE2 x3 ! pc = Goto i;\n            pc < length (compE2 x3)\\<rbrakk>\n           \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n        \\<not> pc < length (compE2 x1);\n        pc - length (compE2 x1) < length (compE2 x2);\n        compE2 x2 ! (pc - length (compE2 x1)) = Goto i;\n        nat (int pc + i) = pc\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x1 x2 x3 pc i.\n       \\<lbrakk>pc < Suc (Suc (length (compE2 x1) +\n                               (length (compE2 x2) + length (compE2 x3))));\n        \\<And>pc i.\n           \\<lbrakk>compE2 x1 ! pc = Goto i;\n            pc < length (compE2 x1)\\<rbrakk>\n           \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n        \\<And>pc i.\n           \\<lbrakk>compE2 x2 ! pc = Goto i;\n            pc < length (compE2 x2)\\<rbrakk>\n           \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n        \\<And>pc i.\n           \\<lbrakk>compE2 x3 ! pc = Goto i;\n            pc < length (compE2 x3)\\<rbrakk>\n           \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n        \\<not> pc < length (compE2 x1);\n        \\<not> pc - length (compE2 x1) < length (compE2 x2);\n        pc - (length (compE2 x1) + length (compE2 x2)) < length (compE2 x3);\n        compE2 x3 ! (pc - (length (compE2 x1) + length (compE2 x2))) =\n        Goto i;\n        nat (int pc + i) = pc\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>x1 x4 pc i.\n       \\<lbrakk>pc < Suc (Suc (length (compE2 x1) + length (compE2 x4)));\n        \\<And>pc i.\n           \\<lbrakk>compE2 x1 ! pc = Goto i;\n            pc < length (compE2 x1)\\<rbrakk>\n           \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n        \\<And>pc i.\n           \\<lbrakk>compE2 x4 ! pc = Goto i;\n            pc < length (compE2 x4)\\<rbrakk>\n           \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n        \\<not> pc < length (compE2 x1);\n        pc - length (compE2 x1) < length (compE2 x4);\n        compE2 x4 ! (pc - length (compE2 x1)) = Goto i;\n        nat (int pc + i) = pc\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>x1 x4 x5 pc i.\n       \\<lbrakk>pc < Suc (length (compE2 x1) +\n                          (length (compE2 x4) + length (compE2 x5)));\n        \\<And>pc i.\n           \\<lbrakk>compE2 x1 ! pc = Goto i;\n            pc < length (compE2 x1)\\<rbrakk>\n           \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n        \\<And>pc i.\n           \\<lbrakk>compE2 x4 ! pc = Goto i;\n            pc < length (compE2 x4)\\<rbrakk>\n           \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n        \\<And>pc i.\n           \\<lbrakk>compE2 x5 ! pc = Goto i;\n            pc < length (compE2 x5)\\<rbrakk>\n           \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n        \\<not> pc < length (compE2 x1);\n        pc - length (compE2 x1) < length (compE2 x4);\n        compE2 x4 ! (pc - length (compE2 x1)) = Goto i;\n        nat (int pc + i) = pc\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>x1 x4 x5 pc i.\n       \\<lbrakk>pc < Suc (length (compE2 x1) +\n                          (length (compE2 x4) + length (compE2 x5)));\n        \\<And>pc i.\n           \\<lbrakk>compE2 x1 ! pc = Goto i;\n            pc < length (compE2 x1)\\<rbrakk>\n           \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n        \\<And>pc i.\n           \\<lbrakk>compE2 x4 ! pc = Goto i;\n            pc < length (compE2 x4)\\<rbrakk>\n           \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n        \\<And>pc i.\n           \\<lbrakk>compE2 x5 ! pc = Goto i;\n            pc < length (compE2 x5)\\<rbrakk>\n           \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n        \\<not> pc < length (compE2 x1);\n        \\<not> pc - length (compE2 x1) < length (compE2 x4);\n        pc - (length (compE2 x1) + length (compE2 x4)) < length (compE2 x5);\n        compE2 x5 ! (pc - (length (compE2 x1) + length (compE2 x4))) =\n        Goto i;\n        nat (int pc + i) = pc\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>x1 x3 pc i.\n       \\<lbrakk>pc < Suc (length (compE2 x1) + length (compEs2 x3));\n        \\<And>pc i.\n           \\<lbrakk>compE2 x1 ! pc = Goto i;\n            pc < length (compE2 x1)\\<rbrakk>\n           \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n        \\<And>pc i.\n           \\<lbrakk>compEs2 x3 ! pc = Goto i;\n            pc < length (compEs2 x3)\\<rbrakk>\n           \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n        \\<not> pc < length (compE2 x1);\n        pc - length (compE2 x1) < length (compEs2 x3);\n        compEs2 x3 ! (pc - length (compE2 x1)) = Goto i;\n        nat (int pc + i) = pc\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>x4 pc i.\n       \\<lbrakk>pc < Suc (Suc (length (compE2 x4)));\n        \\<And>pc i.\n           \\<lbrakk>compE2 x4 ! pc = Goto i;\n            pc < length (compE2 x4)\\<rbrakk>\n           \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n        \\<not> pc < Suc (Suc 0); compE2 x4 ! (pc - Suc (Suc 0)) = Goto i;\n        nat (int pc + i) = pc\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>x2 x3 pc i x2c.\n        \\<lbrakk>pc < Suc (Suc (Suc (Suc\n(Suc (Suc (Suc (Suc (Suc (length (compE2 x2) + length (compE2 x3))))))))));\n         \\<And>pc i.\n            \\<lbrakk>compE2 x2 ! pc = Goto i;\n             pc < length (compE2 x2)\\<rbrakk>\n            \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n         \\<And>pc i.\n            \\<lbrakk>compE2 x3 ! pc = Goto i;\n             pc < length (compE2 x3)\\<rbrakk>\n            \\<Longrightarrow> nat (int pc + i) \\<noteq> pc;\n         \\<not> pc < length (compE2 x2);\n         pc - length (compE2 x2) = Suc (Suc (Suc x2c));\n         x2c < length (compE2 x3); compE2 x3 ! x2c = Goto i;\n         nat (int pc + i) = pc\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 16 subgoals...", "apply fastforce+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "fun ins_jump_ok :: \"'addr instr \\<Rightarrow> nat \\<Rightarrow> bool\"\nwhere\n  \"ins_jump_ok (Goto m) l = (- (int l) \\<le> m)\"\n| \"ins_jump_ok (IfFalse m) l = (- (int l) \\<le> m)\"\n| \"ins_jump_ok _ _ = True\""], ["", "definition wf_ci :: \"('addr, 'heap) check_instr' \\<Rightarrow> bool\"\nwhere\n  \"wf_ci ci \\<longleftrightarrow>\n   ci_stk_offer ci \\<and> ci \\<le> check_instr' \\<and>\n   (\\<forall>ins P h stk loc C M pc pc' frs. ci ins P h stk loc C M pc frs \\<longrightarrow> ins_jump_ok ins pc' \\<longrightarrow> ci ins P h stk loc C M pc' frs)\""], ["", "lemma wf_ciI:\n  \"\\<lbrakk> ci_stk_offer ci;\n    \\<And>ins P h stk loc C M pc frs. ci ins P h stk loc C M pc frs \\<Longrightarrow> check_instr' ins P h stk loc C M pc frs;\n    \\<And>ins P h stk loc C M pc pc' frs. \\<lbrakk> ci ins P h stk loc C M pc frs; ins_jump_ok ins pc' \\<rbrakk> \\<Longrightarrow> ci ins P h stk loc C M pc' frs \\<rbrakk>\n  \\<Longrightarrow> wf_ci ci\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ci_stk_offer ci;\n     \\<And>ins P h stk loc C M pc frs.\n        ci ins P h stk loc C M pc frs \\<Longrightarrow>\n        check_instr' ins P h stk loc C M pc frs;\n     \\<And>ins P h stk loc C M pc pc' frs.\n        \\<lbrakk>ci ins P h stk loc C M pc frs; ins_jump_ok ins pc'\\<rbrakk>\n        \\<Longrightarrow> ci ins P h stk loc C M pc' frs\\<rbrakk>\n    \\<Longrightarrow> wf_ci ci", "unfolding wf_ci_def le_fun_def le_bool_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ci_stk_offer ci;\n     \\<And>ins P h stk loc C M pc frs.\n        ci ins P h stk loc C M pc frs \\<Longrightarrow>\n        check_instr' ins P h stk loc C M pc frs;\n     \\<And>ins P h stk loc C M pc pc' frs.\n        \\<lbrakk>ci ins P h stk loc C M pc frs; ins_jump_ok ins pc'\\<rbrakk>\n        \\<Longrightarrow> ci ins P h stk loc C M pc' frs\\<rbrakk>\n    \\<Longrightarrow> ci_stk_offer ci \\<and>\n                      (\\<forall>x xa xb xc xd xe xf xg xh.\n                          ci x xa xb xc xd xe xf xg xh \\<longrightarrow>\n                          check_instr' x xa xb xc xd xe xf xg xh) \\<and>\n                      (\\<forall>ins P h stk loc C M pc pc' frs.\n                          ci ins P h stk loc C M pc frs \\<longrightarrow>\n                          ins_jump_ok ins pc' \\<longrightarrow>\n                          ci ins P h stk loc C M pc' frs)", "by blast"], ["", "lemma check_instr'_pc:\n  \"\\<lbrakk> check_instr' ins P h stk loc C M pc frs; ins_jump_ok ins pc' \\<rbrakk> \\<Longrightarrow> check_instr' ins P h stk loc C M pc' frs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>check_instr' ins P h stk loc C M pc frs;\n     ins_jump_ok ins pc'\\<rbrakk>\n    \\<Longrightarrow> check_instr' ins P h stk loc C M pc' frs", "by(cases ins) auto"], ["", "lemma wf_ci_check_instr' [iff]:\n  \"wf_ci check_instr'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_ci check_instr'", "apply(rule wf_ciI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ci_stk_offer check_instr'\n 2. \\<And>ins P h stk loc C M pc frs.\n       check_instr' ins P h stk loc C M pc frs \\<Longrightarrow>\n       check_instr' ins P h stk loc C M pc frs\n 3. \\<And>ins P h stk loc C M pc pc' frs.\n       \\<lbrakk>check_instr' ins P h stk loc C M pc frs;\n        ins_jump_ok ins pc'\\<rbrakk>\n       \\<Longrightarrow> check_instr' ins P h stk loc C M pc' frs", "apply(rule check_instr'_stk_offer)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ins P h stk loc C M pc frs.\n       check_instr' ins P h stk loc C M pc frs \\<Longrightarrow>\n       check_instr' ins P h stk loc C M pc frs\n 2. \\<And>ins P h stk loc C M pc pc' frs.\n       \\<lbrakk>check_instr' ins P h stk loc C M pc frs;\n        ins_jump_ok ins pc'\\<rbrakk>\n       \\<Longrightarrow> check_instr' ins P h stk loc C M pc' frs", "apply(assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ins P h stk loc C M pc pc' frs.\n       \\<lbrakk>check_instr' ins P h stk loc C M pc frs;\n        ins_jump_ok ins pc'\\<rbrakk>\n       \\<Longrightarrow> check_instr' ins P h stk loc C M pc' frs", "apply(erule (1) check_instr'_pc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma jump_ok_ins_jump_ok:\n  \"\\<lbrakk> jump_ok ins n n'; pc < length ins \\<rbrakk> \\<Longrightarrow> ins_jump_ok (ins ! pc) (pc + n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>jump_ok ins n n'; pc < length ins\\<rbrakk>\n    \\<Longrightarrow> ins_jump_ok (ins ! pc) (pc + n)", "apply(induct ins arbitrary: n n' pc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n' pc.\n       \\<lbrakk>jump_ok [] n n'; pc < length []\\<rbrakk>\n       \\<Longrightarrow> ins_jump_ok ([] ! pc) (pc + n)\n 2. \\<And>a ins n n' pc.\n       \\<lbrakk>\\<And>n n' pc.\n                   \\<lbrakk>jump_ok ins n n'; pc < length ins\\<rbrakk>\n                   \\<Longrightarrow> ins_jump_ok (ins ! pc) (pc + n);\n        jump_ok (a # ins) n n'; pc < length (a # ins)\\<rbrakk>\n       \\<Longrightarrow> ins_jump_ok ((a # ins) ! pc) (pc + n)", "apply(fastforce simp add: nth_Cons' gr0_conv_Suc split: instr.split_asm)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context JVM_heap_base begin"], ["", "lemma check_instr_pc:\n  \"\\<lbrakk> check_instr ins P h stk loc C M pc frs; ins_jump_ok ins pc' \\<rbrakk> \\<Longrightarrow> check_instr ins P h stk loc C M pc' frs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>check_instr ins P h stk loc C M pc frs;\n     ins_jump_ok ins pc'\\<rbrakk>\n    \\<Longrightarrow> check_instr ins P h stk loc C M pc' frs", "by(cases ins) auto"], ["", "lemma wf_ci_check_instr [iff]:\n  \"wf_ci check_instr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_ci check_instr", "apply(rule wf_ciI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ci_stk_offer check_instr\n 2. \\<And>ins P h stk loc C M pc frs.\n       check_instr ins P h stk loc C M pc frs \\<Longrightarrow>\n       check_instr' ins P h stk loc C M pc frs\n 3. \\<And>ins P h stk loc C M pc pc' frs.\n       \\<lbrakk>check_instr ins P h stk loc C M pc frs;\n        ins_jump_ok ins pc'\\<rbrakk>\n       \\<Longrightarrow> check_instr ins P h stk loc C M pc' frs", "apply(rule check_instr_stk_offer)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ins P h stk loc C M pc frs.\n       check_instr ins P h stk loc C M pc frs \\<Longrightarrow>\n       check_instr' ins P h stk loc C M pc frs\n 2. \\<And>ins P h stk loc C M pc pc' frs.\n       \\<lbrakk>check_instr ins P h stk loc C M pc frs;\n        ins_jump_ok ins pc'\\<rbrakk>\n       \\<Longrightarrow> check_instr ins P h stk loc C M pc' frs", "apply(erule check_instr_imp_check_instr')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ins P h stk loc C M pc pc' frs.\n       \\<lbrakk>check_instr ins P h stk loc C M pc frs;\n        ins_jump_ok ins pc'\\<rbrakk>\n       \\<Longrightarrow> check_instr ins P h stk loc C M pc' frs", "apply(erule (1) check_instr_pc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma wf_ciD1: \"wf_ci ci \\<Longrightarrow> ci_stk_offer ci\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_ci ci \\<Longrightarrow> ci_stk_offer ci", "unfolding wf_ci_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ci_stk_offer ci \\<and>\n    ci \\<le> check_instr' \\<and>\n    (\\<forall>ins P h stk loc C M pc pc' frs.\n        ci ins P h stk loc C M pc frs \\<longrightarrow>\n        ins_jump_ok ins pc' \\<longrightarrow>\n        ci ins P h stk loc C M pc' frs) \\<Longrightarrow>\n    ci_stk_offer ci", "by blast"], ["", "lemma wf_ciD2: \"\\<lbrakk> wf_ci ci; ci ins P h stk loc C M pc frs \\<rbrakk> \\<Longrightarrow> check_instr' ins P h stk loc C M pc frs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_ci ci; ci ins P h stk loc C M pc frs\\<rbrakk>\n    \\<Longrightarrow> check_instr' ins P h stk loc C M pc frs", "unfolding wf_ci_def le_fun_def le_bool_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ci_stk_offer ci \\<and>\n             (\\<forall>x xa xb xc xd xe xf xg xh.\n                 ci x xa xb xc xd xe xf xg xh \\<longrightarrow>\n                 check_instr' x xa xb xc xd xe xf xg xh) \\<and>\n             (\\<forall>ins P h stk loc C M pc pc' frs.\n                 ci ins P h stk loc C M pc frs \\<longrightarrow>\n                 ins_jump_ok ins pc' \\<longrightarrow>\n                 ci ins P h stk loc C M pc' frs);\n     ci ins P h stk loc C M pc frs\\<rbrakk>\n    \\<Longrightarrow> check_instr' ins P h stk loc C M pc frs", "by blast"], ["", "lemma wf_ciD3: \"\\<lbrakk> wf_ci ci; ci ins P h stk loc C M pc frs; ins_jump_ok ins pc' \\<rbrakk> \\<Longrightarrow> ci ins P h stk loc C M pc' frs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_ci ci; ci ins P h stk loc C M pc frs;\n     ins_jump_ok ins pc'\\<rbrakk>\n    \\<Longrightarrow> ci ins P h stk loc C M pc' frs", "unfolding wf_ci_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ci_stk_offer ci \\<and>\n             ci \\<le> check_instr' \\<and>\n             (\\<forall>ins P h stk loc C M pc pc' frs.\n                 ci ins P h stk loc C M pc frs \\<longrightarrow>\n                 ins_jump_ok ins pc' \\<longrightarrow>\n                 ci ins P h stk loc C M pc' frs);\n     ci ins P h stk loc C M pc frs; ins_jump_ok ins pc'\\<rbrakk>\n    \\<Longrightarrow> ci ins P h stk loc C M pc' frs", "by blast"], ["", "lemma check_instr'_ins_jump_ok: \"check_instr' ins P h stk loc C M pc frs \\<Longrightarrow> ins_jump_ok ins pc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_instr' ins P h stk loc C M pc frs \\<Longrightarrow>\n    ins_jump_ok ins pc", "by(cases ins) auto"], ["", "lemma wf_ci_ins_jump_ok:\n  assumes wf: \"wf_ci ci\"\n  and ci: \"ci ins P h stk loc C M pc frs\"\n  and pc': \"pc \\<le> pc'\"\n  shows \"ins_jump_ok ins pc'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ins_jump_ok ins pc'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ins_jump_ok ins pc'", "from wf ci"], ["proof (chain)\npicking this:\n  wf_ci ci\n  ci ins P h stk loc C M pc frs", "have \"check_instr' ins P h stk loc C M pc frs\""], ["proof (prove)\nusing this:\n  wf_ci ci\n  ci ins P h stk loc C M pc frs\n\ngoal (1 subgoal):\n 1. check_instr' ins P h stk loc C M pc frs", "by(rule wf_ciD2)"], ["proof (state)\nthis:\n  check_instr' ins P h stk loc C M pc frs\n\ngoal (1 subgoal):\n 1. ins_jump_ok ins pc'", "with pc'"], ["proof (chain)\npicking this:\n  pc \\<le> pc'\n  check_instr' ins P h stk loc C M pc frs", "have \"check_instr' ins P h stk loc C M pc' frs\""], ["proof (prove)\nusing this:\n  pc \\<le> pc'\n  check_instr' ins P h stk loc C M pc frs\n\ngoal (1 subgoal):\n 1. check_instr' ins P h stk loc C M pc' frs", "by(cases ins) auto"], ["proof (state)\nthis:\n  check_instr' ins P h stk loc C M pc' frs\n\ngoal (1 subgoal):\n 1. ins_jump_ok ins pc'", "thus ?thesis"], ["proof (prove)\nusing this:\n  check_instr' ins P h stk loc C M pc' frs\n\ngoal (1 subgoal):\n 1. ins_jump_ok ins pc'", "by(rule check_instr'_ins_jump_ok)"], ["proof (state)\nthis:\n  ins_jump_ok ins pc'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_ciD3': \"\\<lbrakk> wf_ci ci; ci ins P h stk loc C M pc frs; pc \\<le> pc' \\<rbrakk> \\<Longrightarrow> ci ins P h stk loc C M pc' frs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_ci ci; ci ins P h stk loc C M pc frs; pc \\<le> pc'\\<rbrakk>\n    \\<Longrightarrow> ci ins P h stk loc C M pc' frs", "apply(frule (2) wf_ci_ins_jump_ok)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_ci ci; ci ins P h stk loc C M pc frs; pc \\<le> pc';\n     ins_jump_ok ins pc'\\<rbrakk>\n    \\<Longrightarrow> ci ins P h stk loc C M pc' frs", "apply(erule (2) wf_ciD3)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "typedef ('addr, 'heap) check_instr = \"Collect wf_ci :: ('addr, 'heap) check_instr' set\"\n  morphisms ci_app Abs_check_instr"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> Collect wf_ci", "by auto"], ["", "lemma ci_app_check_instr' [simp]: \"ci_app (Abs_check_instr check_instr') = check_instr'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ci_app (Abs_check_instr check_instr') = check_instr'", "by(simp add: Abs_check_instr_inverse)"], ["", "lemma (in JVM_heap_base) ci_app_check_instr [simp]: \"ci_app (Abs_check_instr check_instr) = check_instr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ci_app (Abs_check_instr check_instr) = check_instr", "by(simp add: Abs_check_instr_inverse)"], ["", "lemma wf_ci_stk_offerD:\n  \"ci_app ci ins P h stk loc C M pc frs \\<Longrightarrow> ci_app ci ins P h (stk @ stk') loc C M pc frs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ci_app ci ins P h stk loc C M pc frs \\<Longrightarrow>\n    ci_app ci ins P h (stk @ stk') loc C M pc frs", "apply(rule ci_stk_offerD[OF wf_ciD1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. ci_app ci ins P h stk loc C M pc frs \\<Longrightarrow>\n    wf_ci (\\<lambda>a b c d e f g h i. c)\n 2. ci_app ci ins P h stk loc C M pc frs \\<Longrightarrow>\n    ci_app ci ins P h (stk @ stk') loc C M pc frs", "back"], ["proof (prove)\ngoal (2 subgoals):\n 1. ci_app ci ins P h stk loc C M pc frs \\<Longrightarrow> wf_ci (ci_app ci)\n 2. ci_app ci ins P h stk loc C M pc frs \\<Longrightarrow>\n    ci_app ci ins P h stk loc C M pc frs", "by(rule ci_app [simplified])"], ["", "lemma wf_ciD2_ci_app:\n  \"ci_app ci ins P h stk loc C M pc frs \\<Longrightarrow> check_instr' ins P h stk loc C M pc frs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ci_app ci ins P h stk loc C M pc frs \\<Longrightarrow>\n    check_instr' ins P h stk loc C M pc frs", "apply(cases ci)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>ci_app ci ins P h stk loc C M pc frs;\n        ci = Abs_check_instr y; y \\<in> Collect wf_ci\\<rbrakk>\n       \\<Longrightarrow> check_instr' ins P h stk loc C M pc frs", "apply(simp add: Abs_check_instr_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y ins P h stk loc C M pc frs; ci = Abs_check_instr y;\n        wf_ci y\\<rbrakk>\n       \\<Longrightarrow> check_instr' ins P h stk loc C M pc frs", "apply(erule (1) wf_ciD2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wf_ciD3_ci_app:\n  \"\\<lbrakk> ci_app ci ins P h stk loc C M pc frs; ins_jump_ok ins pc' \\<rbrakk> \\<Longrightarrow> ci_app ci ins P h stk loc C M pc' frs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ci_app ci ins P h stk loc C M pc frs;\n     ins_jump_ok ins pc'\\<rbrakk>\n    \\<Longrightarrow> ci_app ci ins P h stk loc C M pc' frs", "apply(cases ci)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>ci_app ci ins P h stk loc C M pc frs; ins_jump_ok ins pc';\n        ci = Abs_check_instr y; y \\<in> Collect wf_ci\\<rbrakk>\n       \\<Longrightarrow> ci_app ci ins P h stk loc C M pc' frs", "apply(simp add: Abs_check_instr_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y ins P h stk loc C M pc frs; ins_jump_ok ins pc';\n        ci = Abs_check_instr y; wf_ci y\\<rbrakk>\n       \\<Longrightarrow> y ins P h stk loc C M pc' frs", "apply(erule (2) wf_ciD3)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wf_ciD3'_ci_app: \"\\<lbrakk> ci_app ci ins P h stk loc C M pc frs; pc \\<le> pc' \\<rbrakk> \\<Longrightarrow> ci_app ci ins P h stk loc C M pc' frs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ci_app ci ins P h stk loc C M pc frs; pc \\<le> pc'\\<rbrakk>\n    \\<Longrightarrow> ci_app ci ins P h stk loc C M pc' frs", "apply(cases ci)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>ci_app ci ins P h stk loc C M pc frs; pc \\<le> pc';\n        ci = Abs_check_instr y; y \\<in> Collect wf_ci\\<rbrakk>\n       \\<Longrightarrow> ci_app ci ins P h stk loc C M pc' frs", "apply(simp add: Abs_check_instr_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y ins P h stk loc C M pc frs; pc \\<le> pc';\n        ci = Abs_check_instr y; wf_ci y\\<rbrakk>\n       \\<Longrightarrow> y ins P h stk loc C M pc' frs", "apply(erule (2) wf_ciD3')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context JVM_heap_base begin"], ["", "inductive exec_meth ::\n  \"('addr, 'heap) check_instr \\<Rightarrow> 'addr jvm_prog \\<Rightarrow> 'addr instr list \\<Rightarrow> ex_table \\<Rightarrow> 'thread_id\n  \\<Rightarrow> 'heap \\<Rightarrow> ('addr val list \\<times> 'addr val list \\<times> pc \\<times> 'addr option) \\<Rightarrow> ('addr, 'thread_id, 'heap) jvm_thread_action\n  \\<Rightarrow> 'heap \\<Rightarrow> ('addr val list \\<times> 'addr val list \\<times> pc \\<times> 'addr option) \\<Rightarrow> bool\"\nfor ci :: \"('addr, 'heap) check_instr\" and P :: \"'addr jvm_prog\" \nand ins :: \"'addr instr list\" and xt :: \"ex_table\" and t :: 'thread_id\nwhere\n  exec_instr: \n  \"\\<lbrakk> (ta, xcp, h', [(stk', loc', undefined, undefined, pc')]) \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n     pc < length ins;\n     ci_app ci (ins ! pc) P h stk loc undefined undefined pc [] \\<rbrakk>\n  \\<Longrightarrow> exec_meth ci P ins xt t h (stk, loc, pc, None) ta h' (stk', loc', pc', xcp)\"\n\n| exec_catch:\n  \"\\<lbrakk> match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d)\\<rfloor>; d \\<le> length stk \\<rbrakk>\n  \\<Longrightarrow> exec_meth ci P ins xt t h (stk, loc, pc, \\<lfloor>xcp\\<rfloor>) \\<epsilon> h (Addr xcp # drop (size stk - d) stk, loc, pc', None)\""], ["", "lemma exec_meth_instr:\n  \"exec_meth ci P ins xt t h (stk, loc, pc, None) ta h' (stk', loc', pc', xcp) \\<longleftrightarrow>\n   (ta, xcp, h', [(stk', loc', undefined, undefined, pc')]) \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [] \\<and> pc < length ins \\<and> ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci P ins xt t h (stk, loc, pc, None) ta h'\n     (stk', loc', pc', xcp) =\n    ((ta, xcp, h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc\n            [] \\<and>\n     pc < length ins \\<and>\n     ci_app ci (ins ! pc) P h stk loc undefined undefined pc [])", "by(auto elim: exec_meth.cases intro: exec_instr)"], ["", "lemma exec_meth_xcpt:\n  \"exec_meth ci P ins xt t h (stk, loc, pc, \\<lfloor>xcp\\<rfloor>) ta h (stk', loc', pc', xcp') \\<longleftrightarrow>\n   (\\<exists>d. match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d)\\<rfloor> \\<and> ta = \\<epsilon> \\<and> stk' = (Addr xcp # drop (size stk - d) stk) \\<and> loc' = loc \\<and> xcp' = None \\<and> d \\<le> length stk)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci P ins xt t h (stk, loc, pc, \\<lfloor>xcp\\<rfloor>) ta h\n     (stk', loc', pc', xcp') =\n    (\\<exists>d.\n        match_ex_table P (cname_of h xcp) pc xt =\n        \\<lfloor>(pc', d)\\<rfloor> \\<and>\n        ta = \\<lbrace>\\<rbrace> \\<and>\n        stk' = Addr xcp # drop (length stk - d) stk \\<and>\n        loc' = loc \\<and> xcp' = None \\<and> d \\<le> length stk)", "by(auto elim: exec_meth.cases intro: exec_catch)"], ["", "abbreviation exec_meth_a\nwhere \"exec_meth_a \\<equiv> exec_meth (Abs_check_instr check_instr')\""], ["", "abbreviation exec_meth_d\nwhere \"exec_meth_d \\<equiv> exec_meth (Abs_check_instr check_instr)\""], ["", "lemma exec_meth_length_compE2D [dest]:\n  \"exec_meth ci P (compE2 e) (compxE2 e 0 d) t h (stk, loc, pc, xcp) ta h' s' \\<Longrightarrow> pc < length (compE2 e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci P (compE2 e) (compxE2 e 0 d) t h (stk, loc, pc, xcp) ta h'\n     s' \\<Longrightarrow>\n    pc < length (compE2 e)", "apply(erule exec_meth.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>taa xcpa h'a stk' loc' pc' pca ha stka loca.\n       \\<lbrakk>h = ha; (stk, loc, pc, xcp) = (stka, loca, pca, None);\n        ta = taa; h' = h'a; s' = (stk', loc', pc', xcpa);\n        (taa, xcpa, h'a, [(stk', loc', undefined, undefined, pc')])\n        \\<in> exec_instr (compE2 e ! pca) P t ha stka loca undefined\n               undefined pca [];\n        pca < length (compE2 e);\n        ci_app ci (compE2 e ! pca) P ha stka loca undefined undefined pca\n         []\\<rbrakk>\n       \\<Longrightarrow> pc < length (compE2 e)\n 2. \\<And>ha xcpa pca pc' da stka loca.\n       \\<lbrakk>h = ha;\n        (stk, loc, pc, xcp) = (stka, loca, pca, \\<lfloor>xcpa\\<rfloor>);\n        ta = \\<lbrace>\\<rbrace>; h' = ha;\n        s' = (Addr xcpa # drop (length stka - da) stka, loca, pc', None);\n        match_ex_table P (cname_of ha xcpa) pca (compxE2 e 0 d) =\n        \\<lfloor>(pc', da)\\<rfloor>;\n        da \\<le> length stka\\<rbrakk>\n       \\<Longrightarrow> pc < length (compE2 e)", "apply(auto dest: match_ex_table_pc_length_compE2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma exec_meth_length_compEs2D [dest]:\n  \"exec_meth ci P (compEs2 es) (compxEs2 es 0 0) t h (stk, loc, pc, xcp) ta h' s' \\<Longrightarrow> pc < length (compEs2 es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci P (compEs2 es) (compxEs2 es 0 0) t h (stk, loc, pc, xcp) ta\n     h' s' \\<Longrightarrow>\n    pc < length (compEs2 es)", "apply(erule exec_meth.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>taa xcpa h'a stk' loc' pc' pca ha stka loca.\n       \\<lbrakk>h = ha; (stk, loc, pc, xcp) = (stka, loca, pca, None);\n        ta = taa; h' = h'a; s' = (stk', loc', pc', xcpa);\n        (taa, xcpa, h'a, [(stk', loc', undefined, undefined, pc')])\n        \\<in> exec_instr (compEs2 es ! pca) P t ha stka loca undefined\n               undefined pca [];\n        pca < length (compEs2 es);\n        ci_app ci (compEs2 es ! pca) P ha stka loca undefined undefined pca\n         []\\<rbrakk>\n       \\<Longrightarrow> pc < length (compEs2 es)\n 2. \\<And>ha xcpa pca pc' d stka loca.\n       \\<lbrakk>h = ha;\n        (stk, loc, pc, xcp) = (stka, loca, pca, \\<lfloor>xcpa\\<rfloor>);\n        ta = \\<lbrace>\\<rbrace>; h' = ha;\n        s' = (Addr xcpa # drop (length stka - d) stka, loca, pc', None);\n        match_ex_table P (cname_of ha xcpa) pca (compxEs2 es 0 0) =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stka\\<rbrakk>\n       \\<Longrightarrow> pc < length (compEs2 es)", "apply(auto dest: match_ex_table_pc_length_compEs2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma exec_instr_stk_offer:\n  assumes check: \"check_instr' (ins ! pc) P h stk loc C M pc frs\"\n  and exec: \"(ta', xcp', h', (stk', loc', C, M, pc') # frs) \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\"\n  shows \"(ta', xcp', h', (stk' @ stk'', loc', C, M, pc') # frs) \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc C M pc frs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ta', xcp', h', (stk' @ stk'', loc', C, M, pc') # frs)\n    \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc C M pc frs", "using assms"], ["proof (prove)\nusing this:\n  check_instr' (ins ! pc) P h stk loc C M pc frs\n  (ta', xcp', h', (stk', loc', C, M, pc') # frs)\n  \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n\ngoal (1 subgoal):\n 1. (ta', xcp', h', (stk' @ stk'', loc', C, M, pc') # frs)\n    \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc C M pc frs", "proof(cases \"ins ! pc\")"], ["proof (state)\ngoal (24 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>check_instr' (ins ! pc) P h stk loc C M pc frs;\n        (ta', xcp', h', (stk', loc', C, M, pc') # frs)\n        \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> (ta', xcp', h',\n                          (stk' @ stk'', loc', C, M, pc') # frs)\n                         \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc\n                                C M pc frs\n 2. \\<And>x2.\n       \\<lbrakk>check_instr' (ins ! pc) P h stk loc C M pc frs;\n        (ta', xcp', h', (stk', loc', C, M, pc') # frs)\n        \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> (ta', xcp', h',\n                          (stk' @ stk'', loc', C, M, pc') # frs)\n                         \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc\n                                C M pc frs\n 3. \\<And>x3.\n       \\<lbrakk>check_instr' (ins ! pc) P h stk loc C M pc frs;\n        (ta', xcp', h', (stk', loc', C, M, pc') # frs)\n        \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> (ta', xcp', h',\n                          (stk' @ stk'', loc', C, M, pc') # frs)\n                         \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc\n                                C M pc frs\n 4. \\<And>x4.\n       \\<lbrakk>check_instr' (ins ! pc) P h stk loc C M pc frs;\n        (ta', xcp', h', (stk', loc', C, M, pc') # frs)\n        \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs;\n        ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> (ta', xcp', h',\n                          (stk' @ stk'', loc', C, M, pc') # frs)\n                         \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc\n                                C M pc frs\n 5. \\<And>x5.\n       \\<lbrakk>check_instr' (ins ! pc) P h stk loc C M pc frs;\n        (ta', xcp', h', (stk', loc', C, M, pc') # frs)\n        \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs;\n        ins ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> (ta', xcp', h',\n                          (stk' @ stk'', loc', C, M, pc') # frs)\n                         \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc\n                                C M pc frs\n 6. \\<lbrakk>check_instr' (ins ! pc) P h stk loc C M pc frs;\n     (ta', xcp', h', (stk', loc', C, M, pc') # frs)\n     \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs;\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> (ta', xcp', h', (stk' @ stk'', loc', C, M, pc') # frs)\n                      \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc C\n                             M pc frs\n 7. \\<lbrakk>check_instr' (ins ! pc) P h stk loc C M pc frs;\n     (ta', xcp', h', (stk', loc', C, M, pc') # frs)\n     \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs;\n     ins ! pc = AStore\\<rbrakk>\n    \\<Longrightarrow> (ta', xcp', h', (stk' @ stk'', loc', C, M, pc') # frs)\n                      \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc C\n                             M pc frs\n 8. \\<lbrakk>check_instr' (ins ! pc) P h stk loc C M pc frs;\n     (ta', xcp', h', (stk', loc', C, M, pc') # frs)\n     \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs;\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> (ta', xcp', h', (stk' @ stk'', loc', C, M, pc') # frs)\n                      \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc C\n                             M pc frs\n 9. \\<And>x91 x92.\n       \\<lbrakk>check_instr' (ins ! pc) P h stk loc C M pc frs;\n        (ta', xcp', h', (stk', loc', C, M, pc') # frs)\n        \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs;\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> (ta', xcp', h',\n                          (stk' @ stk'', loc', C, M, pc') # frs)\n                         \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc\n                                C M pc frs\n 10. \\<And>x101 x102.\n        \\<lbrakk>check_instr' (ins ! pc) P h stk loc C M pc frs;\n         (ta', xcp', h', (stk', loc', C, M, pc') # frs)\n         \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs;\n         ins ! pc = Putfield x101 x102\\<rbrakk>\n        \\<Longrightarrow> (ta', xcp', h',\n                           (stk' @ stk'', loc', C, M, pc') # frs)\n                          \\<in> exec_instr (ins ! pc) P t h (stk @ stk'')\n                                 loc C M pc frs\nA total of 24 subgoals...", "case (Invoke M n)"], ["proof (state)\nthis:\n  ins ! pc = Invoke M n\n\ngoal (24 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>check_instr' (ins ! pc) P h stk loc C M pc frs;\n        (ta', xcp', h', (stk', loc', C, M, pc') # frs)\n        \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> (ta', xcp', h',\n                          (stk' @ stk'', loc', C, M, pc') # frs)\n                         \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc\n                                C M pc frs\n 2. \\<And>x2.\n       \\<lbrakk>check_instr' (ins ! pc) P h stk loc C M pc frs;\n        (ta', xcp', h', (stk', loc', C, M, pc') # frs)\n        \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> (ta', xcp', h',\n                          (stk' @ stk'', loc', C, M, pc') # frs)\n                         \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc\n                                C M pc frs\n 3. \\<And>x3.\n       \\<lbrakk>check_instr' (ins ! pc) P h stk loc C M pc frs;\n        (ta', xcp', h', (stk', loc', C, M, pc') # frs)\n        \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> (ta', xcp', h',\n                          (stk' @ stk'', loc', C, M, pc') # frs)\n                         \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc\n                                C M pc frs\n 4. \\<And>x4.\n       \\<lbrakk>check_instr' (ins ! pc) P h stk loc C M pc frs;\n        (ta', xcp', h', (stk', loc', C, M, pc') # frs)\n        \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs;\n        ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> (ta', xcp', h',\n                          (stk' @ stk'', loc', C, M, pc') # frs)\n                         \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc\n                                C M pc frs\n 5. \\<And>x5.\n       \\<lbrakk>check_instr' (ins ! pc) P h stk loc C M pc frs;\n        (ta', xcp', h', (stk', loc', C, M, pc') # frs)\n        \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs;\n        ins ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> (ta', xcp', h',\n                          (stk' @ stk'', loc', C, M, pc') # frs)\n                         \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc\n                                C M pc frs\n 6. \\<lbrakk>check_instr' (ins ! pc) P h stk loc C M pc frs;\n     (ta', xcp', h', (stk', loc', C, M, pc') # frs)\n     \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs;\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> (ta', xcp', h', (stk' @ stk'', loc', C, M, pc') # frs)\n                      \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc C\n                             M pc frs\n 7. \\<lbrakk>check_instr' (ins ! pc) P h stk loc C M pc frs;\n     (ta', xcp', h', (stk', loc', C, M, pc') # frs)\n     \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs;\n     ins ! pc = AStore\\<rbrakk>\n    \\<Longrightarrow> (ta', xcp', h', (stk' @ stk'', loc', C, M, pc') # frs)\n                      \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc C\n                             M pc frs\n 8. \\<lbrakk>check_instr' (ins ! pc) P h stk loc C M pc frs;\n     (ta', xcp', h', (stk', loc', C, M, pc') # frs)\n     \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs;\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> (ta', xcp', h', (stk' @ stk'', loc', C, M, pc') # frs)\n                      \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc C\n                             M pc frs\n 9. \\<And>x91 x92.\n       \\<lbrakk>check_instr' (ins ! pc) P h stk loc C M pc frs;\n        (ta', xcp', h', (stk', loc', C, M, pc') # frs)\n        \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs;\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> (ta', xcp', h',\n                          (stk' @ stk'', loc', C, M, pc') # frs)\n                         \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc\n                                C M pc frs\n 10. \\<And>x101 x102.\n        \\<lbrakk>check_instr' (ins ! pc) P h stk loc C M pc frs;\n         (ta', xcp', h', (stk', loc', C, M, pc') # frs)\n         \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs;\n         ins ! pc = Putfield x101 x102\\<rbrakk>\n        \\<Longrightarrow> (ta', xcp', h',\n                           (stk' @ stk'', loc', C, M, pc') # frs)\n                          \\<in> exec_instr (ins ! pc) P t h (stk @ stk'')\n                                 loc C M pc frs\nA total of 24 subgoals...", "thus ?thesis"], ["proof (prove)\nusing this:\n  ins ! pc = Invoke M n\n\ngoal (1 subgoal):\n 1. (ta', xcp', h', (stk' @ stk'', loc', C, M, pc') # frs)\n    \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc C M pc frs", "using exec check"], ["proof (prove)\nusing this:\n  ins ! pc = Invoke M n\n  (ta', xcp', h', (stk', loc', C, M, pc') # frs)\n  \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs\n  check_instr' (ins ! pc) P h stk loc C M pc frs\n\ngoal (1 subgoal):\n 1. (ta', xcp', h', (stk' @ stk'', loc', C, M, pc') # frs)\n    \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc C M pc frs", "by(auto split: if_split_asm extCallRet.splits split del: if_split simp add: split_beta nth_append min_def extRet2JVM_def)"], ["proof (state)\nthis:\n  (ta', xcp', h', (stk' @ stk'', loc', C, M, pc') # frs)\n  \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc C M pc frs\n\ngoal (23 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>check_instr' (ins ! pc) P h stk loc C M pc frs;\n        (ta', xcp', h', (stk', loc', C, M, pc') # frs)\n        \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> (ta', xcp', h',\n                          (stk' @ stk'', loc', C, M, pc') # frs)\n                         \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc\n                                C M pc frs\n 2. \\<And>x2.\n       \\<lbrakk>check_instr' (ins ! pc) P h stk loc C M pc frs;\n        (ta', xcp', h', (stk', loc', C, M, pc') # frs)\n        \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> (ta', xcp', h',\n                          (stk' @ stk'', loc', C, M, pc') # frs)\n                         \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc\n                                C M pc frs\n 3. \\<And>x3.\n       \\<lbrakk>check_instr' (ins ! pc) P h stk loc C M pc frs;\n        (ta', xcp', h', (stk', loc', C, M, pc') # frs)\n        \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> (ta', xcp', h',\n                          (stk' @ stk'', loc', C, M, pc') # frs)\n                         \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc\n                                C M pc frs\n 4. \\<And>x4.\n       \\<lbrakk>check_instr' (ins ! pc) P h stk loc C M pc frs;\n        (ta', xcp', h', (stk', loc', C, M, pc') # frs)\n        \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs;\n        ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> (ta', xcp', h',\n                          (stk' @ stk'', loc', C, M, pc') # frs)\n                         \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc\n                                C M pc frs\n 5. \\<And>x5.\n       \\<lbrakk>check_instr' (ins ! pc) P h stk loc C M pc frs;\n        (ta', xcp', h', (stk', loc', C, M, pc') # frs)\n        \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs;\n        ins ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> (ta', xcp', h',\n                          (stk' @ stk'', loc', C, M, pc') # frs)\n                         \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc\n                                C M pc frs\n 6. \\<lbrakk>check_instr' (ins ! pc) P h stk loc C M pc frs;\n     (ta', xcp', h', (stk', loc', C, M, pc') # frs)\n     \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs;\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> (ta', xcp', h', (stk' @ stk'', loc', C, M, pc') # frs)\n                      \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc C\n                             M pc frs\n 7. \\<lbrakk>check_instr' (ins ! pc) P h stk loc C M pc frs;\n     (ta', xcp', h', (stk', loc', C, M, pc') # frs)\n     \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs;\n     ins ! pc = AStore\\<rbrakk>\n    \\<Longrightarrow> (ta', xcp', h', (stk' @ stk'', loc', C, M, pc') # frs)\n                      \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc C\n                             M pc frs\n 8. \\<lbrakk>check_instr' (ins ! pc) P h stk loc C M pc frs;\n     (ta', xcp', h', (stk', loc', C, M, pc') # frs)\n     \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs;\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> (ta', xcp', h', (stk' @ stk'', loc', C, M, pc') # frs)\n                      \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc C\n                             M pc frs\n 9. \\<And>x91 x92.\n       \\<lbrakk>check_instr' (ins ! pc) P h stk loc C M pc frs;\n        (ta', xcp', h', (stk', loc', C, M, pc') # frs)\n        \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs;\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> (ta', xcp', h',\n                          (stk' @ stk'', loc', C, M, pc') # frs)\n                         \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc\n                                C M pc frs\n 10. \\<And>x101 x102.\n        \\<lbrakk>check_instr' (ins ! pc) P h stk loc C M pc frs;\n         (ta', xcp', h', (stk', loc', C, M, pc') # frs)\n         \\<in> exec_instr (ins ! pc) P t h stk loc C M pc frs;\n         ins ! pc = Putfield x101 x102\\<rbrakk>\n        \\<Longrightarrow> (ta', xcp', h',\n                           (stk' @ stk'', loc', C, M, pc') # frs)\n                          \\<in> exec_instr (ins ! pc) P t h (stk @ stk'')\n                                 loc C M pc frs\nA total of 23 subgoals...", "qed(force simp add: nth_append is_Ref_def has_method_def nth_Cons split_beta hd_append tl_append neq_Nil_conv split: list.split if_split_asm nat.splits sum.split_asm)+"], ["", "lemma exec_meth_stk_offer:\n  assumes exec: \"exec_meth ci P ins xt t h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  shows \"exec_meth ci P ins (stack_xlift (length stk'') xt) t h (stk @ stk'', loc, pc, xcp) ta h' (stk' @ stk'', loc', pc', xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci P ins (stack_xlift (length stk'') xt) t h\n     (stk @ stk'', loc, pc, xcp) ta h' (stk' @ stk'', loc', pc', xcp')", "using exec"], ["proof (prove)\nusing this:\n  exec_meth ci P ins xt t h (stk, loc, pc, xcp) ta h'\n   (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci P ins (stack_xlift (length stk'') xt) t h\n     (stk @ stk'', loc, pc, xcp) ta h' (stk' @ stk'', loc', pc', xcp')", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n     pc < length ins;\n     ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P ins (stack_xlift (length stk'') xt) t h\n                       (stk @ stk'', loc, pc, xcp) ta h'\n                       (stk' @ stk'', loc', pc', xcp')\n 2. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table P (cname_of h xcpa) pc xt =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P ins (stack_xlift (length stk'') xt)\n                          t h (stk @ stk'', loc, pc, xcp) ta h'\n                          (stk' @ stk'', loc', pc', xcp')", "case (exec_catch xcp d)"], ["proof (state)\nthis:\n  xcp = \\<lfloor>xcp\\<rfloor>\n  ta = \\<lbrace>\\<rbrace>\n  h' = h\n  stk' = Addr xcp # drop (length stk - d) stk\n  loc' = loc\n  xcp' = None\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d)\\<rfloor>\n  d \\<le> length stk\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n     pc < length ins;\n     ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P ins (stack_xlift (length stk'') xt) t h\n                       (stk @ stk'', loc, pc, xcp) ta h'\n                       (stk' @ stk'', loc', pc', xcp')\n 2. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table P (cname_of h xcpa) pc xt =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P ins (stack_xlift (length stk'') xt)\n                          t h (stk @ stk'', loc, pc, xcp) ta h'\n                          (stk' @ stk'', loc', pc', xcp')", "from \\<open>match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d)\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d)\\<rfloor>", "have \"match_ex_table P (cname_of h xcp) pc (stack_xlift (length stk'') xt) = \\<lfloor>(pc', length stk'' + d)\\<rfloor>\""], ["proof (prove)\nusing this:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d)\\<rfloor>\n\ngoal (1 subgoal):\n 1. match_ex_table P (cname_of h xcp) pc (stack_xlift (length stk'') xt) =\n    \\<lfloor>(pc', length stk'' + d)\\<rfloor>", "by(simp add: match_ex_table_stack_xlift)"], ["proof (state)\nthis:\n  match_ex_table P (cname_of h xcp) pc (stack_xlift (length stk'') xt) =\n  \\<lfloor>(pc', length stk'' + d)\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n     pc < length ins;\n     ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P ins (stack_xlift (length stk'') xt) t h\n                       (stk @ stk'', loc, pc, xcp) ta h'\n                       (stk' @ stk'', loc', pc', xcp')\n 2. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table P (cname_of h xcpa) pc xt =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P ins (stack_xlift (length stk'') xt)\n                          t h (stk @ stk'', loc, pc, xcp) ta h'\n                          (stk' @ stk'', loc', pc', xcp')", "moreover"], ["proof (state)\nthis:\n  match_ex_table P (cname_of h xcp) pc (stack_xlift (length stk'') xt) =\n  \\<lfloor>(pc', length stk'' + d)\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n     pc < length ins;\n     ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P ins (stack_xlift (length stk'') xt) t h\n                       (stk @ stk'', loc, pc, xcp) ta h'\n                       (stk' @ stk'', loc', pc', xcp')\n 2. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table P (cname_of h xcpa) pc xt =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P ins (stack_xlift (length stk'') xt)\n                          t h (stk @ stk'', loc, pc, xcp) ta h'\n                          (stk' @ stk'', loc', pc', xcp')", "have \"length stk'' + d \\<le> length (stk @ stk'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length stk'' + d \\<le> length (stk @ stk'')", "using \\<open>d \\<le> length stk\\<close>"], ["proof (prove)\nusing this:\n  d \\<le> length stk\n\ngoal (1 subgoal):\n 1. length stk'' + d \\<le> length (stk @ stk'')", "by simp"], ["proof (state)\nthis:\n  length stk'' + d \\<le> length (stk @ stk'')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n     pc < length ins;\n     ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P ins (stack_xlift (length stk'') xt) t h\n                       (stk @ stk'', loc, pc, xcp) ta h'\n                       (stk' @ stk'', loc', pc', xcp')\n 2. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table P (cname_of h xcpa) pc xt =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P ins (stack_xlift (length stk'') xt)\n                          t h (stk @ stk'', loc, pc, xcp) ta h'\n                          (stk' @ stk'', loc', pc', xcp')", "ultimately"], ["proof (chain)\npicking this:\n  match_ex_table P (cname_of h xcp) pc (stack_xlift (length stk'') xt) =\n  \\<lfloor>(pc', length stk'' + d)\\<rfloor>\n  length stk'' + d \\<le> length (stk @ stk'')", "have \"exec_meth ci P ins (stack_xlift (length stk'') xt) t h ((stk @ stk''), loc, pc, \\<lfloor>xcp\\<rfloor>) \\<epsilon> h ((Addr xcp # drop (length (stk @ stk'') - (length stk'' + d)) (stk @ stk'')), loc, pc', None)\""], ["proof (prove)\nusing this:\n  match_ex_table P (cname_of h xcp) pc (stack_xlift (length stk'') xt) =\n  \\<lfloor>(pc', length stk'' + d)\\<rfloor>\n  length stk'' + d \\<le> length (stk @ stk'')\n\ngoal (1 subgoal):\n 1. exec_meth ci P ins (stack_xlift (length stk'') xt) t h\n     (stk @ stk'', loc, pc, \\<lfloor>xcp\\<rfloor>) \\<lbrace>\\<rbrace> h\n     (Addr xcp #\n      drop (length (stk @ stk'') - (length stk'' + d)) (stk @ stk''),\n      loc, pc', None)", "by(rule exec_meth.exec_catch)"], ["proof (state)\nthis:\n  exec_meth ci P ins (stack_xlift (length stk'') xt) t h\n   (stk @ stk'', loc, pc, \\<lfloor>xcp\\<rfloor>) \\<lbrace>\\<rbrace> h\n   (Addr xcp #\n    drop (length (stk @ stk'') - (length stk'' + d)) (stk @ stk''),\n    loc, pc', None)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n     pc < length ins;\n     ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P ins (stack_xlift (length stk'') xt) t h\n                       (stk @ stk'', loc, pc, xcp) ta h'\n                       (stk' @ stk'', loc', pc', xcp')\n 2. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table P (cname_of h xcpa) pc xt =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P ins (stack_xlift (length stk'') xt)\n                          t h (stk @ stk'', loc, pc, xcp) ta h'\n                          (stk' @ stk'', loc', pc', xcp')", "with exec_catch"], ["proof (chain)\npicking this:\n  xcp = \\<lfloor>xcp\\<rfloor>\n  ta = \\<lbrace>\\<rbrace>\n  h' = h\n  stk' = Addr xcp # drop (length stk - d) stk\n  loc' = loc\n  xcp' = None\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d)\\<rfloor>\n  d \\<le> length stk\n  exec_meth ci P ins (stack_xlift (length stk'') xt) t h\n   (stk @ stk'', loc, pc, \\<lfloor>xcp\\<rfloor>) \\<lbrace>\\<rbrace> h\n   (Addr xcp #\n    drop (length (stk @ stk'') - (length stk'' + d)) (stk @ stk''),\n    loc, pc', None)", "show ?thesis"], ["proof (prove)\nusing this:\n  xcp = \\<lfloor>xcp\\<rfloor>\n  ta = \\<lbrace>\\<rbrace>\n  h' = h\n  stk' = Addr xcp # drop (length stk - d) stk\n  loc' = loc\n  xcp' = None\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d)\\<rfloor>\n  d \\<le> length stk\n  exec_meth ci P ins (stack_xlift (length stk'') xt) t h\n   (stk @ stk'', loc, pc, \\<lfloor>xcp\\<rfloor>) \\<lbrace>\\<rbrace> h\n   (Addr xcp #\n    drop (length (stk @ stk'') - (length stk'' + d)) (stk @ stk''),\n    loc, pc', None)\n\ngoal (1 subgoal):\n 1. exec_meth ci P ins (stack_xlift (length stk'') xt) t h\n     (stk @ stk'', loc, pc, xcp) ta h' (stk' @ stk'', loc', pc', xcp')", "by(simp)"], ["proof (state)\nthis:\n  exec_meth ci P ins (stack_xlift (length stk'') xt) t h\n   (stk @ stk'', loc, pc, xcp) ta h' (stk' @ stk'', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n     pc < length ins;\n     ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P ins (stack_xlift (length stk'') xt) t h\n                       (stk @ stk'', loc, pc, xcp) ta h'\n                       (stk' @ stk'', loc', pc', xcp')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n     pc < length ins;\n     ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P ins (stack_xlift (length stk'') xt) t h\n                       (stk @ stk'', loc, pc, xcp) ta h'\n                       (stk' @ stk'', loc', pc', xcp')", "case exec_instr"], ["proof (state)\nthis:\n  xcp = None\n  (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n  \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc []\n  pc < length ins\n  ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n     pc < length ins;\n     ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P ins (stack_xlift (length stk'') xt) t h\n                       (stk @ stk'', loc, pc, xcp) ta h'\n                       (stk' @ stk'', loc', pc', xcp')", "note ciins = \\<open>ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<close>"], ["proof (state)\nthis:\n  ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n     pc < length ins;\n     ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P ins (stack_xlift (length stk'') xt) t h\n                       (stk @ stk'', loc, pc, xcp) ta h'\n                       (stk' @ stk'', loc', pc', xcp')", "hence \"ci_app ci (ins ! pc) P h (stk @ stk'') loc undefined undefined pc []\""], ["proof (prove)\nusing this:\n  ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\n\ngoal (1 subgoal):\n 1. ci_app ci (ins ! pc) P h (stk @ stk'') loc undefined undefined pc []", "by(rule wf_ci_stk_offerD)"], ["proof (state)\nthis:\n  ci_app ci (ins ! pc) P h (stk @ stk'') loc undefined undefined pc []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n     pc < length ins;\n     ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P ins (stack_xlift (length stk'') xt) t h\n                       (stk @ stk'', loc, pc, xcp) ta h'\n                       (stk' @ stk'', loc', pc', xcp')", "moreover"], ["proof (state)\nthis:\n  ci_app ci (ins ! pc) P h (stk @ stk'') loc undefined undefined pc []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n     pc < length ins;\n     ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P ins (stack_xlift (length stk'') xt) t h\n                       (stk @ stk'', loc, pc, xcp) ta h'\n                       (stk' @ stk'', loc', pc', xcp')", "from ciins"], ["proof (chain)\npicking this:\n  ci_app ci (ins ! pc) P h stk loc undefined undefined pc []", "have \"check_instr' (ins ! pc) P h stk loc undefined undefined  pc []\""], ["proof (prove)\nusing this:\n  ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\n\ngoal (1 subgoal):\n 1. check_instr' (ins ! pc) P h stk loc undefined undefined pc []", "by(rule wf_ciD2_ci_app)"], ["proof (state)\nthis:\n  check_instr' (ins ! pc) P h stk loc undefined undefined pc []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n     pc < length ins;\n     ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P ins (stack_xlift (length stk'') xt) t h\n                       (stk @ stk'', loc, pc, xcp) ta h'\n                       (stk' @ stk'', loc', pc', xcp')", "hence \"(ta, xcp', h', [(stk' @ stk'', loc', undefined, undefined, pc')]) \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc undefined undefined pc []\""], ["proof (prove)\nusing this:\n  check_instr' (ins ! pc) P h stk loc undefined undefined pc []\n\ngoal (1 subgoal):\n 1. (ta, xcp', h', [(stk' @ stk'', loc', undefined, undefined, pc')])\n    \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc undefined undefined\n           pc []", "using \\<open>(ta, xcp', h', [(stk', loc', undefined,undefined , pc')]) \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc []\\<close>"], ["proof (prove)\nusing this:\n  check_instr' (ins ! pc) P h stk loc undefined undefined pc []\n  (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n  \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc []\n\ngoal (1 subgoal):\n 1. (ta, xcp', h', [(stk' @ stk'', loc', undefined, undefined, pc')])\n    \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc undefined undefined\n           pc []", "by(rule exec_instr_stk_offer)"], ["proof (state)\nthis:\n  (ta, xcp', h', [(stk' @ stk'', loc', undefined, undefined, pc')])\n  \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc undefined undefined pc\n         []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n     pc < length ins;\n     ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P ins (stack_xlift (length stk'') xt) t h\n                       (stk @ stk'', loc, pc, xcp) ta h'\n                       (stk' @ stk'', loc', pc', xcp')", "ultimately"], ["proof (chain)\npicking this:\n  ci_app ci (ins ! pc) P h (stk @ stk'') loc undefined undefined pc []\n  (ta, xcp', h', [(stk' @ stk'', loc', undefined, undefined, pc')])\n  \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc undefined undefined pc\n         []", "show ?thesis"], ["proof (prove)\nusing this:\n  ci_app ci (ins ! pc) P h (stk @ stk'') loc undefined undefined pc []\n  (ta, xcp', h', [(stk' @ stk'', loc', undefined, undefined, pc')])\n  \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc undefined undefined pc\n         []\n\ngoal (1 subgoal):\n 1. exec_meth ci P ins (stack_xlift (length stk'') xt) t h\n     (stk @ stk'', loc, pc, xcp) ta h' (stk' @ stk'', loc', pc', xcp')", "using exec_instr"], ["proof (prove)\nusing this:\n  ci_app ci (ins ! pc) P h (stk @ stk'') loc undefined undefined pc []\n  (ta, xcp', h', [(stk' @ stk'', loc', undefined, undefined, pc')])\n  \\<in> exec_instr (ins ! pc) P t h (stk @ stk'') loc undefined undefined pc\n         []\n  xcp = None\n  (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n  \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc []\n  pc < length ins\n  ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\n\ngoal (1 subgoal):\n 1. exec_meth ci P ins (stack_xlift (length stk'') xt) t h\n     (stk @ stk'', loc, pc, xcp) ta h' (stk' @ stk'', loc', pc', xcp')", "by(auto intro: exec_meth.exec_instr)"], ["proof (state)\nthis:\n  exec_meth ci P ins (stack_xlift (length stk'') xt) t h\n   (stk @ stk'', loc, pc, xcp) ta h' (stk' @ stk'', loc', pc', xcp')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exec_meth_append_xt [intro]:\n  \"exec_meth ci P ins xt t h s ta h' s'\n  \\<Longrightarrow> exec_meth ci P (ins @ ins') (xt @ xt') t h s ta h' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci P ins xt t h s ta h' s' \\<Longrightarrow>\n    exec_meth ci P (ins @ ins') (xt @ xt') t h s ta h' s'", "apply(erule exec_meth.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>taa xcp h'a stk' loc' pc' pc ha stk loc.\n       \\<lbrakk>h = ha; s = (stk, loc, pc, None); ta = taa; h' = h'a;\n        s' = (stk', loc', pc', xcp);\n        (taa, xcp, h'a, [(stk', loc', undefined, undefined, pc')])\n        \\<in> exec_instr (ins ! pc) P t ha stk loc undefined undefined pc\n               [];\n        pc < length ins;\n        ci_app ci (ins ! pc) P ha stk loc undefined undefined pc []\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P (ins @ ins') (xt @ xt') t h s ta h'\n                          s'\n 2. \\<And>ha xcp pc pc' d stk loc.\n       \\<lbrakk>h = ha; s = (stk, loc, pc, \\<lfloor>xcp\\<rfloor>);\n        ta = \\<lbrace>\\<rbrace>; h' = ha;\n        s' = (Addr xcp # drop (length stk - d) stk, loc, pc', None);\n        match_ex_table P (cname_of ha xcp) pc xt =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P (ins @ ins') (xt @ xt') t h s ta h'\n                          s'", "apply(auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa ab ac ad b xcp stk' loc' pc' pc stk loc.\n       \\<lbrakk>s = (stk, loc, pc, None); ta = (a, aa, ab, ac, ad, b);\n        s' = (stk', loc', pc', xcp);\n        ((a, aa, ab, ac, ad, b), xcp, h',\n         [(stk', loc', undefined, undefined, pc')])\n        \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n        pc < length ins;\n        ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P (ins @ ins') (xt @ xt') t h\n                          (stk, loc, pc, None) (a, aa, ab, ac, ad, b) h'\n                          (stk', loc', pc', xcp)\n 2. \\<And>xcp pc pc' d stk loc.\n       \\<lbrakk>s = (stk, loc, pc, \\<lfloor>xcp\\<rfloor>);\n        ta = \\<lbrace>\\<rbrace>; h' = h;\n        s' = (Addr xcp # drop (length stk - d) stk, loc, pc', None);\n        match_ex_table P (cname_of h xcp) pc xt =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P (ins @ ins') (xt @ xt') t h\n                          (stk, loc, pc, \\<lfloor>xcp\\<rfloor>)\n                          \\<lbrace>\\<rbrace> h\n                          (Addr xcp # drop (length stk - d) stk, loc, pc',\n                           None)", "apply(rule exec_instr)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a aa ab ac ad b xcp stk' loc' pc' pc stk loc.\n       \\<lbrakk>s = (stk, loc, pc, None); ta = (a, aa, ab, ac, ad, b);\n        s' = (stk', loc', pc', xcp);\n        ((a, aa, ab, ac, ad, b), xcp, h',\n         [(stk', loc', undefined, undefined, pc')])\n        \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n        pc < length ins;\n        ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n       \\<Longrightarrow> ((a, aa, ab, ac, ad, b), xcp, h',\n                          [(stk', loc', undefined, undefined, pc')])\n                         \\<in> exec_instr ((ins @ ins') ! pc) P t h stk loc\n                                undefined undefined pc []\n 2. \\<And>a aa ab ac ad b xcp stk' loc' pc' pc stk loc.\n       \\<lbrakk>s = (stk, loc, pc, None); ta = (a, aa, ab, ac, ad, b);\n        s' = (stk', loc', pc', xcp);\n        ((a, aa, ab, ac, ad, b), xcp, h',\n         [(stk', loc', undefined, undefined, pc')])\n        \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n        pc < length ins;\n        ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n       \\<Longrightarrow> pc < length (ins @ ins')\n 3. \\<And>a aa ab ac ad b xcp stk' loc' pc' pc stk loc.\n       \\<lbrakk>s = (stk, loc, pc, None); ta = (a, aa, ab, ac, ad, b);\n        s' = (stk', loc', pc', xcp);\n        ((a, aa, ab, ac, ad, b), xcp, h',\n         [(stk', loc', undefined, undefined, pc')])\n        \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n        pc < length ins;\n        ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n       \\<Longrightarrow> ci_app ci ((ins @ ins') ! pc) P h stk loc undefined\n                          undefined pc []\n 4. \\<And>xcp pc pc' d stk loc.\n       \\<lbrakk>s = (stk, loc, pc, \\<lfloor>xcp\\<rfloor>);\n        ta = \\<lbrace>\\<rbrace>; h' = h;\n        s' = (Addr xcp # drop (length stk - d) stk, loc, pc', None);\n        match_ex_table P (cname_of h xcp) pc xt =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P (ins @ ins') (xt @ xt') t h\n                          (stk, loc, pc, \\<lfloor>xcp\\<rfloor>)\n                          \\<lbrace>\\<rbrace> h\n                          (Addr xcp # drop (length stk - d) stk, loc, pc',\n                           None)", "apply(clarsimp simp add: nth_append)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a aa ab ac ad b xcp stk' loc' pc' pc stk loc.\n       \\<lbrakk>s = (stk, loc, pc, None); ta = (a, aa, ab, ac, ad, b);\n        s' = (stk', loc', pc', xcp);\n        ((a, aa, ab, ac, ad, b), xcp, h',\n         [(stk', loc', undefined, undefined, pc')])\n        \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n        pc < length ins;\n        ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n       \\<Longrightarrow> pc < length (ins @ ins')\n 2. \\<And>a aa ab ac ad b xcp stk' loc' pc' pc stk loc.\n       \\<lbrakk>s = (stk, loc, pc, None); ta = (a, aa, ab, ac, ad, b);\n        s' = (stk', loc', pc', xcp);\n        ((a, aa, ab, ac, ad, b), xcp, h',\n         [(stk', loc', undefined, undefined, pc')])\n        \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n        pc < length ins;\n        ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n       \\<Longrightarrow> ci_app ci ((ins @ ins') ! pc) P h stk loc undefined\n                          undefined pc []\n 3. \\<And>xcp pc pc' d stk loc.\n       \\<lbrakk>s = (stk, loc, pc, \\<lfloor>xcp\\<rfloor>);\n        ta = \\<lbrace>\\<rbrace>; h' = h;\n        s' = (Addr xcp # drop (length stk - d) stk, loc, pc', None);\n        match_ex_table P (cname_of h xcp) pc xt =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P (ins @ ins') (xt @ xt') t h\n                          (stk, loc, pc, \\<lfloor>xcp\\<rfloor>)\n                          \\<lbrace>\\<rbrace> h\n                          (Addr xcp # drop (length stk - d) stk, loc, pc',\n                           None)", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa ab ac ad b xcp stk' loc' pc' pc stk loc.\n       \\<lbrakk>s = (stk, loc, pc, None); ta = (a, aa, ab, ac, ad, b);\n        s' = (stk', loc', pc', xcp);\n        ((a, aa, ab, ac, ad, b), xcp, h',\n         [(stk', loc', undefined, undefined, pc')])\n        \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n        pc < length ins;\n        ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n       \\<Longrightarrow> ci_app ci ((ins @ ins') ! pc) P h stk loc undefined\n                          undefined pc []\n 2. \\<And>xcp pc pc' d stk loc.\n       \\<lbrakk>s = (stk, loc, pc, \\<lfloor>xcp\\<rfloor>);\n        ta = \\<lbrace>\\<rbrace>; h' = h;\n        s' = (Addr xcp # drop (length stk - d) stk, loc, pc', None);\n        match_ex_table P (cname_of h xcp) pc xt =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P (ins @ ins') (xt @ xt') t h\n                          (stk, loc, pc, \\<lfloor>xcp\\<rfloor>)\n                          \\<lbrace>\\<rbrace> h\n                          (Addr xcp # drop (length stk - d) stk, loc, pc',\n                           None)", "apply(simp add: nth_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xcp pc pc' d stk loc.\n       \\<lbrakk>s = (stk, loc, pc, \\<lfloor>xcp\\<rfloor>);\n        ta = \\<lbrace>\\<rbrace>; h' = h;\n        s' = (Addr xcp # drop (length stk - d) stk, loc, pc', None);\n        match_ex_table P (cname_of h xcp) pc xt =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P (ins @ ins') (xt @ xt') t h\n                          (stk, loc, pc, \\<lfloor>xcp\\<rfloor>)\n                          \\<lbrace>\\<rbrace> h\n                          (Addr xcp # drop (length stk - d) stk, loc, pc',\n                           None)", "apply(rule exec_catch)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xcp pc pc' d stk loc.\n       \\<lbrakk>s = (stk, loc, pc, \\<lfloor>xcp\\<rfloor>);\n        ta = \\<lbrace>\\<rbrace>; h' = h;\n        s' = (Addr xcp # drop (length stk - d) stk, loc, pc', None);\n        match_ex_table P (cname_of h xcp) pc xt =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> match_ex_table P (cname_of h xcp) pc (xt @ xt') =\n                         \\<lfloor>(pc', d)\\<rfloor>\n 2. \\<And>xcp pc pc' d stk loc.\n       \\<lbrakk>s = (stk, loc, pc, \\<lfloor>xcp\\<rfloor>);\n        ta = \\<lbrace>\\<rbrace>; h' = h;\n        s' = (Addr xcp # drop (length stk - d) stk, loc, pc', None);\n        match_ex_table P (cname_of h xcp) pc xt =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> d \\<le> length stk", "by(simp)"], ["", "lemma exec_meth_append [intro]:\n  \"exec_meth ci P ins xt t h s ta h' s' \\<Longrightarrow> exec_meth ci P (ins @ ins') xt t h s ta h' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci P ins xt t h s ta h' s' \\<Longrightarrow>\n    exec_meth ci P (ins @ ins') xt t h s ta h' s'", "by(rule exec_meth_append_xt[where xt'=\"[]\", simplified])"], ["", "lemma append_exec_meth_xt:\n  assumes exec: \"exec_meth ci P ins xt t h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  and jump: \"jump_ok ins 0 n\"\n  and pcs: \"pcs xt' \\<subseteq> {0..<length ins'}\"\n  shows \"exec_meth ci P (ins' @ ins) (xt' @ shift (length ins') xt) t h (stk, loc, (length ins' + pc), xcp) ta h' (stk', loc', (length ins' + pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci P (ins' @ ins) (xt' @ shift (length ins') xt) t h\n     (stk, loc, length ins' + pc, xcp) ta h'\n     (stk', loc', length ins' + pc', xcp')", "using exec"], ["proof (prove)\nusing this:\n  exec_meth ci P ins xt t h (stk, loc, pc, xcp) ta h'\n   (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci P (ins' @ ins) (xt' @ shift (length ins') xt) t h\n     (stk, loc, length ins' + pc, xcp) ta h'\n     (stk', loc', length ins' + pc', xcp')", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n     pc < length ins;\n     ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P (ins' @ ins)\n                       (xt' @ shift (length ins') xt) t h\n                       (stk, loc, length ins' + pc, xcp) ta h'\n                       (stk', loc', length ins' + pc', xcp')\n 2. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table P (cname_of h xcpa) pc xt =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P (ins' @ ins)\n                          (xt' @ shift (length ins') xt) t h\n                          (stk, loc, length ins' + pc, xcp) ta h'\n                          (stk', loc', length ins' + pc', xcp')", "case (exec_catch xcp d)"], ["proof (state)\nthis:\n  xcp = \\<lfloor>xcp\\<rfloor>\n  ta = \\<lbrace>\\<rbrace>\n  h' = h\n  stk' = Addr xcp # drop (length stk - d) stk\n  loc' = loc\n  xcp' = None\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d)\\<rfloor>\n  d \\<le> length stk\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n     pc < length ins;\n     ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P (ins' @ ins)\n                       (xt' @ shift (length ins') xt) t h\n                       (stk, loc, length ins' + pc, xcp) ta h'\n                       (stk', loc', length ins' + pc', xcp')\n 2. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table P (cname_of h xcpa) pc xt =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P (ins' @ ins)\n                          (xt' @ shift (length ins') xt) t h\n                          (stk, loc, length ins' + pc, xcp) ta h'\n                          (stk', loc', length ins' + pc', xcp')", "from \\<open>match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d)\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d)\\<rfloor>", "have \"match_ex_table P (cname_of h xcp) (length ins' + pc) (shift (length ins') xt) = \\<lfloor>(length ins' + pc', d)\\<rfloor>\""], ["proof (prove)\nusing this:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d)\\<rfloor>\n\ngoal (1 subgoal):\n 1. match_ex_table P (cname_of h xcp) (length ins' + pc)\n     (shift (length ins') xt) =\n    \\<lfloor>(length ins' + pc', d)\\<rfloor>", "by(simp add: match_ex_table_shift)"], ["proof (state)\nthis:\n  match_ex_table P (cname_of h xcp) (length ins' + pc)\n   (shift (length ins') xt) =\n  \\<lfloor>(length ins' + pc', d)\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n     pc < length ins;\n     ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P (ins' @ ins)\n                       (xt' @ shift (length ins') xt) t h\n                       (stk, loc, length ins' + pc, xcp) ta h'\n                       (stk', loc', length ins' + pc', xcp')\n 2. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table P (cname_of h xcpa) pc xt =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P (ins' @ ins)\n                          (xt' @ shift (length ins') xt) t h\n                          (stk, loc, length ins' + pc, xcp) ta h'\n                          (stk', loc', length ins' + pc', xcp')", "moreover"], ["proof (state)\nthis:\n  match_ex_table P (cname_of h xcp) (length ins' + pc)\n   (shift (length ins') xt) =\n  \\<lfloor>(length ins' + pc', d)\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n     pc < length ins;\n     ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P (ins' @ ins)\n                       (xt' @ shift (length ins') xt) t h\n                       (stk, loc, length ins' + pc, xcp) ta h'\n                       (stk', loc', length ins' + pc', xcp')\n 2. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table P (cname_of h xcpa) pc xt =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P (ins' @ ins)\n                          (xt' @ shift (length ins') xt) t h\n                          (stk, loc, length ins' + pc, xcp) ta h'\n                          (stk', loc', length ins' + pc', xcp')", "from pcs"], ["proof (chain)\npicking this:\n  pcs xt' \\<subseteq> {0..<length ins'}", "have \"length ins' + pc \\<notin> pcs xt'\""], ["proof (prove)\nusing this:\n  pcs xt' \\<subseteq> {0..<length ins'}\n\ngoal (1 subgoal):\n 1. length ins' + pc \\<notin> pcs xt'", "by(auto)"], ["proof (state)\nthis:\n  length ins' + pc \\<notin> pcs xt'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n     pc < length ins;\n     ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P (ins' @ ins)\n                       (xt' @ shift (length ins') xt) t h\n                       (stk, loc, length ins' + pc, xcp) ta h'\n                       (stk', loc', length ins' + pc', xcp')\n 2. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table P (cname_of h xcpa) pc xt =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P (ins' @ ins)\n                          (xt' @ shift (length ins') xt) t h\n                          (stk, loc, length ins' + pc, xcp) ta h'\n                          (stk', loc', length ins' + pc', xcp')", "ultimately"], ["proof (chain)\npicking this:\n  match_ex_table P (cname_of h xcp) (length ins' + pc)\n   (shift (length ins') xt) =\n  \\<lfloor>(length ins' + pc', d)\\<rfloor>\n  length ins' + pc \\<notin> pcs xt'", "have \"match_ex_table P (cname_of h xcp) (length ins' + pc) (xt' @ shift (length ins') xt) = \\<lfloor>(length ins' + pc', d)\\<rfloor>\""], ["proof (prove)\nusing this:\n  match_ex_table P (cname_of h xcp) (length ins' + pc)\n   (shift (length ins') xt) =\n  \\<lfloor>(length ins' + pc', d)\\<rfloor>\n  length ins' + pc \\<notin> pcs xt'\n\ngoal (1 subgoal):\n 1. match_ex_table P (cname_of h xcp) (length ins' + pc)\n     (xt' @ shift (length ins') xt) =\n    \\<lfloor>(length ins' + pc', d)\\<rfloor>", "by(simp add: match_ex_table_append_not_pcs)"], ["proof (state)\nthis:\n  match_ex_table P (cname_of h xcp) (length ins' + pc)\n   (xt' @ shift (length ins') xt) =\n  \\<lfloor>(length ins' + pc', d)\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n     pc < length ins;\n     ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P (ins' @ ins)\n                       (xt' @ shift (length ins') xt) t h\n                       (stk, loc, length ins' + pc, xcp) ta h'\n                       (stk', loc', length ins' + pc', xcp')\n 2. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table P (cname_of h xcpa) pc xt =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P (ins' @ ins)\n                          (xt' @ shift (length ins') xt) t h\n                          (stk, loc, length ins' + pc, xcp) ta h'\n                          (stk', loc', length ins' + pc', xcp')", "with exec_catch"], ["proof (chain)\npicking this:\n  xcp = \\<lfloor>xcp\\<rfloor>\n  ta = \\<lbrace>\\<rbrace>\n  h' = h\n  stk' = Addr xcp # drop (length stk - d) stk\n  loc' = loc\n  xcp' = None\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d)\\<rfloor>\n  d \\<le> length stk\n  match_ex_table P (cname_of h xcp) (length ins' + pc)\n   (xt' @ shift (length ins') xt) =\n  \\<lfloor>(length ins' + pc', d)\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  xcp = \\<lfloor>xcp\\<rfloor>\n  ta = \\<lbrace>\\<rbrace>\n  h' = h\n  stk' = Addr xcp # drop (length stk - d) stk\n  loc' = loc\n  xcp' = None\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d)\\<rfloor>\n  d \\<le> length stk\n  match_ex_table P (cname_of h xcp) (length ins' + pc)\n   (xt' @ shift (length ins') xt) =\n  \\<lfloor>(length ins' + pc', d)\\<rfloor>\n\ngoal (1 subgoal):\n 1. exec_meth ci P (ins' @ ins) (xt' @ shift (length ins') xt) t h\n     (stk, loc, length ins' + pc, xcp) ta h'\n     (stk', loc', length ins' + pc', xcp')", "by(auto dest: exec_meth.exec_catch)"], ["proof (state)\nthis:\n  exec_meth ci P (ins' @ ins) (xt' @ shift (length ins') xt) t h\n   (stk, loc, length ins' + pc, xcp) ta h'\n   (stk', loc', length ins' + pc', xcp')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n     pc < length ins;\n     ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P (ins' @ ins)\n                       (xt' @ shift (length ins') xt) t h\n                       (stk, loc, length ins' + pc, xcp) ta h'\n                       (stk', loc', length ins' + pc', xcp')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n     pc < length ins;\n     ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P (ins' @ ins)\n                       (xt' @ shift (length ins') xt) t h\n                       (stk, loc, length ins' + pc, xcp) ta h'\n                       (stk', loc', length ins' + pc', xcp')", "case exec_instr"], ["proof (state)\nthis:\n  xcp = None\n  (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n  \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc []\n  pc < length ins\n  ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n     pc < length ins;\n     ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P (ins' @ ins)\n                       (xt' @ shift (length ins') xt) t h\n                       (stk, loc, length ins' + pc, xcp) ta h'\n                       (stk', loc', length ins' + pc', xcp')", "note exec = \\<open>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')]) \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc []\\<close>"], ["proof (state)\nthis:\n  (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n  \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n     pc < length ins;\n     ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P (ins' @ ins)\n                       (xt' @ shift (length ins') xt) t h\n                       (stk, loc, length ins' + pc, xcp) ta h'\n                       (stk', loc', length ins' + pc', xcp')", "hence \"(ta, xcp', h', [(stk', loc', undefined, undefined, length ins' + pc')]) \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined (length ins' + pc) []\""], ["proof (prove)\nusing this:\n  (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n  \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc []\n\ngoal (1 subgoal):\n 1. (ta, xcp', h', [(stk', loc', undefined, undefined, length ins' + pc')])\n    \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n           (length ins' + pc) []", "proof(cases \"ins ! pc\")"], ["proof (state)\ngoal (24 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 4. \\<And>x4.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 5. \\<And>x5.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 6. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n                    pc [];\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         length ins' + pc')])\n                      \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                             undefined (length ins' + pc) []\n 7. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n                    pc [];\n     ins ! pc = AStore\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         length ins' + pc')])\n                      \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                             undefined (length ins' + pc) []\n 8. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n                    pc [];\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         length ins' + pc')])\n                      \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                             undefined (length ins' + pc) []\n 9. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 10. \\<And>x101 x102.\n        \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                 \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                        undefined pc [];\n         ins ! pc = Putfield x101 x102\\<rbrakk>\n        \\<Longrightarrow> (ta, xcp', h',\n                           [(stk', loc', undefined, undefined,\n                             length ins' + pc')])\n                          \\<in> exec_instr (ins ! pc) P t h stk loc\n                                 undefined undefined (length ins' + pc) []\nA total of 24 subgoals...", "case (Goto i)"], ["proof (state)\nthis:\n  ins ! pc = Goto i\n\ngoal (24 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 4. \\<And>x4.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 5. \\<And>x5.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 6. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n                    pc [];\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         length ins' + pc')])\n                      \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                             undefined (length ins' + pc) []\n 7. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n                    pc [];\n     ins ! pc = AStore\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         length ins' + pc')])\n                      \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                             undefined (length ins' + pc) []\n 8. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n                    pc [];\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         length ins' + pc')])\n                      \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                             undefined (length ins' + pc) []\n 9. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 10. \\<And>x101 x102.\n        \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                 \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                        undefined pc [];\n         ins ! pc = Putfield x101 x102\\<rbrakk>\n        \\<Longrightarrow> (ta, xcp', h',\n                           [(stk', loc', undefined, undefined,\n                             length ins' + pc')])\n                          \\<in> exec_instr (ins ! pc) P t h stk loc\n                                 undefined undefined (length ins' + pc) []\nA total of 24 subgoals...", "with jump \\<open>pc < length ins\\<close>"], ["proof (chain)\npicking this:\n  jump_ok ins 0 n\n  pc < length ins\n  ins ! pc = Goto i", "have \"- int pc  \\<le> i\" \"i < int (length ins - pc + n)\""], ["proof (prove)\nusing this:\n  jump_ok ins 0 n\n  pc < length ins\n  ins ! pc = Goto i\n\ngoal (1 subgoal):\n 1. - int pc \\<le> i &&& i < int (length ins - pc + n)", "by(auto dest: jump_ok_GotoD)"], ["proof (state)\nthis:\n  - int pc \\<le> i\n  i < int (length ins - pc + n)\n\ngoal (24 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 4. \\<And>x4.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 5. \\<And>x5.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 6. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n                    pc [];\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         length ins' + pc')])\n                      \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                             undefined (length ins' + pc) []\n 7. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n                    pc [];\n     ins ! pc = AStore\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         length ins' + pc')])\n                      \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                             undefined (length ins' + pc) []\n 8. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n                    pc [];\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         length ins' + pc')])\n                      \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                             undefined (length ins' + pc) []\n 9. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 10. \\<And>x101 x102.\n        \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                 \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                        undefined pc [];\n         ins ! pc = Putfield x101 x102\\<rbrakk>\n        \\<Longrightarrow> (ta, xcp', h',\n                           [(stk', loc', undefined, undefined,\n                             length ins' + pc')])\n                          \\<in> exec_instr (ins ! pc) P t h stk loc\n                                 undefined undefined (length ins' + pc) []\nA total of 24 subgoals...", "with exec Goto"], ["proof (chain)\npicking this:\n  (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n  \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc []\n  ins ! pc = Goto i\n  - int pc \\<le> i\n  i < int (length ins - pc + n)", "show ?thesis"], ["proof (prove)\nusing this:\n  (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n  \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc []\n  ins ! pc = Goto i\n  - int pc \\<le> i\n  i < int (length ins - pc + n)\n\ngoal (1 subgoal):\n 1. (ta, xcp', h', [(stk', loc', undefined, undefined, length ins' + pc')])\n    \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n           (length ins' + pc) []", "by(auto)"], ["proof (state)\nthis:\n  (ta, xcp', h', [(stk', loc', undefined, undefined, length ins' + pc')])\n  \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n         (length ins' + pc) []\n\ngoal (23 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 4. \\<And>x4.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 5. \\<And>x5.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 6. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n                    pc [];\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         length ins' + pc')])\n                      \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                             undefined (length ins' + pc) []\n 7. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n                    pc [];\n     ins ! pc = AStore\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         length ins' + pc')])\n                      \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                             undefined (length ins' + pc) []\n 8. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n                    pc [];\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         length ins' + pc')])\n                      \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                             undefined (length ins' + pc) []\n 9. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 10. \\<And>x101 x102.\n        \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                 \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                        undefined pc [];\n         ins ! pc = Putfield x101 x102\\<rbrakk>\n        \\<Longrightarrow> (ta, xcp', h',\n                           [(stk', loc', undefined, undefined,\n                             length ins' + pc')])\n                          \\<in> exec_instr (ins ! pc) P t h stk loc\n                                 undefined undefined (length ins' + pc) []\nA total of 23 subgoals...", "next"], ["proof (state)\ngoal (23 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 4. \\<And>x4.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 5. \\<And>x5.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 6. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n                    pc [];\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         length ins' + pc')])\n                      \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                             undefined (length ins' + pc) []\n 7. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n                    pc [];\n     ins ! pc = AStore\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         length ins' + pc')])\n                      \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                             undefined (length ins' + pc) []\n 8. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n                    pc [];\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         length ins' + pc')])\n                      \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                             undefined (length ins' + pc) []\n 9. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 10. \\<And>x101 x102.\n        \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                 \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                        undefined pc [];\n         ins ! pc = Putfield x101 x102\\<rbrakk>\n        \\<Longrightarrow> (ta, xcp', h',\n                           [(stk', loc', undefined, undefined,\n                             length ins' + pc')])\n                          \\<in> exec_instr (ins ! pc) P t h stk loc\n                                 undefined undefined (length ins' + pc) []\nA total of 23 subgoals...", "case (IfFalse i)"], ["proof (state)\nthis:\n  ins ! pc = IfFalse i\n\ngoal (23 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 4. \\<And>x4.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 5. \\<And>x5.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 6. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n                    pc [];\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         length ins' + pc')])\n                      \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                             undefined (length ins' + pc) []\n 7. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n                    pc [];\n     ins ! pc = AStore\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         length ins' + pc')])\n                      \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                             undefined (length ins' + pc) []\n 8. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n                    pc [];\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         length ins' + pc')])\n                      \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                             undefined (length ins' + pc) []\n 9. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 10. \\<And>x101 x102.\n        \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                 \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                        undefined pc [];\n         ins ! pc = Putfield x101 x102\\<rbrakk>\n        \\<Longrightarrow> (ta, xcp', h',\n                           [(stk', loc', undefined, undefined,\n                             length ins' + pc')])\n                          \\<in> exec_instr (ins ! pc) P t h stk loc\n                                 undefined undefined (length ins' + pc) []\nA total of 23 subgoals...", "with jump \\<open>pc < length ins\\<close>"], ["proof (chain)\npicking this:\n  jump_ok ins 0 n\n  pc < length ins\n  ins ! pc = IfFalse i", "have \"- int pc  \\<le> i\" \"i < int (length ins - pc + n)\""], ["proof (prove)\nusing this:\n  jump_ok ins 0 n\n  pc < length ins\n  ins ! pc = IfFalse i\n\ngoal (1 subgoal):\n 1. - int pc \\<le> i &&& i < int (length ins - pc + n)", "by(auto dest: jump_ok_IfFalseD)"], ["proof (state)\nthis:\n  - int pc \\<le> i\n  i < int (length ins - pc + n)\n\ngoal (23 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 4. \\<And>x4.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 5. \\<And>x5.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 6. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n                    pc [];\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         length ins' + pc')])\n                      \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                             undefined (length ins' + pc) []\n 7. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n                    pc [];\n     ins ! pc = AStore\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         length ins' + pc')])\n                      \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                             undefined (length ins' + pc) []\n 8. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n                    pc [];\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         length ins' + pc')])\n                      \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                             undefined (length ins' + pc) []\n 9. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 10. \\<And>x101 x102.\n        \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                 \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                        undefined pc [];\n         ins ! pc = Putfield x101 x102\\<rbrakk>\n        \\<Longrightarrow> (ta, xcp', h',\n                           [(stk', loc', undefined, undefined,\n                             length ins' + pc')])\n                          \\<in> exec_instr (ins ! pc) P t h stk loc\n                                 undefined undefined (length ins' + pc) []\nA total of 23 subgoals...", "with exec IfFalse"], ["proof (chain)\npicking this:\n  (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n  \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc []\n  ins ! pc = IfFalse i\n  - int pc \\<le> i\n  i < int (length ins - pc + n)", "show ?thesis"], ["proof (prove)\nusing this:\n  (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n  \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc []\n  ins ! pc = IfFalse i\n  - int pc \\<le> i\n  i < int (length ins - pc + n)\n\ngoal (1 subgoal):\n 1. (ta, xcp', h', [(stk', loc', undefined, undefined, length ins' + pc')])\n    \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n           (length ins' + pc) []", "by(auto)"], ["proof (state)\nthis:\n  (ta, xcp', h', [(stk', loc', undefined, undefined, length ins' + pc')])\n  \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n         (length ins' + pc) []\n\ngoal (22 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 4. \\<And>x4.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 5. \\<And>x5.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 6. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n                    pc [];\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         length ins' + pc')])\n                      \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                             undefined (length ins' + pc) []\n 7. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n                    pc [];\n     ins ! pc = AStore\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         length ins' + pc')])\n                      \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                             undefined (length ins' + pc) []\n 8. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n                    pc [];\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         length ins' + pc')])\n                      \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                             undefined (length ins' + pc) []\n 9. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 10. \\<And>x101 x102.\n        \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                 \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                        undefined pc [];\n         ins ! pc = Putfield x101 x102\\<rbrakk>\n        \\<Longrightarrow> (ta, xcp', h',\n                           [(stk', loc', undefined, undefined,\n                             length ins' + pc')])\n                          \\<in> exec_instr (ins ! pc) P t h stk loc\n                                 undefined undefined (length ins' + pc) []\nA total of 22 subgoals...", "next"], ["proof (state)\ngoal (22 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 4. \\<And>x4.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 5. \\<And>x5.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 6. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n                    pc [];\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         length ins' + pc')])\n                      \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                             undefined (length ins' + pc) []\n 7. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n                    pc [];\n     ins ! pc = AStore\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         length ins' + pc')])\n                      \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                             undefined (length ins' + pc) []\n 8. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n                    pc [];\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         length ins' + pc')])\n                      \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                             undefined (length ins' + pc) []\n 9. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 10. \\<And>x101 x102.\n        \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                 \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                        undefined pc [];\n         ins ! pc = Putfield x101 x102\\<rbrakk>\n        \\<Longrightarrow> (ta, xcp', h',\n                           [(stk', loc', undefined, undefined,\n                             length ins' + pc')])\n                          \\<in> exec_instr (ins ! pc) P t h stk loc\n                                 undefined undefined (length ins' + pc) []\nA total of 22 subgoals...", "case (Invoke M n)"], ["proof (state)\nthis:\n  ins ! pc = Invoke M n\n\ngoal (22 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 4. \\<And>x4.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 5. \\<And>x5.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 6. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n                    pc [];\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         length ins' + pc')])\n                      \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                             undefined (length ins' + pc) []\n 7. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n                    pc [];\n     ins ! pc = AStore\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         length ins' + pc')])\n                      \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                             undefined (length ins' + pc) []\n 8. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n                    pc [];\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         length ins' + pc')])\n                      \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                             undefined (length ins' + pc) []\n 9. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 10. \\<And>x101 x102.\n        \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                 \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                        undefined pc [];\n         ins ! pc = Putfield x101 x102\\<rbrakk>\n        \\<Longrightarrow> (ta, xcp', h',\n                           [(stk', loc', undefined, undefined,\n                             length ins' + pc')])\n                          \\<in> exec_instr (ins ! pc) P t h stk loc\n                                 undefined undefined (length ins' + pc) []\nA total of 22 subgoals...", "with exec"], ["proof (chain)\npicking this:\n  (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n  \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc []\n  ins ! pc = Invoke M n", "show ?thesis"], ["proof (prove)\nusing this:\n  (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n  \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc []\n  ins ! pc = Invoke M n\n\ngoal (1 subgoal):\n 1. (ta, xcp', h', [(stk', loc', undefined, undefined, length ins' + pc')])\n    \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n           (length ins' + pc) []", "by(auto split: if_split_asm extCallRet.splits split del: if_split simp add: split_beta nth_append min_def extRet2JVM_def)"], ["proof (state)\nthis:\n  (ta, xcp', h', [(stk', loc', undefined, undefined, length ins' + pc')])\n  \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n         (length ins' + pc) []\n\ngoal (21 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 4. \\<And>x4.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 5. \\<And>x5.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 6. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n                    pc [];\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         length ins' + pc')])\n                      \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                             undefined (length ins' + pc) []\n 7. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n                    pc [];\n     ins ! pc = AStore\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         length ins' + pc')])\n                      \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                             undefined (length ins' + pc) []\n 8. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n                    pc [];\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         length ins' + pc')])\n                      \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                             undefined (length ins' + pc) []\n 9. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                       undefined pc [];\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            length ins' + pc')])\n                         \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                                undefined (length ins' + pc) []\n 10. \\<And>x101 x102.\n        \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                 \\<in> exec_instr (ins ! pc) P t h stk loc undefined\n                        undefined pc [];\n         ins ! pc = Putfield x101 x102\\<rbrakk>\n        \\<Longrightarrow> (ta, xcp', h',\n                           [(stk', loc', undefined, undefined,\n                             length ins' + pc')])\n                          \\<in> exec_instr (ins ! pc) P t h stk loc\n                                 undefined undefined (length ins' + pc) []\nA total of 21 subgoals...", "qed(auto simp add: split_beta split: if_split_asm sum.split_asm)"], ["proof (state)\nthis:\n  (ta, xcp', h', [(stk', loc', undefined, undefined, length ins' + pc')])\n  \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n         (length ins' + pc) []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n     pc < length ins;\n     ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P (ins' @ ins)\n                       (xt' @ shift (length ins') xt) t h\n                       (stk, loc, length ins' + pc, xcp) ta h'\n                       (stk', loc', length ins' + pc', xcp')", "moreover"], ["proof (state)\nthis:\n  (ta, xcp', h', [(stk', loc', undefined, undefined, length ins' + pc')])\n  \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n         (length ins' + pc) []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n     pc < length ins;\n     ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P (ins' @ ins)\n                       (xt' @ shift (length ins') xt) t h\n                       (stk, loc, length ins' + pc, xcp) ta h'\n                       (stk', loc', length ins' + pc', xcp')", "from \\<open>ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<close>"], ["proof (chain)\npicking this:\n  ci_app ci (ins ! pc) P h stk loc undefined undefined pc []", "have \"ci_app ci (ins ! pc) P h stk loc undefined undefined (length ins' + pc) []\""], ["proof (prove)\nusing this:\n  ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\n\ngoal (1 subgoal):\n 1. ci_app ci (ins ! pc) P h stk loc undefined undefined (length ins' + pc)\n     []", "by(rule wf_ciD3'_ci_app) simp"], ["proof (state)\nthis:\n  ci_app ci (ins ! pc) P h stk loc undefined undefined (length ins' + pc) []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n     pc < length ins;\n     ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P (ins' @ ins)\n                       (xt' @ shift (length ins') xt) t h\n                       (stk, loc, length ins' + pc, xcp) ta h'\n                       (stk', loc', length ins' + pc', xcp')", "ultimately"], ["proof (chain)\npicking this:\n  (ta, xcp', h', [(stk', loc', undefined, undefined, length ins' + pc')])\n  \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n         (length ins' + pc) []\n  ci_app ci (ins ! pc) P h stk loc undefined undefined (length ins' + pc) []", "have \"exec_meth ci P (ins' @ ins) (xt' @ shift (length ins') xt) t h (stk, loc, (length ins' + pc), None) ta h' (stk', loc', (length ins' + pc'), xcp')\""], ["proof (prove)\nusing this:\n  (ta, xcp', h', [(stk', loc', undefined, undefined, length ins' + pc')])\n  \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n         (length ins' + pc) []\n  ci_app ci (ins ! pc) P h stk loc undefined undefined (length ins' + pc) []\n\ngoal (1 subgoal):\n 1. exec_meth ci P (ins' @ ins) (xt' @ shift (length ins') xt) t h\n     (stk, loc, length ins' + pc, None) ta h'\n     (stk', loc', length ins' + pc', xcp')", "using \\<open>pc < length ins\\<close>"], ["proof (prove)\nusing this:\n  (ta, xcp', h', [(stk', loc', undefined, undefined, length ins' + pc')])\n  \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined\n         (length ins' + pc) []\n  ci_app ci (ins ! pc) P h stk loc undefined undefined (length ins' + pc) []\n  pc < length ins\n\ngoal (1 subgoal):\n 1. exec_meth ci P (ins' @ ins) (xt' @ shift (length ins') xt) t h\n     (stk, loc, length ins' + pc, None) ta h'\n     (stk', loc', length ins' + pc', xcp')", "by -(rule exec_meth.exec_instr, simp_all)"], ["proof (state)\nthis:\n  exec_meth ci P (ins' @ ins) (xt' @ shift (length ins') xt) t h\n   (stk, loc, length ins' + pc, None) ta h'\n   (stk', loc', length ins' + pc', xcp')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc [];\n     pc < length ins;\n     ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P (ins' @ ins)\n                       (xt' @ shift (length ins') xt) t h\n                       (stk, loc, length ins' + pc, xcp) ta h'\n                       (stk', loc', length ins' + pc', xcp')", "thus ?thesis"], ["proof (prove)\nusing this:\n  exec_meth ci P (ins' @ ins) (xt' @ shift (length ins') xt) t h\n   (stk, loc, length ins' + pc, None) ta h'\n   (stk', loc', length ins' + pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci P (ins' @ ins) (xt' @ shift (length ins') xt) t h\n     (stk, loc, length ins' + pc, xcp) ta h'\n     (stk', loc', length ins' + pc', xcp')", "using exec_instr"], ["proof (prove)\nusing this:\n  exec_meth ci P (ins' @ ins) (xt' @ shift (length ins') xt) t h\n   (stk, loc, length ins' + pc, None) ta h'\n   (stk', loc', length ins' + pc', xcp')\n  xcp = None\n  (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n  \\<in> exec_instr (ins ! pc) P t h stk loc undefined undefined pc []\n  pc < length ins\n  ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\n\ngoal (1 subgoal):\n 1. exec_meth ci P (ins' @ ins) (xt' @ shift (length ins') xt) t h\n     (stk, loc, length ins' + pc, xcp) ta h'\n     (stk', loc', length ins' + pc', xcp')", "by(auto)"], ["proof (state)\nthis:\n  exec_meth ci P (ins' @ ins) (xt' @ shift (length ins') xt) t h\n   (stk, loc, length ins' + pc, xcp) ta h'\n   (stk', loc', length ins' + pc', xcp')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma append_exec_meth:\n  assumes exec: \"exec_meth ci P ins xt t h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  and jump: \"jump_ok ins 0 n\"\n  shows \"exec_meth ci P (ins' @ ins) (shift (length ins') xt) t h (stk, loc, (length ins' + pc), xcp) ta h' (stk', loc', (length ins' + pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci P (ins' @ ins) (shift (length ins') xt) t h\n     (stk, loc, length ins' + pc, xcp) ta h'\n     (stk', loc', length ins' + pc', xcp')", "using assms"], ["proof (prove)\nusing this:\n  exec_meth ci P ins xt t h (stk, loc, pc, xcp) ta h'\n   (stk', loc', pc', xcp')\n  jump_ok ins 0 n\n\ngoal (1 subgoal):\n 1. exec_meth ci P (ins' @ ins) (shift (length ins') xt) t h\n     (stk, loc, length ins' + pc, xcp) ta h'\n     (stk', loc', length ins' + pc', xcp')", "by(rule append_exec_meth_xt [where xt'=\"[]\", simplified])"], ["", "lemma exec_meth_take_xt':\n  \"\\<lbrakk> exec_meth ci P (ins @ ins') (xt' @ xt) t h (stk, loc, pc, xcp) ta h' s';\n    pc < length ins; pc \\<notin> pcs xt \\<rbrakk>\n  \\<Longrightarrow> exec_meth ci P ins xt' t h (stk, loc, pc, xcp) ta h' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>exec_meth ci P (ins @ ins') (xt' @ xt) t h (stk, loc, pc, xcp)\n              ta h' s';\n     pc < length ins; pc \\<notin> pcs xt\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P ins xt' t h (stk, loc, pc, xcp) ta h'\n                       s'", "apply(erule exec_meth.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>taa xcpa h'a stk' loc' pc' pca ha stka loca.\n       \\<lbrakk>pc < length ins; pc \\<notin> pcs xt; h = ha;\n        (stk, loc, pc, xcp) = (stka, loca, pca, None); ta = taa; h' = h'a;\n        s' = (stk', loc', pc', xcpa);\n        (taa, xcpa, h'a, [(stk', loc', undefined, undefined, pc')])\n        \\<in> exec_instr ((ins @ ins') ! pca) P t ha stka loca undefined\n               undefined pca [];\n        pca < length (ins @ ins');\n        ci_app ci ((ins @ ins') ! pca) P ha stka loca undefined undefined\n         pca []\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P ins xt' t h (stk, loc, pc, xcp) ta\n                          h' s'\n 2. \\<And>ha xcpa pca pc' d stka loca.\n       \\<lbrakk>pc < length ins; pc \\<notin> pcs xt; h = ha;\n        (stk, loc, pc, xcp) = (stka, loca, pca, \\<lfloor>xcpa\\<rfloor>);\n        ta = \\<lbrace>\\<rbrace>; h' = ha;\n        s' = (Addr xcpa # drop (length stka - d) stka, loca, pc', None);\n        match_ex_table P (cname_of ha xcpa) pca (xt' @ xt) =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stka\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P ins xt' t h (stk, loc, pc, xcp) ta\n                          h' s'", "apply(auto intro: exec_meth.intros simp add: match_ex_table_append nth_append dest: match_ex_table_pcsD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma exec_meth_take_xt:\n  \"\\<lbrakk> exec_meth ci P (ins @ ins') (xt' @ shift (length ins) xt) t h (stk, loc, pc, xcp) ta h' s';\n    pc < length ins \\<rbrakk>\n  \\<Longrightarrow> exec_meth ci P ins xt' t h (stk, loc, pc, xcp) ta h' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>exec_meth ci P (ins @ ins') (xt' @ shift (length ins) xt) t h\n              (stk, loc, pc, xcp) ta h' s';\n     pc < length ins\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P ins xt' t h (stk, loc, pc, xcp) ta h'\n                       s'", "by(auto intro: exec_meth_take_xt')"], ["", "lemma exec_meth_take:\n  \"\\<lbrakk> exec_meth ci P (ins @ ins') xt t h (stk, loc, pc, xcp) ta h' s';\n    pc < length ins \\<rbrakk>\n  \\<Longrightarrow> exec_meth ci P ins xt t h (stk, loc, pc, xcp) ta h' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>exec_meth ci P (ins @ ins') xt t h (stk, loc, pc, xcp) ta h'\n              s';\n     pc < length ins\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P ins xt t h (stk, loc, pc, xcp) ta h' s'", "by(auto intro: exec_meth_take_xt[where xt = \"[]\"])"], ["", "lemma exec_meth_drop_xt:\n  assumes exec: \"exec_meth ci P (ins @ ins') (xt @ shift (length ins) xt') t h (stk, loc, (length ins + pc), xcp) ta h' (stk', loc', pc', xcp')\"\n  and xt: \"pcs xt \\<subseteq> {..<length ins}\"\n  and jump: \"jump_ok ins' 0 n\"\n  shows \"exec_meth ci P ins' xt' t h (stk, loc, pc, xcp) ta h' (stk', loc', (pc' - length ins), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci P ins' xt' t h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc' - length ins, xcp')", "using exec"], ["proof (prove)\nusing this:\n  exec_meth ci P (ins @ ins') (xt @ shift (length ins) xt') t h\n   (stk, loc, length ins + pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci P ins' xt' t h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc' - length ins, xcp')", "proof(cases rule: exec_meth.cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr ((ins @ ins') ! (length ins + pc)) P t h stk loc\n            undefined undefined (length ins + pc) [];\n     length ins + pc < length (ins @ ins');\n     ci_app ci ((ins @ ins') ! (length ins + pc)) P h stk loc undefined\n      undefined (length ins + pc) []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P ins' xt' t h (stk, loc, pc, xcp) ta h'\n                       (stk', loc', pc' - length ins, xcp')\n 2. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table P (cname_of h xcpa) (length ins + pc)\n         (xt @ shift (length ins) xt') =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P ins' xt' t h (stk, loc, pc, xcp) ta\n                          h' (stk', loc', pc' - length ins, xcp')", "case exec_instr"], ["proof (state)\nthis:\n  xcp = None\n  (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n  \\<in> exec_instr ((ins @ ins') ! (length ins + pc)) P t h stk loc\n         undefined undefined (length ins + pc) []\n  length ins + pc < length (ins @ ins')\n  ci_app ci ((ins @ ins') ! (length ins + pc)) P h stk loc undefined\n   undefined (length ins + pc) []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr ((ins @ ins') ! (length ins + pc)) P t h stk loc\n            undefined undefined (length ins + pc) [];\n     length ins + pc < length (ins @ ins');\n     ci_app ci ((ins @ ins') ! (length ins + pc)) P h stk loc undefined\n      undefined (length ins + pc) []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P ins' xt' t h (stk, loc, pc, xcp) ta h'\n                       (stk', loc', pc' - length ins, xcp')\n 2. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table P (cname_of h xcpa) (length ins + pc)\n         (xt @ shift (length ins) xt') =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P ins' xt' t h (stk, loc, pc, xcp) ta\n                          h' (stk', loc', pc' - length ins, xcp')", "let ?PC = \"length ins + pc\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr ((ins @ ins') ! (length ins + pc)) P t h stk loc\n            undefined undefined (length ins + pc) [];\n     length ins + pc < length (ins @ ins');\n     ci_app ci ((ins @ ins') ! (length ins + pc)) P h stk loc undefined\n      undefined (length ins + pc) []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P ins' xt' t h (stk, loc, pc, xcp) ta h'\n                       (stk', loc', pc' - length ins, xcp')\n 2. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table P (cname_of h xcpa) (length ins + pc)\n         (xt @ shift (length ins) xt') =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P ins' xt' t h (stk, loc, pc, xcp) ta\n                          h' (stk', loc', pc' - length ins, xcp')", "note [simp] = \\<open>xcp = None\\<close>"], ["proof (state)\nthis:\n  xcp = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr ((ins @ ins') ! (length ins + pc)) P t h stk loc\n            undefined undefined (length ins + pc) [];\n     length ins + pc < length (ins @ ins');\n     ci_app ci ((ins @ ins') ! (length ins + pc)) P h stk loc undefined\n      undefined (length ins + pc) []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P ins' xt' t h (stk, loc, pc, xcp) ta h'\n                       (stk', loc', pc' - length ins, xcp')\n 2. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table P (cname_of h xcpa) (length ins + pc)\n         (xt @ shift (length ins) xt') =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P ins' xt' t h (stk, loc, pc, xcp) ta\n                          h' (stk', loc', pc' - length ins, xcp')", "from \\<open>?PC < length (ins @ ins')\\<close>"], ["proof (chain)\npicking this:\n  length ins + pc < length (ins @ ins')", "have pc: \"pc < length ins'\""], ["proof (prove)\nusing this:\n  length ins + pc < length (ins @ ins')\n\ngoal (1 subgoal):\n 1. pc < length ins'", "by simp"], ["proof (state)\nthis:\n  pc < length ins'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr ((ins @ ins') ! (length ins + pc)) P t h stk loc\n            undefined undefined (length ins + pc) [];\n     length ins + pc < length (ins @ ins');\n     ci_app ci ((ins @ ins') ! (length ins + pc)) P h stk loc undefined\n      undefined (length ins + pc) []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P ins' xt' t h (stk, loc, pc, xcp) ta h'\n                       (stk', loc', pc' - length ins, xcp')\n 2. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table P (cname_of h xcpa) (length ins + pc)\n         (xt @ shift (length ins) xt') =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P ins' xt' t h (stk, loc, pc, xcp) ta\n                          h' (stk', loc', pc' - length ins, xcp')", "moreover"], ["proof (state)\nthis:\n  pc < length ins'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr ((ins @ ins') ! (length ins + pc)) P t h stk loc\n            undefined undefined (length ins + pc) [];\n     length ins + pc < length (ins @ ins');\n     ci_app ci ((ins @ ins') ! (length ins + pc)) P h stk loc undefined\n      undefined (length ins + pc) []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P ins' xt' t h (stk, loc, pc, xcp) ta h'\n                       (stk', loc', pc' - length ins, xcp')\n 2. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table P (cname_of h xcpa) (length ins + pc)\n         (xt @ shift (length ins) xt') =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P ins' xt' t h (stk, loc, pc, xcp) ta\n                          h' (stk', loc', pc' - length ins, xcp')", "with \\<open>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')]) \\<in> exec_instr ((ins @ ins') ! ?PC) P t h stk loc undefined undefined ?PC []\\<close>"], ["proof (chain)\npicking this:\n  (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n  \\<in> exec_instr ((ins @ ins') ! (length ins + pc)) P t h stk loc\n         undefined undefined (length ins + pc) []\n  pc < length ins'", "have \"(ta, xcp', h', [(stk', loc', undefined, undefined, pc' - length ins)]) \\<in> exec_instr (ins' ! pc) P t h stk loc undefined undefined pc []\""], ["proof (prove)\nusing this:\n  (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n  \\<in> exec_instr ((ins @ ins') ! (length ins + pc)) P t h stk loc\n         undefined undefined (length ins + pc) []\n  pc < length ins'\n\ngoal (1 subgoal):\n 1. (ta, xcp', h', [(stk', loc', undefined, undefined, pc' - length ins)])\n    \\<in> exec_instr (ins' ! pc) P t h stk loc undefined undefined pc []", "apply(cases \"ins' ! pc\")"], ["proof (prove)\ngoal (24 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr ((ins @ ins') ! (length ins + pc)) P t h\n                       stk loc undefined undefined (length ins + pc) [];\n        pc < length ins'; ins' ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            pc' - length ins)])\n                         \\<in> exec_instr (ins' ! pc) P t h stk loc\n                                undefined undefined pc []\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr ((ins @ ins') ! (length ins + pc)) P t h\n                       stk loc undefined undefined (length ins + pc) [];\n        pc < length ins'; ins' ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            pc' - length ins)])\n                         \\<in> exec_instr (ins' ! pc) P t h stk loc\n                                undefined undefined pc []\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr ((ins @ ins') ! (length ins + pc)) P t h\n                       stk loc undefined undefined (length ins + pc) [];\n        pc < length ins'; ins' ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            pc' - length ins)])\n                         \\<in> exec_instr (ins' ! pc) P t h stk loc\n                                undefined undefined pc []\n 4. \\<And>x4.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr ((ins @ ins') ! (length ins + pc)) P t h\n                       stk loc undefined undefined (length ins + pc) [];\n        pc < length ins'; ins' ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            pc' - length ins)])\n                         \\<in> exec_instr (ins' ! pc) P t h stk loc\n                                undefined undefined pc []\n 5. \\<And>x5.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr ((ins @ ins') ! (length ins + pc)) P t h\n                       stk loc undefined undefined (length ins + pc) [];\n        pc < length ins'; ins' ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            pc' - length ins)])\n                         \\<in> exec_instr (ins' ! pc) P t h stk loc\n                                undefined undefined pc []\n 6. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr ((ins @ ins') ! (length ins + pc)) P t h stk\n                    loc undefined undefined (length ins + pc) [];\n     pc < length ins'; ins' ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         pc' - length ins)])\n                      \\<in> exec_instr (ins' ! pc) P t h stk loc undefined\n                             undefined pc []\n 7. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr ((ins @ ins') ! (length ins + pc)) P t h stk\n                    loc undefined undefined (length ins + pc) [];\n     pc < length ins'; ins' ! pc = AStore\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         pc' - length ins)])\n                      \\<in> exec_instr (ins' ! pc) P t h stk loc undefined\n                             undefined pc []\n 8. \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n             \\<in> exec_instr ((ins @ ins') ! (length ins + pc)) P t h stk\n                    loc undefined undefined (length ins + pc) [];\n     pc < length ins'; ins' ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h',\n                       [(stk', loc', undefined, undefined,\n                         pc' - length ins)])\n                      \\<in> exec_instr (ins' ! pc) P t h stk loc undefined\n                             undefined pc []\n 9. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr ((ins @ ins') ! (length ins + pc)) P t h\n                       stk loc undefined undefined (length ins + pc) [];\n        pc < length ins'; ins' ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            pc' - length ins)])\n                         \\<in> exec_instr (ins' ! pc) P t h stk loc\n                                undefined undefined pc []\n 10. \\<And>x101 x102.\n        \\<lbrakk>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                 \\<in> exec_instr ((ins @ ins') ! (length ins + pc)) P t h\n                        stk loc undefined undefined (length ins + pc) [];\n         pc < length ins'; ins' ! pc = Putfield x101 x102\\<rbrakk>\n        \\<Longrightarrow> (ta, xcp', h',\n                           [(stk', loc', undefined, undefined,\n                             pc' - length ins)])\n                          \\<in> exec_instr (ins' ! pc) P t h stk loc\n                                 undefined undefined pc []\nA total of 24 subgoals...", "apply(simp_all add: split_beta split: if_split_asm sum.split_asm split del: if_split)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x4.\n       \\<lbrakk>pc < length ins'; ins' ! pc = New x4;\n        allocate h (Class_type x4) \\<noteq> {};\n        (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n        \\<in> (\\<lambda>x.\n                  (\\<lbrace>NewHeapElem (snd x) (Class_type x4)\\<rbrace>,\n                   None, fst x,\n                   [(Addr (snd x) # stk, loc, undefined, undefined,\n                     Suc (length ins + pc))])) `\n              allocate h (Class_type x4)\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            pc' - length ins)])\n                         \\<in> (\\<lambda>x.\n                                   (\\<lbrace>NewHeapElem (snd x)\n        (Class_type x4)\\<rbrace>,\n                                    None, fst x,\n                                    [(Addr (snd x) # stk, loc, undefined,\nundefined, Suc pc)])) `\n                               allocate h (Class_type x4)\n 2. \\<And>x5.\n       \\<lbrakk>pc < length ins'; ins' ! pc = NewArray x5;\n        \\<not> the_Intg (hd stk) <s 0;\n        allocate h (Array_type x5 (nat (sint (the_Intg (hd stk))))) \\<noteq>\n        {};\n        (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n        \\<in> (\\<lambda>x.\n                  (\\<lbrace>NewHeapElem (snd x)\n                             (Array_type x5\n                               (nat (sint (the_Intg (hd stk)))))\\<rbrace>,\n                   None, fst x,\n                   [(Addr (snd x) # tl stk, loc, undefined, undefined,\n                     Suc (length ins + pc))])) `\n              allocate h\n               (Array_type x5 (nat (sint (the_Intg (hd stk)))))\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          [(stk', loc', undefined, undefined,\n                            pc' - length ins)])\n                         \\<in> (\\<lambda>x.\n                                   (\\<lbrace>NewHeapElem (snd x)\n        (Array_type x5 (nat (sint (the_Intg (hd stk)))))\\<rbrace>,\n                                    None, fst x,\n                                    [(Addr (snd x) # tl stk, loc, undefined,\nundefined, Suc pc)])) `\n                               allocate h\n                                (Array_type x5\n                                  (nat (sint (the_Intg (hd stk)))))\n 3. \\<lbrakk>pc < length ins'; ins' ! pc = ALoad; hd (tl stk) \\<noteq> Null;\n     \\<not> the_Intg (hd stk) <s 0 \\<and>\n     \\<not> int (alen_of_htype\n                  (the (typeof_addr h (the_Addr (hd (tl stk))))))\n            \\<le> sint (the_Intg (hd stk));\n     \\<exists>v.\n        ta =\n        \\<lbrace>ReadMem (the_Addr (hd (tl stk)))\n                  (ACell (nat (sint (the_Intg (hd stk))))) v\\<rbrace> \\<and>\n        xcp' = None \\<and>\n        h' = h \\<and>\n        stk' = v # tl (tl stk) \\<and>\n        loc' = loc \\<and>\n        pc' = Suc (length ins + pc) \\<and>\n        heap_read h (the_Addr (hd (tl stk)))\n         (ACell (nat (sint (the_Intg (hd stk))))) v\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v.\n                         ta =\n                         \\<lbrace>ReadMem (the_Addr (hd (tl stk)))\n                                   (ACell (nat (sint (the_Intg (hd stk)))))\n                                   v\\<rbrace> \\<and>\n                         xcp' = None \\<and>\n                         h' = h \\<and>\n                         stk' = v # tl (tl stk) \\<and>\n                         loc' = loc \\<and>\n                         pc' - length ins = Suc pc \\<and>\n                         heap_read h (the_Addr (hd (tl stk)))\n                          (ACell (nat (sint (the_Intg (hd stk))))) v\n 4. \\<And>x91 x92.\n       \\<lbrakk>pc < length ins'; ins' ! pc = Getfield x91 x92;\n        hd stk \\<noteq> Null;\n        \\<exists>v'.\n           ta =\n           \\<lbrace>ReadMem (the_Addr (hd stk)) (CField x92 x91)\n                     v'\\<rbrace> \\<and>\n           xcp' = None \\<and>\n           h' = h \\<and>\n           stk' = v' # tl stk \\<and>\n           loc' = loc \\<and>\n           pc' = Suc (length ins + pc) \\<and>\n           heap_read h (the_Addr (hd stk)) (CField x92 x91) v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'.\n                            ta =\n                            \\<lbrace>ReadMem (the_Addr (hd stk))\n(CField x92 x91) v'\\<rbrace> \\<and>\n                            xcp' = None \\<and>\n                            h' = h \\<and>\n                            stk' = v' # tl stk \\<and>\n                            loc' = loc \\<and>\n                            pc' - length ins = Suc pc \\<and>\n                            heap_read h (the_Addr (hd stk)) (CField x92 x91)\n                             v'\n 5. \\<And>x111 x112.\n       \\<lbrakk>pc < length ins'; ins' ! pc = CAS x111 x112;\n        hd (tl (tl stk)) \\<noteq> Null;\n        ta =\n        \\<lbrace>ReadMem (the_Addr (hd (tl (tl stk)))) (CField x112 x111)\n                  (hd (tl stk)),\n        WriteMem (the_Addr (hd (tl (tl stk)))) (CField x112 x111)\n         (hd stk)\\<rbrace> \\<and>\n        xcp' = None \\<and>\n        stk' = Bool True # tl (tl (tl stk)) \\<and>\n        loc' = loc \\<and>\n        pc' = Suc (length ins + pc) \\<and>\n        heap_read h (the_Addr (hd (tl (tl stk)))) (CField x112 x111)\n         (hd (tl stk)) \\<and>\n        heap_write h (the_Addr (hd (tl (tl stk)))) (CField x112 x111)\n         (hd stk) h' \\<or>\n        (\\<exists>v''.\n            ta =\n            \\<lbrace>ReadMem (the_Addr (hd (tl (tl stk))))\n                      (CField x112 x111) v''\\<rbrace> \\<and>\n            xcp' = None \\<and>\n            h' = h \\<and>\n            stk' = Bool False # tl (tl (tl stk)) \\<and>\n            loc' = loc \\<and>\n            pc' = Suc (length ins + pc) \\<and>\n            heap_read h (the_Addr (hd (tl (tl stk)))) (CField x112 x111)\n             v'' \\<and>\n            v'' \\<noteq> hd (tl stk))\\<rbrakk>\n       \\<Longrightarrow> ta =\n                         \\<lbrace>ReadMem (the_Addr (hd (tl (tl stk))))\n                                   (CField x112 x111) (hd (tl stk)),\n                         WriteMem (the_Addr (hd (tl (tl stk))))\n                          (CField x112 x111) (hd stk)\\<rbrace> \\<and>\n                         xcp' = None \\<and>\n                         stk' = Bool True # tl (tl (tl stk)) \\<and>\n                         loc' = loc \\<and>\n                         pc' - length ins = Suc pc \\<and>\n                         heap_read h (the_Addr (hd (tl (tl stk))))\n                          (CField x112 x111) (hd (tl stk)) \\<and>\n                         heap_write h (the_Addr (hd (tl (tl stk))))\n                          (CField x112 x111) (hd stk) h' \\<or>\n                         (\\<exists>v''.\n                             ta =\n                             \\<lbrace>ReadMem (the_Addr (hd (tl (tl stk))))\n (CField x112 x111) v''\\<rbrace> \\<and>\n                             xcp' = None \\<and>\n                             h' = h \\<and>\n                             stk' = Bool False # tl (tl (tl stk)) \\<and>\n                             loc' = loc \\<and>\n                             pc' - length ins = Suc pc \\<and>\n                             heap_read h (the_Addr (hd (tl (tl stk))))\n                              (CField x112 x111) v'' \\<and>\n                             v'' \\<noteq> hd (tl stk))\n 6. \\<And>x141 x142.\n       \\<lbrakk>pc < length ins'; ins' ! pc = Invoke x141 x142;\n        stk ! x142 \\<noteq> Null;\n        snd (snd (snd (method P\n                        (class_type_of\n                          (the (typeof_addr h (the_Addr (stk ! x142)))))\n                        x141))) =\n        None;\n        \\<exists>a aa aaa aaaa aaaaa b.\n           ta =\n           (a, map (convert_new_thread_action (extNTA2JVM P)) aa, aaa, aaaa,\n            aaaaa, b) \\<and>\n           (\\<exists>va.\n               (case va of\n                RetVal v \\<Rightarrow>\n                  xcp' = None \\<and>\n                  [(stk', loc', undefined, undefined, pc')] =\n                  [(v # drop (Suc x142) stk, loc, undefined, undefined,\n                    length ins + pc + 1)]\n                | RetExc a \\<Rightarrow>\n                    xcp' = \\<lfloor>a\\<rfloor> \\<and>\n                    [(stk', loc', undefined, undefined, pc')] =\n                    [(stk, loc, undefined, undefined, length ins + pc)]\n                | RetStaySame \\<Rightarrow>\n                    xcp' = None \\<and>\n                    [(stk', loc', undefined, undefined, pc')] =\n                    [(stk, loc, undefined, undefined,\n                      length ins + pc)]) \\<and>\n               ((a, aa, aaa, aaaa, aaaaa, b), va, h')\n               \\<in> red_external_aggr P t (the_Addr (stk ! x142)) x141\n                      (rev (take x142 stk)) h)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa aaa aaaa aaaaa b.\n                            ta =\n                            (a, map (convert_new_thread_action\n(extNTA2JVM P))\n                                 aa,\n                             aaa, aaaa, aaaaa, b) \\<and>\n                            (\\<exists>va.\n                                (case va of\n                                 RetVal v \\<Rightarrow>\n                                   xcp' = None \\<and>\n                                   [(stk', loc', undefined, undefined,\n                                     pc' - length ins)] =\n                                   [(v # drop (Suc x142) stk, loc,\n                                     undefined, undefined, pc + 1)]\n                                 | RetExc a \\<Rightarrow>\n                                     xcp' = \\<lfloor>a\\<rfloor> \\<and>\n                                     [(stk', loc', undefined, undefined,\n pc' - length ins)] =\n                                     [(stk, loc, undefined, undefined, pc)]\n                                 | RetStaySame \\<Rightarrow>\n                                     xcp' = None \\<and>\n                                     [(stk', loc', undefined, undefined,\n pc' - length ins)] =\n                                     [(stk, loc, undefined, undefined,\n pc)]) \\<and>\n                                ((a, aa, aaa, aaaa, aaaaa, b), va, h')\n                                \\<in> red_external_aggr P t\n (the_Addr (stk ! x142)) x141 (rev (take x142 stk)) h)\n 7. \\<lbrakk>pc < length ins'; ins' ! pc = MExit; hd stk \\<noteq> Null;\n     ta = \\<lbrace>(Unlock, the_Addr (hd stk)),\n     SyncUnlock (the_Addr (hd stk))\\<rbrace> \\<and>\n     xcp' = None \\<and>\n     h' = h \\<and>\n     stk' = tl stk \\<and>\n     loc' = loc \\<and> pc' = Suc (length ins + pc) \\<or>\n     ta = \\<lbrace>(UnlockFail, the_Addr (hd stk))\\<rbrace> \\<and>\n     xcp' = \\<lfloor>addr_of_sys_xcpt IllegalMonitorState\\<rfloor> \\<and>\n     h' = h \\<and>\n     stk' = stk \\<and> loc' = loc \\<and> pc' = length ins + pc\\<rbrakk>\n    \\<Longrightarrow> ta = \\<lbrace>(Unlock, the_Addr (hd stk)),\n                      SyncUnlock (the_Addr (hd stk))\\<rbrace> \\<and>\n                      xcp' = None \\<and>\n                      h' = h \\<and>\n                      stk' = tl stk \\<and>\n                      loc' = loc \\<and> pc' - length ins = Suc pc \\<or>\n                      ta =\n                      \\<lbrace>(UnlockFail,\n                                the_Addr (hd stk))\\<rbrace> \\<and>\n                      xcp' =\n                      \\<lfloor>addr_of_sys_xcpt\n                                IllegalMonitorState\\<rfloor> \\<and>\n                      h' = h \\<and>\n                      stk' = stk \\<and>\n                      loc' = loc \\<and> pc' - length ins = pc", "apply(force split: extCallRet.splits simp add: min_def extRet2JVM_def)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (ta, xcp', h', [(stk', loc', undefined, undefined, pc' - length ins)])\n  \\<in> exec_instr (ins' ! pc) P t h stk loc undefined undefined pc []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr ((ins @ ins') ! (length ins + pc)) P t h stk loc\n            undefined undefined (length ins + pc) [];\n     length ins + pc < length (ins @ ins');\n     ci_app ci ((ins @ ins') ! (length ins + pc)) P h stk loc undefined\n      undefined (length ins + pc) []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P ins' xt' t h (stk, loc, pc, xcp) ta h'\n                       (stk', loc', pc' - length ins, xcp')\n 2. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table P (cname_of h xcpa) (length ins + pc)\n         (xt @ shift (length ins) xt') =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P ins' xt' t h (stk, loc, pc, xcp) ta\n                          h' (stk', loc', pc' - length ins, xcp')", "moreover"], ["proof (state)\nthis:\n  (ta, xcp', h', [(stk', loc', undefined, undefined, pc' - length ins)])\n  \\<in> exec_instr (ins' ! pc) P t h stk loc undefined undefined pc []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr ((ins @ ins') ! (length ins + pc)) P t h stk loc\n            undefined undefined (length ins + pc) [];\n     length ins + pc < length (ins @ ins');\n     ci_app ci ((ins @ ins') ! (length ins + pc)) P h stk loc undefined\n      undefined (length ins + pc) []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P ins' xt' t h (stk, loc, pc, xcp) ta h'\n                       (stk', loc', pc' - length ins, xcp')\n 2. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table P (cname_of h xcpa) (length ins + pc)\n         (xt @ shift (length ins) xt') =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P ins' xt' t h (stk, loc, pc, xcp) ta\n                          h' (stk', loc', pc' - length ins, xcp')", "from \\<open>ci_app ci ((ins @ ins') ! ?PC) P h stk loc undefined undefined ?PC []\\<close> jump pc"], ["proof (chain)\npicking this:\n  ci_app ci ((ins @ ins') ! (length ins + pc)) P h stk loc undefined\n   undefined (length ins + pc) []\n  jump_ok ins' 0 n\n  pc < length ins'", "have \"ci_app ci (ins' ! pc) P h stk loc undefined undefined pc []\""], ["proof (prove)\nusing this:\n  ci_app ci ((ins @ ins') ! (length ins + pc)) P h stk loc undefined\n   undefined (length ins + pc) []\n  jump_ok ins' 0 n\n  pc < length ins'\n\ngoal (1 subgoal):\n 1. ci_app ci (ins' ! pc) P h stk loc undefined undefined pc []", "by(fastforce elim: wf_ciD3_ci_app dest: jump_ok_ins_jump_ok)"], ["proof (state)\nthis:\n  ci_app ci (ins' ! pc) P h stk loc undefined undefined pc []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr ((ins @ ins') ! (length ins + pc)) P t h stk loc\n            undefined undefined (length ins + pc) [];\n     length ins + pc < length (ins @ ins');\n     ci_app ci ((ins @ ins') ! (length ins + pc)) P h stk loc undefined\n      undefined (length ins + pc) []\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P ins' xt' t h (stk, loc, pc, xcp) ta h'\n                       (stk', loc', pc' - length ins, xcp')\n 2. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table P (cname_of h xcpa) (length ins + pc)\n         (xt @ shift (length ins) xt') =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P ins' xt' t h (stk, loc, pc, xcp) ta\n                          h' (stk', loc', pc' - length ins, xcp')", "ultimately"], ["proof (chain)\npicking this:\n  pc < length ins'\n  (ta, xcp', h', [(stk', loc', undefined, undefined, pc' - length ins)])\n  \\<in> exec_instr (ins' ! pc) P t h stk loc undefined undefined pc []\n  ci_app ci (ins' ! pc) P h stk loc undefined undefined pc []", "show ?thesis"], ["proof (prove)\nusing this:\n  pc < length ins'\n  (ta, xcp', h', [(stk', loc', undefined, undefined, pc' - length ins)])\n  \\<in> exec_instr (ins' ! pc) P t h stk loc undefined undefined pc []\n  ci_app ci (ins' ! pc) P h stk loc undefined undefined pc []\n\ngoal (1 subgoal):\n 1. exec_meth ci P ins' xt' t h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc' - length ins, xcp')", "by(auto intro: exec_meth.intros)"], ["proof (state)\nthis:\n  exec_meth ci P ins' xt' t h (stk, loc, pc, xcp) ta h'\n   (stk', loc', pc' - length ins, xcp')\n\ngoal (1 subgoal):\n 1. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table P (cname_of h xcpa) (length ins + pc)\n         (xt @ shift (length ins) xt') =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P ins' xt' t h (stk, loc, pc, xcp) ta\n                          h' (stk', loc', pc' - length ins, xcp')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table P (cname_of h xcpa) (length ins + pc)\n         (xt @ shift (length ins) xt') =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P ins' xt' t h (stk, loc, pc, xcp) ta\n                          h' (stk', loc', pc' - length ins, xcp')", "case (exec_catch XCP D)"], ["proof (state)\nthis:\n  xcp = \\<lfloor>XCP\\<rfloor>\n  ta = \\<lbrace>\\<rbrace>\n  h' = h\n  stk' = Addr XCP # drop (length stk - D) stk\n  loc' = loc\n  xcp' = None\n  match_ex_table P (cname_of h XCP) (length ins + pc)\n   (xt @ shift (length ins) xt') =\n  \\<lfloor>(pc', D)\\<rfloor>\n  D \\<le> length stk\n\ngoal (1 subgoal):\n 1. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table P (cname_of h xcpa) (length ins + pc)\n         (xt @ shift (length ins) xt') =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P ins' xt' t h (stk, loc, pc, xcp) ta\n                          h' (stk', loc', pc' - length ins, xcp')", "let ?PC = \"length ins + pc\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table P (cname_of h xcpa) (length ins + pc)\n         (xt @ shift (length ins) xt') =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P ins' xt' t h (stk, loc, pc, xcp) ta\n                          h' (stk', loc', pc' - length ins, xcp')", "note [simp] = \\<open>xcp = \\<lfloor>XCP\\<rfloor>\\<close>\n    \\<open>ta = \\<epsilon>\\<close> \\<open>h' = h\\<close> \\<open>stk' = Addr XCP # drop (length stk - D) stk\\<close> \\<open>loc' = loc\\<close> \\<open>xcp' = None\\<close>"], ["proof (state)\nthis:\n  xcp = \\<lfloor>XCP\\<rfloor>\n  ta = \\<lbrace>\\<rbrace>\n  h' = h\n  stk' = Addr XCP # drop (length stk - D) stk\n  loc' = loc\n  xcp' = None\n\ngoal (1 subgoal):\n 1. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table P (cname_of h xcpa) (length ins + pc)\n         (xt @ shift (length ins) xt') =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P ins' xt' t h (stk, loc, pc, xcp) ta\n                          h' (stk', loc', pc' - length ins, xcp')", "from \\<open>match_ex_table P (cname_of h XCP) ?PC (xt @ shift (length ins) xt') = \\<lfloor>(pc', D)\\<rfloor>\\<close> xt"], ["proof (chain)\npicking this:\n  match_ex_table P (cname_of h XCP) (length ins + pc)\n   (xt @ shift (length ins) xt') =\n  \\<lfloor>(pc', D)\\<rfloor>\n  pcs xt \\<subseteq> {..<length ins}", "have \"match_ex_table P (cname_of h XCP) pc xt' = \\<lfloor>(pc' - length ins, D)\\<rfloor>\""], ["proof (prove)\nusing this:\n  match_ex_table P (cname_of h XCP) (length ins + pc)\n   (xt @ shift (length ins) xt') =\n  \\<lfloor>(pc', D)\\<rfloor>\n  pcs xt \\<subseteq> {..<length ins}\n\ngoal (1 subgoal):\n 1. match_ex_table P (cname_of h XCP) pc xt' =\n    \\<lfloor>(pc' - length ins, D)\\<rfloor>", "by(auto simp add: match_ex_table_append dest: match_ex_table_shift_pcD match_ex_table_pcsD)"], ["proof (state)\nthis:\n  match_ex_table P (cname_of h XCP) pc xt' =\n  \\<lfloor>(pc' - length ins, D)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table P (cname_of h xcpa) (length ins + pc)\n         (xt @ shift (length ins) xt') =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> exec_meth ci P ins' xt' t h (stk, loc, pc, xcp) ta\n                          h' (stk', loc', pc' - length ins, xcp')", "with \\<open>D \\<le> length stk\\<close>"], ["proof (chain)\npicking this:\n  D \\<le> length stk\n  match_ex_table P (cname_of h XCP) pc xt' =\n  \\<lfloor>(pc' - length ins, D)\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  D \\<le> length stk\n  match_ex_table P (cname_of h XCP) pc xt' =\n  \\<lfloor>(pc' - length ins, D)\\<rfloor>\n\ngoal (1 subgoal):\n 1. exec_meth ci P ins' xt' t h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc' - length ins, xcp')", "by(auto intro: exec_meth.intros)"], ["proof (state)\nthis:\n  exec_meth ci P ins' xt' t h (stk, loc, pc, xcp) ta h'\n   (stk', loc', pc' - length ins, xcp')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exec_meth_drop:\n  \"\\<lbrakk> exec_meth ci P (ins @ ins') (shift (length ins) xt) t h (stk, loc, (length ins + pc), xcp) ta h' (stk', loc', pc', xcp');\n     jump_ok ins' 0 b \\<rbrakk>\n   \\<Longrightarrow> exec_meth ci P ins' xt t h (stk, loc, pc, xcp) ta h' (stk', loc', (pc' - length ins), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>exec_meth ci P (ins @ ins') (shift (length ins) xt) t h\n              (stk, loc, length ins + pc, xcp) ta h'\n              (stk', loc', pc', xcp');\n     jump_ok ins' 0 b\\<rbrakk>\n    \\<Longrightarrow> exec_meth ci P ins' xt t h (stk, loc, pc, xcp) ta h'\n                       (stk', loc', pc' - length ins, xcp')", "by(auto intro: exec_meth_drop_xt[where xt = \"[]\"])"], ["", "lemma exec_meth_drop_xt_pc:\n  assumes exec: \"exec_meth ci P (ins @ ins') (xt @ shift (length ins) xt') t h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  and pc: \"pc \\<ge> length ins\"\n  and pcs: \"pcs xt \\<subseteq> {..<length ins}\"\n  and jump: \"jump_ok ins' 0 n'\"\n  shows \"pc' \\<ge> length ins\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ins \\<le> pc'", "using exec"], ["proof (prove)\nusing this:\n  exec_meth ci P (ins @ ins') (xt @ shift (length ins) xt') t h\n   (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. length ins \\<le> pc'", "proof(cases rule: exec_meth.cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr ((ins @ ins') ! pc) P t h stk loc undefined undefined\n            pc [];\n     pc < length (ins @ ins');\n     ci_app ci ((ins @ ins') ! pc) P h stk loc undefined undefined pc\n      []\\<rbrakk>\n    \\<Longrightarrow> length ins \\<le> pc'\n 2. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table P (cname_of h xcpa) pc\n         (xt @ shift (length ins) xt') =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> length ins \\<le> pc'", "case exec_instr"], ["proof (state)\nthis:\n  xcp = None\n  (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n  \\<in> exec_instr ((ins @ ins') ! pc) P t h stk loc undefined undefined pc\n         []\n  pc < length (ins @ ins')\n  ci_app ci ((ins @ ins') ! pc) P h stk loc undefined undefined pc []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr ((ins @ ins') ! pc) P t h stk loc undefined undefined\n            pc [];\n     pc < length (ins @ ins');\n     ci_app ci ((ins @ ins') ! pc) P h stk loc undefined undefined pc\n      []\\<rbrakk>\n    \\<Longrightarrow> length ins \\<le> pc'\n 2. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table P (cname_of h xcpa) pc\n         (xt @ shift (length ins) xt') =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> length ins \\<le> pc'", "thus ?thesis"], ["proof (prove)\nusing this:\n  xcp = None\n  (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n  \\<in> exec_instr ((ins @ ins') ! pc) P t h stk loc undefined undefined pc\n         []\n  pc < length (ins @ ins')\n  ci_app ci ((ins @ ins') ! pc) P h stk loc undefined undefined pc []\n\ngoal (1 subgoal):\n 1. length ins \\<le> pc'", "using jump pc"], ["proof (prove)\nusing this:\n  xcp = None\n  (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n  \\<in> exec_instr ((ins @ ins') ! pc) P t h stk loc undefined undefined pc\n         []\n  pc < length (ins @ ins')\n  ci_app ci ((ins @ ins') ! pc) P h stk loc undefined undefined pc []\n  jump_ok ins' 0 n'\n  length ins \\<le> pc\n\ngoal (1 subgoal):\n 1. length ins \\<le> pc'", "apply(cases \"ins' ! (pc - length ins)\")"], ["proof (prove)\ngoal (24 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>xcp = None;\n        (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n        \\<in> exec_instr ((ins @ ins') ! pc) P t h stk loc undefined\n               undefined pc [];\n        pc < length (ins @ ins');\n        ci_app ci ((ins @ ins') ! pc) P h stk loc undefined undefined pc [];\n        jump_ok ins' 0 n'; length ins \\<le> pc;\n        ins' ! (pc - length ins) = Load x1\\<rbrakk>\n       \\<Longrightarrow> length ins \\<le> pc'\n 2. \\<And>x2.\n       \\<lbrakk>xcp = None;\n        (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n        \\<in> exec_instr ((ins @ ins') ! pc) P t h stk loc undefined\n               undefined pc [];\n        pc < length (ins @ ins');\n        ci_app ci ((ins @ ins') ! pc) P h stk loc undefined undefined pc [];\n        jump_ok ins' 0 n'; length ins \\<le> pc;\n        ins' ! (pc - length ins) = Store x2\\<rbrakk>\n       \\<Longrightarrow> length ins \\<le> pc'\n 3. \\<And>x3.\n       \\<lbrakk>xcp = None;\n        (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n        \\<in> exec_instr ((ins @ ins') ! pc) P t h stk loc undefined\n               undefined pc [];\n        pc < length (ins @ ins');\n        ci_app ci ((ins @ ins') ! pc) P h stk loc undefined undefined pc [];\n        jump_ok ins' 0 n'; length ins \\<le> pc;\n        ins' ! (pc - length ins) = Push x3\\<rbrakk>\n       \\<Longrightarrow> length ins \\<le> pc'\n 4. \\<And>x4.\n       \\<lbrakk>xcp = None;\n        (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n        \\<in> exec_instr ((ins @ ins') ! pc) P t h stk loc undefined\n               undefined pc [];\n        pc < length (ins @ ins');\n        ci_app ci ((ins @ ins') ! pc) P h stk loc undefined undefined pc [];\n        jump_ok ins' 0 n'; length ins \\<le> pc;\n        ins' ! (pc - length ins) = New x4\\<rbrakk>\n       \\<Longrightarrow> length ins \\<le> pc'\n 5. \\<And>x5.\n       \\<lbrakk>xcp = None;\n        (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n        \\<in> exec_instr ((ins @ ins') ! pc) P t h stk loc undefined\n               undefined pc [];\n        pc < length (ins @ ins');\n        ci_app ci ((ins @ ins') ! pc) P h stk loc undefined undefined pc [];\n        jump_ok ins' 0 n'; length ins \\<le> pc;\n        ins' ! (pc - length ins) = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> length ins \\<le> pc'\n 6. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr ((ins @ ins') ! pc) P t h stk loc undefined undefined\n            pc [];\n     pc < length (ins @ ins');\n     ci_app ci ((ins @ ins') ! pc) P h stk loc undefined undefined pc [];\n     jump_ok ins' 0 n'; length ins \\<le> pc;\n     ins' ! (pc - length ins) = ALoad\\<rbrakk>\n    \\<Longrightarrow> length ins \\<le> pc'\n 7. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr ((ins @ ins') ! pc) P t h stk loc undefined undefined\n            pc [];\n     pc < length (ins @ ins');\n     ci_app ci ((ins @ ins') ! pc) P h stk loc undefined undefined pc [];\n     jump_ok ins' 0 n'; length ins \\<le> pc;\n     ins' ! (pc - length ins) = AStore\\<rbrakk>\n    \\<Longrightarrow> length ins \\<le> pc'\n 8. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr ((ins @ ins') ! pc) P t h stk loc undefined undefined\n            pc [];\n     pc < length (ins @ ins');\n     ci_app ci ((ins @ ins') ! pc) P h stk loc undefined undefined pc [];\n     jump_ok ins' 0 n'; length ins \\<le> pc;\n     ins' ! (pc - length ins) = ALength\\<rbrakk>\n    \\<Longrightarrow> length ins \\<le> pc'\n 9. \\<And>x91 x92.\n       \\<lbrakk>xcp = None;\n        (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n        \\<in> exec_instr ((ins @ ins') ! pc) P t h stk loc undefined\n               undefined pc [];\n        pc < length (ins @ ins');\n        ci_app ci ((ins @ ins') ! pc) P h stk loc undefined undefined pc [];\n        jump_ok ins' 0 n'; length ins \\<le> pc;\n        ins' ! (pc - length ins) = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> length ins \\<le> pc'\n 10. \\<And>x101 x102.\n        \\<lbrakk>xcp = None;\n         (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n         \\<in> exec_instr ((ins @ ins') ! pc) P t h stk loc undefined\n                undefined pc [];\n         pc < length (ins @ ins');\n         ci_app ci ((ins @ ins') ! pc) P h stk loc undefined undefined pc\n          [];\n         jump_ok ins' 0 n'; length ins \\<le> pc;\n         ins' ! (pc - length ins) = Putfield x101 x102\\<rbrakk>\n        \\<Longrightarrow> length ins \\<le> pc'\nA total of 24 subgoals...", "apply(simp_all add: split_beta nth_append split: if_split_asm sum.split_asm)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x4.\n       \\<lbrakk>pc < length ins + length ins';\n        ci_app ci (New x4) P h stk loc undefined undefined pc [];\n        jump_ok ins' 0 n'; length ins \\<le> pc;\n        ins' ! (pc - length ins) = New x4; xcp = None;\n        allocate h (Class_type x4) \\<noteq> {};\n        (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n        \\<in> (\\<lambda>x.\n                  (\\<lbrace>NewHeapElem (snd x) (Class_type x4)\\<rbrace>,\n                   None, fst x,\n                   [(Addr (snd x) # stk, loc, undefined, undefined,\n                     Suc pc)])) `\n              allocate h (Class_type x4)\\<rbrakk>\n       \\<Longrightarrow> length ins \\<le> pc'\n 2. \\<And>x5.\n       \\<lbrakk>pc < length ins + length ins';\n        ci_app ci (NewArray x5) P h stk loc undefined undefined pc [];\n        jump_ok ins' 0 n'; length ins \\<le> pc;\n        ins' ! (pc - length ins) = NewArray x5; xcp = None;\n        \\<not> the_Intg (hd stk) <s 0;\n        allocate h (Array_type x5 (nat (sint (the_Intg (hd stk))))) \\<noteq>\n        {};\n        (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n        \\<in> (\\<lambda>x.\n                  (\\<lbrace>NewHeapElem (snd x)\n                             (Array_type x5\n                               (nat (sint (the_Intg (hd stk)))))\\<rbrace>,\n                   None, fst x,\n                   [(Addr (snd x) # tl stk, loc, undefined, undefined,\n                     Suc pc)])) `\n              allocate h\n               (Array_type x5 (nat (sint (the_Intg (hd stk)))))\\<rbrakk>\n       \\<Longrightarrow> length ins \\<le> pc'\n 3. \\<lbrakk>pc < length ins + length ins';\n     ci_app ci ALoad P h stk loc undefined undefined pc [];\n     jump_ok ins' 0 n'; length ins \\<le> pc;\n     ins' ! (pc - length ins) = ALoad; xcp = None;\n     hd (tl stk) \\<noteq> Null;\n     \\<not> the_Intg (hd stk) <s 0 \\<and>\n     \\<not> int (alen_of_htype\n                  (the (typeof_addr h (the_Addr (hd (tl stk))))))\n            \\<le> sint (the_Intg (hd stk));\n     \\<exists>v.\n        ta =\n        \\<lbrace>ReadMem (the_Addr (hd (tl stk)))\n                  (ACell (nat (sint (the_Intg (hd stk))))) v\\<rbrace> \\<and>\n        xcp' = None \\<and>\n        h' = h \\<and>\n        stk' = v # tl (tl stk) \\<and>\n        loc' = loc \\<and>\n        pc' = Suc pc \\<and>\n        heap_read h (the_Addr (hd (tl stk)))\n         (ACell (nat (sint (the_Intg (hd stk))))) v\\<rbrakk>\n    \\<Longrightarrow> length ins \\<le> pc'\n 4. \\<And>x91 x92.\n       \\<lbrakk>pc < length ins + length ins';\n        ci_app ci (Getfield x91 x92) P h stk loc undefined undefined pc [];\n        jump_ok ins' 0 n'; length ins \\<le> pc;\n        ins' ! (pc - length ins) = Getfield x91 x92; xcp = None;\n        hd stk \\<noteq> Null;\n        \\<exists>v'.\n           ta =\n           \\<lbrace>ReadMem (the_Addr (hd stk)) (CField x92 x91)\n                     v'\\<rbrace> \\<and>\n           xcp' = None \\<and>\n           h' = h \\<and>\n           stk' = v' # tl stk \\<and>\n           loc' = loc \\<and>\n           pc' = Suc pc \\<and>\n           heap_read h (the_Addr (hd stk)) (CField x92 x91) v'\\<rbrakk>\n       \\<Longrightarrow> length ins \\<le> pc'\n 5. \\<And>x111 x112.\n       \\<lbrakk>pc < length ins + length ins';\n        ci_app ci (CAS x111 x112) P h stk loc undefined undefined pc [];\n        jump_ok ins' 0 n'; length ins \\<le> pc;\n        ins' ! (pc - length ins) = CAS x111 x112; xcp = None;\n        hd (tl (tl stk)) \\<noteq> Null;\n        ta =\n        \\<lbrace>ReadMem (the_Addr (hd (tl (tl stk)))) (CField x112 x111)\n                  (hd (tl stk)),\n        WriteMem (the_Addr (hd (tl (tl stk)))) (CField x112 x111)\n         (hd stk)\\<rbrace> \\<and>\n        xcp' = None \\<and>\n        stk' = Bool True # tl (tl (tl stk)) \\<and>\n        loc' = loc \\<and>\n        pc' = Suc pc \\<and>\n        heap_read h (the_Addr (hd (tl (tl stk)))) (CField x112 x111)\n         (hd (tl stk)) \\<and>\n        heap_write h (the_Addr (hd (tl (tl stk)))) (CField x112 x111)\n         (hd stk) h' \\<or>\n        (\\<exists>v''.\n            ta =\n            \\<lbrace>ReadMem (the_Addr (hd (tl (tl stk))))\n                      (CField x112 x111) v''\\<rbrace> \\<and>\n            xcp' = None \\<and>\n            h' = h \\<and>\n            stk' = Bool False # tl (tl (tl stk)) \\<and>\n            loc' = loc \\<and>\n            pc' = Suc pc \\<and>\n            heap_read h (the_Addr (hd (tl (tl stk)))) (CField x112 x111)\n             v'' \\<and>\n            v'' \\<noteq> hd (tl stk))\\<rbrakk>\n       \\<Longrightarrow> length ins \\<le> pc'\n 6. \\<And>x141 x142.\n       \\<lbrakk>pc < length ins + length ins';\n        ci_app ci (Invoke x141 x142) P h stk loc undefined undefined pc [];\n        jump_ok ins' 0 n'; length ins \\<le> pc;\n        ins' ! (pc - length ins) = Invoke x141 x142; xcp = None;\n        stk ! x142 \\<noteq> Null;\n        snd (snd (snd (method P\n                        (class_type_of\n                          (the (typeof_addr h (the_Addr (stk ! x142)))))\n                        x141))) =\n        None;\n        \\<exists>a aa aaa aaaa aaaaa b.\n           ta =\n           (a, map (convert_new_thread_action (extNTA2JVM P)) aa, aaa, aaaa,\n            aaaaa, b) \\<and>\n           (\\<exists>va.\n               (case va of\n                RetVal v \\<Rightarrow>\n                  xcp' = None \\<and>\n                  [(stk', loc', undefined, undefined, pc')] =\n                  [(v # drop (Suc x142) stk, loc, undefined, undefined,\n                    pc + 1)]\n                | RetExc a \\<Rightarrow>\n                    xcp' = \\<lfloor>a\\<rfloor> \\<and>\n                    [(stk', loc', undefined, undefined, pc')] =\n                    [(stk, loc, undefined, undefined, pc)]\n                | RetStaySame \\<Rightarrow>\n                    xcp' = None \\<and>\n                    [(stk', loc', undefined, undefined, pc')] =\n                    [(stk, loc, undefined, undefined, pc)]) \\<and>\n               ((a, aa, aaa, aaaa, aaaaa, b), va, h')\n               \\<in> red_external_aggr P t (the_Addr (stk ! x142)) x141\n                      (rev (take x142 stk)) h)\\<rbrakk>\n       \\<Longrightarrow> length ins \\<le> pc'\n 7. \\<And>x20.\n       \\<lbrakk>xcp = None;\n        ta = \\<lbrace>\\<rbrace> \\<and>\n        xcp' = None \\<and>\n        h' = h \\<and>\n        stk' = stk \\<and> loc' = loc \\<and> pc' = nat (int pc + x20);\n        pc < length ins + length ins';\n        ci_app ci (Goto x20) P h stk loc undefined undefined pc [];\n        jump_ok ins' 0 n'; length ins \\<le> pc;\n        ins' ! (pc - length ins) = Goto x20\\<rbrakk>\n       \\<Longrightarrow> length ins \\<le> nat (int pc + x20)\n 8. \\<And>x21.\n       \\<lbrakk>pc < length ins + length ins';\n        ci_app ci (IfFalse x21) P h stk loc undefined undefined pc [];\n        jump_ok ins' 0 n'; length ins \\<le> pc;\n        ins' ! (pc - length ins) = IfFalse x21; xcp = None;\n        hd stk = Bool False;\n        ta = \\<lbrace>\\<rbrace> \\<and>\n        xcp' = None \\<and>\n        h' = h \\<and>\n        stk' = tl stk \\<and>\n        loc' = loc \\<and> pc' = nat (int pc + x21)\\<rbrakk>\n       \\<Longrightarrow> length ins \\<le> nat (int pc + x21)\n 9. \\<lbrakk>pc < length ins + length ins';\n     ci_app ci MExit P h stk loc undefined undefined pc [];\n     jump_ok ins' 0 n'; length ins \\<le> pc;\n     ins' ! (pc - length ins) = MExit; xcp = None; hd stk \\<noteq> Null;\n     ta = \\<lbrace>(Unlock, the_Addr (hd stk)),\n     SyncUnlock (the_Addr (hd stk))\\<rbrace> \\<and>\n     xcp' = None \\<and>\n     h' = h \\<and> stk' = tl stk \\<and> loc' = loc \\<and> pc' = Suc pc \\<or>\n     ta = \\<lbrace>(UnlockFail, the_Addr (hd stk))\\<rbrace> \\<and>\n     xcp' = \\<lfloor>addr_of_sys_xcpt IllegalMonitorState\\<rfloor> \\<and>\n     h' = h \\<and> stk' = stk \\<and> loc' = loc \\<and> pc' = pc\\<rbrakk>\n    \\<Longrightarrow> length ins \\<le> pc'", "apply(force split: extCallRet.splits simp add: min_def extRet2JVM_def dest: jump_ok_GotoD jump_ok_IfFalseD)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  length ins \\<le> pc'\n\ngoal (1 subgoal):\n 1. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table P (cname_of h xcpa) pc\n         (xt @ shift (length ins) xt') =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> length ins \\<le> pc'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table P (cname_of h xcpa) pc\n         (xt @ shift (length ins) xt') =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> length ins \\<le> pc'", "case exec_catch"], ["proof (state)\nthis:\n  xcp = \\<lfloor>xcp_\\<rfloor>\n  ta = \\<lbrace>\\<rbrace>\n  h' = h\n  stk' = Addr xcp_ # drop (length stk - d_) stk\n  loc' = loc\n  xcp' = None\n  match_ex_table P (cname_of h xcp_) pc (xt @ shift (length ins) xt') =\n  \\<lfloor>(pc', d_)\\<rfloor>\n  d_ \\<le> length stk\n\ngoal (1 subgoal):\n 1. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table P (cname_of h xcpa) pc\n         (xt @ shift (length ins) xt') =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> length ins \\<le> pc'", "thus ?thesis"], ["proof (prove)\nusing this:\n  xcp = \\<lfloor>xcp_\\<rfloor>\n  ta = \\<lbrace>\\<rbrace>\n  h' = h\n  stk' = Addr xcp_ # drop (length stk - d_) stk\n  loc' = loc\n  xcp' = None\n  match_ex_table P (cname_of h xcp_) pc (xt @ shift (length ins) xt') =\n  \\<lfloor>(pc', d_)\\<rfloor>\n  d_ \\<le> length stk\n\ngoal (1 subgoal):\n 1. length ins \\<le> pc'", "using pcs pc"], ["proof (prove)\nusing this:\n  xcp = \\<lfloor>xcp_\\<rfloor>\n  ta = \\<lbrace>\\<rbrace>\n  h' = h\n  stk' = Addr xcp_ # drop (length stk - d_) stk\n  loc' = loc\n  xcp' = None\n  match_ex_table P (cname_of h xcp_) pc (xt @ shift (length ins) xt') =\n  \\<lfloor>(pc', d_)\\<rfloor>\n  d_ \\<le> length stk\n  pcs xt \\<subseteq> {..<length ins}\n  length ins \\<le> pc\n\ngoal (1 subgoal):\n 1. length ins \\<le> pc'", "by(auto dest: match_ex_table_pcsD match_ex_table_shift_pcD simp add: match_ex_table_append)"], ["proof (state)\nthis:\n  length ins \\<le> pc'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas exec_meth_drop_pc = exec_meth_drop_xt_pc[where xt=\"[]\", simplified]"], ["", "definition exec_move ::\n  \"('addr, 'heap) check_instr \\<Rightarrow> 'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'addr expr1\n  \\<Rightarrow> 'heap  \\<Rightarrow> ('addr val list \\<times> 'addr val list \\<times> pc \\<times> 'addr option)\n  \\<Rightarrow> ('addr, 'thread_id, 'heap) jvm_thread_action\n  \\<Rightarrow> 'heap \\<Rightarrow> ('addr val list \\<times> 'addr val list \\<times> pc \\<times> 'addr option) \\<Rightarrow> bool\"\nwhere \"exec_move ci P t e \\<equiv> exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t\""], ["", "definition exec_moves :: \n  \"('addr, 'heap) check_instr \\<Rightarrow> 'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'addr expr1 list\n  \\<Rightarrow> 'heap \\<Rightarrow> ('addr val list \\<times> 'addr val list \\<times> pc \\<times> 'addr option)\n  \\<Rightarrow> ('addr, 'thread_id, 'heap) jvm_thread_action\n  \\<Rightarrow> 'heap \\<Rightarrow> ('addr val list \\<times> 'addr val list \\<times> pc \\<times> 'addr option) \\<Rightarrow> bool\"\nwhere \"exec_moves ci P t es \\<equiv> exec_meth ci (compP2 P) (compEs2 es) (compxEs2 es 0 0) t\""], ["", "abbreviation exec_move_a\nwhere \"exec_move_a \\<equiv> exec_move (Abs_check_instr check_instr')\""], ["", "abbreviation exec_move_d\nwhere \"exec_move_d \\<equiv> exec_move (Abs_check_instr check_instr)\""], ["", "abbreviation exec_moves_a\nwhere \"exec_moves_a \\<equiv> exec_moves (Abs_check_instr check_instr')\""], ["", "abbreviation exec_moves_d\nwhere \"exec_moves_d \\<equiv> exec_moves (Abs_check_instr check_instr)\""], ["", "lemma exec_move_newArrayI:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (newA T\\<lfloor>e\\<rceil>) h s ta h' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t e h s ta h' s' \\<Longrightarrow>\n    exec_move ci P t (newA T\\<lfloor>e\\<rceil>) h s ta h' s'", "unfolding exec_move_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h s ta h'\n     s' \\<Longrightarrow>\n    exec_meth ci (compP2 P) (compE2 (newA T\\<lfloor>e\\<rceil>))\n     (compxE2 (newA T\\<lfloor>e\\<rceil>) 0 0) t h s ta h' s'", "by auto"], ["", "lemma exec_move_newArray:\n  \"pc < length (compE2 e) \\<Longrightarrow> exec_move ci P t (newA T\\<lfloor>e\\<rceil>) h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (compE2 e) \\<Longrightarrow>\n    exec_move ci P t (newA T\\<lfloor>e\\<rceil>) h (stk, loc, pc, xcp) =\n    exec_move ci P t e h (stk, loc, pc, xcp)", "unfolding exec_move_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (compE2 e) \\<Longrightarrow>\n    exec_meth ci (compP2 P) (compE2 (newA T\\<lfloor>e\\<rceil>))\n     (compxE2 (newA T\\<lfloor>e\\<rceil>) 0 0) t h (stk, loc, pc, xcp) =\n    exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h\n     (stk, loc, pc, xcp)", "by(auto intro!: ext intro: exec_meth_take)"], ["", "lemma exec_move_CastI:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (Cast T e) h s ta h' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t e h s ta h' s' \\<Longrightarrow>\n    exec_move ci P t (Cast T e) h s ta h' s'", "unfolding exec_move_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h s ta h'\n     s' \\<Longrightarrow>\n    exec_meth ci (compP2 P) (compE2 (Cast T e)) (compxE2 (Cast T e) 0 0) t h\n     s ta h' s'", "by auto"], ["", "lemma exec_move_Cast:\n  \"pc < length (compE2 e) \\<Longrightarrow> exec_move ci P t (Cast T e) h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (compE2 e) \\<Longrightarrow>\n    exec_move ci P t (Cast T e) h (stk, loc, pc, xcp) =\n    exec_move ci P t e h (stk, loc, pc, xcp)", "unfolding exec_move_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (compE2 e) \\<Longrightarrow>\n    exec_meth ci (compP2 P) (compE2 (Cast T e)) (compxE2 (Cast T e) 0 0) t h\n     (stk, loc, pc, xcp) =\n    exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h\n     (stk, loc, pc, xcp)", "by(auto intro!: ext intro: exec_meth_take)"], ["", "lemma exec_move_InstanceOfI:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (e instanceof T) h s ta h' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t e h s ta h' s' \\<Longrightarrow>\n    exec_move ci P t (e instanceof T) h s ta h' s'", "unfolding exec_move_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h s ta h'\n     s' \\<Longrightarrow>\n    exec_meth ci (compP2 P) (compE2 (e instanceof T))\n     (compxE2 (e instanceof T) 0 0) t h s ta h' s'", "by auto"], ["", "lemma exec_move_InstanceOf:\n  \"pc < length (compE2 e) \\<Longrightarrow> exec_move ci P t (e instanceof T) h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (compE2 e) \\<Longrightarrow>\n    exec_move ci P t (e instanceof T) h (stk, loc, pc, xcp) =\n    exec_move ci P t e h (stk, loc, pc, xcp)", "unfolding exec_move_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (compE2 e) \\<Longrightarrow>\n    exec_meth ci (compP2 P) (compE2 (e instanceof T))\n     (compxE2 (e instanceof T) 0 0) t h (stk, loc, pc, xcp) =\n    exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h\n     (stk, loc, pc, xcp)", "by(auto intro!: ext intro: exec_meth_take)"], ["", "lemma exec_move_BinOpI1:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (e \\<guillemotleft>bop\\<guillemotright> e') h s ta h' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t e h s ta h' s' \\<Longrightarrow>\n    exec_move ci P t (e \\<guillemotleft>bop\\<guillemotright> e') h s ta h'\n     s'", "unfolding exec_move_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h s ta h'\n     s' \\<Longrightarrow>\n    exec_meth ci (compP2 P)\n     (compE2 (e \\<guillemotleft>bop\\<guillemotright> e'))\n     (compxE2 (e \\<guillemotleft>bop\\<guillemotright> e') 0 0) t h s ta h'\n     s'", "by auto"], ["", "lemma exec_move_BinOp1:\n  \"pc < length (compE2 e) \\<Longrightarrow> exec_move ci P t (e \\<guillemotleft>bop\\<guillemotright> e') h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (compE2 e) \\<Longrightarrow>\n    exec_move ci P t (e \\<guillemotleft>bop\\<guillemotright> e') h\n     (stk, loc, pc, xcp) =\n    exec_move ci P t e h (stk, loc, pc, xcp)", "unfolding exec_move_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (compE2 e) \\<Longrightarrow>\n    exec_meth ci (compP2 P)\n     (compE2 (e \\<guillemotleft>bop\\<guillemotright> e'))\n     (compxE2 (e \\<guillemotleft>bop\\<guillemotright> e') 0 0) t h\n     (stk, loc, pc, xcp) =\n    exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h\n     (stk, loc, pc, xcp)", "by(auto intro!: ext intro: exec_meth_take_xt simp add: compxE2_size_convs)"], ["", "lemma exec_move_BinOpI2:\n  assumes exec: \"exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  shows \"exec_move ci P t (e1 \\<guillemotleft>bop\\<guillemotright> e2) h (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h' (stk' @ [v], loc', length (compE2 e1) + pc', xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t (e1 \\<guillemotleft>bop\\<guillemotright> e2) h\n     (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n     (stk' @ [v], loc', length (compE2 e1) + pc', xcp')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. exec_move ci P t (e1 \\<guillemotleft>bop\\<guillemotright> e2) h\n     (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n     (stk' @ [v], loc', length (compE2 e1) + pc', xcp')", "from exec"], ["proof (chain)\npicking this:\n  exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "have \"exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 0) t h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 0) t h\n     (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "unfolding exec_move_def"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 0) t h\n   (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 0) t h\n     (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "."], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 0) t h\n   (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (e1 \\<guillemotleft>bop\\<guillemotright> e2) h\n     (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n     (stk' @ [v], loc', length (compE2 e1) + pc', xcp')", "from exec_meth_stk_offer[OF this, where stk''=\"[v]\"]"], ["proof (chain)\npicking this:\n  exec_meth ci (compP2 P) (compE2 e2)\n   (stack_xlift (length [v]) (compxE2 e2 0 0)) t h (stk @ [v], loc, pc, xcp)\n   ta h' (stk' @ [v], loc', pc', xcp')", "show ?thesis"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e2)\n   (stack_xlift (length [v]) (compxE2 e2 0 0)) t h (stk @ [v], loc, pc, xcp)\n   ta h' (stk' @ [v], loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (e1 \\<guillemotleft>bop\\<guillemotright> e2) h\n     (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n     (stk' @ [v], loc', length (compE2 e1) + pc', xcp')", "by(fastforce split: bop.splits intro: append_exec_meth_xt simp add: exec_move_def compxE2_size_convs compxE2_stack_xlift_convs)"], ["proof (state)\nthis:\n  exec_move ci P t (e1 \\<guillemotleft>bop\\<guillemotright> e2) h\n   (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n   (stk' @ [v], loc', length (compE2 e1) + pc', xcp')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exec_move_LAssI:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (V := e) h s ta h' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t e h s ta h' s' \\<Longrightarrow>\n    exec_move ci P t (V:=e) h s ta h' s'", "unfolding exec_move_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h s ta h'\n     s' \\<Longrightarrow>\n    exec_meth ci (compP2 P) (compE2 (V:=e)) (compxE2 (V:=e) 0 0) t h s ta h'\n     s'", "by auto"], ["", "lemma exec_move_LAss:\n  \"pc < length (compE2 e) \\<Longrightarrow> exec_move ci P t (V := e) h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (compE2 e) \\<Longrightarrow>\n    exec_move ci P t (V:=e) h (stk, loc, pc, xcp) =\n    exec_move ci P t e h (stk, loc, pc, xcp)", "unfolding exec_move_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (compE2 e) \\<Longrightarrow>\n    exec_meth ci (compP2 P) (compE2 (V:=e)) (compxE2 (V:=e) 0 0) t h\n     (stk, loc, pc, xcp) =\n    exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h\n     (stk, loc, pc, xcp)", "by(auto intro!: ext intro: exec_meth_take)"], ["", "lemma exec_move_AAccI1:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (e\\<lfloor>e'\\<rceil>) h s ta h' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t e h s ta h' s' \\<Longrightarrow>\n    exec_move ci P t (e\\<lfloor>e'\\<rceil>) h s ta h' s'", "unfolding exec_move_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h s ta h'\n     s' \\<Longrightarrow>\n    exec_meth ci (compP2 P) (compE2 (e\\<lfloor>e'\\<rceil>))\n     (compxE2 (e\\<lfloor>e'\\<rceil>) 0 0) t h s ta h' s'", "by auto"], ["", "lemma exec_move_AAcc1:\n  \"pc < length (compE2 e) \\<Longrightarrow> exec_move ci P t (e\\<lfloor>e'\\<rceil>) h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (compE2 e) \\<Longrightarrow>\n    exec_move ci P t (e\\<lfloor>e'\\<rceil>) h (stk, loc, pc, xcp) =\n    exec_move ci P t e h (stk, loc, pc, xcp)", "unfolding exec_move_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (compE2 e) \\<Longrightarrow>\n    exec_meth ci (compP2 P) (compE2 (e\\<lfloor>e'\\<rceil>))\n     (compxE2 (e\\<lfloor>e'\\<rceil>) 0 0) t h (stk, loc, pc, xcp) =\n    exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h\n     (stk, loc, pc, xcp)", "by(auto intro!: ext intro: exec_meth_take_xt simp add: compxE2_size_convs)"], ["", "lemma exec_move_AAccI2:\n  assumes exec: \"exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  shows \"exec_move ci P t (e1\\<lfloor>e2\\<rceil>) h (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h' (stk' @ [v], loc', length (compE2 e1) + pc', xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t (e1\\<lfloor>e2\\<rceil>) h\n     (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n     (stk' @ [v], loc', length (compE2 e1) + pc', xcp')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. exec_move ci P t (e1\\<lfloor>e2\\<rceil>) h\n     (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n     (stk' @ [v], loc', length (compE2 e1) + pc', xcp')", "from exec"], ["proof (chain)\npicking this:\n  exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "have \"exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 0) t h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 0) t h\n     (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "unfolding exec_move_def"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 0) t h\n   (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 0) t h\n     (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "."], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 0) t h\n   (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (e1\\<lfloor>e2\\<rceil>) h\n     (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n     (stk' @ [v], loc', length (compE2 e1) + pc', xcp')", "from exec_meth_stk_offer[OF this, where stk''=\"[v]\"]"], ["proof (chain)\npicking this:\n  exec_meth ci (compP2 P) (compE2 e2)\n   (stack_xlift (length [v]) (compxE2 e2 0 0)) t h (stk @ [v], loc, pc, xcp)\n   ta h' (stk' @ [v], loc', pc', xcp')", "show ?thesis"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e2)\n   (stack_xlift (length [v]) (compxE2 e2 0 0)) t h (stk @ [v], loc, pc, xcp)\n   ta h' (stk' @ [v], loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (e1\\<lfloor>e2\\<rceil>) h\n     (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n     (stk' @ [v], loc', length (compE2 e1) + pc', xcp')", "by(fastforce intro: append_exec_meth_xt simp add: exec_move_def compxE2_size_convs compxE2_stack_xlift_convs)"], ["proof (state)\nthis:\n  exec_move ci P t (e1\\<lfloor>e2\\<rceil>) h\n   (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n   (stk' @ [v], loc', length (compE2 e1) + pc', xcp')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exec_move_AAssI1:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (e\\<lfloor>e'\\<rceil> := e'') h s ta h' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t e h s ta h' s' \\<Longrightarrow>\n    exec_move ci P t (e\\<lfloor>e'\\<rceil> := e'') h s ta h' s'", "unfolding exec_move_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h s ta h'\n     s' \\<Longrightarrow>\n    exec_meth ci (compP2 P) (compE2 (e\\<lfloor>e'\\<rceil> := e''))\n     (compxE2 (e\\<lfloor>e'\\<rceil> := e'') 0 0) t h s ta h' s'", "by auto"], ["", "lemma exec_move_AAss1:\n  assumes pc: \"pc < length (compE2 e)\"\n  shows \"exec_move ci P t (e\\<lfloor>e'\\<rceil> := e'') h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t (e\\<lfloor>e'\\<rceil> := e'') h (stk, loc, pc, xcp) =\n    exec_move ci P t e h (stk, loc, pc, xcp)", "proof(rule ext iffI)+"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       exec_move ci P t (e\\<lfloor>e'\\<rceil> := e'') h (stk, loc, pc, xcp)\n        x xa xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb\n 2. \\<And>x xa xb.\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t (e\\<lfloor>e'\\<rceil> := e'') h (stk, loc, pc, xcp)\n        x xa xb", "fix ta h' s'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       exec_move ci P t (e\\<lfloor>e'\\<rceil> := e'') h (stk, loc, pc, xcp)\n        x xa xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb\n 2. \\<And>x xa xb.\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t (e\\<lfloor>e'\\<rceil> := e'') h (stk, loc, pc, xcp)\n        x xa xb", "assume \"?rhs ta h' s'\""], ["proof (state)\nthis:\n  exec_move ci P t e h (stk, loc, pc, xcp) ta h' s'\n\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       exec_move ci P t (e\\<lfloor>e'\\<rceil> := e'') h (stk, loc, pc, xcp)\n        x xa xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb\n 2. \\<And>x xa xb.\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t (e\\<lfloor>e'\\<rceil> := e'') h (stk, loc, pc, xcp)\n        x xa xb", "thus \"?lhs ta h' s'\""], ["proof (prove)\nusing this:\n  exec_move ci P t e h (stk, loc, pc, xcp) ta h' s'\n\ngoal (1 subgoal):\n 1. exec_move ci P t (e\\<lfloor>e'\\<rceil> := e'') h (stk, loc, pc, xcp) ta\n     h' s'", "by(rule exec_move_AAssI1)"], ["proof (state)\nthis:\n  exec_move ci P t (e\\<lfloor>e'\\<rceil> := e'') h (stk, loc, pc, xcp) ta h'\n   s'\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       exec_move ci P t (e\\<lfloor>e'\\<rceil> := e'') h (stk, loc, pc, xcp)\n        x xa xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       exec_move ci P t (e\\<lfloor>e'\\<rceil> := e'') h (stk, loc, pc, xcp)\n        x xa xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb", "fix ta h' s'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       exec_move ci P t (e\\<lfloor>e'\\<rceil> := e'') h (stk, loc, pc, xcp)\n        x xa xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb", "assume \"?lhs ta h' s'\""], ["proof (state)\nthis:\n  exec_move ci P t (e\\<lfloor>e'\\<rceil> := e'') h (stk, loc, pc, xcp) ta h'\n   s'\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       exec_move ci P t (e\\<lfloor>e'\\<rceil> := e'') h (stk, loc, pc, xcp)\n        x xa xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb", "hence \"exec_meth ci (compP2 P) (compE2 e @ compE2 e' @ compE2 e'' @ [AStore, Push Unit])\n     (compxE2 e 0 0 @ shift (length (compE2 e)) (compxE2 e' 0 (Suc 0) @ compxE2 e'' (length (compE2 e')) (Suc (Suc 0)))) t\n     h (stk, loc, pc, xcp) ta h' s'\""], ["proof (prove)\nusing this:\n  exec_move ci P t (e\\<lfloor>e'\\<rceil> := e'') h (stk, loc, pc, xcp) ta h'\n   s'\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P)\n     (compE2 e @ compE2 e' @ compE2 e'' @ [AStore, Push Unit])\n     (compxE2 e 0 0 @\n      shift (length (compE2 e))\n       (compxE2 e' 0 (Suc 0) @\n        compxE2 e'' (length (compE2 e')) (Suc (Suc 0))))\n     t h (stk, loc, pc, xcp) ta h' s'", "by(simp add: exec_move_def shift_compxE2 ac_simps)"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P)\n   (compE2 e @ compE2 e' @ compE2 e'' @ [AStore, Push Unit])\n   (compxE2 e 0 0 @\n    shift (length (compE2 e))\n     (compxE2 e' 0 (Suc 0) @\n      compxE2 e'' (length (compE2 e')) (Suc (Suc 0))))\n   t h (stk, loc, pc, xcp) ta h' s'\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       exec_move ci P t (e\\<lfloor>e'\\<rceil> := e'') h (stk, loc, pc, xcp)\n        x xa xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb", "thus \"?rhs ta h' s'\""], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P)\n   (compE2 e @ compE2 e' @ compE2 e'' @ [AStore, Push Unit])\n   (compxE2 e 0 0 @\n    shift (length (compE2 e))\n     (compxE2 e' 0 (Suc 0) @\n      compxE2 e'' (length (compE2 e')) (Suc (Suc 0))))\n   t h (stk, loc, pc, xcp) ta h' s'\n\ngoal (1 subgoal):\n 1. exec_move ci P t e h (stk, loc, pc, xcp) ta h' s'", "unfolding exec_move_def"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P)\n   (compE2 e @ compE2 e' @ compE2 e'' @ [AStore, Push Unit])\n   (compxE2 e 0 0 @\n    shift (length (compE2 e))\n     (compxE2 e' 0 (Suc 0) @\n      compxE2 e'' (length (compE2 e')) (Suc (Suc 0))))\n   t h (stk, loc, pc, xcp) ta h' s'\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h\n     (stk, loc, pc, xcp) ta h' s'", "using pc"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P)\n   (compE2 e @ compE2 e' @ compE2 e'' @ [AStore, Push Unit])\n   (compxE2 e 0 0 @\n    shift (length (compE2 e))\n     (compxE2 e' 0 (Suc 0) @\n      compxE2 e'' (length (compE2 e')) (Suc (Suc 0))))\n   t h (stk, loc, pc, xcp) ta h' s'\n  pc < length (compE2 e)\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h\n     (stk, loc, pc, xcp) ta h' s'", "by(rule exec_meth_take_xt)"], ["proof (state)\nthis:\n  exec_move ci P t e h (stk, loc, pc, xcp) ta h' s'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exec_move_AAssI2:\n  assumes exec: \"exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  shows \"exec_move ci P t (e1\\<lfloor>e2\\<rceil> := e3) h (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h' (stk' @ [v], loc', length (compE2 e1) + pc', xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t (e1\\<lfloor>e2\\<rceil> := e3) h\n     (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n     (stk' @ [v], loc', length (compE2 e1) + pc', xcp')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. exec_move ci P t (e1\\<lfloor>e2\\<rceil> := e3) h\n     (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n     (stk' @ [v], loc', length (compE2 e1) + pc', xcp')", "from exec"], ["proof (chain)\npicking this:\n  exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "have \"exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 0) t h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 0) t h\n     (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "unfolding exec_move_def"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 0) t h\n   (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 0) t h\n     (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "."], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 0) t h\n   (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (e1\\<lfloor>e2\\<rceil> := e3) h\n     (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n     (stk' @ [v], loc', length (compE2 e1) + pc', xcp')", "from exec_meth_stk_offer[OF this, where stk''=\"[v]\", simplified stack_xlift_compxE2, simplified]"], ["proof (chain)\npicking this:\n  exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 (Suc 0)) t h\n   (stk @ [v], loc, pc, xcp) ta h' (stk' @ [v], loc', pc', xcp')", "have \"exec_meth ci (compP2 P) (compE2 e2 @ compE2 e3 @ [AStore, Push Unit]) (compxE2 e2 0 (Suc 0) @ shift (length (compE2 e2)) (compxE2 e3 0 (Suc (Suc 0)))) t h (stk @ [v], loc, pc, xcp) ta h' (stk' @ [v], loc', pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 (Suc 0)) t h\n   (stk @ [v], loc, pc, xcp) ta h' (stk' @ [v], loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e2 @ compE2 e3 @ [AStore, Push Unit])\n     (compxE2 e2 0 (Suc 0) @\n      shift (length (compE2 e2)) (compxE2 e3 0 (Suc (Suc 0))))\n     t h (stk @ [v], loc, pc, xcp) ta h' (stk' @ [v], loc', pc', xcp')", "by(rule exec_meth_append_xt)"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) (compE2 e2 @ compE2 e3 @ [AStore, Push Unit])\n   (compxE2 e2 0 (Suc 0) @\n    shift (length (compE2 e2)) (compxE2 e3 0 (Suc (Suc 0))))\n   t h (stk @ [v], loc, pc, xcp) ta h' (stk' @ [v], loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (e1\\<lfloor>e2\\<rceil> := e3) h\n     (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n     (stk' @ [v], loc', length (compE2 e1) + pc', xcp')", "hence \"exec_meth ci (compP2 P) (compE2 e1 @ compE2 e2 @ compE2 e3 @ [AStore, Push Unit]) (compxE2 e1 0 0 @ shift (length (compE2 e1)) (compxE2 e2 0 (Suc 0) @ shift (length (compE2 e2)) (compxE2 e3 0 (Suc (Suc 0))))) t h (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h' (stk' @ [v], loc', length (compE2 e1) + pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e2 @ compE2 e3 @ [AStore, Push Unit])\n   (compxE2 e2 0 (Suc 0) @\n    shift (length (compE2 e2)) (compxE2 e3 0 (Suc (Suc 0))))\n   t h (stk @ [v], loc, pc, xcp) ta h' (stk' @ [v], loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P)\n     (compE2 e1 @ compE2 e2 @ compE2 e3 @ [AStore, Push Unit])\n     (compxE2 e1 0 0 @\n      shift (length (compE2 e1))\n       (compxE2 e2 0 (Suc 0) @\n        shift (length (compE2 e2)) (compxE2 e3 0 (Suc (Suc 0)))))\n     t h (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n     (stk' @ [v], loc', length (compE2 e1) + pc', xcp')", "by(rule append_exec_meth_xt) auto"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P)\n   (compE2 e1 @ compE2 e2 @ compE2 e3 @ [AStore, Push Unit])\n   (compxE2 e1 0 0 @\n    shift (length (compE2 e1))\n     (compxE2 e2 0 (Suc 0) @\n      shift (length (compE2 e2)) (compxE2 e3 0 (Suc (Suc 0)))))\n   t h (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n   (stk' @ [v], loc', length (compE2 e1) + pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (e1\\<lfloor>e2\\<rceil> := e3) h\n     (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n     (stk' @ [v], loc', length (compE2 e1) + pc', xcp')", "thus ?thesis"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P)\n   (compE2 e1 @ compE2 e2 @ compE2 e3 @ [AStore, Push Unit])\n   (compxE2 e1 0 0 @\n    shift (length (compE2 e1))\n     (compxE2 e2 0 (Suc 0) @\n      shift (length (compE2 e2)) (compxE2 e3 0 (Suc (Suc 0)))))\n   t h (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n   (stk' @ [v], loc', length (compE2 e1) + pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (e1\\<lfloor>e2\\<rceil> := e3) h\n     (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n     (stk' @ [v], loc', length (compE2 e1) + pc', xcp')", "by(auto simp add: exec_move_def shift_compxE2 ac_simps)"], ["proof (state)\nthis:\n  exec_move ci P t (e1\\<lfloor>e2\\<rceil> := e3) h\n   (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n   (stk' @ [v], loc', length (compE2 e1) + pc', xcp')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exec_move_AAssI3:\n  assumes exec: \"exec_move ci P t e3 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  shows \"exec_move ci P t (e1\\<lfloor>e2\\<rceil> := e3) h (stk @ [v', v], loc, length (compE2 e1) + length (compE2 e2) + pc, xcp) ta h' (stk' @ [v', v], loc', length (compE2 e1) + length (compE2 e2) + pc', xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t (e1\\<lfloor>e2\\<rceil> := e3) h\n     (stk @ [v', v], loc, length (compE2 e1) + length (compE2 e2) + pc, xcp)\n     ta h'\n     (stk' @ [v', v], loc', length (compE2 e1) + length (compE2 e2) + pc',\n      xcp')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. exec_move ci P t (e1\\<lfloor>e2\\<rceil> := e3) h\n     (stk @ [v', v], loc, length (compE2 e1) + length (compE2 e2) + pc, xcp)\n     ta h'\n     (stk' @ [v', v], loc', length (compE2 e1) + length (compE2 e2) + pc',\n      xcp')", "from exec"], ["proof (chain)\npicking this:\n  exec_move ci P t e3 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "have \"exec_meth ci (compP2 P) (compE2 e3) (compxE2 e3 0 0) t h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_move ci P t e3 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e3) (compxE2 e3 0 0) t h\n     (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "unfolding exec_move_def"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e3) (compxE2 e3 0 0) t h\n   (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e3) (compxE2 e3 0 0) t h\n     (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "."], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) (compE2 e3) (compxE2 e3 0 0) t h\n   (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (e1\\<lfloor>e2\\<rceil> := e3) h\n     (stk @ [v', v], loc, length (compE2 e1) + length (compE2 e2) + pc, xcp)\n     ta h'\n     (stk' @ [v', v], loc', length (compE2 e1) + length (compE2 e2) + pc',\n      xcp')", "from exec_meth_stk_offer[OF this, where stk''=\"[v', v]\", simplified stack_xlift_compxE2, simplified]"], ["proof (chain)\npicking this:\n  exec_meth ci (compP2 P) (compE2 e3) (compxE2 e3 0 (Suc (Suc 0))) t h\n   (stk @ [v', v], loc, pc, xcp) ta h' (stk' @ [v', v], loc', pc', xcp')", "have \"exec_meth ci (compP2 P) (compE2 e3 @ [AStore, Push Unit]) (compxE2 e3 0 (Suc (Suc 0))) t h (stk @ [v', v], loc, pc, xcp) ta h' (stk' @ [v', v], loc', pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e3) (compxE2 e3 0 (Suc (Suc 0))) t h\n   (stk @ [v', v], loc, pc, xcp) ta h' (stk' @ [v', v], loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e3 @ [AStore, Push Unit])\n     (compxE2 e3 0 (Suc (Suc 0))) t h (stk @ [v', v], loc, pc, xcp) ta h'\n     (stk' @ [v', v], loc', pc', xcp')", "by(rule exec_meth_append)"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) (compE2 e3 @ [AStore, Push Unit])\n   (compxE2 e3 0 (Suc (Suc 0))) t h (stk @ [v', v], loc, pc, xcp) ta h'\n   (stk' @ [v', v], loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (e1\\<lfloor>e2\\<rceil> := e3) h\n     (stk @ [v', v], loc, length (compE2 e1) + length (compE2 e2) + pc, xcp)\n     ta h'\n     (stk' @ [v', v], loc', length (compE2 e1) + length (compE2 e2) + pc',\n      xcp')", "hence \"exec_meth ci (compP2 P) ((compE2 e1 @ compE2 e2) @ compE2 e3 @ [AStore, Push Unit]) \n                   ((compxE2 e1 0 0 @ compxE2 e2 (length (compE2 e1)) (Suc 0)) @ shift (length (compE2 e1 @ compE2 e2)) (compxE2 e3 0 (Suc (Suc 0)))) t h (stk @ [v', v], loc, length (compE2 e1 @ compE2 e2) + pc, xcp) ta h' (stk' @ [v', v], loc', length (compE2 e1 @ compE2 e2) + pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e3 @ [AStore, Push Unit])\n   (compxE2 e3 0 (Suc (Suc 0))) t h (stk @ [v', v], loc, pc, xcp) ta h'\n   (stk' @ [v', v], loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P)\n     ((compE2 e1 @ compE2 e2) @ compE2 e3 @ [AStore, Push Unit])\n     ((compxE2 e1 0 0 @ compxE2 e2 (length (compE2 e1)) (Suc 0)) @\n      shift (length (compE2 e1 @ compE2 e2)) (compxE2 e3 0 (Suc (Suc 0))))\n     t h (stk @ [v', v], loc, length (compE2 e1 @ compE2 e2) + pc, xcp) ta\n     h' (stk' @ [v', v], loc', length (compE2 e1 @ compE2 e2) + pc', xcp')", "by(rule append_exec_meth_xt) auto"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P)\n   ((compE2 e1 @ compE2 e2) @ compE2 e3 @ [AStore, Push Unit])\n   ((compxE2 e1 0 0 @ compxE2 e2 (length (compE2 e1)) (Suc 0)) @\n    shift (length (compE2 e1 @ compE2 e2)) (compxE2 e3 0 (Suc (Suc 0))))\n   t h (stk @ [v', v], loc, length (compE2 e1 @ compE2 e2) + pc, xcp) ta h'\n   (stk' @ [v', v], loc', length (compE2 e1 @ compE2 e2) + pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (e1\\<lfloor>e2\\<rceil> := e3) h\n     (stk @ [v', v], loc, length (compE2 e1) + length (compE2 e2) + pc, xcp)\n     ta h'\n     (stk' @ [v', v], loc', length (compE2 e1) + length (compE2 e2) + pc',\n      xcp')", "thus ?thesis"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P)\n   ((compE2 e1 @ compE2 e2) @ compE2 e3 @ [AStore, Push Unit])\n   ((compxE2 e1 0 0 @ compxE2 e2 (length (compE2 e1)) (Suc 0)) @\n    shift (length (compE2 e1 @ compE2 e2)) (compxE2 e3 0 (Suc (Suc 0))))\n   t h (stk @ [v', v], loc, length (compE2 e1 @ compE2 e2) + pc, xcp) ta h'\n   (stk' @ [v', v], loc', length (compE2 e1 @ compE2 e2) + pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (e1\\<lfloor>e2\\<rceil> := e3) h\n     (stk @ [v', v], loc, length (compE2 e1) + length (compE2 e2) + pc, xcp)\n     ta h'\n     (stk' @ [v', v], loc', length (compE2 e1) + length (compE2 e2) + pc',\n      xcp')", "by(auto simp add: exec_move_def shift_compxE2 ac_simps)"], ["proof (state)\nthis:\n  exec_move ci P t (e1\\<lfloor>e2\\<rceil> := e3) h\n   (stk @ [v', v], loc, length (compE2 e1) + length (compE2 e2) + pc, xcp)\n   ta h'\n   (stk' @ [v', v], loc', length (compE2 e1) + length (compE2 e2) + pc',\n    xcp')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exec_move_ALengthI:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (e\\<bullet>length) h s ta h' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t e h s ta h' s' \\<Longrightarrow>\n    exec_move ci P t (e\\<bullet>length) h s ta h' s'", "unfolding exec_move_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h s ta h'\n     s' \\<Longrightarrow>\n    exec_meth ci (compP2 P) (compE2 (e\\<bullet>length))\n     (compxE2 (e\\<bullet>length) 0 0) t h s ta h' s'", "by auto"], ["", "lemma exec_move_ALength:\n  \"pc < length (compE2 e) \\<Longrightarrow> exec_move ci P t (e\\<bullet>length) h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (compE2 e) \\<Longrightarrow>\n    exec_move ci P t (e\\<bullet>length) h (stk, loc, pc, xcp) =\n    exec_move ci P t e h (stk, loc, pc, xcp)", "unfolding exec_move_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (compE2 e) \\<Longrightarrow>\n    exec_meth ci (compP2 P) (compE2 (e\\<bullet>length))\n     (compxE2 (e\\<bullet>length) 0 0) t h (stk, loc, pc, xcp) =\n    exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h\n     (stk, loc, pc, xcp)", "by(auto intro!: ext intro: exec_meth_take)"], ["", "lemma exec_move_FAccI:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (e\\<bullet>F{D}) h s ta h' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t e h s ta h' s' \\<Longrightarrow>\n    exec_move ci P t (e\\<bullet>F{D}) h s ta h' s'", "unfolding exec_move_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h s ta h'\n     s' \\<Longrightarrow>\n    exec_meth ci (compP2 P) (compE2 (e\\<bullet>F{D}))\n     (compxE2 (e\\<bullet>F{D}) 0 0) t h s ta h' s'", "by auto"], ["", "lemma exec_move_FAcc:\n  \"pc < length (compE2 e) \\<Longrightarrow> exec_move ci P t (e\\<bullet>F{D}) h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (compE2 e) \\<Longrightarrow>\n    exec_move ci P t (e\\<bullet>F{D}) h (stk, loc, pc, xcp) =\n    exec_move ci P t e h (stk, loc, pc, xcp)", "unfolding exec_move_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (compE2 e) \\<Longrightarrow>\n    exec_meth ci (compP2 P) (compE2 (e\\<bullet>F{D}))\n     (compxE2 (e\\<bullet>F{D}) 0 0) t h (stk, loc, pc, xcp) =\n    exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h\n     (stk, loc, pc, xcp)", "by(auto intro!: ext intro: exec_meth_take)"], ["", "lemma exec_move_FAssI1:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (e\\<bullet>F{D} := e') h s ta h' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t e h s ta h' s' \\<Longrightarrow>\n    exec_move ci P t (e\\<bullet>F{D} := e') h s ta h' s'", "unfolding exec_move_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h s ta h'\n     s' \\<Longrightarrow>\n    exec_meth ci (compP2 P) (compE2 (e\\<bullet>F{D} := e'))\n     (compxE2 (e\\<bullet>F{D} := e') 0 0) t h s ta h' s'", "by auto"], ["", "lemma exec_move_FAss1:\n  \"pc < length (compE2 e) \\<Longrightarrow> exec_move ci P t (e\\<bullet>F{D} := e') h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (compE2 e) \\<Longrightarrow>\n    exec_move ci P t (e\\<bullet>F{D} := e') h (stk, loc, pc, xcp) =\n    exec_move ci P t e h (stk, loc, pc, xcp)", "unfolding exec_move_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (compE2 e) \\<Longrightarrow>\n    exec_meth ci (compP2 P) (compE2 (e\\<bullet>F{D} := e'))\n     (compxE2 (e\\<bullet>F{D} := e') 0 0) t h (stk, loc, pc, xcp) =\n    exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h\n     (stk, loc, pc, xcp)", "by(auto intro!: ext intro: exec_meth_take_xt simp add: compxE2_size_convs)"], ["", "lemma exec_move_FAssI2:\n  assumes exec: \"exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  shows \"exec_move ci P t (e1\\<bullet>F{D} := e2) h (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h' (stk' @ [v], loc', length (compE2 e1) + pc', xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t (e1\\<bullet>F{D} := e2) h\n     (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n     (stk' @ [v], loc', length (compE2 e1) + pc', xcp')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. exec_move ci P t (e1\\<bullet>F{D} := e2) h\n     (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n     (stk' @ [v], loc', length (compE2 e1) + pc', xcp')", "from exec"], ["proof (chain)\npicking this:\n  exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "have \"exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 0) t h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 0) t h\n     (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "unfolding exec_move_def"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 0) t h\n   (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 0) t h\n     (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "."], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 0) t h\n   (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (e1\\<bullet>F{D} := e2) h\n     (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n     (stk' @ [v], loc', length (compE2 e1) + pc', xcp')", "from exec_meth_stk_offer[OF this, where stk''=\"[v]\"]"], ["proof (chain)\npicking this:\n  exec_meth ci (compP2 P) (compE2 e2)\n   (stack_xlift (length [v]) (compxE2 e2 0 0)) t h (stk @ [v], loc, pc, xcp)\n   ta h' (stk' @ [v], loc', pc', xcp')", "show ?thesis"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e2)\n   (stack_xlift (length [v]) (compxE2 e2 0 0)) t h (stk @ [v], loc, pc, xcp)\n   ta h' (stk' @ [v], loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (e1\\<bullet>F{D} := e2) h\n     (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n     (stk' @ [v], loc', length (compE2 e1) + pc', xcp')", "by(fastforce intro: append_exec_meth_xt simp add: exec_move_def compxE2_size_convs compxE2_stack_xlift_convs)"], ["proof (state)\nthis:\n  exec_move ci P t (e1\\<bullet>F{D} := e2) h\n   (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n   (stk' @ [v], loc', length (compE2 e1) + pc', xcp')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exec_move_CASI1:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h s ta h' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t e h s ta h' s' \\<Longrightarrow>\n    exec_move ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h s ta\n     h' s'", "unfolding exec_move_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h s ta h'\n     s' \\<Longrightarrow>\n    exec_meth ci (compP2 P)\n     (compE2 (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')))\n     (compxE2 (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) 0 0) t h s ta\n     h' s'", "by auto"], ["", "lemma exec_move_CAS1:\n  assumes pc: \"pc < length (compE2 e)\"\n  shows \"exec_move ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h\n     (stk, loc, pc, xcp) =\n    exec_move ci P t e h (stk, loc, pc, xcp)", "proof(rule ext iffI)+"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       exec_move ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h\n        (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb\n 2. \\<And>x xa xb.\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h\n        (stk, loc, pc, xcp) x xa xb", "fix ta h' s'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       exec_move ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h\n        (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb\n 2. \\<And>x xa xb.\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h\n        (stk, loc, pc, xcp) x xa xb", "assume \"?rhs ta h' s'\""], ["proof (state)\nthis:\n  exec_move ci P t e h (stk, loc, pc, xcp) ta h' s'\n\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       exec_move ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h\n        (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb\n 2. \\<And>x xa xb.\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h\n        (stk, loc, pc, xcp) x xa xb", "thus \"?lhs ta h' s'\""], ["proof (prove)\nusing this:\n  exec_move ci P t e h (stk, loc, pc, xcp) ta h' s'\n\ngoal (1 subgoal):\n 1. exec_move ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h\n     (stk, loc, pc, xcp) ta h' s'", "by(rule exec_move_CASI1)"], ["proof (state)\nthis:\n  exec_move ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h\n   (stk, loc, pc, xcp) ta h' s'\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       exec_move ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h\n        (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       exec_move ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h\n        (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb", "fix ta h' s'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       exec_move ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h\n        (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb", "assume \"?lhs ta h' s'\""], ["proof (state)\nthis:\n  exec_move ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h\n   (stk, loc, pc, xcp) ta h' s'\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       exec_move ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h\n        (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb", "hence \"exec_meth ci (compP2 P) (compE2 e @ compE2 e' @ compE2 e'' @ [CAS F D])\n     (compxE2 e 0 0 @ shift (length (compE2 e)) (compxE2 e' 0 (Suc 0) @ compxE2 e'' (length (compE2 e')) (Suc (Suc 0)))) t\n     h (stk, loc, pc, xcp) ta h' s'\""], ["proof (prove)\nusing this:\n  exec_move ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h\n   (stk, loc, pc, xcp) ta h' s'\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e @ compE2 e' @ compE2 e'' @ [CAS F D])\n     (compxE2 e 0 0 @\n      shift (length (compE2 e))\n       (compxE2 e' 0 (Suc 0) @\n        compxE2 e'' (length (compE2 e')) (Suc (Suc 0))))\n     t h (stk, loc, pc, xcp) ta h' s'", "by(simp add: exec_move_def shift_compxE2 ac_simps)"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) (compE2 e @ compE2 e' @ compE2 e'' @ [CAS F D])\n   (compxE2 e 0 0 @\n    shift (length (compE2 e))\n     (compxE2 e' 0 (Suc 0) @\n      compxE2 e'' (length (compE2 e')) (Suc (Suc 0))))\n   t h (stk, loc, pc, xcp) ta h' s'\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       exec_move ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h\n        (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb", "thus \"?rhs ta h' s'\""], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e @ compE2 e' @ compE2 e'' @ [CAS F D])\n   (compxE2 e 0 0 @\n    shift (length (compE2 e))\n     (compxE2 e' 0 (Suc 0) @\n      compxE2 e'' (length (compE2 e')) (Suc (Suc 0))))\n   t h (stk, loc, pc, xcp) ta h' s'\n\ngoal (1 subgoal):\n 1. exec_move ci P t e h (stk, loc, pc, xcp) ta h' s'", "unfolding exec_move_def"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e @ compE2 e' @ compE2 e'' @ [CAS F D])\n   (compxE2 e 0 0 @\n    shift (length (compE2 e))\n     (compxE2 e' 0 (Suc 0) @\n      compxE2 e'' (length (compE2 e')) (Suc (Suc 0))))\n   t h (stk, loc, pc, xcp) ta h' s'\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h\n     (stk, loc, pc, xcp) ta h' s'", "using pc"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e @ compE2 e' @ compE2 e'' @ [CAS F D])\n   (compxE2 e 0 0 @\n    shift (length (compE2 e))\n     (compxE2 e' 0 (Suc 0) @\n      compxE2 e'' (length (compE2 e')) (Suc (Suc 0))))\n   t h (stk, loc, pc, xcp) ta h' s'\n  pc < length (compE2 e)\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h\n     (stk, loc, pc, xcp) ta h' s'", "by(rule exec_meth_take_xt)"], ["proof (state)\nthis:\n  exec_move ci P t e h (stk, loc, pc, xcp) ta h' s'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exec_move_CASI2:\n  assumes exec: \"exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  shows \"exec_move ci P t (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) h (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h' (stk' @ [v], loc', length (compE2 e1) + pc', xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) h\n     (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n     (stk' @ [v], loc', length (compE2 e1) + pc', xcp')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. exec_move ci P t (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) h\n     (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n     (stk' @ [v], loc', length (compE2 e1) + pc', xcp')", "from exec"], ["proof (chain)\npicking this:\n  exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "have \"exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 0) t h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 0) t h\n     (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "unfolding exec_move_def"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 0) t h\n   (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 0) t h\n     (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "."], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 0) t h\n   (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) h\n     (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n     (stk' @ [v], loc', length (compE2 e1) + pc', xcp')", "from exec_meth_stk_offer[OF this, where stk''=\"[v]\", simplified stack_xlift_compxE2, simplified]"], ["proof (chain)\npicking this:\n  exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 (Suc 0)) t h\n   (stk @ [v], loc, pc, xcp) ta h' (stk' @ [v], loc', pc', xcp')", "have \"exec_meth ci (compP2 P) (compE2 e2 @ compE2 e3 @ [CAS F D]) (compxE2 e2 0 (Suc 0) @ shift (length (compE2 e2)) (compxE2 e3 0 (Suc (Suc 0)))) t h (stk @ [v], loc, pc, xcp) ta h' (stk' @ [v], loc', pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 (Suc 0)) t h\n   (stk @ [v], loc, pc, xcp) ta h' (stk' @ [v], loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e2 @ compE2 e3 @ [CAS F D])\n     (compxE2 e2 0 (Suc 0) @\n      shift (length (compE2 e2)) (compxE2 e3 0 (Suc (Suc 0))))\n     t h (stk @ [v], loc, pc, xcp) ta h' (stk' @ [v], loc', pc', xcp')", "by(rule exec_meth_append_xt)"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) (compE2 e2 @ compE2 e3 @ [CAS F D])\n   (compxE2 e2 0 (Suc 0) @\n    shift (length (compE2 e2)) (compxE2 e3 0 (Suc (Suc 0))))\n   t h (stk @ [v], loc, pc, xcp) ta h' (stk' @ [v], loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) h\n     (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n     (stk' @ [v], loc', length (compE2 e1) + pc', xcp')", "hence \"exec_meth ci (compP2 P) (compE2 e1 @ compE2 e2 @ compE2 e3 @ [CAS F D]) (compxE2 e1 0 0 @ shift (length (compE2 e1)) (compxE2 e2 0 (Suc 0) @ shift (length (compE2 e2)) (compxE2 e3 0 (Suc (Suc 0))))) t h (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h' (stk' @ [v], loc', length (compE2 e1) + pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e2 @ compE2 e3 @ [CAS F D])\n   (compxE2 e2 0 (Suc 0) @\n    shift (length (compE2 e2)) (compxE2 e3 0 (Suc (Suc 0))))\n   t h (stk @ [v], loc, pc, xcp) ta h' (stk' @ [v], loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e1 @ compE2 e2 @ compE2 e3 @ [CAS F D])\n     (compxE2 e1 0 0 @\n      shift (length (compE2 e1))\n       (compxE2 e2 0 (Suc 0) @\n        shift (length (compE2 e2)) (compxE2 e3 0 (Suc (Suc 0)))))\n     t h (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n     (stk' @ [v], loc', length (compE2 e1) + pc', xcp')", "by(rule append_exec_meth_xt) auto"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) (compE2 e1 @ compE2 e2 @ compE2 e3 @ [CAS F D])\n   (compxE2 e1 0 0 @\n    shift (length (compE2 e1))\n     (compxE2 e2 0 (Suc 0) @\n      shift (length (compE2 e2)) (compxE2 e3 0 (Suc (Suc 0)))))\n   t h (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n   (stk' @ [v], loc', length (compE2 e1) + pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) h\n     (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n     (stk' @ [v], loc', length (compE2 e1) + pc', xcp')", "thus ?thesis"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e1 @ compE2 e2 @ compE2 e3 @ [CAS F D])\n   (compxE2 e1 0 0 @\n    shift (length (compE2 e1))\n     (compxE2 e2 0 (Suc 0) @\n      shift (length (compE2 e2)) (compxE2 e3 0 (Suc (Suc 0)))))\n   t h (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n   (stk' @ [v], loc', length (compE2 e1) + pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) h\n     (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n     (stk' @ [v], loc', length (compE2 e1) + pc', xcp')", "by(auto simp add: exec_move_def shift_compxE2 ac_simps)"], ["proof (state)\nthis:\n  exec_move ci P t (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) h\n   (stk @ [v], loc, length (compE2 e1) + pc, xcp) ta h'\n   (stk' @ [v], loc', length (compE2 e1) + pc', xcp')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exec_move_CASI3:\n  assumes exec: \"exec_move ci P t e3 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  shows \"exec_move ci P t (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) h (stk @ [v', v], loc, length (compE2 e1) + length (compE2 e2) + pc, xcp) ta h' (stk' @ [v', v], loc', length (compE2 e1) + length (compE2 e2) + pc', xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) h\n     (stk @ [v', v], loc, length (compE2 e1) + length (compE2 e2) + pc, xcp)\n     ta h'\n     (stk' @ [v', v], loc', length (compE2 e1) + length (compE2 e2) + pc',\n      xcp')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. exec_move ci P t (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) h\n     (stk @ [v', v], loc, length (compE2 e1) + length (compE2 e2) + pc, xcp)\n     ta h'\n     (stk' @ [v', v], loc', length (compE2 e1) + length (compE2 e2) + pc',\n      xcp')", "from exec"], ["proof (chain)\npicking this:\n  exec_move ci P t e3 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "have \"exec_meth ci (compP2 P) (compE2 e3) (compxE2 e3 0 0) t h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_move ci P t e3 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e3) (compxE2 e3 0 0) t h\n     (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "unfolding exec_move_def"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e3) (compxE2 e3 0 0) t h\n   (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e3) (compxE2 e3 0 0) t h\n     (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "."], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) (compE2 e3) (compxE2 e3 0 0) t h\n   (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) h\n     (stk @ [v', v], loc, length (compE2 e1) + length (compE2 e2) + pc, xcp)\n     ta h'\n     (stk' @ [v', v], loc', length (compE2 e1) + length (compE2 e2) + pc',\n      xcp')", "from exec_meth_stk_offer[OF this, where stk''=\"[v', v]\", simplified stack_xlift_compxE2, simplified]"], ["proof (chain)\npicking this:\n  exec_meth ci (compP2 P) (compE2 e3) (compxE2 e3 0 (Suc (Suc 0))) t h\n   (stk @ [v', v], loc, pc, xcp) ta h' (stk' @ [v', v], loc', pc', xcp')", "have \"exec_meth ci (compP2 P) (compE2 e3 @ [CAS F D]) (compxE2 e3 0 (Suc (Suc 0))) t h (stk @ [v', v], loc, pc, xcp) ta h' (stk' @ [v', v], loc', pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e3) (compxE2 e3 0 (Suc (Suc 0))) t h\n   (stk @ [v', v], loc, pc, xcp) ta h' (stk' @ [v', v], loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e3 @ [CAS F D])\n     (compxE2 e3 0 (Suc (Suc 0))) t h (stk @ [v', v], loc, pc, xcp) ta h'\n     (stk' @ [v', v], loc', pc', xcp')", "by(rule exec_meth_append)"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) (compE2 e3 @ [CAS F D])\n   (compxE2 e3 0 (Suc (Suc 0))) t h (stk @ [v', v], loc, pc, xcp) ta h'\n   (stk' @ [v', v], loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) h\n     (stk @ [v', v], loc, length (compE2 e1) + length (compE2 e2) + pc, xcp)\n     ta h'\n     (stk' @ [v', v], loc', length (compE2 e1) + length (compE2 e2) + pc',\n      xcp')", "hence \"exec_meth ci (compP2 P) ((compE2 e1 @ compE2 e2) @ compE2 e3 @ [CAS F D]) \n                   ((compxE2 e1 0 0 @ compxE2 e2 (length (compE2 e1)) (Suc 0)) @ shift (length (compE2 e1 @ compE2 e2)) (compxE2 e3 0 (Suc (Suc 0)))) t h (stk @ [v', v], loc, length (compE2 e1 @ compE2 e2) + pc, xcp) ta h' (stk' @ [v', v], loc', length (compE2 e1 @ compE2 e2) + pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e3 @ [CAS F D])\n   (compxE2 e3 0 (Suc (Suc 0))) t h (stk @ [v', v], loc, pc, xcp) ta h'\n   (stk' @ [v', v], loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P)\n     ((compE2 e1 @ compE2 e2) @ compE2 e3 @ [CAS F D])\n     ((compxE2 e1 0 0 @ compxE2 e2 (length (compE2 e1)) (Suc 0)) @\n      shift (length (compE2 e1 @ compE2 e2)) (compxE2 e3 0 (Suc (Suc 0))))\n     t h (stk @ [v', v], loc, length (compE2 e1 @ compE2 e2) + pc, xcp) ta\n     h' (stk' @ [v', v], loc', length (compE2 e1 @ compE2 e2) + pc', xcp')", "by(rule append_exec_meth_xt) auto"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) ((compE2 e1 @ compE2 e2) @ compE2 e3 @ [CAS F D])\n   ((compxE2 e1 0 0 @ compxE2 e2 (length (compE2 e1)) (Suc 0)) @\n    shift (length (compE2 e1 @ compE2 e2)) (compxE2 e3 0 (Suc (Suc 0))))\n   t h (stk @ [v', v], loc, length (compE2 e1 @ compE2 e2) + pc, xcp) ta h'\n   (stk' @ [v', v], loc', length (compE2 e1 @ compE2 e2) + pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) h\n     (stk @ [v', v], loc, length (compE2 e1) + length (compE2 e2) + pc, xcp)\n     ta h'\n     (stk' @ [v', v], loc', length (compE2 e1) + length (compE2 e2) + pc',\n      xcp')", "thus ?thesis"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) ((compE2 e1 @ compE2 e2) @ compE2 e3 @ [CAS F D])\n   ((compxE2 e1 0 0 @ compxE2 e2 (length (compE2 e1)) (Suc 0)) @\n    shift (length (compE2 e1 @ compE2 e2)) (compxE2 e3 0 (Suc (Suc 0))))\n   t h (stk @ [v', v], loc, length (compE2 e1 @ compE2 e2) + pc, xcp) ta h'\n   (stk' @ [v', v], loc', length (compE2 e1 @ compE2 e2) + pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) h\n     (stk @ [v', v], loc, length (compE2 e1) + length (compE2 e2) + pc, xcp)\n     ta h'\n     (stk' @ [v', v], loc', length (compE2 e1) + length (compE2 e2) + pc',\n      xcp')", "by(auto simp add: exec_move_def shift_compxE2 ac_simps)"], ["proof (state)\nthis:\n  exec_move ci P t (e1\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3)) h\n   (stk @ [v', v], loc, length (compE2 e1) + length (compE2 e2) + pc, xcp)\n   ta h'\n   (stk' @ [v', v], loc', length (compE2 e1) + length (compE2 e2) + pc',\n    xcp')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exec_move_CallI1:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (e\\<bullet>M(es)) h s ta h' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t e h s ta h' s' \\<Longrightarrow>\n    exec_move ci P t (e\\<bullet>M(es)) h s ta h' s'", "unfolding exec_move_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h s ta h'\n     s' \\<Longrightarrow>\n    exec_meth ci (compP2 P) (compE2 (e\\<bullet>M(es)))\n     (compxE2 (e\\<bullet>M(es)) 0 0) t h s ta h' s'", "by auto"], ["", "lemma exec_move_Call1:\n  \"pc < length (compE2 e) \\<Longrightarrow> exec_move ci P t (e\\<bullet>M(es)) h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (compE2 e) \\<Longrightarrow>\n    exec_move ci P t (e\\<bullet>M(es)) h (stk, loc, pc, xcp) =\n    exec_move ci P t e h (stk, loc, pc, xcp)", "unfolding exec_move_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (compE2 e) \\<Longrightarrow>\n    exec_meth ci (compP2 P) (compE2 (e\\<bullet>M(es)))\n     (compxE2 (e\\<bullet>M(es)) 0 0) t h (stk, loc, pc, xcp) =\n    exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h\n     (stk, loc, pc, xcp)", "by(auto intro!: ext intro: exec_meth_take_xt simp add: compxEs2_size_convs)"], ["", "lemma exec_move_CallI2:\n  assumes exec: \"exec_moves ci P t es h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  shows \"exec_move ci P t (e\\<bullet>M(es)) h (stk @ [v], loc, length (compE2 e) + pc, xcp) ta h' (stk' @ [v], loc', length (compE2 e) + pc', xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t (e\\<bullet>M(es)) h\n     (stk @ [v], loc, length (compE2 e) + pc, xcp) ta h'\n     (stk' @ [v], loc', length (compE2 e) + pc', xcp')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. exec_move ci P t (e\\<bullet>M(es)) h\n     (stk @ [v], loc, length (compE2 e) + pc, xcp) ta h'\n     (stk' @ [v], loc', length (compE2 e) + pc', xcp')", "from exec"], ["proof (chain)\npicking this:\n  exec_moves ci P t es h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "have \"exec_meth ci (compP2 P) (compEs2 es) (compxEs2 es 0 0) t h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_moves ci P t es h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compEs2 es) (compxEs2 es 0 0) t h\n     (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "unfolding exec_moves_def"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compEs2 es) (compxEs2 es 0 0) t h\n   (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compEs2 es) (compxEs2 es 0 0) t h\n     (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "."], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) (compEs2 es) (compxEs2 es 0 0) t h\n   (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (e\\<bullet>M(es)) h\n     (stk @ [v], loc, length (compE2 e) + pc, xcp) ta h'\n     (stk' @ [v], loc', length (compE2 e) + pc', xcp')", "from exec_meth_stk_offer[OF this, where stk''=\"[v]\"]"], ["proof (chain)\npicking this:\n  exec_meth ci (compP2 P) (compEs2 es)\n   (stack_xlift (length [v]) (compxEs2 es 0 0)) t h\n   (stk @ [v], loc, pc, xcp) ta h' (stk' @ [v], loc', pc', xcp')", "show ?thesis"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compEs2 es)\n   (stack_xlift (length [v]) (compxEs2 es 0 0)) t h\n   (stk @ [v], loc, pc, xcp) ta h' (stk' @ [v], loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (e\\<bullet>M(es)) h\n     (stk @ [v], loc, length (compE2 e) + pc, xcp) ta h'\n     (stk' @ [v], loc', length (compE2 e) + pc', xcp')", "by(fastforce intro: append_exec_meth_xt simp add: exec_move_def compxEs2_size_convs compxEs2_stack_xlift_convs)"], ["proof (state)\nthis:\n  exec_move ci P t (e\\<bullet>M(es)) h\n   (stk @ [v], loc, length (compE2 e) + pc, xcp) ta h'\n   (stk' @ [v], loc', length (compE2 e) + pc', xcp')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exec_move_BlockNoneI:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t {V:T=None; e} h s ta h' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t e h s ta h' s' \\<Longrightarrow>\n    exec_move ci P t {V:T=None; e} h s ta h' s'", "unfolding exec_move_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h s ta h'\n     s' \\<Longrightarrow>\n    exec_meth ci (compP2 P) (compE2 {V:T=None; e})\n     (compxE2 {V:T=None; e} 0 0) t h s ta h' s'", "by simp"], ["", "lemma exec_move_BlockNone:\n  \"exec_move ci P t {V:T=None; e} = exec_move ci P t e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t {V:T=None; e} = exec_move ci P t e", "unfolding exec_move_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 {V:T=None; e})\n     (compxE2 {V:T=None; e} 0 0) t =\n    exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t", "by(simp)"], ["", "lemma exec_move_BlockSomeI:\n  assumes exec: \"exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  shows \"exec_move ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h (stk, loc, Suc (Suc pc), xcp) ta h' (stk', loc', Suc (Suc pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h\n     (stk, loc, Suc (Suc pc), xcp) ta h' (stk', loc', Suc (Suc pc'), xcp')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. exec_move ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h\n     (stk, loc, Suc (Suc pc), xcp) ta h' (stk', loc', Suc (Suc pc'), xcp')", "let ?ins = \"[Push v, Store V]\""], ["proof (state)\ngoal (1 subgoal):\n 1. exec_move ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h\n     (stk, loc, Suc (Suc pc), xcp) ta h' (stk', loc', Suc (Suc pc'), xcp')", "from exec"], ["proof (chain)\npicking this:\n  exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "have \"exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h\n     (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "by(simp add: exec_move_def)"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h (stk, loc, pc, xcp)\n   ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h\n     (stk, loc, Suc (Suc pc), xcp) ta h' (stk', loc', Suc (Suc pc'), xcp')", "hence \"exec_meth ci (compP2 P) (?ins @ compE2 e) (shift (length ?ins) (compxE2 e 0 0)) t h (stk, loc, length ?ins + pc, xcp) ta h' (stk', loc', length ?ins + pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h (stk, loc, pc, xcp)\n   ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) ([Push v, Store V] @ compE2 e)\n     (shift (length [Push v, Store V]) (compxE2 e 0 0)) t h\n     (stk, loc, length [Push v, Store V] + pc, xcp) ta h'\n     (stk', loc', length [Push v, Store V] + pc', xcp')", "by(rule append_exec_meth) auto"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) ([Push v, Store V] @ compE2 e)\n   (shift (length [Push v, Store V]) (compxE2 e 0 0)) t h\n   (stk, loc, length [Push v, Store V] + pc, xcp) ta h'\n   (stk', loc', length [Push v, Store V] + pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h\n     (stk, loc, Suc (Suc pc), xcp) ta h' (stk', loc', Suc (Suc pc'), xcp')", "thus ?thesis"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) ([Push v, Store V] @ compE2 e)\n   (shift (length [Push v, Store V]) (compxE2 e 0 0)) t h\n   (stk, loc, length [Push v, Store V] + pc, xcp) ta h'\n   (stk', loc', length [Push v, Store V] + pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h\n     (stk, loc, Suc (Suc pc), xcp) ta h' (stk', loc', Suc (Suc pc'), xcp')", "by(simp add: exec_move_def shift_compxE2)"], ["proof (state)\nthis:\n  exec_move ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h\n   (stk, loc, Suc (Suc pc), xcp) ta h' (stk', loc', Suc (Suc pc'), xcp')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exec_move_BlockSome:\n  \"exec_move ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h (stk, loc, Suc (Suc pc), xcp) ta h' (stk', loc', Suc (Suc pc'), xcp') =\n   exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h\n     (stk, loc, Suc (Suc pc), xcp) ta h' (stk', loc', Suc (Suc pc'), xcp') =\n    exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. exec_move ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h\n     (stk, loc, Suc (Suc pc), xcp) ta h'\n     (stk', loc', Suc (Suc pc'), xcp') \\<Longrightarrow>\n    exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n 2. exec_move ci P t e h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    exec_move ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h\n     (stk, loc, Suc (Suc pc), xcp) ta h' (stk', loc', Suc (Suc pc'), xcp')", "assume ?rhs"], ["proof (state)\nthis:\n  exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (2 subgoals):\n 1. exec_move ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h\n     (stk, loc, Suc (Suc pc), xcp) ta h'\n     (stk', loc', Suc (Suc pc'), xcp') \\<Longrightarrow>\n    exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n 2. exec_move ci P t e h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    exec_move ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h\n     (stk, loc, Suc (Suc pc), xcp) ta h' (stk', loc', Suc (Suc pc'), xcp')", "thus ?lhs"], ["proof (prove)\nusing this:\n  exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h\n     (stk, loc, Suc (Suc pc), xcp) ta h' (stk', loc', Suc (Suc pc'), xcp')", "by(rule exec_move_BlockSomeI)"], ["proof (state)\nthis:\n  exec_move ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h\n   (stk, loc, Suc (Suc pc), xcp) ta h' (stk', loc', Suc (Suc pc'), xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h\n     (stk, loc, Suc (Suc pc), xcp) ta h'\n     (stk', loc', Suc (Suc pc'), xcp') \\<Longrightarrow>\n    exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. exec_move ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h\n     (stk, loc, Suc (Suc pc), xcp) ta h'\n     (stk', loc', Suc (Suc pc'), xcp') \\<Longrightarrow>\n    exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "let ?ins = \"[Push v, Store V]\""], ["proof (state)\ngoal (1 subgoal):\n 1. exec_move ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h\n     (stk, loc, Suc (Suc pc), xcp) ta h'\n     (stk', loc', Suc (Suc pc'), xcp') \\<Longrightarrow>\n    exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "assume ?lhs"], ["proof (state)\nthis:\n  exec_move ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h\n   (stk, loc, Suc (Suc pc), xcp) ta h' (stk', loc', Suc (Suc pc'), xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h\n     (stk, loc, Suc (Suc pc), xcp) ta h'\n     (stk', loc', Suc (Suc pc'), xcp') \\<Longrightarrow>\n    exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "hence \"exec_meth ci (compP2 P) (?ins @ compE2 e) (shift (length ?ins) (compxE2 e 0 0)) t h (stk, loc, length ?ins + pc, xcp) ta h' (stk', loc', length ?ins + pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_move ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h\n   (stk, loc, Suc (Suc pc), xcp) ta h' (stk', loc', Suc (Suc pc'), xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) ([Push v, Store V] @ compE2 e)\n     (shift (length [Push v, Store V]) (compxE2 e 0 0)) t h\n     (stk, loc, length [Push v, Store V] + pc, xcp) ta h'\n     (stk', loc', length [Push v, Store V] + pc', xcp')", "by(simp add: exec_move_def shift_compxE2)"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) ([Push v, Store V] @ compE2 e)\n   (shift (length [Push v, Store V]) (compxE2 e 0 0)) t h\n   (stk, loc, length [Push v, Store V] + pc, xcp) ta h'\n   (stk', loc', length [Push v, Store V] + pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h\n     (stk, loc, Suc (Suc pc), xcp) ta h'\n     (stk', loc', Suc (Suc pc'), xcp') \\<Longrightarrow>\n    exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "hence \"exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h (stk, loc, pc, xcp) ta h' (stk', loc', length ?ins + pc' - length ?ins, xcp')\""], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) ([Push v, Store V] @ compE2 e)\n   (shift (length [Push v, Store V]) (compxE2 e 0 0)) t h\n   (stk, loc, length [Push v, Store V] + pc, xcp) ta h'\n   (stk', loc', length [Push v, Store V] + pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h\n     (stk, loc, pc, xcp) ta h'\n     (stk', loc', length [Push v, Store V] + pc' - length [Push v, Store V],\n      xcp')", "by(rule exec_meth_drop) auto"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h (stk, loc, pc, xcp)\n   ta h'\n   (stk', loc', length [Push v, Store V] + pc' - length [Push v, Store V],\n    xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h\n     (stk, loc, Suc (Suc pc), xcp) ta h'\n     (stk', loc', Suc (Suc pc'), xcp') \\<Longrightarrow>\n    exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "thus ?rhs"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h (stk, loc, pc, xcp)\n   ta h'\n   (stk', loc', length [Push v, Store V] + pc' - length [Push v, Store V],\n    xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "by(simp add: exec_move_def)"], ["proof (state)\nthis:\n  exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exec_move_SyncI1:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (sync\\<^bsub>V\\<^esub> (e) e') h s ta h' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t e h s ta h' s' \\<Longrightarrow>\n    exec_move ci P t (sync\\<^bsub>V\\<^esub> (e) e') h s ta h' s'", "unfolding exec_move_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h s ta h'\n     s' \\<Longrightarrow>\n    exec_meth ci (compP2 P) (compE2 (sync\\<^bsub>V\\<^esub> (e) e'))\n     (compxE2 (sync\\<^bsub>V\\<^esub> (e) e') 0 0) t h s ta h' s'", "by auto"], ["", "lemma exec_move_Sync1:\n  assumes pc: \"pc < length (compE2 e)\"\n  shows \"exec_move ci P t (sync\\<^bsub>V\\<^esub> (e) e') h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t (sync\\<^bsub>V\\<^esub> (e) e') h (stk, loc, pc, xcp) =\n    exec_move ci P t e h (stk, loc, pc, xcp)", "proof(rule ext iffI)+"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       exec_move ci P t (sync\\<^bsub>V\\<^esub> (e) e') h (stk, loc, pc, xcp)\n        x xa xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb\n 2. \\<And>x xa xb.\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t (sync\\<^bsub>V\\<^esub> (e) e') h (stk, loc, pc, xcp)\n        x xa xb", "fix ta h' s'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       exec_move ci P t (sync\\<^bsub>V\\<^esub> (e) e') h (stk, loc, pc, xcp)\n        x xa xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb\n 2. \\<And>x xa xb.\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t (sync\\<^bsub>V\\<^esub> (e) e') h (stk, loc, pc, xcp)\n        x xa xb", "assume \"?lhs ta h' s'\""], ["proof (state)\nthis:\n  exec_move ci P t (sync\\<^bsub>V\\<^esub> (e) e') h (stk, loc, pc, xcp) ta\n   h' s'\n\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       exec_move ci P t (sync\\<^bsub>V\\<^esub> (e) e') h (stk, loc, pc, xcp)\n        x xa xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb\n 2. \\<And>x xa xb.\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t (sync\\<^bsub>V\\<^esub> (e) e') h (stk, loc, pc, xcp)\n        x xa xb", "hence \"exec_meth ci (compP2 P) (compE2 e @ Dup # Store V # MEnter # compE2 e' @ [Load V, MExit, Goto 4, Load V, MExit, ThrowExc])\n                   (compxE2 e 0 0 @ shift (length (compE2 e)) (compxE2 e' 3 0 @ [(3, 3 + length (compE2 e'), None, 6 + length (compE2 e'), 0)]))\n                   t h (stk, loc, pc, xcp) ta h' s'\""], ["proof (prove)\nusing this:\n  exec_move ci P t (sync\\<^bsub>V\\<^esub> (e) e') h (stk, loc, pc, xcp) ta\n   h' s'\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P)\n     (compE2 e @\n      Dup #\n      Store V #\n      MEnter # compE2 e' @ [Load V, MExit, Goto 4, Load V, MExit, ThrowExc])\n     (compxE2 e 0 0 @\n      shift (length (compE2 e))\n       (compxE2 e' 3 0 @\n        [(3, 3 + length (compE2 e'), Any, 6 + length (compE2 e'), 0)]))\n     t h (stk, loc, pc, xcp) ta h' s'", "by(simp add: shift_compxE2 ac_simps exec_move_def)"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P)\n   (compE2 e @\n    Dup #\n    Store V #\n    MEnter # compE2 e' @ [Load V, MExit, Goto 4, Load V, MExit, ThrowExc])\n   (compxE2 e 0 0 @\n    shift (length (compE2 e))\n     (compxE2 e' 3 0 @\n      [(3, 3 + length (compE2 e'), Any, 6 + length (compE2 e'), 0)]))\n   t h (stk, loc, pc, xcp) ta h' s'\n\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       exec_move ci P t (sync\\<^bsub>V\\<^esub> (e) e') h (stk, loc, pc, xcp)\n        x xa xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb\n 2. \\<And>x xa xb.\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t (sync\\<^bsub>V\\<^esub> (e) e') h (stk, loc, pc, xcp)\n        x xa xb", "thus \"?rhs ta h' s'\""], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P)\n   (compE2 e @\n    Dup #\n    Store V #\n    MEnter # compE2 e' @ [Load V, MExit, Goto 4, Load V, MExit, ThrowExc])\n   (compxE2 e 0 0 @\n    shift (length (compE2 e))\n     (compxE2 e' 3 0 @\n      [(3, 3 + length (compE2 e'), Any, 6 + length (compE2 e'), 0)]))\n   t h (stk, loc, pc, xcp) ta h' s'\n\ngoal (1 subgoal):\n 1. exec_move ci P t e h (stk, loc, pc, xcp) ta h' s'", "unfolding exec_move_def"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P)\n   (compE2 e @\n    Dup #\n    Store V #\n    MEnter # compE2 e' @ [Load V, MExit, Goto 4, Load V, MExit, ThrowExc])\n   (compxE2 e 0 0 @\n    shift (length (compE2 e))\n     (compxE2 e' 3 0 @\n      [(3, 3 + length (compE2 e'), Any, 6 + length (compE2 e'), 0)]))\n   t h (stk, loc, pc, xcp) ta h' s'\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h\n     (stk, loc, pc, xcp) ta h' s'", "using pc"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P)\n   (compE2 e @\n    Dup #\n    Store V #\n    MEnter # compE2 e' @ [Load V, MExit, Goto 4, Load V, MExit, ThrowExc])\n   (compxE2 e 0 0 @\n    shift (length (compE2 e))\n     (compxE2 e' 3 0 @\n      [(3, 3 + length (compE2 e'), Any, 6 + length (compE2 e'), 0)]))\n   t h (stk, loc, pc, xcp) ta h' s'\n  pc < length (compE2 e)\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h\n     (stk, loc, pc, xcp) ta h' s'", "by(rule exec_meth_take_xt)"], ["proof (state)\nthis:\n  exec_move ci P t e h (stk, loc, pc, xcp) ta h' s'\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t (sync\\<^bsub>V\\<^esub> (e) e') h (stk, loc, pc, xcp)\n        x xa xb", "qed(rule exec_move_SyncI1)"], ["", "lemma exec_move_SyncI2:\n  assumes exec: \"exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  shows \"exec_move ci P t (sync\\<^bsub>V\\<^esub> (o') e) h (stk, loc, (Suc (Suc (Suc (length (compE2 o') + pc)))), xcp) ta h' (stk', loc', (Suc (Suc (Suc (length (compE2 o') + pc')))), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t (sync\\<^bsub>V\\<^esub> (o') e) h\n     (stk, loc, Suc (Suc (Suc (length (compE2 o') + pc))), xcp) ta h'\n     (stk', loc', Suc (Suc (Suc (length (compE2 o') + pc'))), xcp')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. exec_move ci P t (sync\\<^bsub>V\\<^esub> (o') e) h\n     (stk, loc, Suc (Suc (Suc (length (compE2 o') + pc))), xcp) ta h'\n     (stk', loc', Suc (Suc (Suc (length (compE2 o') + pc'))), xcp')", "let ?e = \"compE2 o' @ [Dup, Store V, MEnter]\""], ["proof (state)\ngoal (1 subgoal):\n 1. exec_move ci P t (sync\\<^bsub>V\\<^esub> (o') e) h\n     (stk, loc, Suc (Suc (Suc (length (compE2 o') + pc))), xcp) ta h'\n     (stk', loc', Suc (Suc (Suc (length (compE2 o') + pc'))), xcp')", "let ?e' = \"[Load V, MExit, Goto 4, Load V, MExit, ThrowExc]\""], ["proof (state)\ngoal (1 subgoal):\n 1. exec_move ci P t (sync\\<^bsub>V\\<^esub> (o') e) h\n     (stk, loc, Suc (Suc (Suc (length (compE2 o') + pc))), xcp) ta h'\n     (stk', loc', Suc (Suc (Suc (length (compE2 o') + pc'))), xcp')", "from exec"], ["proof (chain)\npicking this:\n  exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "have \"exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h\n     (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "by(simp add: exec_move_def)"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h (stk, loc, pc, xcp)\n   ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (sync\\<^bsub>V\\<^esub> (o') e) h\n     (stk, loc, Suc (Suc (Suc (length (compE2 o') + pc))), xcp) ta h'\n     (stk', loc', Suc (Suc (Suc (length (compE2 o') + pc'))), xcp')", "hence \"exec_meth ci (compP2 P) ((?e @ compE2 e) @ ?e') ((compxE2 o' 0 0 @ shift (length ?e) (compxE2 e 0 0)) @ [(length ?e, length ?e + length (compE2 e), None, length ?e + length (compE2 e) + 3, 0)]) t h (stk, loc, (length ?e + pc), xcp) ta h' (stk', loc', (length ?e + pc'), xcp')\""], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h (stk, loc, pc, xcp)\n   ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P)\n     (((compE2 o' @ [Dup, Store V, MEnter]) @ compE2 e) @\n      [Load V, MExit, Goto 4, Load V, MExit, ThrowExc])\n     ((compxE2 o' 0 0 @\n       shift (length (compE2 o' @ [Dup, Store V, MEnter]))\n        (compxE2 e 0 0)) @\n      [(length (compE2 o' @ [Dup, Store V, MEnter]),\n        length (compE2 o' @ [Dup, Store V, MEnter]) + length (compE2 e),\n        Any,\n        length (compE2 o' @ [Dup, Store V, MEnter]) + length (compE2 e) + 3,\n        0)])\n     t h (stk, loc, length (compE2 o' @ [Dup, Store V, MEnter]) + pc, xcp)\n     ta h'\n     (stk', loc', length (compE2 o' @ [Dup, Store V, MEnter]) + pc', xcp')", "by(rule exec_meth_append_xt[OF append_exec_meth_xt]) auto"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P)\n   (((compE2 o' @ [Dup, Store V, MEnter]) @ compE2 e) @\n    [Load V, MExit, Goto 4, Load V, MExit, ThrowExc])\n   ((compxE2 o' 0 0 @\n     shift (length (compE2 o' @ [Dup, Store V, MEnter])) (compxE2 e 0 0)) @\n    [(length (compE2 o' @ [Dup, Store V, MEnter]),\n      length (compE2 o' @ [Dup, Store V, MEnter]) + length (compE2 e), Any,\n      length (compE2 o' @ [Dup, Store V, MEnter]) + length (compE2 e) + 3,\n      0)])\n   t h (stk, loc, length (compE2 o' @ [Dup, Store V, MEnter]) + pc, xcp) ta\n   h' (stk', loc', length (compE2 o' @ [Dup, Store V, MEnter]) + pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (sync\\<^bsub>V\\<^esub> (o') e) h\n     (stk, loc, Suc (Suc (Suc (length (compE2 o') + pc))), xcp) ta h'\n     (stk', loc', Suc (Suc (Suc (length (compE2 o') + pc'))), xcp')", "thus ?thesis"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P)\n   (((compE2 o' @ [Dup, Store V, MEnter]) @ compE2 e) @\n    [Load V, MExit, Goto 4, Load V, MExit, ThrowExc])\n   ((compxE2 o' 0 0 @\n     shift (length (compE2 o' @ [Dup, Store V, MEnter])) (compxE2 e 0 0)) @\n    [(length (compE2 o' @ [Dup, Store V, MEnter]),\n      length (compE2 o' @ [Dup, Store V, MEnter]) + length (compE2 e), Any,\n      length (compE2 o' @ [Dup, Store V, MEnter]) + length (compE2 e) + 3,\n      0)])\n   t h (stk, loc, length (compE2 o' @ [Dup, Store V, MEnter]) + pc, xcp) ta\n   h' (stk', loc', length (compE2 o' @ [Dup, Store V, MEnter]) + pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (sync\\<^bsub>V\\<^esub> (o') e) h\n     (stk, loc, Suc (Suc (Suc (length (compE2 o') + pc))), xcp) ta h'\n     (stk', loc', Suc (Suc (Suc (length (compE2 o') + pc'))), xcp')", "by(simp add: eval_nat_numeral shift_compxE2 exec_move_def)"], ["proof (state)\nthis:\n  exec_move ci P t (sync\\<^bsub>V\\<^esub> (o') e) h\n   (stk, loc, Suc (Suc (Suc (length (compE2 o') + pc))), xcp) ta h'\n   (stk', loc', Suc (Suc (Suc (length (compE2 o') + pc'))), xcp')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exec_move_SeqI1:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (e;;e') h s ta h' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t e h s ta h' s' \\<Longrightarrow>\n    exec_move ci P t (e;; e') h s ta h' s'", "unfolding exec_move_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h s ta h'\n     s' \\<Longrightarrow>\n    exec_meth ci (compP2 P) (compE2 (e;; e')) (compxE2 (e;; e') 0 0) t h s\n     ta h' s'", "by auto"], ["", "lemma exec_move_Seq1:\n  assumes pc: \"pc < length (compE2 e)\"\n  shows \"exec_move ci P t (e;;e') h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t (e;; e') h (stk, loc, pc, xcp) =\n    exec_move ci P t e h (stk, loc, pc, xcp)", "proof(rule ext iffI)+"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       exec_move ci P t (e;; e') h (stk, loc, pc, xcp) x xa\n        xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb\n 2. \\<And>x xa xb.\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t (e;; e') h (stk, loc, pc, xcp) x xa xb", "fix ta h' s'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       exec_move ci P t (e;; e') h (stk, loc, pc, xcp) x xa\n        xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb\n 2. \\<And>x xa xb.\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t (e;; e') h (stk, loc, pc, xcp) x xa xb", "assume \"?lhs ta h' s'\""], ["proof (state)\nthis:\n  exec_move ci P t (e;; e') h (stk, loc, pc, xcp) ta h' s'\n\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       exec_move ci P t (e;; e') h (stk, loc, pc, xcp) x xa\n        xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb\n 2. \\<And>x xa xb.\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t (e;; e') h (stk, loc, pc, xcp) x xa xb", "hence \"exec_meth ci (compP2 P) (compE2 e @ Pop # compE2 e') (compxE2 e 0 0 @ shift (length (compE2 e)) (compxE2 e' (Suc 0) 0)) t h (stk, loc, pc, xcp) ta h' s'\""], ["proof (prove)\nusing this:\n  exec_move ci P t (e;; e') h (stk, loc, pc, xcp) ta h' s'\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e @ Pop # compE2 e')\n     (compxE2 e 0 0 @ shift (length (compE2 e)) (compxE2 e' (Suc 0) 0)) t h\n     (stk, loc, pc, xcp) ta h' s'", "by(simp add: exec_move_def shift_compxE2)"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) (compE2 e @ Pop # compE2 e')\n   (compxE2 e 0 0 @ shift (length (compE2 e)) (compxE2 e' (Suc 0) 0)) t h\n   (stk, loc, pc, xcp) ta h' s'\n\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       exec_move ci P t (e;; e') h (stk, loc, pc, xcp) x xa\n        xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb\n 2. \\<And>x xa xb.\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t (e;; e') h (stk, loc, pc, xcp) x xa xb", "thus \"?rhs ta h' s'\""], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e @ Pop # compE2 e')\n   (compxE2 e 0 0 @ shift (length (compE2 e)) (compxE2 e' (Suc 0) 0)) t h\n   (stk, loc, pc, xcp) ta h' s'\n\ngoal (1 subgoal):\n 1. exec_move ci P t e h (stk, loc, pc, xcp) ta h' s'", "unfolding exec_move_def"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e @ Pop # compE2 e')\n   (compxE2 e 0 0 @ shift (length (compE2 e)) (compxE2 e' (Suc 0) 0)) t h\n   (stk, loc, pc, xcp) ta h' s'\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h\n     (stk, loc, pc, xcp) ta h' s'", "using pc"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e @ Pop # compE2 e')\n   (compxE2 e 0 0 @ shift (length (compE2 e)) (compxE2 e' (Suc 0) 0)) t h\n   (stk, loc, pc, xcp) ta h' s'\n  pc < length (compE2 e)\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h\n     (stk, loc, pc, xcp) ta h' s'", "by(rule exec_meth_take_xt)"], ["proof (state)\nthis:\n  exec_move ci P t e h (stk, loc, pc, xcp) ta h' s'\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t (e;; e') h (stk, loc, pc, xcp) x xa xb", "qed(rule exec_move_SeqI1)"], ["", "lemma exec_move_SeqI2:\n  assumes exec: \"exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc' ,xcp')\"\n  shows \"exec_move ci P t (e';;e) h (stk, loc, (Suc (length (compE2 e') + pc)), xcp) ta h' (stk', loc', (Suc (length (compE2 e') + pc')), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t (e';; e) h\n     (stk, loc, Suc (length (compE2 e') + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e') + pc'), xcp')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. exec_move ci P t (e';; e) h\n     (stk, loc, Suc (length (compE2 e') + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e') + pc'), xcp')", "from exec"], ["proof (chain)\npicking this:\n  exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "have \"exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h\n     (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "by(simp add: exec_move_def)"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h (stk, loc, pc, xcp)\n   ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (e';; e) h\n     (stk, loc, Suc (length (compE2 e') + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e') + pc'), xcp')", "hence \"exec_meth ci (compP2 P) ((compE2 e' @ [Pop]) @ compE2 e) (compxE2 e' 0 0 @ shift (length (compE2 e' @ [Pop])) (compxE2 e 0 0)) t h (stk, loc, (length ((compE2 e') @ [Pop]) + pc), xcp) ta h' (stk', loc', (length ((compE2 e') @ [Pop]) + pc'), xcp')\""], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h (stk, loc, pc, xcp)\n   ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) ((compE2 e' @ [Pop]) @ compE2 e)\n     (compxE2 e' 0 0 @ shift (length (compE2 e' @ [Pop])) (compxE2 e 0 0)) t\n     h (stk, loc, length (compE2 e' @ [Pop]) + pc, xcp) ta h'\n     (stk', loc', length (compE2 e' @ [Pop]) + pc', xcp')", "by(rule append_exec_meth_xt) auto"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) ((compE2 e' @ [Pop]) @ compE2 e)\n   (compxE2 e' 0 0 @ shift (length (compE2 e' @ [Pop])) (compxE2 e 0 0)) t h\n   (stk, loc, length (compE2 e' @ [Pop]) + pc, xcp) ta h'\n   (stk', loc', length (compE2 e' @ [Pop]) + pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (e';; e) h\n     (stk, loc, Suc (length (compE2 e') + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e') + pc'), xcp')", "thus ?thesis"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) ((compE2 e' @ [Pop]) @ compE2 e)\n   (compxE2 e' 0 0 @ shift (length (compE2 e' @ [Pop])) (compxE2 e 0 0)) t h\n   (stk, loc, length (compE2 e' @ [Pop]) + pc, xcp) ta h'\n   (stk', loc', length (compE2 e' @ [Pop]) + pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (e';; e) h\n     (stk, loc, Suc (length (compE2 e') + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e') + pc'), xcp')", "by(simp add: shift_compxE2 exec_move_def)"], ["proof (state)\nthis:\n  exec_move ci P t (e';; e) h (stk, loc, Suc (length (compE2 e') + pc), xcp)\n   ta h' (stk', loc', Suc (length (compE2 e') + pc'), xcp')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exec_move_Seq2:\n  assumes pc: \"pc < length (compE2 e)\"\n  shows \"exec_move ci P t (e';;e) h (stk, loc, Suc (length (compE2 e') + pc), xcp) ta\n                                h' (stk', loc', Suc (length (compE2 e') + pc'), xcp') =\n         exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t (e';; e) h\n     (stk, loc, Suc (length (compE2 e') + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e') + pc'), xcp') =\n    exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. exec_move ci P t (e';; e) h\n     (stk, loc, Suc (length (compE2 e') + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e') + pc'), xcp') \\<Longrightarrow>\n    exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n 2. exec_move ci P t e h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    exec_move ci P t (e';; e) h\n     (stk, loc, Suc (length (compE2 e') + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e') + pc'), xcp')", "let ?E = \"compE2 e' @ [Pop]\""], ["proof (state)\ngoal (2 subgoals):\n 1. exec_move ci P t (e';; e) h\n     (stk, loc, Suc (length (compE2 e') + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e') + pc'), xcp') \\<Longrightarrow>\n    exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n 2. exec_move ci P t e h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    exec_move ci P t (e';; e) h\n     (stk, loc, Suc (length (compE2 e') + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e') + pc'), xcp')", "assume ?lhs"], ["proof (state)\nthis:\n  exec_move ci P t (e';; e) h (stk, loc, Suc (length (compE2 e') + pc), xcp)\n   ta h' (stk', loc', Suc (length (compE2 e') + pc'), xcp')\n\ngoal (2 subgoals):\n 1. exec_move ci P t (e';; e) h\n     (stk, loc, Suc (length (compE2 e') + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e') + pc'), xcp') \\<Longrightarrow>\n    exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n 2. exec_move ci P t e h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    exec_move ci P t (e';; e) h\n     (stk, loc, Suc (length (compE2 e') + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e') + pc'), xcp')", "hence \"exec_meth ci (compP2 P) (?E @ compE2 e) (compxE2 e' 0 0 @ shift (length ?E) (compxE2 e 0 0)) t h (stk, loc, length ?E + pc, xcp) ta h' (stk', loc', length ?E + pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_move ci P t (e';; e) h (stk, loc, Suc (length (compE2 e') + pc), xcp)\n   ta h' (stk', loc', Suc (length (compE2 e') + pc'), xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) ((compE2 e' @ [Pop]) @ compE2 e)\n     (compxE2 e' 0 0 @ shift (length (compE2 e' @ [Pop])) (compxE2 e 0 0)) t\n     h (stk, loc, length (compE2 e' @ [Pop]) + pc, xcp) ta h'\n     (stk', loc', length (compE2 e' @ [Pop]) + pc', xcp')", "by(simp add: exec_move_def shift_compxE2)"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) ((compE2 e' @ [Pop]) @ compE2 e)\n   (compxE2 e' 0 0 @ shift (length (compE2 e' @ [Pop])) (compxE2 e 0 0)) t h\n   (stk, loc, length (compE2 e' @ [Pop]) + pc, xcp) ta h'\n   (stk', loc', length (compE2 e' @ [Pop]) + pc', xcp')\n\ngoal (2 subgoals):\n 1. exec_move ci P t (e';; e) h\n     (stk, loc, Suc (length (compE2 e') + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e') + pc'), xcp') \\<Longrightarrow>\n    exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n 2. exec_move ci P t e h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    exec_move ci P t (e';; e) h\n     (stk, loc, Suc (length (compE2 e') + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e') + pc'), xcp')", "from exec_meth_drop_xt[OF this]"], ["proof (chain)\npicking this:\n  \\<lbrakk>pcs (compxE2 e' 0 0) \\<subseteq> {..<length (compE2 e' @ [Pop])};\n   jump_ok (compE2 e) 0 ?n\\<rbrakk>\n  \\<Longrightarrow> exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h\n                     (stk, loc, pc, xcp) ta h'\n                     (stk', loc',\n                      length (compE2 e' @ [Pop]) + pc' -\n                      length (compE2 e' @ [Pop]),\n                      xcp')", "show ?rhs"], ["proof (prove)\nusing this:\n  \\<lbrakk>pcs (compxE2 e' 0 0) \\<subseteq> {..<length (compE2 e' @ [Pop])};\n   jump_ok (compE2 e) 0 ?n\\<rbrakk>\n  \\<Longrightarrow> exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h\n                     (stk, loc, pc, xcp) ta h'\n                     (stk', loc',\n                      length (compE2 e' @ [Pop]) + pc' -\n                      length (compE2 e' @ [Pop]),\n                      xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "unfolding exec_move_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>pcs (compxE2 e' 0 0) \\<subseteq> {..<length (compE2 e' @ [Pop])};\n   jump_ok (compE2 e) 0 ?n\\<rbrakk>\n  \\<Longrightarrow> exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h\n                     (stk, loc, pc, xcp) ta h'\n                     (stk', loc',\n                      length (compE2 e' @ [Pop]) + pc' -\n                      length (compE2 e' @ [Pop]),\n                      xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h\n     (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "by fastforce"], ["proof (state)\nthis:\n  exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t e h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    exec_move ci P t (e';; e) h\n     (stk, loc, Suc (length (compE2 e') + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e') + pc'), xcp')", "qed(rule exec_move_SeqI2)"], ["", "lemma exec_move_CondI1:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (if (e) e1 else e2) h s ta h' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t e h s ta h' s' \\<Longrightarrow>\n    exec_move ci P t (if (e) e1 else e2) h s ta h' s'", "unfolding exec_move_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h s ta h'\n     s' \\<Longrightarrow>\n    exec_meth ci (compP2 P) (compE2 (if (e) e1 else e2))\n     (compxE2 (if (e) e1 else e2) 0 0) t h s ta h' s'", "by auto"], ["", "lemma exec_move_Cond1:\n  assumes pc: \"pc < length (compE2 e)\"\n  shows \"exec_move ci P t (if (e) e1 else e2) h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t (if (e) e1 else e2) h (stk, loc, pc, xcp) =\n    exec_move ci P t e h (stk, loc, pc, xcp)", "proof(rule ext iffI)+"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       exec_move ci P t (if (e) e1 else e2) h (stk, loc, pc, xcp) x xa\n        xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb\n 2. \\<And>x xa xb.\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t (if (e) e1 else e2) h (stk, loc, pc, xcp) x xa xb", "let ?E = \"IfFalse (2 + int (length (compE2 e1))) # compE2 e1 @ Goto (1 + int (length (compE2 e2))) # compE2 e2\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       exec_move ci P t (if (e) e1 else e2) h (stk, loc, pc, xcp) x xa\n        xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb\n 2. \\<And>x xa xb.\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t (if (e) e1 else e2) h (stk, loc, pc, xcp) x xa xb", "let ?xt = \"compxE2 e1 (Suc 0) 0 @ compxE2 e2 (Suc (Suc (length (compE2 e1)))) 0\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       exec_move ci P t (if (e) e1 else e2) h (stk, loc, pc, xcp) x xa\n        xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb\n 2. \\<And>x xa xb.\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t (if (e) e1 else e2) h (stk, loc, pc, xcp) x xa xb", "fix ta h' s'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       exec_move ci P t (if (e) e1 else e2) h (stk, loc, pc, xcp) x xa\n        xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb\n 2. \\<And>x xa xb.\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t (if (e) e1 else e2) h (stk, loc, pc, xcp) x xa xb", "assume \"?lhs ta h' s'\""], ["proof (state)\nthis:\n  exec_move ci P t (if (e) e1 else e2) h (stk, loc, pc, xcp) ta h' s'\n\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       exec_move ci P t (if (e) e1 else e2) h (stk, loc, pc, xcp) x xa\n        xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb\n 2. \\<And>x xa xb.\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t (if (e) e1 else e2) h (stk, loc, pc, xcp) x xa xb", "hence \"exec_meth ci (compP2 P) (compE2 e @ ?E) (compxE2 e 0 0 @ shift (length (compE2 e)) ?xt) t h (stk, loc, pc, xcp) ta h' s'\""], ["proof (prove)\nusing this:\n  exec_move ci P t (if (e) e1 else e2) h (stk, loc, pc, xcp) ta h' s'\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P)\n     (compE2 e @\n      IfFalse (2 + int (length (compE2 e1))) #\n      compE2 e1 @ Goto (1 + int (length (compE2 e2))) # compE2 e2)\n     (compxE2 e 0 0 @\n      shift (length (compE2 e))\n       (compxE2 e1 (Suc 0) 0 @\n        compxE2 e2 (Suc (Suc (length (compE2 e1)))) 0))\n     t h (stk, loc, pc, xcp) ta h' s'", "by(simp add: exec_move_def shift_compxE2 ac_simps)"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P)\n   (compE2 e @\n    IfFalse (2 + int (length (compE2 e1))) #\n    compE2 e1 @ Goto (1 + int (length (compE2 e2))) # compE2 e2)\n   (compxE2 e 0 0 @\n    shift (length (compE2 e))\n     (compxE2 e1 (Suc 0) 0 @ compxE2 e2 (Suc (Suc (length (compE2 e1)))) 0))\n   t h (stk, loc, pc, xcp) ta h' s'\n\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       exec_move ci P t (if (e) e1 else e2) h (stk, loc, pc, xcp) x xa\n        xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb\n 2. \\<And>x xa xb.\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t (if (e) e1 else e2) h (stk, loc, pc, xcp) x xa xb", "thus \"?rhs ta h' s'\""], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P)\n   (compE2 e @\n    IfFalse (2 + int (length (compE2 e1))) #\n    compE2 e1 @ Goto (1 + int (length (compE2 e2))) # compE2 e2)\n   (compxE2 e 0 0 @\n    shift (length (compE2 e))\n     (compxE2 e1 (Suc 0) 0 @ compxE2 e2 (Suc (Suc (length (compE2 e1)))) 0))\n   t h (stk, loc, pc, xcp) ta h' s'\n\ngoal (1 subgoal):\n 1. exec_move ci P t e h (stk, loc, pc, xcp) ta h' s'", "unfolding exec_move_def"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P)\n   (compE2 e @\n    IfFalse (2 + int (length (compE2 e1))) #\n    compE2 e1 @ Goto (1 + int (length (compE2 e2))) # compE2 e2)\n   (compxE2 e 0 0 @\n    shift (length (compE2 e))\n     (compxE2 e1 (Suc 0) 0 @ compxE2 e2 (Suc (Suc (length (compE2 e1)))) 0))\n   t h (stk, loc, pc, xcp) ta h' s'\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h\n     (stk, loc, pc, xcp) ta h' s'", "using pc"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P)\n   (compE2 e @\n    IfFalse (2 + int (length (compE2 e1))) #\n    compE2 e1 @ Goto (1 + int (length (compE2 e2))) # compE2 e2)\n   (compxE2 e 0 0 @\n    shift (length (compE2 e))\n     (compxE2 e1 (Suc 0) 0 @ compxE2 e2 (Suc (Suc (length (compE2 e1)))) 0))\n   t h (stk, loc, pc, xcp) ta h' s'\n  pc < length (compE2 e)\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h\n     (stk, loc, pc, xcp) ta h' s'", "by(rule exec_meth_take_xt)"], ["proof (state)\nthis:\n  exec_move ci P t e h (stk, loc, pc, xcp) ta h' s'\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t (if (e) e1 else e2) h (stk, loc, pc, xcp) x xa xb", "qed(rule exec_move_CondI1)"], ["", "lemma exec_move_CondI2:\n  assumes exec: \"exec_move ci P t e1 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  shows \"exec_move ci P t (if (e) e1 else e2) h (stk, loc, (Suc (length (compE2 e) + pc)), xcp) ta h' (stk', loc', (Suc (length (compE2 e) + pc')), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp')", "from exec"], ["proof (chain)\npicking this:\n  exec_move ci P t e1 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "have \"exec_meth ci (compP2 P) (compE2 e1) (compxE2 e1 0 0) t h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_move ci P t e1 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e1) (compxE2 e1 0 0) t h\n     (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "by(simp add: exec_move_def)"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) (compE2 e1) (compxE2 e1 0 0) t h\n   (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp')", "hence \"exec_meth ci (compP2 P) (((compE2 e @ [IfFalse (2 + int (length (compE2 e1)))]) @ compE2 e1) @ Goto (1 + int (length (compE2 e2))) # compE2 e2) ((compxE2 e 0 0 @ shift (length (compE2 e @ [IfFalse (2 + int (length (compE2 e1)))])) (compxE2 e1 0 0)) @ (compxE2 e2 (Suc (Suc (length (compE2 e) + length (compE2 e1)))) 0)) t h (stk, loc, (length (compE2 e @ [IfFalse (2 + int (length (compE2 e1)))]) + pc), xcp) ta h' (stk', loc', (length (compE2 e @ [IfFalse (2 + int (length (compE2 e1)))]) + pc'), xcp')\""], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e1) (compxE2 e1 0 0) t h\n   (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P)\n     (((compE2 e @ [IfFalse (2 + int (length (compE2 e1)))]) @ compE2 e1) @\n      Goto (1 + int (length (compE2 e2))) # compE2 e2)\n     ((compxE2 e 0 0 @\n       shift (length (compE2 e @ [IfFalse (2 + int (length (compE2 e1)))]))\n        (compxE2 e1 0 0)) @\n      compxE2 e2 (Suc (Suc (length (compE2 e) + length (compE2 e1)))) 0)\n     t h\n     (stk, loc,\n      length (compE2 e @ [IfFalse (2 + int (length (compE2 e1)))]) + pc,\n      xcp)\n     ta h'\n     (stk', loc',\n      length (compE2 e @ [IfFalse (2 + int (length (compE2 e1)))]) + pc',\n      xcp')", "by -(rule exec_meth_append_xt, rule append_exec_meth_xt, auto)"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P)\n   (((compE2 e @ [IfFalse (2 + int (length (compE2 e1)))]) @ compE2 e1) @\n    Goto (1 + int (length (compE2 e2))) # compE2 e2)\n   ((compxE2 e 0 0 @\n     shift (length (compE2 e @ [IfFalse (2 + int (length (compE2 e1)))]))\n      (compxE2 e1 0 0)) @\n    compxE2 e2 (Suc (Suc (length (compE2 e) + length (compE2 e1)))) 0)\n   t h\n   (stk, loc,\n    length (compE2 e @ [IfFalse (2 + int (length (compE2 e1)))]) + pc, xcp)\n   ta h'\n   (stk', loc',\n    length (compE2 e @ [IfFalse (2 + int (length (compE2 e1)))]) + pc',\n    xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp')", "thus ?thesis"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P)\n   (((compE2 e @ [IfFalse (2 + int (length (compE2 e1)))]) @ compE2 e1) @\n    Goto (1 + int (length (compE2 e2))) # compE2 e2)\n   ((compxE2 e 0 0 @\n     shift (length (compE2 e @ [IfFalse (2 + int (length (compE2 e1)))]))\n      (compxE2 e1 0 0)) @\n    compxE2 e2 (Suc (Suc (length (compE2 e) + length (compE2 e1)))) 0)\n   t h\n   (stk, loc,\n    length (compE2 e @ [IfFalse (2 + int (length (compE2 e1)))]) + pc, xcp)\n   ta h'\n   (stk', loc',\n    length (compE2 e @ [IfFalse (2 + int (length (compE2 e1)))]) + pc',\n    xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp')", "by(simp add: shift_compxE2 exec_move_def)"], ["proof (state)\nthis:\n  exec_move ci P t (if (e) e1 else e2) h\n   (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n   (stk', loc', Suc (length (compE2 e) + pc'), xcp')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exec_move_Cond2:\n  assumes pc: \"pc < length (compE2 e1)\"\n  shows \"exec_move ci P t (if (e) e1 else e2) h (stk, loc, (Suc (length (compE2 e) + pc)), xcp) ta h' (stk', loc', (Suc (length (compE2 e) + pc')), xcp') = exec_move ci P t e1 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp') =\n    exec_move ci P t e1 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp') \\<Longrightarrow>\n    exec_move ci P t e1 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n 2. exec_move ci P t e1 h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp')", "let ?E1 = \"compE2 e @ [IfFalse (2 + int (length (compE2 e1)))]\""], ["proof (state)\ngoal (2 subgoals):\n 1. exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp') \\<Longrightarrow>\n    exec_move ci P t e1 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n 2. exec_move ci P t e1 h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp')", "let ?E2 = \"Goto (1 + int (length (compE2 e2))) # compE2 e2\""], ["proof (state)\ngoal (2 subgoals):\n 1. exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp') \\<Longrightarrow>\n    exec_move ci P t e1 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n 2. exec_move ci P t e1 h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp')", "assume ?lhs"], ["proof (state)\nthis:\n  exec_move ci P t (if (e) e1 else e2) h\n   (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n   (stk', loc', Suc (length (compE2 e) + pc'), xcp')\n\ngoal (2 subgoals):\n 1. exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp') \\<Longrightarrow>\n    exec_move ci P t e1 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n 2. exec_move ci P t e1 h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp')", "hence \"exec_meth ci (compP2 P) (?E1 @ compE2 e1 @ ?E2) (compxE2 e 0 0 @ shift (length ?E1) (compxE2 e1 0 0 @ shift (length (compE2 e1)) (compxE2 e2 (Suc 0) 0))) t h (stk, loc, length ?E1 + pc, xcp) ta h' (stk', loc', length ?E1 + pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_move ci P t (if (e) e1 else e2) h\n   (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n   (stk', loc', Suc (length (compE2 e) + pc'), xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P)\n     ((compE2 e @ [IfFalse (2 + int (length (compE2 e1)))]) @\n      compE2 e1 @ Goto (1 + int (length (compE2 e2))) # compE2 e2)\n     (compxE2 e 0 0 @\n      shift (length (compE2 e @ [IfFalse (2 + int (length (compE2 e1)))]))\n       (compxE2 e1 0 0 @ shift (length (compE2 e1)) (compxE2 e2 (Suc 0) 0)))\n     t h\n     (stk, loc,\n      length (compE2 e @ [IfFalse (2 + int (length (compE2 e1)))]) + pc,\n      xcp)\n     ta h'\n     (stk', loc',\n      length (compE2 e @ [IfFalse (2 + int (length (compE2 e1)))]) + pc',\n      xcp')", "by(simp add: exec_move_def shift_compxE2 ac_simps)"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P)\n   ((compE2 e @ [IfFalse (2 + int (length (compE2 e1)))]) @\n    compE2 e1 @ Goto (1 + int (length (compE2 e2))) # compE2 e2)\n   (compxE2 e 0 0 @\n    shift (length (compE2 e @ [IfFalse (2 + int (length (compE2 e1)))]))\n     (compxE2 e1 0 0 @ shift (length (compE2 e1)) (compxE2 e2 (Suc 0) 0)))\n   t h\n   (stk, loc,\n    length (compE2 e @ [IfFalse (2 + int (length (compE2 e1)))]) + pc, xcp)\n   ta h'\n   (stk', loc',\n    length (compE2 e @ [IfFalse (2 + int (length (compE2 e1)))]) + pc',\n    xcp')\n\ngoal (2 subgoals):\n 1. exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp') \\<Longrightarrow>\n    exec_move ci P t e1 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n 2. exec_move ci P t e1 h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp')", "thus ?rhs"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P)\n   ((compE2 e @ [IfFalse (2 + int (length (compE2 e1)))]) @\n    compE2 e1 @ Goto (1 + int (length (compE2 e2))) # compE2 e2)\n   (compxE2 e 0 0 @\n    shift (length (compE2 e @ [IfFalse (2 + int (length (compE2 e1)))]))\n     (compxE2 e1 0 0 @ shift (length (compE2 e1)) (compxE2 e2 (Suc 0) 0)))\n   t h\n   (stk, loc,\n    length (compE2 e @ [IfFalse (2 + int (length (compE2 e1)))]) + pc, xcp)\n   ta h'\n   (stk', loc',\n    length (compE2 e @ [IfFalse (2 + int (length (compE2 e1)))]) + pc',\n    xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t e1 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "unfolding exec_move_def"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P)\n   ((compE2 e @ [IfFalse (2 + int (length (compE2 e1)))]) @\n    compE2 e1 @ Goto (1 + int (length (compE2 e2))) # compE2 e2)\n   (compxE2 e 0 0 @\n    shift (length (compE2 e @ [IfFalse (2 + int (length (compE2 e1)))]))\n     (compxE2 e1 0 0 @ shift (length (compE2 e1)) (compxE2 e2 (Suc 0) 0)))\n   t h\n   (stk, loc,\n    length (compE2 e @ [IfFalse (2 + int (length (compE2 e1)))]) + pc, xcp)\n   ta h'\n   (stk', loc',\n    length (compE2 e @ [IfFalse (2 + int (length (compE2 e1)))]) + pc',\n    xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e1) (compxE2 e1 0 0) t h\n     (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "by -(rule exec_meth_take_xt,drule exec_meth_drop_xt,auto simp add: pc)"], ["proof (state)\nthis:\n  exec_move ci P t e1 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t e1 h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp')", "qed(rule exec_move_CondI2)"], ["", "lemma exec_move_CondI3:\n  assumes exec: \"exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  shows \"exec_move ci P t (if (e) e1 else e2) h (stk, loc, Suc (Suc (length (compE2 e) + length (compE2 e1) + pc)), xcp) ta h' (stk', loc', Suc (Suc (length (compE2 e) + length (compE2 e1) + pc')), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (Suc (length (compE2 e) + length (compE2 e1) + pc)),\n      xcp)\n     ta h'\n     (stk', loc', Suc (Suc (length (compE2 e) + length (compE2 e1) + pc')),\n      xcp')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (Suc (length (compE2 e) + length (compE2 e1) + pc)),\n      xcp)\n     ta h'\n     (stk', loc', Suc (Suc (length (compE2 e) + length (compE2 e1) + pc')),\n      xcp')", "let ?E = \"compE2 e @ IfFalse (2 + int (length (compE2 e1))) # compE2 e1 @ [Goto (1 + int (length (compE2 e2)))]\""], ["proof (state)\ngoal (1 subgoal):\n 1. exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (Suc (length (compE2 e) + length (compE2 e1) + pc)),\n      xcp)\n     ta h'\n     (stk', loc', Suc (Suc (length (compE2 e) + length (compE2 e1) + pc')),\n      xcp')", "let ?xt = \"compxE2 e 0 0 @ compxE2 e1 (Suc (length (compE2 e))) 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (Suc (length (compE2 e) + length (compE2 e1) + pc)),\n      xcp)\n     ta h'\n     (stk', loc', Suc (Suc (length (compE2 e) + length (compE2 e1) + pc')),\n      xcp')", "from exec"], ["proof (chain)\npicking this:\n  exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "have \"exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 0) t h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 0) t h\n     (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "by(simp add: exec_move_def)"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 0) t h\n   (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (Suc (length (compE2 e) + length (compE2 e1) + pc)),\n      xcp)\n     ta h'\n     (stk', loc', Suc (Suc (length (compE2 e) + length (compE2 e1) + pc')),\n      xcp')", "hence \"exec_meth ci (compP2 P) (?E @ compE2 e2) (?xt @ shift (length ?E) (compxE2 e2 0 0)) t h (stk, loc, length ?E + pc, xcp) ta h' (stk', loc', length ?E + pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 0) t h\n   (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P)\n     ((compE2 e @\n       IfFalse (2 + int (length (compE2 e1))) #\n       compE2 e1 @ [Goto (1 + int (length (compE2 e2)))]) @\n      compE2 e2)\n     ((compxE2 e 0 0 @ compxE2 e1 (Suc (length (compE2 e))) 0) @\n      shift\n       (length\n         (compE2 e @\n          IfFalse (2 + int (length (compE2 e1))) #\n          compE2 e1 @ [Goto (1 + int (length (compE2 e2)))]))\n       (compxE2 e2 0 0))\n     t h\n     (stk, loc,\n      length\n       (compE2 e @\n        IfFalse (2 + int (length (compE2 e1))) #\n        compE2 e1 @ [Goto (1 + int (length (compE2 e2)))]) +\n      pc,\n      xcp)\n     ta h'\n     (stk', loc',\n      length\n       (compE2 e @\n        IfFalse (2 + int (length (compE2 e1))) #\n        compE2 e1 @ [Goto (1 + int (length (compE2 e2)))]) +\n      pc',\n      xcp')", "by(rule append_exec_meth_xt) auto"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P)\n   ((compE2 e @\n     IfFalse (2 + int (length (compE2 e1))) #\n     compE2 e1 @ [Goto (1 + int (length (compE2 e2)))]) @\n    compE2 e2)\n   ((compxE2 e 0 0 @ compxE2 e1 (Suc (length (compE2 e))) 0) @\n    shift\n     (length\n       (compE2 e @\n        IfFalse (2 + int (length (compE2 e1))) #\n        compE2 e1 @ [Goto (1 + int (length (compE2 e2)))]))\n     (compxE2 e2 0 0))\n   t h\n   (stk, loc,\n    length\n     (compE2 e @\n      IfFalse (2 + int (length (compE2 e1))) #\n      compE2 e1 @ [Goto (1 + int (length (compE2 e2)))]) +\n    pc,\n    xcp)\n   ta h'\n   (stk', loc',\n    length\n     (compE2 e @\n      IfFalse (2 + int (length (compE2 e1))) #\n      compE2 e1 @ [Goto (1 + int (length (compE2 e2)))]) +\n    pc',\n    xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (Suc (length (compE2 e) + length (compE2 e1) + pc)),\n      xcp)\n     ta h'\n     (stk', loc', Suc (Suc (length (compE2 e) + length (compE2 e1) + pc')),\n      xcp')", "thus ?thesis"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P)\n   ((compE2 e @\n     IfFalse (2 + int (length (compE2 e1))) #\n     compE2 e1 @ [Goto (1 + int (length (compE2 e2)))]) @\n    compE2 e2)\n   ((compxE2 e 0 0 @ compxE2 e1 (Suc (length (compE2 e))) 0) @\n    shift\n     (length\n       (compE2 e @\n        IfFalse (2 + int (length (compE2 e1))) #\n        compE2 e1 @ [Goto (1 + int (length (compE2 e2)))]))\n     (compxE2 e2 0 0))\n   t h\n   (stk, loc,\n    length\n     (compE2 e @\n      IfFalse (2 + int (length (compE2 e1))) #\n      compE2 e1 @ [Goto (1 + int (length (compE2 e2)))]) +\n    pc,\n    xcp)\n   ta h'\n   (stk', loc',\n    length\n     (compE2 e @\n      IfFalse (2 + int (length (compE2 e1))) #\n      compE2 e1 @ [Goto (1 + int (length (compE2 e2)))]) +\n    pc',\n    xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (Suc (length (compE2 e) + length (compE2 e1) + pc)),\n      xcp)\n     ta h'\n     (stk', loc', Suc (Suc (length (compE2 e) + length (compE2 e1) + pc')),\n      xcp')", "by(simp add: shift_compxE2 exec_move_def)"], ["proof (state)\nthis:\n  exec_move ci P t (if (e) e1 else e2) h\n   (stk, loc, Suc (Suc (length (compE2 e) + length (compE2 e1) + pc)), xcp)\n   ta h'\n   (stk', loc', Suc (Suc (length (compE2 e) + length (compE2 e1) + pc')),\n    xcp')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exec_move_Cond3:\n  \"exec_move ci P t (if (e) e1 else e2) h (stk, loc, Suc (Suc (length (compE2 e) + length (compE2 e1) + pc)), xcp) ta\n                                      h' (stk', loc', Suc (Suc (length (compE2 e) + length (compE2 e1) + pc')), xcp') =\n   exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (Suc (length (compE2 e) + length (compE2 e1) + pc)),\n      xcp)\n     ta h'\n     (stk', loc', Suc (Suc (length (compE2 e) + length (compE2 e1) + pc')),\n      xcp') =\n    exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (Suc (length (compE2 e) + length (compE2 e1) + pc)),\n      xcp)\n     ta h'\n     (stk', loc', Suc (Suc (length (compE2 e) + length (compE2 e1) + pc')),\n      xcp') \\<Longrightarrow>\n    exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n 2. exec_move ci P t e2 h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (Suc (length (compE2 e) + length (compE2 e1) + pc)),\n      xcp)\n     ta h'\n     (stk', loc', Suc (Suc (length (compE2 e) + length (compE2 e1) + pc')),\n      xcp')", "let ?E = \"compE2 e @ IfFalse (2 + int (length (compE2 e1))) # compE2 e1 @ [Goto (1 + int (length (compE2 e2)))]\""], ["proof (state)\ngoal (2 subgoals):\n 1. exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (Suc (length (compE2 e) + length (compE2 e1) + pc)),\n      xcp)\n     ta h'\n     (stk', loc', Suc (Suc (length (compE2 e) + length (compE2 e1) + pc')),\n      xcp') \\<Longrightarrow>\n    exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n 2. exec_move ci P t e2 h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (Suc (length (compE2 e) + length (compE2 e1) + pc)),\n      xcp)\n     ta h'\n     (stk', loc', Suc (Suc (length (compE2 e) + length (compE2 e1) + pc')),\n      xcp')", "let ?xt = \"compxE2 e 0 0 @ compxE2 e1 (Suc (length (compE2 e))) 0\""], ["proof (state)\ngoal (2 subgoals):\n 1. exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (Suc (length (compE2 e) + length (compE2 e1) + pc)),\n      xcp)\n     ta h'\n     (stk', loc', Suc (Suc (length (compE2 e) + length (compE2 e1) + pc')),\n      xcp') \\<Longrightarrow>\n    exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n 2. exec_move ci P t e2 h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (Suc (length (compE2 e) + length (compE2 e1) + pc)),\n      xcp)\n     ta h'\n     (stk', loc', Suc (Suc (length (compE2 e) + length (compE2 e1) + pc')),\n      xcp')", "assume ?lhs"], ["proof (state)\nthis:\n  exec_move ci P t (if (e) e1 else e2) h\n   (stk, loc, Suc (Suc (length (compE2 e) + length (compE2 e1) + pc)), xcp)\n   ta h'\n   (stk', loc', Suc (Suc (length (compE2 e) + length (compE2 e1) + pc')),\n    xcp')\n\ngoal (2 subgoals):\n 1. exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (Suc (length (compE2 e) + length (compE2 e1) + pc)),\n      xcp)\n     ta h'\n     (stk', loc', Suc (Suc (length (compE2 e) + length (compE2 e1) + pc')),\n      xcp') \\<Longrightarrow>\n    exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n 2. exec_move ci P t e2 h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (Suc (length (compE2 e) + length (compE2 e1) + pc)),\n      xcp)\n     ta h'\n     (stk', loc', Suc (Suc (length (compE2 e) + length (compE2 e1) + pc')),\n      xcp')", "hence \"exec_meth ci (compP2 P) (?E @ compE2 e2) (?xt @ shift (length ?E) (compxE2 e2 0 0)) t h (stk, loc, length ?E + pc, xcp) ta h' (stk', loc', length ?E + pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_move ci P t (if (e) e1 else e2) h\n   (stk, loc, Suc (Suc (length (compE2 e) + length (compE2 e1) + pc)), xcp)\n   ta h'\n   (stk', loc', Suc (Suc (length (compE2 e) + length (compE2 e1) + pc')),\n    xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P)\n     ((compE2 e @\n       IfFalse (2 + int (length (compE2 e1))) #\n       compE2 e1 @ [Goto (1 + int (length (compE2 e2)))]) @\n      compE2 e2)\n     ((compxE2 e 0 0 @ compxE2 e1 (Suc (length (compE2 e))) 0) @\n      shift\n       (length\n         (compE2 e @\n          IfFalse (2 + int (length (compE2 e1))) #\n          compE2 e1 @ [Goto (1 + int (length (compE2 e2)))]))\n       (compxE2 e2 0 0))\n     t h\n     (stk, loc,\n      length\n       (compE2 e @\n        IfFalse (2 + int (length (compE2 e1))) #\n        compE2 e1 @ [Goto (1 + int (length (compE2 e2)))]) +\n      pc,\n      xcp)\n     ta h'\n     (stk', loc',\n      length\n       (compE2 e @\n        IfFalse (2 + int (length (compE2 e1))) #\n        compE2 e1 @ [Goto (1 + int (length (compE2 e2)))]) +\n      pc',\n      xcp')", "by(simp add: shift_compxE2 exec_move_def)"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P)\n   ((compE2 e @\n     IfFalse (2 + int (length (compE2 e1))) #\n     compE2 e1 @ [Goto (1 + int (length (compE2 e2)))]) @\n    compE2 e2)\n   ((compxE2 e 0 0 @ compxE2 e1 (Suc (length (compE2 e))) 0) @\n    shift\n     (length\n       (compE2 e @\n        IfFalse (2 + int (length (compE2 e1))) #\n        compE2 e1 @ [Goto (1 + int (length (compE2 e2)))]))\n     (compxE2 e2 0 0))\n   t h\n   (stk, loc,\n    length\n     (compE2 e @\n      IfFalse (2 + int (length (compE2 e1))) #\n      compE2 e1 @ [Goto (1 + int (length (compE2 e2)))]) +\n    pc,\n    xcp)\n   ta h'\n   (stk', loc',\n    length\n     (compE2 e @\n      IfFalse (2 + int (length (compE2 e1))) #\n      compE2 e1 @ [Goto (1 + int (length (compE2 e2)))]) +\n    pc',\n    xcp')\n\ngoal (2 subgoals):\n 1. exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (Suc (length (compE2 e) + length (compE2 e1) + pc)),\n      xcp)\n     ta h'\n     (stk', loc', Suc (Suc (length (compE2 e) + length (compE2 e1) + pc')),\n      xcp') \\<Longrightarrow>\n    exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n 2. exec_move ci P t e2 h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (Suc (length (compE2 e) + length (compE2 e1) + pc)),\n      xcp)\n     ta h'\n     (stk', loc', Suc (Suc (length (compE2 e) + length (compE2 e1) + pc')),\n      xcp')", "thus ?rhs"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P)\n   ((compE2 e @\n     IfFalse (2 + int (length (compE2 e1))) #\n     compE2 e1 @ [Goto (1 + int (length (compE2 e2)))]) @\n    compE2 e2)\n   ((compxE2 e 0 0 @ compxE2 e1 (Suc (length (compE2 e))) 0) @\n    shift\n     (length\n       (compE2 e @\n        IfFalse (2 + int (length (compE2 e1))) #\n        compE2 e1 @ [Goto (1 + int (length (compE2 e2)))]))\n     (compxE2 e2 0 0))\n   t h\n   (stk, loc,\n    length\n     (compE2 e @\n      IfFalse (2 + int (length (compE2 e1))) #\n      compE2 e1 @ [Goto (1 + int (length (compE2 e2)))]) +\n    pc,\n    xcp)\n   ta h'\n   (stk', loc',\n    length\n     (compE2 e @\n      IfFalse (2 + int (length (compE2 e1))) #\n      compE2 e1 @ [Goto (1 + int (length (compE2 e2)))]) +\n    pc',\n    xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "unfolding exec_move_def"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P)\n   ((compE2 e @\n     IfFalse (2 + int (length (compE2 e1))) #\n     compE2 e1 @ [Goto (1 + int (length (compE2 e2)))]) @\n    compE2 e2)\n   ((compxE2 e 0 0 @ compxE2 e1 (Suc (length (compE2 e))) 0) @\n    shift\n     (length\n       (compE2 e @\n        IfFalse (2 + int (length (compE2 e1))) #\n        compE2 e1 @ [Goto (1 + int (length (compE2 e2)))]))\n     (compxE2 e2 0 0))\n   t h\n   (stk, loc,\n    length\n     (compE2 e @\n      IfFalse (2 + int (length (compE2 e1))) #\n      compE2 e1 @ [Goto (1 + int (length (compE2 e2)))]) +\n    pc,\n    xcp)\n   ta h'\n   (stk', loc',\n    length\n     (compE2 e @\n      IfFalse (2 + int (length (compE2 e1))) #\n      compE2 e1 @ [Goto (1 + int (length (compE2 e2)))]) +\n    pc',\n    xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e2) (compxE2 e2 0 0) t h\n     (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "by -(drule exec_meth_drop_xt, auto)"], ["proof (state)\nthis:\n  exec_move ci P t e2 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t e2 h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    exec_move ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (Suc (length (compE2 e) + length (compE2 e1) + pc)),\n      xcp)\n     ta h'\n     (stk', loc', Suc (Suc (length (compE2 e) + length (compE2 e1) + pc')),\n      xcp')", "qed(rule exec_move_CondI3)"], ["", "lemma exec_move_WhileI1:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (while (e) e') h s ta h' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t e h s ta h' s' \\<Longrightarrow>\n    exec_move ci P t (while (e) e') h s ta h' s'", "unfolding exec_move_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h s ta h'\n     s' \\<Longrightarrow>\n    exec_meth ci (compP2 P) (compE2 (while (e) e'))\n     (compxE2 (while (e) e') 0 0) t h s ta h' s'", "by auto"], ["", "lemma (in ab_group_add) uminus_minus_left_commute:\n  \"- a - (b + c) = - b - (a + c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - a - (b + c) = - b - (a + c)", "by (simp add: algebra_simps)"], ["", "lemma exec_move_While1:\n  assumes pc: \"pc < length (compE2 e)\"\n  shows \"exec_move ci P t (while (e) e') h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t (while (e) e') h (stk, loc, pc, xcp) =\n    exec_move ci P t e h (stk, loc, pc, xcp)", "proof(rule ext iffI)+"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       exec_move ci P t (while (e) e') h (stk, loc, pc, xcp) x xa\n        xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb\n 2. \\<And>x xa xb.\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t (while (e) e') h (stk, loc, pc, xcp) x xa xb", "let ?E = \"IfFalse (3 + int (length (compE2 e'))) # compE2 e' @ [Pop, Goto (- int (length (compE2 e)) + (-2 - int (length (compE2 e')))), Push Unit]\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       exec_move ci P t (while (e) e') h (stk, loc, pc, xcp) x xa\n        xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb\n 2. \\<And>x xa xb.\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t (while (e) e') h (stk, loc, pc, xcp) x xa xb", "let ?xt = \"compxE2 e' (Suc 0) 0\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       exec_move ci P t (while (e) e') h (stk, loc, pc, xcp) x xa\n        xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb\n 2. \\<And>x xa xb.\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t (while (e) e') h (stk, loc, pc, xcp) x xa xb", "fix ta h' s'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       exec_move ci P t (while (e) e') h (stk, loc, pc, xcp) x xa\n        xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb\n 2. \\<And>x xa xb.\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t (while (e) e') h (stk, loc, pc, xcp) x xa xb", "assume \"?lhs ta h' s'\""], ["proof (state)\nthis:\n  exec_move ci P t (while (e) e') h (stk, loc, pc, xcp) ta h' s'\n\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       exec_move ci P t (while (e) e') h (stk, loc, pc, xcp) x xa\n        xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb\n 2. \\<And>x xa xb.\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t (while (e) e') h (stk, loc, pc, xcp) x xa xb", "then"], ["proof (chain)\npicking this:\n  exec_move ci P t (while (e) e') h (stk, loc, pc, xcp) ta h' s'", "have \"exec_meth ci (compP2 P) (compE2 e @ ?E) (compxE2 e 0 0 @ shift (length (compE2 e)) ?xt) t h (stk, loc, pc, xcp) ta h' s'\""], ["proof (prove)\nusing this:\n  exec_move ci P t (while (e) e') h (stk, loc, pc, xcp) ta h' s'\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P)\n     (compE2 e @\n      IfFalse (3 + int (length (compE2 e'))) #\n      compE2 e' @\n      [Pop,\n       Goto (- int (length (compE2 e)) + (- 2 - int (length (compE2 e')))),\n       Push Unit])\n     (compxE2 e 0 0 @ shift (length (compE2 e)) (compxE2 e' (Suc 0) 0)) t h\n     (stk, loc, pc, xcp) ta h' s'", "by (simp add: exec_move_def shift_compxE2 algebra_simps uminus_minus_left_commute)"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P)\n   (compE2 e @\n    IfFalse (3 + int (length (compE2 e'))) #\n    compE2 e' @\n    [Pop,\n     Goto (- int (length (compE2 e)) + (- 2 - int (length (compE2 e')))),\n     Push Unit])\n   (compxE2 e 0 0 @ shift (length (compE2 e)) (compxE2 e' (Suc 0) 0)) t h\n   (stk, loc, pc, xcp) ta h' s'\n\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       exec_move ci P t (while (e) e') h (stk, loc, pc, xcp) x xa\n        xb \\<Longrightarrow>\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb\n 2. \\<And>x xa xb.\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t (while (e) e') h (stk, loc, pc, xcp) x xa xb", "thus \"?rhs ta h' s'\""], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P)\n   (compE2 e @\n    IfFalse (3 + int (length (compE2 e'))) #\n    compE2 e' @\n    [Pop,\n     Goto (- int (length (compE2 e)) + (- 2 - int (length (compE2 e')))),\n     Push Unit])\n   (compxE2 e 0 0 @ shift (length (compE2 e)) (compxE2 e' (Suc 0) 0)) t h\n   (stk, loc, pc, xcp) ta h' s'\n\ngoal (1 subgoal):\n 1. exec_move ci P t e h (stk, loc, pc, xcp) ta h' s'", "unfolding exec_move_def"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P)\n   (compE2 e @\n    IfFalse (3 + int (length (compE2 e'))) #\n    compE2 e' @\n    [Pop,\n     Goto (- int (length (compE2 e)) + (- 2 - int (length (compE2 e')))),\n     Push Unit])\n   (compxE2 e 0 0 @ shift (length (compE2 e)) (compxE2 e' (Suc 0) 0)) t h\n   (stk, loc, pc, xcp) ta h' s'\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h\n     (stk, loc, pc, xcp) ta h' s'", "using pc"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P)\n   (compE2 e @\n    IfFalse (3 + int (length (compE2 e'))) #\n    compE2 e' @\n    [Pop,\n     Goto (- int (length (compE2 e)) + (- 2 - int (length (compE2 e')))),\n     Push Unit])\n   (compxE2 e 0 0 @ shift (length (compE2 e)) (compxE2 e' (Suc 0) 0)) t h\n   (stk, loc, pc, xcp) ta h' s'\n  pc < length (compE2 e)\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h\n     (stk, loc, pc, xcp) ta h' s'", "by(rule exec_meth_take_xt)"], ["proof (state)\nthis:\n  exec_move ci P t e h (stk, loc, pc, xcp) ta h' s'\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       exec_move ci P t e h (stk, loc, pc, xcp) x xa xb \\<Longrightarrow>\n       exec_move ci P t (while (e) e') h (stk, loc, pc, xcp) x xa xb", "qed(rule exec_move_WhileI1)"], ["", "lemma exec_move_WhileI2:\n  assumes exec: \"exec_move ci P t e1 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  shows \"exec_move ci P t (while (e) e1) h (stk, loc, (Suc (length (compE2 e) + pc)), xcp) ta h' (stk', loc', (Suc (length (compE2 e) + pc')), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t (while (e) e1) h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. exec_move ci P t (while (e) e1) h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp')", "let ?E = \"compE2 e @ [IfFalse (3 + int (length (compE2 e1)))]\""], ["proof (state)\ngoal (1 subgoal):\n 1. exec_move ci P t (while (e) e1) h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp')", "let ?E' = \"[Pop, Goto (- int (length (compE2 e)) + (-2 - int (length (compE2 e1)))), Push Unit]\""], ["proof (state)\ngoal (1 subgoal):\n 1. exec_move ci P t (while (e) e1) h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp')", "from exec"], ["proof (chain)\npicking this:\n  exec_move ci P t e1 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "have \"exec_meth ci (compP2 P) (compE2 e1) (compxE2 e1 0 0) t h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_move ci P t e1 h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e1) (compxE2 e1 0 0) t h\n     (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "by(simp add: exec_move_def)"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) (compE2 e1) (compxE2 e1 0 0) t h\n   (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (while (e) e1) h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp')", "hence \"exec_meth ci (compP2 P) ((?E @ compE2 e1) @ ?E') (compxE2 e 0 0 @ shift (length ?E) (compxE2 e1 0 0)) t h (stk, loc, length ?E + pc, xcp) ta h' (stk', loc', length ?E + pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e1) (compxE2 e1 0 0) t h\n   (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P)\n     (((compE2 e @ [IfFalse (3 + int (length (compE2 e1)))]) @ compE2 e1) @\n      [Pop,\n       Goto (- int (length (compE2 e)) + (- 2 - int (length (compE2 e1)))),\n       Push Unit])\n     (compxE2 e 0 0 @\n      shift (length (compE2 e @ [IfFalse (3 + int (length (compE2 e1)))]))\n       (compxE2 e1 0 0))\n     t h\n     (stk, loc,\n      length (compE2 e @ [IfFalse (3 + int (length (compE2 e1)))]) + pc,\n      xcp)\n     ta h'\n     (stk', loc',\n      length (compE2 e @ [IfFalse (3 + int (length (compE2 e1)))]) + pc',\n      xcp')", "by -(rule exec_meth_append, rule append_exec_meth_xt, auto)"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P)\n   (((compE2 e @ [IfFalse (3 + int (length (compE2 e1)))]) @ compE2 e1) @\n    [Pop,\n     Goto (- int (length (compE2 e)) + (- 2 - int (length (compE2 e1)))),\n     Push Unit])\n   (compxE2 e 0 0 @\n    shift (length (compE2 e @ [IfFalse (3 + int (length (compE2 e1)))]))\n     (compxE2 e1 0 0))\n   t h\n   (stk, loc,\n    length (compE2 e @ [IfFalse (3 + int (length (compE2 e1)))]) + pc, xcp)\n   ta h'\n   (stk', loc',\n    length (compE2 e @ [IfFalse (3 + int (length (compE2 e1)))]) + pc',\n    xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (while (e) e1) h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp')", "thus ?thesis"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P)\n   (((compE2 e @ [IfFalse (3 + int (length (compE2 e1)))]) @ compE2 e1) @\n    [Pop,\n     Goto (- int (length (compE2 e)) + (- 2 - int (length (compE2 e1)))),\n     Push Unit])\n   (compxE2 e 0 0 @\n    shift (length (compE2 e @ [IfFalse (3 + int (length (compE2 e1)))]))\n     (compxE2 e1 0 0))\n   t h\n   (stk, loc,\n    length (compE2 e @ [IfFalse (3 + int (length (compE2 e1)))]) + pc, xcp)\n   ta h'\n   (stk', loc',\n    length (compE2 e @ [IfFalse (3 + int (length (compE2 e1)))]) + pc',\n    xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (while (e) e1) h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp')", "by (simp add: shift_compxE2 exec_move_def algebra_simps uminus_minus_left_commute)"], ["proof (state)\nthis:\n  exec_move ci P t (while (e) e1) h\n   (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n   (stk', loc', Suc (length (compE2 e) + pc'), xcp')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exec_move_While2:\n  assumes pc: \"pc < length (compE2 e')\"\n  shows \"exec_move ci P t (while (e) e') h (stk, loc, (Suc (length (compE2 e) + pc)), xcp) ta\n                                    h' (stk', loc', (Suc (length (compE2 e) + pc')), xcp') =\n         exec_move ci P t e' h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t (while (e) e') h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp') =\n    exec_move ci P t e' h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. exec_move ci P t (while (e) e') h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp') \\<Longrightarrow>\n    exec_move ci P t e' h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n 2. exec_move ci P t e' h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    exec_move ci P t (while (e) e') h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp')", "let ?E = \"compE2 e @ [IfFalse (3 + int (length (compE2 e')))]\""], ["proof (state)\ngoal (2 subgoals):\n 1. exec_move ci P t (while (e) e') h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp') \\<Longrightarrow>\n    exec_move ci P t e' h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n 2. exec_move ci P t e' h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    exec_move ci P t (while (e) e') h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp')", "let ?E' = \"[Pop, Goto (- int (length (compE2 e)) + (-2 - int (length (compE2 e')))), Push Unit]\""], ["proof (state)\ngoal (2 subgoals):\n 1. exec_move ci P t (while (e) e') h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp') \\<Longrightarrow>\n    exec_move ci P t e' h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n 2. exec_move ci P t e' h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    exec_move ci P t (while (e) e') h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp')", "assume ?lhs"], ["proof (state)\nthis:\n  exec_move ci P t (while (e) e') h\n   (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n   (stk', loc', Suc (length (compE2 e) + pc'), xcp')\n\ngoal (2 subgoals):\n 1. exec_move ci P t (while (e) e') h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp') \\<Longrightarrow>\n    exec_move ci P t e' h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n 2. exec_move ci P t e' h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    exec_move ci P t (while (e) e') h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp')", "hence \"exec_meth ci (compP2 P) ((?E @ compE2 e') @ ?E') (compxE2 e 0 0 @ shift (length ?E) (compxE2 e' 0 0)) t h (stk, loc, length ?E + pc, xcp) ta h' (stk', loc', length ?E + pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_move ci P t (while (e) e') h\n   (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n   (stk', loc', Suc (length (compE2 e) + pc'), xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P)\n     (((compE2 e @ [IfFalse (3 + int (length (compE2 e')))]) @ compE2 e') @\n      [Pop,\n       Goto (- int (length (compE2 e)) + (- 2 - int (length (compE2 e')))),\n       Push Unit])\n     (compxE2 e 0 0 @\n      shift (length (compE2 e @ [IfFalse (3 + int (length (compE2 e')))]))\n       (compxE2 e' 0 0))\n     t h\n     (stk, loc,\n      length (compE2 e @ [IfFalse (3 + int (length (compE2 e')))]) + pc,\n      xcp)\n     ta h'\n     (stk', loc',\n      length (compE2 e @ [IfFalse (3 + int (length (compE2 e')))]) + pc',\n      xcp')", "by(simp add: exec_move_def shift_compxE2 algebra_simps uminus_minus_left_commute)"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P)\n   (((compE2 e @ [IfFalse (3 + int (length (compE2 e')))]) @ compE2 e') @\n    [Pop,\n     Goto (- int (length (compE2 e)) + (- 2 - int (length (compE2 e')))),\n     Push Unit])\n   (compxE2 e 0 0 @\n    shift (length (compE2 e @ [IfFalse (3 + int (length (compE2 e')))]))\n     (compxE2 e' 0 0))\n   t h\n   (stk, loc,\n    length (compE2 e @ [IfFalse (3 + int (length (compE2 e')))]) + pc, xcp)\n   ta h'\n   (stk', loc',\n    length (compE2 e @ [IfFalse (3 + int (length (compE2 e')))]) + pc',\n    xcp')\n\ngoal (2 subgoals):\n 1. exec_move ci P t (while (e) e') h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp') \\<Longrightarrow>\n    exec_move ci P t e' h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n 2. exec_move ci P t e' h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    exec_move ci P t (while (e) e') h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp')", "thus ?rhs"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P)\n   (((compE2 e @ [IfFalse (3 + int (length (compE2 e')))]) @ compE2 e') @\n    [Pop,\n     Goto (- int (length (compE2 e)) + (- 2 - int (length (compE2 e')))),\n     Push Unit])\n   (compxE2 e 0 0 @\n    shift (length (compE2 e @ [IfFalse (3 + int (length (compE2 e')))]))\n     (compxE2 e' 0 0))\n   t h\n   (stk, loc,\n    length (compE2 e @ [IfFalse (3 + int (length (compE2 e')))]) + pc, xcp)\n   ta h'\n   (stk', loc',\n    length (compE2 e @ [IfFalse (3 + int (length (compE2 e')))]) + pc',\n    xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t e' h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "unfolding exec_move_def"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P)\n   (((compE2 e @ [IfFalse (3 + int (length (compE2 e')))]) @ compE2 e') @\n    [Pop,\n     Goto (- int (length (compE2 e)) + (- 2 - int (length (compE2 e')))),\n     Push Unit])\n   (compxE2 e 0 0 @\n    shift (length (compE2 e @ [IfFalse (3 + int (length (compE2 e')))]))\n     (compxE2 e' 0 0))\n   t h\n   (stk, loc,\n    length (compE2 e @ [IfFalse (3 + int (length (compE2 e')))]) + pc, xcp)\n   ta h'\n   (stk', loc',\n    length (compE2 e @ [IfFalse (3 + int (length (compE2 e')))]) + pc',\n    xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e') (compxE2 e' 0 0) t h\n     (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "using pc"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P)\n   (((compE2 e @ [IfFalse (3 + int (length (compE2 e')))]) @ compE2 e') @\n    [Pop,\n     Goto (- int (length (compE2 e)) + (- 2 - int (length (compE2 e')))),\n     Push Unit])\n   (compxE2 e 0 0 @\n    shift (length (compE2 e @ [IfFalse (3 + int (length (compE2 e')))]))\n     (compxE2 e' 0 0))\n   t h\n   (stk, loc,\n    length (compE2 e @ [IfFalse (3 + int (length (compE2 e')))]) + pc, xcp)\n   ta h'\n   (stk', loc',\n    length (compE2 e @ [IfFalse (3 + int (length (compE2 e')))]) + pc',\n    xcp')\n  pc < length (compE2 e')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e') (compxE2 e' 0 0) t h\n     (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "by -(drule exec_meth_take, simp, drule exec_meth_drop_xt, auto)"], ["proof (state)\nthis:\n  exec_move ci P t e' h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t e' h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    exec_move ci P t (while (e) e') h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp) ta h'\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp')", "qed(rule exec_move_WhileI2)"], ["", "lemma exec_move_ThrowI:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (throw e) h s ta h' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t e h s ta h' s' \\<Longrightarrow>\n    exec_move ci P t (throw e) h s ta h' s'", "unfolding exec_move_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h s ta h'\n     s' \\<Longrightarrow>\n    exec_meth ci (compP2 P) (compE2 (throw e)) (compxE2 (throw e) 0 0) t h s\n     ta h' s'", "by auto"], ["", "lemma exec_move_Throw:\n  \"pc < length (compE2 e) \\<Longrightarrow> exec_move ci P t (throw e) h (stk, loc, pc, xcp) = exec_move ci P t e h (stk, loc, pc, xcp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (compE2 e) \\<Longrightarrow>\n    exec_move ci P t (throw e) h (stk, loc, pc, xcp) =\n    exec_move ci P t e h (stk, loc, pc, xcp)", "unfolding exec_move_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (compE2 e) \\<Longrightarrow>\n    exec_meth ci (compP2 P) (compE2 (throw e)) (compxE2 (throw e) 0 0) t h\n     (stk, loc, pc, xcp) =\n    exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h\n     (stk, loc, pc, xcp)", "by(auto intro!: ext intro: exec_meth_take)"], ["", "lemma exec_move_TryI1:\n  \"exec_move ci P t e h s ta h' s' \\<Longrightarrow> exec_move ci P t (try e catch(C V) e') h s ta h' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t e h s ta h' s' \\<Longrightarrow>\n    exec_move ci P t (try e catch(C V) e') h s ta h' s'", "unfolding exec_move_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h s ta h'\n     s' \\<Longrightarrow>\n    exec_meth ci (compP2 P) (compE2 (try e catch(C V) e'))\n     (compxE2 (try e catch(C V) e') 0 0) t h s ta h' s'", "by auto"], ["", "lemma exec_move_TryI2:\n  assumes exec: \"exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  shows \"exec_move ci P t (try e' catch(C V) e) h (stk, loc, Suc (Suc (length (compE2 e') + pc)), xcp) ta h' (stk', loc', Suc (Suc (length (compE2 e') + pc')), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t (try e' catch(C V) e) h\n     (stk, loc, Suc (Suc (length (compE2 e') + pc)), xcp) ta h'\n     (stk', loc', Suc (Suc (length (compE2 e') + pc')), xcp')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. exec_move ci P t (try e' catch(C V) e) h\n     (stk, loc, Suc (Suc (length (compE2 e') + pc)), xcp) ta h'\n     (stk', loc', Suc (Suc (length (compE2 e') + pc')), xcp')", "let ?e = \"compE2 e' @ [Goto (int(size (compE2 e))+2), Store V]\""], ["proof (state)\ngoal (1 subgoal):\n 1. exec_move ci P t (try e' catch(C V) e) h\n     (stk, loc, Suc (Suc (length (compE2 e') + pc)), xcp) ta h'\n     (stk', loc', Suc (Suc (length (compE2 e') + pc')), xcp')", "from exec"], ["proof (chain)\npicking this:\n  exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "have \"exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_move ci P t e h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h\n     (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "by(simp add: exec_move_def)"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h (stk, loc, pc, xcp)\n   ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (try e' catch(C V) e) h\n     (stk, loc, Suc (Suc (length (compE2 e') + pc)), xcp) ta h'\n     (stk', loc', Suc (Suc (length (compE2 e') + pc')), xcp')", "hence \"exec_meth ci (compP2 P) ((?e @ compE2 e) @ []) ((compxE2 e' 0 0 @ shift (length ?e) (compxE2 e 0 0)) @ [(0, length (compE2 e'), \\<lfloor>C\\<rfloor>, Suc (length (compE2 e')), 0)]) t h (stk, loc, (length ?e + pc), xcp) ta h' (stk', loc', (length ?e + pc'), xcp')\""], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t h (stk, loc, pc, xcp)\n   ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P)\n     (((compE2 e' @ [Goto (int (length (compE2 e)) + 2), Store V]) @\n       compE2 e) @\n      [])\n     ((compxE2 e' 0 0 @\n       shift\n        (length (compE2 e' @ [Goto (int (length (compE2 e)) + 2), Store V]))\n        (compxE2 e 0 0)) @\n      [(0, length (compE2 e'), \\<lfloor>C\\<rfloor>,\n        Suc (length (compE2 e')), 0)])\n     t h\n     (stk, loc,\n      length (compE2 e' @ [Goto (int (length (compE2 e)) + 2), Store V]) +\n      pc,\n      xcp)\n     ta h'\n     (stk', loc',\n      length (compE2 e' @ [Goto (int (length (compE2 e)) + 2), Store V]) +\n      pc',\n      xcp')", "by(rule exec_meth_append_xt[OF append_exec_meth_xt]) auto"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P)\n   (((compE2 e' @ [Goto (int (length (compE2 e)) + 2), Store V]) @\n     compE2 e) @\n    [])\n   ((compxE2 e' 0 0 @\n     shift\n      (length (compE2 e' @ [Goto (int (length (compE2 e)) + 2), Store V]))\n      (compxE2 e 0 0)) @\n    [(0, length (compE2 e'), \\<lfloor>C\\<rfloor>, Suc (length (compE2 e')),\n      0)])\n   t h\n   (stk, loc,\n    length (compE2 e' @ [Goto (int (length (compE2 e)) + 2), Store V]) + pc,\n    xcp)\n   ta h'\n   (stk', loc',\n    length (compE2 e' @ [Goto (int (length (compE2 e)) + 2), Store V]) +\n    pc',\n    xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (try e' catch(C V) e) h\n     (stk, loc, Suc (Suc (length (compE2 e') + pc)), xcp) ta h'\n     (stk', loc', Suc (Suc (length (compE2 e') + pc')), xcp')", "thus ?thesis"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P)\n   (((compE2 e' @ [Goto (int (length (compE2 e)) + 2), Store V]) @\n     compE2 e) @\n    [])\n   ((compxE2 e' 0 0 @\n     shift\n      (length (compE2 e' @ [Goto (int (length (compE2 e)) + 2), Store V]))\n      (compxE2 e 0 0)) @\n    [(0, length (compE2 e'), \\<lfloor>C\\<rfloor>, Suc (length (compE2 e')),\n      0)])\n   t h\n   (stk, loc,\n    length (compE2 e' @ [Goto (int (length (compE2 e)) + 2), Store V]) + pc,\n    xcp)\n   ta h'\n   (stk', loc',\n    length (compE2 e' @ [Goto (int (length (compE2 e)) + 2), Store V]) +\n    pc',\n    xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t (try e' catch(C V) e) h\n     (stk, loc, Suc (Suc (length (compE2 e') + pc)), xcp) ta h'\n     (stk', loc', Suc (Suc (length (compE2 e') + pc')), xcp')", "by(simp add: eval_nat_numeral shift_compxE2 exec_move_def)"], ["proof (state)\nthis:\n  exec_move ci P t (try e' catch(C V) e) h\n   (stk, loc, Suc (Suc (length (compE2 e') + pc)), xcp) ta h'\n   (stk', loc', Suc (Suc (length (compE2 e') + pc')), xcp')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exec_move_Try2:\n  \"exec_move ci P t (try e catch(C V) e') h (stk, loc, Suc (Suc (length (compE2 e) + pc)), xcp) ta\n                                     h' (stk', loc', Suc (Suc (length (compE2 e) + pc')), xcp') =\n   exec_move ci P t e' h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t (try e catch(C V) e') h\n     (stk, loc, Suc (Suc (length (compE2 e) + pc)), xcp) ta h'\n     (stk', loc', Suc (Suc (length (compE2 e) + pc')), xcp') =\n    exec_move ci P t e' h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. exec_move ci P t (try e catch(C V) e') h\n     (stk, loc, Suc (Suc (length (compE2 e) + pc)), xcp) ta h'\n     (stk', loc', Suc (Suc (length (compE2 e) + pc')),\n      xcp') \\<Longrightarrow>\n    exec_move ci P t e' h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n 2. exec_move ci P t e' h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    exec_move ci P t (try e catch(C V) e') h\n     (stk, loc, Suc (Suc (length (compE2 e) + pc)), xcp) ta h'\n     (stk', loc', Suc (Suc (length (compE2 e) + pc')), xcp')", "let ?E = \"compE2 e @ [Goto (int(size (compE2 e'))+2), Store V]\""], ["proof (state)\ngoal (2 subgoals):\n 1. exec_move ci P t (try e catch(C V) e') h\n     (stk, loc, Suc (Suc (length (compE2 e) + pc)), xcp) ta h'\n     (stk', loc', Suc (Suc (length (compE2 e) + pc')),\n      xcp') \\<Longrightarrow>\n    exec_move ci P t e' h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n 2. exec_move ci P t e' h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    exec_move ci P t (try e catch(C V) e') h\n     (stk, loc, Suc (Suc (length (compE2 e) + pc)), xcp) ta h'\n     (stk', loc', Suc (Suc (length (compE2 e) + pc')), xcp')", "let ?xt = \"[(0, length (compE2 e), \\<lfloor>C\\<rfloor>, Suc (length (compE2 e)), 0)]\""], ["proof (state)\ngoal (2 subgoals):\n 1. exec_move ci P t (try e catch(C V) e') h\n     (stk, loc, Suc (Suc (length (compE2 e) + pc)), xcp) ta h'\n     (stk', loc', Suc (Suc (length (compE2 e) + pc')),\n      xcp') \\<Longrightarrow>\n    exec_move ci P t e' h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n 2. exec_move ci P t e' h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    exec_move ci P t (try e catch(C V) e') h\n     (stk, loc, Suc (Suc (length (compE2 e) + pc)), xcp) ta h'\n     (stk', loc', Suc (Suc (length (compE2 e) + pc')), xcp')", "assume lhs: ?lhs"], ["proof (state)\nthis:\n  exec_move ci P t (try e catch(C V) e') h\n   (stk, loc, Suc (Suc (length (compE2 e) + pc)), xcp) ta h'\n   (stk', loc', Suc (Suc (length (compE2 e) + pc')), xcp')\n\ngoal (2 subgoals):\n 1. exec_move ci P t (try e catch(C V) e') h\n     (stk, loc, Suc (Suc (length (compE2 e) + pc)), xcp) ta h'\n     (stk', loc', Suc (Suc (length (compE2 e) + pc')),\n      xcp') \\<Longrightarrow>\n    exec_move ci P t e' h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n 2. exec_move ci P t e' h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    exec_move ci P t (try e catch(C V) e') h\n     (stk, loc, Suc (Suc (length (compE2 e) + pc)), xcp) ta h'\n     (stk', loc', Suc (Suc (length (compE2 e) + pc')), xcp')", "hence pc: \"pc < length (compE2 e')\""], ["proof (prove)\nusing this:\n  exec_move ci P t (try e catch(C V) e') h\n   (stk, loc, Suc (Suc (length (compE2 e) + pc)), xcp) ta h'\n   (stk', loc', Suc (Suc (length (compE2 e) + pc')), xcp')\n\ngoal (1 subgoal):\n 1. pc < length (compE2 e')", "by(fastforce elim!: exec_meth.cases simp add: exec_move_def match_ex_table_append match_ex_entry dest: match_ex_table_pcsD)"], ["proof (state)\nthis:\n  pc < length (compE2 e')\n\ngoal (2 subgoals):\n 1. exec_move ci P t (try e catch(C V) e') h\n     (stk, loc, Suc (Suc (length (compE2 e) + pc)), xcp) ta h'\n     (stk', loc', Suc (Suc (length (compE2 e) + pc')),\n      xcp') \\<Longrightarrow>\n    exec_move ci P t e' h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n 2. exec_move ci P t e' h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    exec_move ci P t (try e catch(C V) e') h\n     (stk, loc, Suc (Suc (length (compE2 e) + pc)), xcp) ta h'\n     (stk', loc', Suc (Suc (length (compE2 e) + pc')), xcp')", "from lhs"], ["proof (chain)\npicking this:\n  exec_move ci P t (try e catch(C V) e') h\n   (stk, loc, Suc (Suc (length (compE2 e) + pc)), xcp) ta h'\n   (stk', loc', Suc (Suc (length (compE2 e) + pc')), xcp')", "have \"exec_meth ci (compP2 P) ((?E @ compE2 e') @ []) ((compxE2 e 0 0 @ shift (length ?E) (compxE2 e' 0 0)) @ ?xt) t h (stk, loc, length ?E + pc, xcp) ta h' (stk', loc', length ?E + pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_move ci P t (try e catch(C V) e') h\n   (stk, loc, Suc (Suc (length (compE2 e) + pc)), xcp) ta h'\n   (stk', loc', Suc (Suc (length (compE2 e) + pc')), xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P)\n     (((compE2 e @ [Goto (int (length (compE2 e')) + 2), Store V]) @\n       compE2 e') @\n      [])\n     ((compxE2 e 0 0 @\n       shift\n        (length (compE2 e @ [Goto (int (length (compE2 e')) + 2), Store V]))\n        (compxE2 e' 0 0)) @\n      [(0, length (compE2 e), \\<lfloor>C\\<rfloor>, Suc (length (compE2 e)),\n        0)])\n     t h\n     (stk, loc,\n      length (compE2 e @ [Goto (int (length (compE2 e')) + 2), Store V]) +\n      pc,\n      xcp)\n     ta h'\n     (stk', loc',\n      length (compE2 e @ [Goto (int (length (compE2 e')) + 2), Store V]) +\n      pc',\n      xcp')", "by(simp add: exec_move_def shift_compxE2 ac_simps)"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P)\n   (((compE2 e @ [Goto (int (length (compE2 e')) + 2), Store V]) @\n     compE2 e') @\n    [])\n   ((compxE2 e 0 0 @\n     shift\n      (length (compE2 e @ [Goto (int (length (compE2 e')) + 2), Store V]))\n      (compxE2 e' 0 0)) @\n    [(0, length (compE2 e), \\<lfloor>C\\<rfloor>, Suc (length (compE2 e)),\n      0)])\n   t h\n   (stk, loc,\n    length (compE2 e @ [Goto (int (length (compE2 e')) + 2), Store V]) + pc,\n    xcp)\n   ta h'\n   (stk', loc',\n    length (compE2 e @ [Goto (int (length (compE2 e')) + 2), Store V]) +\n    pc',\n    xcp')\n\ngoal (2 subgoals):\n 1. exec_move ci P t (try e catch(C V) e') h\n     (stk, loc, Suc (Suc (length (compE2 e) + pc)), xcp) ta h'\n     (stk', loc', Suc (Suc (length (compE2 e) + pc')),\n      xcp') \\<Longrightarrow>\n    exec_move ci P t e' h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n 2. exec_move ci P t e' h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    exec_move ci P t (try e catch(C V) e') h\n     (stk, loc, Suc (Suc (length (compE2 e) + pc)), xcp) ta h'\n     (stk', loc', Suc (Suc (length (compE2 e) + pc')), xcp')", "thus ?rhs"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P)\n   (((compE2 e @ [Goto (int (length (compE2 e')) + 2), Store V]) @\n     compE2 e') @\n    [])\n   ((compxE2 e 0 0 @\n     shift\n      (length (compE2 e @ [Goto (int (length (compE2 e')) + 2), Store V]))\n      (compxE2 e' 0 0)) @\n    [(0, length (compE2 e), \\<lfloor>C\\<rfloor>, Suc (length (compE2 e)),\n      0)])\n   t h\n   (stk, loc,\n    length (compE2 e @ [Goto (int (length (compE2 e')) + 2), Store V]) + pc,\n    xcp)\n   ta h'\n   (stk', loc',\n    length (compE2 e @ [Goto (int (length (compE2 e')) + 2), Store V]) +\n    pc',\n    xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t e' h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "unfolding exec_move_def"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P)\n   (((compE2 e @ [Goto (int (length (compE2 e')) + 2), Store V]) @\n     compE2 e') @\n    [])\n   ((compxE2 e 0 0 @\n     shift\n      (length (compE2 e @ [Goto (int (length (compE2 e')) + 2), Store V]))\n      (compxE2 e' 0 0)) @\n    [(0, length (compE2 e), \\<lfloor>C\\<rfloor>, Suc (length (compE2 e)),\n      0)])\n   t h\n   (stk, loc,\n    length (compE2 e @ [Goto (int (length (compE2 e')) + 2), Store V]) + pc,\n    xcp)\n   ta h'\n   (stk', loc',\n    length (compE2 e @ [Goto (int (length (compE2 e')) + 2), Store V]) +\n    pc',\n    xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e') (compxE2 e' 0 0) t h\n     (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "using pc"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P)\n   (((compE2 e @ [Goto (int (length (compE2 e')) + 2), Store V]) @\n     compE2 e') @\n    [])\n   ((compxE2 e 0 0 @\n     shift\n      (length (compE2 e @ [Goto (int (length (compE2 e')) + 2), Store V]))\n      (compxE2 e' 0 0)) @\n    [(0, length (compE2 e), \\<lfloor>C\\<rfloor>, Suc (length (compE2 e)),\n      0)])\n   t h\n   (stk, loc,\n    length (compE2 e @ [Goto (int (length (compE2 e')) + 2), Store V]) + pc,\n    xcp)\n   ta h'\n   (stk', loc',\n    length (compE2 e @ [Goto (int (length (compE2 e')) + 2), Store V]) +\n    pc',\n    xcp')\n  pc < length (compE2 e')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e') (compxE2 e' 0 0) t h\n     (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "by-(drule exec_meth_drop_xt[OF exec_meth_take_xt'], auto)"], ["proof (state)\nthis:\n  exec_move ci P t e' h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_move ci P t e' h (stk, loc, pc, xcp) ta h'\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    exec_move ci P t (try e catch(C V) e') h\n     (stk, loc, Suc (Suc (length (compE2 e) + pc)), xcp) ta h'\n     (stk', loc', Suc (Suc (length (compE2 e) + pc')), xcp')", "qed(rule exec_move_TryI2)"], ["", "lemma exec_move_raise_xcp_pcD:\n  \"exec_move ci P t E h (stk, loc, pc, None) ta h' (stk', loc', pc', Some a) \\<Longrightarrow> pc' = pc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t E h (stk, loc, pc, None) ta h'\n     (stk', loc', pc', \\<lfloor>a\\<rfloor>) \\<Longrightarrow>\n    pc' = pc", "apply(cases \"compE2 E ! pc\")"], ["proof (prove)\ngoal (24 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>exec_move ci P t E h (stk, loc, pc, None) ta h'\n                 (stk', loc', pc', \\<lfloor>a\\<rfloor>);\n        compE2 E ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> pc' = pc\n 2. \\<And>x2.\n       \\<lbrakk>exec_move ci P t E h (stk, loc, pc, None) ta h'\n                 (stk', loc', pc', \\<lfloor>a\\<rfloor>);\n        compE2 E ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> pc' = pc\n 3. \\<And>x3.\n       \\<lbrakk>exec_move ci P t E h (stk, loc, pc, None) ta h'\n                 (stk', loc', pc', \\<lfloor>a\\<rfloor>);\n        compE2 E ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> pc' = pc\n 4. \\<And>x4.\n       \\<lbrakk>exec_move ci P t E h (stk, loc, pc, None) ta h'\n                 (stk', loc', pc', \\<lfloor>a\\<rfloor>);\n        compE2 E ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> pc' = pc\n 5. \\<And>x5.\n       \\<lbrakk>exec_move ci P t E h (stk, loc, pc, None) ta h'\n                 (stk', loc', pc', \\<lfloor>a\\<rfloor>);\n        compE2 E ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> pc' = pc\n 6. \\<lbrakk>exec_move ci P t E h (stk, loc, pc, None) ta h'\n              (stk', loc', pc', \\<lfloor>a\\<rfloor>);\n     compE2 E ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> pc' = pc\n 7. \\<lbrakk>exec_move ci P t E h (stk, loc, pc, None) ta h'\n              (stk', loc', pc', \\<lfloor>a\\<rfloor>);\n     compE2 E ! pc = AStore\\<rbrakk>\n    \\<Longrightarrow> pc' = pc\n 8. \\<lbrakk>exec_move ci P t E h (stk, loc, pc, None) ta h'\n              (stk', loc', pc', \\<lfloor>a\\<rfloor>);\n     compE2 E ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> pc' = pc\n 9. \\<And>x91 x92.\n       \\<lbrakk>exec_move ci P t E h (stk, loc, pc, None) ta h'\n                 (stk', loc', pc', \\<lfloor>a\\<rfloor>);\n        compE2 E ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> pc' = pc\n 10. \\<And>x101 x102.\n        \\<lbrakk>exec_move ci P t E h (stk, loc, pc, None) ta h'\n                  (stk', loc', pc', \\<lfloor>a\\<rfloor>);\n         compE2 E ! pc = Putfield x101 x102\\<rbrakk>\n        \\<Longrightarrow> pc' = pc\nA total of 24 subgoals...", "apply(auto simp add: exec_move_def elim!: exec_meth.cases split: if_split_asm sum.split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x141 x142 aa ab ac ad b x ae af ag va.\n       \\<lbrakk>pc < length (compE2 E);\n        ci_app ci (Invoke x141 x142) (compP2 P) h stk loc undefined\n         undefined pc [];\n        compE2 E ! pc = Invoke x141 x142;\n        ta =\n        (aa, map (convert_new_thread_action (extNTA2JVM (compP2 P))) ag, ab,\n         ac, ad, b);\n        stk ! x142 \\<noteq> Null;\n        method (compP2 P)\n         (class_type_of (the (typeof_addr h (the_Addr (stk ! x142)))))\n         x141 =\n        (x, ae, af, None);\n        case va of\n        RetVal v \\<Rightarrow>\n          \\<lfloor>a\\<rfloor> = None \\<and>\n          [(stk', loc', undefined, undefined, pc')] =\n          [(v # drop (Suc x142) stk, loc, undefined, undefined, pc + 1)]\n        | RetExc aa \\<Rightarrow>\n            \\<lfloor>a\\<rfloor> = \\<lfloor>aa\\<rfloor> \\<and>\n            [(stk', loc', undefined, undefined, pc')] =\n            [(stk, loc, undefined, undefined, pc)]\n        | RetStaySame \\<Rightarrow>\n            \\<lfloor>a\\<rfloor> = None \\<and>\n            [(stk', loc', undefined, undefined, pc')] =\n            [(stk, loc, undefined, undefined, pc)];\n        ((aa, ag, ab, ac, ad, b), va, h')\n        \\<in> red_external_aggr (compP2 P) t (the_Addr (stk ! x142)) x141\n               (rev (take x142 stk)) h\\<rbrakk>\n       \\<Longrightarrow> pc' = pc", "apply(auto split: extCallRet.split_asm simp add: split_beta)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \\<tau>exec_meth :: \n  \"('addr, 'heap) check_instr \\<Rightarrow> 'addr jvm_prog \\<Rightarrow> 'addr instr list \\<Rightarrow> ex_table \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap\n  \\<Rightarrow> ('addr val list \\<times> 'addr val list \\<times> pc \\<times> 'addr option)\n  \\<Rightarrow> ('addr val list \\<times> 'addr val list \\<times> pc \\<times> 'addr option) \\<Rightarrow> bool\"\nwhere\n  \"\\<tau>exec_meth ci P ins xt t h s s' \\<longleftrightarrow> \n  exec_meth ci P ins xt t h s \\<epsilon> h s' \\<and> (snd (snd (snd s)) = None \\<longrightarrow> \\<tau>instr P h (fst s) (ins ! fst (snd (snd s))))\""], ["", "abbreviation \\<tau>exec_meth_a\nwhere \"\\<tau>exec_meth_a \\<equiv> \\<tau>exec_meth (Abs_check_instr check_instr')\""], ["", "abbreviation \\<tau>exec_meth_d\nwhere \"\\<tau>exec_meth_d \\<equiv> \\<tau>exec_meth (Abs_check_instr check_instr)\""], ["", "lemma \\<tau>exec_methI [intro]:\n  \"\\<lbrakk> exec_meth ci P ins xt t h (stk, loc, pc, xcp) \\<epsilon> h s'; xcp = None \\<Longrightarrow> \\<tau>instr P h stk (ins ! pc) \\<rbrakk>\n   \\<Longrightarrow> \\<tau>exec_meth ci P ins xt t h (stk, loc, pc, xcp) s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>exec_meth ci P ins xt t h (stk, loc, pc, xcp)\n              \\<lbrace>\\<rbrace> h s';\n     xcp = None \\<Longrightarrow> \\<tau>instr P h stk (ins ! pc)\\<rbrakk>\n    \\<Longrightarrow> \\<tau>exec_meth ci P ins xt t h (stk, loc, pc, xcp) s'", "by(simp add: \\<tau>exec_meth_def)"], ["", "lemma \\<tau>exec_methE [elim]:\n  assumes \"\\<tau>exec_meth ci P ins xt t h s s'\"\n  obtains stk loc pc xcp\n  where \"s = (stk, loc, pc, xcp)\"\n  and \"exec_meth ci P ins xt t h (stk, loc, pc, xcp) \\<epsilon> h s'\"\n  and \"xcp = None \\<Longrightarrow> \\<tau>instr P h stk (ins ! pc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>stk loc pc xcp.\n        \\<lbrakk>s = (stk, loc, pc, xcp);\n         exec_meth ci P ins xt t h (stk, loc, pc, xcp) \\<lbrace>\\<rbrace> h\n          s';\n         xcp = None \\<Longrightarrow>\n         \\<tau>instr P h stk (ins ! pc)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<tau>exec_meth ci P ins xt t h s s'\n\ngoal (1 subgoal):\n 1. (\\<And>stk loc pc xcp.\n        \\<lbrakk>s = (stk, loc, pc, xcp);\n         exec_meth ci P ins xt t h (stk, loc, pc, xcp) \\<lbrace>\\<rbrace> h\n          s';\n         xcp = None \\<Longrightarrow>\n         \\<tau>instr P h stk (ins ! pc)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s)(auto simp add: \\<tau>exec_meth_def)"], ["", "abbreviation \\<tau>Exec_methr :: \n  \"('addr, 'heap) check_instr \\<Rightarrow> 'addr jvm_prog \\<Rightarrow> 'addr instr list \\<Rightarrow> ex_table \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \n  \\<Rightarrow> ('addr val list \\<times> 'addr val list \\<times> pc \\<times> 'addr option)\n  \\<Rightarrow> ('addr val list \\<times> 'addr val list \\<times> pc \\<times> 'addr option) \\<Rightarrow> bool\"\nwhere\n  \"\\<tau>Exec_methr ci P ins xt t h == (\\<tau>exec_meth ci P ins xt t h)^**\""], ["", "abbreviation \\<tau>Exec_metht :: \n  \"('addr, 'heap) check_instr \\<Rightarrow> 'addr jvm_prog \\<Rightarrow> 'addr instr list \\<Rightarrow> ex_table \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap\n  \\<Rightarrow> ('addr val list \\<times> 'addr val list \\<times> pc \\<times> 'addr option)\n  \\<Rightarrow> ('addr val list \\<times> 'addr val list \\<times> pc \\<times> 'addr option) \\<Rightarrow> bool\"\nwhere\n  \"\\<tau>Exec_metht ci P ins xt t h == (\\<tau>exec_meth ci P ins xt t h)^++\""], ["", "abbreviation \\<tau>Exec_methr_a\nwhere \"\\<tau>Exec_methr_a \\<equiv> \\<tau>Exec_methr (Abs_check_instr check_instr')\""], ["", "abbreviation \\<tau>Exec_methr_d\nwhere \"\\<tau>Exec_methr_d \\<equiv> \\<tau>Exec_methr (Abs_check_instr check_instr)\""], ["", "abbreviation \\<tau>Exec_metht_a\nwhere \"\\<tau>Exec_metht_a \\<equiv> \\<tau>Exec_metht (Abs_check_instr check_instr')\""], ["", "abbreviation \\<tau>Exec_metht_d\nwhere \"\\<tau>Exec_metht_d \\<equiv> \\<tau>Exec_metht (Abs_check_instr check_instr)\""], ["", "lemma \\<tau>Exec_methr_refl: \"\\<tau>Exec_methr ci P ins xt t h s s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_methr ci P ins xt t h s s", ".."], ["", "lemma \\<tau>Exec_methr_step':\n  \"\\<lbrakk> \\<tau>Exec_methr ci P ins xt t h s (stk', loc', pc', xcp');\n     \\<tau>exec_meth ci P ins xt t h (stk', loc', pc', xcp') s' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>Exec_methr ci P ins xt t h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau>Exec_methr ci P ins xt t h s (stk', loc', pc', xcp');\n     \\<tau>exec_meth ci P ins xt t h (stk', loc', pc', xcp') s'\\<rbrakk>\n    \\<Longrightarrow> \\<tau>Exec_methr ci P ins xt t h s s'", "by(rule rtranclp.rtrancl_into_rtrancl)"], ["", "lemma \\<tau>Exec_methr_step:\n  \"\\<lbrakk> \\<tau>Exec_methr ci P ins xt t h s (stk', loc', pc', xcp');\n     exec_meth ci P ins xt t h (stk', loc', pc', xcp') \\<epsilon> h s';\n     xcp' = None \\<Longrightarrow> \\<tau>instr P h stk' (ins ! pc') \\<rbrakk>\n  \\<Longrightarrow> \\<tau>Exec_methr ci P ins xt t h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau>Exec_methr ci P ins xt t h s (stk', loc', pc', xcp');\n     exec_meth ci P ins xt t h (stk', loc', pc', xcp') \\<lbrace>\\<rbrace> h\n      s';\n     xcp' = None \\<Longrightarrow> \\<tau>instr P h stk' (ins ! pc')\\<rbrakk>\n    \\<Longrightarrow> \\<tau>Exec_methr ci P ins xt t h s s'", "by(erule \\<tau>Exec_methr_step')(rule \\<tau>exec_methI)"], ["", "lemmas \\<tau>Exec_methr_intros = \\<tau>Exec_methr_refl \\<tau>Exec_methr_step"], ["", "lemmas \\<tau>Exec_methr1step = \\<tau>Exec_methr_step[OF \\<tau>Exec_methr_refl]"], ["", "lemmas \\<tau>Exec_methr2step = \\<tau>Exec_methr_step[OF \\<tau>Exec_methr_step, OF \\<tau>Exec_methr_refl]"], ["", "lemmas \\<tau>Exec_methr3step = \\<tau>Exec_methr_step[OF \\<tau>Exec_methr_step, OF \\<tau>Exec_methr_step, OF \\<tau>Exec_methr_refl]"], ["", "lemma \\<tau>Exec_methr_cases [consumes 1, case_names refl step]:\n  assumes \"\\<tau>Exec_methr ci P ins xt t h s s'\"\n  obtains \"s = s'\"\n  | stk' loc' pc' xcp'\n    where \"\\<tau>Exec_methr ci P ins xt t h s (stk', loc', pc', xcp')\"\n       \"exec_meth ci P ins xt t h (stk', loc', pc', xcp') \\<epsilon> h s'\"\n       \"xcp' = None \\<Longrightarrow> \\<tau>instr P h stk' (ins ! pc')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s = s' \\<Longrightarrow> thesis;\n     \\<And>stk' loc' pc' xcp'.\n        \\<lbrakk>\\<tau>Exec_methr ci P ins xt t h s (stk', loc', pc', xcp');\n         exec_meth ci P ins xt t h (stk', loc', pc', xcp')\n          \\<lbrace>\\<rbrace> h s';\n         xcp' = None \\<Longrightarrow>\n         \\<tau>instr P h stk' (ins ! pc')\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<tau>Exec_methr ci P ins xt t h s s'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s = s' \\<Longrightarrow> thesis;\n     \\<And>stk' loc' pc' xcp'.\n        \\<lbrakk>\\<tau>Exec_methr ci P ins xt t h s (stk', loc', pc', xcp');\n         exec_meth ci P ins xt t h (stk', loc', pc', xcp')\n          \\<lbrace>\\<rbrace> h s';\n         xcp' = None \\<Longrightarrow>\n         \\<tau>instr P h stk' (ins ! pc')\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(rule rtranclp.cases)(auto elim!: \\<tau>exec_methE)"], ["", "lemma \\<tau>Exec_methr_induct [consumes 1, case_names refl step]:\n  \"\\<lbrakk> \\<tau>Exec_methr ci P ins xt t h s s';\n     Q s;\n     \\<And>stk loc pc xcp s'. \\<lbrakk> \\<tau>Exec_methr ci P ins xt t h s (stk, loc, pc, xcp); exec_meth ci P ins xt t h (stk, loc, pc, xcp) \\<epsilon> h s';\n                          xcp = None \\<Longrightarrow> \\<tau>instr P h stk (ins ! pc); Q (stk, loc, pc, xcp) \\<rbrakk> \\<Longrightarrow> Q s' \\<rbrakk>\n  \\<Longrightarrow> Q s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau>Exec_methr ci P ins xt t h s s'; Q s;\n     \\<And>stk loc pc xcp s'.\n        \\<lbrakk>\\<tau>Exec_methr ci P ins xt t h s (stk, loc, pc, xcp);\n         exec_meth ci P ins xt t h (stk, loc, pc, xcp) \\<lbrace>\\<rbrace> h\n          s';\n         xcp = None \\<Longrightarrow> \\<tau>instr P h stk (ins ! pc);\n         Q (stk, loc, pc, xcp)\\<rbrakk>\n        \\<Longrightarrow> Q s'\\<rbrakk>\n    \\<Longrightarrow> Q s'", "by(erule (1) rtranclp_induct)(blast elim: \\<tau>exec_methE)"], ["", "lemma \\<tau>Exec_methr_trans: \n  \"\\<lbrakk> \\<tau>Exec_methr ci P ins xt t h s s'; \\<tau>Exec_methr ci P ins xt t h s' s'' \\<rbrakk> \\<Longrightarrow> \\<tau>Exec_methr ci P ins xt t h s s''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau>Exec_methr ci P ins xt t h s s';\n     \\<tau>Exec_methr ci P ins xt t h s' s''\\<rbrakk>\n    \\<Longrightarrow> \\<tau>Exec_methr ci P ins xt t h s s''", "by(rule rtranclp_trans)"], ["", "lemmas \\<tau>Exec_meth_induct_split = \\<tau>Exec_methr_induct[split_format (complete), consumes 1, case_names \\<tau>Exec_refl \\<tau>Exec_step]"], ["", "lemma \\<tau>Exec_methr_converse_cases [consumes 1, case_names refl step]:\n  assumes \"\\<tau>Exec_methr ci P ins xt t h s s'\"\n  obtains \"s = s'\"\n  | stk loc pc xcp s''\n    where \"s = (stk, loc, pc, xcp)\"\n       \"exec_meth ci P ins xt t h (stk, loc, pc, xcp) \\<epsilon> h s''\"\n       \"xcp = None \\<Longrightarrow> \\<tau>instr P h stk (ins ! pc)\"\n       \"\\<tau>Exec_methr ci P ins xt t h s'' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s = s' \\<Longrightarrow> thesis;\n     \\<And>stk loc pc xcp s''.\n        \\<lbrakk>s = (stk, loc, pc, xcp);\n         exec_meth ci P ins xt t h (stk, loc, pc, xcp) \\<lbrace>\\<rbrace> h\n          s'';\n         xcp = None \\<Longrightarrow> \\<tau>instr P h stk (ins ! pc);\n         \\<tau>Exec_methr ci P ins xt t h s'' s'\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<tau>Exec_methr ci P ins xt t h s s'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s = s' \\<Longrightarrow> thesis;\n     \\<And>stk loc pc xcp s''.\n        \\<lbrakk>s = (stk, loc, pc, xcp);\n         exec_meth ci P ins xt t h (stk, loc, pc, xcp) \\<lbrace>\\<rbrace> h\n          s'';\n         xcp = None \\<Longrightarrow> \\<tau>instr P h stk (ins ! pc);\n         \\<tau>Exec_methr ci P ins xt t h s'' s'\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(erule converse_rtranclpE)(blast elim: \\<tau>exec_methE)"], ["", "definition \\<tau>exec_move :: \n  \"('addr, 'heap) check_instr \\<Rightarrow> 'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'addr expr1 \\<Rightarrow> 'heap\n  \\<Rightarrow> ('addr val list \\<times> 'addr val list \\<times> pc \\<times> 'addr option)\n  \\<Rightarrow> ('addr val list \\<times> 'addr val list \\<times> pc \\<times> 'addr option) \\<Rightarrow> bool\"\nwhere\n  \"\\<tau>exec_move ci P t e h =\n  (\\<lambda>(stk, loc, pc, xcp) s'. exec_move ci P t e h (stk, loc, pc, xcp) \\<epsilon> h s' \\<and> \\<tau>move2 P h stk e pc xcp)\""], ["", "definition \\<tau>exec_moves :: \n  \"('addr, 'heap) check_instr \\<Rightarrow> 'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'addr expr1 list \\<Rightarrow> 'heap\n  \\<Rightarrow> ('addr val list \\<times> 'addr val list \\<times> pc \\<times> 'addr option)\n  \\<Rightarrow> ('addr val list \\<times> 'addr val list \\<times> pc \\<times> 'addr option) \\<Rightarrow> bool\"\nwhere\n  \"\\<tau>exec_moves ci P t es h =\n   (\\<lambda>(stk, loc, pc, xcp) s'. exec_moves ci P t es h (stk, loc, pc, xcp) \\<epsilon> h s' \\<and> \\<tau>moves2 P h stk es pc xcp)\""], ["", "lemma \\<tau>exec_moveI:\n  \"\\<lbrakk> exec_move ci P t e h (stk, loc, pc, xcp) \\<epsilon> h s'; \\<tau>move2 P h stk e pc xcp \\<rbrakk> \n  \\<Longrightarrow> \\<tau>exec_move ci P t e h (stk, loc, pc, xcp) s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>exec_move ci P t e h (stk, loc, pc, xcp) \\<lbrace>\\<rbrace> h\n              s';\n     \\<tau>move2 P h stk e pc xcp\\<rbrakk>\n    \\<Longrightarrow> \\<tau>exec_move ci P t e h (stk, loc, pc, xcp) s'", "by(simp add: \\<tau>exec_move_def)"], ["", "lemma \\<tau>exec_moveE:\n  assumes \"\\<tau>exec_move ci P t e h (stk, loc, pc, xcp) s'\"\n  obtains \"exec_move ci P t e h (stk, loc, pc, xcp) \\<epsilon> h s'\" \"\\<tau>move2 P h stk e pc xcp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>exec_move ci P t e h (stk, loc, pc, xcp) \\<lbrace>\\<rbrace> h\n               s';\n      \\<tau>move2 P h stk e pc xcp\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<tau>exec_move ci P t e h (stk, loc, pc, xcp) s'\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>exec_move ci P t e h (stk, loc, pc, xcp) \\<lbrace>\\<rbrace> h\n               s';\n      \\<tau>move2 P h stk e pc xcp\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(simp add: \\<tau>exec_move_def)"], ["", "lemma \\<tau>exec_movesI:\n  \"\\<lbrakk> exec_moves ci P t es h (stk, loc, pc, xcp) \\<epsilon> h s'; \\<tau>moves2 P h stk es pc xcp \\<rbrakk> \n  \\<Longrightarrow> \\<tau>exec_moves ci P t es h (stk, loc, pc, xcp) s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>exec_moves ci P t es h (stk, loc, pc, xcp) \\<lbrace>\\<rbrace> h\n              s';\n     \\<tau>moves2 P h stk es pc xcp\\<rbrakk>\n    \\<Longrightarrow> \\<tau>exec_moves ci P t es h (stk, loc, pc, xcp) s'", "by(simp add: \\<tau>exec_moves_def)"], ["", "lemma \\<tau>exec_movesE:\n  assumes \"\\<tau>exec_moves ci P t es h (stk, loc, pc, xcp) s'\"\n  obtains \"exec_moves ci P t es h (stk, loc, pc, xcp) \\<epsilon> h s'\" \"\\<tau>moves2 P h stk es pc xcp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>exec_moves ci P t es h (stk, loc, pc, xcp) \\<lbrace>\\<rbrace>\n               h s';\n      \\<tau>moves2 P h stk es pc xcp\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<tau>exec_moves ci P t es h (stk, loc, pc, xcp) s'\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>exec_moves ci P t es h (stk, loc, pc, xcp) \\<lbrace>\\<rbrace>\n               h s';\n      \\<tau>moves2 P h stk es pc xcp\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(simp add: \\<tau>exec_moves_def)"], ["", "lemma \\<tau>exec_move_conv_\\<tau>exec_meth:\n  \"\\<tau>exec_move ci P t e = \\<tau>exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e =\n    \\<tau>exec_meth ci (compP2 P) (compE2 e) (compxE2 e 0 0) t", "by(auto simp add: \\<tau>exec_move_def exec_move_def \\<tau>move2_iff compP2_def intro!: ext \\<tau>exec_methI elim!: \\<tau>exec_methE)"], ["", "lemma \\<tau>exec_moves_conv_\\<tau>exec_meth:\n  \"\\<tau>exec_moves ci P t es = \\<tau>exec_meth ci (compP2 P) (compEs2 es) (compxEs2 es 0 0) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_moves ci P t es =\n    \\<tau>exec_meth ci (compP2 P) (compEs2 es) (compxEs2 es 0 0) t", "by(auto simp add: \\<tau>exec_moves_def exec_moves_def \\<tau>moves2_iff compP2_def intro!: ext \\<tau>exec_methI elim!: \\<tau>exec_methE)"], ["", "abbreviation \\<tau>Exec_mover\nwhere \"\\<tau>Exec_mover ci P t e h == (\\<tau>exec_move ci P t e h)^**\""], ["", "abbreviation \\<tau>Exec_movet\nwhere \"\\<tau>Exec_movet ci P t e h == (\\<tau>exec_move ci P t e h)^++\""], ["", "abbreviation \\<tau>Exec_mover_a\nwhere \"\\<tau>Exec_mover_a \\<equiv> \\<tau>Exec_mover (Abs_check_instr check_instr')\""], ["", "abbreviation \\<tau>Exec_mover_d\nwhere \"\\<tau>Exec_mover_d \\<equiv> \\<tau>Exec_mover (Abs_check_instr check_instr)\""], ["", "abbreviation \\<tau>Exec_movet_a\nwhere \"\\<tau>Exec_movet_a \\<equiv> \\<tau>Exec_movet (Abs_check_instr check_instr')\""], ["", "abbreviation \\<tau>Exec_movet_d\nwhere \"\\<tau>Exec_movet_d \\<equiv> \\<tau>Exec_movet (Abs_check_instr check_instr)\""], ["", "abbreviation \\<tau>Exec_movesr\nwhere \"\\<tau>Exec_movesr ci P t e h == (\\<tau>exec_moves ci P t e h)^**\""], ["", "abbreviation \\<tau>Exec_movest\nwhere \"\\<tau>Exec_movest ci P t e h == (\\<tau>exec_moves ci P t e h)^++\""], ["", "abbreviation \\<tau>Exec_movesr_a\nwhere \"\\<tau>Exec_movesr_a \\<equiv> \\<tau>Exec_movesr (Abs_check_instr check_instr')\""], ["", "abbreviation \\<tau>Exec_movesr_d\nwhere \"\\<tau>Exec_movesr_d \\<equiv> \\<tau>Exec_movesr (Abs_check_instr check_instr)\""], ["", "abbreviation \\<tau>Exec_movest_a\nwhere \"\\<tau>Exec_movest_a \\<equiv> \\<tau>Exec_movest (Abs_check_instr check_instr')\""], ["", "abbreviation \\<tau>Exec_movest_d\nwhere \"\\<tau>Exec_movest_d \\<equiv> \\<tau>Exec_movest (Abs_check_instr check_instr)\""], ["", "lemma \\<tau>Execr_refl: \"\\<tau>Exec_mover ci P t e h s s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t e h s s", "by(rule rtranclp.rtrancl_refl)"], ["", "lemma \\<tau>Execsr_refl: \"\\<tau>Exec_movesr ci P t e h s s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movesr ci P t e h s s", "by(rule rtranclp.rtrancl_refl)"], ["", "lemma \\<tau>Execr_step: \n  \"\\<lbrakk> \\<tau>Exec_mover ci P t e h s (stk', loc', pc', xcp');\n     exec_move ci P t e h (stk', loc', pc', xcp') \\<epsilon> h s';\n     \\<tau>move2 P h stk' e pc' xcp' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>Exec_mover ci P t e h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau>Exec_mover ci P t e h s (stk', loc', pc', xcp');\n     exec_move ci P t e h (stk', loc', pc', xcp') \\<lbrace>\\<rbrace> h s';\n     \\<tau>move2 P h stk' e pc' xcp'\\<rbrakk>\n    \\<Longrightarrow> \\<tau>Exec_mover ci P t e h s s'", "by(rule rtranclp.rtrancl_into_rtrancl)(auto elim: \\<tau>exec_moveI)"], ["", "lemma \\<tau>Execsr_step: \n  \"\\<lbrakk> \\<tau>Exec_movesr ci P t es h s (stk', loc', pc', xcp');\n     exec_moves ci P t es h (stk', loc', pc', xcp') \\<epsilon> h s';\n     \\<tau>moves2 P h stk' es pc' xcp' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>Exec_movesr ci P t es h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau>Exec_movesr ci P t es h s (stk', loc', pc', xcp');\n     exec_moves ci P t es h (stk', loc', pc', xcp') \\<lbrace>\\<rbrace> h s';\n     \\<tau>moves2 P h stk' es pc' xcp'\\<rbrakk>\n    \\<Longrightarrow> \\<tau>Exec_movesr ci P t es h s s'", "by(rule rtranclp.rtrancl_into_rtrancl)(auto elim: \\<tau>exec_movesI)"], ["", "lemma \\<tau>Exect_step:\n  \"\\<lbrakk> \\<tau>Exec_movet ci P t e h s (stk', loc', pc', xcp');\n     exec_move ci P t e h (stk', loc', pc', xcp') \\<epsilon> h s';\n     \\<tau>move2 P h stk' e pc' xcp' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>Exec_movet ci P t e h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau>Exec_movet ci P t e h s (stk', loc', pc', xcp');\n     exec_move ci P t e h (stk', loc', pc', xcp') \\<lbrace>\\<rbrace> h s';\n     \\<tau>move2 P h stk' e pc' xcp'\\<rbrakk>\n    \\<Longrightarrow> \\<tau>Exec_movet ci P t e h s s'", "by(rule tranclp.trancl_into_trancl)(auto intro: \\<tau>exec_moveI)"], ["", "lemma \\<tau>Execst_step:\n  \"\\<lbrakk> \\<tau>Exec_movest ci P t es h s (stk', loc', pc', xcp');\n     exec_moves ci P t es h (stk', loc', pc', xcp') \\<epsilon> h s';\n     \\<tau>moves2 P h stk' es pc' xcp' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>Exec_movest ci P t es h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau>Exec_movest ci P t es h s (stk', loc', pc', xcp');\n     exec_moves ci P t es h (stk', loc', pc', xcp') \\<lbrace>\\<rbrace> h s';\n     \\<tau>moves2 P h stk' es pc' xcp'\\<rbrakk>\n    \\<Longrightarrow> \\<tau>Exec_movest ci P t es h s s'", "by(rule tranclp.trancl_into_trancl)(auto intro: \\<tau>exec_movesI)"], ["", "lemmas \\<tau>Execr1step = \\<tau>Execr_step[OF \\<tau>Execr_refl]"], ["", "lemmas \\<tau>Execr2step = \\<tau>Execr_step[OF \\<tau>Execr_step, OF \\<tau>Execr_refl]"], ["", "lemmas \\<tau>Execr3step = \\<tau>Execr_step[OF \\<tau>Execr_step, OF \\<tau>Execr_step, OF \\<tau>Execr_refl]"], ["", "lemmas \\<tau>Execsr1step = \\<tau>Execsr_step[OF \\<tau>Execsr_refl]"], ["", "lemmas \\<tau>Execsr2step = \\<tau>Execsr_step[OF \\<tau>Execsr_step, OF \\<tau>Execsr_refl]"], ["", "lemmas \\<tau>Execsr3step = \\<tau>Execsr_step[OF \\<tau>Execsr_step, OF \\<tau>Execsr_step, OF \\<tau>Execsr_refl]"], ["", "lemma \\<tau>Exect1step:\n  \"\\<lbrakk> exec_move ci P t e h s \\<epsilon> h s';\n     \\<tau>move2 P h (fst s) e (fst (snd (snd s))) (snd (snd (snd s))) \\<rbrakk>\n  \\<Longrightarrow> \\<tau>Exec_movet ci P t e h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>exec_move ci P t e h s \\<lbrace>\\<rbrace> h s';\n     \\<tau>move2 P h (fst s) e (fst (snd (snd s)))\n      (snd (snd (snd s)))\\<rbrakk>\n    \\<Longrightarrow> \\<tau>Exec_movet ci P t e h s s'", "by(rule tranclp.r_into_trancl)(cases s, auto intro: \\<tau>exec_moveI)"], ["", "lemmas \\<tau>Exect2step = \\<tau>Exect_step[OF \\<tau>Exect1step]"], ["", "lemmas \\<tau>Exect3step = \\<tau>Exect_step[OF \\<tau>Exect_step, OF \\<tau>Exect1step]"], ["", "lemma \\<tau>Execst1step:\n  \"\\<lbrakk> exec_moves ci P t es h s \\<epsilon> h s';\n     \\<tau>moves2 P h (fst s) es (fst (snd (snd s))) (snd (snd (snd s))) \\<rbrakk>\n  \\<Longrightarrow> \\<tau>Exec_movest ci P t es h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>exec_moves ci P t es h s \\<lbrace>\\<rbrace> h s';\n     \\<tau>moves2 P h (fst s) es (fst (snd (snd s)))\n      (snd (snd (snd s)))\\<rbrakk>\n    \\<Longrightarrow> \\<tau>Exec_movest ci P t es h s s'", "by(rule tranclp.r_into_trancl)(cases s, auto intro: \\<tau>exec_movesI)"], ["", "lemmas \\<tau>Execst2step = \\<tau>Execst_step[OF \\<tau>Execst1step]"], ["", "lemmas \\<tau>Execst3step = \\<tau>Execst_step[OF \\<tau>Execst_step, OF \\<tau>Execst1step]"], ["", "lemma \\<tau>Execr_induct [consumes 1, case_names refl step]:\n  assumes major: \"\\<tau>Exec_mover ci P t e h (stk, loc, pc, xcp) (stk'', loc'', pc'', xcp'')\"\n  and refl: \"Q stk loc pc xcp\"\n  and step: \"\\<And>stk' loc' pc' xcp' stk'' loc'' pc'' xcp''.\n             \\<lbrakk> \\<tau>Exec_mover ci P t e h (stk, loc, pc, xcp) (stk', loc', pc', xcp');\n               \\<tau>exec_move ci P t e h (stk', loc', pc', xcp') (stk'', loc'', pc'', xcp''); Q stk' loc' pc' xcp' \\<rbrakk>\n             \\<Longrightarrow> Q stk'' loc'' pc'' xcp''\"\n  shows \"Q stk'' loc'' pc'' xcp''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q stk'' loc'' pc'' xcp''", "using major refl"], ["proof (prove)\nusing this:\n  \\<tau>Exec_mover ci P t e h (stk, loc, pc, xcp)\n   (stk'', loc'', pc'', xcp'')\n  Q stk loc pc xcp\n\ngoal (1 subgoal):\n 1. Q stk'' loc'' pc'' xcp''", "by(rule rtranclp_induct4)(rule step)"], ["", "lemma \\<tau>Execsr_induct [consumes 1, case_names refl step]:\n  assumes major: \"\\<tau>Exec_movesr ci P t es h (stk, loc, pc, xcp) (stk'', loc'', pc'', xcp'')\"\n  and refl: \"Q stk loc pc xcp\"\n  and step: \"\\<And>stk' loc' pc' xcp' stk'' loc'' pc'' xcp''.\n             \\<lbrakk> \\<tau>Exec_movesr ci P t es h (stk, loc, pc, xcp) (stk', loc', pc', xcp');\n               \\<tau>exec_moves ci P t es h (stk', loc', pc', xcp') (stk'', loc'', pc'', xcp''); Q stk' loc' pc' xcp' \\<rbrakk>\n             \\<Longrightarrow> Q stk'' loc'' pc'' xcp''\"\n  shows \"Q stk'' loc'' pc'' xcp''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q stk'' loc'' pc'' xcp''", "using major refl"], ["proof (prove)\nusing this:\n  \\<tau>Exec_movesr ci P t es h (stk, loc, pc, xcp)\n   (stk'', loc'', pc'', xcp'')\n  Q stk loc pc xcp\n\ngoal (1 subgoal):\n 1. Q stk'' loc'' pc'' xcp''", "by(rule rtranclp_induct4)(rule step)"], ["", "lemma \\<tau>Exect_induct [consumes 1, case_names base step]:\n  assumes major: \"\\<tau>Exec_movet ci P t e h (stk, loc, pc, xcp) (stk'', loc'', pc'', xcp'')\"\n  and base: \"\\<And>stk' loc' pc' xcp'. \\<tau>exec_move ci P t e h (stk, loc, pc, xcp) (stk', loc', pc', xcp') \\<Longrightarrow> Q stk' loc' pc' xcp'\"\n  and step: \"\\<And>stk' loc' pc' xcp' stk'' loc'' pc'' xcp''.\n             \\<lbrakk> \\<tau>Exec_movet ci P t e h (stk, loc, pc, xcp) (stk', loc', pc', xcp');\n               \\<tau>exec_move ci P t e h (stk', loc', pc', xcp') (stk'', loc'', pc'', xcp''); Q stk' loc' pc' xcp' \\<rbrakk>\n             \\<Longrightarrow> Q stk'' loc'' pc'' xcp''\"\n  shows \"Q stk'' loc'' pc'' xcp''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q stk'' loc'' pc'' xcp''", "using major"], ["proof (prove)\nusing this:\n  \\<tau>Exec_movet ci P t e h (stk, loc, pc, xcp)\n   (stk'', loc'', pc'', xcp'')\n\ngoal (1 subgoal):\n 1. Q stk'' loc'' pc'' xcp''", "by(rule tranclp_induct4)(erule base step)+"], ["", "lemma \\<tau>Execst_induct [consumes 1, case_names base step]:\n  assumes major: \"\\<tau>Exec_movest ci P t es h (stk, loc, pc, xcp) (stk'', loc'', pc'', xcp'')\"\n  and base: \"\\<And>stk' loc' pc' xcp'. \\<tau>exec_moves ci P t es h (stk, loc, pc, xcp) (stk', loc', pc', xcp') \\<Longrightarrow> Q stk' loc' pc' xcp'\"\n  and step: \"\\<And>stk' loc' pc' xcp' stk'' loc'' pc'' xcp''.\n             \\<lbrakk> \\<tau>Exec_movest ci P t es h (stk, loc, pc, xcp) (stk', loc', pc', xcp');\n               \\<tau>exec_moves ci P t es h (stk', loc', pc', xcp') (stk'', loc'', pc'', xcp''); Q stk' loc' pc' xcp' \\<rbrakk>\n             \\<Longrightarrow> Q stk'' loc'' pc'' xcp''\"\n  shows \"Q stk'' loc'' pc'' xcp''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q stk'' loc'' pc'' xcp''", "using major"], ["proof (prove)\nusing this:\n  \\<tau>Exec_movest ci P t es h (stk, loc, pc, xcp)\n   (stk'', loc'', pc'', xcp'')\n\ngoal (1 subgoal):\n 1. Q stk'' loc'' pc'' xcp''", "by(rule tranclp_induct4)(erule base step)+"], ["", "lemma \\<tau>Exec_mover_\\<tau>Exec_methr:\n  \"\\<tau>Exec_mover ci P t e = \\<tau>Exec_methr ci (compP2 P) (compE2 e) (compxE2 e 0 0) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t e =\n    \\<tau>Exec_methr ci (compP2 P) (compE2 e) (compxE2 e 0 0) t", "by(simp only: \\<tau>exec_move_conv_\\<tau>exec_meth)"], ["", "lemma \\<tau>Exec_movesr_\\<tau>Exec_methr:\n  \"\\<tau>Exec_movesr ci P t es = \\<tau>Exec_methr ci (compP2 P) (compEs2 es) (compxEs2 es 0 0) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movesr ci P t es =\n    \\<tau>Exec_methr ci (compP2 P) (compEs2 es) (compxEs2 es 0 0) t", "by(simp only: \\<tau>exec_moves_conv_\\<tau>exec_meth)"], ["", "lemma \\<tau>Exec_movet_\\<tau>Exec_metht:\n  \"\\<tau>Exec_movet ci P t e = \\<tau>Exec_metht ci (compP2 P) (compE2 e) (compxE2 e 0 0) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t e =\n    \\<tau>Exec_metht ci (compP2 P) (compE2 e) (compxE2 e 0 0) t", "by(simp only: \\<tau>exec_move_conv_\\<tau>exec_meth)"], ["", "lemma \\<tau>Exec_movest_\\<tau>Exec_metht:\n  \"\\<tau>Exec_movest ci P t es = \\<tau>Exec_metht ci (compP2 P) (compEs2 es) (compxEs2 es 0 0) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movest ci P t es =\n    \\<tau>Exec_metht ci (compP2 P) (compEs2 es) (compxEs2 es 0 0) t", "by(simp only: \\<tau>exec_moves_conv_\\<tau>exec_meth)"], ["", "lemma \\<tau>Exec_mover_trans: \n  \"\\<lbrakk> \\<tau>Exec_mover ci P t e h s s'; \\<tau>Exec_mover ci P t e h s' s'' \\<rbrakk> \\<Longrightarrow> \\<tau>Exec_mover ci P t e h s s''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau>Exec_mover ci P t e h s s';\n     \\<tau>Exec_mover ci P t e h s' s''\\<rbrakk>\n    \\<Longrightarrow> \\<tau>Exec_mover ci P t e h s s''", "by(rule rtranclp_trans)"], ["", "lemma \\<tau>Exec_movesr_trans: \n  \"\\<lbrakk> \\<tau>Exec_movesr ci P t es h s s'; \\<tau>Exec_movesr ci P t es h s' s'' \\<rbrakk> \\<Longrightarrow> \\<tau>Exec_movesr ci P t es h s s''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau>Exec_movesr ci P t es h s s';\n     \\<tau>Exec_movesr ci P t es h s' s''\\<rbrakk>\n    \\<Longrightarrow> \\<tau>Exec_movesr ci P t es h s s''", "by(rule rtranclp_trans)"], ["", "lemma \\<tau>Exec_movet_trans: \n  \"\\<lbrakk> \\<tau>Exec_movet ci P t e h s s'; \\<tau>Exec_movet ci P t e h s' s'' \\<rbrakk> \\<Longrightarrow> \\<tau>Exec_movet ci P t e h s s''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau>Exec_movet ci P t e h s s';\n     \\<tau>Exec_movet ci P t e h s' s''\\<rbrakk>\n    \\<Longrightarrow> \\<tau>Exec_movet ci P t e h s s''", "by(rule tranclp_trans)"], ["", "lemma \\<tau>Exec_movest_trans: \n  \"\\<lbrakk> \\<tau>Exec_movest ci P t es h s s'; \\<tau>Exec_movest ci P t es h s' s'' \\<rbrakk> \\<Longrightarrow> \\<tau>Exec_movest ci P t es h s s''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau>Exec_movest ci P t es h s s';\n     \\<tau>Exec_movest ci P t es h s' s''\\<rbrakk>\n    \\<Longrightarrow> \\<tau>Exec_movest ci P t es h s s''", "by(rule tranclp_trans)"], ["", "lemma \\<tau>exec_move_into_\\<tau>exec_moves:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_moves ci P t (e # es) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e h s s' \\<Longrightarrow>\n    \\<tau>exec_moves ci P t (e # es) h s s'", "by(cases s)(auto elim!: \\<tau>exec_moveE intro!: \\<tau>exec_movesI simp add: exec_move_def exec_moves_def intro: \\<tau>moves2Hd)"], ["", "lemma \\<tau>Exec_mover_\\<tau>Exec_movesr:\n  \"\\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movesr ci P t (e # es) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow>\n    \\<tau>Exec_movesr ci P t (e # es) h s s'", "by(induct rule: rtranclp_induct)(blast intro: rtranclp.rtrancl_into_rtrancl \\<tau>exec_move_into_\\<tau>exec_moves)+"], ["", "lemma \\<tau>Exec_movet_\\<tau>Exec_movest:\n  \"\\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movest ci P t (e # es) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow>\n    \\<tau>Exec_movest ci P t (e # es) h s s'", "by(induct rule: tranclp_induct)(blast intro: tranclp.trancl_into_trancl \\<tau>exec_move_into_\\<tau>exec_moves)+"], ["", "lemma exec_moves_append: \"exec_moves ci P t es h s ta h' s' \\<Longrightarrow> exec_moves ci P t (es @ es') h s ta h' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_moves ci P t es h s ta h' s' \\<Longrightarrow>\n    exec_moves ci P t (es @ es') h s ta h' s'", "by(auto simp add: exec_moves_def)"], ["", "lemma \\<tau>exec_moves_append: \"\\<tau>exec_moves ci P t es h s s' \\<Longrightarrow> \\<tau>exec_moves ci P t (es @ es') h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_moves ci P t es h s s' \\<Longrightarrow>\n    \\<tau>exec_moves ci P t (es @ es') h s s'", "by(cases s)(auto elim!: \\<tau>exec_movesE intro!: \\<tau>exec_movesI exec_moves_append)"], ["", "lemma \\<tau>Exec_movesr_append [intro]:\n  \"\\<tau>Exec_movesr ci P t es h s s' \\<Longrightarrow> \\<tau>Exec_movesr ci P t (es @ es') h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movesr ci P t es h s s' \\<Longrightarrow>\n    \\<tau>Exec_movesr ci P t (es @ es') h s s'", "by(induct rule: rtranclp_induct)(blast intro: rtranclp.rtrancl_into_rtrancl \\<tau>exec_moves_append)+"], ["", "lemma \\<tau>Exec_movest_append [intro]:\n  \"\\<tau>Exec_movest ci P t es h s s' \\<Longrightarrow> \\<tau>Exec_movest ci P t (es @ es') h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movest ci P t es h s s' \\<Longrightarrow>\n    \\<tau>Exec_movest ci P t (es @ es') h s s'", "by(induct rule: tranclp_induct)(blast intro: tranclp.trancl_into_trancl \\<tau>exec_moves_append)+"], ["", "lemma append_exec_moves:\n  assumes len: \"length vs = length es'\"\n  and exec: \"exec_moves ci P t es h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  shows \"exec_moves ci P t (es' @ es) h ((stk @ vs), loc, (length (compEs2 es') + pc), xcp) ta h' ((stk' @ vs), loc', (length (compEs2 es') + pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_moves ci P t (es' @ es) h\n     (stk @ vs, loc, length (compEs2 es') + pc, xcp) ta h'\n     (stk' @ vs, loc', length (compEs2 es') + pc', xcp')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. exec_moves ci P t (es' @ es) h\n     (stk @ vs, loc, length (compEs2 es') + pc, xcp) ta h'\n     (stk' @ vs, loc', length (compEs2 es') + pc', xcp')", "from exec"], ["proof (chain)\npicking this:\n  exec_moves ci P t es h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "have \"exec_meth ci (compP2 P) (compEs2 es) (compxEs2 es 0 0) t h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_moves ci P t es h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compEs2 es) (compxEs2 es 0 0) t h\n     (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "unfolding exec_moves_def"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compEs2 es) (compxEs2 es 0 0) t h\n   (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compEs2 es) (compxEs2 es 0 0) t h\n     (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')", "."], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) (compEs2 es) (compxEs2 es 0 0) t h\n   (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_moves ci P t (es' @ es) h\n     (stk @ vs, loc, length (compEs2 es') + pc, xcp) ta h'\n     (stk' @ vs, loc', length (compEs2 es') + pc', xcp')", "hence \"exec_meth ci (compP2 P) (compEs2 es) (stack_xlift (length vs) (compxEs2 es 0 0)) t h ((stk @ vs), loc, pc, xcp) ta h' ((stk' @ vs), loc', pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compEs2 es) (compxEs2 es 0 0) t h\n   (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compEs2 es)\n     (stack_xlift (length vs) (compxEs2 es 0 0)) t h\n     (stk @ vs, loc, pc, xcp) ta h' (stk' @ vs, loc', pc', xcp')", "by(rule exec_meth_stk_offer)"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) (compEs2 es)\n   (stack_xlift (length vs) (compxEs2 es 0 0)) t h (stk @ vs, loc, pc, xcp)\n   ta h' (stk' @ vs, loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_moves ci P t (es' @ es) h\n     (stk @ vs, loc, length (compEs2 es') + pc, xcp) ta h'\n     (stk' @ vs, loc', length (compEs2 es') + pc', xcp')", "hence \"exec_meth ci (compP2 P) (compEs2 es' @ compEs2 es) (compxEs2 es' 0 0 @ shift (length (compEs2 es')) (stack_xlift (length (vs)) (compxEs2 es 0 0))) t h ((stk @ vs), loc, (length (compEs2 es') + pc), xcp) ta h' ((stk' @ vs), loc', (length (compEs2 es') + pc'), xcp')\""], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compEs2 es)\n   (stack_xlift (length vs) (compxEs2 es 0 0)) t h (stk @ vs, loc, pc, xcp)\n   ta h' (stk' @ vs, loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compEs2 es' @ compEs2 es)\n     (compxEs2 es' 0 0 @\n      shift (length (compEs2 es'))\n       (stack_xlift (length vs) (compxEs2 es 0 0)))\n     t h (stk @ vs, loc, length (compEs2 es') + pc, xcp) ta h'\n     (stk' @ vs, loc', length (compEs2 es') + pc', xcp')", "by(rule append_exec_meth_xt) auto"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) (compEs2 es' @ compEs2 es)\n   (compxEs2 es' 0 0 @\n    shift (length (compEs2 es'))\n     (stack_xlift (length vs) (compxEs2 es 0 0)))\n   t h (stk @ vs, loc, length (compEs2 es') + pc, xcp) ta h'\n   (stk' @ vs, loc', length (compEs2 es') + pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_moves ci P t (es' @ es) h\n     (stk @ vs, loc, length (compEs2 es') + pc, xcp) ta h'\n     (stk' @ vs, loc', length (compEs2 es') + pc', xcp')", "thus ?thesis"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compEs2 es' @ compEs2 es)\n   (compxEs2 es' 0 0 @\n    shift (length (compEs2 es'))\n     (stack_xlift (length vs) (compxEs2 es 0 0)))\n   t h (stk @ vs, loc, length (compEs2 es') + pc, xcp) ta h'\n   (stk' @ vs, loc', length (compEs2 es') + pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_moves ci P t (es' @ es) h\n     (stk @ vs, loc, length (compEs2 es') + pc, xcp) ta h'\n     (stk' @ vs, loc', length (compEs2 es') + pc', xcp')", "by(simp add: exec_moves_def stack_xlift_compxEs2 shift_compxEs2 len)"], ["proof (state)\nthis:\n  exec_moves ci P t (es' @ es) h\n   (stk @ vs, loc, length (compEs2 es') + pc, xcp) ta h'\n   (stk' @ vs, loc', length (compEs2 es') + pc', xcp')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma append_\\<tau>exec_moves:\n  \"\\<lbrakk> length vs = length es';\n    \\<tau>exec_moves ci P t es h (stk, loc, pc, xcp) (stk', loc', pc', xcp') \\<rbrakk>\n  \\<Longrightarrow> \\<tau>exec_moves ci P t (es' @ es) h ((stk @ vs), loc, (length (compEs2 es') + pc), xcp) ((stk' @ vs), loc', (length (compEs2 es') + pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length vs = length es';\n     \\<tau>exec_moves ci P t es h (stk, loc, pc, xcp)\n      (stk', loc', pc', xcp')\\<rbrakk>\n    \\<Longrightarrow> \\<tau>exec_moves ci P t (es' @ es) h\n                       (stk @ vs, loc, length (compEs2 es') + pc, xcp)\n                       (stk' @ vs, loc', length (compEs2 es') + pc', xcp')", "by(auto elim!: \\<tau>exec_movesE intro: \\<tau>exec_movesI append_exec_moves \\<tau>moves2_stk_append append_\\<tau>moves2)"], ["", "lemma append_\\<tau>Exec_movesr:\n  assumes len: \"length vs = length es'\"\n  shows \"\\<tau>Exec_movesr ci P t es h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_movesr ci P t (es' @ es) h ((stk @ vs), loc, (length (compEs2 es') + pc), xcp) ((stk' @ vs), loc', (length (compEs2 es') + pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movesr ci P t es h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>Exec_movesr ci P t (es' @ es) h\n     (stk @ vs, loc, length (compEs2 es') + pc, xcp)\n     (stk' @ vs, loc', length (compEs2 es') + pc', xcp')", "by(induct rule: rtranclp_induct4)(blast intro: rtranclp.rtrancl_into_rtrancl append_\\<tau>exec_moves[OF len])+"], ["", "lemma append_\\<tau>Exec_movest:\n  assumes len: \"length vs = length es'\"\n  shows \"\\<tau>Exec_movest ci P t es h  (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_movest ci P t (es' @ es) h ((stk @ vs), loc, (length (compEs2 es') + pc), xcp)  ((stk' @ vs), loc', (length (compEs2 es') + pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movest ci P t es h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>Exec_movest ci P t (es' @ es) h\n     (stk @ vs, loc, length (compEs2 es') + pc, xcp)\n     (stk' @ vs, loc', length (compEs2 es') + pc', xcp')", "by(induct rule: tranclp_induct4)(blast intro: tranclp.trancl_into_trancl append_\\<tau>exec_moves[OF len])+"], ["", "lemma NewArray_\\<tau>execI:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (newA T\\<lfloor>e\\<rceil>) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e h s s' \\<Longrightarrow>\n    \\<tau>exec_move ci P t (newA T\\<lfloor>e\\<rceil>) h s s'", "by(cases s)(blast elim: \\<tau>exec_moveE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_newArrayI)"], ["", "lemma Cast_\\<tau>execI:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (Cast T e) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e h s s' \\<Longrightarrow>\n    \\<tau>exec_move ci P t (Cast T e) h s s'", "by(cases s)(blast elim: \\<tau>exec_moveE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_CastI)"], ["", "lemma InstanceOf_\\<tau>execI:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (e instanceof T) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e h s s' \\<Longrightarrow>\n    \\<tau>exec_move ci P t (e instanceof T) h s s'", "by(cases s)(blast elim: \\<tau>exec_moveE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_InstanceOfI)"], ["", "lemma BinOp_\\<tau>execI1:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (e \\<guillemotleft>bop\\<guillemotright> e') h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e h s s' \\<Longrightarrow>\n    \\<tau>exec_move ci P t (e \\<guillemotleft>bop\\<guillemotright> e') h s\n     s'", "by(cases s)(blast elim: \\<tau>exec_moveE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_BinOpI1)"], ["", "lemma BinOp_\\<tau>execI2:\n  \"\\<tau>exec_move ci P t e' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>exec_move ci P t (e \\<guillemotleft>bop\\<guillemotright> e') h ((stk @ [v]), loc, (length (compE2 e) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 e) + pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e' h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>exec_move ci P t (e \\<guillemotleft>bop\\<guillemotright> e') h\n     (stk @ [v], loc, length (compE2 e) + pc, xcp)\n     (stk' @ [v], loc', length (compE2 e) + pc', xcp')", "by(blast elim: \\<tau>exec_moveE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_BinOpI2 \\<tau>move2_stk_append)"], ["", "lemma LAss_\\<tau>execI:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (V := e) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e h s s' \\<Longrightarrow>\n    \\<tau>exec_move ci P t (V:=e) h s s'", "by(cases s)(blast elim: \\<tau>exec_moveE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_LAssI)"], ["", "lemma AAcc_\\<tau>execI1:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (e\\<lfloor>i\\<rceil>) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e h s s' \\<Longrightarrow>\n    \\<tau>exec_move ci P t (e\\<lfloor>i\\<rceil>) h s s'", "by(cases s)(blast elim: \\<tau>exec_moveE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_AAccI1)"], ["", "lemma AAcc_\\<tau>execI2:\n  \"\\<tau>exec_move ci P t e' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>exec_move ci P t (e\\<lfloor>e'\\<rceil>) h ((stk @ [v]), loc, (length (compE2 e) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 e) + pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e' h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>exec_move ci P t (e\\<lfloor>e'\\<rceil>) h\n     (stk @ [v], loc, length (compE2 e) + pc, xcp)\n     (stk' @ [v], loc', length (compE2 e) + pc', xcp')", "by(blast elim: \\<tau>exec_moveE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_AAccI2 \\<tau>move2_stk_append)"], ["", "lemma AAss_\\<tau>execI1:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (e\\<lfloor>i\\<rceil> := e') h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e h s s' \\<Longrightarrow>\n    \\<tau>exec_move ci P t (e\\<lfloor>i\\<rceil> := e') h s s'", "by(cases s)(blast elim: \\<tau>exec_moveE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_AAssI1)"], ["", "lemma AAss_\\<tau>execI2:\n  \"\\<tau>exec_move ci P t e' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>exec_move ci P t (e\\<lfloor>e'\\<rceil> := e'') h ((stk @ [v]), loc, (length (compE2 e) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 e) + pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e' h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>exec_move ci P t (e\\<lfloor>e'\\<rceil> := e'') h\n     (stk @ [v], loc, length (compE2 e) + pc, xcp)\n     (stk' @ [v], loc', length (compE2 e) + pc', xcp')", "by(blast elim: \\<tau>exec_moveE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_AAssI2 \\<tau>move2_stk_append)"], ["", "lemma AAss_\\<tau>execI3:\n  \"\\<tau>exec_move ci P t e'' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>exec_move ci P t (e\\<lfloor>e'\\<rceil> := e'') h ((stk @ [v, v']), loc, (length (compE2 e) + length (compE2 e') + pc), xcp) ((stk' @ [v, v']), loc', (length (compE2 e) + length (compE2 e') + pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e'' h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>exec_move ci P t (e\\<lfloor>e'\\<rceil> := e'') h\n     (stk @ [v, v'], loc, length (compE2 e) + length (compE2 e') + pc, xcp)\n     (stk' @ [v, v'], loc', length (compE2 e) + length (compE2 e') + pc',\n      xcp')", "by(blast elim: \\<tau>exec_moveE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_AAssI3 \\<tau>move2_stk_append)"], ["", "lemma ALength_\\<tau>execI:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (e\\<bullet>length) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e h s s' \\<Longrightarrow>\n    \\<tau>exec_move ci P t (e\\<bullet>length) h s s'", "by(cases s)(blast elim: \\<tau>exec_moveE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_ALengthI)"], ["", "lemma FAcc_\\<tau>execI:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (e\\<bullet>F{D}) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e h s s' \\<Longrightarrow>\n    \\<tau>exec_move ci P t (e\\<bullet>F{D}) h s s'", "by(cases s)(blast elim: \\<tau>exec_moveE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_FAccI)"], ["", "lemma FAss_\\<tau>execI1:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (e\\<bullet>F{D} := e') h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e h s s' \\<Longrightarrow>\n    \\<tau>exec_move ci P t (e\\<bullet>F{D} := e') h s s'", "by(cases s)(blast elim: \\<tau>exec_moveE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_FAssI1)"], ["", "lemma FAss_\\<tau>execI2:\n  \"\\<tau>exec_move ci P t e' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>exec_move ci P t (e\\<bullet>F{D} := e') h ((stk @ [v]), loc, (length (compE2 e) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 e) + pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e' h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>exec_move ci P t (e\\<bullet>F{D} := e') h\n     (stk @ [v], loc, length (compE2 e) + pc, xcp)\n     (stk' @ [v], loc', length (compE2 e) + pc', xcp')", "by(blast elim: \\<tau>exec_moveE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_FAssI2 \\<tau>move2_stk_append)"], ["", "lemma CAS_\\<tau>execI1:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e h s s' \\<Longrightarrow>\n    \\<tau>exec_move ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e''))\n     h s s'", "by(cases s)(blast elim: \\<tau>exec_moveE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_CASI1)"], ["", "lemma CAS_\\<tau>execI2:\n  \"\\<tau>exec_move ci P t e' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>exec_move ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h ((stk @ [v]), loc, (length (compE2 e) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 e) + pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e' h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>exec_move ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e''))\n     h (stk @ [v], loc, length (compE2 e) + pc, xcp)\n     (stk' @ [v], loc', length (compE2 e) + pc', xcp')", "by(blast elim: \\<tau>exec_moveE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_CASI2 \\<tau>move2_stk_append)"], ["", "lemma CAS_\\<tau>execI3:\n  \"\\<tau>exec_move ci P t e'' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>exec_move ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h ((stk @ [v, v']), loc, (length (compE2 e) + length (compE2 e') + pc), xcp) ((stk' @ [v, v']), loc', (length (compE2 e) + length (compE2 e') + pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e'' h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>exec_move ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e''))\n     h (stk @ [v, v'], loc, length (compE2 e) + length (compE2 e') + pc,\n        xcp)\n     (stk' @ [v, v'], loc', length (compE2 e) + length (compE2 e') + pc',\n      xcp')", "by(blast elim: \\<tau>exec_moveE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_CASI3 \\<tau>move2_stk_append)"], ["", "lemma Call_\\<tau>execI1:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (e\\<bullet>M(es)) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e h s s' \\<Longrightarrow>\n    \\<tau>exec_move ci P t (e\\<bullet>M(es)) h s s'", "by(cases s)(blast elim: \\<tau>exec_moveE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_CallI1)"], ["", "lemma Call_\\<tau>execI2:\n  \"\\<tau>exec_moves ci P t es h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>exec_move ci P t (e\\<bullet>M(es)) h ((stk @ [v]), loc, (length (compE2 e) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 e) + pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_moves ci P t es h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>exec_move ci P t (e\\<bullet>M(es)) h\n     (stk @ [v], loc, length (compE2 e) + pc, xcp)\n     (stk' @ [v], loc', length (compE2 e) + pc', xcp')", "by(blast elim: \\<tau>exec_movesE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_CallI2 \\<tau>moves2_stk_append)"], ["", "lemma Block_\\<tau>execI_Some:\n  \"\\<tau>exec_move ci P t e h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>exec_move ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h (stk, loc, Suc (Suc pc), xcp) (stk', loc', Suc (Suc pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>exec_move ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h\n     (stk, loc, Suc (Suc pc), xcp) (stk', loc', Suc (Suc pc'), xcp')", "by(blast elim: \\<tau>exec_moveE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_BlockSomeI)"], ["", "lemma Block_\\<tau>execI_None:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t {V:T=None; e} h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e h s s' \\<Longrightarrow>\n    \\<tau>exec_move ci P t {V:T=None; e} h s s'", "by(cases s)(blast elim: \\<tau>exec_moveE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_BlockNoneI)"], ["", "lemma Sync_\\<tau>execI:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (sync\\<^bsub>V\\<^esub> (e) e') h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e h s s' \\<Longrightarrow>\n    \\<tau>exec_move ci P t (sync\\<^bsub>V\\<^esub> (e) e') h s s'", "by(cases s)(blast elim: \\<tau>exec_moveE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_SyncI1)"], ["", "lemma Insync_\\<tau>execI:\n  \"\\<tau>exec_move ci P t e' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>exec_move ci P t (sync\\<^bsub>V\\<^esub> (e) e') h (stk, loc, Suc (Suc (Suc (length (compE2 e) + pc))), xcp) (stk', loc', Suc (Suc (Suc (length (compE2 e) + pc'))), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e' h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>exec_move ci P t (sync\\<^bsub>V\\<^esub> (e) e') h\n     (stk, loc, Suc (Suc (Suc (length (compE2 e) + pc))), xcp)\n     (stk', loc', Suc (Suc (Suc (length (compE2 e) + pc'))), xcp')", "by(blast elim: \\<tau>exec_moveE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_SyncI2)"], ["", "lemma Seq_\\<tau>execI1:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (e;; e') h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e h s s' \\<Longrightarrow>\n    \\<tau>exec_move ci P t (e;; e') h s s'", "by(cases s)(blast elim: \\<tau>exec_moveE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_SeqI1)"], ["", "lemma Seq_\\<tau>execI2:\n  \"\\<tau>exec_move ci P t e' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>exec_move ci P t (e;; e') h (stk, loc, Suc (length (compE2 e) + pc), xcp) (stk', loc', Suc (length (compE2 e) + pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e' h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>exec_move ci P t (e;; e') h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp)\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp')", "by(blast elim: \\<tau>exec_moveE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_SeqI2)"], ["", "lemma Cond_\\<tau>execI1:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (if (e) e' else e'') h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e h s s' \\<Longrightarrow>\n    \\<tau>exec_move ci P t (if (e) e' else e'') h s s'", "by(cases s)(blast elim: \\<tau>exec_moveE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_CondI1)"], ["", "lemma Cond_\\<tau>execI2:\n  \"\\<tau>exec_move ci P t e' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>exec_move ci P t (if (e) e' else e'') h (stk, loc, Suc (length (compE2 e) + pc), xcp) (stk', loc', Suc (length (compE2 e) + pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e' h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>exec_move ci P t (if (e) e' else e'') h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp)\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp')", "by(blast elim: \\<tau>exec_moveE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_CondI2)"], ["", "lemma Cond_\\<tau>execI3:\n  \"\\<tau>exec_move ci P t e'' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>exec_move ci P t (if (e) e' else e'') h (stk, loc, Suc (Suc (length (compE2 e) + length (compE2 e') + pc)), xcp) (stk', loc', Suc (Suc (length (compE2 e) + length (compE2 e') + pc')), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e'' h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>exec_move ci P t (if (e) e' else e'') h\n     (stk, loc, Suc (Suc (length (compE2 e) + length (compE2 e') + pc)),\n      xcp)\n     (stk', loc', Suc (Suc (length (compE2 e) + length (compE2 e') + pc')),\n      xcp')", "by(blast elim: \\<tau>exec_moveE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_CondI3)"], ["", "lemma While_\\<tau>execI1:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (while (e) e') h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e h s s' \\<Longrightarrow>\n    \\<tau>exec_move ci P t (while (e) e') h s s'", "by(cases s)(blast elim: \\<tau>exec_moveE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_WhileI1)"], ["", "lemma While_\\<tau>execI2:\n  \"\\<tau>exec_move ci P t e' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>exec_move ci P t (while (e) e') h (stk, loc, Suc (length (compE2 e) + pc), xcp) (stk', loc', Suc (length (compE2 e) + pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e' h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>exec_move ci P t (while (e) e') h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp)\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp')", "by(blast elim: \\<tau>exec_moveE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_WhileI2)"], ["", "lemma Throw_\\<tau>execI:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (throw e) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e h s s' \\<Longrightarrow>\n    \\<tau>exec_move ci P t (throw e) h s s'", "by(cases s)(blast elim: \\<tau>exec_moveE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_ThrowI)"], ["", "lemma Try_\\<tau>execI1:\n  \"\\<tau>exec_move ci P t e h s s' \\<Longrightarrow> \\<tau>exec_move ci P t (try e catch(C V) e') h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e h s s' \\<Longrightarrow>\n    \\<tau>exec_move ci P t (try e catch(C V) e') h s s'", "by(cases s)(blast elim: \\<tau>exec_moveE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_TryI1)"], ["", "lemma Try_\\<tau>execI2:\n  \"\\<tau>exec_move ci P t e' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>exec_move ci P t (try e catch(C V) e') h (stk, loc, Suc (Suc (length (compE2 e) + pc)), xcp) (stk', loc', Suc (Suc (length (compE2 e) + pc')), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_move ci P t e' h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>exec_move ci P t (try e catch(C V) e') h\n     (stk, loc, Suc (Suc (length (compE2 e) + pc)), xcp)\n     (stk', loc', Suc (Suc (length (compE2 e) + pc')), xcp')", "by(blast elim: \\<tau>exec_moveE intro: \\<tau>exec_moveI \\<tau>move2_\\<tau>moves2.intros exec_move_TryI2)"], ["", "lemma NewArray_\\<tau>ExecrI:\n  \"\\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (newA T\\<lfloor>e\\<rceil>) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t (newA T\\<lfloor>e\\<rceil>) h s s'", "by(induct rule: rtranclp_induct)(blast intro: rtranclp.rtrancl_into_rtrancl NewArray_\\<tau>execI)+"], ["", "lemma Cast_\\<tau>ExecrI:\n  \"\\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (Cast T e) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t (Cast T e) h s s'", "by(induct rule: rtranclp_induct)(blast intro: rtranclp.rtrancl_into_rtrancl Cast_\\<tau>execI)+"], ["", "lemma InstanceOf_\\<tau>ExecrI:\n  \"\\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (e instanceof T) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t (e instanceof T) h s s'", "by(induct rule: rtranclp_induct)(blast intro: rtranclp.rtrancl_into_rtrancl InstanceOf_\\<tau>execI)+"], ["", "lemma BinOp_\\<tau>ExecrI1:\n  \"\\<tau>Exec_mover ci P t e1 h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (e1 \\<guillemotleft>bop\\<guillemotright> e2) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t e1 h s s' \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t (e1 \\<guillemotleft>bop\\<guillemotright> e2) h s\n     s'", "by(induct rule: rtranclp_induct)(blast intro: rtranclp.rtrancl_into_rtrancl BinOp_\\<tau>execI1)+"], ["", "lemma BinOp_\\<tau>ExecrI2:\n  \"\\<tau>Exec_mover ci P t e2 h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_mover ci P t (e \\<guillemotleft>bop\\<guillemotright> e2)  h ((stk @ [v]), loc, (length (compE2 e) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 e) + pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t e2 h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t (e \\<guillemotleft>bop\\<guillemotright> e2) h\n     (stk @ [v], loc, length (compE2 e) + pc, xcp)\n     (stk' @ [v], loc', length (compE2 e) + pc', xcp')", "by(induct rule: \\<tau>Execr_induct)(blast intro: rtranclp.rtrancl_into_rtrancl BinOp_\\<tau>execI2)+"], ["", "lemma LAss_\\<tau>ExecrI:\n  \"\\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (V := e) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t (V:=e) h s s'", "by(induct rule: rtranclp_induct)(blast intro: rtranclp.rtrancl_into_rtrancl LAss_\\<tau>execI)+"], ["", "lemma AAcc_\\<tau>ExecrI1:\n  \"\\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (e\\<lfloor>i\\<rceil>) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t (e\\<lfloor>i\\<rceil>) h s s'", "by(induct rule: rtranclp_induct)(blast intro: rtranclp.rtrancl_into_rtrancl AAcc_\\<tau>execI1)+"], ["", "lemma AAcc_\\<tau>ExecrI2:\n  \"\\<tau>Exec_mover ci P t i h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_mover ci P t (a\\<lfloor>i\\<rceil>) h ((stk @ [v]), loc, (length (compE2 a) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 a) + pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t i h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t (a\\<lfloor>i\\<rceil>) h\n     (stk @ [v], loc, length (compE2 a) + pc, xcp)\n     (stk' @ [v], loc', length (compE2 a) + pc', xcp')", "by(induct rule: \\<tau>Execr_induct)(blast intro: rtranclp.rtrancl_into_rtrancl AAcc_\\<tau>execI2)+"], ["", "lemma AAss_\\<tau>ExecrI1:\n  \"\\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (e\\<lfloor>i\\<rceil> := e') h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t (e\\<lfloor>i\\<rceil> := e') h s s'", "by(induct rule: rtranclp_induct)(blast intro: rtranclp.rtrancl_into_rtrancl AAss_\\<tau>execI1)+"], ["", "lemma AAss_\\<tau>ExecrI2:\n  \"\\<tau>Exec_mover ci P t i h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_mover ci P t (a\\<lfloor>i\\<rceil> := e) h ((stk @ [v]), loc, (length (compE2 a) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 a) + pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t i h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t (a\\<lfloor>i\\<rceil> := e) h\n     (stk @ [v], loc, length (compE2 a) + pc, xcp)\n     (stk' @ [v], loc', length (compE2 a) + pc', xcp')", "by(induct rule: \\<tau>Execr_induct)(blast intro: rtranclp.rtrancl_into_rtrancl AAss_\\<tau>execI2)+"], ["", "lemma AAss_\\<tau>ExecrI3:\n  \"\\<tau>Exec_mover ci P t e h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_mover ci P t (a\\<lfloor>i\\<rceil> := e) h ((stk @ [v, v']), loc, (length (compE2 a) + length (compE2 i) + pc), xcp) ((stk' @ [v, v']), loc', (length (compE2 a) + length (compE2 i) + pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t e h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t (a\\<lfloor>i\\<rceil> := e) h\n     (stk @ [v, v'], loc, length (compE2 a) + length (compE2 i) + pc, xcp)\n     (stk' @ [v, v'], loc', length (compE2 a) + length (compE2 i) + pc',\n      xcp')", "by(induct rule: \\<tau>Execr_induct)(blast intro: rtranclp.rtrancl_into_rtrancl AAss_\\<tau>execI3)+"], ["", "lemma ALength_\\<tau>ExecrI:\n  \"\\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (e\\<bullet>length) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t (e\\<bullet>length) h s s'", "by(induct rule: rtranclp_induct)(blast intro: rtranclp.rtrancl_into_rtrancl ALength_\\<tau>execI)+"], ["", "lemma FAcc_\\<tau>ExecrI:\n  \"\\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (e\\<bullet>F{D}) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t (e\\<bullet>F{D}) h s s'", "by(induct rule: rtranclp_induct)(blast intro: rtranclp.rtrancl_into_rtrancl FAcc_\\<tau>execI)+"], ["", "lemma FAss_\\<tau>ExecrI1:\n  \"\\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (e\\<bullet>F{D} := e') h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t (e\\<bullet>F{D} := e') h s s'", "by(induct rule: rtranclp_induct)(blast intro: rtranclp.rtrancl_into_rtrancl FAss_\\<tau>execI1)+"], ["", "lemma FAss_\\<tau>ExecrI2:\n  \"\\<tau>Exec_mover ci P t e' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_mover ci P t (e\\<bullet>F{D} := e') h ((stk @ [v]), loc, (length (compE2 e) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 e) + pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t e' h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t (e\\<bullet>F{D} := e') h\n     (stk @ [v], loc, length (compE2 e) + pc, xcp)\n     (stk' @ [v], loc', length (compE2 e) + pc', xcp')", "by(induct rule: \\<tau>Execr_induct)(blast intro: rtranclp.rtrancl_into_rtrancl FAss_\\<tau>execI2)+"], ["", "lemma CAS_\\<tau>ExecrI1:\n  \"\\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e''))\n     h s s'", "by(induct rule: rtranclp_induct)(blast intro: rtranclp.rtrancl_into_rtrancl CAS_\\<tau>execI1)+"], ["", "lemma CAS_\\<tau>ExecrI2:\n  \"\\<tau>Exec_mover ci P t e' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_mover ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h ((stk @ [v]), loc, (length (compE2 e) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 e) + pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t e' h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e''))\n     h (stk @ [v], loc, length (compE2 e) + pc, xcp)\n     (stk' @ [v], loc', length (compE2 e) + pc', xcp')", "by(induct rule: \\<tau>Execr_induct)(blast intro: rtranclp.rtrancl_into_rtrancl CAS_\\<tau>execI2)+"], ["", "lemma CAS_\\<tau>ExecrI3:\n  \"\\<tau>Exec_mover ci P t e'' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_mover ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h ((stk @ [v, v']), loc, (length (compE2 e) + length (compE2 e') + pc), xcp) ((stk' @ [v, v']), loc', (length (compE2 e) + length (compE2 e') + pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t e'' h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e''))\n     h (stk @ [v, v'], loc, length (compE2 e) + length (compE2 e') + pc,\n        xcp)\n     (stk' @ [v, v'], loc', length (compE2 e) + length (compE2 e') + pc',\n      xcp')", "by(induct rule: \\<tau>Execr_induct)(blast intro: rtranclp.rtrancl_into_rtrancl CAS_\\<tau>execI3)+"], ["", "lemma Call_\\<tau>ExecrI1:\n  \"\\<tau>Exec_mover ci P t obj h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (obj\\<bullet>M'(es)) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t obj h s s' \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t (obj\\<bullet>M'(es)) h s s'", "by(induct rule: rtranclp_induct)(blast intro: rtranclp.rtrancl_into_rtrancl Call_\\<tau>execI1)+"], ["", "lemma Call_\\<tau>ExecrI2:\n  \"\\<tau>Exec_movesr ci P t es h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_mover ci P t (obj\\<bullet>M'(es)) h ((stk @ [v]), loc, (length (compE2 obj) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 obj) + pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movesr ci P t es h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t (obj\\<bullet>M'(es)) h\n     (stk @ [v], loc, length (compE2 obj) + pc, xcp)\n     (stk' @ [v], loc', length (compE2 obj) + pc', xcp')", "by(induct rule: \\<tau>Execsr_induct)(blast intro: rtranclp.rtrancl_into_rtrancl Call_\\<tau>execI2)+"], ["", "lemma Block_\\<tau>ExecrI_Some:\n  \"\\<tau>Exec_mover ci P t e h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_mover ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h (stk, loc, (Suc (Suc pc)), xcp) (stk', loc', (Suc (Suc pc')), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t e h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h\n     (stk, loc, Suc (Suc pc), xcp) (stk', loc', Suc (Suc pc'), xcp')", "by(induct rule: \\<tau>Execr_induct)(blast intro: rtranclp.rtrancl_into_rtrancl Block_\\<tau>execI_Some)+"], ["", "lemma Block_\\<tau>ExecrI_None:\n  \"\\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t {V:T=None; e} h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t {V:T=None; e} h s s'", "by(induct rule: rtranclp_induct)(blast intro: rtranclp.rtrancl_into_rtrancl Block_\\<tau>execI_None)+"], ["", "lemma Sync_\\<tau>ExecrI:\n  \"\\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (sync\\<^bsub>V\\<^esub> (e) e') h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t (sync\\<^bsub>V\\<^esub> (e) e') h s s'", "by(induct rule: rtranclp_induct)(blast intro: rtranclp.rtrancl_into_rtrancl Sync_\\<tau>execI)+"], ["", "lemma Insync_\\<tau>ExecrI:\n  \"\\<tau>Exec_mover ci P t e' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_mover ci P t (sync\\<^bsub>V\\<^esub> (e) e')  h (stk, loc, (Suc (Suc (Suc (length (compE2 e) + pc)))), xcp) (stk', loc', (Suc (Suc (Suc (length (compE2 e) + pc')))), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t e' h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t (sync\\<^bsub>V\\<^esub> (e) e') h\n     (stk, loc, Suc (Suc (Suc (length (compE2 e) + pc))), xcp)\n     (stk', loc', Suc (Suc (Suc (length (compE2 e) + pc'))), xcp')", "by(induct rule: \\<tau>Execr_induct)(blast intro: rtranclp.rtrancl_into_rtrancl Insync_\\<tau>execI)+"], ["", "lemma Seq_\\<tau>ExecrI1:\n  \"\\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (e;;e') h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t (e;; e') h s s'", "by(induct rule: rtranclp_induct)(blast intro: rtranclp.rtrancl_into_rtrancl Seq_\\<tau>execI1)+"], ["", "lemma Seq_\\<tau>ExecrI2:\n  \"\\<tau>Exec_mover ci P t e h (stk, loc, pc, xcp) (stk', loc', pc' ,xcp') \\<Longrightarrow>\n   \\<tau>Exec_mover ci P t (e';;e) h (stk, loc, (Suc (length (compE2 e') + pc)), xcp) (stk', loc', (Suc (length (compE2 e') + pc')), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t e h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t (e';; e) h\n     (stk, loc, Suc (length (compE2 e') + pc), xcp)\n     (stk', loc', Suc (length (compE2 e') + pc'), xcp')", "by(induct rule: \\<tau>Execr_induct)(blast intro: rtranclp.rtrancl_into_rtrancl Seq_\\<tau>execI2)+"], ["", "lemma Cond_\\<tau>ExecrI1:\n  \"\\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (if (e) e1 else e2) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t (if (e) e1 else e2) h s s'", "by(induct rule: rtranclp_induct)(blast intro: rtranclp.rtrancl_into_rtrancl Cond_\\<tau>execI1)+"], ["", "lemma Cond_\\<tau>ExecrI2:\n  \"\\<tau>Exec_mover ci P t e1  h (stk, loc, pc, xcp) (stk', loc', pc', xcp') \\<Longrightarrow>\n   \\<tau>Exec_mover ci P t (if (e) e1 else e2)  h (stk, loc, (Suc (length (compE2 e) + pc)), xcp) (stk', loc', (Suc (length (compE2 e) + pc')), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t e1 h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp)\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp')", "by(induct rule: \\<tau>Execr_induct)(blast intro: rtranclp.rtrancl_into_rtrancl Cond_\\<tau>execI2)+"], ["", "lemma Cond_\\<tau>ExecrI3:\n  \"\\<tau>Exec_mover ci P t e2  h (stk, loc ,pc, xcp) (stk', loc', pc', xcp') \\<Longrightarrow>\n   \\<tau>Exec_mover ci P t (if (e) e1 else e2)  h (stk, loc, (Suc (Suc (length (compE2 e) + length (compE2 e1) + pc))), xcp)  (stk', loc', (Suc (Suc (length (compE2 e) + length (compE2 e1) + pc'))), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t e2 h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (Suc (length (compE2 e) + length (compE2 e1) + pc)),\n      xcp)\n     (stk', loc', Suc (Suc (length (compE2 e) + length (compE2 e1) + pc')),\n      xcp')", "by(induct rule: \\<tau>Execr_induct)(blast intro: rtranclp.rtrancl_into_rtrancl Cond_\\<tau>execI3)+"], ["", "lemma While_\\<tau>ExecrI1:\n  \"\\<tau>Exec_mover ci P t c h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (while (c) e) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t c h s s' \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t (while (c) e) h s s'", "by(induct rule: rtranclp_induct)(blast intro: rtranclp.rtrancl_into_rtrancl While_\\<tau>execI1)+"], ["", "lemma While_\\<tau>ExecrI2:\n  \"\\<tau>Exec_mover ci P t E h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_mover ci P t (while (c) E)  h (stk, loc ,(Suc (length (compE2 c) + pc)), xcp) (stk', loc', (Suc (length (compE2 c) + pc')), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t E h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t (while (c) E) h\n     (stk, loc, Suc (length (compE2 c) + pc), xcp)\n     (stk', loc', Suc (length (compE2 c) + pc'), xcp')", "by(induct rule: \\<tau>Execr_induct)(blast intro: rtranclp.rtrancl_into_rtrancl While_\\<tau>execI2)+"], ["", "lemma Throw_\\<tau>ExecrI:\n  \"\\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (throw e) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t e h s s' \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t (throw e) h s s'", "by(induct rule: rtranclp_induct)(blast intro: rtranclp.rtrancl_into_rtrancl Throw_\\<tau>execI)+"], ["", "lemma Try_\\<tau>ExecrI1:\n  \"\\<tau>Exec_mover ci P t E h s s' \\<Longrightarrow> \\<tau>Exec_mover ci P t (try E catch(C' V) e) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t E h s s' \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t (try E catch(C' V) e) h s s'", "by(induct rule: rtranclp_induct)(blast intro: rtranclp.rtrancl_into_rtrancl Try_\\<tau>execI1)+"], ["", "lemma Try_\\<tau>ExecrI2:\n  \"\\<tau>Exec_mover ci P t e h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_mover ci P t (try E catch(C' V) e)  h (stk, loc, (Suc (Suc (length (compE2 E) + pc))), xcp)  (stk', loc', (Suc (Suc (length (compE2 E) + pc'))), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t e h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>Exec_mover ci P t (try E catch(C' V) e) h\n     (stk, loc, Suc (Suc (length (compE2 E) + pc)), xcp)\n     (stk', loc', Suc (Suc (length (compE2 E) + pc')), xcp')", "by(induct rule: \\<tau>Execr_induct)(blast intro: rtranclp.rtrancl_into_rtrancl Try_\\<tau>execI2)+"], ["", "lemma NewArray_\\<tau>ExectI:\n  \"\\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (newA T\\<lfloor>e\\<rceil>) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t (newA T\\<lfloor>e\\<rceil>) h s s'", "by(induct rule: tranclp_induct)(blast intro: tranclp.trancl_into_trancl NewArray_\\<tau>execI)+"], ["", "lemma Cast_\\<tau>ExectI:\n  \"\\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (Cast T e) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t (Cast T e) h s s'", "by(induct rule: tranclp_induct)(blast intro: tranclp.trancl_into_trancl Cast_\\<tau>execI)+"], ["", "lemma InstanceOf_\\<tau>ExectI:\n  \"\\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (e instanceof T) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t (e instanceof T) h s s'", "by(induct rule: tranclp_induct)(blast intro: tranclp.trancl_into_trancl InstanceOf_\\<tau>execI)+"], ["", "lemma BinOp_\\<tau>ExectI1:\n  \"\\<tau>Exec_movet ci P t e1 h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (e1 \\<guillemotleft>bop\\<guillemotright> e2) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t e1 h s s' \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t (e1 \\<guillemotleft>bop\\<guillemotright> e2) h s\n     s'", "by(induct rule: tranclp_induct)(blast intro: tranclp.trancl_into_trancl BinOp_\\<tau>execI1)+"], ["", "lemma BinOp_\\<tau>ExectI2:\n  \"\\<tau>Exec_movet ci P t e2 h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_movet ci P t (e \\<guillemotleft>bop\\<guillemotright> e2)  h ((stk @ [v]), loc, (length (compE2 e) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 e) + pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t e2 h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t (e \\<guillemotleft>bop\\<guillemotright> e2) h\n     (stk @ [v], loc, length (compE2 e) + pc, xcp)\n     (stk' @ [v], loc', length (compE2 e) + pc', xcp')", "by(induct rule: \\<tau>Exect_induct)(blast intro: tranclp.trancl_into_trancl BinOp_\\<tau>execI2)+"], ["", "lemma LAss_\\<tau>ExectI:\n  \"\\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (V := e) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t (V:=e) h s s'", "by(induct rule: tranclp_induct)(blast intro: tranclp.trancl_into_trancl LAss_\\<tau>execI)+"], ["", "lemma AAcc_\\<tau>ExectI1:\n  \"\\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (e\\<lfloor>i\\<rceil>) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t (e\\<lfloor>i\\<rceil>) h s s'", "by(induct rule: tranclp_induct)(blast intro: tranclp.trancl_into_trancl AAcc_\\<tau>execI1)+"], ["", "lemma AAcc_\\<tau>ExectI2:\n  \"\\<tau>Exec_movet ci P t i h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_movet ci P t (a\\<lfloor>i\\<rceil>) h ((stk @ [v]), loc, (length (compE2 a) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 a) + pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t i h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t (a\\<lfloor>i\\<rceil>) h\n     (stk @ [v], loc, length (compE2 a) + pc, xcp)\n     (stk' @ [v], loc', length (compE2 a) + pc', xcp')", "by(induct rule: \\<tau>Exect_induct)(blast intro: tranclp.trancl_into_trancl AAcc_\\<tau>execI2)+"], ["", "lemma AAss_\\<tau>ExectI1:\n  \"\\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (e\\<lfloor>i\\<rceil> := e') h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t (e\\<lfloor>i\\<rceil> := e') h s s'", "by(induct rule: tranclp_induct)(blast intro: tranclp.trancl_into_trancl AAss_\\<tau>execI1)+"], ["", "lemma AAss_\\<tau>ExectI2:\n  \"\\<tau>Exec_movet ci P t i h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_movet ci P t (a\\<lfloor>i\\<rceil> := e) h ((stk @ [v]), loc, (length (compE2 a) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 a) + pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t i h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t (a\\<lfloor>i\\<rceil> := e) h\n     (stk @ [v], loc, length (compE2 a) + pc, xcp)\n     (stk' @ [v], loc', length (compE2 a) + pc', xcp')", "by(induct rule: \\<tau>Exect_induct)(blast intro: tranclp.trancl_into_trancl AAss_\\<tau>execI2)+"], ["", "lemma AAss_\\<tau>ExectI3:\n  \"\\<tau>Exec_movet ci P t e h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_movet ci P t (a\\<lfloor>i\\<rceil> := e) h ((stk @ [v, v']), loc, (length (compE2 a) + length (compE2 i) + pc), xcp) ((stk' @ [v, v']), loc', (length (compE2 a) + length (compE2 i) + pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t e h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t (a\\<lfloor>i\\<rceil> := e) h\n     (stk @ [v, v'], loc, length (compE2 a) + length (compE2 i) + pc, xcp)\n     (stk' @ [v, v'], loc', length (compE2 a) + length (compE2 i) + pc',\n      xcp')", "by(induct rule: \\<tau>Exect_induct)(blast intro: tranclp.trancl_into_trancl AAss_\\<tau>execI3)+"], ["", "lemma ALength_\\<tau>ExectI:\n  \"\\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (e\\<bullet>length) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t (e\\<bullet>length) h s s'", "by(induct rule: tranclp_induct)(blast intro: tranclp.trancl_into_trancl ALength_\\<tau>execI)+"], ["", "lemma FAcc_\\<tau>ExectI:\n  \"\\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (e\\<bullet>F{D}) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t (e\\<bullet>F{D}) h s s'", "by(induct rule: tranclp_induct)(blast intro: tranclp.trancl_into_trancl FAcc_\\<tau>execI)+"], ["", "lemma FAss_\\<tau>ExectI1:\n  \"\\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (e\\<bullet>F{D} := e') h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t (e\\<bullet>F{D} := e') h s s'", "by(induct rule: tranclp_induct)(blast intro: tranclp.trancl_into_trancl FAss_\\<tau>execI1)+"], ["", "lemma FAss_\\<tau>ExectI2:\n  \"\\<tau>Exec_movet ci P t e' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_movet ci P t (e\\<bullet>F{D} := e') h ((stk @ [v]), loc, (length (compE2 e) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 e) + pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t e' h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t (e\\<bullet>F{D} := e') h\n     (stk @ [v], loc, length (compE2 e) + pc, xcp)\n     (stk' @ [v], loc', length (compE2 e) + pc', xcp')", "by(induct rule: \\<tau>Exect_induct)(blast intro: tranclp.trancl_into_trancl FAss_\\<tau>execI2)+"], ["", "lemma CAS_\\<tau>ExectI1:\n  \"\\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e''))\n     h s s'", "by(induct rule: tranclp_induct)(blast intro: tranclp.trancl_into_trancl CAS_\\<tau>execI1)+"], ["", "lemma CAS_\\<tau>ExectI2:\n  \"\\<tau>Exec_movet ci P t e' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_movet ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h ((stk @ [v]), loc, (length (compE2 e) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 e) + pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t e' h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e''))\n     h (stk @ [v], loc, length (compE2 e) + pc, xcp)\n     (stk' @ [v], loc', length (compE2 e) + pc', xcp')", "by(induct rule: \\<tau>Exect_induct)(blast intro: tranclp.trancl_into_trancl CAS_\\<tau>execI2)+"], ["", "lemma CAS_\\<tau>ExectI3:\n  \"\\<tau>Exec_movet ci P t e'' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_movet ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) h ((stk @ [v, v']), loc, (length (compE2 e) + length (compE2 e') + pc), xcp) ((stk' @ [v, v']), loc', (length (compE2 e) + length (compE2 e') + pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t e'' h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e''))\n     h (stk @ [v, v'], loc, length (compE2 e) + length (compE2 e') + pc,\n        xcp)\n     (stk' @ [v, v'], loc', length (compE2 e) + length (compE2 e') + pc',\n      xcp')", "by(induct rule: \\<tau>Exect_induct)(blast intro: tranclp.trancl_into_trancl CAS_\\<tau>execI3)+"], ["", "lemma Call_\\<tau>ExectI1:\n  \"\\<tau>Exec_movet ci P t obj h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (obj\\<bullet>M'(es)) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t obj h s s' \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t (obj\\<bullet>M'(es)) h s s'", "by(induct rule: tranclp_induct)(blast intro: tranclp.trancl_into_trancl Call_\\<tau>execI1)+"], ["", "lemma Call_\\<tau>ExectI2:\n  \"\\<tau>Exec_movest ci P t es h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_movet ci P t (obj\\<bullet>M'(es)) h ((stk @ [v]), loc, (length (compE2 obj) + pc), xcp) ((stk' @ [v]), loc', (length (compE2 obj) + pc'), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movest ci P t es h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t (obj\\<bullet>M'(es)) h\n     (stk @ [v], loc, length (compE2 obj) + pc, xcp)\n     (stk' @ [v], loc', length (compE2 obj) + pc', xcp')", "by(induct rule: \\<tau>Execst_induct)(blast intro: tranclp.trancl_into_trancl Call_\\<tau>execI2)+"], ["", "lemma Block_\\<tau>ExectI_Some:\n  \"\\<tau>Exec_movet ci P t e h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_movet ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h (stk, loc, (Suc (Suc pc)), xcp) (stk', loc', (Suc (Suc pc')), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t e h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t {V:T=\\<lfloor>v\\<rfloor>; e} h\n     (stk, loc, Suc (Suc pc), xcp) (stk', loc', Suc (Suc pc'), xcp')", "by(induct rule: \\<tau>Exect_induct)(blast intro: tranclp.trancl_into_trancl Block_\\<tau>execI_Some)+"], ["", "lemma Block_\\<tau>ExectI_None:\n  \"\\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t {V:T=None; e} h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t {V:T=None; e} h s s'", "by(induct rule: tranclp_induct)(blast intro: tranclp.trancl_into_trancl Block_\\<tau>execI_None)+"], ["", "lemma Sync_\\<tau>ExectI:\n  \"\\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (sync\\<^bsub>V\\<^esub> (e) e') h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t (sync\\<^bsub>V\\<^esub> (e) e') h s s'", "by(induct rule: tranclp_induct)(blast intro: tranclp.trancl_into_trancl Sync_\\<tau>execI)+"], ["", "lemma Insync_\\<tau>ExectI:\n  \"\\<tau>Exec_movet ci P t e' h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_movet ci P t (sync\\<^bsub>V\\<^esub> (e) e')  h (stk, loc, (Suc (Suc (Suc (length (compE2 e) + pc)))), xcp) (stk', loc', (Suc (Suc (Suc (length (compE2 e) + pc')))), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t e' h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t (sync\\<^bsub>V\\<^esub> (e) e') h\n     (stk, loc, Suc (Suc (Suc (length (compE2 e) + pc))), xcp)\n     (stk', loc', Suc (Suc (Suc (length (compE2 e) + pc'))), xcp')", "by(induct rule: \\<tau>Exect_induct)(blast intro: tranclp.trancl_into_trancl Insync_\\<tau>execI)+"], ["", "lemma Seq_\\<tau>ExectI1:\n  \"\\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (e;;e') h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t (e;; e') h s s'", "by(induct rule: tranclp_induct)(blast intro: tranclp.trancl_into_trancl Seq_\\<tau>execI1)+"], ["", "lemma Seq_\\<tau>ExectI2:\n  \"\\<tau>Exec_movet ci P t e h (stk, loc, pc, xcp) (stk', loc', pc' ,xcp') \\<Longrightarrow>\n   \\<tau>Exec_movet ci P t (e';;e) h (stk, loc, (Suc (length (compE2 e') + pc)), xcp) (stk', loc', (Suc (length (compE2 e') + pc')), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t e h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t (e';; e) h\n     (stk, loc, Suc (length (compE2 e') + pc), xcp)\n     (stk', loc', Suc (length (compE2 e') + pc'), xcp')", "by(induct rule: \\<tau>Exect_induct)(blast intro: tranclp.trancl_into_trancl Seq_\\<tau>execI2)+"], ["", "lemma Cond_\\<tau>ExectI1:\n  \"\\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (if (e) e1 else e2) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t (if (e) e1 else e2) h s s'", "by(induct rule: tranclp_induct)(blast intro: tranclp.trancl_into_trancl Cond_\\<tau>execI1)+"], ["", "lemma Cond_\\<tau>ExectI2:\n  \"\\<tau>Exec_movet ci P t e1  h (stk, loc, pc, xcp) (stk', loc', pc', xcp') \\<Longrightarrow>\n   \\<tau>Exec_movet ci P t (if (e) e1 else e2)  h (stk, loc, (Suc (length (compE2 e) + pc)), xcp) (stk', loc', (Suc (length (compE2 e) + pc')), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t e1 h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (length (compE2 e) + pc), xcp)\n     (stk', loc', Suc (length (compE2 e) + pc'), xcp')", "by(induct rule: \\<tau>Exect_induct)(blast intro: tranclp.trancl_into_trancl Cond_\\<tau>execI2)+"], ["", "lemma Cond_\\<tau>ExectI3:\n  \"\\<tau>Exec_movet ci P t e2  h (stk, loc ,pc, xcp) (stk', loc', pc', xcp') \\<Longrightarrow>\n   \\<tau>Exec_movet ci P t (if (e) e1 else e2)  h (stk, loc, (Suc (Suc (length (compE2 e) + length (compE2 e1) + pc))), xcp)  (stk', loc', (Suc (Suc (length (compE2 e) + length (compE2 e1) + pc'))), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t e2 h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t (if (e) e1 else e2) h\n     (stk, loc, Suc (Suc (length (compE2 e) + length (compE2 e1) + pc)),\n      xcp)\n     (stk', loc', Suc (Suc (length (compE2 e) + length (compE2 e1) + pc')),\n      xcp')", "by(induct rule: \\<tau>Exect_induct)(blast intro: tranclp.trancl_into_trancl Cond_\\<tau>execI3)+"], ["", "lemma While_\\<tau>ExectI1:\n  \"\\<tau>Exec_movet ci P t c h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (while (c) e) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t c h s s' \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t (while (c) e) h s s'", "by(induct rule: tranclp_induct)(blast intro: tranclp.trancl_into_trancl While_\\<tau>execI1)+"], ["", "lemma While_\\<tau>ExectI2:\n  \"\\<tau>Exec_movet ci P t E h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_movet ci P t (while (c) E)  h (stk, loc ,(Suc (length (compE2 c) + pc)), xcp) (stk', loc', (Suc (length (compE2 c) + pc')), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t E h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t (while (c) E) h\n     (stk, loc, Suc (length (compE2 c) + pc), xcp)\n     (stk', loc', Suc (length (compE2 c) + pc'), xcp')", "by(induct rule: \\<tau>Exect_induct)(blast intro: tranclp.trancl_into_trancl While_\\<tau>execI2)+"], ["", "lemma Throw_\\<tau>ExectI:\n  \"\\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (throw e) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t e h s s' \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t (throw e) h s s'", "by(induct rule: tranclp_induct)(blast intro: tranclp.trancl_into_trancl Throw_\\<tau>execI)+"], ["", "lemma Try_\\<tau>ExectI1:\n  \"\\<tau>Exec_movet ci P t E h s s' \\<Longrightarrow> \\<tau>Exec_movet ci P t (try E catch(C' V) e) h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t E h s s' \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t (try E catch(C' V) e) h s s'", "by(induct rule: tranclp_induct)(blast intro: tranclp.trancl_into_trancl Try_\\<tau>execI1)+"], ["", "lemma Try_\\<tau>ExectI2:\n  \"\\<tau>Exec_movet ci P t e h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n  \\<Longrightarrow> \\<tau>Exec_movet ci P t (try E catch(C' V) e)  h (stk, loc, (Suc (Suc (length (compE2 E) + pc))), xcp)  (stk', loc', (Suc (Suc (length (compE2 E) + pc'))), xcp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t e h (stk, loc, pc, xcp)\n     (stk', loc', pc', xcp') \\<Longrightarrow>\n    \\<tau>Exec_movet ci P t (try E catch(C' V) e) h\n     (stk, loc, Suc (Suc (length (compE2 E) + pc)), xcp)\n     (stk', loc', Suc (Suc (length (compE2 E) + pc')), xcp')", "by(induct rule: \\<tau>Exect_induct)(blast intro: tranclp.trancl_into_trancl Try_\\<tau>execI2)+"], ["", "lemma \\<tau>Exec_movesr_map_Val:\n  \"\\<tau>Exec_movesr_a P t (map Val vs) h ([], xs, 0, None) ((rev vs), xs, (length (compEs2 (map Val vs))), None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movesr_a P t (map Val vs) h ([], xs, 0, None)\n     (rev vs, xs, length (compEs2 (map Val vs)), None)", "proof(induct vs arbitrary: pc stk Ts rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<tau>Exec_movesr_a P t (map Val []) h ([], xs, 0, None)\n     (rev [], xs, length (compEs2 (map Val [])), None)\n 2. \\<And>x xsa.\n       \\<tau>Exec_movesr_a P t (map Val xsa) h ([], xs, 0, None)\n        (rev xsa, xs, length (compEs2 (map Val xsa)),\n         None) \\<Longrightarrow>\n       \\<tau>Exec_movesr_a P t (map Val (xsa @ [x])) h ([], xs, 0, None)\n        (rev (xsa @ [x]), xs, length (compEs2 (map Val (xsa @ [x]))), None)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<tau>Exec_movesr_a P t (map Val []) h ([], xs, 0, None)\n     (rev [], xs, length (compEs2 (map Val [])), None)\n 2. \\<And>x xsa.\n       \\<tau>Exec_movesr_a P t (map Val xsa) h ([], xs, 0, None)\n        (rev xsa, xs, length (compEs2 (map Val xsa)),\n         None) \\<Longrightarrow>\n       \\<tau>Exec_movesr_a P t (map Val (xsa @ [x])) h ([], xs, 0, None)\n        (rev (xsa @ [x]), xs, length (compEs2 (map Val (xsa @ [x]))), None)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movesr_a P t (map Val []) h ([], xs, 0, None)\n     (rev [], xs, length (compEs2 (map Val [])), None)", "by(auto)"], ["proof (state)\nthis:\n  \\<tau>Exec_movesr_a P t (map Val []) h ([], xs, 0, None)\n   (rev [], xs, length (compEs2 (map Val [])), None)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<tau>Exec_movesr_a P t (map Val xsa) h ([], xs, 0, None)\n        (rev xsa, xs, length (compEs2 (map Val xsa)),\n         None) \\<Longrightarrow>\n       \\<tau>Exec_movesr_a P t (map Val (xsa @ [x])) h ([], xs, 0, None)\n        (rev (xsa @ [x]), xs, length (compEs2 (map Val (xsa @ [x]))), None)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<tau>Exec_movesr_a P t (map Val xsa) h ([], xs, 0, None)\n        (rev xsa, xs, length (compEs2 (map Val xsa)),\n         None) \\<Longrightarrow>\n       \\<tau>Exec_movesr_a P t (map Val (xsa @ [x])) h ([], xs, 0, None)\n        (rev (xsa @ [x]), xs, length (compEs2 (map Val (xsa @ [x]))), None)", "case (snoc v vs')"], ["proof (state)\nthis:\n  \\<tau>Exec_movesr_a P t (map Val vs') h ([], xs, 0, None)\n   (rev vs', xs, length (compEs2 (map Val vs')), None)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<tau>Exec_movesr_a P t (map Val xsa) h ([], xs, 0, None)\n        (rev xsa, xs, length (compEs2 (map Val xsa)),\n         None) \\<Longrightarrow>\n       \\<tau>Exec_movesr_a P t (map Val (xsa @ [x])) h ([], xs, 0, None)\n        (rev (xsa @ [x]), xs, length (compEs2 (map Val (xsa @ [x]))), None)", "let ?E = \"compEs2 (map Val vs')\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<tau>Exec_movesr_a P t (map Val xsa) h ([], xs, 0, None)\n        (rev xsa, xs, length (compEs2 (map Val xsa)),\n         None) \\<Longrightarrow>\n       \\<tau>Exec_movesr_a P t (map Val (xsa @ [x])) h ([], xs, 0, None)\n        (rev (xsa @ [x]), xs, length (compEs2 (map Val (xsa @ [x]))), None)", "from snoc"], ["proof (chain)\npicking this:\n  \\<tau>Exec_movesr_a P t (map Val vs') h ([], xs, 0, None)\n   (rev vs', xs, length (compEs2 (map Val vs')), None)", "have \"\\<tau>Exec_movesr_a P t (map Val (vs' @ [v])) h ([], xs, 0, None) ((rev vs'), xs, (length ?E), None)\""], ["proof (prove)\nusing this:\n  \\<tau>Exec_movesr_a P t (map Val vs') h ([], xs, 0, None)\n   (rev vs', xs, length (compEs2 (map Val vs')), None)\n\ngoal (1 subgoal):\n 1. \\<tau>Exec_movesr_a P t (map Val (vs' @ [v])) h ([], xs, 0, None)\n     (rev vs', xs, length (compEs2 (map Val vs')), None)", "by auto"], ["proof (state)\nthis:\n  \\<tau>Exec_movesr_a P t (map Val (vs' @ [v])) h ([], xs, 0, None)\n   (rev vs', xs, length (compEs2 (map Val vs')), None)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<tau>Exec_movesr_a P t (map Val xsa) h ([], xs, 0, None)\n        (rev xsa, xs, length (compEs2 (map Val xsa)),\n         None) \\<Longrightarrow>\n       \\<tau>Exec_movesr_a P t (map Val (xsa @ [x])) h ([], xs, 0, None)\n        (rev (xsa @ [x]), xs, length (compEs2 (map Val (xsa @ [x]))), None)", "also"], ["proof (state)\nthis:\n  \\<tau>Exec_movesr_a P t (map Val (vs' @ [v])) h ([], xs, 0, None)\n   (rev vs', xs, length (compEs2 (map Val vs')), None)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<tau>Exec_movesr_a P t (map Val xsa) h ([], xs, 0, None)\n        (rev xsa, xs, length (compEs2 (map Val xsa)),\n         None) \\<Longrightarrow>\n       \\<tau>Exec_movesr_a P t (map Val (xsa @ [x])) h ([], xs, 0, None)\n        (rev (xsa @ [x]), xs, length (compEs2 (map Val (xsa @ [x]))), None)", "{"], ["proof (state)\nthis:\n  \\<tau>Exec_movesr_a P t (map Val (vs' @ [v])) h ([], xs, 0, None)\n   (rev vs', xs, length (compEs2 (map Val vs')), None)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<tau>Exec_movesr_a P t (map Val xsa) h ([], xs, 0, None)\n        (rev xsa, xs, length (compEs2 (map Val xsa)),\n         None) \\<Longrightarrow>\n       \\<tau>Exec_movesr_a P t (map Val (xsa @ [x])) h ([], xs, 0, None)\n        (rev (xsa @ [x]), xs, length (compEs2 (map Val (xsa @ [x]))), None)", "have \"exec_meth_a (compP2 P) (?E @ [Push v]) (compxEs2 (map Val vs') 0 0 @ shift (length ?E) []) t h ((rev vs'), xs, (length ?E + 0), None) \\<epsilon> h ((v # rev vs'), xs, (length ?E + Suc 0), None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth_a (compP2 P) (compEs2 (map Val vs') @ [Push v])\n     (compxEs2 (map Val vs') 0 0 @\n      shift (length (compEs2 (map Val vs'))) [])\n     t h (rev vs', xs, length (compEs2 (map Val vs')) + 0, None)\n     \\<lbrace>\\<rbrace> h\n     (v # rev vs', xs, length (compEs2 (map Val vs')) + Suc 0, None)", "by -(rule append_exec_meth_xt, auto simp add: exec_meth_instr)"], ["proof (state)\nthis:\n  exec_meth_a (compP2 P) (compEs2 (map Val vs') @ [Push v])\n   (compxEs2 (map Val vs') 0 0 @ shift (length (compEs2 (map Val vs'))) [])\n   t h (rev vs', xs, length (compEs2 (map Val vs')) + 0, None)\n   \\<lbrace>\\<rbrace> h\n   (v # rev vs', xs, length (compEs2 (map Val vs')) + Suc 0, None)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<tau>Exec_movesr_a P t (map Val xsa) h ([], xs, 0, None)\n        (rev xsa, xs, length (compEs2 (map Val xsa)),\n         None) \\<Longrightarrow>\n       \\<tau>Exec_movesr_a P t (map Val (xsa @ [x])) h ([], xs, 0, None)\n        (rev (xsa @ [x]), xs, length (compEs2 (map Val (xsa @ [x]))), None)", "moreover"], ["proof (state)\nthis:\n  exec_meth_a (compP2 P) (compEs2 (map Val vs') @ [Push v])\n   (compxEs2 (map Val vs') 0 0 @ shift (length (compEs2 (map Val vs'))) [])\n   t h (rev vs', xs, length (compEs2 (map Val vs')) + 0, None)\n   \\<lbrace>\\<rbrace> h\n   (v # rev vs', xs, length (compEs2 (map Val vs')) + Suc 0, None)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<tau>Exec_movesr_a P t (map Val xsa) h ([], xs, 0, None)\n        (rev xsa, xs, length (compEs2 (map Val xsa)),\n         None) \\<Longrightarrow>\n       \\<tau>Exec_movesr_a P t (map Val (xsa @ [x])) h ([], xs, 0, None)\n        (rev (xsa @ [x]), xs, length (compEs2 (map Val (xsa @ [x]))), None)", "have \"\\<tau>moves2 (compP2 P) h (rev vs') (map Val vs' @ [Val v]) (length (compEs2 (map Val vs')) + 0) None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>moves2 (compP2 P) h (rev vs') (map Val vs' @ [Val v])\n     (length (compEs2 (map Val vs')) + 0) None", "by(rule append_\\<tau>moves2 \\<tau>moves2Hd \\<tau>move2Val)+"], ["proof (state)\nthis:\n  \\<tau>moves2 (compP2 P) h (rev vs') (map Val vs' @ [Val v])\n   (length (compEs2 (map Val vs')) + 0) None\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<tau>Exec_movesr_a P t (map Val xsa) h ([], xs, 0, None)\n        (rev xsa, xs, length (compEs2 (map Val xsa)),\n         None) \\<Longrightarrow>\n       \\<tau>Exec_movesr_a P t (map Val (xsa @ [x])) h ([], xs, 0, None)\n        (rev (xsa @ [x]), xs, length (compEs2 (map Val (xsa @ [x]))), None)", "ultimately"], ["proof (chain)\npicking this:\n  exec_meth_a (compP2 P) (compEs2 (map Val vs') @ [Push v])\n   (compxEs2 (map Val vs') 0 0 @ shift (length (compEs2 (map Val vs'))) [])\n   t h (rev vs', xs, length (compEs2 (map Val vs')) + 0, None)\n   \\<lbrace>\\<rbrace> h\n   (v # rev vs', xs, length (compEs2 (map Val vs')) + Suc 0, None)\n  \\<tau>moves2 (compP2 P) h (rev vs') (map Val vs' @ [Val v])\n   (length (compEs2 (map Val vs')) + 0) None", "have \"\\<tau>Exec_movesr_a P t (map Val (vs' @ [v])) h ((rev vs'), xs, (length ?E), None) ((rev (vs' @ [v])), xs, (length (compEs2 (map Val (vs' @ [v])))), None)\""], ["proof (prove)\nusing this:\n  exec_meth_a (compP2 P) (compEs2 (map Val vs') @ [Push v])\n   (compxEs2 (map Val vs') 0 0 @ shift (length (compEs2 (map Val vs'))) [])\n   t h (rev vs', xs, length (compEs2 (map Val vs')) + 0, None)\n   \\<lbrace>\\<rbrace> h\n   (v # rev vs', xs, length (compEs2 (map Val vs')) + Suc 0, None)\n  \\<tau>moves2 (compP2 P) h (rev vs') (map Val vs' @ [Val v])\n   (length (compEs2 (map Val vs')) + 0) None\n\ngoal (1 subgoal):\n 1. \\<tau>Exec_movesr_a P t (map Val (vs' @ [v])) h\n     (rev vs', xs, length (compEs2 (map Val vs')), None)\n     (rev (vs' @ [v]), xs, length (compEs2 (map Val (vs' @ [v]))), None)", "by -(rule \\<tau>Execsr1step, auto simp add: exec_moves_def compP2_def)"], ["proof (state)\nthis:\n  \\<tau>Exec_movesr_a P t (map Val (vs' @ [v])) h\n   (rev vs', xs, length (compEs2 (map Val vs')), None)\n   (rev (vs' @ [v]), xs, length (compEs2 (map Val (vs' @ [v]))), None)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<tau>Exec_movesr_a P t (map Val xsa) h ([], xs, 0, None)\n        (rev xsa, xs, length (compEs2 (map Val xsa)),\n         None) \\<Longrightarrow>\n       \\<tau>Exec_movesr_a P t (map Val (xsa @ [x])) h ([], xs, 0, None)\n        (rev (xsa @ [x]), xs, length (compEs2 (map Val (xsa @ [x]))), None)", "}"], ["proof (state)\nthis:\n  \\<tau>Exec_movesr_a P t (map Val (vs' @ [v])) h\n   (rev vs', xs, length (compEs2 (map Val vs')), None)\n   (rev (vs' @ [v]), xs, length (compEs2 (map Val (vs' @ [v]))), None)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<tau>Exec_movesr_a P t (map Val xsa) h ([], xs, 0, None)\n        (rev xsa, xs, length (compEs2 (map Val xsa)),\n         None) \\<Longrightarrow>\n       \\<tau>Exec_movesr_a P t (map Val (xsa @ [x])) h ([], xs, 0, None)\n        (rev (xsa @ [x]), xs, length (compEs2 (map Val (xsa @ [x]))), None)", "finally"], ["proof (chain)\npicking this:\n  \\<tau>Exec_movesr_a P t (map Val (vs' @ [v])) h ([], xs, 0, None)\n   (rev (vs' @ [v]), xs, length (compEs2 (map Val (vs' @ [v]))), None)", "show ?case"], ["proof (prove)\nusing this:\n  \\<tau>Exec_movesr_a P t (map Val (vs' @ [v])) h ([], xs, 0, None)\n   (rev (vs' @ [v]), xs, length (compEs2 (map Val (vs' @ [v]))), None)\n\ngoal (1 subgoal):\n 1. \\<tau>Exec_movesr_a P t (map Val (vs' @ [v])) h ([], xs, 0, None)\n     (rev (vs' @ [v]), xs, length (compEs2 (map Val (vs' @ [v]))), None)", "."], ["proof (state)\nthis:\n  \\<tau>Exec_movesr_a P t (map Val (vs' @ [v])) h ([], xs, 0, None)\n   (rev (vs' @ [v]), xs, length (compEs2 (map Val (vs' @ [v]))), None)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<tau>Exec_mover_blocks1 [simp]:\n  \"\\<tau>Exec_mover ci P t (blocks1 n Ts body) h s s' = \\<tau>Exec_mover ci P t body h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_mover ci P t (blocks1 n Ts body) h s s' =\n    \\<tau>Exec_mover ci P t body h s s'", "by(simp add: \\<tau>exec_move_conv_\\<tau>exec_meth)"], ["", "lemma \\<tau>Exec_movet_blocks1 [simp]:\n  \"\\<tau>Exec_movet ci P t (blocks1 n Ts body) h s s' = \\<tau>Exec_movet ci P t body h s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_movet ci P t (blocks1 n Ts body) h s s' =\n    \\<tau>Exec_movet ci P t body h s s'", "by(simp add: \\<tau>exec_move_conv_\\<tau>exec_meth)"], ["", "definition \\<tau>exec_1 :: \"'addr jvm_prog \\<Rightarrow> 'thread_id \\<Rightarrow> ('addr, 'heap) jvm_state \\<Rightarrow> ('addr, 'heap) jvm_state \\<Rightarrow> bool\"\n  where \"\\<tau>exec_1 P t \\<sigma> \\<sigma>' \\<longleftrightarrow> exec_1 P t \\<sigma> \\<epsilon> \\<sigma>' \\<and> \\<tau>Move2 P \\<sigma>\""], ["", "lemma \\<tau>exec_1I [intro]:\n  \"\\<lbrakk> exec_1 P t \\<sigma> \\<epsilon> \\<sigma>'; \\<tau>Move2 P \\<sigma> \\<rbrakk> \\<Longrightarrow> \\<tau>exec_1 P t \\<sigma> \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,t \\<turnstile> \\<sigma> -\\<lbrace>\\<rbrace>-jvm\\<rightarrow>\n             \\<sigma>';\n     \\<tau>Move2 P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> \\<tau>exec_1 P t \\<sigma> \\<sigma>'", "by(simp add: \\<tau>exec_1_def)"], ["", "lemma \\<tau>exec_1E [elim]:\n  assumes \"\\<tau>exec_1 P t \\<sigma> \\<sigma>'\"\n  obtains \"exec_1 P t \\<sigma> \\<epsilon> \\<sigma>'\" \"\\<tau>Move2 P \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>P,t \\<turnstile> \\<sigma> -\\<lbrace>\\<rbrace>-jvm\\<rightarrow>\n              \\<sigma>';\n      \\<tau>Move2 P \\<sigma>\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<tau>exec_1 P t \\<sigma> \\<sigma>'\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>P,t \\<turnstile> \\<sigma> -\\<lbrace>\\<rbrace>-jvm\\<rightarrow>\n              \\<sigma>';\n      \\<tau>Move2 P \\<sigma>\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: \\<tau>exec_1_def)"], ["", "abbreviation \\<tau>Exec_1r :: \"'addr jvm_prog \\<Rightarrow> 'thread_id \\<Rightarrow> ('addr, 'heap) jvm_state \\<Rightarrow> ('addr, 'heap) jvm_state \\<Rightarrow> bool\"\nwhere \"\\<tau>Exec_1r P t == (\\<tau>exec_1 P t)^**\""], ["", "abbreviation \\<tau>Exec_1t :: \"'addr jvm_prog \\<Rightarrow> 'thread_id \\<Rightarrow> ('addr, 'heap) jvm_state \\<Rightarrow> ('addr, 'heap) jvm_state \\<Rightarrow> bool\"\nwhere \"\\<tau>Exec_1t P t == (\\<tau>exec_1 P t)^++\""], ["", "definition \\<tau>exec_1_d :: \"'addr jvm_prog \\<Rightarrow> 'thread_id \\<Rightarrow> ('addr, 'heap) jvm_state \\<Rightarrow> ('addr, 'heap) jvm_state \\<Rightarrow> bool\"\nwhere \"\\<tau>exec_1_d P t \\<sigma> \\<sigma>' \\<longleftrightarrow> exec_1 P t \\<sigma> \\<epsilon> \\<sigma>' \\<and> \\<tau>Move2 P \\<sigma> \\<and> check P \\<sigma>\""], ["", "lemma \\<tau>exec_1_dI [intro]:\n  \"\\<lbrakk> exec_1 P t \\<sigma> \\<epsilon> \\<sigma>'; check P \\<sigma>; \\<tau>Move2 P \\<sigma> \\<rbrakk> \\<Longrightarrow> \\<tau>exec_1_d P t \\<sigma> \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,t \\<turnstile> \\<sigma> -\\<lbrace>\\<rbrace>-jvm\\<rightarrow>\n             \\<sigma>';\n     check P \\<sigma>; \\<tau>Move2 P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> \\<tau>exec_1_d P t \\<sigma> \\<sigma>'", "by(simp add: \\<tau>exec_1_d_def)"], ["", "lemma \\<tau>exec_1_dE [elim]:\n  assumes \"\\<tau>exec_1_d P t \\<sigma> \\<sigma>'\"\n  obtains \"exec_1 P t \\<sigma> \\<epsilon> \\<sigma>'\" \"check P \\<sigma>\" \"\\<tau>Move2 P \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>P,t \\<turnstile> \\<sigma> -\\<lbrace>\\<rbrace>-jvm\\<rightarrow>\n              \\<sigma>';\n      check P \\<sigma>; \\<tau>Move2 P \\<sigma>\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<tau>exec_1_d P t \\<sigma> \\<sigma>'\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>P,t \\<turnstile> \\<sigma> -\\<lbrace>\\<rbrace>-jvm\\<rightarrow>\n              \\<sigma>';\n      check P \\<sigma>; \\<tau>Move2 P \\<sigma>\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: \\<tau>exec_1_d_def)"], ["", "abbreviation \\<tau>Exec_1_dr :: \"'addr jvm_prog \\<Rightarrow> 'thread_id \\<Rightarrow> ('addr, 'heap) jvm_state \\<Rightarrow> ('addr, 'heap) jvm_state \\<Rightarrow> bool\"\nwhere \"\\<tau>Exec_1_dr P t == (\\<tau>exec_1_d P t)^**\""], ["", "abbreviation \\<tau>Exec_1_dt :: \"'addr jvm_prog \\<Rightarrow> 'thread_id \\<Rightarrow> ('addr, 'heap) jvm_state \\<Rightarrow> ('addr, 'heap) jvm_state \\<Rightarrow> bool\"\nwhere \"\\<tau>Exec_1_dt P t == (\\<tau>exec_1_d P t)^++\""], ["", "declare compxE2_size_convs[simp del] compxEs2_size_convs[simp del]"], ["", "declare compxE2_stack_xlift_convs[simp del] compxEs2_stack_xlift_convs[simp del]"], ["", "lemma exec_instr_frs_offer:\n  \"(ta, xcp', h', (stk', loc', C, M, pc') # frs) \\<in> exec_instr ins P t h stk loc C M pc frs\n  \\<Longrightarrow> (ta, xcp', h', (stk', loc', C, M, pc') # frs @ frs') \\<in> exec_instr ins P t h stk loc C M pc (frs @ frs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ta, xcp', h', (stk', loc', C, M, pc') # frs)\n    \\<in> exec_instr ins P t h stk loc C M pc frs \\<Longrightarrow>\n    (ta, xcp', h', (stk', loc', C, M, pc') # frs @ frs')\n    \\<in> exec_instr ins P t h stk loc C M pc (frs @ frs')", "apply(cases ins)"], ["proof (prove)\ngoal (24 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', (stk', loc', C, M, pc') # frs)\n                \\<in> exec_instr ins P t h stk loc C M pc frs;\n        ins = Load x1\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          (stk', loc', C, M, pc') # frs @ frs')\n                         \\<in> exec_instr ins P t h stk loc C M pc\n                                (frs @ frs')\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', (stk', loc', C, M, pc') # frs)\n                \\<in> exec_instr ins P t h stk loc C M pc frs;\n        ins = Store x2\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          (stk', loc', C, M, pc') # frs @ frs')\n                         \\<in> exec_instr ins P t h stk loc C M pc\n                                (frs @ frs')\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', (stk', loc', C, M, pc') # frs)\n                \\<in> exec_instr ins P t h stk loc C M pc frs;\n        ins = Push x3\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          (stk', loc', C, M, pc') # frs @ frs')\n                         \\<in> exec_instr ins P t h stk loc C M pc\n                                (frs @ frs')\n 4. \\<And>x4.\n       \\<lbrakk>(ta, xcp', h', (stk', loc', C, M, pc') # frs)\n                \\<in> exec_instr ins P t h stk loc C M pc frs;\n        ins = New x4\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          (stk', loc', C, M, pc') # frs @ frs')\n                         \\<in> exec_instr ins P t h stk loc C M pc\n                                (frs @ frs')\n 5. \\<And>x5.\n       \\<lbrakk>(ta, xcp', h', (stk', loc', C, M, pc') # frs)\n                \\<in> exec_instr ins P t h stk loc C M pc frs;\n        ins = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          (stk', loc', C, M, pc') # frs @ frs')\n                         \\<in> exec_instr ins P t h stk loc C M pc\n                                (frs @ frs')\n 6. \\<lbrakk>(ta, xcp', h', (stk', loc', C, M, pc') # frs)\n             \\<in> exec_instr ins P t h stk loc C M pc frs;\n     ins = ALoad\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h', (stk', loc', C, M, pc') # frs @ frs')\n                      \\<in> exec_instr ins P t h stk loc C M pc (frs @ frs')\n 7. \\<lbrakk>(ta, xcp', h', (stk', loc', C, M, pc') # frs)\n             \\<in> exec_instr ins P t h stk loc C M pc frs;\n     ins = AStore\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h', (stk', loc', C, M, pc') # frs @ frs')\n                      \\<in> exec_instr ins P t h stk loc C M pc (frs @ frs')\n 8. \\<lbrakk>(ta, xcp', h', (stk', loc', C, M, pc') # frs)\n             \\<in> exec_instr ins P t h stk loc C M pc frs;\n     ins = ALength\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h', (stk', loc', C, M, pc') # frs @ frs')\n                      \\<in> exec_instr ins P t h stk loc C M pc (frs @ frs')\n 9. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', (stk', loc', C, M, pc') # frs)\n                \\<in> exec_instr ins P t h stk loc C M pc frs;\n        ins = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          (stk', loc', C, M, pc') # frs @ frs')\n                         \\<in> exec_instr ins P t h stk loc C M pc\n                                (frs @ frs')\n 10. \\<And>x101 x102.\n        \\<lbrakk>(ta, xcp', h', (stk', loc', C, M, pc') # frs)\n                 \\<in> exec_instr ins P t h stk loc C M pc frs;\n         ins = Putfield x101 x102\\<rbrakk>\n        \\<Longrightarrow> (ta, xcp', h',\n                           (stk', loc', C, M, pc') # frs @ frs')\n                          \\<in> exec_instr ins P t h stk loc C M pc\n                                 (frs @ frs')\nA total of 24 subgoals...", "apply(simp_all add: nth_append split_beta split: if_split_asm sum.split_asm)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x4.\n       \\<lbrakk>ins = New x4; allocate h (Class_type x4) \\<noteq> {};\n        (ta, xcp', h', (stk', loc', C, M, pc') # frs)\n        \\<in> (\\<lambda>x.\n                  (\\<lbrace>NewHeapElem (snd x) (Class_type x4)\\<rbrace>,\n                   None, fst x,\n                   (Addr (snd x) # stk, loc, C, M, Suc pc) # frs)) `\n              allocate h (Class_type x4)\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          (stk', loc', C, M, pc') # frs @ frs')\n                         \\<in> (\\<lambda>x.\n                                   (\\<lbrace>NewHeapElem (snd x)\n        (Class_type x4)\\<rbrace>,\n                                    None, fst x,\n                                    (Addr (snd x) # stk, loc, C, M,\n                                     Suc pc) #\n                                    frs @ frs')) `\n                               allocate h (Class_type x4)\n 2. \\<And>x5.\n       \\<lbrakk>ins = NewArray x5; \\<not> the_Intg (hd stk) <s 0;\n        allocate h (Array_type x5 (nat (sint (the_Intg (hd stk))))) \\<noteq>\n        {};\n        (ta, xcp', h', (stk', loc', C, M, pc') # frs)\n        \\<in> (\\<lambda>x.\n                  (\\<lbrace>NewHeapElem (snd x)\n                             (Array_type x5\n                               (nat (sint (the_Intg (hd stk)))))\\<rbrace>,\n                   None, fst x,\n                   (Addr (snd x) # tl stk, loc, C, M, Suc pc) # frs)) `\n              allocate h\n               (Array_type x5 (nat (sint (the_Intg (hd stk)))))\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h',\n                          (stk', loc', C, M, pc') # frs @ frs')\n                         \\<in> (\\<lambda>x.\n                                   (\\<lbrace>NewHeapElem (snd x)\n        (Array_type x5 (nat (sint (the_Intg (hd stk)))))\\<rbrace>,\n                                    None, fst x,\n                                    (Addr (snd x) # tl stk, loc, C, M,\n                                     Suc pc) #\n                                    frs @ frs')) `\n                               allocate h\n                                (Array_type x5\n                                  (nat (sint (the_Intg (hd stk)))))\n 3. \\<lbrakk>ins = AStore; hd (tl (tl stk)) \\<noteq> Null;\n     the_Intg (hd (tl stk)) <s 0 \\<or>\n     int (alen_of_htype (the (typeof_addr h (the_Addr (hd (tl (tl stk)))))))\n     \\<le> sint (the_Intg (hd (tl stk)));\n     ta = \\<lbrace>\\<rbrace> \\<and>\n     xcp' = \\<lfloor>addr_of_sys_xcpt ArrayIndexOutOfBounds\\<rfloor> \\<and>\n     h' = h \\<and> stk' = stk \\<and> loc' = loc \\<and> pc' = pc\\<rbrakk>\n    \\<Longrightarrow> \\<not> P \\<turnstile> the\n       (typeof\\<^bsub>h\\<^esub>\n         (hd stk)) \\<le> the_Array\n                          (ty_of_htype\n                            (the (typeof_addr h\n                                   (the_Addr\n                                     (hd\n (tl (tl stk))))))) \\<longrightarrow>\n                      \\<not> the_Intg (hd (tl stk)) <s 0 \\<and>\n                      \\<not> int (alen_of_htype\n                                   (the (typeof_addr h\n    (the_Addr (hd (tl (tl stk)))))))\n                             \\<le> sint\n                                    (the_Intg\n(hd (tl stk))) \\<longrightarrow>\n                      addr_of_sys_xcpt ArrayIndexOutOfBounds =\n                      addr_of_sys_xcpt ArrayStore\n 4. \\<And>x141 x142.\n       \\<lbrakk>ins = Invoke x141 x142; stk ! x142 \\<noteq> Null;\n        snd (snd (snd (method P\n                        (class_type_of\n                          (the (typeof_addr h (the_Addr (stk ! x142)))))\n                        x141))) =\n        None;\n        \\<exists>a aa aaa aaaa aaaaa b.\n           ta =\n           (a, map (convert_new_thread_action (extNTA2JVM P)) aa, aaa, aaaa,\n            aaaaa, b) \\<and>\n           (\\<exists>va.\n               (case va of\n                RetVal v \\<Rightarrow>\n                  xcp' = None \\<and>\n                  (stk', loc', C, M, pc') # frs =\n                  (v # drop (Suc x142) stk, loc, C, M, pc + 1) # frs\n                | RetExc a \\<Rightarrow>\n                    xcp' = \\<lfloor>a\\<rfloor> \\<and>\n                    (stk', loc', C, M, pc') # frs =\n                    (stk, loc, C, M, pc) # frs\n                | RetStaySame \\<Rightarrow>\n                    xcp' = None \\<and>\n                    (stk', loc', C, M, pc') # frs =\n                    (stk, loc, C, M, pc) # frs) \\<and>\n               ((a, aa, aaa, aaaa, aaaaa, b), va, h')\n               \\<in> red_external_aggr P t (the_Addr (stk ! x142)) x141\n                      (rev (take x142 stk)) h)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa aaa aaaa aaaaa b.\n                            ta =\n                            (a, map (convert_new_thread_action\n(extNTA2JVM P))\n                                 aa,\n                             aaa, aaaa, aaaaa, b) \\<and>\n                            (\\<exists>va.\n                                (case va of\n                                 RetVal v \\<Rightarrow>\n                                   xcp' = None \\<and>\n                                   (stk', loc', C, M, pc') # frs @ frs' =\n                                   (v # drop (Suc x142) stk, loc, C, M,\n                                    pc + 1) #\n                                   frs @ frs'\n                                 | RetExc a \\<Rightarrow>\n                                     xcp' = \\<lfloor>a\\<rfloor> \\<and>\n                                     (stk', loc', C, M, pc') # frs @ frs' =\n                                     (stk, loc, C, M, pc) # frs @ frs'\n                                 | RetStaySame \\<Rightarrow>\n                                     xcp' = None \\<and>\n                                     (stk', loc', C, M, pc') # frs @ frs' =\n                                     (stk, loc, C, M, pc) #\n                                     frs @ frs') \\<and>\n                                ((a, aa, aaa, aaaa, aaaaa, b), va, h')\n                                \\<in> red_external_aggr P t\n (the_Addr (stk ! x142)) x141 (rev (take x142 stk)) h)", "apply(force split: extCallRet.split_asm simp add: extRet2JVM_def)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma check_instr_frs_offer:\n  \"\\<lbrakk> check_instr ins P h stk loc C M pc frs; ins \\<noteq> Return \\<rbrakk>\n  \\<Longrightarrow> check_instr ins P h stk loc C M pc (frs @ frs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>check_instr ins P h stk loc C M pc frs;\n     ins \\<noteq> Return\\<rbrakk>\n    \\<Longrightarrow> check_instr ins P h stk loc C M pc (frs @ frs')", "by(cases ins)(simp_all split: if_split_asm)"], ["", "lemma exec_instr_CM_change:\n  \"(ta, xcp', h', (stk', loc', C, M, pc') # frs) \\<in> exec_instr ins P t h stk loc C M pc frs\n  \\<Longrightarrow> (ta, xcp', h', (stk', loc', C', M', pc') # frs) \\<in> exec_instr ins P t h stk loc C' M' pc frs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ta, xcp', h', (stk', loc', C, M, pc') # frs)\n    \\<in> exec_instr ins P t h stk loc C M pc frs \\<Longrightarrow>\n    (ta, xcp', h', (stk', loc', C', M', pc') # frs)\n    \\<in> exec_instr ins P t h stk loc C' M' pc frs", "apply(cases ins)"], ["proof (prove)\ngoal (24 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', (stk', loc', C, M, pc') # frs)\n                \\<in> exec_instr ins P t h stk loc C M pc frs;\n        ins = Load x1\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h', (stk', loc', C', M', pc') # frs)\n                         \\<in> exec_instr ins P t h stk loc C' M' pc frs\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', (stk', loc', C, M, pc') # frs)\n                \\<in> exec_instr ins P t h stk loc C M pc frs;\n        ins = Store x2\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h', (stk', loc', C', M', pc') # frs)\n                         \\<in> exec_instr ins P t h stk loc C' M' pc frs\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', (stk', loc', C, M, pc') # frs)\n                \\<in> exec_instr ins P t h stk loc C M pc frs;\n        ins = Push x3\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h', (stk', loc', C', M', pc') # frs)\n                         \\<in> exec_instr ins P t h stk loc C' M' pc frs\n 4. \\<And>x4.\n       \\<lbrakk>(ta, xcp', h', (stk', loc', C, M, pc') # frs)\n                \\<in> exec_instr ins P t h stk loc C M pc frs;\n        ins = New x4\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h', (stk', loc', C', M', pc') # frs)\n                         \\<in> exec_instr ins P t h stk loc C' M' pc frs\n 5. \\<And>x5.\n       \\<lbrakk>(ta, xcp', h', (stk', loc', C, M, pc') # frs)\n                \\<in> exec_instr ins P t h stk loc C M pc frs;\n        ins = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h', (stk', loc', C', M', pc') # frs)\n                         \\<in> exec_instr ins P t h stk loc C' M' pc frs\n 6. \\<lbrakk>(ta, xcp', h', (stk', loc', C, M, pc') # frs)\n             \\<in> exec_instr ins P t h stk loc C M pc frs;\n     ins = ALoad\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h', (stk', loc', C', M', pc') # frs)\n                      \\<in> exec_instr ins P t h stk loc C' M' pc frs\n 7. \\<lbrakk>(ta, xcp', h', (stk', loc', C, M, pc') # frs)\n             \\<in> exec_instr ins P t h stk loc C M pc frs;\n     ins = AStore\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h', (stk', loc', C', M', pc') # frs)\n                      \\<in> exec_instr ins P t h stk loc C' M' pc frs\n 8. \\<lbrakk>(ta, xcp', h', (stk', loc', C, M, pc') # frs)\n             \\<in> exec_instr ins P t h stk loc C M pc frs;\n     ins = ALength\\<rbrakk>\n    \\<Longrightarrow> (ta, xcp', h', (stk', loc', C', M', pc') # frs)\n                      \\<in> exec_instr ins P t h stk loc C' M' pc frs\n 9. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', (stk', loc', C, M, pc') # frs)\n                \\<in> exec_instr ins P t h stk loc C M pc frs;\n        ins = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h', (stk', loc', C', M', pc') # frs)\n                         \\<in> exec_instr ins P t h stk loc C' M' pc frs\n 10. \\<And>x101 x102.\n        \\<lbrakk>(ta, xcp', h', (stk', loc', C, M, pc') # frs)\n                 \\<in> exec_instr ins P t h stk loc C M pc frs;\n         ins = Putfield x101 x102\\<rbrakk>\n        \\<Longrightarrow> (ta, xcp', h', (stk', loc', C', M', pc') # frs)\n                          \\<in> exec_instr ins P t h stk loc C' M' pc frs\nA total of 24 subgoals...", "apply(simp_all add: nth_append split_beta neq_Nil_conv split: if_split_asm sum.split_asm)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x4.\n       \\<lbrakk>ins = New x4; allocate h (Class_type x4) \\<noteq> {};\n        (ta, xcp', h', (stk', loc', C, M, pc') # frs)\n        \\<in> (\\<lambda>x.\n                  (\\<lbrace>NewHeapElem (snd x) (Class_type x4)\\<rbrace>,\n                   None, fst x,\n                   (Addr (snd x) # stk, loc, C, M, Suc pc) # frs)) `\n              allocate h (Class_type x4)\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h', (stk', loc', C', M', pc') # frs)\n                         \\<in> (\\<lambda>x.\n                                   (\\<lbrace>NewHeapElem (snd x)\n        (Class_type x4)\\<rbrace>,\n                                    None, fst x,\n                                    (Addr (snd x) # stk, loc, C', M',\n                                     Suc pc) #\n                                    frs)) `\n                               allocate h (Class_type x4)\n 2. \\<And>x5.\n       \\<lbrakk>ins = NewArray x5; \\<not> the_Intg (hd stk) <s 0;\n        allocate h (Array_type x5 (nat (sint (the_Intg (hd stk))))) \\<noteq>\n        {};\n        (ta, xcp', h', (stk', loc', C, M, pc') # frs)\n        \\<in> (\\<lambda>x.\n                  (\\<lbrace>NewHeapElem (snd x)\n                             (Array_type x5\n                               (nat (sint (the_Intg (hd stk)))))\\<rbrace>,\n                   None, fst x,\n                   (Addr (snd x) # tl stk, loc, C, M, Suc pc) # frs)) `\n              allocate h\n               (Array_type x5 (nat (sint (the_Intg (hd stk)))))\\<rbrakk>\n       \\<Longrightarrow> (ta, xcp', h', (stk', loc', C', M', pc') # frs)\n                         \\<in> (\\<lambda>x.\n                                   (\\<lbrace>NewHeapElem (snd x)\n        (Array_type x5 (nat (sint (the_Intg (hd stk)))))\\<rbrace>,\n                                    None, fst x,\n                                    (Addr (snd x) # tl stk, loc, C', M',\n                                     Suc pc) #\n                                    frs)) `\n                               allocate h\n                                (Array_type x5\n                                  (nat (sint (the_Intg (hd stk)))))\n 3. \\<lbrakk>ins = AStore; hd (tl (tl stk)) \\<noteq> Null;\n     the_Intg (hd (tl stk)) <s 0 \\<or>\n     int (alen_of_htype (the (typeof_addr h (the_Addr (hd (tl (tl stk)))))))\n     \\<le> sint (the_Intg (hd (tl stk)));\n     ta = \\<lbrace>\\<rbrace> \\<and>\n     xcp' = \\<lfloor>addr_of_sys_xcpt ArrayIndexOutOfBounds\\<rfloor> \\<and>\n     h' = h \\<and> stk' = stk \\<and> loc' = loc \\<and> pc' = pc\\<rbrakk>\n    \\<Longrightarrow> \\<not> P \\<turnstile> the\n       (typeof\\<^bsub>h\\<^esub>\n         (hd stk)) \\<le> the_Array\n                          (ty_of_htype\n                            (the (typeof_addr h\n                                   (the_Addr\n                                     (hd\n (tl (tl stk))))))) \\<longrightarrow>\n                      \\<not> the_Intg (hd (tl stk)) <s 0 \\<and>\n                      \\<not> int (alen_of_htype\n                                   (the (typeof_addr h\n    (the_Addr (hd (tl (tl stk)))))))\n                             \\<le> sint\n                                    (the_Intg\n(hd (tl stk))) \\<longrightarrow>\n                      addr_of_sys_xcpt ArrayIndexOutOfBounds =\n                      addr_of_sys_xcpt ArrayStore\n 4. \\<And>x141 x142.\n       \\<lbrakk>ins = Invoke x141 x142; stk ! x142 \\<noteq> Null;\n        snd (snd (snd (method P\n                        (class_type_of\n                          (the (typeof_addr h (the_Addr (stk ! x142)))))\n                        x141))) =\n        None;\n        \\<exists>a aa aaa aaaa aaaaa b.\n           ta =\n           (a, map (convert_new_thread_action (extNTA2JVM P)) aa, aaa, aaaa,\n            aaaaa, b) \\<and>\n           (\\<exists>va.\n               (case va of\n                RetVal v \\<Rightarrow>\n                  xcp' = None \\<and>\n                  (stk', loc', C, M, pc') # frs =\n                  (v # drop (Suc x142) stk, loc, C, M, pc + 1) # frs\n                | RetExc a \\<Rightarrow>\n                    xcp' = \\<lfloor>a\\<rfloor> \\<and>\n                    (stk', loc', C, M, pc') # frs =\n                    (stk, loc, C, M, pc) # frs\n                | RetStaySame \\<Rightarrow>\n                    xcp' = None \\<and>\n                    (stk', loc', C, M, pc') # frs =\n                    (stk, loc, C, M, pc) # frs) \\<and>\n               ((a, aa, aaa, aaaa, aaaaa, b), va, h')\n               \\<in> red_external_aggr P t (the_Addr (stk ! x142)) x141\n                      (rev (take x142 stk)) h)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa aaa aaaa aaaaa b.\n                            ta =\n                            (a, map (convert_new_thread_action\n(extNTA2JVM P))\n                                 aa,\n                             aaa, aaaa, aaaaa, b) \\<and>\n                            (\\<exists>va.\n                                (case va of\n                                 RetVal v \\<Rightarrow>\n                                   xcp' = None \\<and>\n                                   (stk', loc', C', M', pc') # frs =\n                                   (v # drop (Suc x142) stk, loc, C', M',\n                                    pc + 1) #\n                                   frs\n                                 | RetExc a \\<Rightarrow>\n                                     xcp' = \\<lfloor>a\\<rfloor> \\<and>\n                                     (stk', loc', C', M', pc') # frs =\n                                     (stk, loc, C', M', pc) # frs\n                                 | RetStaySame \\<Rightarrow>\n                                     xcp' = None \\<and>\n                                     (stk', loc', C', M', pc') # frs =\n                                     (stk, loc, C', M', pc) # frs) \\<and>\n                                ((a, aa, aaa, aaaa, aaaaa, b), va, h')\n                                \\<in> red_external_aggr P t\n (the_Addr (stk ! x142)) x141 (rev (take x142 stk)) h)\n 5. \\<lbrakk>ins = Return;\n     \\<exists>a aa ab ac b ys. frs = (a, aa, ab, ac, b) # ys;\n     ta = \\<lbrace>\\<rbrace> \\<and>\n     xcp' = None \\<and>\n     h' = h \\<and>\n     stk' =\n     hd stk #\n     drop (Suc (length (fst (snd (method P C M))))) (fst (hd frs)) \\<and>\n     loc' = fst (snd (hd frs)) \\<and>\n     C = fst (snd (snd (hd frs))) \\<and>\n     M = fst (snd (snd (snd (hd frs)))) \\<and>\n     pc' = Suc (snd (snd (snd (snd (hd frs))))) \\<and> frs = tl frs\\<rbrakk>\n    \\<Longrightarrow> drop\n                       (Suc (length\n                              (fst (snd (method P (fst (snd (snd (hd frs))))\n    (fst (snd (snd (snd (hd frs))))))))))\n                       (fst (hd frs)) =\n                      drop (Suc (length (fst (snd (method P C' M')))))\n                       (fst (hd frs)) \\<and>\n                      C' = fst (snd (snd (hd frs))) \\<and>\n                      M' = fst (snd (snd (snd (hd frs))))", "apply(force split: extCallRet.split_asm simp add: extRet2JVM_def)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma check_instr_CM_change:\n  \"\\<lbrakk> check_instr ins P h stk loc C M pc frs; ins \\<noteq> Return \\<rbrakk>\n  \\<Longrightarrow> check_instr ins P h stk loc C' M' pc frs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>check_instr ins P h stk loc C M pc frs;\n     ins \\<noteq> Return\\<rbrakk>\n    \\<Longrightarrow> check_instr ins P h stk loc C' M' pc frs", "by(cases ins)(simp_all split: if_split_asm)"], ["", "lemma exec_move_exec_1:\n  assumes exec: \"exec_move ci P t body h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  and sees: \"P \\<turnstile> C sees M : Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\"\n  shows \"exec_1 (compP2 P) t (xcp, h, (stk, loc, C, M, pc) # frs) ta (xcp', h', (stk', loc', C, M, pc') # frs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compP2 P,t \\<turnstile>\n    (xcp, h, (stk, loc, C, M, pc) # frs) -ta-jvm\\<rightarrow>\n    (xcp', h', (stk', loc', C, M, pc') # frs)", "using exec"], ["proof (prove)\nusing this:\n  exec_move ci P t body h (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. compP2 P,t \\<turnstile>\n    (xcp, h, (stk, loc, C, M, pc) # frs) -ta-jvm\\<rightarrow>\n    (xcp', h', (stk', loc', C, M, pc') # frs)", "unfolding exec_move_def"], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 body) (compxE2 body 0 0) t h\n   (stk, loc, pc, xcp) ta h' (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. compP2 P,t \\<turnstile>\n    (xcp, h, (stk, loc, C, M, pc) # frs) -ta-jvm\\<rightarrow>\n    (xcp', h', (stk', loc', C, M, pc') # frs)", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (compE2 body ! pc) (compP2 P) t h stk loc undefined\n            undefined pc [];\n     pc < length (compE2 body);\n     ci_app ci (compE2 body ! pc) (compP2 P) h stk loc undefined undefined\n      pc []\\<rbrakk>\n    \\<Longrightarrow> compP2 P,t \\<turnstile>\n                      (xcp, h,\n                       (stk, loc, C, M, pc) # frs) -ta-jvm\\<rightarrow>\n                      (xcp', h', (stk', loc', C, M, pc') # frs)\n 2. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table (compP2 P) (cname_of h xcpa) pc (compxE2 body 0 0) =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> compP2 P,t \\<turnstile>\n                         (xcp, h,\n                          (stk, loc, C, M, pc) # frs) -ta-jvm\\<rightarrow>\n                         (xcp', h', (stk', loc', C, M, pc') # frs)", "case exec_instr"], ["proof (state)\nthis:\n  xcp = None\n  (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n  \\<in> exec_instr (compE2 body ! pc) (compP2 P) t h stk loc undefined\n         undefined pc []\n  pc < length (compE2 body)\n  ci_app ci (compE2 body ! pc) (compP2 P) h stk loc undefined undefined pc\n   []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (compE2 body ! pc) (compP2 P) t h stk loc undefined\n            undefined pc [];\n     pc < length (compE2 body);\n     ci_app ci (compE2 body ! pc) (compP2 P) h stk loc undefined undefined\n      pc []\\<rbrakk>\n    \\<Longrightarrow> compP2 P,t \\<turnstile>\n                      (xcp, h,\n                       (stk, loc, C, M, pc) # frs) -ta-jvm\\<rightarrow>\n                      (xcp', h', (stk', loc', C, M, pc') # frs)\n 2. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table (compP2 P) (cname_of h xcpa) pc (compxE2 body 0 0) =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> compP2 P,t \\<turnstile>\n                         (xcp, h,\n                          (stk, loc, C, M, pc) # frs) -ta-jvm\\<rightarrow>\n                         (xcp', h', (stk', loc', C, M, pc') # frs)", "note [simp] = \\<open>xcp = None\\<close>\n    and exec = \\<open>(ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n                \\<in> exec_instr (compE2 body ! pc) (compP2 P) t h stk loc undefined undefined pc []\\<close>"], ["proof (state)\nthis:\n  xcp = None\n  (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n  \\<in> exec_instr (compE2 body ! pc) (compP2 P) t h stk loc undefined\n         undefined pc []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (compE2 body ! pc) (compP2 P) t h stk loc undefined\n            undefined pc [];\n     pc < length (compE2 body);\n     ci_app ci (compE2 body ! pc) (compP2 P) h stk loc undefined undefined\n      pc []\\<rbrakk>\n    \\<Longrightarrow> compP2 P,t \\<turnstile>\n                      (xcp, h,\n                       (stk, loc, C, M, pc) # frs) -ta-jvm\\<rightarrow>\n                      (xcp', h', (stk', loc', C, M, pc') # frs)\n 2. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table (compP2 P) (cname_of h xcpa) pc (compxE2 body 0 0) =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> compP2 P,t \\<turnstile>\n                         (xcp, h,\n                          (stk, loc, C, M, pc) # frs) -ta-jvm\\<rightarrow>\n                         (xcp', h', (stk', loc', C, M, pc') # frs)", "from exec"], ["proof (chain)\npicking this:\n  (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n  \\<in> exec_instr (compE2 body ! pc) (compP2 P) t h stk loc undefined\n         undefined pc []", "have \"(ta, xcp', h', [(stk', loc', C, M, pc')])\n                \\<in> exec_instr (compE2 body ! pc) (compP2 P) t h stk loc C M pc []\""], ["proof (prove)\nusing this:\n  (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n  \\<in> exec_instr (compE2 body ! pc) (compP2 P) t h stk loc undefined\n         undefined pc []\n\ngoal (1 subgoal):\n 1. (ta, xcp', h', [(stk', loc', C, M, pc')])\n    \\<in> exec_instr (compE2 body ! pc) (compP2 P) t h stk loc C M pc []", "by(rule exec_instr_CM_change)"], ["proof (state)\nthis:\n  (ta, xcp', h', [(stk', loc', C, M, pc')])\n  \\<in> exec_instr (compE2 body ! pc) (compP2 P) t h stk loc C M pc []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (compE2 body ! pc) (compP2 P) t h stk loc undefined\n            undefined pc [];\n     pc < length (compE2 body);\n     ci_app ci (compE2 body ! pc) (compP2 P) h stk loc undefined undefined\n      pc []\\<rbrakk>\n    \\<Longrightarrow> compP2 P,t \\<turnstile>\n                      (xcp, h,\n                       (stk, loc, C, M, pc) # frs) -ta-jvm\\<rightarrow>\n                      (xcp', h', (stk', loc', C, M, pc') # frs)\n 2. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table (compP2 P) (cname_of h xcpa) pc (compxE2 body 0 0) =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> compP2 P,t \\<turnstile>\n                         (xcp, h,\n                          (stk, loc, C, M, pc) # frs) -ta-jvm\\<rightarrow>\n                         (xcp', h', (stk', loc', C, M, pc') # frs)", "from exec_instr_frs_offer[OF this, of frs]"], ["proof (chain)\npicking this:\n  (ta, xcp', h', (stk', loc', C, M, pc') # [] @ frs)\n  \\<in> exec_instr (compE2 body ! pc) (compP2 P) t h stk loc C M pc\n         ([] @ frs)", "have \"(ta, xcp', h', (stk', loc', C, M, pc') # frs)\n        \\<in> exec_instr (compE2 body ! pc) (compP2 P) t h stk loc C M pc frs\""], ["proof (prove)\nusing this:\n  (ta, xcp', h', (stk', loc', C, M, pc') # [] @ frs)\n  \\<in> exec_instr (compE2 body ! pc) (compP2 P) t h stk loc C M pc\n         ([] @ frs)\n\ngoal (1 subgoal):\n 1. (ta, xcp', h', (stk', loc', C, M, pc') # frs)\n    \\<in> exec_instr (compE2 body ! pc) (compP2 P) t h stk loc C M pc frs", "by simp"], ["proof (state)\nthis:\n  (ta, xcp', h', (stk', loc', C, M, pc') # frs)\n  \\<in> exec_instr (compE2 body ! pc) (compP2 P) t h stk loc C M pc frs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xcp = None;\n     (ta, xcp', h', [(stk', loc', undefined, undefined, pc')])\n     \\<in> exec_instr (compE2 body ! pc) (compP2 P) t h stk loc undefined\n            undefined pc [];\n     pc < length (compE2 body);\n     ci_app ci (compE2 body ! pc) (compP2 P) h stk loc undefined undefined\n      pc []\\<rbrakk>\n    \\<Longrightarrow> compP2 P,t \\<turnstile>\n                      (xcp, h,\n                       (stk, loc, C, M, pc) # frs) -ta-jvm\\<rightarrow>\n                      (xcp', h', (stk', loc', C, M, pc') # frs)\n 2. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table (compP2 P) (cname_of h xcpa) pc (compxE2 body 0 0) =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> compP2 P,t \\<turnstile>\n                         (xcp, h,\n                          (stk, loc, C, M, pc) # frs) -ta-jvm\\<rightarrow>\n                         (xcp', h', (stk', loc', C, M, pc') # frs)", "with sees \\<open>pc < length (compE2 body)\\<close>"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\n  pc < length (compE2 body)\n  (ta, xcp', h', (stk', loc', C, M, pc') # frs)\n  \\<in> exec_instr (compE2 body ! pc) (compP2 P) t h stk loc C M pc frs", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\n  pc < length (compE2 body)\n  (ta, xcp', h', (stk', loc', C, M, pc') # frs)\n  \\<in> exec_instr (compE2 body ! pc) (compP2 P) t h stk loc C M pc frs\n\ngoal (1 subgoal):\n 1. compP2 P,t \\<turnstile>\n    (xcp, h, (stk, loc, C, M, pc) # frs) -ta-jvm\\<rightarrow>\n    (xcp', h', (stk', loc', C, M, pc') # frs)", "by(simp add: exec_1_iff compP2_def compMb2_def nth_append)"], ["proof (state)\nthis:\n  compP2 P,t \\<turnstile>\n  (xcp, h, (stk, loc, C, M, pc) # frs) -ta-jvm\\<rightarrow>\n  (xcp', h', (stk', loc', C, M, pc') # frs)\n\ngoal (1 subgoal):\n 1. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table (compP2 P) (cname_of h xcpa) pc (compxE2 body 0 0) =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> compP2 P,t \\<turnstile>\n                         (xcp, h,\n                          (stk, loc, C, M, pc) # frs) -ta-jvm\\<rightarrow>\n                         (xcp', h', (stk', loc', C, M, pc') # frs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table (compP2 P) (cname_of h xcpa) pc (compxE2 body 0 0) =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> compP2 P,t \\<turnstile>\n                         (xcp, h,\n                          (stk, loc, C, M, pc) # frs) -ta-jvm\\<rightarrow>\n                         (xcp', h', (stk', loc', C, M, pc') # frs)", "case exec_catch"], ["proof (state)\nthis:\n  xcp = \\<lfloor>xcp_\\<rfloor>\n  ta = \\<lbrace>\\<rbrace>\n  h' = h\n  stk' = Addr xcp_ # drop (length stk - d_) stk\n  loc' = loc\n  xcp' = None\n  match_ex_table (compP2 P) (cname_of h xcp_) pc (compxE2 body 0 0) =\n  \\<lfloor>(pc', d_)\\<rfloor>\n  d_ \\<le> length stk\n\ngoal (1 subgoal):\n 1. \\<And>xcpa d.\n       \\<lbrakk>xcp = \\<lfloor>xcpa\\<rfloor>; ta = \\<lbrace>\\<rbrace>;\n        h' = h; stk' = Addr xcpa # drop (length stk - d) stk; loc' = loc;\n        xcp' = None;\n        match_ex_table (compP2 P) (cname_of h xcpa) pc (compxE2 body 0 0) =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stk\\<rbrakk>\n       \\<Longrightarrow> compP2 P,t \\<turnstile>\n                         (xcp, h,\n                          (stk, loc, C, M, pc) # frs) -ta-jvm\\<rightarrow>\n                         (xcp', h', (stk', loc', C, M, pc') # frs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  xcp = \\<lfloor>xcp_\\<rfloor>\n  ta = \\<lbrace>\\<rbrace>\n  h' = h\n  stk' = Addr xcp_ # drop (length stk - d_) stk\n  loc' = loc\n  xcp' = None\n  match_ex_table (compP2 P) (cname_of h xcp_) pc (compxE2 body 0 0) =\n  \\<lfloor>(pc', d_)\\<rfloor>\n  d_ \\<le> length stk\n\ngoal (1 subgoal):\n 1. compP2 P,t \\<turnstile>\n    (xcp, h, (stk, loc, C, M, pc) # frs) -ta-jvm\\<rightarrow>\n    (xcp', h', (stk', loc', C, M, pc') # frs)", "using sees_method_compP[OF sees, of \"\\<lambda>C M Ts T. compMb2\"]"], ["proof (prove)\nusing this:\n  xcp = \\<lfloor>xcp_\\<rfloor>\n  ta = \\<lbrace>\\<rbrace>\n  h' = h\n  stk' = Addr xcp_ # drop (length stk - d_) stk\n  loc' = loc\n  xcp' = None\n  match_ex_table (compP2 P) (cname_of h xcp_) pc (compxE2 body 0 0) =\n  \\<lfloor>(pc', d_)\\<rfloor>\n  d_ \\<le> length stk\n  compP (\\<lambda>C M Ts T. compMb2)\n   P \\<turnstile> C sees M: Ts\\<rightarrow>T = map_option compMb2\n          \\<lfloor>body\\<rfloor> in D\n\ngoal (1 subgoal):\n 1. compP2 P,t \\<turnstile>\n    (xcp, h, (stk, loc, C, M, pc) # frs) -ta-jvm\\<rightarrow>\n    (xcp', h', (stk', loc', C, M, pc') # frs)", "by(simp add: exec_1_iff compMb2_def compP2_def)"], ["proof (state)\nthis:\n  compP2 P,t \\<turnstile>\n  (xcp, h, (stk, loc, C, M, pc) # frs) -ta-jvm\\<rightarrow>\n  (xcp', h', (stk', loc', C, M, pc') # frs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<tau>exec_move_\\<tau>exec_1:\n  assumes exec: \"\\<tau>exec_move ci P t body h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\"\n  and sees: \"P \\<turnstile> C sees M : Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\"\n  shows \"\\<tau>exec_1 (compP2 P) t (xcp, h, (stk, loc, C, M, pc) # frs) (xcp', h, (stk', loc', C, M, pc') # frs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>exec_1 (compP2 P) t (xcp, h, (stk, loc, C, M, pc) # frs)\n     (xcp', h, (stk', loc', C, M, pc') # frs)", "proof(rule \\<tau>exec_1I)"], ["proof (state)\ngoal (2 subgoals):\n 1. compP2 P,t \\<turnstile>\n    (xcp, h,\n     (stk, loc, C, M, pc) # frs) -\\<lbrace>\\<rbrace>-jvm\\<rightarrow>\n    (xcp', h, (stk', loc', C, M, pc') # frs)\n 2. \\<tau>Move2 (compP2 P) (xcp, h, (stk, loc, C, M, pc) # frs)", "from exec"], ["proof (chain)\npicking this:\n  \\<tau>exec_move ci P t body h (stk, loc, pc, xcp) (stk', loc', pc', xcp')", "obtain exec': \"exec_move ci P t body h (stk, loc, pc, xcp) \\<epsilon> h (stk', loc', pc', xcp')\"\n    and \\<tau>: \"\\<tau>move2 P h stk body pc xcp\""], ["proof (prove)\nusing this:\n  \\<tau>exec_move ci P t body h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>exec_move ci P t body h (stk, loc, pc, xcp) \\<lbrace>\\<rbrace>\n               h (stk', loc', pc', xcp');\n      \\<tau>move2 P h stk body pc xcp\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule \\<tau>exec_moveE)"], ["proof (state)\nthis:\n  exec_move ci P t body h (stk, loc, pc, xcp) \\<lbrace>\\<rbrace> h\n   (stk', loc', pc', xcp')\n  \\<tau>move2 P h stk body pc xcp\n\ngoal (2 subgoals):\n 1. compP2 P,t \\<turnstile>\n    (xcp, h,\n     (stk, loc, C, M, pc) # frs) -\\<lbrace>\\<rbrace>-jvm\\<rightarrow>\n    (xcp', h, (stk', loc', C, M, pc') # frs)\n 2. \\<tau>Move2 (compP2 P) (xcp, h, (stk, loc, C, M, pc) # frs)", "have \"exec_1 (compP2 P) t (xcp, h, (stk, loc, C, M, pc) # frs) \\<epsilon> (xcp', h, (stk', loc', C, M, pc') # frs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compP2 P,t \\<turnstile>\n    (xcp, h,\n     (stk, loc, C, M, pc) # frs) -\\<lbrace>\\<rbrace>-jvm\\<rightarrow>\n    (xcp', h, (stk', loc', C, M, pc') # frs)", "using exec' sees"], ["proof (prove)\nusing this:\n  exec_move ci P t body h (stk, loc, pc, xcp) \\<lbrace>\\<rbrace> h\n   (stk', loc', pc', xcp')\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\n\ngoal (1 subgoal):\n 1. compP2 P,t \\<turnstile>\n    (xcp, h,\n     (stk, loc, C, M, pc) # frs) -\\<lbrace>\\<rbrace>-jvm\\<rightarrow>\n    (xcp', h, (stk', loc', C, M, pc') # frs)", "by(rule exec_move_exec_1)"], ["proof (state)\nthis:\n  compP2 P,t \\<turnstile>\n  (xcp, h, (stk, loc, C, M, pc) # frs) -\\<lbrace>\\<rbrace>-jvm\\<rightarrow>\n  (xcp', h, (stk', loc', C, M, pc') # frs)\n\ngoal (2 subgoals):\n 1. compP2 P,t \\<turnstile>\n    (xcp, h,\n     (stk, loc, C, M, pc) # frs) -\\<lbrace>\\<rbrace>-jvm\\<rightarrow>\n    (xcp', h, (stk', loc', C, M, pc') # frs)\n 2. \\<tau>Move2 (compP2 P) (xcp, h, (stk, loc, C, M, pc) # frs)", "thus \"compP2 P,t \\<turnstile> (xcp, h, (stk, loc, C, M, pc) # frs) -\\<epsilon>-jvm\\<rightarrow> (xcp', h, (stk', loc', C, M, pc') # frs)\""], ["proof (prove)\nusing this:\n  compP2 P,t \\<turnstile>\n  (xcp, h, (stk, loc, C, M, pc) # frs) -\\<lbrace>\\<rbrace>-jvm\\<rightarrow>\n  (xcp', h, (stk', loc', C, M, pc') # frs)\n\ngoal (1 subgoal):\n 1. compP2 P,t \\<turnstile>\n    (xcp, h,\n     (stk, loc, C, M, pc) # frs) -\\<lbrace>\\<rbrace>-jvm\\<rightarrow>\n    (xcp', h, (stk', loc', C, M, pc') # frs)", "by auto"], ["proof (state)\nthis:\n  compP2 P,t \\<turnstile>\n  (xcp, h, (stk, loc, C, M, pc) # frs) -\\<lbrace>\\<rbrace>-jvm\\<rightarrow>\n  (xcp', h, (stk', loc', C, M, pc') # frs)\n\ngoal (1 subgoal):\n 1. \\<tau>Move2 (compP2 P) (xcp, h, (stk, loc, C, M, pc) # frs)", "{"], ["proof (state)\nthis:\n  compP2 P,t \\<turnstile>\n  (xcp, h, (stk, loc, C, M, pc) # frs) -\\<lbrace>\\<rbrace>-jvm\\<rightarrow>\n  (xcp', h, (stk', loc', C, M, pc') # frs)\n\ngoal (1 subgoal):\n 1. \\<tau>Move2 (compP2 P) (xcp, h, (stk, loc, C, M, pc) # frs)", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<tau>Move2 (compP2 P) (xcp, h, (stk, loc, C, M, pc) # frs)", "assume [simp]: \"xcp = \\<lfloor>a\\<rfloor>\""], ["proof (state)\nthis:\n  xcp = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<tau>Move2 (compP2 P) (xcp, h, (stk, loc, C, M, pc) # frs)", "from sees_method_compP[OF sees, of \"\\<lambda>C M Ts T. compMb2\"]"], ["proof (chain)\npicking this:\n  compP (\\<lambda>C M Ts T. compMb2)\n   P \\<turnstile> C sees M: Ts\\<rightarrow>T = map_option compMb2\n          \\<lfloor>body\\<rfloor> in D", "have \"ex_table_of (compP2 P) C M = compxE2 body 0 0\""], ["proof (prove)\nusing this:\n  compP (\\<lambda>C M Ts T. compMb2)\n   P \\<turnstile> C sees M: Ts\\<rightarrow>T = map_option compMb2\n          \\<lfloor>body\\<rfloor> in D\n\ngoal (1 subgoal):\n 1. ex_table_of (compP2 P) C M = compxE2 body 0 0", "by(simp add: compP2_def compMb2_def)"], ["proof (state)\nthis:\n  ex_table_of (compP2 P) C M = compxE2 body 0 0\n\ngoal (1 subgoal):\n 1. \\<tau>Move2 (compP2 P) (xcp, h, (stk, loc, C, M, pc) # frs)", "hence \"match_ex_table (compP2 P) (cname_of h a) pc (ex_table_of (compP2 P) C M) \\<noteq> None\" \"pc < length (compE2 body)\""], ["proof (prove)\nusing this:\n  ex_table_of (compP2 P) C M = compxE2 body 0 0\n\ngoal (1 subgoal):\n 1. match_ex_table (compP2 P) (cname_of h a) pc\n     (ex_table_of (compP2 P) C M) \\<noteq>\n    None &&&\n    pc < length (compE2 body)", "using exec' sees"], ["proof (prove)\nusing this:\n  ex_table_of (compP2 P) C M = compxE2 body 0 0\n  exec_move ci P t body h (stk, loc, pc, xcp) \\<lbrace>\\<rbrace> h\n   (stk', loc', pc', xcp')\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\n\ngoal (1 subgoal):\n 1. match_ex_table (compP2 P) (cname_of h a) pc\n     (ex_table_of (compP2 P) C M) \\<noteq>\n    None &&&\n    pc < length (compE2 body)", "by(auto simp add: exec_move_def elim: exec_meth.cases)"], ["proof (state)\nthis:\n  match_ex_table (compP2 P) (cname_of h a) pc\n   (ex_table_of (compP2 P) C M) \\<noteq>\n  None\n  pc < length (compE2 body)\n\ngoal (1 subgoal):\n 1. \\<tau>Move2 (compP2 P) (xcp, h, (stk, loc, C, M, pc) # frs)", "}"], ["proof (state)\nthis:\n  xcp = \\<lfloor>?a22\\<rfloor> \\<Longrightarrow>\n  match_ex_table (compP2 P) (cname_of h ?a22) pc\n   (ex_table_of (compP2 P) C M) \\<noteq>\n  None\n  xcp = \\<lfloor>?a22\\<rfloor> \\<Longrightarrow> pc < length (compE2 body)\n\ngoal (1 subgoal):\n 1. \\<tau>Move2 (compP2 P) (xcp, h, (stk, loc, C, M, pc) # frs)", "with \\<tau> sees sees_method_compP[OF sees, of \"\\<lambda>C M Ts T. compMb2\"]"], ["proof (chain)\npicking this:\n  \\<tau>move2 P h stk body pc xcp\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\n  compP (\\<lambda>C M Ts T. compMb2)\n   P \\<turnstile> C sees M: Ts\\<rightarrow>T = map_option compMb2\n          \\<lfloor>body\\<rfloor> in D\n  xcp = \\<lfloor>?a22\\<rfloor> \\<Longrightarrow>\n  match_ex_table (compP2 P) (cname_of h ?a22) pc\n   (ex_table_of (compP2 P) C M) \\<noteq>\n  None\n  xcp = \\<lfloor>?a22\\<rfloor> \\<Longrightarrow> pc < length (compE2 body)", "show \"\\<tau>Move2 (compP2 P) (xcp, h, (stk, loc, C, M, pc) # frs)\""], ["proof (prove)\nusing this:\n  \\<tau>move2 P h stk body pc xcp\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\n  compP (\\<lambda>C M Ts T. compMb2)\n   P \\<turnstile> C sees M: Ts\\<rightarrow>T = map_option compMb2\n          \\<lfloor>body\\<rfloor> in D\n  xcp = \\<lfloor>?a22\\<rfloor> \\<Longrightarrow>\n  match_ex_table (compP2 P) (cname_of h ?a22) pc\n   (ex_table_of (compP2 P) C M) \\<noteq>\n  None\n  xcp = \\<lfloor>?a22\\<rfloor> \\<Longrightarrow> pc < length (compE2 body)\n\ngoal (1 subgoal):\n 1. \\<tau>Move2 (compP2 P) (xcp, h, (stk, loc, C, M, pc) # frs)", "unfolding \\<tau>Move2_compP2[OF sees]"], ["proof (prove)\nusing this:\n  \\<tau>move2 P h stk body pc xcp\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\n  compP (\\<lambda>C M Ts T. compMb2)\n   P \\<turnstile> C sees M: Ts\\<rightarrow>T = map_option compMb2\n          \\<lfloor>body\\<rfloor> in D\n  xcp = \\<lfloor>?a22\\<rfloor> \\<Longrightarrow>\n  match_ex_table (compP2 P) (cname_of h ?a22) pc\n   (ex_table_of (compP2 P) C M) \\<noteq>\n  None\n  xcp = \\<lfloor>?a22\\<rfloor> \\<Longrightarrow> pc < length (compE2 body)\n\ngoal (1 subgoal):\n 1. case xcp of\n    None \\<Rightarrow>\n      \\<tau>move2 P h stk body pc xcp \\<or> pc = length (compE2 body)\n    | \\<lfloor>a\\<rfloor> \\<Rightarrow> pc < Suc (length (compE2 body))", "by(fastforce simp add: compP2_def compMb2_def)"], ["proof (state)\nthis:\n  \\<tau>Move2 (compP2 P) (xcp, h, (stk, loc, C, M, pc) # frs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<tau>Exec_mover_\\<tau>Exec_1r:\n  assumes move: \"\\<tau>Exec_mover ci P t body h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\"\n  and sees: \"P \\<turnstile> C sees M : Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\"\n  shows \"\\<tau>Exec_1r (compP2 P) t (xcp, h, (stk, loc, C, M, pc) # frs') (xcp', h, (stk', loc', C, M, pc') # frs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_1r (compP2 P) t (xcp, h, (stk, loc, C, M, pc) # frs')\n     (xcp', h, (stk', loc', C, M, pc') # frs')", "using move"], ["proof (prove)\nusing this:\n  \\<tau>Exec_mover ci P t body h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. \\<tau>Exec_1r (compP2 P) t (xcp, h, (stk, loc, C, M, pc) # frs')\n     (xcp', h, (stk', loc', C, M, pc') # frs')", "by(induct rule: \\<tau>Execr_induct)(blast intro: rtranclp.rtrancl_into_rtrancl \\<tau>exec_move_\\<tau>exec_1[OF _ sees])+"], ["", "lemma \\<tau>Exec_movet_\\<tau>Exec_1t:\n  assumes move: \"\\<tau>Exec_movet ci P t body h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\"\n  and sees: \"P \\<turnstile> C sees M : Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D\"\n  shows \"\\<tau>Exec_1t (compP2 P) t (xcp, h, (stk, loc, C, M, pc) # frs') (xcp', h, (stk', loc', C, M, pc') # frs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_1t (compP2 P) t (xcp, h, (stk, loc, C, M, pc) # frs')\n     (xcp', h, (stk', loc', C, M, pc') # frs')", "using move"], ["proof (prove)\nusing this:\n  \\<tau>Exec_movet ci P t body h (stk, loc, pc, xcp) (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. \\<tau>Exec_1t (compP2 P) t (xcp, h, (stk, loc, C, M, pc) # frs')\n     (xcp', h, (stk', loc', C, M, pc') # frs')", "by(induct rule: \\<tau>Exect_induct)(blast intro: tranclp.trancl_into_trancl \\<tau>exec_move_\\<tau>exec_1[OF _ sees])+"], ["", "lemma \\<tau>Exec_1r_rtranclpD:\n  \"\\<tau>Exec_1r P t (xcp, h, frs) (xcp', h', frs')\n  \\<Longrightarrow> (\\<lambda>((xcp, frs), h) ((xcp', frs'), h'). exec_1 P t (xcp, h, frs) \\<epsilon> (xcp', h', frs') \\<and> \\<tau>Move2 P (xcp, h, frs))^** ((xcp, frs), h) ((xcp', frs'), h')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_1r P t (xcp, h, frs) (xcp', h', frs') \\<Longrightarrow>\n    (\\<lambda>((xcp, frs), h) ((xcp', frs'), h').\n        P,t \\<turnstile> (xcp, h, frs) -\\<lbrace>\\<rbrace>-jvm\\<rightarrow>\n        (xcp', h', frs') \\<and> \\<tau>Move2 P (xcp, h, frs))\\<^sup>*\\<^sup>*\n     ((xcp, frs), h) ((xcp', frs'), h')", "by(induct rule: rtranclp_induct3)(fastforce intro: rtranclp.rtrancl_into_rtrancl)+"], ["", "lemma \\<tau>Exec_1t_rtranclpD:\n  \"\\<tau>Exec_1t P t (xcp, h, frs) (xcp', h', frs')\n  \\<Longrightarrow> (\\<lambda>((xcp, frs), h) ((xcp', frs'), h'). exec_1 P t (xcp, h, frs) \\<epsilon> (xcp', h', frs') \\<and> \\<tau>Move2 P (xcp, h, frs))^++ ((xcp, frs), h) ((xcp', frs'), h')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Exec_1t P t (xcp, h, frs) (xcp', h', frs') \\<Longrightarrow>\n    (\\<lambda>((xcp, frs), h) ((xcp', frs'), h').\n        P,t \\<turnstile> (xcp, h, frs) -\\<lbrace>\\<rbrace>-jvm\\<rightarrow>\n        (xcp', h', frs') \\<and> \\<tau>Move2 P (xcp, h, frs))\\<^sup>+\\<^sup>+\n     ((xcp, frs), h) ((xcp', frs'), h')", "by(induct rule: tranclp_induct3)(fastforce intro: tranclp.trancl_into_trancl)+"], ["", "lemma exec_meth_length_compE2_stack_xliftD:\n  \"exec_meth ci P (compE2 e) (stack_xlift d (compxE2 e 0 0)) t h (stk, loc, pc, xcp) ta h' s'\n  \\<Longrightarrow> pc < length (compE2 e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci P (compE2 e) (stack_xlift d (compxE2 e 0 0)) t h\n     (stk, loc, pc, xcp) ta h' s' \\<Longrightarrow>\n    pc < length (compE2 e)", "by(cases s')(auto simp add: stack_xlift_compxE2)"], ["", "lemma exec_meth_length_pc_xt_Nil:\n  \"exec_meth ci P ins [] t h (stk, loc, pc, xcp) ta h' s' \\<Longrightarrow> pc < length ins\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci P ins [] t h (stk, loc, pc, xcp) ta h' s' \\<Longrightarrow>\n    pc < length ins", "apply(erule exec_meth.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>taa xcpa h'a stk' loc' pc' pca ha stka loca.\n       \\<lbrakk>h = ha; (stk, loc, pc, xcp) = (stka, loca, pca, None);\n        ta = taa; h' = h'a; s' = (stk', loc', pc', xcpa);\n        (taa, xcpa, h'a, [(stk', loc', undefined, undefined, pc')])\n        \\<in> exec_instr (ins ! pca) P t ha stka loca undefined undefined\n               pca [];\n        pca < length ins;\n        ci_app ci (ins ! pca) P ha stka loca undefined undefined pca\n         []\\<rbrakk>\n       \\<Longrightarrow> pc < length ins\n 2. \\<And>ha xcpa pca pc' d stka loca.\n       \\<lbrakk>h = ha;\n        (stk, loc, pc, xcp) = (stka, loca, pca, \\<lfloor>xcpa\\<rfloor>);\n        ta = \\<lbrace>\\<rbrace>; h' = ha;\n        s' = (Addr xcpa # drop (length stka - d) stka, loca, pc', None);\n        match_ex_table P (cname_of ha xcpa) pca [] =\n        \\<lfloor>(pc', d)\\<rfloor>;\n        d \\<le> length stka\\<rbrakk>\n       \\<Longrightarrow> pc < length ins", "apply(auto dest: match_ex_table_pc_length_compE2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma BinOp_exec2D:\n  assumes exec: \"exec_meth ci (compP2 P) (compE2 (e1 \\<guillemotleft>bop\\<guillemotright> e2)) (compxE2 (e1 \\<guillemotleft>bop\\<guillemotright> e2) 0 0) t h (stk @ [v1], loc, length (compE2 e1) + pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  and pc: \"pc < length (compE2 e2)\"\n  shows \"exec_meth ci (compP2 P) (compE2 e2) (stack_xlift (length [v1]) (compxE2 e2 0 0)) t h (stk @ [v1], loc, pc, xcp) ta h' (stk', loc', pc' - length (compE2 e1), xcp') \\<and> pc' \\<ge> length (compE2 e1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e2)\n     (stack_xlift (length [v1]) (compxE2 e2 0 0)) t h\n     (stk @ [v1], loc, pc, xcp) ta h'\n     (stk', loc', pc' - length (compE2 e1), xcp') \\<and>\n    length (compE2 e1) \\<le> pc'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. exec_meth ci (compP2 P) (compE2 e2)\n     (stack_xlift (length [v1]) (compxE2 e2 0 0)) t h\n     (stk @ [v1], loc, pc, xcp) ta h'\n     (stk', loc', pc' - length (compE2 e1), xcp')\n 2. length (compE2 e1) \\<le> pc'", "from exec"], ["proof (chain)\npicking this:\n  exec_meth ci (compP2 P)\n   (compE2 (e1 \\<guillemotleft>bop\\<guillemotright> e2))\n   (compxE2 (e1 \\<guillemotleft>bop\\<guillemotright> e2) 0 0) t h\n   (stk @ [v1], loc, length (compE2 e1) + pc, xcp) ta h'\n   (stk', loc', pc', xcp')", "have \"exec_meth ci (compP2 P) ((compE2 e1 @ compE2 e2) @ [BinOpInstr bop])\n     (compxE2 e1 0 0 @ shift (length (compE2 e1)) (stack_xlift (length [v1]) (compxE2 e2 0 0))) t h\n     (stk @ [v1], loc, length (compE2 e1) + pc, xcp) ta h' (stk', loc', pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P)\n   (compE2 (e1 \\<guillemotleft>bop\\<guillemotright> e2))\n   (compxE2 (e1 \\<guillemotleft>bop\\<guillemotright> e2) 0 0) t h\n   (stk @ [v1], loc, length (compE2 e1) + pc, xcp) ta h'\n   (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) ((compE2 e1 @ compE2 e2) @ [BinOpInstr bop])\n     (compxE2 e1 0 0 @\n      shift (length (compE2 e1))\n       (stack_xlift (length [v1]) (compxE2 e2 0 0)))\n     t h (stk @ [v1], loc, length (compE2 e1) + pc, xcp) ta h'\n     (stk', loc', pc', xcp')", "by(simp add: compxE2_size_convs compxE2_stack_xlift_convs)"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) ((compE2 e1 @ compE2 e2) @ [BinOpInstr bop])\n   (compxE2 e1 0 0 @\n    shift (length (compE2 e1)) (stack_xlift (length [v1]) (compxE2 e2 0 0)))\n   t h (stk @ [v1], loc, length (compE2 e1) + pc, xcp) ta h'\n   (stk', loc', pc', xcp')\n\ngoal (2 subgoals):\n 1. exec_meth ci (compP2 P) (compE2 e2)\n     (stack_xlift (length [v1]) (compxE2 e2 0 0)) t h\n     (stk @ [v1], loc, pc, xcp) ta h'\n     (stk', loc', pc' - length (compE2 e1), xcp')\n 2. length (compE2 e1) \\<le> pc'", "hence exec': \"exec_meth ci (compP2 P) (compE2 e1 @ compE2 e2) (compxE2 e1 0 0 @ shift (length (compE2 e1)) (stack_xlift (length [v1]) (compxE2 e2 0 0))) t h\n     (stk @ [v1], loc, length (compE2 e1) + pc, xcp) ta h' (stk', loc', pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) ((compE2 e1 @ compE2 e2) @ [BinOpInstr bop])\n   (compxE2 e1 0 0 @\n    shift (length (compE2 e1)) (stack_xlift (length [v1]) (compxE2 e2 0 0)))\n   t h (stk @ [v1], loc, length (compE2 e1) + pc, xcp) ta h'\n   (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e1 @ compE2 e2)\n     (compxE2 e1 0 0 @\n      shift (length (compE2 e1))\n       (stack_xlift (length [v1]) (compxE2 e2 0 0)))\n     t h (stk @ [v1], loc, length (compE2 e1) + pc, xcp) ta h'\n     (stk', loc', pc', xcp')", "by(rule exec_meth_take) (simp add: pc)"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) (compE2 e1 @ compE2 e2)\n   (compxE2 e1 0 0 @\n    shift (length (compE2 e1)) (stack_xlift (length [v1]) (compxE2 e2 0 0)))\n   t h (stk @ [v1], loc, length (compE2 e1) + pc, xcp) ta h'\n   (stk', loc', pc', xcp')\n\ngoal (2 subgoals):\n 1. exec_meth ci (compP2 P) (compE2 e2)\n     (stack_xlift (length [v1]) (compxE2 e2 0 0)) t h\n     (stk @ [v1], loc, pc, xcp) ta h'\n     (stk', loc', pc' - length (compE2 e1), xcp')\n 2. length (compE2 e1) \\<le> pc'", "thus \"exec_meth ci (compP2 P) (compE2 e2) (stack_xlift (length [v1]) (compxE2 e2 0 0)) t h\n     (stk @ [v1], loc, pc, xcp) ta h' (stk', loc', pc' - length (compE2 e1), xcp')\""], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e1 @ compE2 e2)\n   (compxE2 e1 0 0 @\n    shift (length (compE2 e1)) (stack_xlift (length [v1]) (compxE2 e2 0 0)))\n   t h (stk @ [v1], loc, length (compE2 e1) + pc, xcp) ta h'\n   (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 e2)\n     (stack_xlift (length [v1]) (compxE2 e2 0 0)) t h\n     (stk @ [v1], loc, pc, xcp) ta h'\n     (stk', loc', pc' - length (compE2 e1), xcp')", "by(rule exec_meth_drop_xt) auto"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) (compE2 e2)\n   (stack_xlift (length [v1]) (compxE2 e2 0 0)) t h\n   (stk @ [v1], loc, pc, xcp) ta h'\n   (stk', loc', pc' - length (compE2 e1), xcp')\n\ngoal (1 subgoal):\n 1. length (compE2 e1) \\<le> pc'", "from exec'"], ["proof (chain)\npicking this:\n  exec_meth ci (compP2 P) (compE2 e1 @ compE2 e2)\n   (compxE2 e1 0 0 @\n    shift (length (compE2 e1)) (stack_xlift (length [v1]) (compxE2 e2 0 0)))\n   t h (stk @ [v1], loc, length (compE2 e1) + pc, xcp) ta h'\n   (stk', loc', pc', xcp')", "show \"pc' \\<ge> length (compE2 e1)\""], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 e1 @ compE2 e2)\n   (compxE2 e1 0 0 @\n    shift (length (compE2 e1)) (stack_xlift (length [v1]) (compxE2 e2 0 0)))\n   t h (stk @ [v1], loc, length (compE2 e1) + pc, xcp) ta h'\n   (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. length (compE2 e1) \\<le> pc'", "by(rule exec_meth_drop_xt_pc)(auto)"], ["proof (state)\nthis:\n  length (compE2 e1) \\<le> pc'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Call_execParamD:\n  assumes exec: \"exec_meth ci (compP2 P) (compE2 (obj\\<bullet>M'(ps))) (compxE2 (obj\\<bullet>M'(ps)) 0 0) t h (stk @ [v], loc, length (compE2 obj) + pc, xcp) ta h' (stk', loc', pc', xcp')\"\n  and pc: \"pc < length (compEs2 ps)\"\n  shows \"exec_meth ci (compP2 P) (compEs2 ps) (stack_xlift (length [v]) (compxEs2 ps 0 0)) t h (stk @ [v], loc, pc, xcp) ta h' (stk', loc', pc' - length (compE2 obj), xcp') \\<and> pc' \\<ge> length (compE2 obj)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compEs2 ps)\n     (stack_xlift (length [v]) (compxEs2 ps 0 0)) t h\n     (stk @ [v], loc, pc, xcp) ta h'\n     (stk', loc', pc' - length (compE2 obj), xcp') \\<and>\n    length (compE2 obj) \\<le> pc'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. exec_meth ci (compP2 P) (compEs2 ps)\n     (stack_xlift (length [v]) (compxEs2 ps 0 0)) t h\n     (stk @ [v], loc, pc, xcp) ta h'\n     (stk', loc', pc' - length (compE2 obj), xcp')\n 2. length (compE2 obj) \\<le> pc'", "from exec"], ["proof (chain)\npicking this:\n  exec_meth ci (compP2 P) (compE2 (obj\\<bullet>M'(ps)))\n   (compxE2 (obj\\<bullet>M'(ps)) 0 0) t h\n   (stk @ [v], loc, length (compE2 obj) + pc, xcp) ta h'\n   (stk', loc', pc', xcp')", "have \"exec_meth ci (compP2 P) ((compE2 obj @ compEs2 ps) @ [Invoke M' (length ps)])\n     (compxE2 obj 0 0 @ shift (length (compE2 obj)) (stack_xlift (length [v]) (compxEs2 ps 0 0))) t h\n     (stk @ [v], loc, length (compE2 obj) + pc, xcp) ta h' (stk', loc', pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 (obj\\<bullet>M'(ps)))\n   (compxE2 (obj\\<bullet>M'(ps)) 0 0) t h\n   (stk @ [v], loc, length (compE2 obj) + pc, xcp) ta h'\n   (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P)\n     ((compE2 obj @ compEs2 ps) @ [Invoke M' (length ps)])\n     (compxE2 obj 0 0 @\n      shift (length (compE2 obj))\n       (stack_xlift (length [v]) (compxEs2 ps 0 0)))\n     t h (stk @ [v], loc, length (compE2 obj) + pc, xcp) ta h'\n     (stk', loc', pc', xcp')", "by(simp add: compxEs2_size_convs compxEs2_stack_xlift_convs)"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P)\n   ((compE2 obj @ compEs2 ps) @ [Invoke M' (length ps)])\n   (compxE2 obj 0 0 @\n    shift (length (compE2 obj))\n     (stack_xlift (length [v]) (compxEs2 ps 0 0)))\n   t h (stk @ [v], loc, length (compE2 obj) + pc, xcp) ta h'\n   (stk', loc', pc', xcp')\n\ngoal (2 subgoals):\n 1. exec_meth ci (compP2 P) (compEs2 ps)\n     (stack_xlift (length [v]) (compxEs2 ps 0 0)) t h\n     (stk @ [v], loc, pc, xcp) ta h'\n     (stk', loc', pc' - length (compE2 obj), xcp')\n 2. length (compE2 obj) \\<le> pc'", "hence exec': \"exec_meth ci (compP2 P) (compE2 obj @ compEs2 ps) (compxE2 obj 0 0 @ shift (length (compE2 obj)) (stack_xlift (length [v]) (compxEs2 ps 0 0))) t h\n     (stk @ [v], loc, length (compE2 obj) + pc, xcp) ta h' (stk', loc', pc', xcp')\""], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P)\n   ((compE2 obj @ compEs2 ps) @ [Invoke M' (length ps)])\n   (compxE2 obj 0 0 @\n    shift (length (compE2 obj))\n     (stack_xlift (length [v]) (compxEs2 ps 0 0)))\n   t h (stk @ [v], loc, length (compE2 obj) + pc, xcp) ta h'\n   (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 obj @ compEs2 ps)\n     (compxE2 obj 0 0 @\n      shift (length (compE2 obj))\n       (stack_xlift (length [v]) (compxEs2 ps 0 0)))\n     t h (stk @ [v], loc, length (compE2 obj) + pc, xcp) ta h'\n     (stk', loc', pc', xcp')", "by(rule exec_meth_take)(simp add: pc)"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) (compE2 obj @ compEs2 ps)\n   (compxE2 obj 0 0 @\n    shift (length (compE2 obj))\n     (stack_xlift (length [v]) (compxEs2 ps 0 0)))\n   t h (stk @ [v], loc, length (compE2 obj) + pc, xcp) ta h'\n   (stk', loc', pc', xcp')\n\ngoal (2 subgoals):\n 1. exec_meth ci (compP2 P) (compEs2 ps)\n     (stack_xlift (length [v]) (compxEs2 ps 0 0)) t h\n     (stk @ [v], loc, pc, xcp) ta h'\n     (stk', loc', pc' - length (compE2 obj), xcp')\n 2. length (compE2 obj) \\<le> pc'", "thus \"exec_meth ci (compP2 P) (compEs2 ps) (stack_xlift (length [v]) (compxEs2 ps 0 0)) t h (stk @ [v], loc, pc, xcp) ta h' (stk', loc', pc' - length (compE2 obj), xcp')\""], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 obj @ compEs2 ps)\n   (compxE2 obj 0 0 @\n    shift (length (compE2 obj))\n     (stack_xlift (length [v]) (compxEs2 ps 0 0)))\n   t h (stk @ [v], loc, length (compE2 obj) + pc, xcp) ta h'\n   (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compEs2 ps)\n     (stack_xlift (length [v]) (compxEs2 ps 0 0)) t h\n     (stk @ [v], loc, pc, xcp) ta h'\n     (stk', loc', pc' - length (compE2 obj), xcp')", "by(rule exec_meth_drop_xt) auto"], ["proof (state)\nthis:\n  exec_meth ci (compP2 P) (compEs2 ps)\n   (stack_xlift (length [v]) (compxEs2 ps 0 0)) t h\n   (stk @ [v], loc, pc, xcp) ta h'\n   (stk', loc', pc' - length (compE2 obj), xcp')\n\ngoal (1 subgoal):\n 1. length (compE2 obj) \\<le> pc'", "from exec'"], ["proof (chain)\npicking this:\n  exec_meth ci (compP2 P) (compE2 obj @ compEs2 ps)\n   (compxE2 obj 0 0 @\n    shift (length (compE2 obj))\n     (stack_xlift (length [v]) (compxEs2 ps 0 0)))\n   t h (stk @ [v], loc, length (compE2 obj) + pc, xcp) ta h'\n   (stk', loc', pc', xcp')", "show \"pc' \\<ge> length (compE2 obj)\""], ["proof (prove)\nusing this:\n  exec_meth ci (compP2 P) (compE2 obj @ compEs2 ps)\n   (compxE2 obj 0 0 @\n    shift (length (compE2 obj))\n     (stack_xlift (length [v]) (compxEs2 ps 0 0)))\n   t h (stk @ [v], loc, length (compE2 obj) + pc, xcp) ta h'\n   (stk', loc', pc', xcp')\n\ngoal (1 subgoal):\n 1. length (compE2 obj) \\<le> pc'", "by(rule exec_meth_drop_xt_pc)(auto)"], ["proof (state)\nthis:\n  length (compE2 obj) \\<le> pc'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exec_move_length_compE2D [dest]:\n  \"exec_move ci P t e h (stk, loc, pc, xcp) ta h' s' \\<Longrightarrow> pc < length (compE2 e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t e h (stk, loc, pc, xcp) ta h' s' \\<Longrightarrow>\n    pc < length (compE2 e)", "by(cases s')(auto simp add: exec_move_def)"], ["", "lemma exec_moves_length_compEs2D [dest]:\n  \"exec_moves ci P t es h (stk, loc, pc, xcp) ta h' s' \\<Longrightarrow> pc < length (compEs2 es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_moves ci P t es h (stk, loc, pc, xcp) ta h' s' \\<Longrightarrow>\n    pc < length (compEs2 es)", "by(cases s')(auto simp add: exec_moves_def)"], ["", "lemma exec_meth_ci_appD:\n  \"\\<lbrakk> exec_meth ci P ins xt t h (stk, loc, pc, None) ta h' fr' \\<rbrakk>\n  \\<Longrightarrow>  ci_app ci (ins ! pc) P h stk loc undefined undefined pc []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci P ins xt t h (stk, loc, pc, None) ta h'\n     fr' \\<Longrightarrow>\n    ci_app ci (ins ! pc) P h stk loc undefined undefined pc []", "by(cases fr')(simp add: exec_meth_instr)"], ["", "lemma exec_move_ci_appD:\n  \"exec_move ci P t E h (stk, loc, pc, None) ta h' fr'\n  \\<Longrightarrow> ci_app ci (compE2 E ! pc) (compP2 P) h stk loc undefined undefined pc []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t E h (stk, loc, pc, None) ta h' fr' \\<Longrightarrow>\n    ci_app ci (compE2 E ! pc) (compP2 P) h stk loc undefined undefined pc []", "unfolding exec_move_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compE2 E) (compxE2 E 0 0) t h\n     (stk, loc, pc, None) ta h' fr' \\<Longrightarrow>\n    ci_app ci (compE2 E ! pc) (compP2 P) h stk loc undefined undefined pc []", "by(rule exec_meth_ci_appD)"], ["", "lemma exec_moves_ci_appD:\n  \"exec_moves ci P t Es h (stk, loc, pc, None) ta h' fr'\n  \\<Longrightarrow> ci_app ci (compEs2 Es ! pc) (compP2 P) h stk loc undefined undefined pc []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_moves ci P t Es h (stk, loc, pc, None) ta h' fr' \\<Longrightarrow>\n    ci_app ci (compEs2 Es ! pc) (compP2 P) h stk loc undefined undefined pc\n     []", "unfolding exec_moves_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_meth ci (compP2 P) (compEs2 Es) (compxEs2 Es 0 0) t h\n     (stk, loc, pc, None) ta h' fr' \\<Longrightarrow>\n    ci_app ci (compEs2 Es ! pc) (compP2 P) h stk loc undefined undefined pc\n     []", "by(rule exec_meth_ci_appD)"], ["", "lemma \\<tau>instr_stk_append_check:\n  \"check_instr' i P h stk loc C M pc frs \\<Longrightarrow> \\<tau>instr P h (stk @ vs) i = \\<tau>instr P h stk i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_instr' i P h stk loc C M pc frs \\<Longrightarrow>\n    \\<tau>instr P h (stk @ vs) i = \\<tau>instr P h stk i", "by(cases i)(simp_all add: nth_append)"], ["", "lemma \\<tau>instr_stk_drop_exec_move:\n  \"exec_move ci P t e h (stk, loc, pc, None) ta h' fr'\n  \\<Longrightarrow> \\<tau>instr (compP2 P) h (stk @ vs) (compE2 e ! pc) = \\<tau>instr (compP2 P) h stk (compE2 e ! pc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_move ci P t e h (stk, loc, pc, None) ta h' fr' \\<Longrightarrow>\n    \\<tau>instr (compP2 P) h (stk @ vs) (compE2 e ! pc) =\n    \\<tau>instr (compP2 P) h stk (compE2 e ! pc)", "apply(drule exec_move_ci_appD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ci_app ci (compE2 e ! pc) (compP2 P) h stk loc undefined undefined pc\n     [] \\<Longrightarrow>\n    \\<tau>instr (compP2 P) h (stk @ vs) (compE2 e ! pc) =\n    \\<tau>instr (compP2 P) h stk (compE2 e ! pc)", "apply(drule wf_ciD2_ci_app)"], ["proof (prove)\ngoal (1 subgoal):\n 1. check_instr' (compE2 e ! pc) (compP2 P) h stk loc undefined undefined pc\n     [] \\<Longrightarrow>\n    \\<tau>instr (compP2 P) h (stk @ vs) (compE2 e ! pc) =\n    \\<tau>instr (compP2 P) h stk (compE2 e ! pc)", "apply(erule \\<tau>instr_stk_append_check)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \\<tau>instr_stk_drop_exec_moves:\n  \"exec_moves ci P t es h (stk, loc, pc, None) ta h' fr'\n  \\<Longrightarrow> \\<tau>instr (compP2 P) h (stk @ vs) (compEs2 es ! pc) = \\<tau>instr (compP2 P) h stk (compEs2 es ! pc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_moves ci P t es h (stk, loc, pc, None) ta h' fr' \\<Longrightarrow>\n    \\<tau>instr (compP2 P) h (stk @ vs) (compEs2 es ! pc) =\n    \\<tau>instr (compP2 P) h stk (compEs2 es ! pc)", "apply(drule exec_moves_ci_appD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ci_app ci (compEs2 es ! pc) (compP2 P) h stk loc undefined undefined pc\n     [] \\<Longrightarrow>\n    \\<tau>instr (compP2 P) h (stk @ vs) (compEs2 es ! pc) =\n    \\<tau>instr (compP2 P) h stk (compEs2 es ! pc)", "apply(drule wf_ciD2_ci_app)"], ["proof (prove)\ngoal (1 subgoal):\n 1. check_instr' (compEs2 es ! pc) (compP2 P) h stk loc undefined undefined\n     pc [] \\<Longrightarrow>\n    \\<tau>instr (compP2 P) h (stk @ vs) (compEs2 es ! pc) =\n    \\<tau>instr (compP2 P) h stk (compEs2 es ! pc)", "apply(erule \\<tau>instr_stk_append_check)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"]]}