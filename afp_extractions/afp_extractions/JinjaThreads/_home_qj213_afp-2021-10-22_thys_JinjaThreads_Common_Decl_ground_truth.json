{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Common/Decl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma finite_is_class: \"finite {C. is_class P C}\"", "lemma is_type_ArrayD: \"is_type P (T\\<lfloor>\\<rceil>) \\<Longrightarrow> is_type P T\"", "lemma is_type_ground_type:\n  \"is_type P T \\<Longrightarrow> is_type P (ground_type T)\"", "lemma is_class_intros [code_pred_intro]:\n  \"class P C \\<noteq> None \\<Longrightarrow> is_class P C\""], "translations": [["", "lemma finite_is_class: \"finite {C. is_class P C}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {C. is_class P C}", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {C. is_class P C}", "apply(cases P)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. P = Program x \\<Longrightarrow> finite {C. is_class P C}", "apply (unfold is_class_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       P = Program x \\<Longrightarrow> finite {C. class P C \\<noteq> None}", "apply (fold dom_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. P = Program x \\<Longrightarrow> finite (dom (class P))", "apply(simp add: finite_dom_map_of)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "primrec is_type :: \"'m prog \\<Rightarrow> ty \\<Rightarrow> bool\"\nwhere\n  is_type_void:   \"is_type P Void = True\"\n| is_type_bool:   \"is_type P Boolean = True\"\n| is_type_int:    \"is_type P Integer = True\"\n| is_type_nt:     \"is_type P NT = True\"\n| is_type_class:  \"is_type P (Class C) = is_class P C\"\n| is_type_array:  \"is_type P (A\\<lfloor>\\<rceil>) = (case ground_type A of NT \\<Rightarrow> False | Class C \\<Rightarrow> is_class P C | _ \\<Rightarrow> True)\""], ["", "lemma is_type_ArrayD: \"is_type P (T\\<lfloor>\\<rceil>) \\<Longrightarrow> is_type P T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_type P (T\\<lfloor>\\<rceil>) \\<Longrightarrow> is_type P T", "by(induct T) auto"], ["", "lemma is_type_ground_type:\n  \"is_type P T \\<Longrightarrow> is_type P (ground_type T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_type P T \\<Longrightarrow> is_type P (ground_type T)", "by(induct T)(auto, metis is_type_ArrayD is_type_array)"], ["", "abbreviation \"types\" :: \"'m prog \\<Rightarrow> ty set\"\nwhere \"types P \\<equiv> {T. is_type P T}\""], ["", "abbreviation is_htype :: \"'m prog \\<Rightarrow> htype \\<Rightarrow> bool\"\nwhere \"is_htype P hT \\<equiv> is_type P (ty_of_htype hT)\""], ["", "subsection \\<open>Code generation\\<close>"], ["", "lemma is_class_intros [code_pred_intro]:\n  \"class P C \\<noteq> None \\<Longrightarrow> is_class P C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class P C \\<noteq> None \\<Longrightarrow> is_class P C", "by(auto simp add: is_class_def)"], ["", "code_pred \n  (modes: i \\<Rightarrow> i \\<Rightarrow> bool)\n  is_class"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_class x xa;\n     \\<And>P C.\n        \\<lbrakk>x = P; xa = C; class P C \\<noteq> None\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "unfolding is_class_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>class x xa \\<noteq> None;\n     \\<And>P C.\n        \\<lbrakk>x = P; xa = C; class P C \\<noteq> None\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by simp"], ["", "declare is_class_def[code]"], ["", "end"]]}